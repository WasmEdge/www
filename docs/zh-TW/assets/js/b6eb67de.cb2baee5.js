"use strict";(self.webpackChunkbook=self.webpackChunkbook||[]).push([[2974],{3905:(e,n,t)=>{t.d(n,{Zo:()=>d,kt:()=>c});var a=t(67294);function i(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function l(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function r(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?l(Object(t),!0).forEach((function(n){i(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):l(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function s(e,n){if(null==e)return{};var t,a,i=function(e,n){if(null==e)return{};var t,a,i={},l=Object.keys(e);for(a=0;a<l.length;a++)t=l[a],n.indexOf(t)>=0||(i[t]=e[t]);return i}(e,n);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(a=0;a<l.length;a++)t=l[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(i[t]=e[t])}return i}var o=a.createContext({}),u=function(e){var n=a.useContext(o),t=n;return e&&(t="function"==typeof e?e(n):r(r({},n),e)),t},d=function(e){var n=u(e.components);return a.createElement(o.Provider,{value:n},e.children)},m="mdxType",g={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},p=a.forwardRef((function(e,n){var t=e.components,i=e.mdxType,l=e.originalType,o=e.parentName,d=s(e,["components","mdxType","originalType","parentName"]),m=u(t),p=i,c=m["".concat(o,".").concat(p)]||m[p]||g[p]||l;return t?a.createElement(c,r(r({ref:n},d),{},{components:t})):a.createElement(c,r({ref:n},d))}));function c(e,n){var t=arguments,i=n&&n.mdxType;if("string"==typeof e||i){var l=t.length,r=new Array(l);r[0]=p;var s={};for(var o in n)hasOwnProperty.call(n,o)&&(s[o]=n[o]);s.originalType=e,s[m]="string"==typeof e?e:i,r[1]=s;for(var u=2;u<l;u++)r[u]=t[u];return a.createElement.apply(null,r)}return a.createElement.apply(null,t)}p.displayName="MDXCreateElement"},58294:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>o,contentTitle:()=>r,default:()=>g,frontMatter:()=>l,metadata:()=>s,toc:()=>u});var a=t(87462),i=(t(67294),t(3905));const l={sidebar_position:1},r=void 0,s={unversionedId:"embed/use-case/plugin/c_sdk",id:"embed/use-case/plugin/c_sdk",title:"c_sdk",description:"Using Plug-ins to Extend the Runtime in C",source:"@site/docs/embed/use-case/plugin/c_sdk.md",sourceDirName:"embed/use-case/plugin",slug:"/embed/use-case/plugin/c_sdk",permalink:"/docs/zh-TW/embed/use-case/plugin/c_sdk",draft:!1,editUrl:"https://github.com/wasmedge/docs/blob/main/docs/embed/use-case/plugin/c_sdk.md",tags:[],version:"current",sidebarPosition:1,frontMatter:{sidebar_position:1},sidebar:"embedSidebar",previous:{title:"Plugin-User Guide",permalink:"/docs/zh-TW/category/plugin-user-guide"},next:{title:"rust_sdk",permalink:"/docs/zh-TW/embed/use-case/plugin/rust_sdk"}},o={},u=[{value:"Using Plug-ins to Extend the Runtime in C",id:"using-plug-ins-to-extend-the-runtime-in-c",level:2},{value:"Loading Plug-ins from Paths",id:"loading-plug-ins-from-paths",level:2},{value:"Listing Loaded Plug-ins",id:"listing-loaded-plug-ins",level:2},{value:"Getting Plug-in Context by Name",id:"getting-plug-in-context-by-name",level:2},{value:"Creating Module Instances from Plug-ins",id:"creating-module-instances-from-plug-ins",level:2},{value:"Automatic Module Creation and Mocking",id:"automatic-module-creation-and-mocking",level:2},{value:"Handling Missing Plug-ins and Error Messages",id:"handling-missing-plug-ins-and-error-messages",level:2}],d={toc:u},m="wrapper";function g(e){let{components:n,...t}=e;return(0,i.kt)(m,(0,a.Z)({},d,t,{components:n,mdxType:"MDXLayout"}),(0,i.kt)("h2",{id:"using-plug-ins-to-extend-the-runtime-in-c"},"Using Plug-ins to Extend the Runtime in C"),(0,i.kt)("p",null,"The WasmEdge plug-ins are the shared libraries to provide the WasmEdge runtime to load and create host module instances. With the plug-ins, the WasmEdge runtime can be extended more easily."),(0,i.kt)("h2",{id:"loading-plug-ins-from-paths"},"Loading Plug-ins from Paths"),(0,i.kt)("p",null,"Developers can start using WasmEdge plug-ins by loading them from specific paths. To load plug-ins from the default paths, the following API can be used:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},"WasmEdge_PluginLoadWithDefaultPaths();\n")),(0,i.kt)("p",null,"Once this API is called, plug-ins from the default paths will be loaded. The default paths include:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"The path specified in the ",(0,i.kt)("inlineCode",{parentName:"li"},"WASMEDGE_PLUGIN_PATH")," environment variable."),(0,i.kt)("li",{parentName:"ul"},"The ",(0,i.kt)("inlineCode",{parentName:"li"},"../plugin/")," directory relative to the WasmEdge installation path."),(0,i.kt)("li",{parentName:"ul"},"The ",(0,i.kt)("inlineCode",{parentName:"li"},"./wasmedge/")," directory under the library path if WasmEdge is installed in a system directory (e.g., ",(0,i.kt)("inlineCode",{parentName:"li"},"/usr")," and ",(0,i.kt)("inlineCode",{parentName:"li"},"/usr/local"),").")),(0,i.kt)("p",null,"Developers can also load plug-ins from specific paths using this API:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},'WasmEdge_PluginLoadFromPath("PATH_TO_PLUGIN/plugin.so");\n')),(0,i.kt)("h2",{id:"listing-loaded-plug-ins"},"Listing Loaded Plug-ins"),(0,i.kt)("p",null,"Once plug-ins are loaded, developers can list the loaded plug-in names using the following approach:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},'WasmEdge_PluginLoadWithDefaultPaths();\nprintf("Number of loaded plug-ins: %d\\n", WasmEdge_PluginListPluginsLength());\n\nWasmEdge_String Names[20];\nuint32_t NumPlugins = WasmEdge_PluginListPlugins(Names, 20);\nfor (int I = 0; I < NumPlugins; I++) {\n  printf("Plug-in %d name: %s\\n", I, Names[I].Buf);\n}\n')),(0,i.kt)("h2",{id:"getting-plug-in-context-by-name"},"Getting Plug-in Context by Name"),(0,i.kt)("p",null,"Developers can obtain the plug-in context by its name using the following method:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},'/* Assume that wasi_crypto plug-in is installed in the default plug-in path. */\nWasmEdge_PluginLoadWithDefaultPaths();\n\nconst char PluginName[] = "wasi_crypto";\nWasmEdge_String NameString =\n    WasmEdge_StringWrap(PluginName, strlen(PluginName));\nconst WasmEdge_PluginContext *PluginCxt = WasmEdge_PluginFind(NameString);\n')),(0,i.kt)("h2",{id:"creating-module-instances-from-plug-ins"},"Creating Module Instances from Plug-ins"),(0,i.kt)("p",null,"With the plug-in context, developers can create module instances by providing the module name:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},'/* Assume that the `PluginCxt` is the context to the wasi_crypto plug-in. */\n\n/* List the available host modules in the plug-in. */\nWasmEdge_String Names[20];\nuint32_t ModuleLen = WasmEdge_PluginListModule(PluginCxt, Names, 20);\nfor (uint32_t I = 0; I < ModuleLen; I++) {\n  /* Will print the available host module names in the plug-in. */\n  printf("%s\\n", Names[I].Buf);\n}\n/* Will print here for the WASI-Crypto plug-in here:\n * wasi_ephemeral_crypto_asymmetric_common\n * wasi_ephemeral_crypto_common\n * wasi_ephemeral_crypto_kx\n * wasi_ephemeral_crypto_signatures\n * wasi_ephemeral_crypto_symmetric\n */\n\n/* Create a module instance from the plug-in by the module name. */\nconst char ModuleName[] = "wasi_ephemeral_crypto_common";\nWasmEdge_String NameString =\n    WasmEdge_StringWrap(ModuleName, strlen(ModuleName));\nWasmEdge_ModuleInstance *ModCxt =\n    WasmEdge_PluginCreateModule(PluginCxt, NameString);\n\nWasmEdge_ModuleInstanceDelete(ModCxt);\n')),(0,i.kt)("p",null,"There may be several plug-ins in the default plug-in paths if users ",(0,i.kt)("a",{parentName:"p",href:"/docs/zh-TW/contribute/installer#plugins"},"installed WasmEdge plug-ins by the installer"),"."),(0,i.kt)("p",null,"Before using the plug-ins, developers should ",(0,i.kt)("a",{parentName:"p",href:"#loading-plug-ins-from-paths"},"Loading Plug-ins from Paths"),"."),(0,i.kt)("h2",{id:"automatic-module-creation-and-mocking"},"Automatic Module Creation and Mocking"),(0,i.kt)("p",null,"Upon creating a ",(0,i.kt)("inlineCode",{parentName:"p"},"VM")," context, the WasmEdge runtime will automatically create and register the modules of loaded plug-ins. In cases where specific plug-ins are not loaded, WasmEdge will provide mock implementations for certain host modules. These mocked modules include:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"wasi_ephemeral_crypto_asymmetric_common")," (for the ",(0,i.kt)("inlineCode",{parentName:"li"},"WASI-Crypto"),")"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"wasi_ephemeral_crypto_common")," (for the ",(0,i.kt)("inlineCode",{parentName:"li"},"WASI-Crypto"),")"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"wasi_ephemeral_crypto_kx")," (for the ",(0,i.kt)("inlineCode",{parentName:"li"},"WASI-Crypto"),")"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"wasi_ephemeral_crypto_signatures")," (for the ",(0,i.kt)("inlineCode",{parentName:"li"},"WASI-Crypto"),")"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"wasi_ephemeral_crypto_symmetric")," (for the ",(0,i.kt)("inlineCode",{parentName:"li"},"WASI-Crypto"),")"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"wasi_ephemeral_nn")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"wasi_snapshot_preview1")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"wasmedge_httpsreq")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"wasmedge_process"))),(0,i.kt)("h2",{id:"handling-missing-plug-ins-and-error-messages"},"Handling Missing Plug-ins and Error Messages"),(0,i.kt)("p",null,"When the WASM want to invoke these host functions but the corresponding plug-in is not installed, WasmEdge will print the error message and return an error."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},'/* Load the plug-ins in the default paths first. */\nWasmEdge_PluginLoadWithDefaultPaths();\n/* Create the configure context and add the WASI configuration. */\nWasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();\nWasmEdge_ConfigureAddHostRegistration(ConfCxt,\n                                        WasmEdge_HostRegistration_Wasi);\nWasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(ConfCxt, NULL);\nWasmEdge_ConfigureDelete(ConfCxt);\n/* The following API can retrieve the registered modules in the VM context,\n* includes the built-in WASI and the plug-ins.\n*/\n/*\n* This API will return `NULL` if the module instance is not found.\n*/\nWasmEdge_String WasiName =\n    WasmEdge_StringCreateByCString("wasi_snapshot_preview1");\n/* The `WasiModule` will not be `NULL` because the configuration was set. */\nconst WasmEdge_ModuleInstanceContext *WasiModule =\n    WasmEdge_VMGetRegisteredModule(VMCxt, WasiName);\nWasmEdge_StringDelete(WasiName);\nWasmEdge_String WasiNNName =\n    WasmEdge_StringCreateByCString("wasi_ephemeral_nn");\n/* The `WasiNNModule` will not be `NULL` even if the wasi_nn plug-in is not\n* installed, because the VM context will mock and register the host\n* modules.\n*/\nconst WasmEdge_ModuleInstanceContext *WasiNNModule =\n    WasmEdge_VMGetRegisteredModule(VMCxt, WasiNNName);\nWasmEdge_StringDelete(WasiNNName);\n\nWasmEdge_VMDelete(VMCxt);\n')))}g.isMDXComponent=!0}}]);