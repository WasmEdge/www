"use strict";(self.webpackChunkbook=self.webpackChunkbook||[]).push([[4931],{3905:(e,t,n)=>{n.d(t,{Zo:()=>d,kt:()=>h});var r=n(67294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function s(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?s(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):s(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function i(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},s=Object.keys(e);for(r=0;r<s.length;r++)n=s[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(r=0;r<s.length;r++)n=s[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var p=r.createContext({}),l=function(e){var t=r.useContext(p),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},d=function(e){var t=l(e.components);return r.createElement(p.Provider,{value:t},e.children)},c="mdxType",m={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},u=r.forwardRef((function(e,t){var n=e.components,a=e.mdxType,s=e.originalType,p=e.parentName,d=i(e,["components","mdxType","originalType","parentName"]),c=l(n),u=a,h=c["".concat(p,".").concat(u)]||c[u]||m[u]||s;return n?r.createElement(h,o(o({ref:t},d),{},{components:n})):r.createElement(h,o({ref:t},d))}));function h(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var s=n.length,o=new Array(s);o[0]=u;var i={};for(var p in t)hasOwnProperty.call(t,p)&&(i[p]=t[p]);i.originalType=e,i[c]="string"==typeof e?e:a,o[1]=i;for(var l=2;l<s;l++)o[l]=n[l];return r.createElement.apply(null,o)}return r.createElement.apply(null,n)}u.displayName="MDXCreateElement"},98690:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>p,contentTitle:()=>o,default:()=>m,frontMatter:()=>s,metadata:()=>i,toc:()=>l});var r=n(87462),a=(n(67294),n(3905));const s={sidebar_position:12},o="Server-side rendering",i={unversionedId:"develop/rust/ssr",id:"develop/rust/ssr",title:"Server-side rendering",description:"Frontend web frameworks allow developers to create web apps in a high-level language and component model. The web app is built into a static website to be rendered in the browser. While many frontend web frameworks are based on JavaScript, such as React and Vue, Rust-based frameworks are also emerging as the Rust language gains traction among developers. Those web frameworks render the HTML DOM UI using the WebAssembly, compiled from Rust source code. They use wasm-bindgen to tie the Rust to the HTML DOM. While these frameworks send .wasm files to the browser to render the UI on the client side, some provide the additional choice for Server-side rendering. That is to run the WebAssembly code, build the HTML DOM UI on the server, and stream the HTML content to the browser for faster performance and startup time on slow devices and networks.",source:"@site/docs/develop/rust/ssr.md",sourceDirName:"develop/rust",slug:"/develop/rust/ssr",permalink:"/docs/zh-TW/develop/rust/ssr",draft:!1,editUrl:"https://github.com/wasmedge/docs/blob/main/docs/develop/rust/ssr.md",tags:[],version:"current",sidebarPosition:12,frontMatter:{sidebar_position:12},sidebar:"developSidebar",previous:{title:"Command interface",permalink:"/docs/zh-TW/develop/rust/command"},next:{title:"Develop WASM Apps in JavaScript",permalink:"/docs/zh-TW/category/develop-wasm-apps-in-javascript"}},p={},l=[],d={toc:l},c="wrapper";function m(e){let{components:t,...n}=e;return(0,a.kt)(c,(0,r.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"server-side-rendering"},"Server-side rendering"),(0,a.kt)("p",null,"Frontend web frameworks allow developers to create web apps in a high-level language and component model. The web app is built into a static website to be rendered in the browser. While many frontend web frameworks are based on JavaScript, such as React and Vue, Rust-based frameworks are also emerging as the Rust language gains traction among developers. Those web frameworks render the HTML DOM UI using the WebAssembly, compiled from Rust source code. They use ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/rustwasm/wasm-bindgen"},"wasm-bindgen")," to tie the Rust to the HTML DOM. While these frameworks send ",(0,a.kt)("inlineCode",{parentName:"p"},".wasm")," files to the browser to render the UI on the client side, some provide the additional choice for ",(0,a.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Server-side_scripting"},"Server-side rendering"),". That is to run the WebAssembly code, build the HTML DOM UI on the server, and stream the HTML content to the browser for faster performance and startup time on slow devices and networks."),(0,a.kt)("admonition",{type:"note"},(0,a.kt)("p",{parentName:"admonition"},"If you are interested in JavaScript-based Jamstack and SSR frameworks, such as React, please ",(0,a.kt)("a",{parentName:"p",href:"/docs/zh-TW/develop/javascript/ssr"},"check out our JavaScript SSR chapter"),".")),(0,a.kt)("p",null,"This article will explore how to render the web UI on the server using WasmEdge. We pick ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/chinedufn/percy"},"Percy")," as our framework because it is relatively mature in SSR and ",(0,a.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Hydration_(web_development)"},"Hydration"),". Percy already provides an ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/chinedufn/percy/tree/master/examples/isomorphic"},"example")," for SSR. It's highly recommended to read it first to understand how it works. The default SSR setup with Percy utilizes a native Rust web server. The Rust code is compiled to machine native code for the server. However, we need a sandbox to host user applications on the server. While we could run native code inside a Linux container (Docker), a far more efficient (and safer) approach is to run the compiled code in a WebAssembly VM on the server, especially considering the rendering code is already compiled into WebAssembly."),(0,a.kt)("p",null,"Let's go through the steps to run a Percy SSR service in a WasmEdge server."),(0,a.kt)("p",null,"Assuming we are in the ",(0,a.kt)("inlineCode",{parentName:"p"},"examples/isomorphic")," directory, make a new crate beside the existing ",(0,a.kt)("inlineCode",{parentName:"p"},"server"),"."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-bash"},"cargo new server-wasmedge\n")),(0,a.kt)("p",null,"You'll receive a warning to let you put the new crate into the workspace, so insert below into ",(0,a.kt)("inlineCode",{parentName:"p"},"members")," of ",(0,a.kt)("inlineCode",{parentName:"p"},"[workspace]"),". The file is ",(0,a.kt)("inlineCode",{parentName:"p"},"../../Cargo.toml"),"."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-toml"},'"examples/isomorphic/server-wasmedge"\n')),(0,a.kt)("p",null,"With the file open, put these two lines in the bottom:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-toml"},'[patch.crates-io]\nwasm-bindgen = { git = "https://github.com/KernelErr/wasm-bindgen.git", branch = "wasi-compat" }\n')),(0,a.kt)("admonition",{type:"note"},(0,a.kt)("p",{parentName:"admonition"},"Why do we need a forked ",(0,a.kt)("inlineCode",{parentName:"p"},"wasm-bindgen"),"? That is because ",(0,a.kt)("inlineCode",{parentName:"p"},"wasm-bindgen")," is the required glue between Rust and HTML in the browser. On the server, however, we need to build the Rust code to the ",(0,a.kt)("inlineCode",{parentName:"p"},"wasm32-wasi")," target, which is incompatible with ",(0,a.kt)("inlineCode",{parentName:"p"},"wasm-bindgen"),". Our forked ",(0,a.kt)("inlineCode",{parentName:"p"},"wasm-bindgen")," has conditional configs that remove browser-specific code in the generated ",(0,a.kt)("inlineCode",{parentName:"p"},".wasm")," file for the ",(0,a.kt)("inlineCode",{parentName:"p"},"wasm32-wasi")," target.")),(0,a.kt)("p",null,"Then replace the crate's ",(0,a.kt)("inlineCode",{parentName:"p"},"Cargo.toml")," with the following content."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-toml"},'[package]\nname = "isomorphic-server-wasmedge"\nversion = "0.1.0"\nedition = "2021"\n\n# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\n\n[dependencies]\nwasmedge_wasi_socket = "0"\nquerystring = "1.1.0"\nparsed = { version = "0.3", features = ["http"] }\nanyhow = "1"\nserde = { version = "1.0", features = ["derive"] }\nisomorphic-app = { path = "../app" }\n')),(0,a.kt)("p",null,"The ",(0,a.kt)("inlineCode",{parentName:"p"},"wasmedge_wasi_socket")," crate is the socket API of WasmEdge. This project is under development. Next, copy the ",(0,a.kt)("inlineCode",{parentName:"p"},"index.html")," file into the crate's root."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-bash"},"cp server/src/index.html server-wasmedge/src/\n")),(0,a.kt)("p",null,"Then let's create some Rust code to start a web service in WasmEdge! The ",(0,a.kt)("inlineCode",{parentName:"p"},"main.rs")," program listens to the request and sends the response via the stream."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust"},'use std::io::Write;\nuse wasmedge_wasi_socket::{Shutdown, TcpListener};\n\nmod handler;\nmod mime;\nmod response;\n\nfn main() {\n    let server = TcpListener::bind("127.0.0.1:3000", false).unwrap();\n    println!("Server listening on 127.0.0.1:3000");\n\n    // Simple single-thread HTTP server\n    // For server with Pool support, see https://github.com/second-state/wasmedge_wasi_socket/tree/main/examples/poll_http_server\n    loop {\n        let (mut stream, addr) = server.accept(0).unwrap();\n        println!("Accepted connection from {}", addr);\n        match handler::handle_req(&mut stream, addr) {\n            Ok((res, binary)) => {\n                let res: String = res.into();\n                let bytes = res.as_bytes();\n                stream.write_all(bytes).unwrap();\n                if let Some(binary) = binary {\n                    stream.write_all(&binary).unwrap();\n                }\n            }\n            Err(e) => {\n                println!("Error: {:?}", e);\n            }\n        };\n        stream.shutdown(Shutdown::Both).unwrap();\n    }\n}\n')),(0,a.kt)("p",null,"The ",(0,a.kt)("inlineCode",{parentName:"p"},"handler.rs")," parses the received data to the path and queries objects and returns the corresponding response."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust"},'use crate::response;\nuse anyhow::Result;\nuse parsed::http::Response;\nuse std::io::Read;\nuse wasmedge_wasi_socket::{SocketAddr, TcpStream};\n\npub fn handle_req(stream: &mut TcpStream, addr: SocketAddr) -> Result<(Response, Option<Vec<u8>>)> {\n    let mut buf = [0u8; 1024];\n    let mut received_data: Vec<u8> = Vec::new();\n\n    loop {\n        let n = stream.read(&mut buf)?;\n        received_data.extend_from_slice(&buf[..n]);\n        if n < 1024 {\n            break;\n        }\n    }\n\n    let mut bs: parsed::stream::ByteStream = match String::from_utf8(received_data) {\n        Ok(s) => s.into(),\n        Err(_) => return Ok((response::bad_request(), None)),\n    };\n\n    let req = match parsed::http::parse_http_request(&mut bs) {\n        Some(req) => req,\n        None => return Ok((response::bad_request(), None)),\n    };\n\n    println!("{:?} request: {:?} {:?}", addr, req.method, req.path);\n\n    let mut path_split = req.path.split("?");\n    let path = path_split.next().unwrap_or("/");\n    let query_str = path_split.next().unwrap_or("");\n    let query = querystring::querify(&query_str);\n    let mut init_count: Option<u32> = None;\n    for (k, v) in query {\n        if k.eq("init") {\n            match v.parse::<u32>() {\n                Ok(v) => init_count = Some(v),\n                Err(_) => return Ok((response::bad_request(), None)),\n            }\n        }\n    }\n\n    let (res, binary) = if path.starts_with("/static") {\n        response::file(&path)\n    } else {\n        // render page\n        response::ssr(&path, init_count)\n    }\n    .unwrap_or_else(|_| response::internal_error());\n\n    Ok((res, binary))\n}\n')),(0,a.kt)("p",null,"The ",(0,a.kt)("inlineCode",{parentName:"p"},"response.rs")," program packs the response object for static assets and server-rendered content. For the latter, you could see that SSR happens at ",(0,a.kt)("inlineCode",{parentName:"p"},"app.render().to_string()"),", the result string is put into HTML by replacing the placeholder text."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust"},'use crate::mime::MimeType;\nuse anyhow::Result;\nuse parsed::http::{Header, Response};\nuse std::fs::{read};\nuse std::path::Path;\nuse isomorphic_app::App;\n\nconst HTML_PLACEHOLDER: &str = "#HTML_INSERTED_HERE_BY_SERVER#";\nconst STATE_PLACEHOLDER: &str = "#INITIAL_STATE_JSON#";\n\npub fn ssr(path: &str, init: Option<u32>) -> Result<(Response, Option<Vec<u8>>)> {\n    let html = format!("{}", include_str!("./index.html"));\n\n    let app = App::new(init.unwrap_or(1001), path.to_string());\n    let state = app.store.borrow();\n\n    let html = html.replace(HTML_PLACEHOLDER, &app.render().to_string());\n    let html = html.replace(STATE_PLACEHOLDER, &state.to_json());\n\n    Ok((Response {\n        protocol: "HTTP/1.0".to_string(),\n        code: 200,\n        message: "OK".to_string(),\n        headers: vec![\n            Header {\n                name: "content-type".to_string(),\n                value: MimeType::from_ext("html").get(),\n            },\n            Header {\n                name: "content-length".to_string(),\n                value: html.len().to_string(),\n            },\n        ],\n        content: html.into_bytes(),\n    }, None))\n}\n\n/// Get raw file content\npub fn file(path: &str) -> Result<(Response, Option<Vec<u8>>)> {\n    let path = Path::new(&path);\n    if path.exists() {\n        let content_type: MimeType = match path.extension() {\n            Some(ext) => MimeType::from_ext(ext.to_str().get_or_insert("")),\n            None => MimeType::from_ext(""),\n        };\n        let content = read(path)?;\n\n        Ok((Response {\n            protocol: "HTTP/1.0".to_string(),\n            code: 200,\n            message: "OK".to_string(),\n            headers: vec![\n                Header {\n                    name: "content-type".to_string(),\n                    value: content_type.get(),\n                },\n                Header {\n                    name: "content-length".to_string(),\n                    value: content.len().to_string(),\n                },\n            ],\n            content: vec![],\n        }, Some(content)))\n    } else {\n        Ok((Response {\n            protocol: "HTTP/1.0".to_string(),\n            code: 404,\n            message: "Not Found".to_string(),\n            headers: vec![],\n            content: vec![],\n        }, None))\n    }\n}\n\n/// Bad Request\npub fn bad_request() -> Response {\n    Response {\n        protocol: "HTTP/1.0".to_string(),\n        code: 400,\n        message: "Bad Request".to_string(),\n        headers: vec![],\n        content: vec![],\n    }\n}\n\n/// Internal Server Error\npub fn internal_error() -> (Response, Option<Vec<u8>>) {\n    (Response {\n        protocol: "HTTP/1.0".to_owned(),\n        code: 500,\n        message: "Internal Server Error".to_owned(),\n        headers: vec![],\n        content: vec![],\n    }, None)\n}\n')),(0,a.kt)("p",null,"The ",(0,a.kt)("inlineCode",{parentName:"p"},"mime.rs")," program is a map for assets' extension names and the Mime type."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust"},'pub struct MimeType {\n    pub r#type: String,\n}\n\nimpl MimeType {\n    pub fn new(r#type: &str) -> Self {\n        MimeType {\n            r#type: r#type.to_string(),\n        }\n    }\n\n    pub fn from_ext(ext: &str) -> Self {\n        match ext {\n            "html" => MimeType::new("text/html"),\n            "css" => MimeType::new("text/css"),\n            "map" => MimeType::new("application/json"),\n            "js" => MimeType::new("application/javascript"),\n            "json" => MimeType::new("application/json"),\n            "svg" => MimeType::new("image/svg+xml"),\n            "wasm" => MimeType::new("application/wasm"),\n            _ => MimeType::new("text/plain"),\n        }\n    }\n\n    pub fn get(self) -> String {\n        self.r#type\n    }\n}\n')),(0,a.kt)("p",null,"That's it! Now let's build and run the web application. If you have tested the original example, you have already built the client WebAssembly."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-bash"},"cd client\n./build-wasm.sh\n")),(0,a.kt)("p",null,"Next, build and run the server."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-bash"},'cd ../server-wasmedge\ncargo build --target wasm32-wasi\nOUTPUT_CSS="$(pwd)/../client/build/app.css" wasmedge --dir /static:../client/build ../../../target/wasm32-wasi/debug/isomorphic-server-wasmedge.wasm\n')),(0,a.kt)("p",null,"Navigate to ",(0,a.kt)("inlineCode",{parentName:"p"},"http://127.0.0.1:3000"),", and you will see the web application in action."),(0,a.kt)("p",null,"Furthermore, you can place all the steps into a shell script ",(0,a.kt)("inlineCode",{parentName:"p"},"../start-wasmedge.sh"),"."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-bash"},'#!/bin/bash\n\ncd $(dirname $0)\n\ncd ./client\n\n./build-wasm.sh\n\ncd ../server-wasmedge\n\nOUTPUT_CSS="$(pwd)/../client/build/app.css" cargo run -p isomorphic-server-wasmedge\n')),(0,a.kt)("p",null,"Add the following to the ",(0,a.kt)("inlineCode",{parentName:"p"},".cargo/config.toml")," file."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-toml"},'[build]\ntarget = "wasm32-wasi"\n\n[target.wasm32-wasi]\nrunner = "wasmedge --dir /static:../client/build"\n')),(0,a.kt)("p",null,"After that, a single CLI command ",(0,a.kt)("inlineCode",{parentName:"p"},"./start-wasmedge.sh")," would perform all the tasks to build and run the web application!"),(0,a.kt)("p",null,"We forked the Percy repository and made a ready-to-build ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/second-state/percy/tree/master/examples/isomorphic/server-wasmedge"},"server-wasmedge")," example project for you. Happy coding!"))}m.isMDXComponent=!0}}]);