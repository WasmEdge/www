"use strict";(self.webpackChunkbook=self.webpackChunkbook||[]).push([[5976],{3905:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>d});var a=n(67294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function s(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?s(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):s(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function i(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},s=Object.keys(e);for(a=0;a<s.length;a++)n=s[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(a=0;a<s.length;a++)n=s[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var l=a.createContext({}),p=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},c=function(e){var t=p(e.components);return a.createElement(l.Provider,{value:t},e.children)},m="mdxType",h={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},u=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,s=e.originalType,l=e.parentName,c=i(e,["components","mdxType","originalType","parentName"]),m=p(n),u=r,d=m["".concat(l,".").concat(u)]||m[u]||h[u]||s;return n?a.createElement(d,o(o({ref:t},c),{},{components:n})):a.createElement(d,o({ref:t},c))}));function d(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var s=n.length,o=new Array(s);o[0]=u;var i={};for(var l in t)hasOwnProperty.call(t,l)&&(i[l]=t[l]);i.originalType=e,i[m]="string"==typeof e?e:r,o[1]=i;for(var p=2;p<s;p++)o[p]=n[p];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}u.displayName="MDXCreateElement"},31372:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>h,frontMatter:()=>s,metadata:()=>i,toc:()=>p});var a=n(87462),r=(n(67294),n(3905));const s={sidebar_position:1},o="HTTP client",i={unversionedId:"develop/rust/http_service/client",id:"develop/rust/http_service/client",title:"HTTP client",description:"WasmEdge allows Rust developers to use APIs they are already familiar with to access the Internet via the HTTP or HTTPS protocols. This chapter will cover HTTP client APIs and libraries to access external web services from your WasmEdge app. For HTTP servers in WasmEdge, please see the next chapter.",source:"@site/docs/develop/rust/http_service/client.md",sourceDirName:"develop/rust/http_service",slug:"/develop/rust/http_service/client",permalink:"/docs/zh-TW/develop/rust/http_service/client",draft:!1,editUrl:"https://github.com/wasmedge/docs/blob/main/docs/develop/rust/http_service/client.md",tags:[],version:"current",sidebarPosition:1,frontMatter:{sidebar_position:1},sidebar:"developSidebar",previous:{title:"HTTP services",permalink:"/docs/zh-TW/category/http-services"},next:{title:"Server",permalink:"/docs/zh-TW/develop/rust/http_service/server"}},l={},p=[{value:"The reqwest API",id:"the-reqwest-api",level:2},{value:"The hyper API",id:"the-hyper-api",level:2}],c={toc:p},m="wrapper";function h(e){let{components:t,...n}=e;return(0,r.kt)(m,(0,a.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"http-client"},"HTTP client"),(0,r.kt)("p",null,"WasmEdge allows Rust developers to use APIs they are already familiar with to access the Internet via the HTTP or HTTPS protocols. This chapter will cover HTTP client APIs and libraries to access external web services from your WasmEdge app. For HTTP servers in WasmEdge, please see ",(0,r.kt)("a",{parentName:"p",href:"server"},"the next chapter"),"."),(0,r.kt)("admonition",{type:"note"},(0,r.kt)("p",{parentName:"admonition"},"Before we start, ensure ",(0,r.kt)("a",{parentName:"p",href:"/docs/zh-TW/develop/rust/setup"},"you have Rust and WasmEdge installed"),".")),(0,r.kt)("p",null,"We will discuss HTTP and HTTPS clients using popular Rust APIs."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#the-reqwest-api"},"The reqwest API")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#the-hyper-api"},"The hyper API"))),(0,r.kt)("h2",{id:"the-reqwest-api"},"The reqwest API"),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"reqwest")," crate is a popular Rust library to create asynchronous HTTP clients. It is built on top of the ",(0,r.kt)("inlineCode",{parentName:"p"},"hyper")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"tokio")," APIs. Many developers find it easier to use. But perhaps more importantly, many existing Rust applications use ",(0,r.kt)("inlineCode",{parentName:"p"},"reqwest"),", and you can make them work in WasmEdge by simply patching the ",(0,r.kt)("inlineCode",{parentName:"p"},"reqwest")," crate in ",(0,r.kt)("inlineCode",{parentName:"p"},"Cargo.toml")," with simple patches! Build and run ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/WasmEdge/wasmedge_reqwest_demo/"},"the example")," in WasmEdge as follows."),(0,r.kt)("admonition",{type:"note"},(0,r.kt)("p",{parentName:"admonition"},"Non-blocking I/O means that the application program can keep multiple connections open simultaneously, and process data in and out of those connections as they come in. The program can either alternatingly poll those open connections or wait for incoming data to trigger async functions. That allows I/O intensive programs to run much faster, even in a single-threaded environment.")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},'git clone https://github.com/WasmEdge/wasmedge_reqwest_demo\ncd wasmedge_reqwest_demo\n\n# Build the Rust code\nRUSTFLAGS="--cfg wasmedge --cfg tokio_unstable" cargo build --target wasm32-wasi --release\n# Use the AoT compiler to get better performance\nwasmedge compile target/wasm32-wasi/release/http.wasm http.wasm\nwasmedge compile target/wasm32-wasi/release/https.wasm https.wasm\n\n# Run the HTTP GET and POST examples\nwasmedge http.wasm\n\n# Run the HTTPS GET and POST examples\nwasmedge https.wasm\n')),(0,r.kt)("p",null,"In your Rust application, import the standard ",(0,r.kt)("a",{parentName:"p",href:"https://crates.io/crates/reqwest"},"reqwest")," and ",(0,r.kt)("a",{parentName:"p",href:"https://crates.io/crates/tokio"},"tokio")," crates. You will also patch a few dependency crates to make them aware of the WasmEdge socket API. Just add the following lines to your ",(0,r.kt)("inlineCode",{parentName:"p"},"Cargo.toml"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-toml"},'[patch.crates-io]\ntokio = { git = "https://github.com/second-state/wasi_tokio.git", branch = "v1.36.x" }\nsocket2 = { git = "https://github.com/second-state/socket2.git", branch = "v0.5.x" }\nhyper = { git = "https://github.com/second-state/wasi_hyper.git", branch = "v0.14.x" }\nreqwest = { git = "https://github.com/second-state/wasi_reqwest.git", branch = "0.11.x" }\n\n[dependencies]\nreqwest = { version = "0.11", default-features = false, features = ["rustls-tls"] }\ntokio = { version = "1", features = ["rt", "macros", "net", "time"] }\n')),(0,r.kt)("admonition",{type:"note"},(0,r.kt)("p",{parentName:"admonition"},"The ",(0,r.kt)("inlineCode",{parentName:"p"},"Cargo.toml")," here shows that TLS is enabled. If you need to compile it on the MacOS, you will need the ",(0,r.kt)("a",{parentName:"p",href:"../setup#compile-rust-tls-on-macos"},"wasi-sdk version of clang"),".")),(0,r.kt)("p",null,"The ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/WasmEdge/wasmedge_reqwest_demo/blob/main/src/http.rs"},"example Rust code")," below shows an HTTP GET request."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},'use std::collections::HashMap;\n\n#[tokio::main]\nasync fn main() -> Result<(), Box<dyn std::error::Error>> {\n    let resp = reqwest::get("http://eu.httpbin.org/ip")\n        .await?\n        .json::<HashMap<String, String>>()\n        .await?;\n    println!("{:#?}", resp);\n    Ok(())\n}\n')),(0,r.kt)("p",null,"And here is an HTTP POST request."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},'    let client = reqwest::Client::new();\n\n    let res = client\n        .post("http://eu.httpbin.org/post")\n        .body("msg=WasmEdge")\n        .send()\n        .await?;\n    let body = res.text().await?;\n\n    println!("POST: {}", body);\n')),(0,r.kt)("h2",{id:"the-hyper-api"},"The hyper API"),(0,r.kt)("p",null,"The ",(0,r.kt)("a",{parentName:"p",href:"https://crates.io/crates/hyper"},"hyper crate")," is a widely used Rust library to create HTTP and HTTPS networking applications for both clients and servers. A key feature of the ",(0,r.kt)("inlineCode",{parentName:"p"},"hyper")," crate is that it is based on the ",(0,r.kt)("inlineCode",{parentName:"p"},"tokio")," runtime, which supports asynchronous network connections. Asynchronous HTTP or HTTPS requests do not block the execution of the calling application. It allows an application to make multiple concurrent HTTP requests and to process responses as they are received. That enables high-performance networking applications in WasmEdge. Build and run ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/WasmEdge/wasmedge_hyper_demo/"},"the hyper example")," in WasmEdge as follows."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},'git clone https://github.com/WasmEdge/wasmedge_hyper_demo\ncd wasmedge_hyper_demo/client\n\n# Build the Rust code\nRUSTFLAGS="--cfg wasmedge --cfg tokio_unstable" cargo build --target wasm32-wasi --release\n# Use the AoT compiler to get better performance\nwasmedge compile target/wasm32-wasi/release/wasmedge_hyper_client.wasm wasmedge_hyper_client.wasm\n\n# Run the example\nwasmedge wasmedge_hyper_client.wasm\n')),(0,r.kt)("p",null,"In your Rust application, import the ",(0,r.kt)("a",{parentName:"p",href:"https://crates.io/crates/hyper"},"hyper")," crate,\nand patch it with WasmEdge sockets patches.\nJust add the following line to your ",(0,r.kt)("inlineCode",{parentName:"p"},"Cargo.toml"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-toml"},'[patch.crates-io]\ntokio = { git = "https://github.com/second-state/wasi_tokio.git", branch = "v1.36.x" }\nsocket2 = { git = "https://github.com/second-state/socket2.git", branch = "v0.5.x" }\nhyper = { git = "https://github.com/second-state/wasi_hyper.git", branch = "v0.14.x" }\n\n[dependencies]\nhyper = { version = "0.14", features = ["full"] }\ntokio = { version = "1", features = [ "rt", "macros", "net", "time", "io-util" ] }\n')),(0,r.kt)("p",null,"The HTTPS version of the demo is as follows."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},'// Build\ncd wasmedge_hyper_demo/client-https\nRUSTFLAGS="--cfg wasmedge --cfg tokio_unstable" cargo build --target wasm32-wasi --release\nwasmedge compile target/wasm32-wasi/release/wasmedge_hyper_client_https.wasm wasmedge_hyper_client_https.wasm\n\n// Run\nwasmedge wasmedge_hyper_client_https.wasm\n')),(0,r.kt)("p",null,"In the HTTPS version of ",(0,r.kt)("inlineCode",{parentName:"p"},"Cargo.toml"),", you just need to import the standard ",(0,r.kt)("a",{parentName:"p",href:"https://crates.io/crates/hyper-rustls"},"hyper-rustls"),", ",(0,r.kt)("a",{parentName:"p",href:"https://crates.io/crates/rustls"},"rustls")," and ",(0,r.kt)("a",{parentName:"p",href:"https://crates.io/crates/webpki-roots"},"webpki-roots")," crates with the same patches as above."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'[patch.crates-io]\ntokio = { git = "https://github.com/second-state/wasi_tokio.git", branch = "v1.36.x" }\nsocket2 = { git = "https://github.com/second-state/socket2.git", branch = "v0.5.x" }\nhyper = { git = "https://github.com/second-state/wasi_hyper.git", branch = "v0.14.x" }\n\n[dependencies]\nhyper = { version = "0.14", features = ["full"]}\nhyper-rustls = { version = "0.25", default-features = false, features = [ "http1", "tls12", "logging", "ring", "webpki-tokio" ] }\nrustls = { version = "0.22", default-features = false }\nwebpki-roots = "0.26.1"\n\ntokio = { version = "1", features = ["rt", "macros", "net", "time", "io-util"]}\npretty_env_logger = "0.4.0"\n')),(0,r.kt)("admonition",{type:"note"},(0,r.kt)("p",{parentName:"admonition"},"If you need to compile ",(0,r.kt)("inlineCode",{parentName:"p"},"rustls")," as shown in the ",(0,r.kt)("inlineCode",{parentName:"p"},"Cargo.toml")," above on the MacOS, you will need the ",(0,r.kt)("a",{parentName:"p",href:"../setup#compile-rust-tls-on-macos"},"wasi-sdk version of clang"),".")),(0,r.kt)("p",null,"The ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/WasmEdge/wasmedge_hyper_demo/blob/main/client/src/main.rs"},"Rust example code")," below shows an HTTP GET request."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},'async fn fetch_url_return_str (url: hyper::Uri) -> Result<()> {\n    let client = Client::new();\n    let mut res = client.get(url).await?;\n\n    let mut resp_data = Vec::new();\n    while let Some(next) = res.data().await {\n        let chunk = next?;\n        resp_data.extend_from_slice(&chunk);\n    }\n    println!("{}", String::from_utf8_lossy(&resp_data));\n')),(0,r.kt)("p",null,"The ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/WasmEdge/wasmedge_hyper_demo/blob/main/client-https/src/main.rs"},"HTTPS example")," is slightly more complex."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},'async fn fetch_https_url(url: hyper::Uri) -> Result<()> {\n    let https = wasmedge_hyper_rustls::connector::new_https_connector(\n        wasmedge_rustls_api::ClientConfig::default(),\n    );\n    let client = Client::builder().build::<_, hyper::Body>(https);\n    let res = client.get(url).await?;\n\n    let body = hyper::body::to_bytes(res.into_body()).await.unwrap();\n    println!("{}", String::from_utf8(body.into()).unwrap());\n    Ok(())\n}\n')),(0,r.kt)("p",null,"And here is an HTTP POST request."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},'async fn post_url_return_str (url: hyper::Uri, post_body: &\'static [u8]) -> Result<()> {\n    let client = Client::new();\n    let req = Request::builder()\n        .method(Method::POST)\n        .uri(url)\n        .body(Body::from(post_body))?;\n    let mut res = client.request(req).await?;\n\n    let mut resp_data = Vec::new();\n    while let Some(next) = res.data().await {\n        let chunk = next?;\n        resp_data.extend_from_slice(&chunk);\n    }\n    println!("{}", String::from_utf8_lossy(&resp_data));\n\n    Ok(())\n}\n')))}h.isMDXComponent=!0}}]);