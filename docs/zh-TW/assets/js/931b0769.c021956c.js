"use strict";(self.webpackChunkbook=self.webpackChunkbook||[]).push([[1881],{3905:(e,t,n)=>{n.d(t,{Zo:()=>u,kt:()=>h});var s=n(67294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);t&&(s=s.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,s)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function i(e,t){if(null==e)return{};var n,s,a=function(e,t){if(null==e)return{};var n,s,a={},o=Object.keys(e);for(s=0;s<o.length;s++)n=o[s],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(s=0;s<o.length;s++)n=o[s],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var p=s.createContext({}),d=function(e){var t=s.useContext(p),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},u=function(e){var t=d(e.components);return s.createElement(p.Provider,{value:t},e.children)},c="mdxType",l={inlineCode:"code",wrapper:function(e){var t=e.children;return s.createElement(s.Fragment,{},t)}},m=s.forwardRef((function(e,t){var n=e.components,a=e.mdxType,o=e.originalType,p=e.parentName,u=i(e,["components","mdxType","originalType","parentName"]),c=d(n),m=a,h=c["".concat(p,".").concat(m)]||c[m]||l[m]||o;return n?s.createElement(h,r(r({ref:t},u),{},{components:n})):s.createElement(h,r({ref:t},u))}));function h(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var o=n.length,r=new Array(o);r[0]=m;var i={};for(var p in t)hasOwnProperty.call(t,p)&&(i[p]=t[p]);i.originalType=e,i[c]="string"==typeof e?e:a,r[1]=i;for(var d=2;d<o;d++)r[d]=n[d];return s.createElement.apply(null,r)}return s.createElement.apply(null,n)}m.displayName="MDXCreateElement"},64487:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>p,contentTitle:()=>r,default:()=>l,frontMatter:()=>o,metadata:()=>i,toc:()=>d});var s=n(87462),a=(n(67294),n(3905));const o={sidebar_position:5},r="Node.js support",i={unversionedId:"develop/javascript/nodejs",id:"develop/javascript/nodejs",title:"Node.js support",description:"Many existing JavaScript apps use Node.js built-in APIs. To support and reuse these JavaScript apps, we are implementing many Node.JS APIs for WasmEdge QuickJS. The goal is to have unmodified Node.js programs running in WasmEdge QuickJS.",source:"@site/docs/develop/javascript/nodejs.md",sourceDirName:"develop/javascript",slug:"/develop/javascript/nodejs",permalink:"/docs/zh-TW/develop/javascript/nodejs",draft:!1,editUrl:"https://github.com/wasmedge/docs/blob/main/docs/develop/javascript/nodejs.md",tags:[],version:"current",sidebarPosition:5,frontMatter:{sidebar_position:5},sidebar:"developSidebar",previous:{title:"AI inference",permalink:"/docs/zh-TW/develop/javascript/tensorflow"},next:{title:"ES6 Modules",permalink:"/docs/zh-TW/develop/javascript/es6"}},p={},d=[{value:"The JavaScript modules",id:"the-javascript-modules",level:2},{value:"The Rust internal modules",id:"the-rust-internal-modules",level:2}],u={toc:d},c="wrapper";function l(e){let{components:t,...n}=e;return(0,a.kt)(c,(0,s.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"nodejs-support"},"Node.js support"),(0,a.kt)("p",null,"Many existing JavaScript apps use Node.js built-in APIs. To support and reuse these JavaScript apps, we are implementing many Node.JS APIs for WasmEdge QuickJS. The goal is to have unmodified Node.js programs running in WasmEdge QuickJS."),(0,a.kt)("p",null,"To use Node.js APIs in WasmEdge, you must make the ",(0,a.kt)("inlineCode",{parentName:"p"},"modules")," directory from ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/second-state/wasmedge-quickjs"},"wasmedge-quickjs")," accessible to the WasmEdge Runtime. The most straightforward approach is to clone the ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/second-state/wasmedge-quickjs"},"wasmedge-quickjs")," repo and run the Node.js app from the repo's top directory."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-bash"},"# Clone the wasmedge-quickjs\ngit clone https://github.com/second-state/wasmedge-quickjs\n# Use the wasmedge-quickjs directory as the working directory for modules access\ncd wasmedge-quickjs\n# Download a released WasmEdge QuickJS runtime\ncurl -OL https://github.com/second-state/wasmedge-quickjs/releases/download/v0.5.0-alpha/wasmedge_quickjs.wasm\n# Copy the nodejs project to the current working directory and run the nodejs app\ncp -r /path/to/my_node_app .\nwasmedge --dir .:. wasmedge_quickjs.wasm my_node_app/index.js\n")),(0,a.kt)("admonition",{type:"note"},(0,a.kt)("p",{parentName:"admonition"},"If you want to run ",(0,a.kt)("inlineCode",{parentName:"p"},"wasmedge")," from a directory outside the repo, you will need to tell it where to find the ",(0,a.kt)("inlineCode",{parentName:"p"},"modules")," directory using the ",(0,a.kt)("inlineCode",{parentName:"p"},"--dir")," option. A typical command will look like this: ",(0,a.kt)("inlineCode",{parentName:"p"},"wasmedge --dir .:. --dir ./modules:/path/to/modules wasmedge_quickjs.wasm app.js"))),(0,a.kt)("p",null,"The progress of Node.js support in WasmEdge QuickJS is ",(0,a.kt)("strong",{parentName:"p"},(0,a.kt)("a",{parentName:"strong",href:"https://github.com/WasmEdge/WasmEdge/issues/1535"},"tracked in this issue"),".")," There are two approaches for supporting Node.js APIs in WasmEdge QuickJS."),(0,a.kt)("h2",{id:"the-javascript-modules"},"The JavaScript modules"),(0,a.kt)("p",null,"Some Node.js functions can be implemented in pure JavaScript using the ",(0,a.kt)("a",{parentName:"p",href:"modules"},"modules")," approach. For example,"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"The ",(0,a.kt)("a",{parentName:"li",href:"https://github.com/second-state/wasmedge-quickjs/blob/main/modules/querystring.js"},"querystring")," functions just perform string manipulations."),(0,a.kt)("li",{parentName:"ul"},"The ",(0,a.kt)("a",{parentName:"li",href:"https://github.com/second-state/wasmedge-quickjs/blob/main/modules/buffer.js"},"buffer")," functions manage and encode arrays and memory structures."),(0,a.kt)("li",{parentName:"ul"},"The ",(0,a.kt)("a",{parentName:"li",href:"https://github.com/second-state/wasmedge-quickjs/blob/main/modules/encoding.js"},"encoding")," and ",(0,a.kt)("a",{parentName:"li",href:"https://github.com/second-state/wasmedge-quickjs/blob/main/modules/http.js"},"http")," functions support corresponding Node.js APIs by wrapping around ",(0,a.kt)("a",{parentName:"li",href:"rust"},"Rust internal modules"),".")),(0,a.kt)("h2",{id:"the-rust-internal-modules"},"The Rust internal modules"),(0,a.kt)("p",null,"Other Node.js functions must be implemented using the ",(0,a.kt)("a",{parentName:"p",href:"rust"},"internal_module")," approach in Rust. There are two reasons for that. First, some Node.js API functions are CPU intensive (e.g., encoding) and is most efficiently implemented in Rust. Second, some Node.js API functions require access to the underlying system (e.g., networking and file system) through native host functions."),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"The ",(0,a.kt)("a",{parentName:"li",href:"https://github.com/second-state/wasmedge-quickjs/blob/main/src/internal_module/core.rs"},"core")," module provides OS-level functions such as ",(0,a.kt)("inlineCode",{parentName:"li"},"timeout"),"."),(0,a.kt)("li",{parentName:"ul"},"The ",(0,a.kt)("a",{parentName:"li",href:"https://github.com/second-state/wasmedge-quickjs/blob/main/src/internal_module/encoding.rs"},"encoding")," module provides high-performance encoding and decoding functions, which are in turn ",(0,a.kt)("a",{parentName:"li",href:"https://github.com/second-state/wasmedge-quickjs/blob/main/modules/encoding.js"},"wrapped into Node.js encoding APIs"),"."),(0,a.kt)("li",{parentName:"ul"},"The ",(0,a.kt)("a",{parentName:"li",href:"https://github.com/second-state/wasmedge-quickjs/blob/main/src/internal_module/wasi_net_module.rs"},"wasi_net_module")," provides JavaScript networking functions implemented via the Rust-based WasmEdge WASI socket API. It is then wrapped into the ",(0,a.kt)("a",{parentName:"li",href:"https://github.com/second-state/wasmedge-quickjs/blob/main/modules/http.js"},"Node.js http module"),".")),(0,a.kt)("p",null,"Node.js compatibility support in WasmEdge QuickJS is a work in progress. It is an excellent way for new developers to get familiar with WasmEdge QuickJS. Join us!"))}l.isMDXComponent=!0}}]);