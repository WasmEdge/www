"use strict";(self.webpackChunkbook=self.webpackChunkbook||[]).push([[4738],{3905:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>h});var o=n(67294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function a(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);t&&(o=o.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,o)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?a(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function i(e,t){if(null==e)return{};var n,o,r=function(e,t){if(null==e)return{};var n,o,r={},a=Object.keys(e);for(o=0;o<a.length;o++)n=a[o],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(o=0;o<a.length;o++)n=a[o],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var c=o.createContext({}),l=function(e){var t=o.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},p=function(e){var t=l(e.components);return o.createElement(c.Provider,{value:t},e.children)},d="mdxType",m={inlineCode:"code",wrapper:function(e){var t=e.children;return o.createElement(o.Fragment,{},t)}},u=o.forwardRef((function(e,t){var n=e.components,r=e.mdxType,a=e.originalType,c=e.parentName,p=i(e,["components","mdxType","originalType","parentName"]),d=l(n),u=r,h=d["".concat(c,".").concat(u)]||d[u]||m[u]||a;return n?o.createElement(h,s(s({ref:t},p),{},{components:n})):o.createElement(h,s({ref:t},p))}));function h(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var a=n.length,s=new Array(a);s[0]=u;var i={};for(var c in t)hasOwnProperty.call(t,c)&&(i[c]=t[c]);i.originalType=e,i[d]="string"==typeof e?e:r,s[1]=i;for(var l=2;l<a;l++)s[l]=n[l];return o.createElement.apply(null,s)}return o.createElement.apply(null,n)}u.displayName="MDXCreateElement"},20050:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>s,default:()=>m,frontMatter:()=>a,metadata:()=>i,toc:()=>l});var o=n(87462),r=(n(67294),n(3905));const a={sidebar_position:1},s="Socket client",i={unversionedId:"develop/rust/socket_networking/client",id:"develop/rust/socket_networking/client",title:"Socket client",description:"It is possible for WasmEdge applications to open TCP/IP or UDP network sockets in the host system to communicate directly with external applications. One of the key features of WasmEdge is that it supports non-blocking sockets. That allows even a single-threaded WASM application to handle concurrent network requests. For example, while the program is waiting for data to stream in from one connection, it can start or handle another connection. The wasmedgewasisocket crate enables Rust developers to work on the network socket level.",source:"@site/i18n/zh/docusaurus-plugin-content-docs/current/develop/rust/socket_networking/client.md",sourceDirName:"develop/rust/socket_networking",slug:"/develop/rust/socket_networking/client",permalink:"/docs/zh/develop/rust/socket_networking/client",draft:!1,editUrl:"https://github.com/wasmedge/docs/blob/main/docs/develop/rust/socket_networking/client.md",tags:[],version:"current",sidebarPosition:1,frontMatter:{sidebar_position:1},sidebar:"developSidebar",previous:{title:"Socket networking",permalink:"/docs/zh/category/socket-networking"},next:{title:"Socket server",permalink:"/docs/zh/develop/rust/socket_networking/server"}},c={},l=[{value:"A Simple HTTP Client",id:"a-simple-http-client",level:2},{value:"A non-blocking HTTP client example",id:"a-non-blocking-http-client-example",level:2}],p={toc:l},d="wrapper";function m(e){let{components:t,...n}=e;return(0,r.kt)(d,(0,o.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"socket-client"},"Socket client"),(0,r.kt)("p",null,"It is possible for WasmEdge applications to open TCP/IP or UDP network sockets in the host system to communicate directly with external applications. One of the key features of WasmEdge is that it supports non-blocking sockets. That allows even a single-threaded WASM application to handle concurrent network requests. For example, while the program is waiting for data to stream in from one connection, it can start or handle another connection. The ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/second-state/wasmedge_wasi_socket"},"wasmedge_wasi_socket")," crate enables Rust developers to work on the network socket level."),(0,r.kt)("p",null,"In this chapter, we will show you how to build HTTP clients on TCP sockets. The reason is that the HTTP protocol is relatively simple and could be demonstrated easily. If you use HTTP clients in production, we recommend checking out the ",(0,r.kt)("a",{parentName:"p",href:"/docs/zh/develop/rust/http_service/client"},"HTTP client")," chapter in this book."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#a-simple-http-client"},"A simple HTTP client based on TCP sockets")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#a-non-blocking-http-client-example"},"A non-blocking HTTP client based on TCP sockets"))),(0,r.kt)("admonition",{type:"note"},(0,r.kt)("p",{parentName:"admonition"},"Before we start, ensure ",(0,r.kt)("a",{parentName:"p",href:"/docs/zh/develop/rust/setup"},"you have Rust and WasmEdge installed"),".")),(0,r.kt)("h2",{id:"a-simple-http-client"},"A Simple HTTP Client"),(0,r.kt)("p",null,"You can build and run ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/second-state/wasmedge_wasi_socket/tree/main/examples/http_client"},"the example")," in WasmEdge as follows."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"git clone https://github.com/second-state/wasmedge_wasi_socket.git\ncd wasmedge_wasi_socket/http_client/\n\n# Build the Rust Code\ncargo build --target wasm32-wasi --release\n# Use the AoT compiler to get better performance\nwasmedge compile target/wasm32-wasi/release/http_client.wasm http_client.wasm\n\n# Run the example\nwasmedge http_client.wasm\n")),(0,r.kt)("p",null,"The ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/second-state/wasmedge_wasi_socket/tree/main/examples/http_client"},"source code")," for the HTTP client is available as follows."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},'use wasmedge_http_req::request;\n\nfn main() {\n  let mut writer = Vec::new(); //container for body of a response\n  let res = request::get("http://127.0.0.1:1234/get", &mut writer).unwrap();\n\n  println!("GET");\n  println!("Status: {} {}", res.status_code(), res.reason());\n  println!("Headers {}", res.headers());\n  println!("{}", String::from_utf8_lossy(&writer));\n\n  let mut writer = Vec::new(); //container for body of a response\n  const BODY: &[u8; 27] = b"field1=value1&field2=value2";\n  // let res = request::post("https://httpbin.org/post", BODY, &mut writer).unwrap();\n  // no https , no dns\n  let res = request::post("http://127.0.0.1:1234/post", BODY, &mut writer).unwrap();\n\n  println!("POST");\n  println!("Status: {} {}", res.status_code(), res.reason());\n  println!("Headers {}", res.headers());\n  println!("{}", String::from_utf8_lossy(&writer));\n}\n')),(0,r.kt)("h2",{id:"a-non-blocking-http-client-example"},"A non-blocking HTTP client example"),(0,r.kt)("p",null,"You can build and run ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/second-state/wasmedge_wasi_socket/tree/main/examples/nonblock_http_client"},"the example")," in WasmEdge as follows."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"git clone https://github.com/second-state/wasmedge_wasi_socket\ncd wasmedge_wasi_socket/nonblock_http_client/\n\n# Build the Rust Code\ncargo build --target wasm32-wasi --release\n# Use the AoT compiler for better performance\nwasmedge compile target/wasm32-wasi/release/nonblock_http_client.wasm nonblock_http_client.wasm\n\n# Run the example\nwasmedge nonblock_http_client.wasm\n")),(0,r.kt)("admonition",{type:"note"},(0,r.kt)("p",{parentName:"admonition"},"Non-blocking I/O means that the application program can keep multiple connections open simultaneously, and process data in and out of those connections as they come in. The program can either alternatingly poll those open connections or wait for incoming data to trigger async functions. That allows I/O intensive programs to run faster, even in a single-threaded environment.")),(0,r.kt)("p",null,"The ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/second-state/wasmedge_wasi_socket/tree/main/examples/nonblock_http_client"},"source code")," for a non-blocking HTTP client application is available. The following ",(0,r.kt)("inlineCode",{parentName:"p"},"main()")," function starts two HTTP connections. The program keeps both connections open and alternatingly checks for incoming data. In other words, the two connections are not blocking each other. Their data are handled concurrently (or alternatingly) as the data comes in."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},'use httparse::{Response, EMPTY_HEADER};\nuse std::io::{self, Read, Write};\nuse std::str::from_utf8;\nuse wasmedge_wasi_socket::TcpStream;\n\nfn main() {\n    let req = "GET / HTTP/1.0\\n\\n";\n    let mut first_connection = TcpStream::connect("127.0.0.1:80").unwrap();\n    first_connection.set_nonblocking(true).unwrap();\n    first_connection.write_all(req.as_bytes()).unwrap();\n\n    let mut second_connection = TcpStream::connect("127.0.0.1:80").unwrap();\n    second_connection.set_nonblocking(true).unwrap();\n    second_connection.write_all(req.as_bytes()).unwrap();\n\n    let mut first_buf = vec![0; 4096];\n    let mut first_bytes_read = 0;\n    let mut second_buf = vec![0; 4096];\n    let mut second_bytes_read = 0;\n\n    loop {\n        let mut first_complete = false;\n        let mut second_complete = false;\n        if !first_complete {\n            match read_data(&mut first_connection, &mut first_buf, first_bytes_read) {\n                Ok((bytes_read, false)) => {\n                    first_bytes_read = bytes_read;\n                }\n                Ok((bytes_read, true)) => {\n                    println!("First connection completed");\n                    if bytes_read != 0 {\n                        parse_data(&first_buf, bytes_read);\n                    }\n                    first_complete = true;\n                }\n                Err(e) => {\n                    println!("First connection error: {}", e);\n                    first_complete = true;\n                }\n            }\n        }\n        if !second_complete {\n            match read_data(&mut second_connection, &mut second_buf, second_bytes_read) {\n                Ok((bytes_read, false)) => {\n                    second_bytes_read = bytes_read;\n                }\n                Ok((bytes_read, true)) => {\n                    println!("Second connection completed");\n                    if bytes_read != 0 {\n                        parse_data(&second_buf, bytes_read);\n                    }\n                    second_complete = true;\n                }\n                Err(e) => {\n                    println!("Second connection error: {}", e);\n                    second_complete = true;\n                }\n            }\n        }\n        if first_complete && second_complete {\n            break;\n        }\n    }\n}\n')))}m.isMDXComponent=!0}}]);