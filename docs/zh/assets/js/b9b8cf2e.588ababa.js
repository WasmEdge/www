"use strict";(self.webpackChunkbook=self.webpackChunkbook||[]).push([[1464],{3905:(e,a,t)=>{t.d(a,{Zo:()=>p,kt:()=>h});var n=t(7294);function r(e,a,t){return a in e?Object.defineProperty(e,a,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[a]=t,e}function i(e,a){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);a&&(n=n.filter((function(a){return Object.getOwnPropertyDescriptor(e,a).enumerable}))),t.push.apply(t,n)}return t}function l(e){for(var a=1;a<arguments.length;a++){var t=null!=arguments[a]?arguments[a]:{};a%2?i(Object(t),!0).forEach((function(a){r(e,a,t[a])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):i(Object(t)).forEach((function(a){Object.defineProperty(e,a,Object.getOwnPropertyDescriptor(t,a))}))}return e}function s(e,a){if(null==e)return{};var t,n,r=function(e,a){if(null==e)return{};var t,n,r={},i=Object.keys(e);for(n=0;n<i.length;n++)t=i[n],a.indexOf(t)>=0||(r[t]=e[t]);return r}(e,a);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(n=0;n<i.length;n++)t=i[n],a.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var o=n.createContext({}),m=function(e){var a=n.useContext(o),t=a;return e&&(t="function"==typeof e?e(a):l(l({},a),e)),t},p=function(e){var a=m(e.components);return n.createElement(o.Provider,{value:a},e.children)},d="mdxType",c={inlineCode:"code",wrapper:function(e){var a=e.children;return n.createElement(n.Fragment,{},a)}},u=n.forwardRef((function(e,a){var t=e.components,r=e.mdxType,i=e.originalType,o=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),d=m(t),u=r,h=d["".concat(o,".").concat(u)]||d[u]||c[u]||i;return t?n.createElement(h,l(l({ref:a},p),{},{components:t})):n.createElement(h,l({ref:a},p))}));function h(e,a){var t=arguments,r=a&&a.mdxType;if("string"==typeof e||r){var i=t.length,l=new Array(i);l[0]=u;var s={};for(var o in a)hasOwnProperty.call(a,o)&&(s[o]=a[o]);s.originalType=e,s[d]="string"==typeof e?e:r,l[1]=s;for(var m=2;m<i;m++)l[m]=t[m];return n.createElement.apply(null,l)}return n.createElement.apply(null,t)}u.displayName="MDXCreateElement"},2993:(e,a,t)=>{t.r(a),t.d(a,{assets:()=>o,contentTitle:()=>l,default:()=>c,frontMatter:()=>i,metadata:()=>s,toc:()=>m});var n=t(7462),r=(t(7294),t(3905));const i={sidebar_position:5},l="Using WasmEdge in Docker",s={unversionedId:"develop/deploy/using-wasmedge-in-docker",id:"develop/deploy/using-wasmedge-in-docker",title:"Using WasmEdge in Docker",description:"What is the WasmEdge DockerSlim",source:"@site/i18n/zh/docusaurus-plugin-content-docs/current/develop/deploy/using-wasmedge-in-docker.md",sourceDirName:"develop/deploy",slug:"/develop/deploy/using-wasmedge-in-docker",permalink:"/docs/zh/develop/deploy/using-wasmedge-in-docker",draft:!1,editUrl:"https://github.com/wasmedge/docs/blob/main/docs/develop/deploy/using-wasmedge-in-docker.md",tags:[],version:"current",sidebarPosition:5,frontMatter:{sidebar_position:5},sidebar:"developSidebar",previous:{title:"Deploy with quark",permalink:"/docs/zh/develop/deploy/oci-runtime/quark"},next:{title:"High level runtime support",permalink:"/docs/zh/category/high-level-runtime-support"}},o={},m=[{value:"What is the WasmEdge DockerSlim",id:"what-is-the-wasmedge-dockerslim",level:2},{value:"WasmEdge DockerSlim",id:"wasmedge-dockerslim",level:2},{value:"Run a simple WebAssembly app",id:"run-a-simple-webassembly-app",level:2},{value:"Run a HTTP server app",id:"run-a-http-server-app",level:2},{value:"Run a lightweight Node.js server",id:"run-a-lightweight-nodejs-server",level:2},{value:"Run a lightweight Tensorflow inference application",id:"run-a-lightweight-tensorflow-inference-application",level:2}],p={toc:m},d="wrapper";function c(e){let{components:a,...t}=e;return(0,r.kt)(d,(0,n.Z)({},p,t,{components:a,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"using-wasmedge-in-docker"},"Using WasmEdge in Docker"),(0,r.kt)("h2",{id:"what-is-the-wasmedge-dockerslim"},"What is the WasmEdge DockerSlim"),(0,r.kt)("p",null,"An easy way to run WebAssembly applications in the Docker ecosystem is to embed the WebAssembly bytecode file in a Linux container image. Precisely, we trim down the Linux OS inside the container to the point where it is just enough to support the ",(0,r.kt)("inlineCode",{parentName:"p"},"wasmedge")," runtime. This approach has many advantages."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"It works seamlessly with any Docker or container ecosystem tool since the WebAssembly application is wrapped in a regular container."),(0,r.kt)("li",{parentName:"ul"},"The memory footprint of the entire image of Linux OS and WasmEdge can be reduced to as low as 4MB."),(0,r.kt)("li",{parentName:"ul"},"The attack surface of the slimmed Linux OS is dramatically reduced from a regular Linux OS."),(0,r.kt)("li",{parentName:"ul"},"The overall application security is managed by the WebAssembly sandbox. The software supply chain attack risk is greatly reduced since the WebAssembly sandbox only has access to explicitly declared capabilities."),(0,r.kt)("li",{parentName:"ul"},"The above three advantages are amplified if the application is complex. For example, a WasmEdge AI inference application would NOT require a Python install. A WasmEdge node.js application would NOT require a Node.js and v8 install.")),(0,r.kt)("p",null,"However, this approach still requires starting up a Linux container. The containerized Linux OS, however slim, still takes 80% of the total image size. There is still a lot of room for optimization. The performance and security of this approach would not be as great as running WebAssembly applications directly in ",(0,r.kt)("a",{parentName:"p",href:"/docs/zh/develop/deploy/oci-runtime/crun"},"crun")," or in a ",(0,r.kt)("a",{parentName:"p",href:"/docs/zh/develop/deploy/cri-runtime/containerd"},"containerd shim"),"."),(0,r.kt)("h2",{id:"wasmedge-dockerslim"},"WasmEdge DockerSlim"),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"wasmedge/slim:{version}")," Docker images provide a slim WasmEdge images built with ",(0,r.kt)("a",{parentName:"p",href:"https://dockersl.im"},"DockerSlim")," every release."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Image ",(0,r.kt)("inlineCode",{parentName:"li"},"wasmedge/slim-runtime:{version}")," includes only WasmEdge runtime with ",(0,r.kt)("inlineCode",{parentName:"li"},"wasmedge")," command."),(0,r.kt)("li",{parentName:"ul"},"Image ",(0,r.kt)("inlineCode",{parentName:"li"},"wasmedge/slim:{version}")," includes the following command line utilities:",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"wasmedge")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"wasmedgec")))),(0,r.kt)("li",{parentName:"ul"},"Image ",(0,r.kt)("inlineCode",{parentName:"li"},"wasmedge/slim-tf:{version}")," includes the following command line utilities:",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"wasmedge")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"wasmedgec")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"wasmedge-tensorflow-lite")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"wasmedge-tensorflow")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"show-tflite-tensor")))),(0,r.kt)("li",{parentName:"ul"},"The working directory of the release docker image is ",(0,r.kt)("inlineCode",{parentName:"li"},"/app"),".")),(0,r.kt)("h2",{id:"run-a-simple-webassembly-app"},"Run a simple WebAssembly app"),(0,r.kt)("p",null,"We can run a simple WebAssembly program using Docker. A slim Linux image with WasmEdge installed is only 4MB instead of 30MB for a general Linux image for natively compiled applications. The Linux + WasmEdge image is similar to a unikernel OS image. It minimizes the footprint, performance overhead, and potential attack surface for WebAssembly applications."),(0,r.kt)("p",null,(0,r.kt)("a",{parentName:"p",href:"https://github.com/second-state/wasm-learning/tree/master/cli/wasi"},"The sample application is here"),". First, create a ",(0,r.kt)("inlineCode",{parentName:"p"},"Dockerfile")," based on our release image. Include the ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/second-state/wasm-learning/raw/master/cli/wasi/wasi_example_main.wasm"},"wasm application file")," in the new image, and run the ",(0,r.kt)("inlineCode",{parentName:"p"},"wasmedge")," command at start up."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-shell"},'FROM wasmedge/slim-runtime:0.10.1\nADD wasi_example_main.wasm /\nCMD ["wasmedge", "--dir", ".:/", "/wasi_example_main.wasm"]\n')),(0,r.kt)("p",null,"Run the WebAssembly application in Docker CLI as follows."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-shell"},"$ docker build -t wasmedge/myapp -f Dockerfile ./\n... ...\nSuccessfully tagged wasmedge/myapp:latest\n\n$ docker run --rm wasmedge/myapp\nRandom number: -807910034\nRandom bytes: [113, 123, 78, 85, 63, 124, 68, 66, 151, 71, 91, 249, 242, 160, 164, 133, 35, 209, 106, 143, 202, 87, 147, 87, 236, 49, 238, 165, 125, 175, 172, 114, 136, 205, 200, 176, 30, 122, 149, 21, 39, 58, 221, 102, 165, 179, 124, 13, 60, 166, 188, 127, 83, 95, 145, 0, 25, 209, 226, 190, 10, 184, 139, 191, 243, 149, 197, 85, 186, 160, 162, 156, 181, 74, 255, 99, 203, 161, 108, 153, 90, 155, 247, 183, 106, 79, 48, 255, 172, 17, 193, 36, 245, 195, 170, 202, 119, 238, 104, 254, 214, 227, 149, 20, 8, 147, 105, 227, 114, 146, 246, 153, 251, 139, 130, 1, 219, 56, 228, 154, 146, 203, 205, 56, 27, 115, 79, 254]\nPrinted from wasi: This is from a main function\nThis is from a main function\nThe env vars are as follows.\nThe args are as follows.\nwasi_example_main.wasm\nFile content is This is in a file\n")),(0,r.kt)("h2",{id:"run-a-http-server-app"},"Run a HTTP server app"),(0,r.kt)("p",null,"We can run a simple WebAssembly-based HTTP micro-service using the Docker CLI. The ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/second-state/wasmedge_wasi_socket/tree/main/examples/http_server"},"sample application is here"),". Follow the instructions to compile and build the ",(0,r.kt)("inlineCode",{parentName:"p"},"http_server.wasm")," file."),(0,r.kt)("p",null,"Create a ",(0,r.kt)("inlineCode",{parentName:"p"},"Dockerfile")," based on our release image. Include the ",(0,r.kt)("inlineCode",{parentName:"p"},"http_server.wasm")," application file in the new image, and run the ",(0,r.kt)("inlineCode",{parentName:"p"},"wasmedge")," command at startup."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-shell"},'FROM wasmedge/slim-runtime:0.10.1\nADD http_server.wasm /\nCMD ["wasmedge", "--dir", ".:/", "/http_server.wasm"]\n')),(0,r.kt)("p",null,"Run the WebAssembly server application in Docker CLI as follows. Notice that we map the server port from the container to the host."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-shell"},"$ docker build -t wasmedge/myapp -f Dockerfile ./\n... ...\nSuccessfully tagged wasmedge/myapp:latest\n\n$ docker run --rm -p 1234:1234 wasmedge/myapp\nnew connection at 1234\n")),(0,r.kt)("p",null,"You can now access the server from another terminal."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-shell"},'$ curl -X POST http://127.0.0.1:1234 -d "name=WasmEdge"\necho: name=WasmEdge\n')),(0,r.kt)("h2",{id:"run-a-lightweight-nodejs-server"},"Run a lightweight Node.js server"),(0,r.kt)("p",null,"With WasmEdge QuickJS support for the Node.js API, we can run a lightweight and secure node.js server from Docker CLI. The slim Linux + WasmEdge + Node.js support image size is less than 15MB instead of over 350MB for a standard Node.js image. You will need to do the following."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://github.com/second-state/wasmedge-quickjs/releases/download/v0.4.0-alpha/wasmedge_quickjs.wasm"},"Download the WasmEdge QuickJS runtime")," here. You will have the ",(0,r.kt)("inlineCode",{parentName:"li"},"wasmedge_quickjs.wasm")," file."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://github.com/second-state/wasmedge-quickjs/tree/main/modules"},"Download the modules")," directory from the WasmEdge QuickJS repo."),(0,r.kt)("li",{parentName:"ul"},"Create a JavaScript file for the server. Below is an example ",(0,r.kt)("inlineCode",{parentName:"li"},"http_echo.js")," file you can use.")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-javascript"},"import { createServer, request, fetch } from 'http';\n\ncreateServer((req, resp) => {\n  req.on('data', (body) => {\n    resp.write('echo:');\n    resp.end(body);\n  });\n}).listen(8001, () => {\n  print('listen 8001 ...\\n');\n});\n")),(0,r.kt)("p",null,"Add those files to the Docker image and run the JavaScript file at startup."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-shell"},'FROM wasmedge/slim-runtime:0.10.1\nADD wasmedge_quickjs.wasm /\nADD http_echo.js /\nADD modules /modules\nCMD ["wasmedge", "--dir", ".:/", "/wasmedge_quickjs.wasm", "http_echo.js"]\n')),(0,r.kt)("p",null,"Start the server from Docker CLI."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-shell"},"$ docker build -t wasmedge/myapp -f Dockerfile ./\n... ...\nSuccessfully tagged wasmedge/myapp:latest\n\n$ docker run --rm -p 8001:8001 wasmedge/myapp\nlisten 8001 ...\n")),(0,r.kt)("p",null,"You can now access the server from another terminal."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-shell"},'$ curl -X POST http://127.0.0.1:8001 -d "WasmEdge"\necho:WasmEdge\n')),(0,r.kt)("h2",{id:"run-a-lightweight-tensorflow-inference-application"},"Run a lightweight Tensorflow inference application"),(0,r.kt)("p",null,"A unique and powerful feature of the WasmEdge runtime is its support for AI frameworks. In this example, we will show you how to run an image recognition service from Docker CLI. ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/WasmEdge/wasmedge_hyper_demo/tree/main/server-tflite"},"The sample application is here"),". First, create a ",(0,r.kt)("inlineCode",{parentName:"p"},"Dockerfile")," based on our ",(0,r.kt)("inlineCode",{parentName:"p"},"tensorflow")," release image. Include the ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/WasmEdge/wasmedge_hyper_demo/raw/main/server-tflite/wasmedge_hyper_server_tflite.wasm"},"wasm application file")," in the new image, and run the ",(0,r.kt)("inlineCode",{parentName:"p"},"wasmedge-tensorflow-lite")," command at startup."),(0,r.kt)("p",null,"The Dockerfile is as follows. The whole package is 115MB. It is less than 1/4 of a typically Linux + Python + Tensorflow setup."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-shell"},'FROM wasmedge/slim-tf:0.10.1\nADD wasmedge_hyper_server_tflite.wasm /\nCMD ["wasmedge-tensorflow-lite", "--dir", ".:/", "/wasmedge_hyper_server_tflite.wasm"]\n')),(0,r.kt)("p",null,"Start the server from Docker CLI."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-shell"},"$ docker build -t wasmedge/myapp -f Dockerfile ./\n... ...\nSuccessfully tagged wasmedge/myapp:latest\n\n$ docker run --rm -p 3000:3000 wasmedge/myapp\nlisten 3000 ...\n")),(0,r.kt)("p",null,"You can now access the server from another terminal."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-shell"},'$ curl http://localhost:3000/classify -X POST --data-binary "@grace_hopper.jpg"\nmilitary uniform is detected with 206/255 confidence\n')))}c.isMDXComponent=!0}}]);