"use strict";(self.webpackChunkbook=self.webpackChunkbook||[]).push([[9926],{3905:(e,t,n)=>{n.d(t,{Zo:()=>d,kt:()=>h});var a=n(67294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var l=a.createContext({}),c=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},d=function(e){var t=c(e.components);return a.createElement(l.Provider,{value:t},e.children)},p="mdxType",m={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},u=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,o=e.originalType,l=e.parentName,d=s(e,["components","mdxType","originalType","parentName"]),p=c(n),u=r,h=p["".concat(l,".").concat(u)]||p[u]||m[u]||o;return n?a.createElement(h,i(i({ref:t},d),{},{components:n})):a.createElement(h,i({ref:t},d))}));function h(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=n.length,i=new Array(o);i[0]=u;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[p]="string"==typeof e?e:r,i[1]=s;for(var c=2;c<o;c++)i[c]=n[c];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}u.displayName="MDXCreateElement"},89594:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>i,default:()=>m,frontMatter:()=>o,metadata:()=>s,toc:()=>c});var a=n(87462),r=(n(67294),n(3905));const o={sidebar_position:4},i="Qdrant driver",s={unversionedId:"develop/rust/database/qdrant_driver",id:"develop/rust/database/qdrant_driver",title:"Qdrant driver",description:"WasmEdge is emerging as a lightweight, portable, and embeddable runtime for large language models (LLMs). LLM inference applications, such as RAG chatbots and AI agents, can be developed on Mac or Windows, compiled to Wasm once, and then deployed across Nvidia / AMD / ARM-powered devices or servers, fully taking advantage of on-device GPUs, NPUs, and accelerators.",source:"@site/i18n/zh/docusaurus-plugin-content-docs/current/develop/rust/database/qdrant_driver.md",sourceDirName:"develop/rust/database",slug:"/develop/rust/database/qdrant_driver",permalink:"/docs/zh/develop/rust/database/qdrant_driver",draft:!1,editUrl:"https://github.com/wasmedge/docs/blob/main/docs/develop/rust/database/qdrant_driver.md",tags:[],version:"current",sidebarPosition:4,frontMatter:{sidebar_position:4},sidebar:"developSidebar",previous:{title:"Redis driver",permalink:"/docs/zh/develop/rust/database/redis_driver"},next:{title:"Dapr services",permalink:"/docs/zh/develop/rust/dapr"}},l={},c=[{value:"Run the example",id:"run-the-example",level:2},{value:"Configuration",id:"configuration",level:2},{value:"Code explanation",id:"code-explanation",level:2}],d={toc:c},p="wrapper";function m(e){let{components:t,...n}=e;return(0,r.kt)(p,(0,a.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"qdrant-driver"},"Qdrant driver"),(0,r.kt)("p",null,"WasmEdge is emerging as a lightweight, portable, and embeddable runtime for large language models (LLMs). LLM inference applications, such as RAG chatbots and AI agents, can be developed on Mac or Windows, compiled to Wasm once, and then deployed across Nvidia / AMD / ARM-powered devices or servers, fully taking advantage of on-device GPUs, NPUs, and accelerators."),(0,r.kt)("p",null,"Hence, besides the LLM inference runtime, those LLM applications also need to manage embeddings in vector databases. The ",(0,r.kt)("a",{parentName:"p",href:"https://crates.io/crates/qdrant_rest_client"},"qdrant-rest-client")," crate allows you to access the Qdrant vector database from your portable Wasm apps!"),(0,r.kt)("admonition",{type:"note"},(0,r.kt)("p",{parentName:"admonition"},"Before we start, ",(0,r.kt)("a",{parentName:"p",href:"/docs/zh/develop/rust/setup"},"you need to have Rust and WasmEdge installed"),".\nMake sure that you read the ",(0,r.kt)("a",{parentName:"p",href:"../setup#special-notes"},"special notes on networking apps")," especially if you are compiling Rust programs on a Mac.")),(0,r.kt)("h2",{id:"run-the-example"},"Run the example"),(0,r.kt)("p",null,"The ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/WasmEdge/wasmedge-db-examples/tree/main/qdrant"},"wasmedge-db-example/qdrant")," is a Qdrant client example written in Rust."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},'git clone https://github.com/WasmEdge/wasmedge-db-examples\ncd wasmedge-db-examples/qdrant\n\n# Compile the rust code into WASM\nRUSTFLAGS="--cfg wasmedge --cfg tokio_unstable" cargo build --target wasm32-wasi --release\n\n# Perform vector data operations against a Qdrant at http://localhost:6333\nwasmedge target/wasm32-wasi/release/qdrant_examples.wasm\n')),(0,r.kt)("h2",{id:"configuration"},"Configuration"),(0,r.kt)("p",null,"In order to compile the ",(0,r.kt)("inlineCode",{parentName:"p"},"qdrant_rest_client")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"tokio")," crates, we will need to apply patches to add WasmEdge-specific socket APIs to those crates in ",(0,r.kt)("inlineCode",{parentName:"p"},"Cargo.toml"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},'[patch.crates-io]\nsocket2 = { git = "https://github.com/second-state/socket2.git", branch = "v0.5.x" }\nreqwest = { git = "https://github.com/second-state/wasi_reqwest.git", branch = "0.11.x" }\nhyper = { git = "https://github.com/second-state/wasi_hyper.git", branch = "v0.14.x" }\ntokio = { git = "https://github.com/second-state/wasi_tokio.git", branch = "v1.36.x" }\n\n[dependencies]\nanyhow = "1.0"\nserde_json = "1.0"\nserde = { version = "1.0", features = ["derive"] }\nurl = "2.3"\ntokio = { version = "1", features = ["io-util", "fs", "net", "time", "rt", "macros"] }\nqdrant_rest_client = "0.1.0"\n')),(0,r.kt)("h2",{id:"code-explanation"},"Code explanation"),(0,r.kt)("p",null,"The following program uses the ",(0,r.kt)("inlineCode",{parentName:"p"},"qdrant_rest_client")," crate to access local Qdrant server through its RESTful API.\nIt first creates several points (vectors), saves those vectors to the Qdrant database, retrieves some vectors,\nsearches for vectors, and finally deletes them from the database."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},'#[tokio::main(flavor = "current_thread")]\nasync fn main() -> Result<(), Box<dyn std::error::Error + Send + Sync>> {\n    let client = qdrant::Qdrant::new();\n    // Create a collection with 10-dimensional vectors\n    let r = client.create_collection("my_test", 4).await;\n    println!("Create collection result is {:?}", r);\n\n    let mut points = Vec::<Point>::new();\n    points.push(Point {\n        id: PointId::Num(1),\n        vector: vec![0.05, 0.61, 0.76, 0.74],\n        payload: json!({"city": "Berlin"}).as_object().map(|m| m.to_owned()),\n    });\n    points.push(Point {\n        id: PointId::Num(2),\n        vector: vec![0.19, 0.81, 0.75, 0.11],\n        payload: json!({"city": "London"}).as_object().map(|m| m.to_owned()),\n    });\n    points.push(Point {\n        id: PointId::Num(3),\n        vector: vec![0.36, 0.55, 0.47, 0.94],\n        payload: json!({"city": "Moscow"}).as_object().map(|m| m.to_owned()),\n    });\n    points.push(Point {\n        id: PointId::Num(4),\n        vector: vec![0.18, 0.01, 0.85, 0.80],\n        payload: json!({"city": "New York"})\n            .as_object()\n            .map(|m| m.to_owned()),\n    });\n    points.push(Point {\n        id: PointId::Num(5),\n        vector: vec![0.24, 0.18, 0.22, 0.44],\n        payload: json!({"city": "Beijing"}).as_object().map(|m| m.to_owned()),\n    });\n    points.push(Point {\n        id: PointId::Num(6),\n        vector: vec![0.35, 0.08, 0.11, 0.44],\n        payload: json!({"city": "Mumbai"}).as_object().map(|m| m.to_owned()),\n    });\n\n    let r = client.upsert_points("my_test", points).await;\n    println!("Upsert points result is {:?}", r);\n\n    println!(\n        "The collection size is {}",\n        client.collection_info("my_test").await\n    );\n\n    let p = client.get_point("my_test", 2).await;\n    println!("The second point is {:?}", p);\n\n    let ps = client.get_points("my_test", vec![1, 2, 3, 4, 5, 6]).await;\n    println!("The 1-6 points are {:?}", ps);\n\n    let q = vec![0.2, 0.1, 0.9, 0.7];\n    let r = client.search_points("my_test", q, 2, None).await;\n    println!("Search result points are {:?}", r);\n\n    let r = client.delete_points("my_test", vec![1, 4]).await;\n    println!("Delete points result is {:?}", r);\n\n    println!(\n        "The collection size is {}",\n        client.collection_info("my_test").await\n    );\n\n    let q = vec![0.2, 0.1, 0.9, 0.7];\n    let r = client.search_points("my_test", q, 2, None).await;\n    println!("Search result points are {:?}", r);\n    Ok(())\n}\n')))}m.isMDXComponent=!0}}]);