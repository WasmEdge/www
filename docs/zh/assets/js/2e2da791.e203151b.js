"use strict";(self.webpackChunkbook=self.webpackChunkbook||[]).push([[9457],{3905:(e,n,t)=>{t.d(n,{Zo:()=>p,kt:()=>m});var i=t(67294);function a(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function s(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);n&&(i=i.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,i)}return t}function r(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?s(Object(t),!0).forEach((function(n){a(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):s(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function l(e,n){if(null==e)return{};var t,i,a=function(e,n){if(null==e)return{};var t,i,a={},s=Object.keys(e);for(i=0;i<s.length;i++)t=s[i],n.indexOf(t)>=0||(a[t]=e[t]);return a}(e,n);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(i=0;i<s.length;i++)t=s[i],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(a[t]=e[t])}return a}var o=i.createContext({}),u=function(e){var n=i.useContext(o),t=n;return e&&(t="function"==typeof e?e(n):r(r({},n),e)),t},p=function(e){var n=u(e.components);return i.createElement(o.Provider,{value:n},e.children)},d="mdxType",c={inlineCode:"code",wrapper:function(e){var n=e.children;return i.createElement(i.Fragment,{},n)}},g=i.forwardRef((function(e,n){var t=e.components,a=e.mdxType,s=e.originalType,o=e.parentName,p=l(e,["components","mdxType","originalType","parentName"]),d=u(t),g=a,m=d["".concat(o,".").concat(g)]||d[g]||c[g]||s;return t?i.createElement(m,r(r({ref:n},p),{},{components:t})):i.createElement(m,r({ref:n},p))}));function m(e,n){var t=arguments,a=n&&n.mdxType;if("string"==typeof e||a){var s=t.length,r=new Array(s);r[0]=g;var l={};for(var o in n)hasOwnProperty.call(n,o)&&(l[o]=n[o]);l.originalType=e,l[d]="string"==typeof e?e:a,r[1]=l;for(var u=2;u<s;u++)r[u]=t[u];return i.createElement.apply(null,r)}return i.createElement.apply(null,t)}g.displayName="MDXCreateElement"},26429:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>o,contentTitle:()=>r,default:()=>c,frontMatter:()=>s,metadata:()=>l,toc:()=>u});var i=t(87462),a=(t(67294),t(3905));const s={sidebar_position:3},r="Develop WasmEdge Plug-in in C++ API",l={unversionedId:"contribute/plugin/develop_plugin_cpp",id:"contribute/plugin/develop_plugin_cpp",title:"Develop WasmEdge Plug-in in C++ API",description:"By developing a plug-in, one can extend the functionality of WasmEdge and customize it to suit specific needs. WasmEdge provides a C based API for registering extension modules and host functions. While the WasmEdge language SDKs allow registering host functions from a host (wrapping) application, the plug-in API allows such extensions to be incorporated into WasmEdge's building and releasing process.",source:"@site/i18n/zh/docusaurus-plugin-content-docs/current/contribute/plugin/develop_plugin_cpp.md",sourceDirName:"contribute/plugin",slug:"/contribute/plugin/develop_plugin_cpp",permalink:"/docs/zh/contribute/plugin/develop_plugin_cpp",draft:!1,editUrl:"https://github.com/wasmedge/docs/blob/main/docs/contribute/plugin/develop_plugin_cpp.md",tags:[],version:"current",sidebarPosition:3,frontMatter:{sidebar_position:3},sidebar:"contributeSidebar",previous:{title:"Develop WasmEdge Plug-in in C API",permalink:"/docs/zh/contribute/plugin/develop_plugin_c"},next:{title:"Develop WasmEdge Plug-in in Rust SDK with witc",permalink:"/docs/zh/contribute/plugin/develop_plugin_rustsdk"}},o={},u=[{value:"Set up a development environment",id:"set-up-a-development-environment",level:2},{value:"Create a WasmEdge plug-in project",id:"create-a-wasmedge-plug-in-project",level:2},{value:"Write plug-in code",id:"write-plug-in-code",level:2},{value:"Build plug-in",id:"build-plug-in",level:2}],p={toc:u},d="wrapper";function c(e){let{components:n,...t}=e;return(0,a.kt)(d,(0,i.Z)({},p,t,{components:n,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"develop-wasmedge-plug-in-in-c-api"},"Develop WasmEdge Plug-in in C++ API"),(0,a.kt)("p",null,"By developing a plug-in, one can extend the functionality of WasmEdge and customize it to suit specific needs. WasmEdge provides a C based API for registering extension modules and host functions. While the WasmEdge language SDKs allow registering host functions from a host (wrapping) application, the plug-in API allows such extensions to be incorporated into WasmEdge's building and releasing process."),(0,a.kt)("admonition",{type:"note"},(0,a.kt)("p",{parentName:"admonition"},"It is recommended that developers choose the WasmEdge ",(0,a.kt)("a",{parentName:"p",href:"/docs/zh/contribute/plugin/develop_plugin_c"},"C API")," for plug-in development because of the support, compatibility, and flexibility the WasmEdge runtime provides.")),(0,a.kt)("p",null,"Here is a flowchart showing all the steps needed for developing WasmEdge Plug-in -"),(0,a.kt)("mermaid",{value:"graph TD;\nA[Develop WasmEdge Plug-in in C++ API]\nA --\x3e B(Set up development environment)\nB --\x3e C(Create project directory)\nC --\x3e D(Add configuration files)\nD --\x3e E(Install necessary tools and dependencies)\nE --\x3e F(Enable specific backends or components)\nF --\x3e G(Write plug-in code)\nG --\x3e H(Build plug-in)\nC --\x3e I(Define plug-in API)\nH --\x3e I\nI --\x3e J(Compile WasmEdge plug-in)\nJ --\x3e K(Test and debug plug-in)"}),(0,a.kt)("p",null,"This flowchart illustrates developing a WasmEdge plug-in, showcasing the steps from choosing a programming language to finalizing and releasing the plug-in."),(0,a.kt)("h2",{id:"set-up-a-development-environment"},"Set up a development environment"),(0,a.kt)("p",null,"To start developing WasmEdge plug-ins, it is essential to correctly set up the development environment. This section provides step-by-step instructions for WasmEdge plug-in development -"),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Build WasmEdge from source"),": For developing the WasmEdge plug-in in C++, you must build WasmEdge from source. Follow the",(0,a.kt)("a",{parentName:"p",href:"/docs/zh/contribute/source/build_from_src"},"build WasmEdge from source")," for instructions."),(0,a.kt)("p",null,"After installing WasmEdge, you need to set up the build environment. If you're using Linux or other platforms, you can follow the instructions in the ",(0,a.kt)("a",{parentName:"p",href:"/docs/zh/contribute/source/os/linux"},"build environment setup guide"),"."),(0,a.kt)("h2",{id:"create-a-wasmedge-plug-in-project"},"Create a WasmEdge plug-in project"),(0,a.kt)("p",null,"To create a WasmEdge plug-in project, follow these steps:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},(0,a.kt)("strong",{parentName:"p"},"Set up the project directory"),": Create a directory structure for your plug-in project. You can use a standard structure for the chosen language or create your structure. To create a project directory structure, use the following commands:"),(0,a.kt)("pre",{parentName:"li"},(0,a.kt)("code",{parentName:"pre",className:"language-bash"},"mkdir testplugin\ncd testplugin\nmkdir src include build\n"))),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},(0,a.kt)("strong",{parentName:"p"},"Add necessary libraries or dependencies"),": Include any required libraries or dependencies for your plug-in. Modify the configuration files created in the previous step to include the required dependencies."))),(0,a.kt)("h2",{id:"write-plug-in-code"},"Write plug-in code"),(0,a.kt)("p",null,"To create a plug-in with host functions and modules, follow these steps:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},(0,a.kt)("strong",{parentName:"p"},"Host Functions and Modules"),": The plug-in aims to provide the host functions that can be imported when instantiating WASM. Therefore, developers should first implement their plug-in host functions in WasmEdge internal C++. Assume that the host function implementations are in the ",(0,a.kt)("inlineCode",{parentName:"p"},"testplugin.h"),"."),(0,a.kt)("pre",{parentName:"li"},(0,a.kt)("code",{parentName:"pre",className:"language-cpp"},'#pragma once\n\n#include "plug-in/plug-in.h"\n\n#include <cstdint>\n#include <string>\n\nnamespace WasmEdge {\nnamespace Host {\n\n// The environment class. For the register object.\nclass WasmEdgePluginTestEnv {\npublic:\n  WasmEdgePluginTestEnv() noexcept = default;\n\n  static Plugin::PluginRegister Register;\n};\n\n// The host function base template class. For inheriting the environment class\n// reference.\ntemplate <typename T>\nclass WasmEdgePluginTestFunc : public Runtime::HostFunction<T> {\npublic:\n  WasmEdgePluginTestFunc(WasmEdgePluginTestEnv &HostEnv)\n      : Runtime::HostFunction<T>(0), Env(HostEnv) {}\n\nprotected:\n  WasmEdgePluginTestEnv &Env;\n};\n\n// The host function to add 2 int32_t numbers.\nclass WasmEdgePluginTestFuncAdd\n    : public WasmEdgePluginTestFunc<WasmEdgePluginTestFuncAdd> {\npublic:\n  WasmEdgePluginTestFuncAdd(WasmEdgePluginTestEnv &HostEnv)\n      : WasmEdgePluginTestFunc(HostEnv) {}\n  Expect<uint32_t> body(const Runtime::CallingFrame &, uint32_t A, uint32_t B) {\n    return A + B;\n  }\n};\n\n// The host function to sub 2 int32_t numbers.\nclass WasmEdgePluginTestFuncSub\n    : public WasmEdgePluginTestFunc<WasmEdgePluginTestFuncSub> {\npublic:\n  WasmEdgePluginTestFuncSub(WasmEdgePluginTestEnv &HostEnv)\n      : WasmEdgePluginTestFunc(HostEnv) {}\n  Expect<uint32_t> body(const Runtime::CallingFrame &, uint32_t A, uint32_t B) {\n    return A - B;\n  }\n};\n\n// The host module class. There can be several modules in a plug-in.\nclass WasmEdgePluginTestModule : public Runtime::Instance::ModuleInstance {\npublic:\n  WasmEdgePluginTestModule()\n      : Runtime::Instance::ModuleInstance("wasmedge_plugintest_cpp_module") {\n    addHostFunc("add", std::make_unique<WasmEdgePluginTestFuncAdd>(Env));\n    addHostFunc("sub", std::make_unique<WasmEdgePluginTestFuncSub>(Env));\n  }\n\n  WasmEdgePluginTestEnv &getEnv() { return Env; }\n\nprivate:\n  WasmEdgePluginTestEnv Env;\n};\n\n} // namespace Host\n} // namespace WasmEdge\n'))),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},(0,a.kt)("strong",{parentName:"p"},"Creation Functions for Modules"),": Then developers should implement the module creation functions. Assume the following implementations are all in the ",(0,a.kt)("inlineCode",{parentName:"p"},"testplugin.cpp"),"."),(0,a.kt)("pre",{parentName:"li"},(0,a.kt)("code",{parentName:"pre",className:"language-cpp"},'#include "testplugin.h"\n\nnamespace WasmEdge {\nnamespace Host {\nnamespace {\n\nRuntime::Instance::ModuleInstance *\ncreate(const Plugin::PluginModule::ModuleDescriptor *) noexcept {\n  // There can be several modules in a plug-in. For that, developers should\n  // implement several `create` functions for each module.\n  return new WasmEdgePluginTestModule;\n}\n\n} // namespace\n} // namespace Host\n} // namespace WasmEdge\n'))),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},(0,a.kt)("strong",{parentName:"p"},"Plug-in Descriptions"),": For constructing the plug-in, developers should supply the descriptions of this plug-in and the modules."),(0,a.kt)("pre",{parentName:"li"},(0,a.kt)("code",{parentName:"pre",className:"language-cpp"},'namespace WasmEdge {\nnamespace Host {\nnamespace {\n\nPlugin::Plugin::PluginDescriptor Descriptor{\n    //Plug-in name - for searching the plug-in context by the\n    // `WasmEdge_PluginFind()` C API.\n    .Name = "wasmedge_plugintest_cpp",\n    //Plug-in description.\n    .Description = "",\n    //Plug-in API version.\n    .APIVersion = Plugin::Plugin::CurrentAPIVersion,\n    //Plug-in version.\n    .Version = {0, 10, 0, 0},\n    // Module count in this plug-in.\n    .ModuleCount = 1,\n    // Pointer to module description array.\n    .ModuleDescriptions =\n        // The module descriptor array.\n        (Plugin::PluginModule::ModuleDescriptor[]){\n            {\n                // Module name. This is the name for searching and creating the\n                // module instance context by the\n                // `WasmEdge_PluginCreateModule()` C API.\n                .Name = "wasmedge_plugintest_cpp_module",\n                // Module description.\n                .Description = "This is for the plugin tests in WasmEdge.",\n                // Creation function pointer.\n                .Create = create,\n            },\n        },\n    //Plug-in options (Work in progress).\n    .AddOptions = nullptr,\n};\n\n} // namespace\n} // namespace Host\n} // namespace WasmEdge\n'))),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},(0,a.kt)("strong",{parentName:"p"},"Plug-in Options"),": WORK IN PROGRESS. This section is reserved for the feature in the future.")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},(0,a.kt)("strong",{parentName:"p"},"Implement Plug-in Descriptor Registration"),": The final step is to implement the ",(0,a.kt)("inlineCode",{parentName:"p"},"Plugin::PluginRegister")," initialization with the plug-in descriptor."))),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cpp"},"namespace WasmEdge {\nnamespace Host {\n\nPlugin::PluginRegister WasmEdgePluginTestEnv::Register(&Descriptor);\n\n} // namespace Host\n} // namespace WasmEdge\n")),(0,a.kt)("p",null,"Remember to implement any additional functions or structures your plug-in requires to fulfill its functionality."),(0,a.kt)("p",null,"Following these steps and implementing the necessary functions and descriptors, you can create a plug-in with host functions and modules in WasmEdge C++ API. You can continue developing your plug-in by adding functionality and implementing the desired behavior."),(0,a.kt)("h2",{id:"build-plug-in"},"Build plug-in"),(0,a.kt)("p",null,"To build the plug-in shared library, developers should build in CMake with the WasmEdge source."),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},"Assume that the' test' folder is created under the ",(0,a.kt)("inlineCode",{parentName:"p"},"<PATH_TO_WASMEDGE_SOURCE>/plug-ins"),". Add this line in the ",(0,a.kt)("inlineCode",{parentName:"p"},"<PATH_TO_WASMEDGE_SOURCE>/plugins/CMakeLists.txt"),":"),(0,a.kt)("pre",{parentName:"li"},(0,a.kt)("code",{parentName:"pre",className:"language-cmake"},"add_subdirectory(test)\n"))),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},"Copy the ",(0,a.kt)("inlineCode",{parentName:"p"},"testplugin.h")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"testplugin.cpp")," into the ",(0,a.kt)("inlineCode",{parentName:"p"},"<PATH_TO_WASMEDGE_SOURCE>/plugins/test")," directory. And then edit the file ",(0,a.kt)("inlineCode",{parentName:"p"},"<PATH_TO_WASMEDGE_SOURCE>/plugins/test/CMakeLists.txt"),":"),(0,a.kt)("pre",{parentName:"li"},(0,a.kt)("code",{parentName:"pre",className:"language-cmake"},"wasmedge_add_library(wasmedgePluginTest\n  SHARED\n  env.cpp\n  func.cpp\n  module.cpp\n  testplugin.cpp\n)\n\ntarget_compile_options(wasmedgePluginTest\n  PUBLIC\n  -DWASMEDGE_PLUGIN\n)\n\ntarget_include_directories(wasmedgePluginTest\n  PUBLIC\n  $<TARGET_PROPERTY:wasmedgePlugin,INCLUDE_DIRECTORIES>\n  ${CMAKE_CURRENT_SOURCE_DIR}\n)\n\nif(WASMEDGE_LINK_PLUGINS_STATIC)\n  target_link_libraries(wasmedgePluginTest\n    PRIVATE\n    wasmedgeCAPI\n  )\nelse()\n  target_link_libraries(wasmedgePluginTest\n    PRIVATE\n    wasmedge_shared\n  )\nendif()\n\ninstall(TARGETS wasmedgePluginTest DESTINATION ${CMAKE_INSTALL_LIBDIR}/wasmedge)\n")))),(0,a.kt)("p",null,"Follow the guide to ",(0,a.kt)("a",{parentName:"p",href:"/docs/zh/contribute/source/os/linux"},"build WasmEdge from source"),", according to your specific operating system (e.g., Linux), which will include building the plug-in shared library along with WasmEdge."))}c.isMDXComponent=!0}}]);