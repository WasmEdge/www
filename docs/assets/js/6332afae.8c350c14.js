"use strict";(self.webpackChunkbook=self.webpackChunkbook||[]).push([[4316],{3905:(e,t,n)=>{n.d(t,{Zo:()=>u,kt:()=>m});var r=n(7294);function s(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function a(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?a(Object(n),!0).forEach((function(t){s(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function i(e,t){if(null==e)return{};var n,r,s=function(e,t){if(null==e)return{};var n,r,s={},a=Object.keys(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||(s[n]=e[n]);return s}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(s[n]=e[n])}return s}var p=r.createContext({}),l=function(e){var t=r.useContext(p),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},u=function(e){var t=l(e.components);return r.createElement(p.Provider,{value:t},e.children)},d="mdxType",c={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},h=r.forwardRef((function(e,t){var n=e.components,s=e.mdxType,a=e.originalType,p=e.parentName,u=i(e,["components","mdxType","originalType","parentName"]),d=l(n),h=s,m=d["".concat(p,".").concat(h)]||d[h]||c[h]||a;return n?r.createElement(m,o(o({ref:t},u),{},{components:n})):r.createElement(m,o({ref:t},u))}));function m(e,t){var n=arguments,s=t&&t.mdxType;if("string"==typeof e||s){var a=n.length,o=new Array(a);o[0]=h;var i={};for(var p in t)hasOwnProperty.call(t,p)&&(i[p]=t[p]);i.originalType=e,i[d]="string"==typeof e?e:s,o[1]=i;for(var l=2;l<a;l++)o[l]=n[l];return r.createElement.apply(null,o)}return r.createElement.apply(null,n)}h.displayName="MDXCreateElement"},7123:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>p,contentTitle:()=>o,default:()=>d,frontMatter:()=>a,metadata:()=>i,toc:()=>l});var r=n(7462),s=(n(7294),n(3905));const a={sidebar_position:6},o="4.5 Networking for HTTPS",i={unversionedId:"develop/rust/https-service",id:"develop/rust/https-service",title:"4.5 Networking for HTTPS",description:"The WasmEdge WASI socket API supports HTTP networking in Wasm apps. In order to achieve the goal of supporting HTTPS requests with the same API as an HTTP request, we now create a WasmEdge-HttpsReq plug-in using the OpenSSL library. In this chapter, we will give the example of HTTPS requests and explain the design.",source:"@site/docs/develop/rust/https-service.md",sourceDirName:"develop/rust",slug:"/develop/rust/https-service",permalink:"/docs/develop/rust/https-service",draft:!1,editUrl:"https://github.com/wasmedge/docs/blob/main/docs/develop/rust/https-service.md",tags:[],version:"current",sidebarPosition:6,frontMatter:{sidebar_position:6},sidebar:"developSidebar",previous:{title:"4.4.1 Server",permalink:"/docs/develop/rust/socket_networking/server"},next:{title:"4.7 AI Inference",permalink:"/docs/category/47-ai-inference"}},p={},l=[{value:"Prerequisites",id:"prerequisites",level:2},{value:"An HTTPS request example",id:"an-https-request-example",level:2},{value:"Explanation of design",id:"explanation-of-design",level:2},{value:"Implementation of httpsreq host function",id:"implementation-of-httpsreq-host-function",level:3}],u={toc:l};function d(e){let{components:t,...n}=e;return(0,s.kt)("wrapper",(0,r.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,s.kt)("h1",{id:"45-networking-for-https"},"4.5 Networking for HTTPS"),(0,s.kt)("p",null,"The ",(0,s.kt)("a",{parentName:"p",href:"https://github.com/second-state/wasmedge_wasi_socket"},"WasmEdge WASI socket API")," supports HTTP networking in Wasm apps. In order to achieve the goal of supporting HTTPS requests with the same API as an HTTP request, we now create a WasmEdge-HttpsReq plug-in using the OpenSSL library. In this chapter, we will give the example of HTTPS requests and explain the design."),(0,s.kt)("h2",{id:"prerequisites"},"Prerequisites"),(0,s.kt)("p",null,"Make sure ",(0,s.kt)("a",{parentName:"p",href:"setup"},"you have Rust and WasmEdge installed")," and ",(0,s.kt)("a",{parentName:"p",href:"../build-and-run/install#WasmEdge-Httpsreq-plugin"},"the WasmEdge-HttpsReq plug-in")," installed."),(0,s.kt)("h2",{id:"an-https-request-example"},"An HTTPS request example"),(0,s.kt)("p",null,"The ",(0,s.kt)("a",{parentName:"p",href:"https://github.com/second-state/http_req/blob/master/examples/get_https.rs"},"example source code")," for the HTTPS request is available as follows. The HTTP and HTTPS APIs are the same. The Err messages are presented differently because the HTTP uses the rust code while the HTTPS request uses a wasmedge host function."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-rust"},'use wasmedge_http_req::request;\n\nfn main() {\n    // get request\n    let mut writer = Vec::new(); //container for body of a response\n    let mut res = request::get("https://httpbin.org/get", &mut writer).unwrap();\n\n    println!("Status: {} {}", res.status_code(), res.reason());\n    println!("Headers {}", res.headers());\n    //println!("{}", String::from_utf8_lossy(&writer));  // uncomment this line to display the content of writer\n\n    // head request\n    res = request::head("https://httpbin.org/head").unwrap();\n\n    println!("Status: {} {}", res.status_code(), res.reason());\n    println!("{:?}", res.headers());\n\n    // post request\n    writer = Vec::new(); //container for body of a response\n    const BODY: &[u8; 27] = b"field1=value1&field2=value2";\n    res = request::post("https://httpbin.org/post", BODY, &mut writer).unwrap();\n\n    println!("Status: {} {}", res.status_code(), res.reason());\n    println!("Headers {}", res.headers());\n    //println!("{}", String::from_utf8_lossy(&writer));  // uncomment this line to display the content of writer\n\n    // add headers and set version\n    let uri = Uri::try_from("http://httpbin.org/get").unwrap();\n    // let uri = Uri::try_from("https://httpbin.org/get").unwrap(); // uncomment the line for https request\n\n    // add headers to the request\n    let mut headers = Headers::new();\n    headers.insert("Accept-Charset", "utf-8");\n    headers.insert("Accept-Language", "en-US");\n    headers.insert("Host", "rust-lang.org");\n    headers.insert("Connection", "Close");\n\n    let mut response = Request::new(&uri)\n        .headers(headers)\n        .send(&mut writer)\n        .unwrap();\n\n    println!("{}", String::from_utf8_lossy(&writer));\n\n    // set version\n    response = Request::new(&uri)\n        .version(HttpVersion::Http10)\n        .send(&mut writer)\n        .unwrap();\n\n    println!("{}", String::from_utf8_lossy(&writer));\n}\n')),(0,s.kt)("p",null,"The following command compiles the Rust program"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-bash"},"# build the wasmedge httpsreq plugin module\nsudo apt-get install libssl-dev\ncmake -DCMAKE_BUILD_TYPE=Release -DWASMEDGE_BUILD_TESTS=OFF -DWASMEDGE_PLUGIN_HTTPSREQ=On  .. && make -j4\n\ncargo build --target wasm32-wasi --release\n")),(0,s.kt)("p",null,"The following command runs the application in WasmEdge."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-bash"},"wasmedge target/wasm32-wasi/release/get_https.wasm\nwasmedge target/wasm32-wasi/release/post_https.wasm\nwasmedge target/wasm32-wasi/release/head_https.wasm\n")),(0,s.kt)("h2",{id:"explanation-of-design"},"Explanation of design"),(0,s.kt)("p",null,"It is observed that the request is first parsed and then added to a stream which sends the parsed request to the server. We remain the first step that is HTTPS request is parsed in the original Rust code. We modify the second step by replacing it with a function called ",(0,s.kt)("inlineCode",{parentName:"p"},"send_data")," that is implemented by the ",(0,s.kt)("a",{parentName:"p",href:"https://github.com/WasmEdge/WasmEdge/tree/master/plugins/wasmedge_httpsreq"},"wasmedge_httpsreq host function"),". We also let the original Rust source code to process the received content by implementing two additional functions ",(0,s.kt)("inlineCode",{parentName:"p"},"get_rcv_len")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"get_rcv"),"."),(0,s.kt)("p",null,"The advantage of this design is that because the first step is retained, we can use the same API for HTTP and HTTPS request. Besides, one function (i.e. send_data in httpsreq plugin) is needed for all types of requests as long as it is supported in wasmedge_http_req. ",(0,s.kt)("inlineCode",{parentName:"p"},"send_data")," function receives three parameters namely the host, the port and the parsed request. An example for using the send_data function is available as follows."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-Rust"},'send_data("www.google.com", 443, "GET / HTTP/1.1\\nHost: www.google.com\\r\\nConnection: Close\\r\\nReferer: https://www.google.com/\\r\\n\\r\\n");\n')),(0,s.kt)("p",null,"So, We only do a little change to the original Rust code."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-Rust"},'if self.inner.uri.scheme() == "https" {\nlet buf = &self.inner.parse_msg();\n    let body = String::from_utf8_lossy(buf);\n    send_data(host, port.into(), &body);\n    let output = get_receive();\n    let tmp = String::from_utf8(output.rcv_vec).unwrap();\n    let res = Response::try_from(tmp.as_bytes(), writer).unwrap();\n    return Ok(res);\n}\n')),(0,s.kt)("p",null,"To add the host function to a crate that can be used by Rust code, we also implement the ",(0,s.kt)("a",{parentName:"p",href:"https://github.com/second-state/wasmedge_http_req"},"httpreq module"),"."),(0,s.kt)("h3",{id:"implementation-of-httpsreq-host-function"},"Implementation of httpsreq host function"),(0,s.kt)("p",null,"The httpsreq host has three functions (i.e. ",(0,s.kt)("inlineCode",{parentName:"p"},"send_data"),", ",(0,s.kt)("inlineCode",{parentName:"p"},"get_rcv_len")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"get_rcv"),")\nThe ",(0,s.kt)("inlineCode",{parentName:"p"},"send_data")," function uses the OpenSSL library to send the data to the server. The ",(0,s.kt)("inlineCode",{parentName:"p"},"send_data")," function receives three inputs, that is, the host, the port and the parsed request."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-cpp"},"Expect<void> WasmEdgeHttpsReqSendData::body(const Runtime::CallingFrame &Frame,\n                                            uint32_t HostPtr, uint32_t HostLen,\n                                            uint32_t Port, uint32_t BodyPtr,\n                                            uint32_t BodyLen)\n")),(0,s.kt)("p",null,"The ",(0,s.kt)("inlineCode",{parentName:"p"},"get_rcv")," function and ",(0,s.kt)("inlineCode",{parentName:"p"},"get_rcv_len")," function pass the received content out of the host function which is later processed by the original Rust code. The get_rcv function receives the pointer while the get_rcv_len function returns the length of the received content."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-cpp"},"Expect<void> WasmEdgeHttpsReqGetRcv::body(const Runtime::CallingFrame &Frame,\n                                          uint32_t BufPtr)\n\nExpect<uint32_t>\nWasmEdgeHttpsReqGetRcvLen::body(const Runtime::CallingFrame &)\n")),(0,s.kt)("p",null,"It then opens the connection. Next, use the ",(0,s.kt)("inlineCode",{parentName:"p"},"SSL_write")," to write the parsed request to the connection. Finally, it receives by using ",(0,s.kt)("inlineCode",{parentName:"p"},"SSL_read")," and prints the receive to the console."))}d.isMDXComponent=!0}}]);