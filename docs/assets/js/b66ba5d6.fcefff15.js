"use strict";(self.webpackChunkbook=self.webpackChunkbook||[]).push([[5976],{3905:(e,t,n)=>{n.d(t,{Zo:()=>m,kt:()=>d});var a=n(67294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function s(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?s(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):s(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function i(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},s=Object.keys(e);for(a=0;a<s.length;a++)n=s[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(a=0;a<s.length;a++)n=s[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var p=a.createContext({}),l=function(e){var t=a.useContext(p),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},m=function(e){var t=l(e.components);return a.createElement(p.Provider,{value:t},e.children)},c="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},h=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,s=e.originalType,p=e.parentName,m=i(e,["components","mdxType","originalType","parentName"]),c=l(n),h=r,d=c["".concat(p,".").concat(h)]||c[h]||u[h]||s;return n?a.createElement(d,o(o({ref:t},m),{},{components:n})):a.createElement(d,o({ref:t},m))}));function d(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var s=n.length,o=new Array(s);o[0]=h;var i={};for(var p in t)hasOwnProperty.call(t,p)&&(i[p]=t[p]);i.originalType=e,i[c]="string"==typeof e?e:r,o[1]=i;for(var l=2;l<s;l++)o[l]=n[l];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}h.displayName="MDXCreateElement"},31372:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>p,contentTitle:()=>o,default:()=>u,frontMatter:()=>s,metadata:()=>i,toc:()=>l});var a=n(87462),r=(n(67294),n(3905));const s={sidebar_position:1},o="HTTP client",i={unversionedId:"develop/rust/http_service/client",id:"develop/rust/http_service/client",title:"HTTP client",description:"WasmEdge allows Rust developers to use APIs they are already familiar with to access the Internet via the HTTP or HTTPS protocols. This chapter will cover HTTP client APIs and libraries to access external web services from your WasmEdge app. For HTTP servers in WasmEdge, please see the next chapter.",source:"@site/docs/develop/rust/http_service/client.md",sourceDirName:"develop/rust/http_service",slug:"/develop/rust/http_service/client",permalink:"/docs/develop/rust/http_service/client",draft:!1,editUrl:"https://github.com/wasmedge/docs/blob/main/docs/develop/rust/http_service/client.md",tags:[],version:"current",sidebarPosition:1,frontMatter:{sidebar_position:1},sidebar:"developSidebar",previous:{title:"HTTP services",permalink:"/docs/category/http-services"},next:{title:"Server",permalink:"/docs/develop/rust/http_service/server"}},p={},l=[{value:"The hyper API",id:"the-hyper-api",level:2},{value:"The http_req API",id:"the-http_req-api",level:2},{value:"The reqwest API",id:"the-reqwest-api",level:2}],m={toc:l},c="wrapper";function u(e){let{components:t,...n}=e;return(0,r.kt)(c,(0,a.Z)({},m,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"http-client"},"HTTP client"),(0,r.kt)("p",null,"WasmEdge allows Rust developers to use APIs they are already familiar with to access the Internet via the HTTP or HTTPS protocols. This chapter will cover HTTP client APIs and libraries to access external web services from your WasmEdge app. For HTTP servers in WasmEdge, please see ",(0,r.kt)("a",{parentName:"p",href:"server"},"the next chapter"),"."),(0,r.kt)("admonition",{type:"note"},(0,r.kt)("p",{parentName:"admonition"},"Before we start, ensure ",(0,r.kt)("a",{parentName:"p",href:"/docs/develop/rust/setup"},"you have Rust and WasmEdge installed"),". To make HTTPS requests, install the ",(0,r.kt)("a",{parentName:"p",href:"/docs/start/install#tls-plug-in"},"WasmEdge TLS plug-in"),".")),(0,r.kt)("p",null,"We will discuss HTTP and HTTPS clients using popular Rust APIs."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#the-hyper-api"},"The hyper API (recommended)")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#the-http_req-api"},"The http_req API")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#the-reqwest-api"},"The reqwest API"))),(0,r.kt)("h2",{id:"the-hyper-api"},"The hyper API"),(0,r.kt)("p",null,"The ",(0,r.kt)("a",{parentName:"p",href:"https://crates.io/crates/hyper"},"hyper crate")," is a widely used Rust library to create HTTP and HTTPS networking applications. We recommend you use it in WasmEdge applications. A key feature of the ",(0,r.kt)("inlineCode",{parentName:"p"},"hyper")," crate is that it is based on the ",(0,r.kt)("inlineCode",{parentName:"p"},"tokio")," runtime, which supports asynchronous network connections. Asynchronous HTTP or HTTPS requests do not block the execution of the calling application. It allows an application to make multiple concurrent HTTP requests and to process responses as they are received. That enables high-performance networking applications in WasmEdge."),(0,r.kt)("admonition",{type:"note"},(0,r.kt)("p",{parentName:"admonition"},"Non-blocking I/O means that the application program can keep multiple connections open simultaneously, and process data in and out of those connections as they come in. The program can either alternatingly poll those open connections or wait for incoming data to trigger async functions. That allows I/O intensive programs to run much faster, even in a single-threaded environment.")),(0,r.kt)("p",null,"Build and run ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/WasmEdge/wasmedge_hyper_demo/"},"the hyper example")," in WasmEdge as follows."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"git clone https://github.com/WasmEdge/wasmedge_hyper_demo\ncd wasmedge_hyper_demo/client\n\n# Build the Rust code\ncargo build --target wasm32-wasi --release\n# Use the AoT compiler to get better performance\nwasmedge compile target/wasm32-wasi/release/wasmedge_hyper_client.wasm wasmedge_hyper_client.wasm\n\n# Run the example\nwasmedge wasmedge_hyper_client.wasm\n")),(0,r.kt)("p",null,"The HTTPS version of the demo is as follows. Make sure that you install the ",(0,r.kt)("a",{parentName:"p",href:"/docs/start/install#tls-plug-in"},"WasmEdge TLS plug-in")," first."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"// Build\ncd wasmedge_hyper_demo/client-https\ncargo build --target wasm32-wasi --release\nwasmedge compile target/wasm32-wasi/release/wasmedge_hyper_client_https.wasm wasmedge_hyper_client_https.wasm\n\n// Run\nwasmedge wasmedge_hyper_client_https.wasm\n")),(0,r.kt)("p",null,"In your Rust application, import ",(0,r.kt)("a",{parentName:"p",href:"https://crates.io/crates/hyper_wasi"},"the WasmEdge adapted hyper crate"),", which uses a special version of single-threaded Tokio that is adapted for WebAssembly. Just add the following line to your ",(0,r.kt)("inlineCode",{parentName:"p"},"Cargo.toml"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-toml"},'[dependencies]\nhyper_wasi = "0.15.0"\n')),(0,r.kt)("p",null,"The ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/WasmEdge/wasmedge_hyper_demo/blob/main/client/src/main.rs"},"Rust example code")," below shows an HTTP GET request."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},'async fn fetch_url_return_str (url: hyper::Uri) -> Result<()> {\n    let client = Client::new();\n    let mut res = client.get(url).await?;\n\n    let mut resp_data = Vec::new();\n    while let Some(next) = res.data().await {\n        let chunk = next?;\n        resp_data.extend_from_slice(&chunk);\n    }\n    println!("{}", String::from_utf8_lossy(&resp_data));\n')),(0,r.kt)("p",null,"The ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/WasmEdge/wasmedge_hyper_demo/blob/main/client-https/src/main.rs"},"HTTPS example")," is slightly more complex."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},'async fn fetch_https_url(url: hyper::Uri) -> Result<()> {\n    let https = wasmedge_hyper_rustls::connector::new_https_connector(\n        wasmedge_rustls_api::ClientConfig::default(),\n    );\n    let client = Client::builder().build::<_, hyper::Body>(https);\n    let res = client.get(url).await?;\n\n    let body = hyper::body::to_bytes(res.into_body()).await.unwrap();\n    println!("{}", String::from_utf8(body.into()).unwrap());\n    Ok(())\n}\n')),(0,r.kt)("p",null,"And here is an HTTP POST request."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},'async fn post_url_return_str (url: hyper::Uri, post_body: &\'static [u8]) -> Result<()> {\n    let client = Client::new();\n    let req = Request::builder()\n        .method(Method::POST)\n        .uri(url)\n        .body(Body::from(post_body))?;\n    let mut res = client.request(req).await?;\n\n    let mut resp_data = Vec::new();\n    while let Some(next) = res.data().await {\n        let chunk = next?;\n        resp_data.extend_from_slice(&chunk);\n    }\n    println!("{}", String::from_utf8_lossy(&resp_data));\n\n    Ok(())\n}\n')),(0,r.kt)("h2",{id:"the-http_req-api"},"The http_req API"),(0,r.kt)("p",null,"If your WasmEdge application only needs to make sequential requests to external web services, a synchronous client is easier to work with. It allows you to make a request, wait for the response, and move on once the response is fully received. Use the ",(0,r.kt)("inlineCode",{parentName:"p"},"http_req")," API to make simple synchronous HTTP requests. Build and run ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/second-state/http_req/"},"the example")," in WasmEdge."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"git clone https://github.com/second-state/http_req\ncd http_req/\n\n# Build the Rust Code\ncargo build --target wasm32-wasi --release\n# Use the AoT compiler to get better performance\nwasmedge compile target/wasm32-wasi/release/get.wasm get.wasm\n\n# Run the example\nwasmedge get.wasm\n... ...\nwasmedge get_https.wasm\n... ...\n")),(0,r.kt)("p",null,"In your Rust application, import the ",(0,r.kt)("a",{parentName:"p",href:"https://crates.io/crates/http_req_wasi"},"http_req_wasi")," crate, which is compatible with ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/jayjamesjay/http_req"},"http_req")," at the API level. Just add the following line to your ",(0,r.kt)("inlineCode",{parentName:"p"},"Cargo.toml"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-toml"},'[dependencies]\nhttp_req_wasi  = "0.10"\n')),(0,r.kt)("p",null,"The example below shows an ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/second-state/http_req/blob/master/examples/get.rs"},"HTTP GET request"),". For HTTPS requests, you can ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/second-state/http_req/blob/master/examples/get_https.rs"},"simply change")," the ",(0,r.kt)("inlineCode",{parentName:"p"},"http")," URL to ",(0,r.kt)("inlineCode",{parentName:"p"},"https"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},'use http_req::request;\n\nfn main() {\n    let mut writer = Vec::new(); //container for body of a response\n    let res = request::get("http://eu.httpbin.org/get?msg=WasmEdge", &mut writer).unwrap();\n\n    println!("Status: {} {}", res.status_code(), res.reason());\n    println!("Headers {}", res.headers());\n    println!("{}", String::from_utf8_lossy(&writer));\n}\n')),(0,r.kt)("p",null,"And here is an ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/second-state/http_req/blob/master/examples/post.rs"},"HTTP POST request"),". For HTTPS requests, you can ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/second-state/http_req/blob/master/examples/post_https.rs"},"simply change")," the ",(0,r.kt)("inlineCode",{parentName:"p"},"http")," URL to ",(0,r.kt)("inlineCode",{parentName:"p"},"https"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},'use http_req::request;\n\nfn main() {\n    let mut writer = Vec::new(); //container for body of a response\n    const BODY: &[u8; 27] = b"field1=value1&field2=value2";\n    let res = request::post("http://eu.httpbin.org/post", BODY, &mut writer).unwrap();\n\n    println!("Status: {} {}", res.status_code(), res.reason());\n    println!("Headers {}", res.headers());\n    println!("{}", String::from_utf8_lossy(&writer));\n}\n')),(0,r.kt)("h2",{id:"the-reqwest-api"},"The reqwest API"),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"reqwest")," crate is another popular Rust library to create asynchronous HTTP clients. It is built on top of the ",(0,r.kt)("inlineCode",{parentName:"p"},"hyper")," API. Many developers find it easier to use. But perhaps more importantly, many existing Rust applications use ",(0,r.kt)("inlineCode",{parentName:"p"},"reqwest"),", and you can make them work in WasmEdge by simply replacing the ",(0,r.kt)("inlineCode",{parentName:"p"},"reqwest")," crate with ",(0,r.kt)("inlineCode",{parentName:"p"},"reqwest_wasi"),"! Build and run ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/WasmEdge/wasmedge_reqwest_demo/"},"the example")," in WasmEdge as follows."),(0,r.kt)("admonition",{type:"note"},(0,r.kt)("p",{parentName:"admonition"},"Our current adaptation of ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/wasmedge/reqwest"},"reqwest_wasi")," does not support HTTPS yet. You are welcome to contribute to the project!")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"git clone https://github.com/WasmEdge/wasmedge_reqwest_demo\ncd wasmedge_reqwest_demo\n\n# Build the Rust code\ncargo build --target wasm32-wasi --release\n# Use the AoT compiler to get better performance\nwasmedge compile target/wasm32-wasi/release/wasmedge_reqwest_demo.wasm wasmedge_reqwest_demo.wasm\n\n# Run the example\nwasmedge wasmedge_reqwest_demo.wasm\n")),(0,r.kt)("p",null,"In your Rust application, import ",(0,r.kt)("a",{parentName:"p",href:"https://crates.io/crates/reqwest_wasi"},"the WasmEdge adapted reqwest crate"),", which uses a special version of single-threaded Tokio that is adapted for WebAssembly. Just add the following lines to your ",(0,r.kt)("inlineCode",{parentName:"p"},"Cargo.toml"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-toml"},'[dependencies]\nreqwest_wasi = { version = "0.11", features = ["json"] }\ntokio_wasi = { version = "1.21", features = ["full"] }\n')),(0,r.kt)("p",null,"The ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/WasmEdge/wasmedge_reqwest_demo/blob/main/src/main.rs"},"example Rust code")," below shows an HTTP GET request."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},'use std::collections::HashMap;\n\n#[tokio::main]\nasync fn main() -> Result<(), Box<dyn std::error::Error>> {\n    let resp = reqwest::get("http://eu.httpbin.org/ip")\n        .await?\n        .json::<HashMap<String, String>>()\n        .await?;\n    println!("{:#?}", resp);\n    Ok(())\n}\n')),(0,r.kt)("p",null,"And here is an HTTP POST request."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},'    let client = reqwest::Client::new();\n\n    let res = client\n        .post("http://eu.httpbin.org/post")\n        .body("msg=WasmEdge")\n        .send()\n        .await?;\n    let body = res.text().await?;\n\n    println!("POST: {}", body);\n')))}u.isMDXComponent=!0}}]);