"use strict";(self.webpackChunkbook=self.webpackChunkbook||[]).push([[6357],{3905:(e,t,n)=>{n.d(t,{Zo:()=>d,kt:()=>g});var a=n(7294);function s(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){s(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function r(e,t){if(null==e)return{};var n,a,s=function(e,t){if(null==e)return{};var n,a,s={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(s[n]=e[n]);return s}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(s[n]=e[n])}return s}var l=a.createContext({}),m=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},d=function(e){var t=m(e.components);return a.createElement(l.Provider,{value:t},e.children)},p="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},c=a.forwardRef((function(e,t){var n=e.components,s=e.mdxType,o=e.originalType,l=e.parentName,d=r(e,["components","mdxType","originalType","parentName"]),p=m(n),c=s,g=p["".concat(l,".").concat(c)]||p[c]||u[c]||o;return n?a.createElement(g,i(i({ref:t},d),{},{components:n})):a.createElement(g,i({ref:t},d))}));function g(e,t){var n=arguments,s=t&&t.mdxType;if("string"==typeof e||s){var o=n.length,i=new Array(o);i[0]=c;var r={};for(var l in t)hasOwnProperty.call(t,l)&&(r[l]=t[l]);r.originalType=e,r[p]="string"==typeof e?e:s,i[1]=r;for(var m=2;m<o;m++)i[m]=n[m];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}c.displayName="MDXCreateElement"},1101:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>i,default:()=>p,frontMatter:()=>o,metadata:()=>r,toc:()=>m});var a=n(7462),s=(n(7294),n(3905));const o={sidebar_position:2},i="4.5.2 C API 0.11.2  Documentation",r={unversionedId:"embed/c/reference/0.11.2",id:"embed/c/reference/0.11.2",title:"4.5.2 C API 0.11.2  Documentation",description:"WasmEdge C API denotes an interface to access the WasmEdge runtime. The following are the guides to working with the C APIs of WasmEdge.",source:"@site/docs/embed/c/reference/0.11.2.md",sourceDirName:"embed/c/reference",slug:"/embed/c/reference/0.11.2",permalink:"/book/embed/c/reference/0.11.2",draft:!1,editUrl:"https://github.com/alabulei1/book/docs/embed/c/reference/0.11.2.md",tags:[],version:"current",sidebarPosition:2,frontMatter:{sidebar_position:2},sidebar:"embedSidebar",previous:{title:"4.5.1  0.12.0 API Documentation",permalink:"/book/embed/c/reference/ref"},next:{title:"4.4.3 Upgrade to WasmEdge 0.11.0",permalink:"/book/embed/c/reference/upgrade_to_0.11.0"}},l={},m=[{value:"Table of Contents",id:"table-of-contents",level:2},{value:"WasmEdge Installation",id:"wasmedge-installation",level:2},{value:"Download And Install",id:"download-and-install",level:3},{value:"Compile Sources",id:"compile-sources",level:3},{value:"ABI Compatibility",id:"abi-compatibility",level:3},{value:"WasmEdge Basics",id:"wasmedge-basics",level:2},{value:"Version",id:"version",level:3},{value:"Logging Settings",id:"logging-settings",level:3},{value:"Value Types",id:"value-types",level:3},{value:"Strings",id:"strings",level:3},{value:"Results",id:"results",level:3},{value:"Contexts",id:"contexts",level:3},{value:"WASM Data Structures",id:"wasm-data-structures",level:3},{value:"Async",id:"async",level:3},{value:"Configurations",id:"configurations",level:3},{value:"Statistics",id:"statistics",level:3},{value:"Tools Driver",id:"tools-driver",level:3},{value:"WasmEdge VM",id:"wasmedge-vm",level:2},{value:"WASM Execution Example With VM Context",id:"wasm-execution-example-with-vm-context",level:3},{value:"VM Creations",id:"vm-creations",level:3},{value:"Preregistrations",id:"preregistrations",level:3},{value:"Host Module Registrations",id:"host-module-registrations",level:3},{value:"WASM Registrations And Executions",id:"wasm-registrations-and-executions",level:3},{value:"Asynchronous Execution",id:"asynchronous-execution",level:3},{value:"Instance Tracing",id:"instance-tracing",level:3},{value:"WasmEdge Runtime",id:"wasmedge-runtime",level:2},{value:"WASM Execution Example Step-By-Step",id:"wasm-execution-example-step-by-step",level:3},{value:"Loader",id:"loader",level:3},{value:"Validator",id:"validator",level:3},{value:"Executor",id:"executor",level:3},{value:"AST Module",id:"ast-module",level:3},{value:"Store",id:"store",level:3},{value:"Instances",id:"instances",level:3},{value:"Host Functions",id:"host-functions",level:3},{value:"WasmEdge AOT Compiler",id:"wasmedge-aot-compiler",level:2},{value:"Compilation Example",id:"compilation-example",level:3},{value:"Compiler Options",id:"compiler-options",level:3}],d={toc:m};function p(e){let{components:t,...n}=e;return(0,s.kt)("wrapper",(0,a.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,s.kt)("h1",{id:"452-c-api-0112--documentation"},"4.5.2 C API 0.11.2  Documentation"),(0,s.kt)("p",null,(0,s.kt)("a",{parentName:"p",href:"https://github.com/WasmEdge/WasmEdge/blob/master/include/api/wasmedge/wasmedge.h"},"WasmEdge C API")," denotes an interface to access the WasmEdge runtime. The following are the guides to working with the C APIs of WasmEdge."),(0,s.kt)("p",null,(0,s.kt)("strong",{parentName:"p"},"Please notice that the WasmEdge C API provides SONAME and SOVERSION after the ",(0,s.kt)("inlineCode",{parentName:"strong"},"0.11.0")," release.")),(0,s.kt)("p",null,(0,s.kt)("strong",{parentName:"p"},"Please notice that ",(0,s.kt)("inlineCode",{parentName:"strong"},"libwasmedge_c.so")," is renamed to ",(0,s.kt)("inlineCode",{parentName:"strong"},"libwasmedge.so")," after the ",(0,s.kt)("inlineCode",{parentName:"strong"},"0.11.0")," release. Please use ",(0,s.kt)("inlineCode",{parentName:"strong"},"-lwasmedge")," instead of ",(0,s.kt)("inlineCode",{parentName:"strong"},"-lwasmedge_c")," for the linker option.")),(0,s.kt)("p",null,(0,s.kt)("strong",{parentName:"p"},"This document is for the ",(0,s.kt)("inlineCode",{parentName:"strong"},"0.11.2")," version. For the older ",(0,s.kt)("inlineCode",{parentName:"strong"},"0.10.1")," version, please refer to the ",(0,s.kt)("a",{parentName:"strong",href:"/book/embed/c/reference/0.10.1"},"document here"),".")),(0,s.kt)("p",null,(0,s.kt)("strong",{parentName:"p"},"Developers can refer to ",(0,s.kt)("a",{parentName:"strong",href:"/book/embed/c/reference/upgrade_to_0.11.0"},"here to upgrade to 0.11.0"),".")),(0,s.kt)("h2",{id:"table-of-contents"},"Table of Contents"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("a",{parentName:"li",href:"#wasmedge-installation"},"WasmEdge Installation"),(0,s.kt)("ul",{parentName:"li"},(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("a",{parentName:"li",href:"#download-and-install"},"Download And Install")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("a",{parentName:"li",href:"#compile-sources"},"Compile Sources")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("a",{parentName:"li",href:"#abi-compatibility"},"ABI Compatibility")))),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("a",{parentName:"li",href:"#wasmedge-basics"},"WasmEdge Basics"),(0,s.kt)("ul",{parentName:"li"},(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("a",{parentName:"li",href:"#version"},"Version")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("a",{parentName:"li",href:"#logging-settings"},"Logging Settings")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("a",{parentName:"li",href:"#value-types"},"Value Types")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("a",{parentName:"li",href:"#strings"},"Strings")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("a",{parentName:"li",href:"#results"},"Results")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("a",{parentName:"li",href:"#contexts"},"Contexts")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("a",{parentName:"li",href:"#wasm-data-structures"},"WASM data structures")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("a",{parentName:"li",href:"#async"},"Async")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("a",{parentName:"li",href:"#configurations"},"Configurations")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("a",{parentName:"li",href:"#statistics"},"Statistics")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("a",{parentName:"li",href:"#tools-driver"},"Tools driver")))),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("a",{parentName:"li",href:"#wasmedge-vm"},"WasmEdge VM"),(0,s.kt)("ul",{parentName:"li"},(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("a",{parentName:"li",href:"#wasm-execution-example-with-vm-context"},"WASM Execution Example With VM Context")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("a",{parentName:"li",href:"#vm-creations"},"VM Creations")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("a",{parentName:"li",href:"#preregistrations"},"Preregistrations")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("a",{parentName:"li",href:"#host-module-registrations"},"Host Module Registrations")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("a",{parentName:"li",href:"#wasm-registrations-and-executions"},"WASM Registrations And Executions")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("a",{parentName:"li",href:"#asynchronous-execution"},"Asynchronous execution")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("a",{parentName:"li",href:"#instance-tracing"},"Instance Tracing")))),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("a",{parentName:"li",href:"#wasmedge-runtime"},"WasmEdge Runtime"),(0,s.kt)("ul",{parentName:"li"},(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("a",{parentName:"li",href:"#wasm-execution-example-step-by-step"},"WASM Execution Example Step-By-Step")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("a",{parentName:"li",href:"#loader"},"Loader")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("a",{parentName:"li",href:"#validator"},"Validator")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("a",{parentName:"li",href:"#executor"},"Executor")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("a",{parentName:"li",href:"#ast-module"},"AST Module")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("a",{parentName:"li",href:"#store"},"Store")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("a",{parentName:"li",href:"#instances"},"Instances")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("a",{parentName:"li",href:"#host-functions"},"Host Functions")))),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("a",{parentName:"li",href:"#wasmedge-aot-compiler"},"WasmEdge AOT Compiler"),(0,s.kt)("ul",{parentName:"li"},(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("a",{parentName:"li",href:"#compilation-example"},"Compilation Example")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("a",{parentName:"li",href:"#compiler-options"},"Compiler Options"))))),(0,s.kt)("h2",{id:"wasmedge-installation"},"WasmEdge Installation"),(0,s.kt)("h3",{id:"download-and-install"},"Download And Install"),(0,s.kt)("p",null,"The easiest way to install WasmEdge is to run the following command. Your system should have ",(0,s.kt)("inlineCode",{parentName:"p"},"git")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"wget")," as prerequisites."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-bash"},"curl -sSf https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/utils/install.sh | bash -s -- -v 0.11.2\n")),(0,s.kt)("p",null,"For more details, please refer to the ",(0,s.kt)("a",{parentName:"p",href:"/book/develop/build-and-run/install"},"Installation Guide")," for the WasmEdge installation."),(0,s.kt)("h3",{id:"compile-sources"},"Compile Sources"),(0,s.kt)("p",null,"After the installation of WasmEdge, the following guide can help you to test for the availability of the WasmEdge C API."),(0,s.kt)("ol",null,(0,s.kt)("li",{parentName:"ol"},(0,s.kt)("p",{parentName:"li"},"Prepare the test C file (and assumed saved as ",(0,s.kt)("inlineCode",{parentName:"p"},"test.c"),"):"),(0,s.kt)("pre",{parentName:"li"},(0,s.kt)("code",{parentName:"pre",className:"language-c"},'#include <wasmedge/wasmedge.h>\n#include <stdio.h>\nint main() {\n  printf("WasmEdge version: %s\\n", WasmEdge_VersionGet());\n  return 0;\n}\n'))),(0,s.kt)("li",{parentName:"ol"},(0,s.kt)("p",{parentName:"li"},"Compile the file with ",(0,s.kt)("inlineCode",{parentName:"p"},"gcc")," or ",(0,s.kt)("inlineCode",{parentName:"p"},"clang"),"."),(0,s.kt)("pre",{parentName:"li"},(0,s.kt)("code",{parentName:"pre",className:"language-bash"},"gcc test.c -lwasmedge\n"))),(0,s.kt)("li",{parentName:"ol"},(0,s.kt)("p",{parentName:"li"},"Run and get the expected output."),(0,s.kt)("pre",{parentName:"li"},(0,s.kt)("code",{parentName:"pre",className:"language-bash"},"$ ./a.out\nWasmEdge version: 0.11.2\n")))),(0,s.kt)("h3",{id:"abi-compatibility"},"ABI Compatibility"),(0,s.kt)("p",null,"WasmEdge C API introduces SONAME and SOVERSION in the 0.11.0 release to present the compatibility between different C API versions."),(0,s.kt)("p",null,"The releases before 0.11.0 are all unversioned. Please make sure the library version is the same as the corresponding C API version you used."),(0,s.kt)("table",null,(0,s.kt)("thead",{parentName:"table"},(0,s.kt)("tr",{parentName:"thead"},(0,s.kt)("th",{parentName:"tr",align:null},"WasmEdge Version"),(0,s.kt)("th",{parentName:"tr",align:null},"WasmEdge C API Library Name"),(0,s.kt)("th",{parentName:"tr",align:null},"WasmEdge C API SONAME"),(0,s.kt)("th",{parentName:"tr",align:null},"WasmEdge C API SOVERSION"))),(0,s.kt)("tbody",{parentName:"table"},(0,s.kt)("tr",{parentName:"tbody"},(0,s.kt)("td",{parentName:"tr",align:null},"< 0.11.0"),(0,s.kt)("td",{parentName:"tr",align:null},"libwasmedge","_","c.so"),(0,s.kt)("td",{parentName:"tr",align:null},"Unversioned"),(0,s.kt)("td",{parentName:"tr",align:null},"Unversioned")),(0,s.kt)("tr",{parentName:"tbody"},(0,s.kt)("td",{parentName:"tr",align:null},"0.11.0 to 0.11.1"),(0,s.kt)("td",{parentName:"tr",align:null},"libwasmedge.so"),(0,s.kt)("td",{parentName:"tr",align:null},"libwasmedge.so.0"),(0,s.kt)("td",{parentName:"tr",align:null},"libwasmedge.so.0.0.0")),(0,s.kt)("tr",{parentName:"tbody"},(0,s.kt)("td",{parentName:"tr",align:null},"since 0.11.2"),(0,s.kt)("td",{parentName:"tr",align:null},"libwasmedge.so"),(0,s.kt)("td",{parentName:"tr",align:null},"libwasmedge.so.0"),(0,s.kt)("td",{parentName:"tr",align:null},"libwasmedge.so.0.0.1")))),(0,s.kt)("h2",{id:"wasmedge-basics"},"WasmEdge Basics"),(0,s.kt)("p",null,"In this part, we will introduce the utilities and concepts of WasmEdge shared library."),(0,s.kt)("h3",{id:"version"},"Version"),(0,s.kt)("p",null,"The ",(0,s.kt)("inlineCode",{parentName:"p"},"Version")," related APIs provide developers to check for the WasmEdge shared library version."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-c"},'#include <wasmedge/wasmedge.h>\nprintf("WasmEdge version: %s\\n", WasmEdge_VersionGet());\nprintf("WasmEdge version major: %u\\n", WasmEdge_VersionGetMajor());\nprintf("WasmEdge version minor: %u\\n", WasmEdge_VersionGetMinor());\nprintf("WasmEdge version patch: %u\\n", WasmEdge_VersionGetPatch());\n')),(0,s.kt)("h3",{id:"logging-settings"},"Logging Settings"),(0,s.kt)("p",null,"The ",(0,s.kt)("inlineCode",{parentName:"p"},"WasmEdge_LogSetErrorLevel()")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"WasmEdge_LogSetDebugLevel()")," APIs can set the logging system to debug level or error level. By default, the error level is set, and the debug info is hidden."),(0,s.kt)("p",null,"Developers can also use the ",(0,s.kt)("inlineCode",{parentName:"p"},"WasmEdge_LogOff()")," API to disable all logging. (",(0,s.kt)("inlineCode",{parentName:"p"},"0.11.2")," or upper only)"),(0,s.kt)("h3",{id:"value-types"},"Value Types"),(0,s.kt)("p",null,"In WasmEdge, developers should convert the values to ",(0,s.kt)("inlineCode",{parentName:"p"},"WasmEdge_Value")," objects through APIs for matching to the WASM value types."),(0,s.kt)("ol",null,(0,s.kt)("li",{parentName:"ol"},(0,s.kt)("p",{parentName:"li"},"Number types: ",(0,s.kt)("inlineCode",{parentName:"p"},"i32"),", ",(0,s.kt)("inlineCode",{parentName:"p"},"i64"),", ",(0,s.kt)("inlineCode",{parentName:"p"},"f32"),", ",(0,s.kt)("inlineCode",{parentName:"p"},"f64"),", and ",(0,s.kt)("inlineCode",{parentName:"p"},"v128")," for the ",(0,s.kt)("inlineCode",{parentName:"p"},"SIMD")," proposal"),(0,s.kt)("pre",{parentName:"li"},(0,s.kt)("code",{parentName:"pre",className:"language-c"},'WasmEdge_Value Val;\nVal = WasmEdge_ValueGenI32(123456);\nprintf("%d\\n", WasmEdge_ValueGetI32(Val));\n/* Will print "123456" */\nVal = WasmEdge_ValueGenI64(1234567890123LL);\nprintf("%ld\\n", WasmEdge_ValueGetI64(Val));\n/* Will print "1234567890123" */\nVal = WasmEdge_ValueGenF32(123.456f);\nprintf("%f\\n", WasmEdge_ValueGetF32(Val));\n/* Will print "123.456001" */\nVal = WasmEdge_ValueGenF64(123456.123456789);\nprintf("%.10f\\n", WasmEdge_ValueGetF64(Val));\n/* Will print "123456.1234567890" */\n'))),(0,s.kt)("li",{parentName:"ol"},(0,s.kt)("p",{parentName:"li"},"Reference types: ",(0,s.kt)("inlineCode",{parentName:"p"},"funcref")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"externref")," for the ",(0,s.kt)("inlineCode",{parentName:"p"},"Reference-Types")," proposal"),(0,s.kt)("pre",{parentName:"li"},(0,s.kt)("code",{parentName:"pre",className:"language-c"},'WasmEdge_Value Val;\nvoid *Ptr;\nbool IsNull;\nuint32_t Num = 10;\n/* Generate a externref to NULL. */\nVal = WasmEdge_ValueGenNullRef(WasmEdge_RefType_ExternRef);\nIsNull = WasmEdge_ValueIsNullRef(Val);\n/* The `IsNull` will be `TRUE`. */\nPtr = WasmEdge_ValueGetExternRef(Val);\n/* The `Ptr` will be `NULL`. */\n\n/* Get the function instance by creation or from module instance. */\nconst WasmEdge_FunctionInstanceContext *FuncCxt = ...;\n/* Generate a funcref with the given function instance context. */\nVal = WasmEdge_ValueGenFuncRef(FuncCxt);\nconst WasmEdge_FunctionInstanceContext *GotFuncCxt =\n    WasmEdge_ValueGetFuncRef(Val);\n/* The `GotFuncCxt` will be the same as `FuncCxt`. */\n\n/* Generate a externref to `Num`. */\nVal = WasmEdge_ValueGenExternRef(&Num);\nPtr = WasmEdge_ValueGetExternRef(Val);\n/* The `Ptr` will be `&Num`. */\nprintf("%u\\n", *(uint32_t *)Ptr);\n/* Will print "10" */\nNum += 55;\nprintf("%u\\n", *(uint32_t *)Ptr);\n/* Will print "65" */\n')))),(0,s.kt)("h3",{id:"strings"},"Strings"),(0,s.kt)("p",null,"The ",(0,s.kt)("inlineCode",{parentName:"p"},"WasmEdge_String")," object is for the instance names when invoking a WASM function or finding the contexts of instances."),(0,s.kt)("ol",null,(0,s.kt)("li",{parentName:"ol"},(0,s.kt)("p",{parentName:"li"},"Create a ",(0,s.kt)("inlineCode",{parentName:"p"},"WasmEdge_String")," from a C string (",(0,s.kt)("inlineCode",{parentName:"p"},"const char *")," with NULL termination) or a buffer with length."),(0,s.kt)("p",{parentName:"li"},"The content of the C string or buffer will be copied into the ",(0,s.kt)("inlineCode",{parentName:"p"},"WasmEdge_String")," object."),(0,s.kt)("pre",{parentName:"li"},(0,s.kt)("code",{parentName:"pre",className:"language-c"},'char Buf[4] = {50, 55, 60, 65};\nWasmEdge_String Str1 = WasmEdge_StringCreateByCString("test");\nWasmEdge_String Str2 = WasmEdge_StringCreateByBuffer(Buf, 4);\n/* The objects should be deleted by `WasmEdge_StringDelete()`. */\nWasmEdge_StringDelete(Str1);\nWasmEdge_StringDelete(Str2);\n'))),(0,s.kt)("li",{parentName:"ol"},(0,s.kt)("p",{parentName:"li"},"Wrap a ",(0,s.kt)("inlineCode",{parentName:"p"},"WasmEdge_String")," to a buffer with length."),(0,s.kt)("p",{parentName:"li"},"The content will not be copied, and the caller should guarantee the life cycle of the input buffer."),(0,s.kt)("pre",{parentName:"li"},(0,s.kt)("code",{parentName:"pre",className:"language-c"},'const char CStr[] = "test";\nWasmEdge_String Str = WasmEdge_StringWrap(CStr, 4);\n/* The object should __NOT__ be deleted by `WasmEdge_StringDelete()`. */\n'))),(0,s.kt)("li",{parentName:"ol"},(0,s.kt)("p",{parentName:"li"},"String comparison"),(0,s.kt)("pre",{parentName:"li"},(0,s.kt)("code",{parentName:"pre",className:"language-c"},'const char CStr[] = "abcd";\nchar Buf[4] = {0x61, 0x62, 0x63, 0x64};\nWasmEdge_String Str1 = WasmEdge_StringWrap(CStr, 4);\nWasmEdge_String Str2 = WasmEdge_StringCreateByBuffer(Buf, 4);\nbool IsEq = WasmEdge_StringIsEqual(Str1, Str2);\n/* The `IsEq` will be `TRUE`. */\nWasmEdge_StringDelete(Str2);\n'))),(0,s.kt)("li",{parentName:"ol"},(0,s.kt)("p",{parentName:"li"},"Convert to C string"),(0,s.kt)("pre",{parentName:"li"},(0,s.kt)("code",{parentName:"pre",className:"language-c"},'char Buf[256];\nWasmEdge_String Str =\n    WasmEdge_StringCreateByCString("test_wasmedge_string");\nuint32_t StrLength = WasmEdge_StringCopy(Str, Buf, sizeof(Buf));\n/* StrLength will be 20 */\nprintf("String: %s\\n", Buf);\n/* Will print "test_wasmedge_string". */\n')))),(0,s.kt)("h3",{id:"results"},"Results"),(0,s.kt)("p",null,"The ",(0,s.kt)("inlineCode",{parentName:"p"},"WasmEdge_Result")," object specifies the execution status.\nAPIs about WASM execution will return the ",(0,s.kt)("inlineCode",{parentName:"p"},"WasmEdge_Result")," to denote the status."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-c"},'WasmEdge_Result Res = WasmEdge_Result_Success;\nbool IsSucceeded = WasmEdge_ResultOK(Res);\n/* The `IsSucceeded` will be `TRUE`. */\nuint32_t Code = WasmEdge_ResultGetCode(Res);\n/* The `Code` will be 0. */\nconst char *Msg = WasmEdge_ResultGetMessage(Res);\n/* The `Msg` will be "success". */\nenum WasmEdge_ErrCategory Category = WasmEdge_ResultGetCategory(Res);\n/* The `Category` will be WasmEdge_ErrCategory_WASM. */\n\nRes = WasmEdge_ResultGen(WasmEdge_ErrCategory_UserLevelError, 123);\n/* Generate the user-defined result with code. */\nCode = WasmEdge_ResultGetCode(Res);\n/* The `Code` will be 123. */\nCategory = WasmEdge_ResultGetCategory(Res);\n/* The `Category` will be WasmEdge_ErrCategory_UserLevelError. */\n')),(0,s.kt)("h3",{id:"contexts"},"Contexts"),(0,s.kt)("p",null,"The objects, such as ",(0,s.kt)("inlineCode",{parentName:"p"},"VM"),", ",(0,s.kt)("inlineCode",{parentName:"p"},"Store"),", and ",(0,s.kt)("inlineCode",{parentName:"p"},"Function"),", are composed of ",(0,s.kt)("inlineCode",{parentName:"p"},"Context"),"s.\nAll of the contexts can be created by calling the corresponding creation APIs and should be destroyed by calling the corresponding deletion APIs. Developers have responsibilities to manage the contexts for memory management."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-c"},"/* Create the configure context. */\nWasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();\n/* Delete the configure context. */\nWasmEdge_ConfigureDelete(ConfCxt);\n")),(0,s.kt)("p",null,"The details of other contexts will be introduced later."),(0,s.kt)("h3",{id:"wasm-data-structures"},"WASM Data Structures"),(0,s.kt)("p",null,"The WASM data structures are used for creating instances or can be queried from instance contexts.\nThe details of instances creation will be introduced in the ",(0,s.kt)("a",{parentName:"p",href:"#instances"},"Instances"),"."),(0,s.kt)("ol",null,(0,s.kt)("li",{parentName:"ol"},(0,s.kt)("p",{parentName:"li"},"Limit"),(0,s.kt)("p",{parentName:"li"},"The ",(0,s.kt)("inlineCode",{parentName:"p"},"WasmEdge_Limit")," struct is defined in the header:"),(0,s.kt)("pre",{parentName:"li"},(0,s.kt)("code",{parentName:"pre",className:"language-c"},"/// Struct of WASM limit.\ntypedef struct WasmEdge_Limit {\n  /// Boolean to describe has max value or not.\n  bool HasMax;\n  /// Boolean to describe is shared memory or not.\n  bool Shared;\n  /// Minimum value.\n  uint32_t Min;\n  /// Maximum value. Will be ignored if the `HasMax` is false.\n  uint32_t Max;\n} WasmEdge_Limit;\n")),(0,s.kt)("p",{parentName:"li"},"Developers can initialize the struct by assigning it's value, and the ",(0,s.kt)("inlineCode",{parentName:"p"},"Max")," value is needed to be larger or equal to the ",(0,s.kt)("inlineCode",{parentName:"p"},"Min")," value.\nThe API ",(0,s.kt)("inlineCode",{parentName:"p"},"WasmEdge_LimitIsEqual()")," is provided to compare with 2 ",(0,s.kt)("inlineCode",{parentName:"p"},"WasmEdge_Limit")," structs.")),(0,s.kt)("li",{parentName:"ol"},(0,s.kt)("p",{parentName:"li"},"Function type context"),(0,s.kt)("p",{parentName:"li"},"The ",(0,s.kt)("inlineCode",{parentName:"p"},"Function Type")," context is used for the ",(0,s.kt)("inlineCode",{parentName:"p"},"Function")," creation, checking the value types of a ",(0,s.kt)("inlineCode",{parentName:"p"},"Function")," instance, or getting the function type with function name from VM. Developers can use the ",(0,s.kt)("inlineCode",{parentName:"p"},"Function Type")," context APIs to get the parameter or return value types information."),(0,s.kt)("pre",{parentName:"li"},(0,s.kt)("code",{parentName:"pre",className:"language-c"},"enum WasmEdge_ValType ParamList[2] = {WasmEdge_ValType_I32,\n                                      WasmEdge_ValType_I64};\nenum WasmEdge_ValType ReturnList[1] = {WasmEdge_ValType_FuncRef};\nWasmEdge_FunctionTypeContext *FuncTypeCxt =\n    WasmEdge_FunctionTypeCreate(ParamList, 2, ReturnList, 1);\n\nenum WasmEdge_ValType Buf[16];\nuint32_t ParamLen = WasmEdge_FunctionTypeGetParametersLength(FuncTypeCxt);\n/* `ParamLen` will be 2. */\nuint32_t GotParamLen =\n    WasmEdge_FunctionTypeGetParameters(FuncTypeCxt, Buf, 16);\n/* `GotParamLen` will be 2, and `Buf[0]` and `Buf[1]` will be the same as\n * `ParamList`. */\nuint32_t ReturnLen = WasmEdge_FunctionTypeGetReturnsLength(FuncTypeCxt);\n/* `ReturnLen` will be 1. */\nuint32_t GotReturnLen =\n    WasmEdge_FunctionTypeGetReturns(FuncTypeCxt, Buf, 16);\n/* `GotReturnLen` will be 1, and `Buf[0]` will be the same as `ReturnList`.\n */\n\nWasmEdge_FunctionTypeDelete(FuncTypeCxt);\n"))),(0,s.kt)("li",{parentName:"ol"},(0,s.kt)("p",{parentName:"li"},"Table type context"),(0,s.kt)("p",{parentName:"li"},"The ",(0,s.kt)("inlineCode",{parentName:"p"},"Table Type")," context is used for ",(0,s.kt)("inlineCode",{parentName:"p"},"Table")," instance creation or getting information from ",(0,s.kt)("inlineCode",{parentName:"p"},"Table")," instances."),(0,s.kt)("pre",{parentName:"li"},(0,s.kt)("code",{parentName:"pre",className:"language-c"},"WasmEdge_Limit TabLim = {\n    .HasMax = true, .Shared = false, .Min = 10, .Max = 20};\nWasmEdge_TableTypeContext *TabTypeCxt =\n    WasmEdge_TableTypeCreate(WasmEdge_RefType_ExternRef, TabLim);\n\nenum WasmEdge_RefType GotRefType = WasmEdge_TableTypeGetRefType(TabTypeCxt);\n/* `GotRefType` will be WasmEdge_RefType_ExternRef. */\nWasmEdge_Limit GotTabLim = WasmEdge_TableTypeGetLimit(TabTypeCxt);\n/* `GotTabLim` will be the same value as `TabLim`. */\n\nWasmEdge_TableTypeDelete(TabTypeCxt);\n"))),(0,s.kt)("li",{parentName:"ol"},(0,s.kt)("p",{parentName:"li"},"Memory type context"),(0,s.kt)("p",{parentName:"li"},"The ",(0,s.kt)("inlineCode",{parentName:"p"},"Memory Type")," context is used for ",(0,s.kt)("inlineCode",{parentName:"p"},"Memory")," instance creation or getting information from ",(0,s.kt)("inlineCode",{parentName:"p"},"Memory")," instances."),(0,s.kt)("pre",{parentName:"li"},(0,s.kt)("code",{parentName:"pre",className:"language-c"},"WasmEdge_Limit MemLim = {\n    .HasMax = true, .Shared = false, .Min = 10, .Max = 20};\nWasmEdge_MemoryTypeContext *MemTypeCxt = WasmEdge_MemoryTypeCreate(MemLim);\n\nWasmEdge_Limit GotMemLim = WasmEdge_MemoryTypeGetLimit(MemTypeCxt);\n/* `GotMemLim` will be the same value as `MemLim`. */\n\nWasmEdge_MemoryTypeDelete(MemTypeCxt)\n"))),(0,s.kt)("li",{parentName:"ol"},(0,s.kt)("p",{parentName:"li"},"Global type context"),(0,s.kt)("p",{parentName:"li"},"The ",(0,s.kt)("inlineCode",{parentName:"p"},"Global Type")," context is used for ",(0,s.kt)("inlineCode",{parentName:"p"},"Global")," instance creation or getting information from ",(0,s.kt)("inlineCode",{parentName:"p"},"Global")," instances."),(0,s.kt)("pre",{parentName:"li"},(0,s.kt)("code",{parentName:"pre",className:"language-c"},"WasmEdge_GlobalTypeContext *GlobTypeCxt = WasmEdge_GlobalTypeCreate(\n    WasmEdge_ValType_F64, WasmEdge_Mutability_Var);\n\nWasmEdge_ValType GotValType = WasmEdge_GlobalTypeGetValType(GlobTypeCxt);\n/* `GotValType` will be WasmEdge_ValType_F64. */\nWasmEdge_Mutability GotValMut =\n    WasmEdge_GlobalTypeGetMutability(GlobTypeCxt);\n/* `GotValMut` will be WasmEdge_Mutability_Var. */\n\nWasmEdge_GlobalTypeDelete(GlobTypeCxt);\n"))),(0,s.kt)("li",{parentName:"ol"},(0,s.kt)("p",{parentName:"li"},"Import type context"),(0,s.kt)("p",{parentName:"li"},"The ",(0,s.kt)("inlineCode",{parentName:"p"},"Import Type")," context is used for getting the imports information from a ",(0,s.kt)("a",{parentName:"p",href:"#ast-module"},"AST Module"),".\nDevelopers can get the external type (",(0,s.kt)("inlineCode",{parentName:"p"},"function"),", ",(0,s.kt)("inlineCode",{parentName:"p"},"table"),", ",(0,s.kt)("inlineCode",{parentName:"p"},"memory"),", or ",(0,s.kt)("inlineCode",{parentName:"p"},"global"),"), import module name, and external name from an ",(0,s.kt)("inlineCode",{parentName:"p"},"Import Type")," context.\nThe details about querying ",(0,s.kt)("inlineCode",{parentName:"p"},"Import Type")," contexts will be introduced in the ",(0,s.kt)("a",{parentName:"p",href:"#ast-module"},"AST Module"),"."),(0,s.kt)("pre",{parentName:"li"},(0,s.kt)("code",{parentName:"pre",className:"language-c"},"WasmEdge_ASTModuleContext *ASTCxt = ...;\n/*\n * Assume that `ASTCxt` is returned by the `WasmEdge_LoaderContext` for the\n * result of loading a WASM file.\n */\nconst WasmEdge_ImportTypeContext *ImpType = ...;\n/* Assume that `ImpType` is queried from the `ASTCxt` for the import. */\n\nenum WasmEdge_ExternalType ExtType =\n    WasmEdge_ImportTypeGetExternalType(ImpType);\n/*\n * The `ExtType` can be one of `WasmEdge_ExternalType_Function`,\n * `WasmEdge_ExternalType_Table`, `WasmEdge_ExternalType_Memory`, or\n * `WasmEdge_ExternalType_Global`.\n */\nWasmEdge_String ModName = WasmEdge_ImportTypeGetModuleName(ImpType);\nWasmEdge_String ExtName = WasmEdge_ImportTypeGetExternalName(ImpType);\n/*\n * The `ModName` and `ExtName` should not be destroyed and the string\n * buffers are binded into the `ASTCxt`.\n */\nconst WasmEdge_FunctionTypeContext *FuncTypeCxt =\n    WasmEdge_ImportTypeGetFunctionType(ASTCxt, ImpType);\n/*\n * If the `ExtType` is not `WasmEdge_ExternalType_Function`, the\n * `FuncTypeCxt` will be NULL.\n */\nconst WasmEdge_TableTypeContext *TabTypeCxt =\n    WasmEdge_ImportTypeGetTableType(ASTCxt, ImpType);\n/*\n * If the `ExtType` is not `WasmEdge_ExternalType_Table`, the `TabTypeCxt`\n * will be NULL.\n */\nconst WasmEdge_MemoryTypeContext *MemTypeCxt =\n    WasmEdge_ImportTypeGetMemoryType(ASTCxt, ImpType);\n/*\n * If the `ExtType` is not `WasmEdge_ExternalType_Memory`, the `MemTypeCxt`\n * will be NULL.\n */\nconst WasmEdge_GlobalTypeContext *GlobTypeCxt =\n    WasmEdge_ImportTypeGetGlobalType(ASTCxt, ImpType);\n/*\n * If the `ExtType` is not `WasmEdge_ExternalType_Global`, the `GlobTypeCxt`\n * will be NULL.\n */\n"))),(0,s.kt)("li",{parentName:"ol"},(0,s.kt)("p",{parentName:"li"},"Export type context"),(0,s.kt)("p",{parentName:"li"},"The ",(0,s.kt)("inlineCode",{parentName:"p"},"Export Type")," context is used for getting the exports information from a ",(0,s.kt)("a",{parentName:"p",href:"#ast-module"},"AST Module"),".\nDevelopers can get the external type (",(0,s.kt)("inlineCode",{parentName:"p"},"function"),", ",(0,s.kt)("inlineCode",{parentName:"p"},"table"),", ",(0,s.kt)("inlineCode",{parentName:"p"},"memory"),", or ",(0,s.kt)("inlineCode",{parentName:"p"},"global"),") and external name from an ",(0,s.kt)("inlineCode",{parentName:"p"},"Export Type")," context.\nThe details about querying ",(0,s.kt)("inlineCode",{parentName:"p"},"Export Type")," contexts will be introduced in the ",(0,s.kt)("a",{parentName:"p",href:"#ast-module"},"AST Module"),"."),(0,s.kt)("pre",{parentName:"li"},(0,s.kt)("code",{parentName:"pre",className:"language-c"},"WasmEdge_ASTModuleContext *ASTCxt = ...;\n/*\n * Assume that `ASTCxt` is returned by the `WasmEdge_LoaderContext` for the\n * result of loading a WASM file.\n */\nconst WasmEdge_ExportTypeContext *ExpType = ...;\n/* Assume that `ExpType` is queried from the `ASTCxt` for the export. */\n\nenum WasmEdge_ExternalType ExtType =\n    WasmEdge_ExportTypeGetExternalType(ExpType);\n/*\n * The `ExtType` can be one of `WasmEdge_ExternalType_Function`,\n * `WasmEdge_ExternalType_Table`, `WasmEdge_ExternalType_Memory`, or\n * `WasmEdge_ExternalType_Global`.\n */\nWasmEdge_String ExtName = WasmEdge_ExportTypeGetExternalName(ExpType);\n/*\n * The `ExtName` should not be destroyed and the string buffer is binded\n * into the `ASTCxt`.\n */\nconst WasmEdge_FunctionTypeContext *FuncTypeCxt =\n    WasmEdge_ExportTypeGetFunctionType(ASTCxt, ExpType);\n/*\n * If the `ExtType` is not `WasmEdge_ExternalType_Function`, the\n * `FuncTypeCxt` will be NULL.\n */\nconst WasmEdge_TableTypeContext *TabTypeCxt =\n    WasmEdge_ExportTypeGetTableType(ASTCxt, ExpType);\n/*\n * If the `ExtType` is not `WasmEdge_ExternalType_Table`, the `TabTypeCxt`\n * will be NULL.\n */\nconst WasmEdge_MemoryTypeContext *MemTypeCxt =\n    WasmEdge_ExportTypeGetMemoryType(ASTCxt, ExpType);\n/*\n * If the `ExtType` is not `WasmEdge_ExternalType_Memory`, the `MemTypeCxt`\n * will be NULL.\n */\nconst WasmEdge_GlobalTypeContext *GlobTypeCxt =\n    WasmEdge_ExportTypeGetGlobalType(ASTCxt, ExpType);\n/*\n * If the `ExtType` is not `WasmEdge_ExternalType_Global`, the `GlobTypeCxt`\n * will be NULL.\n */\n")))),(0,s.kt)("h3",{id:"async"},"Async"),(0,s.kt)("p",null,"After calling the ",(0,s.kt)("a",{parentName:"p",href:"#asynchronous-execution"},"asynchronous execution APIs"),", developers will get the ",(0,s.kt)("inlineCode",{parentName:"p"},"WasmEdge_Async")," object.\nDevelopers own the object and should call the ",(0,s.kt)("inlineCode",{parentName:"p"},"WasmEdge_AsyncDelete()")," API to destroy it."),(0,s.kt)("ol",null,(0,s.kt)("li",{parentName:"ol"},(0,s.kt)("p",{parentName:"li"},"Wait for the asynchronous execution"),(0,s.kt)("p",{parentName:"li"},"Developers can wait the execution until finished:"),(0,s.kt)("pre",{parentName:"li"},(0,s.kt)("code",{parentName:"pre",className:"language-c"},"WasmEdge_Async *Async = ...; /* Ignored. Asynchronous execute a function. */\n/* Blocking and waiting for the execution. */\nWasmEdge_AsyncWait(Async);\nWasmEdge_AsyncDelete(Async);\n")),(0,s.kt)("p",{parentName:"li"},"Or developers can wait for a time limit.\nIf the time limit exceeded, developers can choose to cancel the execution.\nFor the interruptible execution in AOT mode, developers should set ",(0,s.kt)("inlineCode",{parentName:"p"},"TRUE")," through the ",(0,s.kt)("inlineCode",{parentName:"p"},"WasmEdge_ConfigureCompilerSetInterruptible()")," API into the configure context for the AOT compiler."),(0,s.kt)("pre",{parentName:"li"},(0,s.kt)("code",{parentName:"pre",className:"language-c"},"WasmEdge_Async *Async = ...; /* Ignored. Asynchronous execute a function. */\n/* Blocking and waiting for the execution for 1 second. */\nbool IsEnd = WasmEdge_AsyncWaitFor(Async, 1000);\nif (IsEnd) {\n  /* The execution finished. Developers can get the result. */\n  WasmEdge_Result Res = WasmEdge_AsyncGet(/* ... Ignored */);\n} else {\n  /*\n   * The time limit exceeded. Developers can keep waiting or cancel the\n   * execution.\n   */\n  WasmEdge_AsyncCancel(Async);\n  WasmEdge_Result Res = WasmEdge_AsyncGet(Async, 0, NULL);\n  /* The result error code will be `WasmEdge_ErrCode_Interrupted`. */\n}\nWasmEdge_AsyncDelete(Async);\n"))),(0,s.kt)("li",{parentName:"ol"},(0,s.kt)("p",{parentName:"li"},"Get the execution result of the asynchronous execution"),(0,s.kt)("p",{parentName:"li"},"Developers can use the ",(0,s.kt)("inlineCode",{parentName:"p"},"WasmEdge_AsyncGetReturnsLength()")," API to get the return value list length.\nThis function will block and wait for the execution. If the execution has finished, this function will return the length immediately. If the execution failed, this function will return ",(0,s.kt)("inlineCode",{parentName:"p"},"0"),".\nThis function can help the developers to create the buffer to get the return values. If developers have already known the buffer length, they can skip this function and use the ",(0,s.kt)("inlineCode",{parentName:"p"},"WasmEdge_AsyncGet()")," API to get the result."),(0,s.kt)("pre",{parentName:"li"},(0,s.kt)("code",{parentName:"pre",className:"language-c"},"WasmEdge_Async *Async = ...; /* Ignored. Asynchronous execute a function. */\n/*\n * Blocking and waiting for the execution and get the return value list\n * length.\n */\nuint32_t Arity = WasmEdge_AsyncGetReturnsLength(Async);\nWasmEdge_AsyncDelete(Async);\n")),(0,s.kt)("p",{parentName:"li"},"The ",(0,s.kt)("inlineCode",{parentName:"p"},"WasmEdge_AsyncGet()")," API will block and wait for the execution. If the execution has finished, this function will fill the return values into the buffer and return the execution result immediately."),(0,s.kt)("pre",{parentName:"li"},(0,s.kt)("code",{parentName:"pre",className:"language-c"},"WasmEdge_Async *Async = ...; /* Ignored. Asynchronous execute a function. */\n/* Blocking and waiting for the execution and get the return values. */\nconst uint32_t BUF_LEN = 256;\nWasmEdge_Value Buf[BUF_LEN];\nWasmEdge_Result Res = WasmEdge_AsyncGet(Async, Buf, BUF_LEN);\nWasmEdge_AsyncDelete(Async);\n")))),(0,s.kt)("h3",{id:"configurations"},"Configurations"),(0,s.kt)("p",null,"The configuration context, ",(0,s.kt)("inlineCode",{parentName:"p"},"WasmEdge_ConfigureContext"),", manages the configurations for ",(0,s.kt)("inlineCode",{parentName:"p"},"Loader"),", ",(0,s.kt)("inlineCode",{parentName:"p"},"Validator"),", ",(0,s.kt)("inlineCode",{parentName:"p"},"Executor"),", ",(0,s.kt)("inlineCode",{parentName:"p"},"VM"),", and ",(0,s.kt)("inlineCode",{parentName:"p"},"Compiler"),".\nDevelopers can adjust the settings about the proposals, VM host pre-registrations (such as ",(0,s.kt)("inlineCode",{parentName:"p"},"WASI"),"), and AOT compiler options, and then apply the ",(0,s.kt)("inlineCode",{parentName:"p"},"Configure")," context to create other runtime contexts."),(0,s.kt)("ol",null,(0,s.kt)("li",{parentName:"ol"},(0,s.kt)("p",{parentName:"li"},"Proposals"),(0,s.kt)("p",{parentName:"li"},"WasmEdge supports turning on or off the WebAssembly proposals.\nThis configuration is effective in any contexts created with the ",(0,s.kt)("inlineCode",{parentName:"p"},"Configure")," context."),(0,s.kt)("pre",{parentName:"li"},(0,s.kt)("code",{parentName:"pre",className:"language-c"},"enum WasmEdge_Proposal {\n  WasmEdge_Proposal_ImportExportMutGlobals = 0,\n  WasmEdge_Proposal_NonTrapFloatToIntConversions,\n  WasmEdge_Proposal_SignExtensionOperators,\n  WasmEdge_Proposal_MultiValue,\n  WasmEdge_Proposal_BulkMemoryOperations,\n  WasmEdge_Proposal_ReferenceTypes,\n  WasmEdge_Proposal_SIMD,\n  WasmEdge_Proposal_TailCall,\n  WasmEdge_Proposal_MultiMemories,\n  WasmEdge_Proposal_Annotations,\n  WasmEdge_Proposal_Memory64,\n  WasmEdge_Proposal_ExceptionHandling,\n  WasmEdge_Proposal_ExtendedConst,\n  WasmEdge_Proposal_Threads,\n  WasmEdge_Proposal_FunctionReferences\n};\n")),(0,s.kt)("p",{parentName:"li"},"Developers can add or remove the proposals into the ",(0,s.kt)("inlineCode",{parentName:"p"},"Configure")," context."),(0,s.kt)("pre",{parentName:"li"},(0,s.kt)("code",{parentName:"pre",className:"language-c"},"/*\n * By default, the following proposals have turned on initially:\n * * Import/Export of mutable globals\n * * Non-trapping float-to-int conversions\n * * Sign-extension operators\n * * Multi-value returns\n * * Bulk memory operations\n * * Reference types\n * * Fixed-width SIMD\n *\n * For the current WasmEdge version, the following proposals are supported\n * (turned off by default) additionally:\n * * Tail-call\n * * Multiple memories\n * * Extended-const\n * * Threads\n */\nWasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();\nWasmEdge_ConfigureAddProposal(ConfCxt, WasmEdge_Proposal_MultiMemories);\nWasmEdge_ConfigureRemoveProposal(ConfCxt, WasmEdge_Proposal_ReferenceTypes);\nbool IsBulkMem = WasmEdge_ConfigureHasProposal(\n    ConfCxt, WasmEdge_Proposal_BulkMemoryOperations);\n/* The `IsBulkMem` will be `TRUE`. */\nWasmEdge_ConfigureDelete(ConfCxt);\n"))),(0,s.kt)("li",{parentName:"ol"},(0,s.kt)("p",{parentName:"li"},"Host registrations"),(0,s.kt)("p",{parentName:"li"},"This configuration is used for the ",(0,s.kt)("inlineCode",{parentName:"p"},"VM")," context to turn on the ",(0,s.kt)("inlineCode",{parentName:"p"},"WASI")," or ",(0,s.kt)("inlineCode",{parentName:"p"},"wasmedge_process")," supports and only effective in ",(0,s.kt)("inlineCode",{parentName:"p"},"VM")," contexts."),(0,s.kt)("pre",{parentName:"li"},(0,s.kt)("code",{parentName:"pre",className:"language-c"},"enum WasmEdge_HostRegistration {\n  WasmEdge_HostRegistration_Wasi = 0,\n  WasmEdge_HostRegistration_WasmEdge_Process\n};\n")),(0,s.kt)("p",{parentName:"li"},"The details will be introduced in the ",(0,s.kt)("a",{parentName:"p",href:"#preregistrations"},"preregistrations of VM context"),"."),(0,s.kt)("pre",{parentName:"li"},(0,s.kt)("code",{parentName:"pre",className:"language-c"},"WasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();\nbool IsHostWasi = WasmEdge_ConfigureHasHostRegistration(\n    ConfCxt, WasmEdge_HostRegistration_Wasi);\n/* The `IsHostWasi` will be `FALSE`. */\nWasmEdge_ConfigureAddHostRegistration(ConfCxt,\n                                      WasmEdge_HostRegistration_Wasi);\nIsHostWasi = WasmEdge_ConfigureHasHostRegistration(\n    ConfCxt, WasmEdge_HostRegistration_Wasi);\n/* The `IsHostWasi` will be `TRUE`. */\nWasmEdge_ConfigureDelete(ConfCxt);\n"))),(0,s.kt)("li",{parentName:"ol"},(0,s.kt)("p",{parentName:"li"},"Maximum memory pages"),(0,s.kt)("p",{parentName:"li"},"Developers can limit the page size of memory instances by this configuration.\nWhen growing the page size of memory instances in WASM execution and exceeding the limited size, the page growing will fail.\nThis configuration is only effective in the ",(0,s.kt)("inlineCode",{parentName:"p"},"Executor")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"VM")," contexts."),(0,s.kt)("pre",{parentName:"li"},(0,s.kt)("code",{parentName:"pre",className:"language-c"},"WasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();\nuint32_t PageSize = WasmEdge_ConfigureGetMaxMemoryPage(ConfCxt);\n/* By default, the maximum memory page size is 65536. */\nWasmEdge_ConfigureSetMaxMemoryPage(ConfCxt, 1024);\n/*\n * Limit the memory size of each memory instance with not larger than 1024\n * pages (64 MiB).\n */\nPageSize = WasmEdge_ConfigureGetMaxMemoryPage(ConfCxt);\n/* The `PageSize` will be 1024. */\nWasmEdge_ConfigureDelete(ConfCxt);\n"))),(0,s.kt)("li",{parentName:"ol"},(0,s.kt)("p",{parentName:"li"},"Forcibly interpreter mode (",(0,s.kt)("inlineCode",{parentName:"p"},"0.11.2")," or upper only)"),(0,s.kt)("p",{parentName:"li"},"If developers want to execute the WASM file or the AOT compiled WASM in interpreter mode forcibly, they can turn on the configuration."),(0,s.kt)("pre",{parentName:"li"},(0,s.kt)("code",{parentName:"pre",className:"language-c"},"WasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();\nbool IsForceInterp = WasmEdge_ConfigureIsForceInterpreter(ConfCxt);\n/* By default, The `IsForceInterp` will be `FALSE`. */\nWasmEdge_ConfigureSetForceInterpreter(ConfCxt, TRUE);\nIsForceInterp = WasmEdge_ConfigureIsForceInterpreter(ConfCxt);\n/* The `IsForceInterp` will be `TRUE`. */\nWasmEdge_ConfigureDelete(ConfCxt);\n"))),(0,s.kt)("li",{parentName:"ol"},(0,s.kt)("p",{parentName:"li"},"AOT compiler options"),(0,s.kt)("p",{parentName:"li"},"The AOT compiler options configure the behavior about optimization level, output format, dump IR, and generic binary."),(0,s.kt)("pre",{parentName:"li"},(0,s.kt)("code",{parentName:"pre",className:"language-c"},"enum WasmEdge_CompilerOptimizationLevel {\n  // Disable as many optimizations as possible.\n  WasmEdge_CompilerOptimizationLevel_O0 = 0,\n  // Optimize quickly without destroying debuggability.\n  WasmEdge_CompilerOptimizationLevel_O1,\n  // Optimize for fast execution as much as possible without triggering\n  // significant incremental compile time or code size growth.\n  WasmEdge_CompilerOptimizationLevel_O2,\n  // Optimize for fast execution as much as possible.\n  WasmEdge_CompilerOptimizationLevel_O3,\n  // Optimize for small code size as much as possible without triggering\n  // significant incremental compile time or execution time slowdowns.\n  WasmEdge_CompilerOptimizationLevel_Os,\n  // Optimize for small code size as much as possible.\n  WasmEdge_CompilerOptimizationLevel_Oz\n};\n\nenum WasmEdge_CompilerOutputFormat {\n  // Native dynamic library format.\n  WasmEdge_CompilerOutputFormat_Native = 0,\n  // WebAssembly with AOT compiled codes in custom section.\n  WasmEdge_CompilerOutputFormat_Wasm\n};\n")),(0,s.kt)("p",{parentName:"li"},"These configurations are only effective in ",(0,s.kt)("inlineCode",{parentName:"p"},"Compiler")," contexts."),(0,s.kt)("pre",{parentName:"li"},(0,s.kt)("code",{parentName:"pre",className:"language-c"},"WasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();\n/* By default, the optimization level is O3. */\nWasmEdge_ConfigureCompilerSetOptimizationLevel(\n    ConfCxt, WasmEdge_CompilerOptimizationLevel_O2);\n/* By default, the output format is universal WASM. */\nWasmEdge_ConfigureCompilerSetOutputFormat(\n    ConfCxt, WasmEdge_CompilerOutputFormat_Native);\n/* By default, the dump IR is `FALSE`. */\nWasmEdge_ConfigureCompilerSetDumpIR(ConfCxt, TRUE);\n/* By default, the generic binary is `FALSE`. */\nWasmEdge_ConfigureCompilerSetGenericBinary(ConfCxt, TRUE);\n/* By default, the interruptible is `FALSE`.\n/* Set this option to `TRUE` to support the interruptible execution in AOT\nmode. */\nWasmEdge_ConfigureCompilerSetInterruptible(ConfCxt, TRUE);\nWasmEdge_ConfigureDelete(ConfCxt);\n"))),(0,s.kt)("li",{parentName:"ol"},(0,s.kt)("p",{parentName:"li"},"Statistics options"),(0,s.kt)("p",{parentName:"li"},"The statistics options configure the behavior about instruction counting, cost measuring, and time measuring in both runtime and AOT compiler.\nThese configurations are effective in ",(0,s.kt)("inlineCode",{parentName:"p"},"Compiler"),", ",(0,s.kt)("inlineCode",{parentName:"p"},"VM"),", and ",(0,s.kt)("inlineCode",{parentName:"p"},"Executor")," contexts."),(0,s.kt)("pre",{parentName:"li"},(0,s.kt)("code",{parentName:"pre",className:"language-c"},"WasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();\n/*\n * By default, the instruction counting is `FALSE` when running a\n * compiled-WASM or a pure-WASM.\n */\nWasmEdge_ConfigureStatisticsSetInstructionCounting(ConfCxt, TRUE);\n/*\n * By default, the cost measurement is `FALSE` when running a compiled-WASM\n * or a pure-WASM.\n */\nWasmEdge_ConfigureStatisticsSetCostMeasuring(ConfCxt, TRUE);\n/*\n * By default, the time measurement is `FALSE` when running a compiled-WASM\n * or a pure-WASM.\n */\nWasmEdge_ConfigureStatisticsSetTimeMeasuring(ConfCxt, TRUE);\nWasmEdge_ConfigureDelete(ConfCxt);\n")))),(0,s.kt)("h3",{id:"statistics"},"Statistics"),(0,s.kt)("p",null,"The statistics context, ",(0,s.kt)("inlineCode",{parentName:"p"},"WasmEdge_StatisticsContext"),", provides the instruction counter, cost summation, and cost limitation at runtime."),(0,s.kt)("p",null,"Before using statistics, the statistics configuration must be set. Otherwise, the return values of calling statistics are undefined behaviour."),(0,s.kt)("ol",null,(0,s.kt)("li",{parentName:"ol"},(0,s.kt)("p",{parentName:"li"},"Instruction counter"),(0,s.kt)("p",{parentName:"li"},"The instruction counter can help developers to profile the performance of WASM running.\nDevelopers can retrieve the ",(0,s.kt)("inlineCode",{parentName:"p"},"Statistics")," context from the ",(0,s.kt)("inlineCode",{parentName:"p"},"VM")," context, or create a new one for the ",(0,s.kt)("inlineCode",{parentName:"p"},"Executor")," creation.\nThe details will be introduced in the next partitions."),(0,s.kt)("pre",{parentName:"li"},(0,s.kt)("code",{parentName:"pre",className:"language-c"},"WasmEdge_StatisticsContext *StatCxt = WasmEdge_StatisticsCreate();\n/*\n * ...\n * After running the WASM functions with the `Statistics` context\n */\nuint32_t Count = WasmEdge_StatisticsGetInstrCount(StatCxt);\ndouble IPS = WasmEdge_StatisticsGetInstrPerSecond(StatCxt);\nWasmEdge_StatisticsDelete(StatCxt);\n"))),(0,s.kt)("li",{parentName:"ol"},(0,s.kt)("p",{parentName:"li"},"Cost table"),(0,s.kt)("p",{parentName:"li"},"The cost table is to accumulate the cost of instructions with their weights.\nDevelopers can set the cost table array (the indices are the byte code value of instructions, and the values are the cost of instructions) into the ",(0,s.kt)("inlineCode",{parentName:"p"},"Statistics")," context.\nIf the cost limit value is set, the execution will return the ",(0,s.kt)("inlineCode",{parentName:"p"},"cost limit exceeded")," error immediately when exceeds the cost limit in runtime."),(0,s.kt)("pre",{parentName:"li"},(0,s.kt)("code",{parentName:"pre",className:"language-c"},"WasmEdge_StatisticsContext *StatCxt = WasmEdge_StatisticsCreate();\nuint64_t CostTable[16] = {\n  0, 0,\n  10, /* 0x02: Block */\n  11, /* 0x03: Loop */\n  12, /* 0x04: If */\n  12, /* 0x05: Else */\n  0, 0, 0, 0, 0, 0, \n  20, /* 0x0C: Br */\n  21, /* 0x0D: Br_if */\n  22, /* 0x0E: Br_table */\n  0\n};\n/*\n * Developers can set the costs of each instruction. The value not\n * covered will be 0.\n */\nWasmEdge_StatisticsSetCostTable(StatCxt, CostTable, 16);\nWasmEdge_StatisticsSetCostLimit(StatCxt, 5000000);\n/*\n * ...\n * After running the WASM functions with the `Statistics` context\n */\nuint64_t Cost = WasmEdge_StatisticsGetTotalCost(StatCxt);\nWasmEdge_StatisticsDelete(StatCxt);\n")))),(0,s.kt)("h3",{id:"tools-driver"},"Tools Driver"),(0,s.kt)("p",null,"Besides executing the ",(0,s.kt)("inlineCode",{parentName:"p"},"wasmedge")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"wasmedgec")," CLI tools, developers can trigger the WasmEdge CLI tools by WasmEdge C API.\nThe API arguments are the same as the command line arguments of the CLI tools."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-c"},"#include <wasmedge/wasmedge.h>\n#include <stdio.h>\nint main(int argc, const char *argv[]) {\n  /* Run the WasmEdge AOT compiler. */\n  return WasmEdge_Driver_Compiler(argc, argv);\n}\n")),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-c"},"#include <wasmedge/wasmedge.h>\n#include <stdio.h>\nint main(int argc, const char *argv[]) {\n  /* Run the WasmEdge runtime tool. */\n  return WasmEdge_Driver_Tool(argc, argv);\n}\n")),(0,s.kt)("h2",{id:"wasmedge-vm"},"WasmEdge VM"),(0,s.kt)("p",null,"In this partition, we will introduce the functions of ",(0,s.kt)("inlineCode",{parentName:"p"},"WasmEdge_VMContext")," object and show examples of executing WASM functions."),(0,s.kt)("h3",{id:"wasm-execution-example-with-vm-context"},"WASM Execution Example With VM Context"),(0,s.kt)("p",null,"The following shows the example of running the WASM for getting the Fibonacci.\nThis example uses the ",(0,s.kt)("a",{parentName:"p",href:"https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/examples/wasm/fibonacci.wasm"},"fibonacci.wasm"),", and the corresponding WAT file is at ",(0,s.kt)("a",{parentName:"p",href:"https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/examples/wasm/fibonacci.wat"},"fibonacci.wat"),"."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-wasm"},'(module\n  (export "fib" (func $fib))\n  (func $fib (param $n i32) (result i32)\n    (if\n      (i32.lt_s (get_local $n)(i32.const 2))\n      (return (i32.const 1))\n    )\n    (return\n      (i32.add\n        (call $fib (i32.sub (get_local $n)(i32.const 2)))\n        (call $fib (i32.sub (get_local $n)(i32.const 1)))\n      )\n    )\n  )\n)\n')),(0,s.kt)("ol",null,(0,s.kt)("li",{parentName:"ol"},(0,s.kt)("p",{parentName:"li"},"Run WASM functions rapidly"),(0,s.kt)("p",{parentName:"li"},"Assume that the WASM file ",(0,s.kt)("a",{parentName:"p",href:"https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/examples/wasm/fibonacci.wasm"},(0,s.kt)("inlineCode",{parentName:"a"},"fibonacci.wasm"))," is copied into the current directory, and the C file ",(0,s.kt)("inlineCode",{parentName:"p"},"test.c")," is as following:"),(0,s.kt)("pre",{parentName:"li"},(0,s.kt)("code",{parentName:"pre",className:"language-c"},'#include <stdio.h>\n#include <wasmedge/wasmedge.h>\nint main() {\n  /* Create the configure context and add the WASI support. */\n  /* This step is not necessary unless you need WASI support. */\n  WasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();\n  WasmEdge_ConfigureAddHostRegistration(ConfCxt,\n                                        WasmEdge_HostRegistration_Wasi);\n  /* The configure and store context to the VM creation can be NULL. */\n  WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(ConfCxt, NULL);\n\n  /* The parameters and returns arrays. */\n  WasmEdge_Value Params[1] = {WasmEdge_ValueGenI32(5)};\n  WasmEdge_Value Returns[1];\n  /* Function name. */\n  WasmEdge_String FuncName = WasmEdge_StringCreateByCString("fib");\n  /* Run the WASM function from file. */\n  WasmEdge_Result Res = WasmEdge_VMRunWasmFromFile(\n      VMCxt, "fibonacci.wasm", FuncName, Params, 1, Returns, 1);\n  /*\n   * Developers can run the WASM binary from buffer with the\n   * `WasmEdge_VMRunWasmFromBuffer()` API, or from\n   * `WasmEdge_ASTModuleContext` object with the\n   * `WasmEdge_VMRunWasmFromASTModule()` API.\n   */\n\n  if (WasmEdge_ResultOK(Res)) {\n    printf("Get the result: %d\\n", WasmEdge_ValueGetI32(Returns[0]));\n  } else {\n    printf("Error message: %s\\n", WasmEdge_ResultGetMessage(Res));\n  }\n\n  /* Resources deallocations. */\n  WasmEdge_VMDelete(VMCxt);\n  WasmEdge_ConfigureDelete(ConfCxt);\n  WasmEdge_StringDelete(FuncName);\n  return 0;\n}\n')),(0,s.kt)("p",{parentName:"li"},"Then you can compile and run: (the 5th Fibonacci number is 8 in 0-based index)"),(0,s.kt)("pre",{parentName:"li"},(0,s.kt)("code",{parentName:"pre",className:"language-bash"},"$ gcc test.c -lwasmedge\n$ ./a.out\nGet the result: 8\n"))),(0,s.kt)("li",{parentName:"ol"},(0,s.kt)("p",{parentName:"li"},"Instantiate and run WASM functions manually"),(0,s.kt)("p",{parentName:"li"},"Besides the above example, developers can run the WASM functions step-by-step with ",(0,s.kt)("inlineCode",{parentName:"p"},"VM")," context APIs:"),(0,s.kt)("pre",{parentName:"li"},(0,s.kt)("code",{parentName:"pre",className:"language-c"},'#include <wasmedge/wasmedge.h>\n#include <stdio.h>\nint main() {\n  /* Create the configure context and add the WASI support. */\n  /* This step is not necessary unless you need the WASI support. */\n  WasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();\n  WasmEdge_ConfigureAddHostRegistration(ConfCxt,\n                                        WasmEdge_HostRegistration_Wasi);\n  /* The configure and store context to the VM creation can be NULL. */\n  WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(ConfCxt, NULL);\n\n  /* The parameters and returns arrays. */\n  WasmEdge_Value Params[1] = {WasmEdge_ValueGenI32(10)};\n  WasmEdge_Value Returns[1];\n  /* Function name. */\n  WasmEdge_String FuncName = WasmEdge_StringCreateByCString("fib");\n  /* Result. */\n  WasmEdge_Result Res;\n\n  /* Step 1: Load WASM file. */\n  Res = WasmEdge_VMLoadWasmFromFile(VMCxt, "fibonacci.wasm");\n  /*\n   * Developers can load the WASM binary from buffer with the\n   * `WasmEdge_VMLoadWasmFromBuffer()` API, or from\n   * `WasmEdge_ASTModuleContext` object with the\n   * `WasmEdge_VMLoadWasmFromASTModule()` API.\n   */\n  if (!WasmEdge_ResultOK(Res)) {\n    printf("Loading phase failed: %s\\n", WasmEdge_ResultGetMessage(Res));\n    return 1;\n  }\n  /* Step 2: Validate the WASM module. */\n  Res = WasmEdge_VMValidate(VMCxt);\n  if (!WasmEdge_ResultOK(Res)) {\n    printf("Validation phase failed: %s\\n", WasmEdge_ResultGetMessage(Res));\n    return 1;\n  }\n  /* Step 3: Instantiate the WASM module. */\n  Res = WasmEdge_VMInstantiate(VMCxt);\n  /*\n   * Developers can load, validate, and instantiate another WASM module to\n   * replace the instantiated one. In this case, the old module will be\n   * cleared, but the registered modules are still kept.\n   */\n  if (!WasmEdge_ResultOK(Res)) {\n    printf("Instantiation phase failed: %s\\n",\n           WasmEdge_ResultGetMessage(Res));\n    return 1;\n  }\n  /*\n   * Step 4: Execute WASM functions. You can execute functions repeatedly\n   * after instantiation.\n   */\n  Res = WasmEdge_VMExecute(VMCxt, FuncName, Params, 1, Returns, 1);\n  if (WasmEdge_ResultOK(Res)) {\n    printf("Get the result: %d\\n", WasmEdge_ValueGetI32(Returns[0]));\n  } else {\n    printf("Execution phase failed: %s\\n", WasmEdge_ResultGetMessage(Res));\n  }\n\n  /* Resources deallocations. */\n  WasmEdge_VMDelete(VMCxt);\n  WasmEdge_ConfigureDelete(ConfCxt);\n  WasmEdge_StringDelete(FuncName);\n  return 0;\n}\n')),(0,s.kt)("p",{parentName:"li"},"Then you can compile and run: (the 10th Fibonacci number is 89 in 0-based index)"),(0,s.kt)("pre",{parentName:"li"},(0,s.kt)("code",{parentName:"pre",className:"language-bash"},"$ gcc test.c -lwasmedge\n$ ./a.out\nGet the result: 89\n")),(0,s.kt)("p",{parentName:"li"},"The following graph explains the status of the ",(0,s.kt)("inlineCode",{parentName:"p"},"VM")," context."),(0,s.kt)("pre",{parentName:"li"},(0,s.kt)("code",{parentName:"pre",className:"language-text"},"                       |========================|\n              |-------\x3e|      VM: Initiated     |\n              |        |========================|\n              |                    |\n              |                 LoadWasm\n              |                    |\n              |                    v\n              |        |========================|\n              |--------|       VM: Loaded       |<-------|\n              |        |========================|        |\n              |              |            ^              |\n              |         Validate          |              |\n          Cleanup            |          LoadWasm         |\n              |              v            |            LoadWasm\n              |        |========================|        |\n              |--------|      VM: Validated     |        |\n              |        |========================|        |\n              |              |            ^              |\n              |      Instantiate          |              |\n              |              |          RegisterModule   |\n              |              v            |              |\n              |        |========================|        |\n              |--------|    VM: Instantiated    |--------|\n                       |========================|\n                             |            ^\n                             |            |\n                             --------------\n                Instantiate, Execute, ExecuteRegistered\n")),(0,s.kt)("p",{parentName:"li"},"The status of the ",(0,s.kt)("inlineCode",{parentName:"p"},"VM")," context would be ",(0,s.kt)("inlineCode",{parentName:"p"},"Inited")," when created.\nAfter loading WASM successfully, the status will be ",(0,s.kt)("inlineCode",{parentName:"p"},"Loaded"),".\nAfter validating WASM successfully, the status will be ",(0,s.kt)("inlineCode",{parentName:"p"},"Validated"),".\nAfter instantiating WASM successfully, the status will be ",(0,s.kt)("inlineCode",{parentName:"p"},"Instantiated"),", and developers can invoke functions.\nDevelopers can register WASM or module instances in any status, but they should instantiate WASM again.\nDevelopers can also load WASM in any status, and they should validate and instantiate the WASM module before function invocation.\nWhen in the ",(0,s.kt)("inlineCode",{parentName:"p"},"Instantiated")," status, developers can instantiate the WASM module again to reset the old WASM runtime structures."))),(0,s.kt)("h3",{id:"vm-creations"},"VM Creations"),(0,s.kt)("p",null,"The ",(0,s.kt)("inlineCode",{parentName:"p"},"VM")," creation API accepts the ",(0,s.kt)("inlineCode",{parentName:"p"},"Configure")," context and the ",(0,s.kt)("inlineCode",{parentName:"p"},"Store")," context.\nIf developers only need the default settings, just pass ",(0,s.kt)("inlineCode",{parentName:"p"},"NULL")," to the creation API.\nThe details of the ",(0,s.kt)("inlineCode",{parentName:"p"},"Store")," context will be introduced in ",(0,s.kt)("a",{parentName:"p",href:"#store"},"Store"),"."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-c"},"WasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();\nWasmEdge_StoreContext *StoreCxt = WasmEdge_StoreCreate();\nWasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(ConfCxt, StoreCxt);\n/* The caller should guarantee the life cycle if the store context. */\nWasmEdge_StatisticsContext *StatCxt = WasmEdge_VMGetStatisticsContext(VMCxt);\n/*\n * The VM context already contains the statistics context and can be retrieved\n * by this API.\n */\n/*\n * Note that the retrieved store and statistics contexts from the VM contexts by\n * VM APIs should __NOT__ be destroyed and owned by the VM contexts.\n */\nWasmEdge_VMDelete(VMCxt);\nWasmEdge_StoreDelete(StoreCxt);\nWasmEdge_ConfigureDelete(ConfCxt);\n")),(0,s.kt)("h3",{id:"preregistrations"},"Preregistrations"),(0,s.kt)("p",null,"WasmEdge provides the following built-in pre-registrations."),(0,s.kt)("ol",null,(0,s.kt)("li",{parentName:"ol"},(0,s.kt)("p",{parentName:"li"},(0,s.kt)("a",{parentName:"p",href:"https://github.com/WebAssembly/WASI"},"WASI (WebAssembly System Interface)")),(0,s.kt)("p",{parentName:"li"},"Developers can turn on the WASI support for VM in the ",(0,s.kt)("inlineCode",{parentName:"p"},"Configure")," context."),(0,s.kt)("pre",{parentName:"li"},(0,s.kt)("code",{parentName:"pre",className:"language-c"},"WasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();\nWasmEdge_ConfigureAddHostRegistration(ConfCxt,\n                                      WasmEdge_HostRegistration_Wasi);\nWasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(ConfCxt, NULL);\n/*\n * The following API can retrieve the pre-registration module instances from\n * the VM context.\n */\n/*\n * This API will return `NULL` if the corresponding pre-registration is not\n * set into the configuration.\n */\nWasmEdge_ModuleInstanceContext *WasiModule =\n    WasmEdge_VMGetImportModuleContext(VMCxt,\n                                      WasmEdge_HostRegistration_Wasi);\n/* Initialize the WASI. */\nWasmEdge_ModuleInstanceInitWASI(WasiModule, /* ... ignored */);\nWasmEdge_VMDelete(VMCxt);\nWasmEdge_ConfigureDelete(ConfCxt);\n")),(0,s.kt)("p",{parentName:"li"},"And also can create the WASI module instance from API. The details will be introduced in the ",(0,s.kt)("a",{parentName:"p",href:"#host-functions"},"Host Functions")," and the ",(0,s.kt)("a",{parentName:"p",href:"#host-module-registrations"},"Host Module Registrations"),".")),(0,s.kt)("li",{parentName:"ol"},(0,s.kt)("p",{parentName:"li"},(0,s.kt)("a",{parentName:"p",href:"https://crates.io/crates/wasmedge_process_interface"},"WasmEdge_Process")),(0,s.kt)("p",{parentName:"li"},"This pre-registration is for the process interface for WasmEdge on ",(0,s.kt)("inlineCode",{parentName:"p"},"Rust")," sources.\nAfter turning on this pre-registration, the VM will support the ",(0,s.kt)("inlineCode",{parentName:"p"},"wasmedge_process")," plugin."),(0,s.kt)("pre",{parentName:"li"},(0,s.kt)("code",{parentName:"pre",className:"language-c"},"WasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();\nWasmEdge_ConfigureAddHostRegistration(\n    ConfCxt, WasmEdge_HostRegistration_WasmEdge_Process);\nWasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(ConfCxt, NULL);\n/*\n * The following API can retrieve the pre-registration module instances from\n * the VM context.\n */\n/*\n * This API will return `NULL` if the corresponding pre-registration is not\n * set into the configuration or the plugin load failed.\n */\nWasmEdge_ModuleInstanceContext *ProcModule =\n    WasmEdge_VMGetImportModuleContext(\n        VMCxt, WasmEdge_HostRegistration_WasmEdge_Process);\n/* Initialize the WasmEdge_Process. */\nWasmEdge_ModuleInstanceInitWasmEdgeProcess(ProcModule, /* ... ignored */);\nWasmEdge_VMDelete(VMCxt);\nWasmEdge_ConfigureDelete(ConfCxt);\n")),(0,s.kt)("p",{parentName:"li"},"And also can create the WasmEdge_Process module instance from API. The details will be introduced in the ",(0,s.kt)("a",{parentName:"p",href:"#host-functions"},"Host Functions")," and the ",(0,s.kt)("a",{parentName:"p",href:"#host-module-registrations"},"Host Module Registrations"),".")),(0,s.kt)("li",{parentName:"ol"},(0,s.kt)("p",{parentName:"li"},(0,s.kt)("a",{parentName:"p",href:"https://github.com/WebAssembly/wasi-nn"},"WASI-NN proposal")),(0,s.kt)("p",{parentName:"li"},"Developers can turn on the WASI-NN proposal support for VM in the ",(0,s.kt)("inlineCode",{parentName:"p"},"Configure")," context."),(0,s.kt)("blockquote",{parentName:"li"},(0,s.kt)("p",{parentName:"blockquote"},"Note: Please check that the ",(0,s.kt)("a",{parentName:"p",href:"/book/develop/build-and-run/install#install-plugins-and-extensions"},"dependencies and prerequisites")," are satisfied.")),(0,s.kt)("pre",{parentName:"li"},(0,s.kt)("code",{parentName:"pre",className:"language-c"},"WasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();\nWasmEdge_ConfigureAddHostRegistration(ConfCxt,\n                                      WasmEdge_HostRegistration_WasiNN);\nWasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(ConfCxt, NULL);\n/*\n * The following API can retrieve the pre-registration module instances from\n * the VM context.\n */\n/*\n * This API will return `NULL` if the corresponding pre-registration is not\n * set into the configuration or the plugin load failed.\n */\nWasmEdge_ModuleInstanceContext *NNModule =\n    WasmEdge_VMGetImportModuleContext(VMCxt,\n                                      WasmEdge_HostRegistration_WasiNN);\nWasmEdge_VMDelete(VMCxt);\nWasmEdge_ConfigureDelete(ConfCxt);\n")),(0,s.kt)("p",{parentName:"li"},"And also can create the WASI-NN module instance from API. The details will be introduced in the ",(0,s.kt)("a",{parentName:"p",href:"#host-functions"},"Host Functions")," and the ",(0,s.kt)("a",{parentName:"p",href:"#host-module-registrations"},"Host Module Registrations"),".")),(0,s.kt)("li",{parentName:"ol"},(0,s.kt)("p",{parentName:"li"},(0,s.kt)("a",{parentName:"p",href:"https://github.com/WebAssembly/wasi-crypto"},"WASI-Crypto proposal")),(0,s.kt)("p",{parentName:"li"},"Developers can turn on the WASI-Crypto proposal support for VM in the ",(0,s.kt)("inlineCode",{parentName:"p"},"Configure")," context."),(0,s.kt)("blockquote",{parentName:"li"},(0,s.kt)("p",{parentName:"blockquote"},"Note: Please check that the ",(0,s.kt)("a",{parentName:"p",href:"/book/develop/build-and-run/install#install-plugins-and-extensions"},"dependencies and prerequests")," are satisfied.")),(0,s.kt)("pre",{parentName:"li"},(0,s.kt)("code",{parentName:"pre",className:"language-c"},"WasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();\n/* The WASI-Crypto related configures are suggested to turn on together. */\nWasmEdge_ConfigureAddHostRegistration(\n    ConfCxt, WasmEdge_HostRegistration_WasiCrypto_Common);\nWasmEdge_ConfigureAddHostRegistration(\n    ConfCxt, WasmEdge_HostRegistration_WasiCrypto_AsymmetricCommon);\nWasmEdge_ConfigureAddHostRegistration(\n    ConfCxt, WasmEdge_HostRegistration_WasiCrypto_Kx);\nWasmEdge_ConfigureAddHostRegistration(\n    ConfCxt, WasmEdge_HostRegistration_WasiCrypto_Signatures);\nWasmEdge_ConfigureAddHostRegistration(\n    ConfCxt, WasmEdge_HostRegistration_WasiCrypto_Symmetric);\nWasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(ConfCxt, NULL);\n/*\n * The following API can retrieve the pre-registration module instances from\n * the VM context.\n  */\n/*\n * This API will return `NULL` if the corresponding pre-registration is not\n * set into the configuration or the plugin load failed.\n  */\nWasmEdge_ModuleInstanceContext *CryptoCommonModule =\n    WasmEdge_VMGetImportModuleContext(\n        VMCxt, WasmEdge_HostRegistration_WasiCrypto_Common);\nWasmEdge_VMDelete(VMCxt);\nWasmEdge_ConfigureDelete(ConfCxt);\n")),(0,s.kt)("p",{parentName:"li"},"And also can create the WASI-Crypto module instance from API. The details will be introduced in the ",(0,s.kt)("a",{parentName:"p",href:"#host-functions"},"Host Functions")," and the ",(0,s.kt)("a",{parentName:"p",href:"#host-module-registrations"},"Host Module Registrations"),"."))),(0,s.kt)("h3",{id:"host-module-registrations"},"Host Module Registrations"),(0,s.kt)("p",null,(0,s.kt)("a",{parentName:"p",href:"https://webassembly.github.io/spec/core/exec/runtime.html#syntax-hostfunc"},"Host functions")," are functions outside WebAssembly and passed to WASM modules as imports.\nIn WasmEdge, the host functions are composed into host modules as ",(0,s.kt)("inlineCode",{parentName:"p"},"WasmEdge_ModuleInstanceContext")," objects with module names.\nPlease refer to the ",(0,s.kt)("a",{parentName:"p",href:"#host-functions"},"Host Functions in WasmEdge Runtime")," for the details.\nIn this chapter, we show the example for registering the host modules into a ",(0,s.kt)("inlineCode",{parentName:"p"},"VM")," context."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-c"},"WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(NULL, NULL);\nWasmEdge_ModuleInstanceContext *WasiModule =\n    WasmEdge_ModuleInstanceCreateWASI(/* ... ignored ... */);\n/* You can also create and register the WASI host modules by this API. */\nWasmEdge_Result Res = WasmEdge_VMRegisterModuleFromImport(VMCxt, WasiModule);\n/* The result status should be checked. */\n\n/* ... */\n\nWasmEdge_ModuleInstanceDelete(WasiModule);\n/*\n * The created module instances should be deleted by the developers when the VM\n * deallocation.\n */\nWasmEdge_VMDelete(VMCxt);\n")),(0,s.kt)("h3",{id:"wasm-registrations-and-executions"},"WASM Registrations And Executions"),(0,s.kt)("p",null,"In WebAssembly, the instances in WASM modules can be exported and can be imported by other WASM modules.\nWasmEdge VM provides APIs for developers to register and export any WASM modules, and execute the functions or host functions in the registered WASM modules."),(0,s.kt)("ol",null,(0,s.kt)("li",{parentName:"ol"},(0,s.kt)("p",{parentName:"li"},"Register the WASM modules with exported module names"),(0,s.kt)("p",{parentName:"li"},"Unless the module instances have already contained the module names, every WASM module should be named uniquely when registering.\nAssume that the WASM file ",(0,s.kt)("a",{parentName:"p",href:"https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/examples/wasm/fibonacci.wasm"},(0,s.kt)("inlineCode",{parentName:"a"},"fibonacci.wasm"))," is copied into the current directory."),(0,s.kt)("pre",{parentName:"li"},(0,s.kt)("code",{parentName:"pre",className:"language-c"},'WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(NULL, NULL);\nWasmEdge_String ModName = WasmEdge_StringCreateByCString("mod");\nWasmEdge_Result Res =\n    WasmEdge_VMRegisterModuleFromFile(VMCxt, ModName, "fibonacci.wasm");\n/*\n * Developers can register the WASM module from buffer with the\n * `WasmEdge_VMRegisterModuleFromBuffer()` API, or from\n * `WasmEdge_ASTModuleContext` object with the\n * `WasmEdge_VMRegisterModuleFromASTModule()` API.\n */\n/*\n * The result status should be checked.\n * The error will occur if the WASM module instantiation failed or the\n * module name conflicts.\n */\nWasmEdge_StringDelete(ModName);\nWasmEdge_VMDelete(VMCxt);\n'))),(0,s.kt)("li",{parentName:"ol"},(0,s.kt)("p",{parentName:"li"},"Execute the functions in registered WASM modules"),(0,s.kt)("p",{parentName:"li"},"Assume that the C file ",(0,s.kt)("inlineCode",{parentName:"p"},"test.c")," is as follows:"),(0,s.kt)("pre",{parentName:"li"},(0,s.kt)("code",{parentName:"pre",className:"language-c"},'#include <wasmedge/wasmedge.h>\n#include <stdio.h>\nint main() {\n  WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(NULL, NULL);\n\n  /* The parameters and returns arrays. */\n  WasmEdge_Value Params[1] = {WasmEdge_ValueGenI32(20)};\n  WasmEdge_Value Returns[1];\n  /* Names. */\n  WasmEdge_String ModName = WasmEdge_StringCreateByCString("mod");\n  WasmEdge_String FuncName = WasmEdge_StringCreateByCString("fib");\n  /* Result. */\n  WasmEdge_Result Res;\n\n  /* Register the WASM module into VM. */\n  Res = WasmEdge_VMRegisterModuleFromFile(VMCxt, ModName, "fibonacci.wasm");\n  /*\n   * Developers can register the WASM module from buffer with the\n   * `WasmEdge_VMRegisterModuleFromBuffer()` API, or from\n   * `WasmEdge_ASTModuleContext` object with the\n   * `WasmEdge_VMRegisterModuleFromASTModule()` API.\n   */\n  if (!WasmEdge_ResultOK(Res)) {\n    printf("WASM registration failed: %s\\n",\n           WasmEdge_ResultGetMessage(Res));\n    return 1;\n  }\n  /*\n   * The function "fib" in the "fibonacci.wasm" was exported with the module\n   * name "mod". As the same as host functions, other modules can import the\n   * function `"mod" "fib"`.\n   */\n\n  /*\n   * Execute WASM functions in registered modules.\n   * Unlike the execution of functions, the registered functions can be\n   * invoked without `WasmEdge_VMInstantiate()` because the WASM module was\n   * instantiated when registering. Developers can also invoke the host\n   * functions directly with this API.\n   */\n  Res = WasmEdge_VMExecuteRegistered(VMCxt, ModName, FuncName, Params, 1,\n                                     Returns, 1);\n  if (WasmEdge_ResultOK(Res)) {\n    printf("Get the result: %d\\n", WasmEdge_ValueGetI32(Returns[0]));\n  } else {\n    printf("Execution phase failed: %s\\n", WasmEdge_ResultGetMessage(Res));\n  }\n  WasmEdge_StringDelete(ModName);\n  WasmEdge_StringDelete(FuncName);\n  WasmEdge_VMDelete(VMCxt);\n  return 0;\n}\n')),(0,s.kt)("p",{parentName:"li"},"Then you can compile and run: (the 20th Fibonacci number is 89 in 0-based index)"),(0,s.kt)("pre",{parentName:"li"},(0,s.kt)("code",{parentName:"pre",className:"language-bash"},"$ gcc test.c -lwasmedge\n$ ./a.out\nGet the result: 10946\n")))),(0,s.kt)("h3",{id:"asynchronous-execution"},"Asynchronous Execution"),(0,s.kt)("ol",null,(0,s.kt)("li",{parentName:"ol"},(0,s.kt)("p",{parentName:"li"},"Asynchronously run WASM functions rapidly"),(0,s.kt)("p",{parentName:"li"},"Assume that the WASM file ",(0,s.kt)("a",{parentName:"p",href:"https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/examples/wasm/fibonacci.wasm"},(0,s.kt)("inlineCode",{parentName:"a"},"fibonacci.wasm"))," is copied into the current directory, and the C file ",(0,s.kt)("inlineCode",{parentName:"p"},"test.c")," is as following:"),(0,s.kt)("pre",{parentName:"li"},(0,s.kt)("code",{parentName:"pre",className:"language-c"},'#include <wasmedge/wasmedge.h>\n#include <stdio.h>\nint main() {\n  /* Create the VM context. */\n  WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(NULL, NULL);\n\n  /* The parameters and returns arrays. */\n  WasmEdge_Value Params[1] = {WasmEdge_ValueGenI32(20)};\n  WasmEdge_Value Returns[1];\n  /* Function name. */\n  WasmEdge_String FuncName = WasmEdge_StringCreateByCString("fib");\n  /* Asynchronously run the WASM function from file and get the\n   * `WasmEdge_Async` object. */\n  WasmEdge_Async *Async = WasmEdge_VMAsyncRunWasmFromFile(\n      VMCxt, "fibonacci.wasm", FuncName, Params, 1);\n  /*\n   * Developers can run the WASM binary from buffer with the\n   * `WasmEdge_VMAsyncRunWasmFromBuffer()` API, or from\n   * `WasmEdge_ASTModuleContext` object with the\n   * `WasmEdge_VMAsyncRunWasmFromASTModule()` API.\n   */\n\n  /* Wait for the execution. */\n  WasmEdge_AsyncWait(Async);\n  /*\n   * Developers can also use the `WasmEdge_AsyncGetReturnsLength()` or\n   * `WasmEdge_AsyncGet()` APIs to wait for the asynchronous execution.\n   * These APIs will wait until the execution finished.\n   */\n\n  /* Check the return values length. */\n  uint32_t Arity = WasmEdge_AsyncGetReturnsLength(Async);\n  /* The `Arity` should be 1. Developers can skip this step if they have\n   * known the return arity. */\n\n  /* Get the result. */\n  WasmEdge_Result Res = WasmEdge_AsyncGet(Async, Returns, Arity);\n\n  if (WasmEdge_ResultOK(Res)) {\n    printf("Get the result: %d\\n", WasmEdge_ValueGetI32(Returns[0]));\n  } else {\n    printf("Error message: %s\\n", WasmEdge_ResultGetMessage(Res));\n  }\n\n  /* Resources deallocations. */\n  WasmEdge_AsyncDelete(Async);\n  WasmEdge_VMDelete(VMCxt);\n  WasmEdge_StringDelete(FuncName);\n  return 0;\n}\n')),(0,s.kt)("p",{parentName:"li"},"Then you can compile and run: (the 20th Fibonacci number is 10946 in 0-based index)"),(0,s.kt)("pre",{parentName:"li"},(0,s.kt)("code",{parentName:"pre",className:"language-bash"},"$ gcc test.c -lwasmedge\n$ ./a.out\nGet the result: 10946\n"))),(0,s.kt)("li",{parentName:"ol"},(0,s.kt)("p",{parentName:"li"},"Instantiate and asynchronously run WASM functions manually"),(0,s.kt)("p",{parentName:"li"},"Besides the above example, developers can run the WASM functions step-by-step with ",(0,s.kt)("inlineCode",{parentName:"p"},"VM")," context APIs:"),(0,s.kt)("pre",{parentName:"li"},(0,s.kt)("code",{parentName:"pre",className:"language-c"},'#include <wasmedge/wasmedge.h>\n#include <stdio.h>\nint main() {\n  /* Create the VM context. */\n  WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(NULL, NULL);\n\n  /* The parameters and returns arrays. */\n  WasmEdge_Value Params[1] = {WasmEdge_ValueGenI32(25)};\n  WasmEdge_Value Returns[1];\n  /* Function name. */\n  WasmEdge_String FuncName = WasmEdge_StringCreateByCString("fib");\n  /* Result. */\n  WasmEdge_Result Res;\n\n  /* Step 1: Load WASM file. */\n  Res = WasmEdge_VMLoadWasmFromFile(VMCxt, "fibonacci.wasm");\n  /*\n   * Developers can load the WASM binary from buffer with the\n   * `WasmEdge_VMLoadWasmFromBuffer()` API, or from\n   * `WasmEdge_ASTModuleContext` object with the\n   * `WasmEdge_VMLoadWasmFromASTModule()` API.\n   */\n  if (!WasmEdge_ResultOK(Res)) {\n    printf("Loading phase failed: %s\\n", WasmEdge_ResultGetMessage(Res));\n    return 1;\n  }\n  /* Step 2: Validate the WASM module. */\n  Res = WasmEdge_VMValidate(VMCxt);\n  if (!WasmEdge_ResultOK(Res)) {\n    printf("Validation phase failed: %s\\n", WasmEdge_ResultGetMessage(Res));\n    return 1;\n  }\n  /* Step 3: Instantiate the WASM module. */\n  Res = WasmEdge_VMInstantiate(VMCxt);\n  /*\n   * Developers can load, validate, and instantiate another WASM module to\n   * replace the instantiated one. In this case, the old module will be\n   * cleared, but the registered modules are still kept.\n   */\n  if (!WasmEdge_ResultOK(Res)) {\n    printf("Instantiation phase failed: %s\\n",\n           WasmEdge_ResultGetMessage(Res));\n    return 1;\n  }\n  /* Step 4: Asynchronously execute the WASM function and get the\n   * `WasmEdge_Async` object. */\n  WasmEdge_Async *Async =\n      WasmEdge_VMAsyncExecute(VMCxt, FuncName, Params, 1);\n  /*\n   * Developers can execute functions repeatedly after instantiation.\n   * For invoking the registered functions, you can use the\n   * `WasmEdge_VMAsyncExecuteRegistered()` API.\n   */\n\n  /* Wait and check the return values length. */\n  uint32_t Arity = WasmEdge_AsyncGetReturnsLength(Async);\n  /* The `Arity` should be 1. Developers can skip this step if they have\n   * known the return arity. */\n\n  /* Get the result. */\n  Res = WasmEdge_AsyncGet(Async, Returns, Arity);\n  if (WasmEdge_ResultOK(Res)) {\n    printf("Get the result: %d\\n", WasmEdge_ValueGetI32(Returns[0]));\n  } else {\n    printf("Execution phase failed: %s\\n", WasmEdge_ResultGetMessage(Res));\n  }\n\n  /* Resources deallocations. */\n  WasmEdge_AsyncDelete(Async);\n  WasmEdge_VMDelete(VMCxt);\n  WasmEdge_StringDelete(FuncName);\n}\n')),(0,s.kt)("p",{parentName:"li"},"Then you can compile and run: (the 25th Fibonacci number is 121393 in 0-based index)"),(0,s.kt)("pre",{parentName:"li"},(0,s.kt)("code",{parentName:"pre",className:"language-bash"},"$ gcc test.c -lwasmedge\n$ ./a.out\nGet the result: 121393\n")))),(0,s.kt)("h3",{id:"instance-tracing"},"Instance Tracing"),(0,s.kt)("p",null,"Sometimes the developers may have requirements to get the instances of the WASM runtime.\nThe ",(0,s.kt)("inlineCode",{parentName:"p"},"VM")," context supplies the APIs to retrieve the instances."),(0,s.kt)("ol",null,(0,s.kt)("li",{parentName:"ol"},(0,s.kt)("p",{parentName:"li"},"Store"),(0,s.kt)("p",{parentName:"li"},"If the ",(0,s.kt)("inlineCode",{parentName:"p"},"VM")," context is created without assigning a ",(0,s.kt)("inlineCode",{parentName:"p"},"Store")," context, the ",(0,s.kt)("inlineCode",{parentName:"p"},"VM")," context will allocate and own a ",(0,s.kt)("inlineCode",{parentName:"p"},"Store")," context."),(0,s.kt)("pre",{parentName:"li"},(0,s.kt)("code",{parentName:"pre",className:"language-c"},"WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(NULL, NULL);\nWasmEdge_StoreContext *StoreCxt = WasmEdge_VMGetStoreContext(VMCxt);\n/* The object should __NOT__ be deleted by `WasmEdge_StoreDelete()`. */\nWasmEdge_VMDelete(VMCxt);\n")),(0,s.kt)("p",{parentName:"li"},"Developers can also create the ",(0,s.kt)("inlineCode",{parentName:"p"},"VM")," context with a ",(0,s.kt)("inlineCode",{parentName:"p"},"Store")," context.\nIn this case, developers should guarantee the life cycle of the ",(0,s.kt)("inlineCode",{parentName:"p"},"Store")," context.\nPlease refer to the ",(0,s.kt)("a",{parentName:"p",href:"#store"},"Store Contexts")," for the details about the ",(0,s.kt)("inlineCode",{parentName:"p"},"Store")," context APIs."),(0,s.kt)("pre",{parentName:"li"},(0,s.kt)("code",{parentName:"pre",className:"language-c"},"WasmEdge_StoreContext *StoreCxt = WasmEdge_StoreCreate();\nWasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(NULL, StoreCxt);\nWasmEdge_StoreContext *StoreCxtMock = WasmEdge_VMGetStoreContext(VMCxt);\n/* The `StoreCxt` and the `StoreCxtMock` are the same. */\nWasmEdge_VMDelete(VMCxt);\nWasmEdge_StoreDelete(StoreCxt);\n"))),(0,s.kt)("li",{parentName:"ol"},(0,s.kt)("p",{parentName:"li"},"List exported functions"),(0,s.kt)("p",{parentName:"li"},"After the WASM module instantiation, developers can use the ",(0,s.kt)("inlineCode",{parentName:"p"},"WasmEdge_VMExecute()")," API to invoke the exported WASM functions. For this purpose, developers may need information about the exported WASM function list.\nPlease refer to the ",(0,s.kt)("a",{parentName:"p",href:"#instances"},"Instances in runtime")," for the details about the function types.\nAssume that the WASM file ",(0,s.kt)("a",{parentName:"p",href:"https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/examples/wasm/fibonacci.wasm"},(0,s.kt)("inlineCode",{parentName:"a"},"fibonacci.wasm"))," is copied into the current directory, and the C file ",(0,s.kt)("inlineCode",{parentName:"p"},"test.c")," is as following:"),(0,s.kt)("pre",{parentName:"li"},(0,s.kt)("code",{parentName:"pre",className:"language-c"},'#include <wasmedge/wasmedge.h>\n#include <stdio.h>\nint main() {\n  WasmEdge_StoreContext *StoreCxt = WasmEdge_StoreCreate();\n  WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(NULL, StoreCxt);\n\n  WasmEdge_VMLoadWasmFromFile(VMCxt, "fibonacci.wasm");\n  WasmEdge_VMValidate(VMCxt);\n  WasmEdge_VMInstantiate(VMCxt);\n\n  /* List the exported functions. */\n  /* Get the number of exported functions. */\n  uint32_t FuncNum = WasmEdge_VMGetFunctionListLength(VMCxt);\n  /* Create the name buffers and the function type buffers. */\n  const uint32_t BUF_LEN = 256;\n  WasmEdge_String FuncNames[BUF_LEN];\n  WasmEdge_FunctionTypeContext *FuncTypes[BUF_LEN];\n  /*\n   * Get the export function list.\n   * If the function list length is larger than the buffer length, the\n   * overflowed data will be discarded. The `FuncNames` and `FuncTypes` can\n   * be NULL if developers don\'t need them.\n   */\n  uint32_t RealFuncNum =\n      WasmEdge_VMGetFunctionList(VMCxt, FuncNames, FuncTypes, BUF_LEN);\n\n  for (uint32_t I = 0; I < RealFuncNum && I < BUF_LEN; I++) {\n    char Buf[BUF_LEN];\n    uint32_t Size = WasmEdge_StringCopy(FuncNames[I], Buf, sizeof(Buf));\n    printf("Get exported function string length: %u, name: %s\\n", Size,\n           Buf);\n    /*\n     * The function names should be __NOT__ destroyed.\n     * The returned function type contexts should __NOT__ be destroyed.\n     */\n  }\n  WasmEdge_StoreDelete(StoreCxt);\n  WasmEdge_VMDelete(VMCxt);\n  return 0;\n}\n')),(0,s.kt)("p",{parentName:"li"},"Then you can compile and run: (the only exported function in ",(0,s.kt)("inlineCode",{parentName:"p"},"fibonacci.wasm")," is ",(0,s.kt)("inlineCode",{parentName:"p"},"fib"),")"),(0,s.kt)("pre",{parentName:"li"},(0,s.kt)("code",{parentName:"pre",className:"language-bash"},"$ gcc test.c -lwasmedge\n$ ./a.out\nGet exported function string length: 3, name: fib\n")),(0,s.kt)("p",{parentName:"li"},"If developers want to get the exported function names in the registered WASM modules, please retrieve the ",(0,s.kt)("inlineCode",{parentName:"p"},"Store")," context from the ",(0,s.kt)("inlineCode",{parentName:"p"},"VM")," context and refer to the APIs of ",(0,s.kt)("a",{parentName:"p",href:"#store"},"Store Contexts")," to list the registered functions by the module name.")),(0,s.kt)("li",{parentName:"ol"},(0,s.kt)("p",{parentName:"li"},"Get function types"),(0,s.kt)("p",{parentName:"li"},"The ",(0,s.kt)("inlineCode",{parentName:"p"},"VM")," context provides APIs to find the function type by function name.\nPlease refer to the ",(0,s.kt)("a",{parentName:"p",href:"#instances"},"Instances in runtime")," for the details about the function types."),(0,s.kt)("pre",{parentName:"li"},(0,s.kt)("code",{parentName:"pre",className:"language-c"},'/*\n * ...\n * Assume that a WASM module is instantiated in `VMCxt`.\n */\nWasmEdge_String FuncName = WasmEdge_StringCreateByCString("fib");\nconst WasmEdge_FunctionTypeContext *FuncType =\n    WasmEdge_VMGetFunctionType(VMCxt, FuncName);\n/*\n * Developers can get the function types of functions in the registered\n * modules via the `WasmEdge_VMGetFunctionTypeRegistered()` API with the\n * module name. If the function is not found, these APIs will return `NULL`.\n * The returned function type contexts should __NOT__ be destroyed.\n */\nWasmEdge_StringDelete(FuncName);\n'))),(0,s.kt)("li",{parentName:"ol"},(0,s.kt)("p",{parentName:"li"},"Get the active module"),(0,s.kt)("p",{parentName:"li"},"After the WASM module instantiation, an anonymous module is instantiated and owned by the ",(0,s.kt)("inlineCode",{parentName:"p"},"VM")," context.\nDevelopers may need to retrieve it to get the instances beyond the module.\nThen developers can use the ",(0,s.kt)("inlineCode",{parentName:"p"},"WasmEdge_VMGetActiveModule()")," API to get that anonymous module instance.\nPlease refer to the ",(0,s.kt)("a",{parentName:"p",href:"#instances"},"Module instance")," for the details about the module instance APIs."),(0,s.kt)("pre",{parentName:"li"},(0,s.kt)("code",{parentName:"pre",className:"language-c"},"/*\n * ...\n * Assume that a WASM module is instantiated in `VMCxt`.\n */\nconst WasmEdge_ModuleInstanceContext *ModCxt =\n    WasmEdge_VMGetActiveModule(VMCxt);\n/*\n * If there's no WASM module instantiated, this API will return `NULL`.\n * The returned module instance context should __NOT__ be destroyed.\n */\n"))),(0,s.kt)("li",{parentName:"ol"},(0,s.kt)("p",{parentName:"li"},"Get the components"),(0,s.kt)("p",{parentName:"li"},"The ",(0,s.kt)("inlineCode",{parentName:"p"},"VM")," context is composed by the ",(0,s.kt)("inlineCode",{parentName:"p"},"Loader"),", ",(0,s.kt)("inlineCode",{parentName:"p"},"Validator"),", and ",(0,s.kt)("inlineCode",{parentName:"p"},"Executor")," contexts.\nFor the developers who want to use these contexts without creating another instances, these APIs can help developers to get them from the ",(0,s.kt)("inlineCode",{parentName:"p"},"VM")," context.\nThe get contexts are owned by the ",(0,s.kt)("inlineCode",{parentName:"p"},"VM")," context, and developers should not call their delete functions."),(0,s.kt)("pre",{parentName:"li"},(0,s.kt)("code",{parentName:"pre",className:"language-c"},"WasmEdge_LoaderContext *LoadCxt = WasmEdge_VMGetLoaderContext(VMCxt);\n/* The object should __NOT__ be deleted by `WasmEdge_LoaderDelete()`. */\nWasmEdge_ValidatorContext *ValidCxt = WasmEdge_VMGetValidatorContext(VMCxt);\n/* The object should __NOT__ be deleted by `WasmEdge_ValidatorDelete()`. */\nWasmEdge_ExecutorContext *ExecCxt = WasmEdge_VMGetExecutorContext(VMCxt);\n/* The object should __NOT__ be deleted by `WasmEdge_ExecutorDelete()`. */\n")))),(0,s.kt)("h2",{id:"wasmedge-runtime"},"WasmEdge Runtime"),(0,s.kt)("p",null,"In this partition, we will introduce the objects of WasmEdge runtime manually."),(0,s.kt)("h3",{id:"wasm-execution-example-step-by-step"},"WASM Execution Example Step-By-Step"),(0,s.kt)("p",null,"Besides the WASM execution through the ",(0,s.kt)("a",{parentName:"p",href:"#wasmedge-vm"},(0,s.kt)("inlineCode",{parentName:"a"},"VM")," context"),", developers can execute the WASM functions or instantiate WASM modules step-by-step with the ",(0,s.kt)("inlineCode",{parentName:"p"},"Loader"),", ",(0,s.kt)("inlineCode",{parentName:"p"},"Validator"),", ",(0,s.kt)("inlineCode",{parentName:"p"},"Executor"),", and ",(0,s.kt)("inlineCode",{parentName:"p"},"Store")," contexts.\nAssume that the WASM file ",(0,s.kt)("a",{parentName:"p",href:"https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/examples/wasm/fibonacci.wasm"},(0,s.kt)("inlineCode",{parentName:"a"},"fibonacci.wasm"))," is copied into the current directory, and the C file ",(0,s.kt)("inlineCode",{parentName:"p"},"test.c")," is as following:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-c"},'#include <wasmedge/wasmedge.h>\n#include <stdio.h>\nint main() {\n  /*\n   * Create the configure context. This step is not necessary because we didn\'t\n   * adjust any setting.\n   */\n  WasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();\n  /*\n   * Create the statistics context. This step is not necessary if the statistics\n   * in runtime is not needed.\n   */\n  WasmEdge_StatisticsContext *StatCxt = WasmEdge_StatisticsCreate();\n  /*\n   * Create the store context. The store context is the object to link the\n   * modules for imports and exports.\n   */\n  WasmEdge_StoreContext *StoreCxt = WasmEdge_StoreCreate();\n  /* Result. */\n  WasmEdge_Result Res;\n\n  /* Create the loader context. The configure context can be NULL. */\n  WasmEdge_LoaderContext *LoadCxt = WasmEdge_LoaderCreate(ConfCxt);\n  /* Create the validator context. The configure context can be NULL. */\n  WasmEdge_ValidatorContext *ValidCxt = WasmEdge_ValidatorCreate(ConfCxt);\n  /*\n   * Create the executor context. The configure context and the statistics\n   * context can be NULL.\n   */\n  WasmEdge_ExecutorContext *ExecCxt = WasmEdge_ExecutorCreate(ConfCxt, StatCxt);\n\n  /*\n   * Load the WASM file or the compiled-WASM file and convert into the AST\n   * module context.\n   */\n  WasmEdge_ASTModuleContext *ASTCxt = NULL;\n  Res = WasmEdge_LoaderParseFromFile(LoadCxt, &ASTCxt, "fibonacci.wasm");\n  if (!WasmEdge_ResultOK(Res)) {\n    printf("Loading phase failed: %s\\n", WasmEdge_ResultGetMessage(Res));\n    return 1;\n  }\n  /* Validate the WASM module. */\n  Res = WasmEdge_ValidatorValidate(ValidCxt, ASTCxt);\n  if (!WasmEdge_ResultOK(Res)) {\n    printf("Validation phase failed: %s\\n", WasmEdge_ResultGetMessage(Res));\n    return 1;\n  }\n  /* Instantiate the WASM module into store context. */\n  WasmEdge_ModuleInstanceContext *ModCxt = NULL;\n  Res = WasmEdge_ExecutorInstantiate(ExecCxt, &ModCxt, StoreCxt, ASTCxt);\n  if (!WasmEdge_ResultOK(Res)) {\n    printf("Instantiation phase failed: %s\\n", WasmEdge_ResultGetMessage(Res));\n    return 1;\n  }\n\n  /* Try to list the exported functions of the instantiated WASM module. */\n  uint32_t FuncNum = WasmEdge_ModuleInstanceListFunctionLength(ModCxt);\n  /* Create the name buffers. */\n  const uint32_t BUF_LEN = 256;\n  WasmEdge_String FuncNames[BUF_LEN];\n  /*\n   * If the list length is larger than the buffer length, the overflowed data\n   * will be discarded.\n   */\n  uint32_t RealFuncNum =\n      WasmEdge_ModuleInstanceListFunction(ModCxt, FuncNames, BUF_LEN);\n  for (uint32_t I = 0; I < RealFuncNum && I < BUF_LEN; I++) {\n    char Buf[BUF_LEN];\n    uint32_t Size = WasmEdge_StringCopy(FuncNames[I], Buf, sizeof(Buf));\n    printf("Get exported function string length: %u, name: %s\\n", Size, Buf);\n    /* The function names should __NOT__ be destroyed. */\n  }\n\n  /* The parameters and returns arrays. */\n  WasmEdge_Value Params[1] = {WasmEdge_ValueGenI32(18)};\n  WasmEdge_Value Returns[1];\n  /* Function name. */\n  WasmEdge_String FuncName = WasmEdge_StringCreateByCString("fib");\n  /* Find the exported function by function name. */\n  WasmEdge_FunctionInstanceContext *FuncCxt =\n      WasmEdge_ModuleInstanceFindFunction(ModCxt, FuncName);\n  if (FuncCxt == NULL) {\n    printf("Function `fib` not found.\\n");\n    return 1;\n  }\n  /* Invoke the WASM fnction. */\n  Res = WasmEdge_ExecutorInvoke(ExecCxt, FuncCxt, Params, 1, Returns, 1);\n  if (WasmEdge_ResultOK(Res)) {\n    printf("Get the result: %d\\n", WasmEdge_ValueGetI32(Returns[0]));\n  } else {\n    printf("Execution phase failed: %s\\n", WasmEdge_ResultGetMessage(Res));\n  }\n\n  /* Resources deallocations. */\n  WasmEdge_StringDelete(FuncName);\n  WasmEdge_ASTModuleDelete(ASTCxt);\n  WasmEdge_ModuleInstanceDelete(ModCxt);\n  WasmEdge_LoaderDelete(LoadCxt);\n  WasmEdge_ValidatorDelete(ValidCxt);\n  WasmEdge_ExecutorDelete(ExecCxt);\n  WasmEdge_ConfigureDelete(ConfCxt);\n  WasmEdge_StoreDelete(StoreCxt);\n  WasmEdge_StatisticsDelete(StatCxt);\n  return 0;\n}\n')),(0,s.kt)("p",null,"Then you can compile and run: (the 18th Fibonacci number is 4181 in 0-based index)"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-bash"},"$ gcc test.c -lwasmedge\n$ ./a.out\nGet exported function string length: 3, name: fib\nGet the result: 4181\n")),(0,s.kt)("h3",{id:"loader"},"Loader"),(0,s.kt)("p",null,"The ",(0,s.kt)("inlineCode",{parentName:"p"},"Loader")," context loads the WASM binary from files or buffers.\nBoth the WASM and the compiled-WASM from the ",(0,s.kt)("a",{parentName:"p",href:"#wasmedge-aot-compiler"},"WasmEdge AOT Compiler")," are supported."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-c"},'uint8_t Buf[4096];\n/* ... Read the WASM code to the buffer. */\nuint32_t FileSize = ...;\n/* The `FileSize` is the length of the WASM code. */\n\n/* Developers can adjust settings in the configure context. */\nWasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();\n/* Create the loader context. The configure context can be NULL. */\nWasmEdge_LoaderContext *LoadCxt = WasmEdge_LoaderCreate(ConfCxt);\n\nWasmEdge_ASTModuleContext *ASTCxt = NULL;\nWasmEdge_Result Res;\n\n/* Load WASM or compiled-WASM from the file. */\nRes = WasmEdge_LoaderParseFromFile(LoadCxt, &ASTCxt, "fibonacci.wasm");\nif (!WasmEdge_ResultOK(Res)) {\n  printf("Loading phase failed: %s\\n", WasmEdge_ResultGetMessage(Res));\n}\n/* The output AST module context should be destroyed. */\nWasmEdge_ASTModuleDelete(ASTCxt);\n\n/* Load WASM or compiled-WASM from the buffer. */\nRes = WasmEdge_LoaderParseFromBuffer(LoadCxt, &ASTCxt, Buf, FileSize);\nif (!WasmEdge_ResultOK(Res)) {\n  printf("Loading phase failed: %s\\n", WasmEdge_ResultGetMessage(Res));\n}\n/* The output AST module context should be destroyed. */\nWasmEdge_ASTModuleDelete(ASTCxt);\n\nWasmEdge_LoaderDelete(LoadCxt);\nWasmEdge_ConfigureDelete(ConfCxt);\n')),(0,s.kt)("h3",{id:"validator"},"Validator"),(0,s.kt)("p",null,"The ",(0,s.kt)("inlineCode",{parentName:"p"},"Validator")," context can validate the WASM module.\nEvery WASM module should be validated before instantiation."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-c"},'/* \n * ...\n * Assume that the `ASTCxt` is the output AST module context from the loader\n * context.\n * Assume that the `ConfCxt` is the configure context.\n */\n/* Create the validator context. The configure context can be NULL. */\nWasmEdge_ValidatorContext *ValidCxt = WasmEdge_ValidatorCreate(ConfCxt);\nWasmEdge_Result Res = WasmEdge_ValidatorValidate(ValidCxt, ASTCxt);\nif (!WasmEdge_ResultOK(Res)) {\n  printf("Validation phase failed: %s\\n", WasmEdge_ResultGetMessage(Res));\n}\nWasmEdge_ValidatorDelete(ValidCxt);\n')),(0,s.kt)("h3",{id:"executor"},"Executor"),(0,s.kt)("p",null,"The ",(0,s.kt)("inlineCode",{parentName:"p"},"Executor")," context is the executor for both WASM and compiled-WASM.\nThis object should work base on the ",(0,s.kt)("inlineCode",{parentName:"p"},"Store")," context. For the details of the ",(0,s.kt)("inlineCode",{parentName:"p"},"Store")," context, please refer to the ",(0,s.kt)("a",{parentName:"p",href:"#store"},"next chapter"),"."),(0,s.kt)("ol",null,(0,s.kt)("li",{parentName:"ol"},(0,s.kt)("p",{parentName:"li"},"Instantiate and register an ",(0,s.kt)("inlineCode",{parentName:"p"},"AST module")," as a named ",(0,s.kt)("inlineCode",{parentName:"p"},"Module")," instance"),(0,s.kt)("p",{parentName:"li"},"As the same of ",(0,s.kt)("a",{parentName:"p",href:"#host-module-registrations"},"registering host modules")," or ",(0,s.kt)("a",{parentName:"p",href:"#wasm-registrations-and-executions"},"importing WASM modules")," in ",(0,s.kt)("inlineCode",{parentName:"p"},"VM")," contexts, developers can instantiate and register an ",(0,s.kt)("inlineCode",{parentName:"p"},"AST module")," contexts into the ",(0,s.kt)("inlineCode",{parentName:"p"},"Store")," context as a named ",(0,s.kt)("inlineCode",{parentName:"p"},"Module")," instance by the ",(0,s.kt)("inlineCode",{parentName:"p"},"Executor")," APIs.\nAfter the registration, the result ",(0,s.kt)("inlineCode",{parentName:"p"},"Module")," instance is exported with the given module name and can be linked when instantiating another module.\nFor the details about the ",(0,s.kt)("inlineCode",{parentName:"p"},"Module")," instances APIs, please refer to the ",(0,s.kt)("a",{parentName:"p",href:"#instances"},"Instances"),"."),(0,s.kt)("pre",{parentName:"li"},(0,s.kt)("code",{parentName:"pre",className:"language-c"},'/*\n * ...\n * Assume that the `ASTCxt` is the output AST module context from the loader\n * context and has passed the validation. Assume that the `ConfCxt` is the\n * configure context.\n */\n/* Create the statistics context. This step is not necessary. */\nWasmEdge_StatisticsContext *StatCxt = WasmEdge_StatisticsCreate();\n/*\n * Create the executor context. The configure and the statistics contexts\n * can be NULL.\n */\nWasmEdge_ExecutorContext *ExecCxt =\n    WasmEdge_ExecutorCreate(ConfCxt, StatCxt);\n/*\n * Create the store context. The store context is the object to link the\n * modules for imports and exports.\n */\nWasmEdge_StoreContext *StoreCxt = WasmEdge_StoreCreate();\n/* Result. */\nWasmEdge_Result Res;\n\nWasmEdge_String ModName = WasmEdge_StringCreateByCString("mod");\n/* The output module instance. */\nWasmEdge_ModuleInstanceContext *ModCxt = NULL;\n/*\n * Register the WASM module into the store with the export module name\n * "mod".\n */\nRes =\n    WasmEdge_ExecutorRegister(ExecCxt, &ModCxt, StoreCxt, ASTCxt, ModName);\nif (!WasmEdge_ResultOK(Res)) {\n  printf("WASM registration failed: %s\\n", WasmEdge_ResultGetMessage(Res));\n  return -1;\n}\nWasmEdge_StringDelete(ModName);\n\n/* ... */\n\n/* After the execution, the resources should be released. */\nWasmEdge_ExecutorDelete(ExecCxt);\nWasmEdge_StatisticsDelete(StatCxt);\nWasmEdge_StoreDelete(StoreCxt);\nWasmEdge_ModuleInstanceDelete(ModCxt);\n'))),(0,s.kt)("li",{parentName:"ol"},(0,s.kt)("p",{parentName:"li"},"Register an existing ",(0,s.kt)("inlineCode",{parentName:"p"},"Module")," instance and export the module name"),(0,s.kt)("p",{parentName:"li"},"Besides instantiating and registering an ",(0,s.kt)("inlineCode",{parentName:"p"},"AST module")," contexts, developers can register an existing ",(0,s.kt)("inlineCode",{parentName:"p"},"Module")," instance into the store with exporting the module name (which is in the ",(0,s.kt)("inlineCode",{parentName:"p"},"Module")," instance already).\nThis case occurs when developers create a ",(0,s.kt)("inlineCode",{parentName:"p"},"Module")," instance for the host functions and want to register it for linking.\nFor the details about the construction of host functions in ",(0,s.kt)("inlineCode",{parentName:"p"},"Module")," instances, please refer to the ",(0,s.kt)("a",{parentName:"p",href:"#host-functions"},"Host Functions"),"."),(0,s.kt)("pre",{parentName:"li"},(0,s.kt)("code",{parentName:"pre",className:"language-c"},'/*\n * ...\n * Assume that the `ASTCxt` is the output AST module context from the loader\n * context and has passed the validation. Assume that the `ConfCxt` is the\n * configure context.\n */\n/* Create the statistics context. This step is not necessary. */\nWasmEdge_StatisticsContext *StatCxt = WasmEdge_StatisticsCreate();\n/*\n * Create the executor context. The configure and the statistics contexts\n * can be NULL.\n */\nWasmEdge_ExecutorContext *ExecCxt =\n    WasmEdge_ExecutorCreate(ConfCxt, StatCxt);\n/*\n * Create the store context. The store context is the object to link the\n * modules for imports and exports. \n */\nWasmEdge_StoreContext *StoreCxt = WasmEdge_StoreCreate();\n/* Result. */\nWasmEdge_Result Res;\n\n/* Create a module instance for host functions. */\nWasmEdge_String ModName = WasmEdge_StringCreateByCString("host-module");\nWasmEdge_ModuleInstanceContext *HostModCxt =\n    WasmEdge_ModuleInstanceCreate(ModName);\nWasmEdge_StringDelete(ModName);\n/*\n * ...\n * Create and add the host functions, tables, memories, and globals into the\n * module instance.\n */\n\n/* Register the module instance into store with the exported module name. */\n/* The export module name is in the module instance already. */\nRes = WasmEdge_ExecutorRegisterImport(ExecCxt, StoreCxt, HostModCxt);\nif (!WasmEdge_ResultOK(Res)) {\n  printf("WASM registration failed: %s\\n", WasmEdge_ResultGetMessage(Res));\n  return -1;\n}\n\n/* ... */\n\n/* After the execution, the resources should be released. */\nWasmEdge_ExecutorDelete(ExecCxt);\nWasmEdge_StatisticsDelete(StatCxt);\nWasmEdge_StoreDelete(StoreCxt);\nWasmEdge_ModuleInstanceDelete(ModCxt);\n'))),(0,s.kt)("li",{parentName:"ol"},(0,s.kt)("p",{parentName:"li"},"Instantiate an ",(0,s.kt)("inlineCode",{parentName:"p"},"AST module")," to an anonymous ",(0,s.kt)("inlineCode",{parentName:"p"},"Module")," instance"),(0,s.kt)("p",{parentName:"li"},"WASM or compiled-WASM modules should be instantiated before the function invocation.\nBefore instantiating a WASM module, please check the ",(0,s.kt)("a",{parentName:"p",href:"https://webassembly.github.io/spec/core/syntax/modules.html#syntax-import"},"import section")," for ensuring the imports are registered into the ",(0,s.kt)("inlineCode",{parentName:"p"},"Store")," context for linking."),(0,s.kt)("pre",{parentName:"li"},(0,s.kt)("code",{parentName:"pre",className:"language-c"},'/*\n * ...\n * Assume that the `ASTCxt` is the output AST module context from the loader\n * context and has passed the validation. Assume that the `ConfCxt` is the\n * configure context.\n */\n/* Create the statistics context. This step is not necessary. */\nWasmEdge_StatisticsContext *StatCxt = WasmEdge_StatisticsCreate();\n/*\n * Create the executor context. The configure and the statistics contexts\n * can be NULL.\n */\nWasmEdge_ExecutorContext *ExecCxt =\n    WasmEdge_ExecutorCreate(ConfCxt, StatCxt);\n/*\n * Create the store context. The store context is the object to link the\n * modules for imports and exports.\n */\nWasmEdge_StoreContext *StoreCxt = WasmEdge_StoreCreate();\n\n/* The output module instance. */\nWasmEdge_ModuleInstanceContext *ModCxt = NULL;\n/* Instantiate the WASM module. */\nWasmEdge_Result Res =\n    WasmEdge_ExecutorInstantiate(ExecCxt, &ModCxt, StoreCxt, ASTCxt);\nif (!WasmEdge_ResultOK(Res)) {\n  printf("WASM instantiation failed: %s\\n", WasmEdge_ResultGetMessage(Res));\n  return -1;\n}\n\n/* ... */\n\n/* After the execution, the resources should be released. */\nWasmEdge_ExecutorDelete(ExecCxt);\nWasmEdge_StatisticsDelete(StatCxt);\nWasmEdge_StoreDelete(StoreCxt);\nWasmEdge_ModuleInstanceDelete(ModCxt);\n'))),(0,s.kt)("li",{parentName:"ol"},(0,s.kt)("p",{parentName:"li"},"Invoke functions"),(0,s.kt)("p",{parentName:"li"},"After registering or instantiating and get the result ",(0,s.kt)("inlineCode",{parentName:"p"},"Module")," instance, developers can retrieve the exported ",(0,s.kt)("inlineCode",{parentName:"p"},"Function")," instances from the ",(0,s.kt)("inlineCode",{parentName:"p"},"Module")," instance for invocation.\nFor the details about the ",(0,s.kt)("inlineCode",{parentName:"p"},"Module")," instances APIs, please refer to the ",(0,s.kt)("a",{parentName:"p",href:"#instances"},"Instances"),".\nPlease refer to the ",(0,s.kt)("a",{parentName:"p",href:"#wasm-execution-example-step-by-step"},"example above")," for the ",(0,s.kt)("inlineCode",{parentName:"p"},"Function")," instance invocation with the ",(0,s.kt)("inlineCode",{parentName:"p"},"WasmEdge_ExecutorInvoke()")," API."))),(0,s.kt)("h3",{id:"ast-module"},"AST Module"),(0,s.kt)("p",null,"The ",(0,s.kt)("inlineCode",{parentName:"p"},"AST Module")," context presents the loaded structure from a WASM file or buffer. Developer will get this object after loading a WASM file or buffer from ",(0,s.kt)("a",{parentName:"p",href:"#loader"},"Loader"),".\nBefore instantiation, developers can also query the imports and exports of an ",(0,s.kt)("inlineCode",{parentName:"p"},"AST Module")," context."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-c"},"WasmEdge_ASTModuleContext *ASTCxt = ...;\n/* Assume that a WASM is loaded into an AST module context. */\n\n/* Create the import type context buffers. */\nconst uint32_t BUF_LEN = 256;\nconst WasmEdge_ImportTypeContext *ImpTypes[BUF_LEN];\nuint32_t ImportNum = WasmEdge_ASTModuleListImportsLength(ASTCxt);\n/*\n * If the list length is larger than the buffer length, the overflowed data will\n * be discarded.\n */\nuint32_t RealImportNum =\n    WasmEdge_ASTModuleListImports(ASTCxt, ImpTypes, BUF_LEN);\nfor (uint32_t I = 0; I < RealImportNum && I < BUF_LEN; I++) {\n  /* Working with the import type `ImpTypes[I]` ... */\n}\n\n/* Create the export type context buffers. */\nconst WasmEdge_ExportTypeContext *ExpTypes[BUF_LEN];\nuint32_t ExportNum = WasmEdge_ASTModuleListExportsLength(ASTCxt);\n/*\n * If the list length is larger than the buffer length, the overflowed data will\n * be discarded.\n */\nuint32_t RealExportNum =\n    WasmEdge_ASTModuleListExports(ASTCxt, ExpTypes, BUF_LEN);\nfor (uint32_t I = 0; I < RealExportNum && I < BUF_LEN; I++) {\n  /* Working with the export type `ExpTypes[I]` ... */\n}\n\nWasmEdge_ASTModuleDelete(ASTCxt);\n/*\n * After deletion of `ASTCxt`, all data queried from the `ASTCxt` should not be\n * accessed.\n */\n")),(0,s.kt)("h3",{id:"store"},"Store"),(0,s.kt)("p",null,(0,s.kt)("a",{parentName:"p",href:"https://webassembly.github.io/spec/core/exec/runtime.html#store"},"Store")," is the runtime structure for the representation of all global state that can be manipulated by WebAssembly programs.\nThe ",(0,s.kt)("inlineCode",{parentName:"p"},"Store")," context in WasmEdge is an object to provide the instance exporting and importing when instantiating WASM modules.\nDevelopers can retrieve the named modules from the ",(0,s.kt)("inlineCode",{parentName:"p"},"Store")," context."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-c"},'WasmEdge_StoreContext *StoreCxt = WasmEdge_StoreCreate();\n\n/*\n * ...\n * Register a WASM module via the executor context.\n */\n\n/* Try to list the registered WASM modules. */\nuint32_t ModNum = WasmEdge_StoreListModuleLength(StoreCxt);\n/* Create the name buffers. */\nconst uint32_t BUF_LEN = 256;\nWasmEdge_String ModNames[BUF_LEN];\n/*\n * If the list length is larger than the buffer length, the overflowed data will\n * be discarded.\n */\nuint32_t RealModNum = WasmEdge_StoreListModule(StoreCxt, ModNames, BUF_LEN);\nfor (uint32_t I = 0; I < RealModNum && I < BUF_LEN; I++) {\n  /* Working with the module name `ModNames[I]` ... */\n  /* The module names should __NOT__ be destroyed. */\n}\n\n/* Find named module by name. */\nWasmEdge_String ModName = WasmEdge_StringCreateByCString("module");\nconst WasmEdge_ModuleInstanceContext *ModCxt =\n    WasmEdge_StoreFindModule(StoreCxt, ModName);\n/* If the module with name not found, the `ModCxt` will be NULL. */\nWasmEdge_StringDelete(ModName);\n')),(0,s.kt)("h3",{id:"instances"},"Instances"),(0,s.kt)("p",null,"The instances are the runtime structures of WASM. Developers can retrieve the ",(0,s.kt)("inlineCode",{parentName:"p"},"Module")," instances from the ",(0,s.kt)("inlineCode",{parentName:"p"},"Store")," contexts, and retrieve the other instances from the ",(0,s.kt)("inlineCode",{parentName:"p"},"Module")," instances.\nA single instance can be allocated by its creation function. Developers can construct instances into an ",(0,s.kt)("inlineCode",{parentName:"p"},"Module")," instance for registration. Please refer to the ",(0,s.kt)("a",{parentName:"p",href:"#host-functions"},"Host Functions")," for details.\nThe instances created by their creation functions should be destroyed by developers, EXCEPT they are added into an ",(0,s.kt)("inlineCode",{parentName:"p"},"Module")," instance."),(0,s.kt)("ol",null,(0,s.kt)("li",{parentName:"ol"},(0,s.kt)("p",{parentName:"li"},"Module instance"),(0,s.kt)("p",{parentName:"li"},"After instantiating or registering an ",(0,s.kt)("inlineCode",{parentName:"p"},"AST module")," context, developers will get a ",(0,s.kt)("inlineCode",{parentName:"p"},"Module")," instance as the result, and have the responsibility to destroy it when not in use.\nA ",(0,s.kt)("inlineCode",{parentName:"p"},"Module")," instance can also be created for the host module. Please refer to the ",(0,s.kt)("a",{parentName:"p",href:"#host-functions"},"host function")," for the details.\n",(0,s.kt)("inlineCode",{parentName:"p"},"Module")," instance provides APIs to list and find the exported instances in the module."),(0,s.kt)("pre",{parentName:"li"},(0,s.kt)("code",{parentName:"pre",className:"language-c"},'/*\n * ...\n * Instantiate a WASM module via the executor context and get the `ModCxt`\n * as the output module instance.\n */\n\n/* Try to list the exported instance of the instantiated WASM module. */\n/* Take the function instances for example here. */\nuint32_t FuncNum = WasmEdge_ModuleInstanceListFunctionLength(ModCxt);\n/* Create the name buffers. */\nconst uint32_t BUF_LEN = 256;\nWasmEdge_String FuncNames[BUF_LEN];\n/*\n * If the list length is larger than the buffer length, the overflowed data\n * will be discarded.\n */\nuint32_t RealFuncNum =\n    WasmEdge_ModuleInstanceListFunction(ModCxt, FuncNames, BUF_LEN);\nfor (uint32_t I = 0; I < RealFuncNum && I < BUF_LEN; I++) {\n  /* Working with the function name `FuncNames[I]` ... */\n  /* The function names should __NOT__ be destroyed. */\n}\n\n/* Try to find the exported instance of the instantiated WASM module. */\n/* Take the function instances for example here. */\n/* Function name. */\nWasmEdge_String FuncName = WasmEdge_StringCreateByCString("fib");\nWasmEdge_FunctionInstanceContext *FuncCxt =\n    WasmEdge_ModuleInstanceFindFunction(ModCxt, FuncName);\n/* `FuncCxt` will be `NULL` if the function not found. */\n/*\n * The returned instance is owned by the module instance context and should\n * __NOT__ be destroyed.\n */\nWasmEdge_StringDelete(FuncName);\n'))),(0,s.kt)("li",{parentName:"ol"},(0,s.kt)("p",{parentName:"li"},"Function instance"),(0,s.kt)("p",{parentName:"li"},(0,s.kt)("a",{parentName:"p",href:"https://webassembly.github.io/spec/core/exec/runtime.html#syntax-hostfunc"},"Host functions")," are functions outside WebAssembly and passed to WASM modules as imports.\nIn WasmEdge, developers can create the ",(0,s.kt)("inlineCode",{parentName:"p"},"Function")," contexts for host functions and add them into an ",(0,s.kt)("inlineCode",{parentName:"p"},"Module")," instance context for registering into a ",(0,s.kt)("inlineCode",{parentName:"p"},"VM")," or a ",(0,s.kt)("inlineCode",{parentName:"p"},"Store"),".\nDevelopers can retrieve the ",(0,s.kt)("inlineCode",{parentName:"p"},"Function Type")," from the ",(0,s.kt)("inlineCode",{parentName:"p"},"Function")," contexts through the API.\nFor the details of the ",(0,s.kt)("inlineCode",{parentName:"p"},"Host Function")," guide, please refer to the ",(0,s.kt)("a",{parentName:"p",href:"#host-functions"},"next chapter"),"."),(0,s.kt)("pre",{parentName:"li"},(0,s.kt)("code",{parentName:"pre",className:"language-c"},"/* Retrieve the function instance from the module instance context. */\nWasmEdge_FunctionInstanceContext *FuncCxt = ...;\nWasmEdge_FunctionTypeContext *FuncTypeCxt =\n    WasmEdge_FunctionInstanceGetFunctionType(FuncCxt);\n/*\n * The `FuncTypeCxt` is owned by the `FuncCxt` and should __NOT__ be\n * destroyed.\n */\n\n/*\n * For the function instance creation, please refer to the `Host Function`\n * guide.\n */\n"))),(0,s.kt)("li",{parentName:"ol"},(0,s.kt)("p",{parentName:"li"},"Table instance"),(0,s.kt)("p",{parentName:"li"},"In WasmEdge, developers can create the ",(0,s.kt)("inlineCode",{parentName:"p"},"Table")," contexts and add them into an ",(0,s.kt)("inlineCode",{parentName:"p"},"Module")," instance context for registering into a ",(0,s.kt)("inlineCode",{parentName:"p"},"VM")," or a ",(0,s.kt)("inlineCode",{parentName:"p"},"Store"),".\nThe ",(0,s.kt)("inlineCode",{parentName:"p"},"Table")," contexts supply APIs to control the data in table instances."),(0,s.kt)("pre",{parentName:"li"},(0,s.kt)("code",{parentName:"pre",className:"language-c"},'WasmEdge_Limit TabLimit = {\n    .HasMax = true, .Shared = false, .Min = 10, .Max = 20};\n/* Create the table type with limit and the `FuncRef` element type. */\nWasmEdge_TableTypeContext *TabTypeCxt =\n    WasmEdge_TableTypeCreate(WasmEdge_RefType_FuncRef, TabLimit);\n/* Create the table instance with table type. */\nWasmEdge_TableInstanceContext *HostTable =\n    WasmEdge_TableInstanceCreate(TabTypeCxt);\n/* Delete the table type. */\nWasmEdge_TableTypeDelete(TabTypeCxt);\nWasmEdge_Result Res;\nWasmEdge_Value Data;\n\nTabTypeCxt = WasmEdge_TableInstanceGetTableType(HostTable);\n/*\n * The `TabTypeCxt` got from table instance is owned by the `HostTable` and\n * should __NOT__ be destroyed.\n */\nenum WasmEdge_RefType RefType = WasmEdge_TableTypeGetRefType(TabTypeCxt);\n/* `RefType` will be `WasmEdge_RefType_FuncRef`. */\nData = WasmEdge_ValueGenFuncRef(5);\nRes = WasmEdge_TableInstanceSetData(HostTable, Data, 3);\n/* Set the function index 5 to the table[3]. */\n/*\n * This will get an "out of bounds table access" error\n * because the position (13) is out of the table size (10):\n *   Res = WasmEdge_TableInstanceSetData(HostTable, Data, 13);\n */\nRes = WasmEdge_TableInstanceGetData(HostTable, &Data, 3);\n/* Get the FuncRef value of the table[3]. */\n/*\n * This will get an "out of bounds table access" error\n * because the position (13) is out of the table size (10):\n *   Res = WasmEdge_TableInstanceGetData(HostTable, &Data, 13);\n */\n\nuint32_t Size = WasmEdge_TableInstanceGetSize(HostTable);\n/* `Size` will be 10. */\nRes = WasmEdge_TableInstanceGrow(HostTable, 6);\n/* Grow the table size of 6, the table size will be 16. */\n/*\n * This will get an "out of bounds table access" error because\n * the size (16 + 6) will reach the table limit(20):\n *   Res = WasmEdge_TableInstanceGrow(HostTable, 6);\n */\n\nWasmEdge_TableInstanceDelete(HostTable);\n'))),(0,s.kt)("li",{parentName:"ol"},(0,s.kt)("p",{parentName:"li"},"Memory instance"),(0,s.kt)("p",{parentName:"li"},"In WasmEdge, developers can create the ",(0,s.kt)("inlineCode",{parentName:"p"},"Memory")," contexts and add them into an ",(0,s.kt)("inlineCode",{parentName:"p"},"Module")," instance context for registering into a ",(0,s.kt)("inlineCode",{parentName:"p"},"VM")," or a ",(0,s.kt)("inlineCode",{parentName:"p"},"Store"),".\nThe ",(0,s.kt)("inlineCode",{parentName:"p"},"Memory")," contexts supply APIs to control the data in memory instances."),(0,s.kt)("pre",{parentName:"li"},(0,s.kt)("code",{parentName:"pre",className:"language-c"},'WasmEdge_Limit MemLimit = {\n    .HasMax = true, .Shared = false, .Min = 1, .Max = 5};\n/* Create the memory type with limit. The memory page size is 64KiB. */\nWasmEdge_MemoryTypeContext *MemTypeCxt =\n    WasmEdge_MemoryTypeCreate(MemLimit);\n/* Create the memory instance with memory type. */\nWasmEdge_MemoryInstanceContext *HostMemory =\n    WasmEdge_MemoryInstanceCreate(MemTypeCxt);\n/* Delete the memory type. */\nWasmEdge_MemoryTypeDelete(MemTypeCxt);\nWasmEdge_Result Res;\nuint8_t Buf[256];\n\nBuf[0] = 0xAA;\nBuf[1] = 0xBB;\nBuf[2] = 0xCC;\nRes = WasmEdge_MemoryInstanceSetData(HostMemory, Buf, 0x1000, 3);\n/* Set the data[0:2] to the memory[4096:4098]. */\n/*\n * This will get an "out of bounds memory access" error\n * because [65535:65537] is out of 1 page size (65536):\n *   Res = WasmEdge_MemoryInstanceSetData(HostMemory, Buf, 0xFFFF, 3);\n */\nBuf[0] = 0;\nBuf[1] = 0;\nBuf[2] = 0;\nRes = WasmEdge_MemoryInstanceGetData(HostMemory, Buf, 0x1000, 3);\n/* Get the memory[4096:4098]. Buf[0:2] will be `{0xAA, 0xBB, 0xCC}`. */\n/*\n * This will get an "out of bounds memory access" error\n * because [65535:65537] is out of 1 page size (65536):\n *   Res = WasmEdge_MemoryInstanceSetData(HostMemory, Buf, 0xFFFF, 3);\n */\n\nuint32_t PageSize = WasmEdge_MemoryInstanceGetPageSize(HostMemory);\n/* `PageSize` will be 1. */\nRes = WasmEdge_MemoryInstanceGrowPage(HostMemory, 2);\n/* Grow the page size of 2, the page size of the memory instance will be 3.\n */\n/*\n * This will get an "out of bounds memory access" error because\n * the page size (3 + 3) will reach the memory limit(5):\n *   Res = WasmEdge_MemoryInstanceGrowPage(HostMemory, 3);\n */\n\nWasmEdge_MemoryInstanceDelete(HostMemory);\n'))),(0,s.kt)("li",{parentName:"ol"},(0,s.kt)("p",{parentName:"li"},"Global instance"),(0,s.kt)("p",{parentName:"li"},"In WasmEdge, developers can create the ",(0,s.kt)("inlineCode",{parentName:"p"},"Global")," contexts and add them into an ",(0,s.kt)("inlineCode",{parentName:"p"},"Module")," instance context for registering into a ",(0,s.kt)("inlineCode",{parentName:"p"},"VM")," or a ",(0,s.kt)("inlineCode",{parentName:"p"},"Store"),".\nThe ",(0,s.kt)("inlineCode",{parentName:"p"},"Global")," contexts supply APIs to control the value in global instances."),(0,s.kt)("pre",{parentName:"li"},(0,s.kt)("code",{parentName:"pre",className:"language-c"},"WasmEdge_Value Val = WasmEdge_ValueGenI64(1000);\n/* Create the global type with value type and mutation. */\nWasmEdge_GlobalTypeContext *GlobTypeCxt = WasmEdge_GlobalTypeCreate(\n    WasmEdge_ValType_I64, WasmEdge_Mutability_Var);\n/* Create the global instance with value and global type. */\nWasmEdge_GlobalInstanceContext *HostGlobal =\n    WasmEdge_GlobalInstanceCreate(GlobTypeCxt, Val);\n/* Delete the global type. */\nWasmEdge_GlobalTypeDelete(GlobTypeCxt);\nWasmEdge_Result Res;\n\nGlobTypeCxt = WasmEdge_GlobalInstanceGetGlobalType(HostGlobal);\n/* The `GlobTypeCxt` got from global instance is owned by the `HostGlobal`\n * and should __NOT__ be destroyed. */\nenum WasmEdge_ValType ValType = WasmEdge_GlobalTypeGetValType(GlobTypeCxt);\n/* `ValType` will be `WasmEdge_ValType_I64`. */\nenum WasmEdge_Mutability ValMut =\n    WasmEdge_GlobalTypeGetMutability(GlobTypeCxt);\n/* `ValMut` will be `WasmEdge_Mutability_Var`. */\n\nWasmEdge_GlobalInstanceSetValue(HostGlobal, WasmEdge_ValueGenI64(888));\n/*\n * Set the value u64(888) to the global.\n * This function will do nothing if the value type mismatched or\n * the global mutability is `WasmEdge_Mutability_Const`.\n */\nWasmEdge_Value GlobVal = WasmEdge_GlobalInstanceGetValue(HostGlobal);\n/* Get the value (888 now) of the global context. */\n\nWasmEdge_GlobalInstanceDelete(HostGlobal);\n")))),(0,s.kt)("h3",{id:"host-functions"},"Host Functions"),(0,s.kt)("p",null,(0,s.kt)("a",{parentName:"p",href:"https://webassembly.github.io/spec/core/exec/runtime.html#syntax-hostfunc"},"Host functions")," are functions outside WebAssembly and passed to WASM modules as imports.\nIn WasmEdge, developers can create the ",(0,s.kt)("inlineCode",{parentName:"p"},"Function"),", ",(0,s.kt)("inlineCode",{parentName:"p"},"Memory"),", ",(0,s.kt)("inlineCode",{parentName:"p"},"Table"),", and ",(0,s.kt)("inlineCode",{parentName:"p"},"Global")," contexts and add them into an ",(0,s.kt)("inlineCode",{parentName:"p"},"Module")," instance context for registering into a ",(0,s.kt)("inlineCode",{parentName:"p"},"VM")," or a ",(0,s.kt)("inlineCode",{parentName:"p"},"Store"),"."),(0,s.kt)("ol",null,(0,s.kt)("li",{parentName:"ol"},(0,s.kt)("p",{parentName:"li"},"Host function allocation"),(0,s.kt)("p",{parentName:"li"},"Developers can define C functions with the following function signature as the host function body:"),(0,s.kt)("pre",{parentName:"li"},(0,s.kt)("code",{parentName:"pre",className:"language-c"},"typedef WasmEdge_Result (*WasmEdge_HostFunc_t)(\n    void *Data, const WasmEdge_CallingFrameContext *CallFrameCxt,\n    const WasmEdge_Value *Params, WasmEdge_Value *Returns);\n")),(0,s.kt)("p",{parentName:"li"},"The example of an ",(0,s.kt)("inlineCode",{parentName:"p"},"add")," host function to add 2 ",(0,s.kt)("inlineCode",{parentName:"p"},"i32")," values:"),(0,s.kt)("pre",{parentName:"li"},(0,s.kt)("code",{parentName:"pre",className:"language-c"},"WasmEdge_Result Add(void *, const WasmEdge_CallingFrameContext *,\n                    const WasmEdge_Value *In, WasmEdge_Value *Out) {\n  /*\n  * Params: {i32, i32}\n  * Returns: {i32}\n  * Developers should take care about the function type.\n  */ \n  /* Retrieve the value 1. */\n  int32_t Val1 = WasmEdge_ValueGetI32(In[0]);\n  /* Retrieve the value 2. */\n  int32_t Val2 = WasmEdge_ValueGetI32(In[1]);\n  /* Output value 1 is Val1 + Val2. */\n  Out[0] = WasmEdge_ValueGenI32(Val1 + Val2);\n  /* Return the status of success. */\n  return WasmEdge_Result_Success;\n}\n")),(0,s.kt)("p",{parentName:"li"},"Then developers can create ",(0,s.kt)("inlineCode",{parentName:"p"},"Function")," context with the host function body and the function type:"),(0,s.kt)("pre",{parentName:"li"},(0,s.kt)("code",{parentName:"pre",className:"language-c"},"enum WasmEdge_ValType ParamList[2] = {WasmEdge_ValType_I32,\n                                      WasmEdge_ValType_I32};\nenum WasmEdge_ValType ReturnList[1] = {WasmEdge_ValType_I32};\n/* Create a function type: {i32, i32} -> {i32}. */\nWasmEdge_FunctionTypeContext *HostFType =\n    WasmEdge_FunctionTypeCreate(ParamList, 2, ReturnList, 1);\n/*\n * Create a function context with the function type and host function body.\n * The `Cost` parameter can be 0 if developers do not need the cost\n * measuring.\n */\nWasmEdge_FunctionInstanceContext *HostFunc =\n    WasmEdge_FunctionInstanceCreate(HostFType, Add, NULL, 0);\n/*\n * The third parameter is the pointer to the additional data.\n * Developers should guarantee the life cycle of the data, and it can be\n * `NULL` if the external data is not needed.\n */\nWasmEdge_FunctionTypeDelete(HostType);\n\n/*\n * If the function instance is __NOT__ added into a module instance context,\n * it should be deleted.\n */\nWasmEdge_FunctionInstanceDelete(HostFunc);\n"))),(0,s.kt)("li",{parentName:"ol"},(0,s.kt)("p",{parentName:"li"},"Calling frame context"),(0,s.kt)("p",{parentName:"li"},"The ",(0,s.kt)("inlineCode",{parentName:"p"},"WasmEdge_CallingFrameContext")," is the context to provide developers to access the module instance of the ",(0,s.kt)("a",{parentName:"p",href:"https://webassembly.github.io/spec/core/exec/runtime.html#activations-and-frames"},"frame on the top of the calling stack"),".\nAccording to the ",(0,s.kt)("a",{parentName:"p",href:"https://webassembly.github.io/spec/core/exec/instructions.html#function-calls"},"WASM spec"),", a frame with the module instance is pushed into the stack when invoking a function.\nTherefore, the host functions can access the module instance of the top frame to retrieve the memory instances to read/write data."),(0,s.kt)("pre",{parentName:"li"},(0,s.kt)("code",{parentName:"pre",className:"language-c"},'WasmEdge_Result LoadOffset(void *Data,\n                           const WasmEdge_CallingFrameContext *CallFrameCxt,\n                           const WasmEdge_Value *In, WasmEdge_Value *Out) {\n  /* Function type: {i32} -> {} */\n  uint32_t Offset = (uint32_t)WasmEdge_ValueGetI32(In[0]);\n  uint32_t Num = 0;\n\n  /*\n   * Get the 0-th memory instance of the module instance of the top frame on\n   * stack.\n   */\n  WasmEdge_MemoryInstanceContext *MemCxt =\n      WasmEdge_CallingFrameGetMemoryInstance(CallFrameCxt, 0);\n\n  WasmEdge_Result Res =\n      WasmEdge_MemoryInstanceGetData(MemCxt, (uint8_t *)(&Num), Offset, 4);\n  if (WasmEdge_ResultOK(Res)) {\n    printf("u32 at memory[%lu]: %lu\\n", Offset, Num);\n  } else {\n    return Res;\n  }\n  return WasmEdge_Result_Success;\n}\n')),(0,s.kt)("p",{parentName:"li"},"Besides using the ",(0,s.kt)("inlineCode",{parentName:"p"},"WasmEdge_CallingFrameGetMemoryInstance()")," API to get the memory instance by index in the module instance, developers can use the ",(0,s.kt)("inlineCode",{parentName:"p"},"WasmEdge_CallingFrameGetModuleInstance()")," to get the module instance directly.\nTherefore, developers can retrieve the exported contexts by the ",(0,s.kt)("inlineCode",{parentName:"p"},"WasmEdge_ModuleInstanceContext")," APIs.\nAnd also, developers can use the ",(0,s.kt)("inlineCode",{parentName:"p"},"WasmEdge_CallingFrameGetExecutor()")," API to get the currently used executor context.")),(0,s.kt)("li",{parentName:"ol"},(0,s.kt)("p",{parentName:"li"},"User-defined error code of the host functions"),(0,s.kt)("p",{parentName:"li"},"In host functions, WasmEdge provides ",(0,s.kt)("inlineCode",{parentName:"p"},"WasmEdge_Result_Success")," to return success, ",(0,s.kt)("inlineCode",{parentName:"p"},"WasmEdge_Result_Terminate")," to terminate the WASM execution, and ",(0,s.kt)("inlineCode",{parentName:"p"},"WasmEdge_Result_Fail")," to return fail.\nWasmEdge also provides the usage of returning the user-specified codes.\nDevelopers can use the ",(0,s.kt)("inlineCode",{parentName:"p"},"WasmEdge_ResultGen()")," API to generate the ",(0,s.kt)("inlineCode",{parentName:"p"},"WasmEdge_Result")," with error code, and use the ",(0,s.kt)("inlineCode",{parentName:"p"},"WasmEdge_ResultGetCode()")," API to get the error code."),(0,s.kt)("blockquote",{parentName:"li"},(0,s.kt)("p",{parentName:"blockquote"},"Notice: The error code only supports 24-bit integer (0 ~ 16777216 in ",(0,s.kt)("inlineCode",{parentName:"p"},"uint32_t"),"). The values larger than 24-bit will be truncated.")),(0,s.kt)("p",{parentName:"li"},"Assume that a simple WASM from the WAT is as following:"),(0,s.kt)("pre",{parentName:"li"},(0,s.kt)("code",{parentName:"pre",className:"language-wasm"},'(module\n  (type $t0 (func (param i32)))\n  (import "extern" "trap" (func $f-trap (type $t0)))\n  (func (export "trap") (param i32)\n    local.get 0\n    call $f-trap)\n)\n')),(0,s.kt)("p",{parentName:"li"},"And the ",(0,s.kt)("inlineCode",{parentName:"p"},"test.c")," is as following:"),(0,s.kt)("pre",{parentName:"li"},(0,s.kt)("code",{parentName:"pre",className:"language-c"},'#include <wasmedge/wasmedge.h>\n#include <stdio.h>\n\n/* Host function body definition. */\nWasmEdge_Result Trap(void *Data,\n                     const WasmEdge_CallingFrameContext *CallFrameCxt,\n                     const WasmEdge_Value *In, WasmEdge_Value *Out) {\n  int32_t Val = WasmEdge_ValueGetI32(In[0]);\n  /* Return the error code from the param[0]. */\n  return WasmEdge_ResultGen(WasmEdge_ErrCategory_UserLevelError, Val);\n}\n\nint main() {\n  /* Create the VM context. */\n  WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(NULL, NULL);\n\n  /* The WASM module buffer. */\n  uint8_t WASM[] = {/* WASM header */\n                    0x00, 0x61, 0x73, 0x6D, 0x01, 0x00, 0x00, 0x00,\n                    /* Type section */\n                    0x01, 0x05, 0x01,\n                    /* function type {i32} -> {} */\n                    0x60, 0x01, 0x7F, 0x00,\n                    /* Import section */\n                    0x02, 0x0F, 0x01,\n                    /* module name: "extern" */\n                    0x06, 0x65, 0x78, 0x74, 0x65, 0x72, 0x6E,\n                    /* extern name: "trap" */\n                    0x04, 0x74, 0x72, 0x61, 0x70,\n                    /* import desc: func 0 */\n                    0x00, 0x00,\n                    /* Function section */\n                    0x03, 0x02, 0x01, 0x00,\n                    /* Export section */\n                    0x07, 0x08, 0x01,\n                    /* export name: "trap" */\n                    0x04, 0x74, 0x72, 0x61, 0x70,\n                    /* export desc: func 0 */\n                    0x00, 0x01,\n                    /* Code section */\n                    0x0A, 0x08, 0x01,\n                    /* code body */\n                    0x06, 0x00, 0x20, 0x00, 0x10, 0x00, 0x0B};\n\n  /* Create the module instance. */\n  WasmEdge_String ExportName = WasmEdge_StringCreateByCString("extern");\n  WasmEdge_ModuleInstanceContext *HostModCxt =\n      WasmEdge_ModuleInstanceCreate(ExportName);\n  enum WasmEdge_ValType ParamList[1] = {WasmEdge_ValType_I32};\n  WasmEdge_FunctionTypeContext *HostFType =\n      WasmEdge_FunctionTypeCreate(ParamList, 1, NULL, 0);\n  WasmEdge_FunctionInstanceContext *HostFunc =\n      WasmEdge_FunctionInstanceCreate(HostFType, Trap, NULL, 0);\n  WasmEdge_FunctionTypeDelete(HostFType);\n  WasmEdge_String HostFuncName = WasmEdge_StringCreateByCString("trap");\n  WasmEdge_ModuleInstanceAddFunction(HostModCxt, HostFuncName, HostFunc);\n  WasmEdge_StringDelete(HostFuncName);\n\n  WasmEdge_VMRegisterModuleFromImport(VMCxt, HostModCxt);\n\n  /* The parameters and returns arrays. */\n  WasmEdge_Value Params[1] = {WasmEdge_ValueGenI32(5566)};\n  /* Function name. */\n  WasmEdge_String FuncName = WasmEdge_StringCreateByCString("trap");\n  /* Run the WASM function from file. */\n  WasmEdge_Result Res = WasmEdge_VMRunWasmFromBuffer(\n      VMCxt, WASM, sizeof(WASM), FuncName, Params, 1, NULL, 0);\n\n  /* Get the result code and print. */\n  printf("Get the error code: %u\\n", WasmEdge_ResultGetCode(Res));\n\n  /* Resources deallocations. */\n  WasmEdge_VMDelete(VMCxt);\n  WasmEdge_StringDelete(FuncName);\n  WasmEdge_ModuleInstanceDelete(HostModCxt);\n  return 0;\n}\n')),(0,s.kt)("p",{parentName:"li"},"Then you can compile and run: (giving the expected error code ",(0,s.kt)("inlineCode",{parentName:"p"},"5566"),")"),(0,s.kt)("pre",{parentName:"li"},(0,s.kt)("code",{parentName:"pre",className:"language-bash"},'$ gcc test.c -lwasmedge\n$ ./a.out\n[2022-08-26 15:06:40.384] [error] user defined failed: user defined error code, Code: 0x15be\n[2022-08-26 15:06:40.384] [error]     When executing function name: "trap"\nGet the error code: 5566\n'))),(0,s.kt)("li",{parentName:"ol"},(0,s.kt)("p",{parentName:"li"},"Construct a module instance with host instances"),(0,s.kt)("p",{parentName:"li"},"Besides creating a ",(0,s.kt)("inlineCode",{parentName:"p"},"Module")," instance by registering or instantiating a WASM module, developers can create a ",(0,s.kt)("inlineCode",{parentName:"p"},"Module")," instance with a module name and add the ",(0,s.kt)("inlineCode",{parentName:"p"},"Function"),", ",(0,s.kt)("inlineCode",{parentName:"p"},"Memory"),", ",(0,s.kt)("inlineCode",{parentName:"p"},"Table"),", and ",(0,s.kt)("inlineCode",{parentName:"p"},"Global")," instances into it with their exporting names."),(0,s.kt)("pre",{parentName:"li"},(0,s.kt)("code",{parentName:"pre",className:"language-c"},'/* Host function body definition. */\nWasmEdge_Result Add(void *Data,\n                    const WasmEdge_CallingFrameContext *CallFrameCxt,\n                    const WasmEdge_Value *In, WasmEdge_Value *Out) {\n  int32_t Val1 = WasmEdge_ValueGetI32(In[0]);\n  int32_t Val2 = WasmEdge_ValueGetI32(In[1]);\n  Out[0] = WasmEdge_ValueGenI32(Val1 + Val2);\n  return WasmEdge_Result_Success;\n}\n\n/* Create a module instance. */\nWasmEdge_String ExportName = WasmEdge_StringCreateByCString("module");\nWasmEdge_ModuleInstanceContext *HostModCxt =\n    WasmEdge_ModuleInstanceCreate(ExportName);\nWasmEdge_StringDelete(ExportName);\n\n/* Create and add a function instance into the module instance. */\nenum WasmEdge_ValType ParamList[2] = {WasmEdge_ValType_I32,\n                                      WasmEdge_ValType_I32};\nenum WasmEdge_ValType ReturnList[1] = {WasmEdge_ValType_I32};\nWasmEdge_FunctionTypeContext *HostFType =\n    WasmEdge_FunctionTypeCreate(ParamList, 2, ReturnList, 1);\nWasmEdge_FunctionInstanceContext *HostFunc =\n    WasmEdge_FunctionInstanceCreate(HostFType, Add, NULL, 0);\n/*\n * The third parameter is the pointer to the additional data object.\n * Developers should guarantee the life cycle of the data, and it can be\n * `NULL` if the external data is not needed.\n */\nWasmEdge_FunctionTypeDelete(HostFType);\nWasmEdge_String FuncName = WasmEdge_StringCreateByCString("add");\nWasmEdge_ModuleInstanceAddFunction(HostModCxt, FuncName, HostFunc);\nWasmEdge_StringDelete(FuncName);\n\n/* Create and add a table instance into the import object. */\nWasmEdge_Limit TableLimit = {\n    .HasMax = true, .Shared = false, .Min = 10, .Max = 20};\nWasmEdge_TableTypeContext *HostTType =\n    WasmEdge_TableTypeCreate(WasmEdge_RefType_FuncRef, TableLimit);\nWasmEdge_TableInstanceContext *HostTable =\n    WasmEdge_TableInstanceCreate(HostTType);\nWasmEdge_TableTypeDelete(HostTType);\nWasmEdge_String TableName = WasmEdge_StringCreateByCString("table");\nWasmEdge_ModuleInstanceAddTable(HostModCxt, TableName, HostTable);\nWasmEdge_StringDelete(TableName);\n\n/* Create and add a memory instance into the import object. */\nWasmEdge_Limit MemoryLimit = {\n    .HasMax = true, .Shared = false, .Min = 1, .Max = 2};\nWasmEdge_MemoryTypeContext *HostMType =\n    WasmEdge_MemoryTypeCreate(MemoryLimit);\nWasmEdge_MemoryInstanceContext *HostMemory =\n    WasmEdge_MemoryInstanceCreate(HostMType);\nWasmEdge_MemoryTypeDelete(HostMType);\nWasmEdge_String MemoryName = WasmEdge_StringCreateByCString("memory");\nWasmEdge_ModuleInstanceAddMemory(HostModCxt, MemoryName, HostMemory);\nWasmEdge_StringDelete(MemoryName);\n\n/* Create and add a global instance into the module instance. */\nWasmEdge_GlobalTypeContext *HostGType = WasmEdge_GlobalTypeCreate(\n    WasmEdge_ValType_I32, WasmEdge_Mutability_Var);\nWasmEdge_GlobalInstanceContext *HostGlobal =\n    WasmEdge_GlobalInstanceCreate(HostGType, WasmEdge_ValueGenI32(666));\nWasmEdge_GlobalTypeDelete(HostGType);\nWasmEdge_String GlobalName = WasmEdge_StringCreateByCString("global");\nWasmEdge_ModuleInstanceAddGlobal(HostModCxt, GlobalName, HostGlobal);\nWasmEdge_StringDelete(GlobalName);\n\n/*\n * The module instance should be deleted.\n * Developers should __NOT__ destroy the instances added into the module\n * instance contexts.\n */\nWasmEdge_ModuleInstanceDelete(HostModCxt);\n'))),(0,s.kt)("li",{parentName:"ol"},(0,s.kt)("p",{parentName:"li"},"Specified module instance"),(0,s.kt)("p",{parentName:"li"},(0,s.kt)("inlineCode",{parentName:"p"},"WasmEdge_ModuleInstanceCreateWASI()")," API can create and initialize the ",(0,s.kt)("inlineCode",{parentName:"p"},"WASI")," module instance."),(0,s.kt)("p",{parentName:"li"},(0,s.kt)("inlineCode",{parentName:"p"},"WasmEdge_ModuleInstanceCreateWasiNN()")," API can create and initialize the ",(0,s.kt)("inlineCode",{parentName:"p"},"wasi_ephemeral_nn")," module instance for ",(0,s.kt)("inlineCode",{parentName:"p"},"WASI-NN")," plugin."),(0,s.kt)("p",{parentName:"li"},(0,s.kt)("inlineCode",{parentName:"p"},"WasmEdge_ModuleInstanceCreateWasiCryptoCommon()")," API can create and initialize the ",(0,s.kt)("inlineCode",{parentName:"p"},"wasi_ephemeral_crypto_common")," module instance for ",(0,s.kt)("inlineCode",{parentName:"p"},"WASI-Crypto")," plugin."),(0,s.kt)("p",{parentName:"li"},(0,s.kt)("inlineCode",{parentName:"p"},"WasmEdge_ModuleInstanceCreateWasiCryptoAsymmetricCommon()")," API can create and initialize the ",(0,s.kt)("inlineCode",{parentName:"p"},"wasi_ephemeral_crypto_asymmetric_common")," module instance for ",(0,s.kt)("inlineCode",{parentName:"p"},"WASI-Crypto")," plugin."),(0,s.kt)("p",{parentName:"li"},(0,s.kt)("inlineCode",{parentName:"p"},"WasmEdge_ModuleInstanceCreateWasiCryptoKx()")," API can create and initialize the ",(0,s.kt)("inlineCode",{parentName:"p"},"wasi_ephemeral_crypto_kx")," module instance for ",(0,s.kt)("inlineCode",{parentName:"p"},"WASI-Crypto")," plugin."),(0,s.kt)("p",{parentName:"li"},(0,s.kt)("inlineCode",{parentName:"p"},"WasmEdge_ModuleInstanceCreateWasiCryptoSignatures()")," API can create and initialize the ",(0,s.kt)("inlineCode",{parentName:"p"},"wasi_ephemeral_crypto_signatures")," module instance for ",(0,s.kt)("inlineCode",{parentName:"p"},"WASI-Crypto")," plugin."),(0,s.kt)("p",{parentName:"li"},(0,s.kt)("inlineCode",{parentName:"p"},"WasmEdge_ModuleInstanceCreateWasiCryptoSymmetric()")," API can create and initialize the ",(0,s.kt)("inlineCode",{parentName:"p"},"wasi_ephemeral_crypto_symmetric")," module instance for ",(0,s.kt)("inlineCode",{parentName:"p"},"WASI-Crypto")," plugin."),(0,s.kt)("p",{parentName:"li"},(0,s.kt)("inlineCode",{parentName:"p"},"WasmEdge_ModuleInstanceCreateWasmEdgeProcess()")," API can create and initialize the ",(0,s.kt)("inlineCode",{parentName:"p"},"wasmedge_process")," module instance for ",(0,s.kt)("inlineCode",{parentName:"p"},"wasmedge_process")," plugin."),(0,s.kt)("p",{parentName:"li"},"Developers can create these module instance contexts and register them into the ",(0,s.kt)("inlineCode",{parentName:"p"},"Store")," or ",(0,s.kt)("inlineCode",{parentName:"p"},"VM")," contexts rather than adjust the settings in the ",(0,s.kt)("inlineCode",{parentName:"p"},"Configure")," contexts."),(0,s.kt)("blockquote",{parentName:"li"},(0,s.kt)("p",{parentName:"blockquote"},"Note: For the ",(0,s.kt)("inlineCode",{parentName:"p"},"WASI-NN")," plugin, please check that the ",(0,s.kt)("a",{parentName:"p",href:"/book/develop/build-and-run/install#install-plugins-and-extensions"},"dependencies and prerequisites")," are satisfied.\nNote: For the ",(0,s.kt)("inlineCode",{parentName:"p"},"WASI-Crypto")," plugin, please check that the ",(0,s.kt)("a",{parentName:"p",href:"/book/develop/build-and-run/install#install-plugins-and-extensions"},"dependencies and prerequisites")," are satisfied. And the 5 modules are recommended to all be created and registered together.")),(0,s.kt)("pre",{parentName:"li"},(0,s.kt)("code",{parentName:"pre",className:"language-c"},"WasmEdge_ModuleInstanceContext *WasiModCxt =\n    WasmEdge_ModuleInstanceCreateWASI(/* ... ignored */);\nWasmEdge_ModuleInstanceContext *ProcModCxt =\n    WasmEdge_ModuleInstanceCreateWasmEdgeProcess(/* ... ignored */);\nWasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(NULL, NULL);\n/* Register the WASI and WasmEdge_Process into the VM context. */\nWasmEdge_VMRegisterModuleFromImport(VMCxt, WasiModCxt);\nWasmEdge_VMRegisterModuleFromImport(VMCxt, ProcModCxt);\n/* Get the WASI exit code. */\nuint32_t ExitCode = WasmEdge_ModuleInstanceWASIGetExitCode(WasiModCxt);\n/*\n * The `ExitCode` will be EXIT_SUCCESS if the execution has no error.\n * Otherwise, it will return with the related exit code.\n */\nWasmEdge_VMDelete(VMCxt);\n/* The module instances should be deleted. */\nWasmEdge_ModuleInstanceDelete(WasiModCxt);\nWasmEdge_ModuleInstanceDelete(ProcModCxt);\n"))),(0,s.kt)("li",{parentName:"ol"},(0,s.kt)("p",{parentName:"li"},"Example"),(0,s.kt)("p",{parentName:"li"},"Assume that a simple WASM from the WAT is as following:"),(0,s.kt)("pre",{parentName:"li"},(0,s.kt)("code",{parentName:"pre",className:"language-wasm"},'(module\n  (type $t0 (func (param i32 i32) (result i32)))\n  (import "extern" "func-add" (func $f-add (type $t0)))\n  (func (export "addTwo") (param i32 i32) (result i32)\n    local.get 0\n    local.get 1\n    call $f-add)\n)\n')),(0,s.kt)("p",{parentName:"li"},"And the ",(0,s.kt)("inlineCode",{parentName:"p"},"test.c")," is as following:"),(0,s.kt)("pre",{parentName:"li"},(0,s.kt)("code",{parentName:"pre",className:"language-c"},'#include <wasmedge/wasmedge.h>\n#include <stdio.h>\n\n/* Host function body definition. */\nWasmEdge_Result Add(void *Data,\n                    const WasmEdge_CallingFrameContext *CallFrameCxt,\n                    const WasmEdge_Value *In, WasmEdge_Value *Out) {\n  int32_t Val1 = WasmEdge_ValueGetI32(In[0]);\n  int32_t Val2 = WasmEdge_ValueGetI32(In[1]);\n  printf("Host function \\"Add\\": %d + %d\\n", Val1, Val2);\n  Out[0] = WasmEdge_ValueGenI32(Val1 + Val2);\n  return WasmEdge_Result_Success;\n}\n\nint main() {\n  /* Create the VM context. */\n  WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(NULL, NULL);\n\n  /* The WASM module buffer. */\n  uint8_t WASM[] = {/* WASM header */\n                    0x00, 0x61, 0x73, 0x6D, 0x01, 0x00, 0x00, 0x00,\n                    /* Type section */\n                    0x01, 0x07, 0x01,\n                    /* function type {i32, i32} -> {i32} */\n                    0x60, 0x02, 0x7F, 0x7F, 0x01, 0x7F,\n                    /* Import section */\n                    0x02, 0x13, 0x01,\n                    /* module name: "extern" */\n                    0x06, 0x65, 0x78, 0x74, 0x65, 0x72, 0x6E,\n                    /* extern name: "func-add" */\n                    0x08, 0x66, 0x75, 0x6E, 0x63, 0x2D, 0x61, 0x64, 0x64,\n                    /* import desc: func 0 */\n                    0x00, 0x00,\n                    /* Function section */\n                    0x03, 0x02, 0x01, 0x00,\n                    /* Export section */\n                    0x07, 0x0A, 0x01,\n                    /* export name: "addTwo" */\n                    0x06, 0x61, 0x64, 0x64, 0x54, 0x77, 0x6F,\n                    /* export desc: func 0 */\n                    0x00, 0x01,\n                    /* Code section */\n                    0x0A, 0x0A, 0x01,\n                    /* code body */\n                    0x08, 0x00, 0x20, 0x00, 0x20, 0x01, 0x10, 0x00, 0x0B};\n\n  /* Create the module instance. */\n  WasmEdge_String ExportName = WasmEdge_StringCreateByCString("extern");\n  WasmEdge_ModuleInstanceContext *HostModCxt =\n      WasmEdge_ModuleInstanceCreate(ExportName);\n  enum WasmEdge_ValType ParamList[2] = {WasmEdge_ValType_I32,\n                                        WasmEdge_ValType_I32};\n  enum WasmEdge_ValType ReturnList[1] = {WasmEdge_ValType_I32};\n  WasmEdge_FunctionTypeContext *HostFType =\n      WasmEdge_FunctionTypeCreate(ParamList, 2, ReturnList, 1);\n  WasmEdge_FunctionInstanceContext *HostFunc =\n      WasmEdge_FunctionInstanceCreate(HostFType, Add, NULL, 0);\n  WasmEdge_FunctionTypeDelete(HostFType);\n  WasmEdge_String HostFuncName = WasmEdge_StringCreateByCString("func-add");\n  WasmEdge_ModuleInstanceAddFunction(HostModCxt, HostFuncName, HostFunc);\n  WasmEdge_StringDelete(HostFuncName);\n\n  WasmEdge_VMRegisterModuleFromImport(VMCxt, HostModCxt);\n\n  /* The parameters and returns arrays. */\n  WasmEdge_Value Params[2] = {WasmEdge_ValueGenI32(1234),\n                              WasmEdge_ValueGenI32(5678)};\n  WasmEdge_Value Returns[1];\n  /* Function name. */\n  WasmEdge_String FuncName = WasmEdge_StringCreateByCString("addTwo");\n  /* Run the WASM function from file. */\n  WasmEdge_Result Res = WasmEdge_VMRunWasmFromBuffer(\n      VMCxt, WASM, sizeof(WASM), FuncName, Params, 2, Returns, 1);\n\n  if (WasmEdge_ResultOK(Res)) {\n    printf("Get the result: %d\\n", WasmEdge_ValueGetI32(Returns[0]));\n  } else {\n    printf("Error message: %s\\n", WasmEdge_ResultGetMessage(Res));\n  }\n\n  /* Resources deallocations. */\n  WasmEdge_VMDelete(VMCxt);\n  WasmEdge_StringDelete(FuncName);\n  WasmEdge_ModuleInstanceDelete(HostModCxt);\n  return 0;\n}\n')),(0,s.kt)("p",{parentName:"li"},"Then you can compile and run: (the result of 1234 + 5678 is 6912)"),(0,s.kt)("pre",{parentName:"li"},(0,s.kt)("code",{parentName:"pre",className:"language-bash"},'$ gcc test.c -lwasmedge\n$ ./a.out\nHost function "Add": 1234 + 5678\nGet the result: 6912\n'))),(0,s.kt)("li",{parentName:"ol"},(0,s.kt)("p",{parentName:"li"},"Host Data Example"),(0,s.kt)("p",{parentName:"li"},"Developers can set a external data object to the ",(0,s.kt)("inlineCode",{parentName:"p"},"Function")," context, and access to the object in the function body.\nAssume that a simple WASM from the WAT is as following:"),(0,s.kt)("pre",{parentName:"li"},(0,s.kt)("code",{parentName:"pre",className:"language-wasm"},'(module\n  (type $t0 (func (param i32 i32) (result i32)))\n  (import "extern" "func-add" (func $f-add (type $t0)))\n  (func (export "addTwo") (param i32 i32) (result i32)\n    local.get 0\n    local.get 1\n    call $f-add)\n)\n')),(0,s.kt)("p",{parentName:"li"},"And the ",(0,s.kt)("inlineCode",{parentName:"p"},"test.c")," is as following:"),(0,s.kt)("pre",{parentName:"li"},(0,s.kt)("code",{parentName:"pre",className:"language-c"},'#include <wasmedge/wasmedge.h>\n#include <stdio.h>\n\n/* Host function body definition. */\nWasmEdge_Result Add(void *Data,\n                    const WasmEdge_CallingFrameContext *CallFrameCxt,\n                    const WasmEdge_Value *In, WasmEdge_Value *Out) {\n  int32_t Val1 = WasmEdge_ValueGetI32(In[0]);\n  int32_t Val2 = WasmEdge_ValueGetI32(In[1]);\n  printf("Host function \\"Add\\": %d + %d\\n", Val1, Val2);\n  Out[0] = WasmEdge_ValueGenI32(Val1 + Val2);\n  /* Also set the result to the data. */\n  int32_t *DataPtr = (int32_t *)Data;\n  *DataPtr = Val1 + Val2;\n  return WasmEdge_Result_Success;\n}\n\nint main() {\n  /* Create the VM context. */\n  WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(NULL, NULL);\n\n  /* The WASM module buffer. */\n  uint8_t WASM[] = {/* WASM header */\n                    0x00, 0x61, 0x73, 0x6D, 0x01, 0x00, 0x00, 0x00,\n                    /* Type section */\n                    0x01, 0x07, 0x01,\n                    /* function type {i32, i32} -> {i32} */\n                    0x60, 0x02, 0x7F, 0x7F, 0x01, 0x7F,\n                    /* Import section */\n                    0x02, 0x13, 0x01,\n                    /* module name: "extern" */\n                    0x06, 0x65, 0x78, 0x74, 0x65, 0x72, 0x6E,\n                    /* extern name: "func-add" */\n                    0x08, 0x66, 0x75, 0x6E, 0x63, 0x2D, 0x61, 0x64, 0x64,\n                    /* import desc: func 0 */\n                    0x00, 0x00,\n                    /* Function section */\n                    0x03, 0x02, 0x01, 0x00,\n                    /* Export section */\n                    0x07, 0x0A, 0x01,\n                    /* export name: "addTwo" */\n                    0x06, 0x61, 0x64, 0x64, 0x54, 0x77, 0x6F,\n                    /* export desc: func 0 */\n                    0x00, 0x01,\n                    /* Code section */\n                    0x0A, 0x0A, 0x01,\n                    /* code body */\n                    0x08, 0x00, 0x20, 0x00, 0x20, 0x01, 0x10, 0x00, 0x0B};\n\n  /* The external data object: an integer. */\n  int32_t Data;\n\n  /* Create the module instance. */\n  WasmEdge_String ExportName = WasmEdge_StringCreateByCString("extern");\n  WasmEdge_ModuleInstanceContext *HostModCxt =\n      WasmEdge_ModuleInstanceCreate(ExportName);\n  enum WasmEdge_ValType ParamList[2] = {WasmEdge_ValType_I32,\n                                        WasmEdge_ValType_I32};\n  enum WasmEdge_ValType ReturnList[1] = {WasmEdge_ValType_I32};\n  WasmEdge_FunctionTypeContext *HostFType =\n      WasmEdge_FunctionTypeCreate(ParamList, 2, ReturnList, 1);\n  WasmEdge_FunctionInstanceContext *HostFunc =\n      WasmEdge_FunctionInstanceCreate(HostFType, Add, &Data, 0);\n  WasmEdge_FunctionTypeDelete(HostFType);\n  WasmEdge_String HostFuncName = WasmEdge_StringCreateByCString("func-add");\n  WasmEdge_ModuleInstanceAddFunction(HostModCxt, HostFuncName, HostFunc);\n  WasmEdge_StringDelete(HostFuncName);\n\n  WasmEdge_VMRegisterModuleFromImport(VMCxt, HostModCxt);\n\n  /* The parameters and returns arrays. */\n  WasmEdge_Value Params[2] = {WasmEdge_ValueGenI32(1234),\n                              WasmEdge_ValueGenI32(5678)};\n  WasmEdge_Value Returns[1];\n  /* Function name. */\n  WasmEdge_String FuncName = WasmEdge_StringCreateByCString("addTwo");\n  /* Run the WASM function from file. */\n  WasmEdge_Result Res = WasmEdge_VMRunWasmFromBuffer(\n      VMCxt, WASM, sizeof(WASM), FuncName, Params, 2, Returns, 1);\n\n  if (WasmEdge_ResultOK(Res)) {\n    printf("Get the result: %d\\n", WasmEdge_ValueGetI32(Returns[0]));\n  } else {\n    printf("Error message: %s\\n", WasmEdge_ResultGetMessage(Res));\n  }\n  printf("Data value: %d\\n", Data);\n\n  /* Resources deallocations. */\n  WasmEdge_VMDelete(VMCxt);\n  WasmEdge_StringDelete(FuncName);\n  WasmEdge_ModuleInstanceDelete(HostModCxt);\n  return 0;\n}\n')),(0,s.kt)("p",{parentName:"li"},"Then you can compile and run: (the result of 1234 + 5678 is 6912)"),(0,s.kt)("pre",{parentName:"li"},(0,s.kt)("code",{parentName:"pre",className:"language-bash"},'$ gcc test.c -lwasmedge\n$ ./a.out\nHost function "Add": 1234 + 5678\nGet the result: 6912\nData value: 6912\n')))),(0,s.kt)("h2",{id:"wasmedge-aot-compiler"},"WasmEdge AOT Compiler"),(0,s.kt)("p",null,"In this partition, we will introduce the WasmEdge AOT compiler and the options."),(0,s.kt)("p",null,"WasmEdge runs the WASM files in interpreter mode, and WasmEdge also supports the AOT (ahead-of-time) mode running without modifying any code.\nThe WasmEdge AOT (ahead-of-time) compiler compiles the WASM files for running in AOT mode which is much faster than interpreter mode. Developers can compile the WASM files into the compiled-WASM files in shared library format for universal WASM format for the AOT mode execution."),(0,s.kt)("h3",{id:"compilation-example"},"Compilation Example"),(0,s.kt)("p",null,"Assume that the WASM file ",(0,s.kt)("a",{parentName:"p",href:"https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/examples/wasm/fibonacci.wasm"},(0,s.kt)("inlineCode",{parentName:"a"},"fibonacci.wasm"))," is copied into the current directory, and the C file ",(0,s.kt)("inlineCode",{parentName:"p"},"test.c")," is as following:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-c"},'#include <wasmedge/wasmedge.h>\n#include <stdio.h>\nint main() {\n  /* Create the configure context. */\n  WasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();\n  /* ... Adjust settings in the configure context. */\n  /* Result. */\n  WasmEdge_Result Res;\n\n  /* Create the compiler context. The configure context can be NULL. */\n  WasmEdge_CompilerContext *CompilerCxt = WasmEdge_CompilerCreate(ConfCxt);\n  /* Compile the WASM file with input and output paths. */\n  Res = WasmEdge_CompilerCompile(CompilerCxt, "fibonacci.wasm",\n                                 "fibonacci-aot.wasm");\n  if (!WasmEdge_ResultOK(Res)) {\n    printf("Compilation failed: %s\\n", WasmEdge_ResultGetMessage(Res));\n    return 1;\n  }\n\n  WasmEdge_CompilerDelete(CompilerCxt);\n  WasmEdge_ConfigureDelete(ConfCxt);\n  return 0;\n}\n')),(0,s.kt)("p",null,'Then you can compile and run (the output file is "fibonacci-aot.wasm"):'),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-bash"},"$ gcc test.c -lwasmedge\n$ ./a.out\n[2021-07-02 11:08:08.651] [info] compile start\n[2021-07-02 11:08:08.653] [info] verify start\n[2021-07-02 11:08:08.653] [info] optimize start\n[2021-07-02 11:08:08.670] [info] codegen start\n[2021-07-02 11:08:08.706] [info] compile done\n")),(0,s.kt)("h3",{id:"compiler-options"},"Compiler Options"),(0,s.kt)("p",null,"Developers can set options for AOT compilers such as optimization level and output format:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-c"},"/// AOT compiler optimization level enumeration.\nenum WasmEdge_CompilerOptimizationLevel {\n  /// Disable as many optimizations as possible.\n  WasmEdge_CompilerOptimizationLevel_O0 = 0,\n  /// Optimize quickly without destroying debuggability.\n  WasmEdge_CompilerOptimizationLevel_O1,\n  /// Optimize for fast execution as much as possible without triggering\n  /// significant incremental compile time or code size growth.\n  WasmEdge_CompilerOptimizationLevel_O2,\n  /// Optimize for fast execution as much as possible.\n  WasmEdge_CompilerOptimizationLevel_O3,\n  /// Optimize for small code size as much as possible without triggering\n  /// significant incremental compile time or execution time slowdowns.\n  WasmEdge_CompilerOptimizationLevel_Os,\n  /// Optimize for small code size as much as possible.\n  WasmEdge_CompilerOptimizationLevel_Oz\n};\n\n/// AOT compiler output binary format enumeration.\nenum WasmEdge_CompilerOutputFormat {\n  /// Native dynamic library format.\n  WasmEdge_CompilerOutputFormat_Native = 0,\n  /// WebAssembly with AOT compiled codes in custom sections.\n  WasmEdge_CompilerOutputFormat_Wasm\n};\n")),(0,s.kt)("p",null,"Please refer to the ",(0,s.kt)("a",{parentName:"p",href:"#configurations"},"AOT compiler options configuration")," for details."))}p.isMDXComponent=!0}}]);