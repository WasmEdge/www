<!DOCTYPE HTML>
<html lang="zh" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Reactr - WasmEdge Runtime</title>
        <!-- Custom HTML head -->
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-NGPCK7VF2L"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-NGPCK7VF2L');
</script>
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../../favicon.svg">
        <link rel="shortcut icon" href="../../favicon.png">
        <link rel="stylesheet" href="../../css/variables.css">
        <link rel="stylesheet" href="../../css/general.css">
        <link rel="stylesheet" href="../../css/chrome.css">
        <link rel="stylesheet" href="../../css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="../../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../../fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../../highlight.css">
        <link rel="stylesheet" href="../../tomorrow-night.css">
        <link rel="stylesheet" href="../../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item "><a href="../../index.html"><strong aria-hidden="true">1.</strong> 快速开始</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../start/install.html"><strong aria-hidden="true">1.1.</strong> WasmEdge 的安装与卸载</a></li><li class="chapter-item "><a href="../../start/docker.html"><strong aria-hidden="true">1.2.</strong> 使用 Docker 进行 WasmEdge 应用程序开发</a></li><li class="chapter-item "><a href="../../start/cli.html"><strong aria-hidden="true">1.3.</strong> WasmEdge 命令行</a></li><li class="chapter-item "><a href="../../start/universal.html"><strong aria-hidden="true">1.4.</strong> 通用 wasm 二进制格式</a></li></ol></li><li class="chapter-item "><a href="../../intro.html"><strong aria-hidden="true">2.</strong> WasmEdge 介绍</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../intro/use.html"><strong aria-hidden="true">2.1.</strong> 应用场景</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../intro/use/runtime.html"><strong aria-hidden="true">2.1.1.</strong> 云原生的 runtime</a></li><li class="chapter-item "><a href="../../intro/use/js.html"><strong aria-hidden="true">2.1.2.</strong> JavaScript 或 DSL runtime</a></li><li class="chapter-item "><a href="../../intro/use/serverless.html"><strong aria-hidden="true">2.1.3.</strong> 公有云中的 Serverless 函数即服务</a></li><li class="chapter-item "><a href="../../intro/use/edge.html"><strong aria-hidden="true">2.1.4.</strong> 边缘计算</a></li><li class="chapter-item "><a href="../../intro/use/saas.html"><strong aria-hidden="true">2.1.5.</strong> SaaS 里的嵌入式函数</a></li></ol></li><li class="chapter-item "><a href="../../intro/features.html"><strong aria-hidden="true">2.2.</strong> WasmEdge 的优势与特点</a></li><li class="chapter-item "><a href="../../intro/standard.html"><strong aria-hidden="true">2.3.</strong> WebAssembly 的标准扩展</a></li><li class="chapter-item "><a href="../../intro/proprietary.html"><strong aria-hidden="true">2.4.</strong> WasmEdge 特有的扩展</a></li><li class="chapter-item "><a href="../../intro/integrations.html"><strong aria-hidden="true">2.5.</strong> 与外部框架的集成</a></li><li class="chapter-item "><a href="../../intro/faq.html"><strong aria-hidden="true">2.6.</strong> FAQ</a></li></ol></li><li class="chapter-item "><a href="../../dev.html"><strong aria-hidden="true">3.</strong> 开发 WasmEdge 应用</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../dev/rust.html"><strong aria-hidden="true">3.1.</strong> Rust</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../dev/rust/bindgen.html"><strong aria-hidden="true">3.1.1.</strong> 调用 Rust 函数</a></li><li class="chapter-item "><a href="../../dev/rust/wasi.html"><strong aria-hidden="true">3.1.2.</strong> 使用操作系统服务</a></li><li class="chapter-item "><a href="../../dev/rust/tensorflow.html"><strong aria-hidden="true">3.1.3.</strong> Tensorflow</a></li><li class="chapter-item "><a href="../../dev/rust/networking.html"><strong aria-hidden="true">3.1.4.</strong> 简单的 HTTP 客户端和服务器</a></li><li class="chapter-item "><a href="../../dev/rust/networking-nonblocking.html"><strong aria-hidden="true">3.1.5.</strong> 非阻塞网络应用</a></li><li class="chapter-item "><a href="../../dev/rust/ssr.html"><strong aria-hidden="true">3.1.6.</strong> 服务端渲染</a></li><li class="chapter-item "><a href="../../dev/rust/command.html"><strong aria-hidden="true">3.1.7.</strong> 命令行接口</a></li></ol></li><li class="chapter-item "><a href="../../dev/js.html"><strong aria-hidden="true">3.2.</strong> JavaScript</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../dev/js/quickstart.html"><strong aria-hidden="true">3.2.1.</strong> 快速开始</a></li><li class="chapter-item "><a href="../../dev/js/networking.html"><strong aria-hidden="true">3.2.2.</strong> 网络</a></li><li class="chapter-item "><a href="../../dev/js/fetch.html"><strong aria-hidden="true">3.2.3.</strong> Fetch</a></li><li class="chapter-item "><a href="../../dev/js/tensorflow.html"><strong aria-hidden="true">3.2.4.</strong> Tensorflow 推理</a></li><li class="chapter-item "><a href="../../dev/js/ssr.html"><strong aria-hidden="true">3.2.5.</strong> 示例：React SSR</a></li><li class="chapter-item "><a href="../../dev/js/es6.html"><strong aria-hidden="true">3.2.6.</strong> ES6 模块</a></li><li class="chapter-item "><a href="../../dev/js/npm.html"><strong aria-hidden="true">3.2.7.</strong> NodeJS & NPM 模块</a></li><li class="chapter-item "><a href="../../dev/js/rust.html"><strong aria-hidden="true">3.2.8.</strong> 用 Rust 实现 JS API</a></li></ol></li><li class="chapter-item "><a href="../../dev/python.html"><strong aria-hidden="true">3.3.</strong> Python</a></li><li class="chapter-item "><a href="../../dev/go.html"><strong aria-hidden="true">3.4.</strong> Go</a></li><li class="chapter-item "><a href="../../dev/swift.html"><strong aria-hidden="true">3.5.</strong> Swift</a></li><li class="chapter-item "><a href="../../dev/as.html"><strong aria-hidden="true">3.6.</strong> AssemblyScript</a></li><li class="chapter-item "><a href="../../dev/kotlin.html"><strong aria-hidden="true">3.7.</strong> Kotlin</a></li><li class="chapter-item "><a href="../../dev/grain.html"><strong aria-hidden="true">3.8.</strong> Grain</a></li></ol></li><li class="chapter-item "><a href="../../embed.html"><strong aria-hidden="true">4.</strong> 嵌入 WasmEdge 函数</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../embed/c.html"><strong aria-hidden="true">4.1.</strong> C SDK</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../embed/c/ref.html"><strong aria-hidden="true">4.1.1.</strong> API 参考文档</a></li></ol></li><li class="chapter-item "><a href="../../embed/go.html"><strong aria-hidden="true">4.2.</strong> Go SDK</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../embed/go/app.html"><strong aria-hidden="true">4.2.1.</strong> 嵌入 WASM 应用程序</a></li><li class="chapter-item "><a href="../../embed/go/function.html"><strong aria-hidden="true">4.2.2.</strong> 嵌入 WASM 函数</a></li><li class="chapter-item "><a href="../../embed/go/memory.html"><strong aria-hidden="true">4.2.3.</strong> 传递复杂参数</a></li><li class="chapter-item "><a href="../../embed/go/tensorflow.html"><strong aria-hidden="true">4.2.4.</strong> Tensorflow 调用</a></li><li class="chapter-item "><a href="../../embed/go/host_function.html"><strong aria-hidden="true">4.2.5.</strong> 编写 Host Function</a></li><li class="chapter-item "><a href="../../embed/go/bindgen.html"><strong aria-hidden="true">4.2.6.</strong> 使用 wasm-bindgen</a></li><li class="chapter-item "><a href="../../embed/go/ref.html"><strong aria-hidden="true">4.2.7.</strong> API 参考文档</a></li></ol></li><li class="chapter-item "><a href="../../embed/node.html"><strong aria-hidden="true">4.3.</strong> Node.js SDK</a></li><li class="chapter-item "><a href="../../embed/rust.html"><strong aria-hidden="true">4.4.</strong> Rust SDK</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../embed/rust/sys_run_host_func.html"><strong aria-hidden="true">4.4.1.</strong> 使用 WasmEdge 底层 Rust API 运行 WebAssembly 函数</a></li><li class="chapter-item "><a href="../../embed/rust/concurrent_fib.html"><strong aria-hidden="true">4.4.2.</strong> 并行计算斐波那契数</a></li></ol></li><li class="chapter-item "><a href="../../embed/python.html"><strong aria-hidden="true">4.5.</strong> Python SDK</a></li></ol></li><li class="chapter-item "><a href="../../kubernetes.html"><strong aria-hidden="true">5.</strong> 用 Kubernetes 管理 WasmEdge 应用</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../kubernetes/quickstart.html"><strong aria-hidden="true">5.1.</strong> 快速开始</a></li><li class="chapter-item "><a href="../../kubernetes/demo.html"><strong aria-hidden="true">5.2.</strong> 应用示例</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../kubernetes/demo/wasi.html"><strong aria-hidden="true">5.2.1.</strong> 简单的 WASI 例子</a></li><li class="chapter-item "><a href="../../kubernetes/demo/server.html"><strong aria-hidden="true">5.2.2.</strong> HTTP 微服务</a></li></ol></li><li class="chapter-item "><a href="../../kubernetes/container.html"><strong aria-hidden="true">5.3.</strong> 容器 runtimes</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../kubernetes/container/crun.html"><strong aria-hidden="true">5.3.1.</strong> crun</a></li><li class="chapter-item "><a href="../../kubernetes/container/runc.html"><strong aria-hidden="true">5.3.2.</strong> runc</a></li><li class="chapter-item "><a href="../../kubernetes/container/youki.html"><strong aria-hidden="true">5.3.3.</strong> youki</a></li></ol></li><li class="chapter-item "><a href="../../kubernetes/cri.html"><strong aria-hidden="true">5.4.</strong> CRI runtimes</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../kubernetes/cri/crio.html"><strong aria-hidden="true">5.4.1.</strong> CRI-O</a></li><li class="chapter-item "><a href="../../kubernetes/cri/containerd.html"><strong aria-hidden="true">5.4.2.</strong> containerd</a></li></ol></li><li class="chapter-item "><a href="../../kubernetes/kubernetes.html"><strong aria-hidden="true">5.5.</strong> Kubernetes</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../kubernetes/kubernetes/kubernetes-crio.html"><strong aria-hidden="true">5.5.1.</strong> Kubernetes + CRI-O</a></li><li class="chapter-item "><a href="../../kubernetes/kubernetes/kubernetes-containerd.html"><strong aria-hidden="true">5.5.2.</strong> Kubernetes + containerd</a></li><li class="chapter-item "><a href="../../kubernetes/kubernetes/kind.html"><strong aria-hidden="true">5.5.3.</strong> KinD</a></li><li class="chapter-item "><a href="../../kubernetes/kubernetes/kubeedge.html"><strong aria-hidden="true">5.5.4.</strong> KubeEdge</a></li><li class="chapter-item "><a href="../../kubernetes/kubernetes/superedge.html"><strong aria-hidden="true">5.5.5.</strong> SuperEdge</a></li><li class="chapter-item "><a href="../../kubernetes/kubernetes/openyurt.html"><strong aria-hidden="true">5.5.6.</strong> OpenYurt</a></li><li class="chapter-item "><a href="../../kubernetes/kubernetes/knative.html"><strong aria-hidden="true">5.5.7.</strong> Knative</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="../../frameworks.html"><strong aria-hidden="true">6.</strong> 应用框架与平台</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../frameworks/mesh.html"><strong aria-hidden="true">6.1.</strong> Service mesh 与分布式框架</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../frameworks/mesh/dapr.html"><strong aria-hidden="true">6.1.1.</strong> Dapr</a></li><li class="chapter-item "><a href="../../frameworks/mesh/mosn.html"><strong aria-hidden="true">6.1.2.</strong> MOSN</a></li><li class="chapter-item "><a href="../../frameworks/mesh/eventmesh.html"><strong aria-hidden="true">6.1.3.</strong> Apache EventMesh</a></li></ol></li><li class="chapter-item expanded "><a href="../../frameworks/app.html"><strong aria-hidden="true">6.2.</strong> 应用框架</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../frameworks/app/yomo.html"><strong aria-hidden="true">6.2.1.</strong> YoMo</a></li><li class="chapter-item expanded "><a href="../../frameworks/app/reactr.html" class="active"><strong aria-hidden="true">6.2.2.</strong> Reactr</a></li></ol></li><li class="chapter-item "><a href="../../frameworks/serverless.html"><strong aria-hidden="true">6.3.</strong> Serverless 平台</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../frameworks/serverless/vercel.html"><strong aria-hidden="true">6.3.1.</strong> Vercel</a></li><li class="chapter-item "><a href="../../frameworks/serverless/netlify.html"><strong aria-hidden="true">6.3.2.</strong> Netlify</a></li><li class="chapter-item "><a href="../../frameworks/serverless/aws.html"><strong aria-hidden="true">6.3.3.</strong> AWS</a></li><li class="chapter-item "><a href="../../frameworks/serverless/tencent.html"><strong aria-hidden="true">6.3.4.</strong> Tencent</a></li><li class="chapter-item "><a href="../../frameworks/serverless/secondstate.html"><strong aria-hidden="true">6.3.5.</strong> Second State</a></li></ol></li></ol></li><li class="chapter-item "><a href="../../os.html"><strong aria-hidden="true">7.</strong> 操作系统</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../os/linux.html"><strong aria-hidden="true">7.1.</strong> Linux</a></li><li class="chapter-item "><a href="../../os/windows.html"><strong aria-hidden="true">7.2.</strong> Windows</a></li><li class="chapter-item "><a href="../../os/mac.html"><strong aria-hidden="true">7.3.</strong> Mac</a></li><li class="chapter-item "><a href="../../os/android.html"><strong aria-hidden="true">7.4.</strong> Android</a></li><li class="chapter-item "><a href="../../os/sel4.html"><strong aria-hidden="true">7.5.</strong> seL4</a></li><li class="chapter-item "><a href="../../os/openharmony.html"><strong aria-hidden="true">7.6.</strong> Open Harmony</a></li><li class="chapter-item "><a href="../../os/raspberrypi.html"><strong aria-hidden="true">7.7.</strong> Raspberry Pi</a></li></ol></li><li class="chapter-item "><a href="../../extend.html"><strong aria-hidden="true">8.</strong> 为 WasmEdge 贡献代码</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../extend/build.html"><strong aria-hidden="true">8.1.</strong> 编译 WasmEdge</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../extend/build_on_mac.html"><strong aria-hidden="true">8.1.1.</strong> 用 Mac 编译</a></li><li class="chapter-item "><a href="../../extend/build_on_windows.html"><strong aria-hidden="true">8.1.2.</strong> 用 Windows 编译</a></li><li class="chapter-item "><a href="../../extend/build_for_android.html"><strong aria-hidden="true">8.1.3.</strong> 为 Android 编译</a></li></ol></li><li class="chapter-item "><a href="../../extend/plugin.html"><strong aria-hidden="true">8.2.</strong> WasmEdge plug-in API</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../extend/plugin/hostfunction.html"><strong aria-hidden="true">8.2.1.</strong> Host 函数</a></li><li class="chapter-item "><a href="../../extend/plugin/externref.html"><strong aria-hidden="true">8.2.2.</strong> 外部引用</a></li></ol></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">WasmEdge Runtime</h1>

                    <div class="right-buttons">
                        <a href="../../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/WasmEdge/WasmEdge" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        <a href="https://github.com/WasmEdge/WasmEdge/tree/master/docs/book/zh/src/frameworks/app/reactr.md" title="Suggest an edit" aria-label="Suggest an edit">
                            <i id="git-edit-button" class="fa fa-edit"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="reactr"><a class="header" href="#reactr">Reactr</a></h1>
<p><a href="https://github.com/suborbital/reactr">Reactr</a> 是一个用 Go 语言编写的高性能函数调用库。Reactr 的设计十分灵活，你可将其嵌入 Go 程序中运行，它也为 WebAssembly 提供了一流的支持。
得益于 Go 语言出色的并发性能，Reactr 可以同时管理和执行上百个 WebAssembly 运行时实例，这使得 Reactr 成为了服务端程序框架的一个优秀选择。</p>
<p>Reactr 让你可以在 Go 程序中调用 WebAssembly 函数，<a href="../../embed/go.html">WasmEdge Go SDK</a> 也是如此。
Reactr 的特别之处在于，它在 Go 语言中提供了一套丰富的主机函数，其中包括了对访问网络、数据库等功能的支持。此外，Reactr 提供了 Rust (以及 Swift / AssemblyScript) 的 API，你可以用它在 WebAssembly 函数中调用上述的主机函数。</p>
<p>本文将向你展示如何将 WasmEdge 与 Reactr 结合起来使用，以充分利用二者的优势。
WasmEdge 是<a href="../../intro/features.html">性能最佳且最具拓展性的 WebAssembly 运行时</a>，
并在 <a href="https://github.com/suborbital/reactr/runs/4476074960?check_suite_focus=true">Reactr 的官方测试用例</a>中是性能最好的。
我们将演示如何在 WasmEdge 和 Reactr 中运行编译为 WebAssembly 的 Rust 函数以及 JavaScript 程序。</p>
<blockquote>
<p>WasmEdge 为 JavaScript 提供了<a href="../../dev/js.html">增强支持</a>，包括<a href="../../dev/js/rust.html">将 Rust 与 JavaScript 混合</a>以提高性能。</p>
</blockquote>
<ul>
<li><a href="#hello-world">Hello world</a></li>
<li><a href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9F%A5%E8%AF%A2">数据库查询</a></li>
<li><a href="#%E5%9C%A8-Go-%E4%B8%AD%E5%B5%8C%E5%85%A5-JavaScript">在 Go 中嵌入 JavaScript</a></li>
</ul>
<h2 id="环境准备"><a class="header" href="#环境准备">环境准备</a></h2>
<p>你的系统中需要装有 <a href="https://www.rust-lang.org/zh-CN/tools/install">Rust</a>、<a href="https://go.dev/doc/install">Go</a> 以及 <a href="../../start/install.html">WasmEdge</a>。
WasmEdge 需要用到 GCC 编译器（<code>build-essential</code> 中包含 GCC 编译器）。</p>
<pre><code class="language-bash">sudo apt-get update
sudo apt-get -y upgrade
sudo apt install build-essential

curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh
source $HOME/.cargo/env
rustup target add wasm32-wasi

curl -OL https://golang.org/dl/go1.17.5.linux-amd64.tar.gz
sudo tar -C /usr/local -xvf go1.17.5.linux-amd64.tar.gz
export PATH=$PATH:/usr/local/go/bin

wget -qO- https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/utils/install.sh | bash
source $HOME/.wasmedge/env
</code></pre>
<h2 id="hello-world"><a class="header" href="#hello-world">Hello world</a></h2>
<p>你可以在<a href="https://github.com/second-state/wasm-learning/tree/master/reactr/hello">这里</a>找到一个简单的关于 Reactr 的 <code>hello world</code> 示例。</p>
<h3 id="hello-world-编译为-webassembly-的-rust-函数"><a class="header" href="#hello-world-编译为-webassembly-的-rust-函数">Hello world: 编译为 WebAssembly 的 Rust 函数</a></h3>
<p>我们首先编写一个<a href="https://github.com/second-state/wasm-learning/blob/master/reactr/hello/hello-echo/src/lib.rs">简单的 Rust 函数</a>，它所做的事只是回应一个 &quot;hello&quot;。
我们将通过 Reactr 把下面的 Rust 函数 <code>HelloEcho::run()</code> 暴露给 Go 主机应用。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use suborbital::runnable::*;

struct HelloEcho{}

impl Runnable for HelloEcho {
  fn run(&amp;self, input: Vec&lt;u8&gt;) -&gt; Result&lt;Vec&lt;u8&gt;, RunErr&gt; {
    let in_string = String::from_utf8(input).unwrap();
    Ok(format!(&quot;hello {}&quot;, in_string).as_bytes().to_vec())
  }
}
<span class="boring">}</span></code></pre></pre>
<p>接下来，把这个 Rust 函数构建为 WebAssembly 字节码文件。</p>
<pre><code class="language-bash">cd hello-echo
cargo build --target wasm32-wasi --release
cp target/wasm32-wasi/release/hello_echo.wasm ..
cd ..
</code></pre>
<h3 id="hello-world-go-主机程序"><a class="header" href="#hello-world-go-主机程序">Hello world: Go 主机程序</a></h3>
<p>接下来，让我们看看执行这个 WebAssembly 函数的 <a href="https://github.com/second-state/wasm-learning/blob/master/reactr/hello/main.go">Go 主机程序</a>。
<code>Runnable</code> 结构体中的 <code>runBundle()</code> 函数所做的事是调用 <code>run()</code> 函数。</p>
<pre><code class="language-go">func runBundle() {
  r := rt.New()
  doWasm := r.Register(&quot;hello-echo&quot;, rwasm.NewRunner(&quot;./hello_echo.wasm&quot;))

  res, err := doWasm([]byte(&quot;wasmWorker!&quot;)).Then()
  if err != nil {
    fmt.Println(err)
    return
  }

  fmt.Println(string(res.([]byte)))
}
</code></pre>
<p><code>runGroup()</code> 函数会在组内异步地执行由 Rust 编译的 WebAssembly <code>run()</code> 函数，并在返回结果的时候接收它们。</p>
<pre><code class="language-go">func runGroup() {
  r := rt.New()

  doWasm := r.Register(&quot;hello-echo&quot;, rwasm.NewRunner(&quot;./hello_echo.wasm&quot;))

  grp := rt.NewGroup()
  for i := 0; i &lt; 100000; i++ {
    grp.Add(doWasm([]byte(fmt.Sprintf(&quot;world %d&quot;, i))))
  }

  if err := grp.Wait(); err != nil {
    fmt.Println(err)
  }
}
</code></pre>
<p>现在，我们可以将 Go 主机程序运行起来，并观察控制台中所打印的结果。</p>
<blockquote>
<p>只有在设置了 <code>-tags wasmedge</code> 这一标签后，你才能获得 WasmEdge 提供的性能优势以及拓展 WebAssembly API。</p>
</blockquote>
<pre><code class="language-bash">go mod tidy
go run -tags wasmedge main.go
</code></pre>
<h2 id="数据库查询"><a class="header" href="#数据库查询">数据库查询</a></h2>
<p>这个<a href="https://github.com/second-state/wasm-learning/tree/master/reactr/db">示例</a>演示了如何在 WebAssembly 函数中使用 Reactr 主机函数及 API 查询 PostgreSQL 数据库。</p>
<h3 id="数据库查询下载并安装-postgresql"><a class="header" href="#数据库查询下载并安装-postgresql">数据库查询：下载并安装 PostgreSQL</a></h3>
<p>我们可以在 Docker 中启动一个 PostgreSQL 实例。</p>
<pre><code class="language-bash">docker pull postgres
docker run --name reactr-postgres -p 5432:5432 -e POSTGRES_PASSWORD=12345 -d postgres
</code></pre>
<p>接下来，创建一个数据库并向其中填入一些样本数据。</p>
<pre><code class="language-bash">$ docker run -it --rm --network host postgres psql -h 127.0.0.1 -U postgres
postgres=# CREATE DATABASE reactr;
postgres=# \c reactr;

# Create a table:
postgres=# CREATE TABLE users (
    uuid        varchar(100) CONSTRAINT firstkey PRIMARY KEY,
    email       varchar(50) NOT NULL,
    created_at  date,
    state       char(1),
    identifier  integer
);
</code></pre>
<p>保持容器的运行状态，并打开一个新的终端窗口来与 PostgreSQL 服务器进行交互。</p>
<h3 id="数据库查询编译为-webassembly-的-rust-函数"><a class="header" href="#数据库查询编译为-webassembly-的-rust-函数">数据库查询：编译为 WebAssembly 的 Rust 函数</a></h3>
<p>让我们编写一个访问 PostgreSQL 数据库的 <a href="https://github.com/second-state/wasm-learning/blob/master/reactr/db/rs-db/src/lib.rs">Rust 函数</a>。
如下所示的 Rust 函数 <code>RsDbtest::run()</code> 将会通过 Reactr 暴露给 Go 主机程序。它使用 <code>PGInsertUser</code>、<code>PGSelectUserWithUUID</code> 等命名查询来操作数据库，稍后我们会看到定义在 Go 主机程序中的查询。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use suborbital::runnable::*;
use suborbital::db;
use suborbital::util;
use suborbital::db::query;
use suborbital::log;
use uuid::Uuid;

struct RsDbtest{}

impl Runnable for RsDbtest {
  fn run(&amp;self, _: Vec&lt;u8&gt;) -&gt; Result&lt;Vec&lt;u8&gt;, RunErr&gt; {
    let uuid = Uuid::new_v4().to_string();

    let mut args: Vec&lt;query::QueryArg&gt; = Vec::new();
    args.push(query::QueryArg::new(&quot;uuid&quot;, uuid.as_str()));
    args.push(query::QueryArg::new(&quot;email&quot;, &quot;connor@suborbital.dev&quot;));

    match db::insert(&quot;PGInsertUser&quot;, args) {
      Ok(_) =&gt; log::info(&quot;insert successful&quot;),
      Err(e) =&gt; {
        return Err(RunErr::new(500, e.message.as_str()))
      }
    };

    let mut args2: Vec&lt;query::QueryArg&gt; = Vec::new();
    args2.push(query::QueryArg::new(&quot;uuid&quot;, uuid.as_str()));

    match db::update(&quot;PGUpdateUserWithUUID&quot;, args2.clone()) {
      Ok(rows) =&gt; log::info(format!(&quot;update: {}&quot;, util::to_string(rows).as_str()).as_str()),
      Err(e) =&gt; {
        return Err(RunErr::new(500, e.message.as_str()))
      }
    }

    match db::select(&quot;PGSelectUserWithUUID&quot;, args2.clone()) {
      Ok(result) =&gt; log::info(format!(&quot;select: {}&quot;, util::to_string(result).as_str()).as_str()),
      Err(e) =&gt; {
        return Err(RunErr::new(500, e.message.as_str()))
      }
    }

    match db::delete(&quot;PGDeleteUserWithUUID&quot;, args2.clone()) {
      Ok(rows) =&gt; log::info(format!(&quot;delete: {}&quot;, util::to_string(rows).as_str()).as_str()),
      Err(e) =&gt; {
        return Err(RunErr::new(500, e.message.as_str()))
      }
    }

    ... ...
  }
}
<span class="boring">}</span></code></pre></pre>
<p>让我们把这个 Rust 函数构建为 WebAssembly 字节码文件。</p>
<pre><code class="language-bash">cd rs-db
cargo build --target wasm32-wasi --release
cp target/wasm32-wasi/release/rs_db.wasm ..
cd ..
</code></pre>
<h3 id="数据库查询go-主机程序"><a class="header" href="#数据库查询go-主机程序">数据库查询：Go 主机程序</a></h3>
<p>在这个 <a href="https://github.com/second-state/wasm-learning/blob/master/reactr/db/main.go">Go 主机程序</a>中，我们首先定义了几个 SQL 查询，并为其命名。
我们将把这些查询作为配置传入 Reactr 运行时。</p>
<pre><code class="language-go">func main() {
  dbConnString, exists := os.LookupEnv(&quot;REACTR_DB_CONN_STRING&quot;)
  if !exists {
    fmt.Println(&quot;skipping as conn string env var not set&quot;)
    return
  }

  q1 := rcap.Query{
    Type:     rcap.QueryTypeInsert,
    Name:     &quot;PGInsertUser&quot;,
    VarCount: 2,
    Query: `
    INSERT INTO users (uuid, email, created_at, state, identifier)
    VALUES ($1, $2, NOW(), 'A', 12345)`,
  }

  q2 := rcap.Query{
    Type:     rcap.QueryTypeSelect,
    Name:     &quot;PGSelectUserWithUUID&quot;,
    VarCount: 1,
    Query: `
    SELECT * FROM users
    WHERE uuid = $1`,
  }

  q3 := rcap.Query{
    Type:     rcap.QueryTypeUpdate,
    Name:     &quot;PGUpdateUserWithUUID&quot;,
    VarCount: 1,
    Query: `
    UPDATE users SET state='B' WHERE uuid = $1`,
  }

  q4 := rcap.Query{
    Type:     rcap.QueryTypeDelete,
    Name:     &quot;PGDeleteUserWithUUID&quot;,
    VarCount: 1,
    Query: `
    DELETE FROM users WHERE uuid = $1`,
  }

  config := rcap.DefaultConfigWithDB(vlog.Default(), rcap.DBTypePostgres, dbConnString, []rcap.Query{q1, q2, q3, q4})

  r, err := rt.NewWithConfig(config)
  if err != nil {
    fmt.Println(err)
    return
  }

  ... ...
}
</code></pre>
<p>接下来便可以在 Reactr 中运行这个 WebAssembly 函数了。</p>
<pre><code class="language-go">func main() {
  ... ...

  doWasm := r.Register(&quot;rs-db&quot;, rwasm.NewRunner(&quot;./rs_db.wasm&quot;))

  res, err := doWasm(nil).Then()
  if err != nil {
    fmt.Println(err)
    return
  }

  fmt.Println(string(res.([]byte)))
}
</code></pre>
<p>最后，让我们运行 Go 主机程序并观察控制台中打印出的结果。</p>
<blockquote>
<p>只有在设置了 <code>-tags wasmedge</code> 这一标签后，你才能获得 WasmEdge 提供的性能优势以及拓展 WebAssembly API。</p>
</blockquote>
<pre><code class="language-bash">export REACTR_DB_CONN_STRING='postgresql://postgres:12345@127.0.0.1:5432/reactr'
go mod tidy
go run -tags wasmedge main.go
</code></pre>
<h2 id="在-go-中嵌入-javascript"><a class="header" href="#在-go-中嵌入-javascript">在 Go 中嵌入 JavaScript</a></h2>
<p>我们前面提过，WasmEdge 运行时的一大特点就是它<a href="../../dev/js.html">对 JavaScript 的高级支持</a>，这使得我们能在轻量、高性能、安全、支持多语言的<a href="../../kubernetes.html">Kubernetes 管理的 WasmEdge 容器</a>中运行 JavaScript 程序。
你可以在<a href="https://github.com/second-state/wasm-learning/tree/master/reactr/quickjs">这里</a>找到一个在 Reactr 中嵌入的 JavaScript 函数示例。</p>
<h3 id="javascript-示例"><a class="header" href="#javascript-示例">JavaScript 示例</a></h3>
<p>这个<a href="https://github.com/second-state/wasm-learning/tree/master/reactr/quickjs/hello.js">示例函数</a>十分简单，仅仅是返回一个字符串值。</p>
<pre><code class="language-javascript">let h = 'hello';
let w = 'wasmedge';
`${h} ${w}`;
</code></pre>
<h3 id="javascript-示例go-主机程序"><a class="header" href="#javascript-示例go-主机程序">JavaScript 示例：Go 主机程序</a></h3>
<p>这个 <a href="https://github.com/second-state/wasm-learning/tree/master/reactr/quickjs/main.go">Go 主机程序</a> 使用了 Reactr API 来运行 WasmEdge 的标准 JavaScript 解释器（<a href="https://github.com/second-state/wasm-learning/blob/master/reactr/quickjs/rs_embed_js.wasm">rs_embed_js.wasm</a>）。你也可以通过修改这个 <a href="https://github.com/second-state/wasm-learning/tree/master/reactr/quickjs/rs-embed-js">Rust 项目</a> 来使用其他版本的 JavaScript 解释器。</p>
<blockquote>
<p>你可以点击这两个超链接来了解如何<a href="https://github.com/second-state/wasmedge-quickjs/tree/main/examples/embed_js">将 JavaScript 代码嵌入 Rust</a> 以及<a href="../../dev/js/rust.html">使用 Rust 实现 JavaScript API</a>。</p>
</blockquote>
<p>Go 主机程序只需要启动 <code>rs_embed_js.wasm</code> 的任务并将 JavaScript 内容传入它。接下来可以用 Go 程序来捕获并打印出返回值。</p>
<pre><code class="language-go">func main() {
  r := rt.New()
  doWasm := r.Register(&quot;hello-quickjs&quot;, rwasm.NewRunner(&quot;./rs_embed_js.wasm&quot;))

  code, err := ioutil.ReadFile(os.Args[1])
  if err != nil {
    fmt.Print(err)
  }
  res, err := doWasm(code).Then()
  if err != nil {
    fmt.Println(err)
    return
  }

  fmt.Println(string(res.([]byte)))
}
</code></pre>
<p>使用下面的命令运行 Go 主机程序。</p>
<pre><code class="language-bash">$ cd quickjs
$ go mod tidy
$ go run -tags wasmedge main.go hello.js
String(JsString(hello wasmedge))
</code></pre>
<p>打印出来的结果中包含了 Rust 和 Go API 中的字符串类型信息。你可以对 Rust / Go 程序进行修改来将其移除。</p>
<h3 id="javascript-示例功能实例"><a class="header" href="#javascript-示例功能实例">JavaScript 示例：功能实例</a></h3>
<p>WasmEdge 支持许多 JavaScript 高级特性。在了解了上面的三个简单例子后，你可以尝试使用我们的 <a href="https://github.com/second-state/wasmedge-quickjs/tree/main/example_js/react_ssr">React SSR 示例</a>来通过一个 Reactr 函数生成 HTML UI。
你可以只从 React SSR 示例中构建 <code>dist/main.js</code>，并将其复制到这个示例的文件夹中，然后你就能让它工作起来了！</p>
<pre><code class="language-bash">$ cd quickjs
# 从 react ssr 示例中拷贝出 dist/main.js
$ go mod tidy
$ go run -tags wasmedge main.go main.js
&lt;div data-reactroot=&quot;&quot;&gt;&lt;div&gt;This is home&lt;/div&gt;&lt;div&gt;&lt;div&gt;This is page&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;
UnDefined
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../../frameworks/app/yomo.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                            <a rel="next" href="../../frameworks/serverless.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../../frameworks/app/yomo.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                    <a rel="next" href="../../frameworks/serverless.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <script>
            window.playground_copyable = true;
        </script>
        <script src="../../elasticlunr.min.js"></script>
        <script src="../../mark.min.js"></script>
        <script src="../../searcher.js"></script>
        <script src="../../clipboard.min.js"></script>
        <script src="../../highlight.js"></script>
        <script src="../../book.js"></script>

        <!-- Custom JS scripts -->
    </body>
</html>
