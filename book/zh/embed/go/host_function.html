<!DOCTYPE HTML>
<html lang="zh" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>编写 Host Function - WasmEdge Runtime</title>
        <!-- Custom HTML head -->
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-NGPCK7VF2L"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-NGPCK7VF2L');
</script>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../../favicon.svg">
        <link rel="shortcut icon" href="../../favicon.png">
        <link rel="stylesheet" href="../../css/variables.css">
        <link rel="stylesheet" href="../../css/general.css">
        <link rel="stylesheet" href="../../css/chrome.css">
        <link rel="stylesheet" href="../../css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="../../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../../fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../../highlight.css">
        <link rel="stylesheet" href="../../tomorrow-night.css">
        <link rel="stylesheet" href="../../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item "><a href="../../index.html"><strong aria-hidden="true">1.</strong> 快速开始</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../start/install.html"><strong aria-hidden="true">1.1.</strong> WasmEdge 的安装与卸载</a></li><li class="chapter-item "><a href="../../start/docker.html"><strong aria-hidden="true">1.2.</strong> 使用 Docker 进行 WasmEdge 应用程序开发</a></li><li class="chapter-item "><a href="../../start/cli.html"><strong aria-hidden="true">1.3.</strong> WasmEdge 命令行</a></li><li class="chapter-item "><a href="../../start/universal.html"><strong aria-hidden="true">1.4.</strong> 通用 wasm 二进制格式</a></li></ol></li><li class="chapter-item "><a href="../../intro.html"><strong aria-hidden="true">2.</strong> WasmEdge 介绍</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../intro/use.html"><strong aria-hidden="true">2.1.</strong> 应用场景</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../intro/use/runtime.html"><strong aria-hidden="true">2.1.1.</strong> 云原生的 runtime</a></li><li class="chapter-item "><a href="../../intro/use/js.html"><strong aria-hidden="true">2.1.2.</strong> JavaScript 或 DSL runtime</a></li><li class="chapter-item "><a href="../../intro/use/serverless.html"><strong aria-hidden="true">2.1.3.</strong> 公有云中的 Serverless 函数即服务</a></li><li class="chapter-item "><a href="../../intro/use/edge.html"><strong aria-hidden="true">2.1.4.</strong> 边缘计算</a></li><li class="chapter-item "><a href="../../intro/use/saas.html"><strong aria-hidden="true">2.1.5.</strong> SaaS 里的嵌入式函数</a></li></ol></li><li class="chapter-item "><a href="../../intro/features.html"><strong aria-hidden="true">2.2.</strong> WasmEdge 的优势与特点</a></li><li class="chapter-item "><a href="../../intro/standard.html"><strong aria-hidden="true">2.3.</strong> WebAssembly 的标准扩展</a></li><li class="chapter-item "><a href="../../intro/proprietary.html"><strong aria-hidden="true">2.4.</strong> WasmEdge 特有的扩展</a></li><li class="chapter-item "><a href="../../intro/integrations.html"><strong aria-hidden="true">2.5.</strong> 与外部框架的集成</a></li><li class="chapter-item "><a href="../../intro/faq.html"><strong aria-hidden="true">2.6.</strong> FAQ</a></li></ol></li><li class="chapter-item "><a href="../../dev.html"><strong aria-hidden="true">3.</strong> 开发 WasmEdge 应用</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../dev/rust.html"><strong aria-hidden="true">3.1.</strong> Rust</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../dev/rust/bindgen.html"><strong aria-hidden="true">3.1.1.</strong> 调用 Rust 函数</a></li><li class="chapter-item "><a href="../../dev/rust/wasi.html"><strong aria-hidden="true">3.1.2.</strong> 使用操作系统服务</a></li><li class="chapter-item "><a href="../../dev/rust/tensorflow.html"><strong aria-hidden="true">3.1.3.</strong> Tensorflow</a></li><li class="chapter-item "><a href="../../dev/rust/networking.html"><strong aria-hidden="true">3.1.4.</strong> 简单的 HTTP 客户端和服务器</a></li><li class="chapter-item "><a href="../../dev/rust/networking-nonblocking.html"><strong aria-hidden="true">3.1.5.</strong> 非阻塞网络应用</a></li><li class="chapter-item "><a href="../../dev/rust/ssr.html"><strong aria-hidden="true">3.1.6.</strong> 服务端渲染</a></li><li class="chapter-item "><a href="../../dev/rust/command.html"><strong aria-hidden="true">3.1.7.</strong> 命令行接口</a></li></ol></li><li class="chapter-item "><a href="../../dev/js.html"><strong aria-hidden="true">3.2.</strong> JavaScript</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../dev/js/quickstart.html"><strong aria-hidden="true">3.2.1.</strong> 快速开始</a></li><li class="chapter-item "><a href="../../dev/js/networking.html"><strong aria-hidden="true">3.2.2.</strong> 网络</a></li><li class="chapter-item "><a href="../../dev/js/fetch.html"><strong aria-hidden="true">3.2.3.</strong> Fetch</a></li><li class="chapter-item "><a href="../../dev/js/tensorflow.html"><strong aria-hidden="true">3.2.4.</strong> Tensorflow 推理</a></li><li class="chapter-item "><a href="../../dev/js/ssr.html"><strong aria-hidden="true">3.2.5.</strong> 示例：React SSR</a></li><li class="chapter-item "><a href="../../dev/js/es6.html"><strong aria-hidden="true">3.2.6.</strong> ES6 模块</a></li><li class="chapter-item "><a href="../../dev/js/npm.html"><strong aria-hidden="true">3.2.7.</strong> NodeJS & NPM 模块</a></li><li class="chapter-item "><a href="../../dev/js/rust.html"><strong aria-hidden="true">3.2.8.</strong> 用 Rust 实现 JS API</a></li></ol></li><li class="chapter-item "><a href="../../dev/python.html"><strong aria-hidden="true">3.3.</strong> Python</a></li><li class="chapter-item "><a href="../../dev/go.html"><strong aria-hidden="true">3.4.</strong> Go</a></li><li class="chapter-item "><a href="../../dev/swift.html"><strong aria-hidden="true">3.5.</strong> Swift</a></li><li class="chapter-item "><a href="../../dev/as.html"><strong aria-hidden="true">3.6.</strong> AssemblyScript</a></li><li class="chapter-item "><a href="../../dev/kotlin.html"><strong aria-hidden="true">3.7.</strong> Kotlin</a></li><li class="chapter-item "><a href="../../dev/grain.html"><strong aria-hidden="true">3.8.</strong> Grain</a></li></ol></li><li class="chapter-item expanded "><a href="../../embed.html"><strong aria-hidden="true">4.</strong> 嵌入 WasmEdge 函数</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../embed/c.html"><strong aria-hidden="true">4.1.</strong> C SDK</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../embed/c/ref.html"><strong aria-hidden="true">4.1.1.</strong> API 参考文档</a></li></ol></li><li class="chapter-item expanded "><a href="../../embed/go.html"><strong aria-hidden="true">4.2.</strong> Go SDK</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../embed/go/app.html"><strong aria-hidden="true">4.2.1.</strong> 嵌入 WASM 应用程序</a></li><li class="chapter-item "><a href="../../embed/go/function.html"><strong aria-hidden="true">4.2.2.</strong> 嵌入 WASM 函数</a></li><li class="chapter-item "><a href="../../embed/go/memory.html"><strong aria-hidden="true">4.2.3.</strong> 传递复杂参数</a></li><li class="chapter-item "><a href="../../embed/go/tensorflow.html"><strong aria-hidden="true">4.2.4.</strong> Tensorflow 调用</a></li><li class="chapter-item expanded "><a href="../../embed/go/host_function.html" class="active"><strong aria-hidden="true">4.2.5.</strong> 编写 Host Function</a></li><li class="chapter-item "><a href="../../embed/go/bindgen.html"><strong aria-hidden="true">4.2.6.</strong> 使用 wasm-bindgen</a></li><li class="chapter-item "><a href="../../embed/go/ref.html"><strong aria-hidden="true">4.2.7.</strong> API 参考文档</a></li></ol></li><li class="chapter-item "><a href="../../embed/node.html"><strong aria-hidden="true">4.3.</strong> Node.js SDK</a></li><li class="chapter-item "><a href="../../embed/rust.html"><strong aria-hidden="true">4.4.</strong> Rust SDK</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../embed/rust/sys_run_host_func.html"><strong aria-hidden="true">4.4.1.</strong> 使用 WasmEdge 底层 Rust API 运行 WebAssembly 函数</a></li><li class="chapter-item "><a href="../../embed/rust/concurrent_fib.html"><strong aria-hidden="true">4.4.2.</strong> 并行计算斐波那契数</a></li></ol></li><li class="chapter-item "><a href="../../embed/python.html"><strong aria-hidden="true">4.5.</strong> Python SDK</a></li></ol></li><li class="chapter-item "><a href="../../kubernetes.html"><strong aria-hidden="true">5.</strong> 用 Kubernetes 管理 WasmEdge 应用</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../kubernetes/quickstart.html"><strong aria-hidden="true">5.1.</strong> 快速开始</a></li><li class="chapter-item "><a href="../../kubernetes/demo.html"><strong aria-hidden="true">5.2.</strong> 应用示例</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../kubernetes/demo/wasi.html"><strong aria-hidden="true">5.2.1.</strong> 简单的 WASI 例子</a></li><li class="chapter-item "><a href="../../kubernetes/demo/server.html"><strong aria-hidden="true">5.2.2.</strong> HTTP 微服务</a></li></ol></li><li class="chapter-item "><a href="../../kubernetes/container.html"><strong aria-hidden="true">5.3.</strong> 容器 runtimes</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../kubernetes/container/crun.html"><strong aria-hidden="true">5.3.1.</strong> crun</a></li><li class="chapter-item "><a href="../../kubernetes/container/runc.html"><strong aria-hidden="true">5.3.2.</strong> runc</a></li><li class="chapter-item "><a href="../../kubernetes/container/youki.html"><strong aria-hidden="true">5.3.3.</strong> youki</a></li></ol></li><li class="chapter-item "><a href="../../kubernetes/cri.html"><strong aria-hidden="true">5.4.</strong> CRI runtimes</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../kubernetes/cri/crio.html"><strong aria-hidden="true">5.4.1.</strong> CRI-O</a></li><li class="chapter-item "><a href="../../kubernetes/cri/containerd.html"><strong aria-hidden="true">5.4.2.</strong> containerd</a></li></ol></li><li class="chapter-item "><a href="../../kubernetes/kubernetes.html"><strong aria-hidden="true">5.5.</strong> Kubernetes</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../kubernetes/kubernetes/kubernetes-crio.html"><strong aria-hidden="true">5.5.1.</strong> Kubernetes + CRI-O</a></li><li class="chapter-item "><a href="../../kubernetes/kubernetes/kubernetes-containerd.html"><strong aria-hidden="true">5.5.2.</strong> Kubernetes + containerd</a></li><li class="chapter-item "><a href="../../kubernetes/kubernetes/kind.html"><strong aria-hidden="true">5.5.3.</strong> KinD</a></li><li class="chapter-item "><a href="../../kubernetes/kubernetes/kubeedge.html"><strong aria-hidden="true">5.5.4.</strong> KubeEdge</a></li><li class="chapter-item "><a href="../../kubernetes/kubernetes/superedge.html"><strong aria-hidden="true">5.5.5.</strong> SuperEdge</a></li><li class="chapter-item "><a href="../../kubernetes/kubernetes/openyurt.html"><strong aria-hidden="true">5.5.6.</strong> OpenYurt</a></li></ol></li></ol></li><li class="chapter-item "><a href="../../frameworks.html"><strong aria-hidden="true">6.</strong> 应用框架与平台</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../frameworks/mesh.html"><strong aria-hidden="true">6.1.</strong> Service mesh 与分布式框架</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../frameworks/mesh/dapr.html"><strong aria-hidden="true">6.1.1.</strong> Dapr</a></li><li class="chapter-item "><a href="../../frameworks/mesh/mosn.html"><strong aria-hidden="true">6.1.2.</strong> MOSN</a></li><li class="chapter-item "><a href="../../frameworks/mesh/eventmesh.html"><strong aria-hidden="true">6.1.3.</strong> Apache EventMesh</a></li></ol></li><li class="chapter-item "><a href="../../frameworks/app.html"><strong aria-hidden="true">6.2.</strong> 应用框架</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../frameworks/app/yomo.html"><strong aria-hidden="true">6.2.1.</strong> YoMo</a></li><li class="chapter-item "><a href="../../frameworks/app/reactr.html"><strong aria-hidden="true">6.2.2.</strong> Reactr</a></li></ol></li><li class="chapter-item "><a href="../../frameworks/serverless.html"><strong aria-hidden="true">6.3.</strong> Serverless 平台</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../frameworks/serverless/vercel.html"><strong aria-hidden="true">6.3.1.</strong> Vercel</a></li><li class="chapter-item "><a href="../../frameworks/serverless/netlify.html"><strong aria-hidden="true">6.3.2.</strong> Netlify</a></li><li class="chapter-item "><a href="../../frameworks/serverless/aws.html"><strong aria-hidden="true">6.3.3.</strong> AWS</a></li><li class="chapter-item "><a href="../../frameworks/serverless/tencent.html"><strong aria-hidden="true">6.3.4.</strong> Tencent</a></li><li class="chapter-item "><a href="../../frameworks/serverless/secondstate.html"><strong aria-hidden="true">6.3.5.</strong> Second State</a></li></ol></li></ol></li><li class="chapter-item "><a href="../../os.html"><strong aria-hidden="true">7.</strong> 操作系统</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../os/linux.html"><strong aria-hidden="true">7.1.</strong> Linux</a></li><li class="chapter-item "><a href="../../os/windows.html"><strong aria-hidden="true">7.2.</strong> Windows</a></li><li class="chapter-item "><a href="../../os/mac.html"><strong aria-hidden="true">7.3.</strong> Mac</a></li><li class="chapter-item "><a href="../../os/android.html"><strong aria-hidden="true">7.4.</strong> Android</a></li><li class="chapter-item "><a href="../../os/sel4.html"><strong aria-hidden="true">7.5.</strong> seL4</a></li><li class="chapter-item "><a href="../../os/openharmony.html"><strong aria-hidden="true">7.6.</strong> Open Harmony</a></li><li class="chapter-item "><a href="../../os/raspberrypi.html"><strong aria-hidden="true">7.7.</strong> Raspberry Pi</a></li></ol></li><li class="chapter-item "><a href="../../extend.html"><strong aria-hidden="true">8.</strong> 为 WasmEdge 贡献代码</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../extend/build.html"><strong aria-hidden="true">8.1.</strong> 编译 WasmEdge</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../extend/build_on_mac.html"><strong aria-hidden="true">8.1.1.</strong> 用 Mac 编译</a></li><li class="chapter-item "><a href="../../extend/build_on_windows.html"><strong aria-hidden="true">8.1.2.</strong> 用 Windows 编译</a></li><li class="chapter-item "><a href="../../extend/build_for_android.html"><strong aria-hidden="true">8.1.3.</strong> 为 Android 编译</a></li></ol></li><li class="chapter-item "><a href="../../extend/plugin.html"><strong aria-hidden="true">8.2.</strong> WasmEdge plug-in API</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../extend/plugin/hostfunction.html"><strong aria-hidden="true">8.2.1.</strong> Host 函数</a></li><li class="chapter-item "><a href="../../extend/plugin/externref.html"><strong aria-hidden="true">8.2.2.</strong> 外部引用</a></li></ol></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">WasmEdge Runtime</h1>

                    <div class="right-buttons">
                        <a href="../../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/WasmEdge/WasmEdge" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        <a href="https://github.com/WasmEdge/WasmEdge/tree/master/docs/book/zh/src/embed/go/host_function.md" title="Suggest an edit" aria-label="Suggest an edit">
                            <i id="git-edit-button" class="fa fa-edit"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="如何用-go-编写-host-function"><a class="header" href="#如何用-go-编写-host-function">如何用 Go 编写 Host Function</a></h1>
<p><strong>This file is needed to update to 0.10.0 and translate into English.</strong></p>
<h2 id="什么是-host-function"><a class="header" href="#什么是-host-function">什么是 Host Function</a></h2>
<p>顾名思义, Host Function 就是定义在 Host 程序中的函数. 对于 Wasm 来说, Host Function 可以做为导入段 <code>import</code> 被注册到一个模块 <code>module</code> 中, 之后便可以在 Wasm 运行时被调用.</p>
<p>Wasm 目前的能力有限，但那些 Wasm 本身做不了的事情, 都可以依靠 Host Function 来解决, 这极大地扩展了 Wasm 的能力范围.</p>
<p><a href="https://github.com/WasmEdge/WasmEdge">WasmEdge</a> 在标准之外做的扩展基本都是依赖 Host Function 做的的，比如，<a href="https://wasmedge.org/book/en/dev/rust/tensorflow.html">WasmEdge</a> 提供的 <a href="https://github.com/second-state/wasmedge_tensorflow_interface">Tensorflow API</a>, 是使用 Host Function 实现的，也因此实现了以原生速度运行 AI 推理的目标。</p>
<p>Networking socket 也是使用 host function 实现的，因此我们可以在 <a href="https://wasmedge.org/book/en/dev/rust/networking-nonblocking.html">WasmEdge 运行异步 HTTP 客户端和服务器</a>，弥补了 WebAssembly 在网络上的不足。</p>
<p>再比如 <a href="https://www.fastly.com/blog/edge-programming-rust-web-assembly">Fastly</a> 使用 Host Function 为 Wasm 增加了 Http Request 和 Key-value store 等接口, 进而增添了扩展功能。</p>
<h2 id="如何编写简单的-host-function"><a class="header" href="#如何编写简单的-host-function">如何编写简单的 Host Function</a></h2>
<p>让我们从一个最简单的例子入手, 来看看如何在一个 Go 程序里编写 Host function。</p>
<p>先来编写一个简单的 rust 程序。国际惯例，<code>Cargo.toml</code> 不能少。</p>
<p><code>Cargo.toml</code>:</p>
<pre><code class="language-toml">[package]
name = &quot;rust_host_func&quot;
version = &quot;0.1.0&quot;
edition = &quot;2021&quot;

[lib]
crate-type = [&quot;cdylib&quot;, &quot;rlib&quot;]

[dependencies]
</code></pre>
<p>再来看看 Rust 代码是什么样的。</p>
<p><code>lib.rs</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>extern &quot;C&quot; {
  fn add(a: i32, b: i32) -&gt; i32;
}

#[no_mangle]
pub unsafe extern fn run() -&gt; i32 {
  add(1, 2)
}
<span class="boring">}
</span></code></pre></pre>
<p>上述程序中的 <code>add</code> 函数被声明在 <code>extern &quot;C&quot;</code> 中, 这就是一个 Host Function。我们使用如下命令将这段 Rust 程序编译为 wasm:</p>
<pre><code class="language-bash">cargo build --target wasm32-wasi --release
</code></pre>
<p>然后我们使用 <code>wasm2wat</code> 来查看 wasm 文件的导入段:</p>
<pre><code class="language-bash">wasm2wat target/wasm32-wasi/release/rust_host_func.wasm | grep import
</code></pre>
<p>输出如下:</p>
<pre><code class="language-bash">  (import &quot;env&quot; &quot;add&quot; (func $add (type 0)))
</code></pre>
<p>可以看到 <code>add</code> 函数被放到了默认名称为 <code>env</code> 的模块的导入段中.</p>
<p>接下来我们来看如何使用 <a href="https://github.com/second-state/WasmEdge-go">WasmEdge-go</a> SDK 来执行这段 wasm 程序.</p>
<p><code>hostfunc.go</code>:</p>
<pre><code class="language-go">package main

import (
  &quot;fmt&quot;
  &quot;os&quot;

  &quot;github.com/second-state/WasmEdge-go/wasmedge&quot;
)

func add(_ interface{}, _ *wasmedge.Memory, params []interface{}) ([]interface{}, wasmedge.Result) {
  // 将从 wasm 传过来的两个参数做加法运算
  return []interface{}{params[0].(int32) + params[1].(int32)}, wasmedge.Result_Success
}

func main() {
  vm := wasmedge.NewVM()
 
  // 使用默认名称 env 构建导入段对象
  obj := wasmedge.NewImportObject(&quot;env&quot;)

  // 构建 Host Function 的参数和返回值类型
  funcAddType := wasmedge.NewFunctionType(
    []wasmedge.ValType{
      wasmedge.ValType_I32,
      wasmedge.ValType_I32,
    },
    []wasmedge.ValType{
      wasmedge.ValType_I32,
    })
  hostAdd := wasmedge.NewFunction(funcAddType, add, nil, 0)
 
  // 将 Host Function 加入到导入段对象中
  // 注意第一个参数 `add` 是 rust 中定义的外部函数的名称
  obj.AddFunction(&quot;add&quot;, hostAdd)

  // 注册导入段对象
  vm.RegisterImport(obj)

  // 加载, 验证并实例化 wasm 程序
  vm.LoadWasmFile(os.Args[1])
  vm.Validate()
  vm.Instantiate()

  // 执行 wasm 导出的函数并取得返回值
  r, _ := vm.Execute(&quot;run&quot;)
  fmt.Printf(&quot;%d&quot;, r[0].(int32))

  obj.Release()
  vm.Release()
}

</code></pre>
<p>编译并执行:</p>
<pre><code class="language-bash">go build
./hostfunc rust_host_func.wasm
</code></pre>
<p>程序输出 <code>3</code> 。</p>
<p>这样我们就完成了一个最简单的在 Host 中定义 Function, 并在 wasm 中调用的例子。</p>
<p>下面让我们尝试用 Host Function 做一些更有趣的事情.</p>
<h2 id="传递复杂类型"><a class="header" href="#传递复杂类型">传递复杂类型</a></h2>
<p>受 Wasm 里数据类型的制约, Host Function 只能传递如 int32 等少数几种基本类型的数据, 这就会大大限制 Host Function 的应用范围. 那有没有什么办法能让我们传递如 string 等复杂数据类型的数据呢？答案是当然可以， 下面我们就通过一个例子看看是如何做到的。</p>
<p>在这个例子中, 我们要统计 <code>https://www.google.com</code> 的网页源代码中 <code>google</code> 出现的次数。
例子的源代码在<a href="https://github.com/second-state/WasmEdge-go-examples/tree/master/go_HostFunc">这里</a>.</p>
<p>还是先上 Rust 代码。<code>Cargo.toml</code> 是必不可少的，只是我在这里省略了。</p>
<p><code>lib.rs</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>extern &quot;C&quot; {
  fn fetch(url_pointer: *const u8, url_length: i32) -&gt; i32;
  fn write_mem(pointer: *const u8);
}

#[no_mangle]
pub unsafe extern fn run() -&gt; i32 {
  let url = &quot;https://www.google.com&quot;;
  let pointer = url.as_bytes().as_ptr();

  // call host function to fetch the source code, return the result length
  let res_len = fetch(pointer, url.len() as i32) as usize;

  // malloc memory
  let mut buffer = Vec::with_capacity(res_len);
  let pointer = buffer.as_mut_ptr();

  // call host function to write source code to the memory
  write_mem(pointer);

  // find occurrences from source code
  buffer.set_len(res_len);
  let str = std::str::from_utf8(&amp;buffer).unwrap();
  str.matches(&quot;google&quot;).count() as i32
}
<span class="boring">}
</span></code></pre></pre>
<p>在这段代码中, 引入了两个 Host Function:</p>
<ul>
<li><code>fetch</code> 用于发送 http 请求以获取网页源代码</li>
<li><code>write_mem</code> 用于把网页源代码写到 wasm 的内存</li>
</ul>
<p>你可能已经看出来了, 要在 Host Function 里传递 string, 实际是通过传递这段 string 所在内存指针和长度来实现的. <code>fetch</code> 接收两个参数, 他们就分别是字符串 <code>https://www.google.com</code> 的指针和字节长度.</p>
<p><code>fetch</code> 在获取到源代码后, 将源码的字节长度做为返回值返回。Rust 在分配了此长度的内存后, 将内存指针传递给 <code>write_mem</code>, host 将源码写入到这段内存, 进而达到了返回 string 的目的.</p>
<p>编译的过程同上不再赘述, 接下来展示如何使用 <a href="https://github.com/second-state/WasmEdge-go">WasmEdge-go</a> SDK 来执行这段 Wasm 程序。</p>
<p><code>hostfun.go</code>:</p>
<pre><code class="language-go">package main

import (
  &quot;fmt&quot;
  &quot;io&quot;
  &quot;os&quot;
  &quot;net/http&quot;

  &quot;github.com/second-state/WasmEdge-go/wasmedge&quot;
)

type host struct {
  fetchResult []byte
}

// do the http fetch
func fetch(url string) []byte {
  resp, err := http.Get(string(url))
  if err != nil {
    return nil
  }
  defer resp.Body.Close()
  body, err := io.ReadAll(resp.Body)
  if err != nil {
    return nil
  }

  return body
}

// Host function for fetching
func (h *host) fetch(_ interface{}, mem *wasmedge.Memory, params []interface{}) ([]interface{}, wasmedge.Result) {
  // get url from memory
  pointer := params[0].(int32)
  size := params[1].(int32)
  data, _ := mem.GetData(uint(pointer), uint(size))
  url := make([]byte, size)

  copy(url, data)

  respBody := fetch(string(url))

  if respBody == nil {
    return nil, wasmedge.Result_Fail
  }

  // store the source code
  h.fetchResult = respBody

  return []interface{}{len(respBody)}, wasmedge.Result_Success
}

// Host function for writting memory
func (h *host) writeMem(_ interface{}, mem *wasmedge.Memory, params []interface{}) ([]interface{}, wasmedge.Result) {
  // write source code to memory
  pointer := params[0].(int32)
  mem.SetData(h.fetchResult, uint(pointer), uint(len(h.fetchResult)))

  return nil, wasmedge.Result_Success
}

func main() {
  conf := wasmedge.NewConfigure(wasmedge.WASI)
  vm := wasmedge.NewVMWithConfig(conf)
  obj := wasmedge.NewImportObject(&quot;env&quot;)

  h := host{}
  // Add host functions into the import object
  funcFetchType := wasmedge.NewFunctionType(
    []wasmedge.ValType{
      wasmedge.ValType_I32,
      wasmedge.ValType_I32,
    },
    []wasmedge.ValType{
      wasmedge.ValType_I32,
    })

  hostFetch := wasmedge.NewFunction(funcFetchType, h.fetch, nil, 0)
  obj.AddFunction(&quot;fetch&quot;, hostFetch)

  funcWriteType := wasmedge.NewFunctionType(
    []wasmedge.ValType{
      wasmedge.ValType_I32
    },
    []wasmedge.ValType{})
  hostWrite := wasmedge.NewFunction(funcWriteType, h.writeMem, nil, 0)
  obj.AddFunction(&quot;write_mem&quot;, hostWrite)

  vm.RegisterImport(obj)

  vm.LoadWasmFile(os.Args[1])
  vm.Validate()
  vm.Instantiate()

  r, _ := vm.Execute(&quot;run&quot;)
  fmt.Printf(&quot;There are %d 'google' in source code of google.com\n&quot;, r[0])

  obj.Release()
  vm.Release()
  conf.Release()
}

</code></pre>
<p>有了对 Rust 代码的理解, 这段 go 代码其实就很容易理解了。 比较关键的就是对 Wasm 内存的存取:</p>
<ul>
<li><code>mem.GetData(uint(pointer), uint(size))</code> 取得 Wasm 中网页的 url</li>
<li><code>mem.SetData(h.fetchResult, uint(pointer), uint(len(h.fetchResult)))</code> 将网页源码写入 wasm 内存</li>
</ul>
<p>这个例子的编译执行步骤和前一个例子一模一样, 最后执行的结果是:</p>
<p><code>There are 79 'google' in source code of google.com</code></p>
<h2 id="结语"><a class="header" href="#结语">结语</a></h2>
<p>通过以上两个例子的抛砖引玉, 相信你已经对 Host Function 有了一个初步印象。
虽然因为 Wasm 的诸多限制, 在开发体验上还不太理想, 但随着我们对工具及库的不断完善, 将会为 Wasm 的应用场景带来无尽可能。</p>
<p>欢迎持续关注 <a href="https://wasmedge.org">WasmEdge</a> 项目, 谢谢。</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../../embed/go/tensorflow.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                            <a rel="next" href="../../embed/go/bindgen.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../../embed/go/tensorflow.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                    <a rel="next" href="../../embed/go/bindgen.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="../../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
    </body>
</html>
