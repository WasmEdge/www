<!DOCTYPE HTML>
<html lang="zh" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>WasmEdge Runtime</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-NGPCK7VF2L"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-NGPCK7VF2L');
</script>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item "><a href="index.html"><strong aria-hidden="true">1.</strong> 快速开始</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="start/install.html"><strong aria-hidden="true">1.1.</strong> WasmEdge 的安装与卸载</a></li><li class="chapter-item "><a href="start/docker.html"><strong aria-hidden="true">1.2.</strong> 使用 Docker 进行 WasmEdge 应用程序开发</a></li><li class="chapter-item "><a href="start/cli.html"><strong aria-hidden="true">1.3.</strong> WasmEdge 命令行</a></li><li class="chapter-item "><a href="start/universal.html"><strong aria-hidden="true">1.4.</strong> 通用 wasm 二进制格式</a></li></ol></li><li class="chapter-item "><a href="intro.html"><strong aria-hidden="true">2.</strong> WasmEdge 介绍</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="intro/use.html"><strong aria-hidden="true">2.1.</strong> 应用场景</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="intro/use/runtime.html"><strong aria-hidden="true">2.1.1.</strong> 云原生的 runtime</a></li><li class="chapter-item "><a href="intro/use/js.html"><strong aria-hidden="true">2.1.2.</strong> JavaScript 或 DSL runtime</a></li><li class="chapter-item "><a href="intro/use/serverless.html"><strong aria-hidden="true">2.1.3.</strong> 公有云中的 Serverless 函数即服务</a></li><li class="chapter-item "><a href="intro/use/edge.html"><strong aria-hidden="true">2.1.4.</strong> 边缘计算</a></li><li class="chapter-item "><a href="intro/use/saas.html"><strong aria-hidden="true">2.1.5.</strong> SaaS 里的嵌入式函数</a></li></ol></li><li class="chapter-item "><a href="intro/features.html"><strong aria-hidden="true">2.2.</strong> WasmEdge 的优势与特点</a></li><li class="chapter-item "><a href="intro/standard.html"><strong aria-hidden="true">2.3.</strong> WebAssembly 的标准扩展</a></li><li class="chapter-item "><a href="intro/proprietary.html"><strong aria-hidden="true">2.4.</strong> WasmEdge 特有的扩展</a></li><li class="chapter-item "><a href="intro/integrations.html"><strong aria-hidden="true">2.5.</strong> 与外部框架的集成</a></li><li class="chapter-item "><a href="intro/faq.html"><strong aria-hidden="true">2.6.</strong> FAQ</a></li></ol></li><li class="chapter-item "><a href="dev.html"><strong aria-hidden="true">3.</strong> 开发 WasmEdge 应用</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="dev/rust.html"><strong aria-hidden="true">3.1.</strong> Rust</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="dev/rust/wasi.html"><strong aria-hidden="true">3.1.1.</strong> 使用操作系统服务</a></li><li class="chapter-item "><a href="dev/rust/tensorflow.html"><strong aria-hidden="true">3.1.2.</strong> Tensorflow 推理</a></li><li class="chapter-item "><a href="dev/rust/networking.html"><strong aria-hidden="true">3.1.3.</strong> 网络</a></li><li class="chapter-item "><a href="dev/rust/command.html"><strong aria-hidden="true">3.1.4.</strong> 使用命令行程序</a></li><li class="chapter-item "><a href="dev/rust/bindgen.html"><strong aria-hidden="true">3.1.5.</strong> rustwasmc</a></li></ol></li><li class="chapter-item "><a href="dev/js.html"><strong aria-hidden="true">3.2.</strong> JavaScript</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="dev/js/quickstart.html"><strong aria-hidden="true">3.2.1.</strong> 快速开始</a></li><li class="chapter-item "><a href="dev/js/networking.html"><strong aria-hidden="true">3.2.2.</strong> 网络</a></li><li class="chapter-item "><a href="dev/js/fetch.html"><strong aria-hidden="true">3.2.3.</strong> Fetch</a></li><li class="chapter-item "><a href="dev/js/tensorflow.html"><strong aria-hidden="true">3.2.4.</strong> Tensorflow 推理</a></li><li class="chapter-item "><a href="dev/js/ssr.html"><strong aria-hidden="true">3.2.5.</strong> 示例：React SSR</a></li><li class="chapter-item "><a href="dev/js/es6.html"><strong aria-hidden="true">3.2.6.</strong> ES6 模块</a></li><li class="chapter-item "><a href="dev/js/npm.html"><strong aria-hidden="true">3.2.7.</strong> NodeJS &amp; NPM 模块</a></li><li class="chapter-item "><a href="dev/js/rust.html"><strong aria-hidden="true">3.2.8.</strong> 用 Rust 实现 JS API</a></li></ol></li><li class="chapter-item "><a href="dev/python.html"><strong aria-hidden="true">3.3.</strong> Python</a></li><li class="chapter-item "><a href="dev/go.html"><strong aria-hidden="true">3.4.</strong> Go</a></li><li class="chapter-item "><a href="dev/swift.html"><strong aria-hidden="true">3.5.</strong> Swift</a></li><li class="chapter-item "><a href="dev/as.html"><strong aria-hidden="true">3.6.</strong> AssemblyScript</a></li><li class="chapter-item "><a href="dev/kotlin.html"><strong aria-hidden="true">3.7.</strong> Kotlin</a></li><li class="chapter-item "><a href="dev/grain.html"><strong aria-hidden="true">3.8.</strong> Grain</a></li></ol></li><li class="chapter-item "><a href="embed.html"><strong aria-hidden="true">4.</strong> 嵌入 WasmEdge 函数</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="embed/c.html"><strong aria-hidden="true">4.1.</strong> C SDK</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="embed/c/ref.html"><strong aria-hidden="true">4.1.1.</strong> API 参考文档</a></li></ol></li><li class="chapter-item "><a href="embed/go.html"><strong aria-hidden="true">4.2.</strong> Go SDK</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="embed/go/app.html"><strong aria-hidden="true">4.2.1.</strong> 嵌入 WASM 应用程序</a></li><li class="chapter-item "><a href="embed/go/function.html"><strong aria-hidden="true">4.2.2.</strong> 嵌入 WASM 函数</a></li><li class="chapter-item "><a href="embed/go/memory.html"><strong aria-hidden="true">4.2.3.</strong> 传递复杂参数</a></li><li class="chapter-item "><a href="embed/go/tensorflow.html"><strong aria-hidden="true">4.2.4.</strong> Tensorflow 调用</a></li><li class="chapter-item "><a href="embed/go/bindgen.html"><strong aria-hidden="true">4.2.5.</strong> 使用 wasm-bindgen</a></li><li class="chapter-item "><a href="embed/go/ref.html"><strong aria-hidden="true">4.2.6.</strong> API 参考文档</a></li></ol></li><li class="chapter-item "><a href="embed/node.html"><strong aria-hidden="true">4.3.</strong> Node.js SDK</a></li><li class="chapter-item "><a href="embed/rust.html"><strong aria-hidden="true">4.4.</strong> Rust SDK</a></li><li class="chapter-item "><a href="embed/python.html"><strong aria-hidden="true">4.5.</strong> Python SDK</a></li></ol></li><li class="chapter-item "><a href="kubernetes.html"><strong aria-hidden="true">5.</strong> 用 Kubernetes 管理 WasmEdge 应用</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="kubernetes/quickstart.html"><strong aria-hidden="true">5.1.</strong> 快速开始</a></li><li class="chapter-item "><a href="kubernetes/demo.html"><strong aria-hidden="true">5.2.</strong> 应用示例</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="kubernetes/demo/wasi.html"><strong aria-hidden="true">5.2.1.</strong> 简单的 WASI 例子</a></li><li class="chapter-item "><a href="kubernetes/demo/server.html"><strong aria-hidden="true">5.2.2.</strong> HTTP 微服务</a></li></ol></li><li class="chapter-item "><a href="kubernetes/container.html"><strong aria-hidden="true">5.3.</strong> 容器 runtimes</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="kubernetes/container/crun.html"><strong aria-hidden="true">5.3.1.</strong> crun</a></li><li class="chapter-item "><a href="kubernetes/container/runc.html"><strong aria-hidden="true">5.3.2.</strong> runc</a></li><li class="chapter-item "><a href="kubernetes/container/youki.html"><strong aria-hidden="true">5.3.3.</strong> youki</a></li></ol></li><li class="chapter-item "><a href="kubernetes/cri.html"><strong aria-hidden="true">5.4.</strong> CRI runtimes</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="kubernetes/cri/crio.html"><strong aria-hidden="true">5.4.1.</strong> CRI-O</a></li><li class="chapter-item "><a href="kubernetes/cri/containerd.html"><strong aria-hidden="true">5.4.2.</strong> containerd</a></li></ol></li><li class="chapter-item "><a href="kubernetes/kubernetes.html"><strong aria-hidden="true">5.5.</strong> Kubernetes</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="kubernetes/kubernetes/kubernetes-crio.html"><strong aria-hidden="true">5.5.1.</strong> Kubernetes + CRI-O</a></li><li class="chapter-item "><a href="kubernetes/kubernetes/kubernetes-containerd.html"><strong aria-hidden="true">5.5.2.</strong> Kubernetes + containerd</a></li><li class="chapter-item "><a href="kubernetes/kubernetes/kind.html"><strong aria-hidden="true">5.5.3.</strong> KinD</a></li><li class="chapter-item "><a href="kubernetes/kubernetes/kubeedge.html"><strong aria-hidden="true">5.5.4.</strong> KubeEdge</a></li><li class="chapter-item "><a href="kubernetes/kubernetes/superedge.html"><strong aria-hidden="true">5.5.5.</strong> SuperEdge</a></li><li class="chapter-item "><a href="kubernetes/kubernetes/openyurt.html"><strong aria-hidden="true">5.5.6.</strong> OpenYurt</a></li></ol></li></ol></li><li class="chapter-item "><a href="frameworks.html"><strong aria-hidden="true">6.</strong> 应用框架与平台</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="frameworks/mesh.html"><strong aria-hidden="true">6.1.</strong> Service mesh 与分布式框架</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="frameworks/mesh/dapr.html"><strong aria-hidden="true">6.1.1.</strong> Dapr</a></li><li class="chapter-item "><a href="frameworks/mesh/mosn.html"><strong aria-hidden="true">6.1.2.</strong> MOSN</a></li><li class="chapter-item "><a href="frameworks/mesh/eventmesh.html"><strong aria-hidden="true">6.1.3.</strong> Apache EventMesh</a></li></ol></li><li class="chapter-item "><a href="frameworks/app.html"><strong aria-hidden="true">6.2.</strong> 应用框架</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="frameworks/app/yomo.html"><strong aria-hidden="true">6.2.1.</strong> YoMo</a></li><li class="chapter-item "><a href="frameworks/app/reactr.html"><strong aria-hidden="true">6.2.2.</strong> Reactr</a></li></ol></li><li class="chapter-item "><a href="frameworks/serverless.html"><strong aria-hidden="true">6.3.</strong> Serverless 平台</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="frameworks/serverless/vercel.html"><strong aria-hidden="true">6.3.1.</strong> Vercel</a></li><li class="chapter-item "><a href="frameworks/serverless/netlify.html"><strong aria-hidden="true">6.3.2.</strong> Netlify</a></li><li class="chapter-item "><a href="frameworks/serverless/aws.html"><strong aria-hidden="true">6.3.3.</strong> AWS</a></li><li class="chapter-item "><a href="frameworks/serverless/tencent.html"><strong aria-hidden="true">6.3.4.</strong> Tencent</a></li><li class="chapter-item "><a href="frameworks/serverless/secondstate.html"><strong aria-hidden="true">6.3.5.</strong> Second State</a></li></ol></li></ol></li><li class="chapter-item "><a href="os.html"><strong aria-hidden="true">7.</strong> 操作系统</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="os/linux.html"><strong aria-hidden="true">7.1.</strong> Linux</a></li><li class="chapter-item "><a href="os/windows.html"><strong aria-hidden="true">7.2.</strong> Windows</a></li><li class="chapter-item "><a href="os/mac.html"><strong aria-hidden="true">7.3.</strong> Mac</a></li><li class="chapter-item "><a href="os/android.html"><strong aria-hidden="true">7.4.</strong> Android</a></li><li class="chapter-item "><a href="os/sel4.html"><strong aria-hidden="true">7.5.</strong> seL4</a></li><li class="chapter-item "><a href="os/openharmony.html"><strong aria-hidden="true">7.6.</strong> Open Harmony</a></li><li class="chapter-item "><a href="os/raspberrypi.html"><strong aria-hidden="true">7.7.</strong> Raspberry Pi</a></li></ol></li><li class="chapter-item "><a href="extend.html"><strong aria-hidden="true">8.</strong> 为 WasmEdge 贡献代码</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="extend/build.html"><strong aria-hidden="true">8.1.</strong> 编译 WasmEdge</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="extend/build_on_mac.html"><strong aria-hidden="true">8.1.1.</strong> 用 Mac 编译</a></li><li class="chapter-item "><a href="extend/build_on_windows.html"><strong aria-hidden="true">8.1.2.</strong> 用 Windows 编译</a></li><li class="chapter-item "><a href="extend/build_for_android.html"><strong aria-hidden="true">8.1.3.</strong> 为 Android 编译</a></li></ol></li><li class="chapter-item "><a href="extend/plugin.html"><strong aria-hidden="true">8.2.</strong> WasmEdge plug-in API</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="extend/plugin/hostfunction.html"><strong aria-hidden="true">8.2.1.</strong> Host functions</a></li><li class="chapter-item "><a href="extend/plugin/externref.html"><strong aria-hidden="true">8.2.2.</strong> External references</a></li></ol></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">WasmEdge Runtime</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/WasmEdge/WasmEdge" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="快速开始"><a class="header" href="#快速开始">快速开始</a></h1>
<p>WasmEdge 最简单的使用方式是通过 WasmEdge CLI。
开发者们能使用这个命令行工具来运行我们的 WebAssembly 和 JavaScript 示例程序。
之后，我们也可以使用该工具来创建新的 WasmEdge 程序，并将这些程序部署到不同的应用或者框架中运行。</p>
<h2 id="安装"><a class="header" href="#安装">安装</a></h2>
<p>你可以使用以下的单行命令来安装 WasmEdge。
你的系统必须预先安装 <code>git</code> 和 <code>curl</code>。</p>
<pre><code class="language-bash">curl -sSf https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/utils/install.sh | bash
</code></pre>
<p>如果你希望一并安装 <a href="https://www.secondstate.io/articles/wasi-tensorflow/">Tensorflow 和图像处理扩展</a>，请执行以下命令。它将尝试在你的系统上安装 Tensorflow 和图像共享库。</p>
<pre><code class="language-bash">curl -sSf https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/utils/install.sh | bash -s -- -e all
</code></pre>
<p>执行以下命令能使已安装的二进制文件在当前会话中可用。</p>
<pre><code class="language-bash">source $HOME/.wasmedge/env
</code></pre>
<h2 id="使用-docker-进行安装"><a class="header" href="#使用-docker-进行安装">使用 Docker 进行安装</a></h2>
<p>如果你使用的是 Docker，你可以直接运行 WasmEdge 应用开发镜像（<a href="https://hub.docker.com/repository/docker/wasmedge/appdev_x86_64">x86</a> 和 <a href="https://hub.docker.com/repository/docker/wasmedge/appdev_aarch64">arm64</a>）。这些镜像里包含快速开发 WasmEdge 所需的所有工具。</p>
<pre><code class="language-bash">$ docker pull wasmedge/appdev_x86_64:0.9.0
$ docker run --rm -v $(pwd):/app -it wasmedge/appdev_x86_64:0.9.0
(docker) #
</code></pre>
<h2 id="webassembly-示例"><a class="header" href="#webassembly-示例">WebAssembly 示例</a></h2>
<p>这里有几个 WebAssembly 字节码的示例供您试用新安装的 WasmEdge CLI。</p>
<h3 id="hello-world"><a class="header" href="#hello-world">Hello world</a></h3>
<p><a href="https://github.com/WasmEdge/WasmEdge/raw/master/tools/wasmedge/examples/hello.wasm">hello.wasm</a> 这个 WebAssembly 程序中包含一个 <code>main()</code> 函数。
<a href="https://github.com/second-state/wasm-learning/tree/master/cli/hello">查看该程序的 Rust 源码项目。</a>
它将打印 <code>hello</code>，以及所有的命令行参数。</p>
<pre><code class="language-bash">$ wasmedge hello.wasm second state
hello
second
state
</code></pre>
<h3 id="调用一个-rust-函数"><a class="header" href="#调用一个-rust-函数">调用一个 Rust 函数</a></h3>
<p><a href="https://github.com/WasmEdge/WasmEdge/raw/master/tools/wasmedge/examples/add.wasm">add.wasm</a> 这个 WebAssembly 程序包含一个 <code>add()</code> 函数。
<a href="https://github.com/second-state/wasm-learning/tree/master/cli/add">查看该程序的 Rust 源码项目。</a>
我们在反应器模式下使用 WasmEdge 来调用 <code>add()</code>，并给它 2 个整数作为输入参数。</p>
<pre><code class="language-bash">$ wasmedge --reactor add.wasm add 2 2
4
</code></pre>
<h3 id="调用一个-wat-函数"><a class="header" href="#调用一个-wat-函数">调用一个 WAT 函数</a></h3>
<p>我们手动创建了 <a href="https://github.com/WasmEdge/WasmEdge/raw/master/tools/wasmedge/examples/fibonacci.wat">fibonacci.wat</a> 程序，并使用了 <a href="https://github.com/WebAssembly/wabt">wat2wasm</a> 编译器来构建 <a href="https://github.com/WasmEdge/WasmEdge/raw/master/tools/wasmedge/examples/fibonacci.wasm">fibonacci.wasm</a> 这个 WebAssembly 程序。
它包含了一个 <code>fib()</code> 函数，这个函数以一个整数作为输入参数。我们在反应器模式下使用 WasmEdge 来调用这个导出函数。</p>
<pre><code class="language-bash">$ wasmedge --reactor fibonacci.wasm fib 10
89
</code></pre>
<h3 id="开启统计"><a class="header" href="#开启统计">开启统计</a></h3>
<p>CLI工具支持 <code>--enable-all-statistics</code> 标志，用于开启统计和 gas meter 的相关配置。</p>
<pre><code class="language-bash">$ wasmedge --enable-all-statistics hello.wasm second state
hello
second
state
[2021-12-09 16:03:33.261] [info] ====================  Statistics  ====================
[2021-12-09 16:03:33.261] [info]  Total execution time: 268266 ns
[2021-12-09 16:03:33.261] [info]  Wasm instructions execution time: 251610 ns
[2021-12-09 16:03:33.261] [info]  Host functions execution time: 16656 ns
[2021-12-09 16:03:33.261] [info]  Executed wasm instructions count: 20425
[2021-12-09 16:03:33.261] [info]  Gas costs: 20425
[2021-12-09 16:03:33.261] [info]  Instructions per second: 81177218
[2021-12-09 16:03:33.261] [info] =======================   End   ======================
</code></pre>
<h3 id="开启-gas-limit"><a class="header" href="#开启-gas-limit">开启 gas-limit</a></h3>
<p>CLI工具支持 <code>--gas-limit</code> 标志，用于控制执行的成本。</p>
<pre><code class="language-bash"># cd &lt;path/to/WasmEdge&gt;
$ cd tools/wasmedge/examples
# gas 足够时
$ wasmedge --enable-all-statistics --gas-limit 20425 hello.wasm second state
hello
second
state
[2021-12-09 16:03:33.261] [info] ====================  Statistics  ====================
[2021-12-09 16:03:33.261] [info]  Total execution time: 268266 ns
[2021-12-09 16:03:33.261] [info]  Wasm instructions execution time: 251610 ns
[2021-12-09 16:03:33.261] [info]  Host functions execution time: 16656 ns
[2021-12-09 16:03:33.261] [info]  Executed wasm instructions count: 20425
[2021-12-09 16:03:33.261] [info]  Gas costs: 20425
[2021-12-09 16:03:33.261] [info]  Instructions per second: 81177218
[2021-12-09 16:03:33.261] [info] =======================   End   ======================

# gas 不足时
$ wasmedge --enable-all-statistics --gas-limit 20 hello.wasm second state
[2021-12-23 15:19:06.690] [error] Cost exceeded limit. Force terminate the execution.
[2021-12-23 15:19:06.690] [error]     In instruction: ref.func (0xd2) , Bytecode offset: 0x00000000
[2021-12-23 15:19:06.690] [error]     At AST node: expression
[2021-12-23 15:19:06.690] [error]     At AST node: element segment
[2021-12-23 15:19:06.690] [error]     At AST node: element section
[2021-12-23 15:19:06.690] [error]     At AST node: module
[2021-12-23 15:19:06.690] [info] ====================  Statistics  ====================
[2021-12-23 15:19:06.690] [info]  Total execution time: 0 ns
[2021-12-23 15:19:06.690] [info]  Wasm instructions execution time: 0 ns
[2021-12-23 15:19:06.690] [info]  Host functions execution time: 0 ns
[2021-12-23 15:19:06.690] [info]  Executed wasm instructions count: 21
[2021-12-23 15:19:06.690] [info]  Gas costs: 20
</code></pre>
<h2 id="javascript-示例"><a class="header" href="#javascript-示例">JavaScript 示例</a></h2>
<p>WasmEdge 也可以作为一个高性能、安全、可扩展、易于部署且<a href="https://github.com/second-state/wasmedge-containers-examples">遵循 Kubernetes</a> 的 JavaScript 运行时。</p>
<p><a href="https://github.com/WasmEdge/WasmEdge/raw/master/tools/wasmedge/examples/js/qjs.wasm">qjs.wasm</a> 是一个被编译为 WebAssembly 的 JavaScript 解释器。
<a href="https://github.com/WasmEdge/WasmEdge/raw/master/tools/wasmedge/examples/js/hello.js">hello.js</a> 是一个非常简单的 JavaScript 程序。</p>
<pre><code class="language-bash">$ wasmedge --dir .:. qjs.wasm hello.js 1 2 3
Hello 1 2 3
</code></pre>
<p><a href="https://github.com/WasmEdge/WasmEdge/raw/master/tools/wasmedge/examples/js/qjs_tf.wasm">qjs_tf.wasm</a> 则是一个 WebAssembly 版本的 JavaScript 解释器（带有 <a href="https://www.secondstate.io/articles/wasi-tensorflow/">Tensorflow 扩展</a>）。
要想运行 <a href="https://github.com/WasmEdge/WasmEdge/raw/master/tools/wasmedge/examples/js/qjs_tf.wasm">qjs_tf.wasm</a>，你必须使用 <code>wasmedge-tensorflow-lite</code> 这个命令行工具；这个工具里内置了包含 Tensorflow 扩展的 WasmEdge 构建版本。
你可以下载一个<a href="https://github.com/second-state/wasmedge-quickjs/tree/main/example_js/tensorflow_lite_demo">基于 Tensorflow 的完整 JavaScript 示例</a>来对图像进行分类。</p>
<pre><code class="language-bash"># Download the Tensorflow example
$ wget https://raw.githubusercontent.com/second-state/wasmedge-quickjs/main/example_js/tensorflow_lite_demo/aiy_food_V1_labelmap.txt
$ wget https://raw.githubusercontent.com/second-state/wasmedge-quickjs/main/example_js/tensorflow_lite_demo/food.jpg
$ wget https://raw.githubusercontent.com/second-state/wasmedge-quickjs/main/example_js/tensorflow_lite_demo/lite-model_aiy_vision_classifier_food_V1_1.tflite
$ wget https://raw.githubusercontent.com/second-state/wasmedge-quickjs/main/example_js/tensorflow_lite_demo/main.js

$ wasmedge-tensorflow-lite --dir .:. qjs_tf.wasm main.js
label: Hot dog
confidence: 0.8941176470588236
</code></pre>
<p>继续阅读并学习 WasmEdge。</p>
<ul>
<li><a href="start/install.html">WasmEdge 的安装与卸载</a></li>
<li><a href="start/cli.html">WasmEdge 命令行</a></li>
<li><a href="intro/use.html">WasmEdge 应用场景</a></li>
<li><a href="intro/features.html">WasmEdge 的优势与特点</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="wasmedge-的安装与卸载"><a class="header" href="#wasmedge-的安装与卸载">WasmEdge 的安装与卸载</a></h1>
<h2 id="快速安装"><a class="header" href="#快速安装">快速安装</a></h2>
<p>安装 WasmEdge 最简单的方式是执行以下的命令（前提是你的系统已经安装了 <code>git</code> 和 <code>curl</code>）：</p>
<pre><code class="language-bash">curl -sSf https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/utils/install.sh | bash
</code></pre>
<p>如果你希望一并安装 <a href="https://www.secondstate.io/articles/wasi-tensorflow/">Tensorflow 和图像处理扩展</a>，请执行以下命令。它将尝试在你的系统上安装 Tensorflow 和图像共享库。</p>
<pre><code class="language-bash">curl -sSf https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/utils/install.sh | bash -s -- -e all
</code></pre>
<p>执行 <code>source $HOME/.wasmedge/env</code> 命令能使已安装的二进制文件在当前会话中可用。</p>
<p>**就这么简单！**你现在可以通过命令行使用 WasmEdge，或者直接将其作为应用打开。要想升级 WasmEdge，你只需要重新执行以上的命令，旧的文件将被覆盖。</p>
<h2 id="为所有用户安装-wasmedge"><a class="header" href="#为所有用户安装-wasmedge">为所有用户安装 WasmEdge</a></h2>
<p>在默认情况下，WasmEdge 将安装在 <code>$HOME/.wasmedge</code> 目录中。你也可以将它安装在系统目录中，如 <code>/usr/local</code>，以便所有用户都能使用 WasmEdge。要想指定一个安装路径，你可以在执行 <code>install.sh</code> 脚本时附上 <code>-p</code> 选项。由于文件将写入系统目录，你需要以 <code>root</code> 用户或 <code>sudo</code> 权限执行以下命令：</p>
<pre><code class="language-bash">curl -sSf https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/utils/install.sh | bash -s -- -p /usr/local
</code></pre>
<p>或者（包含图像扩展）：</p>
<pre><code class="language-bash">curl -sSf https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/utils/install.sh | bash -s -- -e all -p /usr/local
</code></pre>
<h2 id="安装指定版本的-wasmedge"><a class="header" href="#安装指定版本的-wasmedge">安装指定版本的 WasmEdge</a></h2>
<p>你可以将 <code>-v</code> 参数传递给 <code>install.sh</code> 脚本来安装指定版本的 WasmEdge（包括预发行版本和历史版本）。例子如下：</p>
<pre><code class="language-bash">curl -sSf https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/utils/install.sh | bash -s -- -e all -v 0.9.1
</code></pre>
<p>如果你对 <code>master</code> 分支的 <code>HEAD</code> 中的最新的构建感兴趣（也就是 WasmEdge 的 nightly 版本），你可以直接从 Github Action 的 CI artifact 中下载已发布的包。<a href="https://github.com/WasmEdge/WasmEdge/actions/runs/1521549504#artifacts">例子请看这里。</a></p>
<h2 id="安装内容"><a class="header" href="#安装内容">安装内容</a></h2>
<p>安装完成后，你将会得到以下的目录和文件。这里我们假设你将 WasmEdge 安装到 <code>$HOME/.wasmedge</code> 目录中。如果你想进行系统范围的安装，你也可以将安装目录更改为 <code>/usr/local</code>。</p>
<ul>
<li><code>$HOME/.wasmedge/bin</code> 目录包含 WasmEdge Runtime CLI 可执行文件。你可以拷贝这些文件并放置到任意目录中。
<ul>
<li><code>wasmedge</code> 工具是标准的 WasmEdge 运行时。你可以在命令行中使用它：<code>wasmedge --dir .:. app.wasm</code>。</li>
<li><code>wasmedgec</code> 工具是 AOT 编译器，它能将 <code>wasm</code> 文件编译为原生 <code>so</code> 文件：<code>wasmedgec app.wasm app.so</code>。之后，<code>wasmedge</code> 就能执行 <code>so</code> 文件了：<code>wasmedge --dir .:. app.so</code>。</li>
<li><code>wasmedge-tensorflow</code> 和 <code>wasmedge-tensorflow-lite</code> 工具是支持 WasmEdge Tensorflow SDK 的 WasmEdge 运行时。</li>
</ul>
</li>
<li><code>$HOME/.wasmedge/lib</code> 目录包含 WasmEdge 的共享库和依赖库。从主程序中启动 WasmEdge 程序和功能会用到这些文件。</li>
<li><code>$HOME/.wasmedge/include</code> 目录包含了 WasmEdge 的头文件。这些文件用于 WasmEdge SDK 中。</li>
</ul>
<h2 id="卸载"><a class="header" href="#卸载">卸载</a></h2>
<p>要想卸载 WasmEdge，你可以执行以下的命令：</p>
<pre><code class="language-bash">bash &lt;(curl -sSf https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/utils/uninstall.sh)
</code></pre>
<p>如果 <code>wasmedge</code> 这个二进制文件不在 <code>PATH</code> 中，且 WasmEdge 不是安装在默认的<code>$HOME/.wasmedge</code> 目录，那么你必须在执行命令时附上安装路径。</p>
<pre><code class="language-bash">bash &lt;(curl -sSf https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/utils/uninstall.sh) -p /path/to/parent/folder
</code></pre>
<p>如果你希望以非交互的方式卸载 WasmEdge，你可以附上 <code>--quick</code> 或 <code>-q</code> 选项。</p>
<pre><code class="language-bash">bash &lt;(curl -sSf https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/utils/uninstall.sh) -q
</code></pre>
<blockquote>
<p>如果 <code>wasmedge</code> 二进制文件的父目录中包含 <code>.wasmedge</code>，那么该目录将会被一并删除。举例来说，该脚本将会完全删除默认的 <code>$HOME/.wasmedge</code> 目录。</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="使用-docker-进行-wasmedge-应用程序开发"><a class="header" href="#使用-docker-进行-wasmedge-应用程序开发">使用 Docker 进行 WasmEdge 应用程序开发</a></h1>
<p><code>appdev</code> Docker 镜像提供了一个完整的 WasmEdge 应用程序开发环境。要想使用该镜像，请执行以下操作。</p>
<h2 id="使用-x86_64-系统"><a class="header" href="#使用-x86_64-系统">使用 x86_64 系统</a></h2>
<pre><code class="language-bash">$ docker pull wasmedge/appdev_x86_64:0.9.0
$ docker run --rm -v $(pwd):/app -it wasmedge/appdev_x86_64:0.9.0
(docker) #
</code></pre>
<p>查看 <code>appdev</code> 的 <a href="https://github.com/WasmEdge/WasmEdge/blob/master/utils/docker/Dockerfile.appdev_x86_64">Dockerfile</a> 和 <a href="https://hub.docker.com/repository/docker/wasmedge/appdev_x86_64">Docker Hub 镜像</a>。</p>
<h2 id="使用-arm64-系统"><a class="header" href="#使用-arm64-系统">使用 arm64 系统</a></h2>
<pre><code class="language-bash">$ docker pull wasmedge/appdev_aarch64:0.9.0
$ docker run --rm -v $(pwd):/app -it wasmedge/appdev_aarch64:0.9.0
(docker) #
</code></pre>
<p>查看 <code>appdev</code> 的 <a href="https://github.com/WasmEdge/WasmEdge/blob/master/utils/docker/Dockerfile.appdev_aarch64">Dockerfile</a> 和 <a href="https://hub.docker.com/repository/docker/wasmedge/appdev_aarch64">Docker Hub 镜像</a>。</p>
<p>这个 <code>appdev</code> 镜像安装了以下组件：</p>
<ul>
<li>WasmEdge CLI 和共享库；</li>
<li>(仅限 x86_64 系统）包含 Tensorflow 扩展命令行和库的 WasmEdge；</li>
<li>Golang；</li>
<li>Rust；</li>
<li>包含 WasmEdge 插件的 Node.js；</li>
<li>在 <code>/root/examples/</code> 文件夹的一些示例。</li>
</ul>
<h2 id="一些示例"><a class="header" href="#一些示例">一些示例</a></h2>
<p>Hello World 示例。<a href="https://github.com/WasmEdge/WasmEdge/tree/master/tools/wasmedge/examples">查看更多。</a></p>
<pre><code class="language-bash">$ wasmedge hello.wasm world
hello
world
</code></pre>
<p>使用 AOT 来<strong>加快程序的运行速度</strong>。</p>
<pre><code class="language-bash">$ wasmedgec hello.wasm hello.wasm
$ wasmedge hello.wasm world
hello
world
</code></pre>
<p>以下是一些 JavaScript 示例。<a href="https://github.com/WasmEdge/WasmEdge/tree/master/tools/wasmedge/examples/js">查看更多。</a></p>
<pre><code class="language-bash">$ wasmedge --dir .:. qjs.wasm hello.js 1 2 3
Hello 1 2 3

$ wasmedge-tensorflow-lite --dir .:. qjs_tf.wasm tf_image_classify.js
label: Hot dog
confidence: 0.8941176470588236
</code></pre>
<h2 id="构建并发布-appdev-镜像"><a class="header" href="#构建并发布-appdev-镜像">构建并发布 <code>appdev</code> 镜像</a></h2>
<p>运行以下的命令来构建并发布 <code>appdev</code> 镜像：</p>
<h3 id="x86_64-系统"><a class="header" href="#x86_64-系统">x86_64 系统</a></h3>
<pre><code class="language-bash">docker build -t wasmedge/appdev_x86_64:0.9.0 -f Dockerfile.appdev_x86_64 ./
docker image push wasmedge/appdev_x86_64:0.9.0
</code></pre>
<h3 id="arm64--aarch64-系统"><a class="header" href="#arm64--aarch64-系统">ARM64 / aarch64 系统</a></h3>
<pre><code class="language-bash">docker build -t wasmedge/appdev_aarch64:0.9.0 -f Dockerfile.appdev_aarch64 ./
docker image push wasmedge/appdev_aarch64:0.9.0
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="wasmedge-命令行"><a class="header" href="#wasmedge-命令行">WasmEdge 命令行</a></h1>
<p>在<a href="start/install.html">安装 WasmEdge</a> 或启动 <a href="start/docker.html">WasmEdge appdev Docker 容器</a>后，我们可以通过多种方法运行已经编译好的 WebAssembly 程序。</p>
<h2 id="wasmedge"><a class="header" href="#wasmedge">wasmedge</a></h2>
<p><code>wasmedge</code> 二进制文件是一个用来运行 WebAssembly 程序应用的命令行工具（CLI）。</p>
<ul>
<li>假如 WebAssembly 程序包含一个 <code>main()</code> 函数，<code>wasmedge</code> 将在命令模式下将其作为独立程序执行。</li>
<li>假如 WebAssembly 程序包含一个或者多个公共函数，<code>wasmedge</code> 可以在 反应器模式下单独执行每个函数。</li>
</ul>
<h3 id="命令行选项"><a class="header" href="#命令行选项">命令行选项</a></h3>
<p><code>wasmedge</code> 的选项和标志如下所示：</p>
<ol>
<li>（可选）统计信息：
<ul>
<li>用 <code>--enable-time-measuring</code> 来展示执行时间；</li>
<li>用 <code>--enable-gas-measuring</code> 来展示 gas 的消耗量；</li>
<li>用 <code>--enable-instruction-count</code> 来展示执行的指令数量；</li>
<li>或者用 <code>--enable-all-statistics</code> 来启用所有的统计选项。</li>
</ul>
</li>
<li>（可选）资源限制：
<ul>
<li>用 <code>--gas-limit</code> 来限制执行所花费的 gas；</li>
<li>用 <code>--memory-page-limit</code> 来设置每一个内存实例的页限制（大小为 64 KiB）。</li>
</ul>
</li>
<li>(可选) 反应器模式：使用 <code>--reactor</code> 来启用反应器模式；在该模式下，<code>wasmedge</code> 将运行 WebAssembly 程序中指定的函数：
<ul>
<li>WasmEdge 将执行第一个参数（<code>ARG[0]</code>）所指定的函数名；</li>
<li>假如存在名为 <code>_initialize</code> 的导出函数，这个函数将最先以空参的方式执行。</li>
</ul>
</li>
<li>（可选）将目录绑定到 WASI 虚拟文件系统：
<ul>
<li>每一个目录都以 <code>--dir guest_path:host_path</code> 的方式指定。</li>
</ul>
</li>
<li>（可选）环境变量：
<ul>
<li>每一个变量都以 <code>--env NAME=VALUE</code> 的方式指定。</li>
</ul>
</li>
<li>Wasm 文件（<code>/path/to/wasm/file</code>）；</li>
<li>（可选）参数：
<ul>
<li>在反应器模式下，第一个参数将作为函数的名称，<code>ARG[0]</code> 后的其余参数将作为 <code>ARG[0]</code> 函数的参数；</li>
<li>在命令模式下，命令行参数将作为 <code>_start</code> 函数的参数；它们也被称为独立程序的命令行参数。</li>
</ul>
</li>
</ol>
<p>安装完毕后，你可以<a href="start/../index.html">查看并运行我们的示例</a>。</p>
<h2 id="wasmedgec"><a class="header" href="#wasmedgec">wasmedgec</a></h2>
<p><code>wasmedgec</code> 是一个将 WebAssembly 字节码编译成原生机器码的程序（即 AOT 编译器）。
编译好的机器码可以被<a href="start/universal.html">储存在原本的 <code>wasm</code> 文件中</a>，<code>wasmedge</code> 命令行将自动地选择可用的原生机器码。</p>
<p><code>wasmedgec</code> 的选项和标志如下所示：</p>
<ol>
<li>Wasm 输入文件（<code>/path/to/input/wasm/file</code>）；</li>
<li>输出文件的名称（<code>/path/to/output/file</code>）：
<ul>
<li>默认情况下，它将生成<a href="start/universal.html">通用 wasm 二进制格式</a>；</li>
<li>用户也可以通过指定 <code>.so</code>、<code>.dylib</code> 或者 <code>.dll</code> 扩展名来生成原生二进制文件。</li>
</ul>
</li>
</ol>
<pre><code class="language-bash"># 这很慢
wasmedge app.wasm

# AOT 编译
wasmedgec app.wasm app.wasm

# 现在就快多了
wasmedge app.wasm
</code></pre>
<p>在 Linux 系统上，它将会生成一个 <code>so</code> 共享库文件，然后由 <code>wasmedge</code> 运行时执行。</p>
<pre><code class="language-bash">wasmedgec app.wasm app.so
wasmedge app.so
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="通用-wasm-二进制格式"><a class="header" href="#通用-wasm-二进制格式">通用 wasm 二进制格式</a></h1>
<p>WasmEdge 可以将 AOT 编译的原生二进制包装到原始 wasm 文件中的自定义部分。我们将其称之为通用 wasm 二进制格式。</p>
<p>AOT 编译的 wasm 文件与任何 wasm 运行时兼容。然而，当 WasmEdge 运行时执行此 wasm 文件时，WasmEdge 将从自定义部分中提取原生二进制并执行它。</p>
<p>当然，用户仍然可以选择使用 <code>wasmedgec</code> AOT 编译器生成原生二进制文件。
WasmEdge 将以输出文件扩展名来确定生成的文件格式。举例来说，如果你将 <code>wasmedgec</code> 的输出文件扩展名设置为 <code>.so</code>，它将生成 Linux 共享库格式的原生二进制文件；否则，它将默认生成一个通用的 wasm 二进制文件。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="wasmedge-介绍"><a class="header" href="#wasmedge-介绍">WasmEdge 介绍</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="应用场景"><a class="header" href="#应用场景">应用场景</a></h1>
<p>WasmEdge 是由 CNCF 托管的云原生 WebAssembly runtime。它广泛应用于边缘计算、汽车、Jamstack、Serverless、SaaS、服务网格，乃至区块链应用。 WasmEdge 可以进行 AOT （提前编译）编译器优化，是当今市场上最快的 WebAssembly runtime 之一。</p>
<ul>
<li><a href="intro/use/runtime.html">云原生 runtime</a>
<ul>
<li>Dapr</li>
<li>Kubernetes</li>
</ul>
</li>
<li><a href="intro/use/js.html">JavaScript 或 DSL runtime</a>
<ul>
<li>JavaScript</li>
<li>用于图像识别的 DSL</li>
<li>用于聊天机器人的 DSL</li>
</ul>
</li>
<li><a href="intro/use/serverless.html">公有云中的 Serverless 函数即服务</a>
<ul>
<li>AWS Lambda</li>
<li>腾讯 Serverless 函数</li>
<li>Vercel Serverless 函数</li>
<li>Netlify Functions</li>
<li>Second State Functions</li>
</ul>
</li>
<li><a href="intro/use/edge.html">边缘计算</a>
<ul>
<li>YoMo Flow</li>
<li>seL4 micokernel and RTOS</li>
</ul>
</li>
<li><a href="intro/use/saas.html">用于 SaaS 的响应式函数</a>
<ul>
<li>Slack</li>
<li>飞书</li>
</ul>
</li>
</ul>
<p>如果关于 WasmEdge 有什么好主意，马上开 <a href="https://github.com/WasmEdge/WasmEdge/issues">一个 GitHub issue</a> 来一起讨论吧。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="云原生的-runtime"><a class="header" href="#云原生的-runtime">云原生的 runtime</a></h1>
<p>WasmEdge 可以通过其 <a href="intro/use/../../embed/c.html">C</a>, <a href="intro/use/../../embed/go.html">Go</a>, <a href="intro/use/../../embed/rust.html">Rust</a>, 和 <a href="intro/use/../../embed/node.html">JavaScript</a> 的 SDK 嵌入到云原生基础设施中。它也是一个符合 OCI 的 runtime ，可以由 <a href="https://www.secondstate.io/articles/manage-webassembly-apps-in-wasmedge-using-docker-tools/">CRI-O 和 Docker 工具直接管理</a> ，作为 Docker 的轻量级和高性能替代。</p>
<h2 id="dapr-分布式应用-runtime"><a class="header" href="#dapr-分布式应用-runtime">Dapr (分布式应用 Runtime)</a></h2>
<ul>
<li><a href="https://www.secondstate.io/articles/dapr-wasmedge-webassembly/">教程</a></li>
<li><a href="https://github.com/second-state/dapr-wasm">代码教程</a></li>
</ul>
<h2 id="service-mesh-开发进行中"><a class="header" href="#service-mesh-开发进行中">Service mesh (开发进行中)</a></h2>
<ul>
<li>Linkerd</li>
<li>MOSN</li>
<li>Envoy</li>
</ul>
<h2 id="编排和管理"><a class="header" href="#编排和管理">编排和管理</a></h2>
<ul>
<li><a href="https://www.secondstate.io/articles/manage-webassembly-apps-in-wasmedge-using-docker-tools/">Kubernetes</a></li>
<li>KubeEdge</li>
<li>SuperEdge</li>
<li>OpenYurt</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="javascript-或-dsl-runtime"><a class="header" href="#javascript-或-dsl-runtime">JavaScript 或 DSL runtime</a></h1>
<p>为了让 WebAssembly 被开发者广泛采用作为 runtime，它必须支持像 JavaScript 这样的“简单”语言。或者，更棒的是，通过其高级编译器工具链， WasmEdge 可以支持高性能 DSL（领域特定语言），这是专为特定任务设计的低代码解决方案。</p>
<h2 id="javascript"><a class="header" href="#javascript">JavaScript</a></h2>
<p>WasmEdge 可以通过嵌入 JS 执行引擎或解释器来充当云原生 JavaScript runtime 。它比在 Docker 中运行 JS 引擎更快更轻。 WasmEdge 支持 JS API 访问原生扩展库，例如网络 socket 、 tensorflow 和用户定义的共享库。它还允许将 JS 嵌入其他高性能语言（例如 Rust ）或使用 Rust/C 来实现 JS 函数。</p>
<ul>
<li>教程
<ul>
<li><a href="https://www.secondstate.io/articles/run-javascript-in-webassembly-with-wasmedge/">运行 JavaScript</a></li>
<li><a href="https://www.secondstate.io/articles/embed-javascript-in-rust/">在 Rust 中嵌入 JavaScript</a></li>
<li><a href="https://www.secondstate.io/articles/embed-rust-in-javascript/">用 Rust 函数创建 JavaScript API</a></li>
<li><a href="https://www.secondstate.io/articles/call-native-functions-from-javascript/">从 JavaScript调用 C 原生共享库函数</a></li>
</ul>
</li>
<li><a href="https://github.com/WasmEdge/WasmEdge/blob/master/tools/wasmedge/examples/js/README.md">例子</a></li>
<li><a href="https://github.com/second-state/wasmedge-quickjs">WasmEdge的内嵌 QuickJS 引擎</a></li>
</ul>
<h2 id="用于图片识别的-dsl"><a class="header" href="#用于图片识别的-dsl">用于图片识别的 DSL</a></h2>
<p>图像识别 DSL 是一种 YAML 格式，允许用户指定 tensorflow 模型及其参数。 WasmEdge 将图像作为 DSL 的输入并输出检测到的项目名称/标签。</p>
<ul>
<li>示例: <a href="https://github.com/second-state/wasm-learning/blob/master/cli/classify_yml/config/food.yml">运行 YMAL 以识别图片中的食品</a></li>
</ul>
<h2 id="用于聊天机器人的-dsl"><a class="header" href="#用于聊天机器人的-dsl">用于聊天机器人的 DSL</a></h2>
<p>聊天机器人 DSL 函数接受输入字符串并回复字符串进行响应。 DSL 指定了聊天机器人的内部状态转换，以及用于语言理解的 AI 模型。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="公有云中的-serverless-函数即服务"><a class="header" href="#公有云中的-serverless-函数即服务">公有云中的 Serverless 函数即服务</a></h1>
<p>WasmEdge 与现有的 Serverless 或 Jamstack 平台配合使用，为函数提供高性能、可移植和安全的 runtime。即在这些平台上的 Docker 或 microVM 中运行，也能提供显着的好处。</p>
<h2 id="aws-lambda"><a class="header" href="#aws-lambda">AWS Lambda</a></h2>
<ul>
<li><a href="https://www.cncf.io/blog/2021/08/25/webassembly-serverless-functions-in-aws-lambda/">教程</a></li>
<li><a href="https://github.com/second-state/aws-lambda-wasm-runtime">代码模板</a></li>
</ul>
<h2 id="腾讯-serverless-函数"><a class="header" href="#腾讯-serverless-函数">腾讯 Serverless 函数</a></h2>
<ul>
<li><a href="https://my.oschina.net/u/4532842/blog/5172639">中文教程</a></li>
<li><a href="https://github.com/second-state/tencent-scf-wasm-runtime">代码模板</a></li>
</ul>
<h2 id="vercel-serverless-函数"><a class="header" href="#vercel-serverless-函数">Vercel Serverless 函数</a></h2>
<ul>
<li><a href="https://www.secondstate.io/articles/vercel-wasmedge-webassembly-rust/">教程</a></li>
<li><a href="https://github.com/second-state/vercel-wasm-runtime">代码模版</a></li>
</ul>
<h2 id="netlify-functions"><a class="header" href="#netlify-functions">Netlify Functions</a></h2>
<ul>
<li><a href="https://www.secondstate.io/articles/netlify-wasmedge-webassembly-rust-serverless/">教程</a></li>
<li><a href="https://github.com/second-state/netlify-wasm-runtime">代码模版</a></li>
</ul>
<h2 id="second-state-functions"><a class="header" href="#second-state-functions">Second State Functions</a></h2>
<ul>
<li><a href="https://www.secondstate.io/faas/">教程</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="边缘计算"><a class="header" href="#边缘计算">边缘计算</a></h1>
<p>WasmEdge 非常适合在任务关键的边缘设备或边缘网络上运行。</p>
<h2 id="yomo-flow"><a class="header" href="#yomo-flow">YoMo Flow</a></h2>
<p>YoMo 是一种用于远边缘（far edge）网络的高性能数据流框架。 WasmEdge 集成到 YoMo 中以运行用户定义的工作负载，例如在工厂装配线上进行的图像识别。</p>
<ul>
<li><a href="https://www.secondstate.io/articles/yomo-wasmedge-real-time-data-streams/">教程</a></li>
<li><a href="https://github.com/yomorun/yomo-wasmedge-tensorflow">代码模板</a></li>
</ul>
<h2 id="sel4-微内核操作系统"><a class="header" href="#sel4-微内核操作系统">seL4 微内核操作系统</a></h2>
<p>seL4 是一个高度安全的实时操作系统。 WasmEdge 是唯一可以在 seL4 上运行的 WebAssembly runtime，它以本机速度运行。我们还提供了一个管理工具来支持 wasm 模块的 OTA 部署。</p>
<ul>
<li><a href="https://github.com/second-state/wasmedge-seL4">Demo</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="saas-里的嵌入式函数"><a class="header" href="#saas-里的嵌入式函数">SaaS 里的嵌入式函数</a></h1>
<p>WasmEdge 可以使用 Serverless 函数而不是传统的网络 API 来支持定制的 SaaS 扩展或应用程序。这极大地提高了 SaaS 用户和开发者的生产力。</p>
<h2 id="slack"><a class="header" href="#slack">Slack</a></h2>
<ul>
<li><a href="http://reactor.secondstate.info/en/docs/user_guideline.html">为 Slack 创建 serverless 聊天机器人</a></li>
</ul>
<h2 id="飞书"><a class="header" href="#飞书">飞书</a></h2>
<p>飞书为字节跳动旗下的聊天软件。</p>
<ul>
<li><a href="http://reactor.secondstate.info/zh/docs/user_guideline.html">为飞书创建 serverless 聊天机器人</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="wasmedge-的优势与特点"><a class="header" href="#wasmedge-的优势与特点">WasmEdge 的优势与特点</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="webassembly-的标准扩展"><a class="header" href="#webassembly-的标准扩展">WebAssembly 的标准扩展</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="wasmedge-特有的扩展"><a class="header" href="#wasmedge-特有的扩展">WasmEdge 特有的扩展</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="wasmedge-特有的集成"><a class="header" href="#wasmedge-特有的集成">WasmEdge 特有的集成</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="faq"><a class="header" href="#faq">FAQ</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="开发-wasmedge-应用"><a class="header" href="#开发-wasmedge-应用">开发 WasmEdge 应用</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rust"><a class="header" href="#rust">Rust</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="使用操作系统服务"><a class="header" href="#使用操作系统服务">使用操作系统服务</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tensorflow"><a class="header" href="#tensorflow">Tensorflow</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="网络"><a class="header" href="#网络">网络</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="使用命令行程序"><a class="header" href="#使用命令行程序">使用命令行程序</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rustwasmc"><a class="header" href="#rustwasmc">rustwasmc</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="javascript-1"><a class="header" href="#javascript-1">JavaScript</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="快速开始-1"><a class="header" href="#快速开始-1">快速开始</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="网络-1"><a class="header" href="#网络-1">网络</a></h1>
<p>QuickJS WasmEdge Runtime 支持 WasmEdge 的<a href="https://github.com/second-state/wasmedge_wasi_socket">网络 sockets 拓展</a>， 所以 JavaScript 程序也可以在网络上建立 HTTP 连接。此文将向你展示相关的 <a href="https://github.com/second-state/wasmedge-quickjs/blob/main/example_js/wasi_http_client.js">HTTP 客户端</a>和 <a href="https://github.com/second-state/wasmedge-quickjs/blob/main/example_js/wasi_http_echo.js">HTTP 服务端</a>例子.</p>
<blockquote>
<p>WasmEdge 的网络 API 是非阻塞的，所以能够开发出强异步 I/O 交互的应用。当网络请求 handler 正在创建一个对外的请求并等待服务应答的时候，应用仍然可以处理另外一个进来的请求。这让单线程应用可以并发处理多个请求。</p>
</blockquote>
<h2 id="javascript-客户端网络通讯例子"><a class="header" href="#javascript-客户端网络通讯例子">JavaScript 客户端网络通讯例子</a></h2>
<p>以下是一个使用 JavaScript 编写的异步客户端的例子。你可以在 <a href="https://github.com/second-state/wasmedge-quickjs/blob/main/example_js/wasi_http_client.js">example_js/wasi_http_client.js</a> 中找到源码。以下的代码会向你展示如何发送一个异步 HTTP GET 请求。</p>
<pre><code class="language-javascript">async function get_test() {
  try {
    let ss = await net.connect('152.136.235.225:80');
    let req = new http.WasiRequest();
    req.headers = { 'Host': '152.136.235.225' };
    req.uri = '/get?a=123';
    req.method = 'GET';
    ss.write(req.encode());
    print('wait get');
    await handle_response(ss);
    print('get end');

  } catch (e) {
    print('catch:', e);
  }
}
</code></pre>
<p>以上代码可以在等待服务端应答的同时处理其他任务。当服务端返回数据后，<code>handle_response()</code> 会被异步调用，处理好数据后就会将内容打印出来。</p>
<pre><code class="language-javascript">async function handle_response(s) {
  let buf = new http.Buffer();
  let resp = undefined;
  while (true) {
    buf.append(await s.read());
    if (resp == undefined) {
      resp = buf.parseResponse();
    }
    if (resp instanceof http.WasiResponse) {
      let resp_length = resp.bodyLength;
      if (typeof (resp_length) === &quot;number&quot;) {
        if (buf.length &gt;= resp.bodyLength) {
          print('resp.body');
          print(newStringFromUTF8(buf.buffer));
          break;
        }
      } else {
        throw new Error('no support');
      }
    }
  }
}
</code></pre>
<p>使用以下 CLI 命令，就可以在 WasmEdge runtime 中运行以上的 JavaScript 代码。</p>
<pre><code class="language-bash">cd example_js
wasmedge --dir .:. ../target/wasm32-wasi/release/wasmedge_quickjs.wasm wasi_http_client.js
</code></pre>
<p>将会有如下内容被打印出来。</p>
<pre><code class="language-json">{
  &quot;args&quot;: {
    &quot;a&quot;: &quot;123&quot;
  }, 
  &quot;data&quot;: &quot;hello&quot;, 
  &quot;files&quot;: {}, 
  &quot;form&quot;: {}, 
  &quot;headers&quot;: {
    &quot;Content-Length&quot;: &quot;5&quot;, 
    &quot;Host&quot;: &quot;152.136.235.225&quot;
  }, 
  &quot;json&quot;: null, 
  &quot;origin&quot;: &quot;20.124.39.106&quot;, 
  &quot;url&quot;: &quot;http://152.136.235.225/post?a=123&quot;
}
</code></pre>
<p>以上应用例子发出了两个 HTTP 请求，一个是 <code>GET</code> 请求另一个是 <code>POST</code> 请求。该应用会异步等待这两个请求的应答数据，并且哪一个先从服务端返回就先会处理哪个。从日志中你可以看到这两个请求的 handlers 是交错执行的。</p>
<h2 id="javascript-网络服务例子"><a class="header" href="#javascript-网络服务例子">JavaScript 网络服务例子</a></h2>
<p>以下的例子是使用 JavaScript 运行了一个监听 8000 端口的 TCP 服务器。接收到的网络请求都会被异步处理。你可以在 <a href="https://github.com/second-state/wasmedge-quickjs/blob/main/example_js/wasi_net_echo.js">example_js/wasi_net_echo.js</a> 中找到源码。</p>
<pre><code class="language-javascript">import * as net from 'wasi_net';

async function handle_client(cs) {
  while (true) {
    try {
      let d = await cs.read();
      if (d.byteLength &lt;= 0) {
        break;
      }
      let s = newStringFromUTF8(d);
      cs.write('echo:' + s);
    } catch (e) {
      print(e);
    }
  }
}

async function server_start() {
  let s = new net.WasiTcpServer(8000);
  for (var i = 0; i &lt; 100; i++) {
    let cs = await s.accept();
    handle_client(cs);
  }
}

server_start();
</code></pre>
<p>调用 <code>server_start()</code> 方法会在 8000 端口启动一个监听服务。当一个请求进入，会异步传给 <code>handle_client()</code> function 函数处理。这意味着当应用返回应答数据后，它又可以处理下一个进来的请求了。</p>
<p>使用以下 CLI 命令，就可以在 WasmEdge runtime 中运行这段 JavaScript 代码。因为它将作为一个服务运行，你最好是以后台应用的形式启动。</p>
<pre><code class="language-bash">cd example_js
nohup wasmedge --dir .:. ../target/wasm32-wasi/release/wasmedge_quickjs.wasm wasi_net_echo.js &amp;
</code></pre>
<p>然后你就可以向它发出网络请求，观察运行效果。</p>
<pre><code class="language-bash">$ curl -d &quot;WasmEdge&quot; -X POST http://localhost:8000
echo:WasmEdge
</code></pre>
<p>WasmEdge 的 <code>wasi_net</code> 包为 JavaScript 应用提供了一种自适应的动态网络栈。在很多高级用法中，我们基于这个包，设计了很多抽象良好的 API。在下一章节，我们会带着具体的常见应用，向你展示如何处理 HTTP 请求。在 <a href="dev/js/ssr.html">React 服务器渲染文章</a>中，我们还将会讨论一下如何基于这种异步网络的 API 来创建一个 React 服务器渲染功能。</p>
<h2 id="javascript-http-服务器例子"><a class="header" href="#javascript-http-服务器例子">JavaScript HTTP 服务器例子</a></h2>
<p>假如你已经知道服务器的请问和应答都是基于 HTTP 协议的，这里有一些增强方法可以帮到你更好地处理这些请求。你可以在 <a href="https://github.com/second-state/wasmedge-quickjs/blob/main/example_js/wasi_http_echo.js">example_js/wasi_http_echo.js</a> 中找到源码。</p>
<pre><code class="language-javascript">import * as http from 'wasi_http';
import * as net from 'wasi_net';

async function handle_client(cs, handler_req) {
  let buffer = new http.Buffer();

  while (true) {
    try {
      let d = await cs.read();
      if (d.byteLength &lt;= 0) {
        return;
      }
      buffer.append(d);
      let req = buffer.parseRequest();
      if (req instanceof http.WasiRequest) {
        handler_req(cs, req);
        break;
      }
    } catch (e) {
      print(e);
    }
  }
}

function handler_req(cs, req) {
  print(&quot;version=&quot;, req.version);
  print(&quot;uri=&quot;, req.uri);
  print(&quot;method=&quot;, req.method);
  print(&quot;headers=&quot;, Object.keys(req.headers));
  print(&quot;body=&quot;, newStringFromUTF8(req.body));

  let resp = new http.WasiResponse();
  let body = 'echo:' + newStringFromUTF8(req.body);
  let r = resp.encode(body);
  cs.write(r);
}

async function server_start() {
  try {
    let s = new net.WasiTcpServer(8000);
    for (var i = 0; i &lt; 100; i++) {
      let cs = await s.accept();
      try {
        handle_client(cs, handler_req);
      } catch (e) {
        print(e);
      }
    }
  } catch (e) {
    print(e);
  }
}

server_start();
</code></pre>
<p><code>server_start()</code> 方法会启动一个监听 8000 端口的服务。当请求进来，会被传给 <code>handle_client()</code> 方法来处理。当请求是合法的 HTTP 请求，对应的 handler 方法会调用 <code>handle_req()</code> 来解析对应的字段，组装新的 HTTP 应答，然后异步把应答数据发送回去。这意味着当应用发送完数据，又能继续处理下一个进来的请求了。</p>
<p>使用以下 CLI 命令，就可以在 WasmEdge runtime 中运行这段 JavaScript 代码。因为它将作为一个服务运行，你最好是以后台应用的形式运行。</p>
<pre><code class="language-bash">cd example_js
nohup wasmedge --dir .:. ../target/wasm32-wasi/release/wasmedge_quickjs.wasm wasi_http_echo.js &amp;
</code></pre>
<p>然后你就可以向它发出网络请求，观察运行效果。</p>
<pre><code class="language-bash">$ curl -d &quot;WasmEdge&quot; -X POST http://localhost:8000
echo:WasmEdge
</code></pre>
<p>在异步 HTTP 网络编程中，开发者可以安全并高效地在 WasmEdge 中使用 JavaScript 创建强交互的应用，例如数据库驱动的微服务。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="fetch-api"><a class="header" href="#fetch-api">Fetch API</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tensorflow-1"><a class="header" href="#tensorflow-1">TensorFlow</a></h1>
<p>解释器支持 WasmEdge TensorFlow lite 的推断扩展，从而使你的 JavaScript 能够运行 ImageNet 模型来进行图像分类。本文会向你展示如何在你的 javascript 程序中使用基于 WasmEdge 的 TensorFlow Rust SDK。</p>
<p>下面是一个 JavaScript 的示例。全部代码可参考这里 <a href="https://github.com/second-state/wasmedge-quickjs/tree/main/example_js/tensorflow_lite_demo">example_js/tensorflow_lite_demo/</a></p>
<pre><code class="language-javascript">import {Image} from 'image';
import * as std from 'std';
import {TensorflowLiteSession} from 'tensorflow_lite';

let img = new Image('food.jpg');
let img_rgb = img.to_rgb().resize(192, 192);
let rgb_pix = img_rgb.pixels();

let session = new TensorflowLiteSession(
    'lite-model_aiy_vision_classifier_food_V1_1.tflite');
session.add_input('input', rgb_pix);
session.run();
let output = session.get_output('MobilenetV1/Predictions/Softmax');
let output_view = new Uint8Array(output);
let max = 0;
let max_idx = 0;
for (var i in output_view) {
  let v = output_view[i];
  if (v &gt; max) {
    max = v;
    max_idx = i;
  }
}
let label_file = std.open('aiy_food_V1_labelmap.txt', 'r');
let label = '';
for (var i = 0; i &lt;= max_idx; i++) {
  label = label_file.getline();
}
label_file.close();

print('label:');
print(label);
print('confidence:');
print(max / 255);
</code></pre>
<p>为了在 WasmEdge runtime 中运行 JavaScript，你可以在 CLI 中执行如下操作，这样就可以重新构建一个包含 TensorFlow 的 QuickJS 引擎，然后就可以在 JavaScript 应用中调用 TensorFlow API 了。</p>
<pre><code class="language-bash">$ cargo build --target wasm32-wasi --release --features=tensorflow
... ...
$ cd example_js/tensorflow_lite_demo
$ wasmedge-tensorflow-lite --dir .:. ../../target/wasm32-wasi/release/wasmedge_quickjs.wasm main.js
label:
Hot dog
confidence:
0.8941176470588236
</code></pre>
<blockquote>
<p>注意: 命令行中的 <code>--dir .:.</code> 是为了给 wasmedge 开启本地文件读取权限， 以便正常读取到 <code>main.js</code> 文件.</p>
</blockquote>
<h2 id="注意"><a class="header" href="#注意">注意</a></h2>
<ul>
<li>编译器标志 <code>--features=tensorflow</code> 构建了一个包含 WasmEdge TensorFlow 扩展的 QuickJS 引擎。</li>
<li>程序 <code>wasmedge-tensorflow-lite</code> 是 WasmEdge 包的一部分。它是内含有 Tensorflow 扩展的 WasmEdge runtime。</li>
</ul>
<p>你现在应该可以看到食物的名字了，它被 TensorFlow lite ImageNet 模型识别出来了。</p>
<h2 id="使其更快"><a class="header" href="#使其更快">使其更快</a></h2>
<p>以上 Tensorflow 推断示例执行一次需要耗时 1-2 秒. 在 web 应用场景中虽然可以接受，但是仍然有改进空间。回想一下，WasmEdge 是如今最快的 WebAssembly runtime，这是由于它的提前编译（AOT, Ahead-of-time compiler）优化。WasmEdge 提供了一个 <code>wasmedgec</code> 实用程序去编译和添加原生机器码段，并放到 <code>wasm</code> 文件里，从而达到更快的性能。</p>
<p>以下示例采用了 <code>wasmedge</code> 和 <code>wasmedgec</code> 的扩展版本以支持 WasmEdge Tensorflow 扩展。</p>
<pre><code class="language-bash">$ cd example_js/tensorflow_lite_demo
$ wasmedgec-tensorflow ../../target/wasm32-wasi/release/wasmedge_quickjs.wasm wasmedge_quickjs.wasm
$ wasmedge-tensorflow-lite --dir .:. wasmedge_quickjs.wasm main.js
label:
Hot dog
confidence:
0.8941176470588236
</code></pre>
<p>你可以看到，图像识别任务在 0.1 秒内就完成了。它的性能至少提高了 10 倍。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="react-ssr"><a class="header" href="#react-ssr">React SSR</a></h1>
<p><a href="https://medium.com/jspoint/a-beginners-guide-to-react-server-side-rendering-ssr-bf3853841d55">React 服务端渲染（SSR）</a> 是 JavaScript 在 BFF（为前端提供服务的后端）函数中一种常见的使用场景。
和在浏览器中渲染 HTML DOM 元素的方式不同，这种技术使用 React 框架在服务端就生成了 HTML 元素，以此来加快应用的加载速度。
在 <a href="https://jamstack.org/">Jamstack</a> 应用中，这是使用 serverless 函数时一种较理想的方式。</p>
<p>在这篇文章中，我们将向你展示如何使用 WasmEdge 的 QuickJS 运行时来实现 React SSR 的能力。与 Docker + Linux + nodejs + v8 的方案相比，WasmEdge 要轻量得多（仅 1% 的占用），也更安全，能够提供更好的资源隔离和管理机制，并有着和非 JIT（同时是安全的）近似的性能。</p>
<p>本文将包含对静态渲染和流式渲染两种渲染方式的介绍。静态渲染相对容易理解和实现。而流式渲染则可以提供更好的用户体验，因为用户在浏览器前等待结果时，可以优先看到生成的部分内容。</p>
<h2 id="静态渲染"><a class="header" href="#静态渲染">静态渲染</a></h2>
<p>本示例的源代码可以在 GitHub 仓库的 <a href="https://github.com/second-state/wasmedge-quickjs/tree/main/example_js/react_ssr">example_js/react_ssr</a> 文件夹中找到。它展示了运行于 WasmEdge 的 JavaScript 应用程序，是如何编排 HTML 模板并将其渲染成 HTML 字符串的。</p>
<p>文件 <a href="https://github.com/second-state/wasmedge-quickjs/blob/main/example_js/react_ssr/component/Home.jsx">component/Home.jsx</a> 里是 React 的主页模板。</p>
<pre><code class="language-javascript">import React from 'react';
import Page from './Page.jsx';
class Home extends React.Component {
  render() {
    const { dataList = [] } = this.props;
    return (
      &lt;div&gt;
        &lt;div&gt;This is home&lt;/div&gt;
        &lt;Page&gt;&lt;/Page&gt;
      &lt;/div&gt;
    );
  }
};

export default Home;
</code></pre>
<p><code>Home.jsx</code> 中会包含 <a href="https://github.com/second-state/wasmedge-quickjs/blob/main/example_js/react_ssr/component/Page.jsx">Page.jsx</a> 提供的模板，作为页面的一部分。</p>
<pre><code class="language-javascript">import React from 'react';

class Page extends React.Component {
  render() {
    const { dataList = [] } = this.props;
    return (
      &lt;div&gt;
        &lt;div&gt;This is page&lt;/div&gt;
      &lt;/div&gt;
    );
  }
};

export default Page;
</code></pre>
<p>文件 <a href="https://github.com/second-state/wasmedge-quickjs/blob/main/example_js/react_ssr/main.js">main.js</a> 会调用 React 将模板渲染成 HTML。</p>
<pre><code class="language-javascript">import React from 'react';
import {renderToString} from 'react-dom/server';

import Home from './component/Home.jsx';

const content = renderToString(React.createElement(Home));
console.log(content);
</code></pre>
<p>目录中的 <a href="https://github.com/second-state/wasmedge-quickjs/blob/main/example_js/react_ssr/rollup.config.js">rollup.config.js</a> 文件和 <a href="https://github.com/second-state/wasmedge-quickjs/blob/main/example_js/react_ssr/package.json">package.json</a> 文件用于把 React SSR 的所有依赖和组件打包成一个 WasmEdge 可用的 JavaScript 文件。你可以使用 <code>npm</code> 命令来进行构建，构建产物会输出到 <code>dist/main.js</code> 文件里。</p>
<pre><code class="language-bash">npm install
npm run build
</code></pre>
<p>要运行这个例子，请在命令行中执行以下命令。你会看到，所有的模板成功合成了一个 HTML 字符串。</p>
<pre><code class="language-bash">$ cd example_js/react_ssr
$ wasmedge --dir .:. ../../target/wasm32-wasi/release/wasmedge_quickjs.wasm dist/main.js
&lt;div data-reactroot=&quot;&quot;&gt;&lt;div&gt;This is home&lt;/div&gt;&lt;div&gt;&lt;div&gt;This is page&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;
</code></pre>
<blockquote>
<p>注意： 命令行里的 <code>--dir .:.</code> 会给 WasmEdge 读取本地文件系统下目录的权限，以此读取 <code>dist/main.js</code> 文件。</p>
</blockquote>
<h2 id="流式渲染"><a class="header" href="#流式渲染">流式渲染</a></h2>
<p>本示例的源代码可以在 GitHub 仓库的 <a href="https://github.com/second-state/wasmedge-quickjs/tree/main/example_js/react_ssr_stream">example_js/react_ssr_stream</a> 文件夹中找到。它展示了运行于 WasmEdge 的 JavaScript 应用程序，是如何流式地把 HTML 模板渲染成 HTML 字符串的。</p>
<p>文件 <a href="https://github.com/second-state/wasmedge-quickjs/blob/main/example_js/react_ssr_stream/component/LazyHome.jsx">component/LazyHome.jsx</a> 是 React 的主页模板。当外层的 HTML 渲染好并返回给用户 2s 之后，它才会开始“懒”加载内层的页面模板。</p>
<pre><code class="language-javascript">import React, { Suspense } from 'react';

async function sleep(ms) {
  return new Promise((r, _) =&gt; {
    setTimeout(() =&gt; r(), ms)
  });
}

async function loadLazyPage() {
  await sleep(2000);
  return await import('./LazyPage.jsx');
}

class LazyHome extends React.Component {
  render() {
    let LazyPage1 = React.lazy(() =&gt; loadLazyPage());
    return (
      &lt;html lang=&quot;en&quot;&gt;
        &lt;head&gt;
          &lt;meta charSet=&quot;utf-8&quot; /&gt;
          &lt;title&gt;Title&lt;/title&gt;
        &lt;/head&gt;
        &lt;body&gt;
          &lt;div&gt;
            &lt;div&gt; This is LazyHome &lt;/div&gt;
            &lt;Suspense fallback={&lt;div&gt; loading... &lt;/div&gt;}&gt;
              &lt;LazyPage1 /&gt;
            &lt;/Suspense&gt;
          &lt;/div&gt;
        &lt;/body&gt;
      &lt;/html&gt;
    );
  }
}

export default LazyHome;
</code></pre>
<p><a href="https://github.com/second-state/wasmedge-quickjs/blob/main/example_js/react_ssr_stream/component/LazyPage.jsx">LazyPage.jsx</a> 里就是内层的模板。只有在外层页面返回给用户 2s 之后，它才会被渲染。</p>
<pre><code class="language-javascript">import React from 'react';

class LazyPage extends React.Component {
  render() {
    return (
      &lt;div&gt;
        &lt;div&gt;
          This is lazy page
        &lt;/div&gt;
      &lt;/div&gt;
    );
  }
}

export default LazyPage;
</code></pre>
<p><a href="https://github.com/second-state/wasmedge-quickjs/blob/main/example_js/react_ssr_stream/main.mjs">main.mjs</a> 文件会启动一个异步的 HTTP 服务器，然后把 HTML 页面渲染成多段放入响应。当一个 HTTP 请求进来的时候，<code>handle_client()</code> 函数就会被调用来渲染 HTML，并以流的形式返回结果。</p>
<pre><code class="language-javascript">import * as React from 'react';
import { renderToPipeableStream } from 'react-dom/server';
import * as http from 'wasi_http';
import * as net from 'wasi_net';

import LazyHome from './component/LazyHome.jsx';

async function handle_client(s) {
  let resp = new http.WasiResponse();
  resp.headers = {
    &quot;Content-Type&quot;: &quot;text/html; charset=utf-8&quot;
  }
  renderToPipeableStream(&lt;LazyHome /&gt;).pipe(resp.chunk(s));
}

async function server_start() {
  print('listen 8001...');
  let s = new net.WasiTcpServer(8001);
  for (var i = 0; i &lt; 100; i++) {
    let cs = await s.accept();
    handle_client(cs);
  }
}

server_start();
</code></pre>
<p>目录中的 <a href="https://github.com/second-state/wasmedge-quickjs/blob/main/example_js/react_ssr_stream/rollup.config.js">rollup.config.js</a> 文件和 <a href="https://github.com/second-state/wasmedge-quickjs/blob/main/example_js/react_ssr_stream/package.json">package.json</a> 文件用于把 React SSR 的所有依赖和组件打包成一个 WasmEdge 可用的 JavaScript 文件。你可以使用 <code>npm</code> 命令来进行构建，构建产物会输出到 <code>dist/main.js</code> 文件里。</p>
<pre><code class="language-bash">npm install
npm run build
</code></pre>
<p>要运行这个例子，请在命令行上执行以下命令来启动服务器。</p>
<pre><code class="language-bash">cd example_js/react_ssr_stream
nohup wasmedge --dir .:. ../../target/wasm32-wasi/release/wasmedge_quickjs.wasm dist/main.mjs &amp;
</code></pre>
<p>然后通过 <code>curl</code> 或浏览器发送一个 HTTP 请求。</p>
<pre><code class="language-bash">curl http://localhost:8001
</code></pre>
<p>结果如下所示。该服务首先返回一个 HTML 页面，里面包含一个空的内层部分（即 <code>loading</code> 部分）。然后在 2s 后返回内层部分的 HTML 内容，以及将它显示出来的 JavaScript 代码。</p>
<pre><code class="language-bash">  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current
                                 Dload  Upload   Total   Spent    Left  Speed

  0     0    0     0    0     0      0      0 --:--:-- --:--:-- --:--:--     0
100   211    0   211    0     0   1029      0 --:--:-- --:--:-- --:--:--  1024
100   275    0   275    0     0    221      0 --:--:--  0:00:01 --:--:--   220
100   547    0   547    0     0    245      0 --:--:--  0:00:02 --:--:--   245
100  1020    0  1020    0     0    413      0 --:--:--  0:00:02 --:--:--   413

&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;&lt;meta charSet=&quot;utf-8&quot;/&gt;&lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div&gt;&lt;div&gt; This is LazyHome &lt;/div&gt;&lt;!--$?--&gt;&lt;template id=&quot;B:0&quot;&gt;&lt;/template&gt;&lt;div&gt; loading... &lt;/div&gt;&lt;!--/$--&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;&lt;div hidden id=&quot;S:0&quot;&gt;&lt;template id=&quot;P:1&quot;&gt;&lt;/template&gt;&lt;/div&gt;&lt;div hidden id=&quot;S:1&quot;&gt;&lt;div&gt;&lt;div&gt;This is lazy page&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;script&gt;function $RS(a,b){a=document.getElementById(a);b=document.getElementById(b);for(a.parentNode.removeChild(a);a.firstChild;)b.parentNode.insertBefore(a.firstChild,b);b.parentNode.removeChild(b)};$RS(&quot;S:1&quot;,&quot;P:1&quot;)&lt;/script&gt;&lt;script&gt;function $RC(a,b){a=document.getElementById(a);b=document.getElementById(b);b.parentNode.removeChild(b);if(a){a=a.previousSibling;var f=a.parentNode,c=a.nextSibling,e=0;do{if(c&amp;&amp;8===c.nodeType){var d=c.data;if(&quot;/$&quot;===d)if(0===e)break;else e--;else&quot;$&quot;!==d&amp;&amp;&quot;$?&quot;!==d&amp;&amp;&quot;$!&quot;!==d||e++}d=c.nextSibling;f.removeChild(c);c=d}while(c);for(;b.firstChild;)f.insertBefore(b.firstChild,c);a.data=&quot;$&quot;;a._reactRetry&amp;&amp;a._reactRetry()}};$RC(&quot;B:0&quot;,&quot;S:0&quot;)&lt;/script&gt;
</code></pre>
<p>流式 SSR 的示例充分利用了 WasmEdge 独特的处理异步网络的能力以及对 ES6 module 的支持（rollup 打包的 JS 文件中包含了 ES6 的模块）。你可以在本书中阅读更多有关 <a href="dev/js/networking.html">异步网络</a> 和 <a href="dev/js/es6.html">ES6</a> 的知识。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="es6-模块"><a class="header" href="#es6-模块">ES6 模块</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="nodejs--npm-模块"><a class="header" href="#nodejs--npm-模块">NodeJS &amp; NPM 模块</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="用-rust-实现-js-api"><a class="header" href="#用-rust-实现-js-api">用 Rust 实现 JS API</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="python"><a class="header" href="#python">Python</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="go"><a class="header" href="#go">Go</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="swift"><a class="header" href="#swift">Swift</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="assemblyscript"><a class="header" href="#assemblyscript">AssemblyScript</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="kotlin"><a class="header" href="#kotlin">Kotlin</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="grain"><a class="header" href="#grain">Grain</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="嵌入-wasmedge-函数"><a class="header" href="#嵌入-wasmedge-函数">嵌入 WasmEdge 函数</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="wasmedge-c-sdk"><a class="header" href="#wasmedge-c-sdk">WasmEdge C SDK</a></h1>
<p>文档 <a href="https://github.com/WasmEdge/WasmEdge/blob/master/include/api/wasmedge/wasmedge.h">WasmEdge C API</a> 里提供了访问 WasmEdge 运行时的接口。以下内容是关于如何使用 WasmEdge C API 的简单说明。如果要了解 WasmEdge C API 的更多细节，请参考<a href="embed/c/ref.html">完整的文档</a>。</p>
<h2 id="wasmedge-运行时快速指南"><a class="header" href="#wasmedge-运行时快速指南">WasmEdge 运行时快速指南</a></h2>
<p>以下是运行一个 WASM 文件的示例。
假设 WASM 文件<a href="https://github.com/WasmEdge/WasmEdge/raw/master/tools/wasmedge/examples/fibonacci.wasm"><code>fibonacci.wasm</code></a>已经被拷贝到当前目录，并且 C 文件 <code>test_wasmedge.c</code> 的源代码如下所示：</p>
<pre><code class="language-c">#include &lt;wasmedge/wasmedge.h&gt;
#include &lt;stdio.h&gt;
int main(int Argc, const char* Argv[]) {
  /* 创建配置上下文以及 WASI 支持。 */
  /* 除非你需要使用 WASI，否则这步不是必须的。 */
  WasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();
  WasmEdge_ConfigureAddHostRegistration(ConfCxt, WasmEdge_HostRegistration_Wasi);
  /* 创建VM的时候可以提供空的配置。*/
  WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(ConfCxt, NULL);

  /* 参数以及返回的数组。 */
  WasmEdge_Value Params[1] = { WasmEdge_ValueGenI32(32) };
  WasmEdge_Value Returns[1];
  /* 要调用的函数名。 */
  WasmEdge_String FuncName = WasmEdge_StringCreateByCString(&quot;fib&quot;);
  /* 运行文件里的 WASM 函数。 */
  WasmEdge_Result Res = WasmEdge_VMRunWasmFromFile(VMCxt, Argv[1], FuncName, Params, 1, Returns, 1);

  if (WasmEdge_ResultOK(Res)) {
    printf(&quot;Get result: %d\n&quot;, WasmEdge_ValueGetI32(Returns[0]));
  } else {
    printf(&quot;Error message: %s\n&quot;, WasmEdge_ResultGetMessage(Res));
  }

  /* 资源析构。 */
  WasmEdge_VMDelete(VMCxt);
  WasmEdge_ConfigureDelete(ConfCxt);
  WasmEdge_StringDelete(FuncName);
  return 0;
}
</code></pre>
<p>接下来你可以编译并且运行它：（索引从 0 开始的情况下，斐波那契数列的的第 32 个数值是 3524578 ）</p>
<pre><code class="language-bash">$ gcc test_wasmedge.c -lwasmedge_c -o test_wasmedge
$ ./test_wasmedge fibonacci.wasm
Get result: 3524578
</code></pre>
<p>如果要了解 API 的细节，请参考 <a href="https://github.com/WasmEdge/WasmEdge/blob/master/include/api/wasmedge/wasmedge.h">API 头文件</a>.</p>
<h2 id="wasmedge-aot-编译器快速指南"><a class="header" href="#wasmedge-aot-编译器快速指南">WasmEdge AOT 编译器快速指南</a></h2>
<p>假设 WASM 文件 <a href="https://github.com/WasmEdge/WasmEdge/raw/master/tools/wasmedge/examples/fibonacci.wasm"><code>fibonacci.wasm</code></a> 已经被拷贝到当前目录，并且 C 文件 <code>test_wasmedge_compiler.c</code> 的代码如下所示：</p>
<pre><code class="language-c">#include &lt;wasmedge/wasmedge.h&gt;
#include &lt;stdio.h&gt;
int main(int Argc, const char* Argv[]) {
  /* 创建配置上下文。 */
  WasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();
  /* ... 通过配置上下文调整配置。 */
  /* 结果。 */
  WasmEdge_Result Res;

  /* 创建编译器上下文。配置上下文可以为空。 */
  WasmEdge_CompilerContext *CompilerCxt = WasmEdge_CompilerCreate(ConfCxt);
  /* 根据指定的输入和输出路径来编译 WASM 文件。 */
  Res = WasmEdge_CompilerCompile(CompilerCxt, Argv[1], Argv[2]);
  if (!WasmEdge_ResultOK(Res)) {
    printf(&quot;Compilation failed: %s\n&quot;, WasmEdge_ResultGetMessage(Res));
    return 1;
  }

  WasmEdge_CompilerDelete(CompilerCxt);
  WasmEdge_ConfigureDelete(ConfCxt);
  return 0;
}
</code></pre>
<p>接下来你可以编译和运行它（输出的文件是 &quot;fibonacci.wasm.so&quot; ）：</p>
<pre><code class="language-bash">$ gcc test_wasmedge_compiler.c -lwasmedge_c -o test_wasmedge_compiler
$ ./test_wasmedge_compiler fibonacci.wasm fibonacci.wasm.so
[2021-07-02 11:08:08.651] [info] compile start
[2021-07-02 11:08:08.653] [info] verify start
[2021-07-02 11:08:08.653] [info] optimize start
[2021-07-02 11:08:08.670] [info] codegen start
[2021-07-02 11:08:08.706] [info] compile done
</code></pre>
<p>编译后的的 WASM 文件也可以直接作为 WasmEdge 运行时的输入。
以下是解释模式和 AOT 模式的一个对比：</p>
<pre><code class="language-bash">$ time ./test_wasmedge fibonacci.wasm
Get result: 5702887

real 0m2.715s
user 0m2.700s
sys 0m0.008s

$ time ./test_wasmedge fibonacci.wasm.so
Get result: 5702887

real 0m0.036s
user 0m0.022s
sys 0m0.011s
</code></pre>
<p>如果要了解这些 API 的细节，请参考<a href="https://github.com/WasmEdge/WasmEdge/blob/master/include/api/wasmedge/wasmedge.h">API 头文件</a>。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="api-references"><a class="header" href="#api-references">API references</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="go-sdk"><a class="header" href="#go-sdk">Go SDK</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="嵌入-wasm-应用程序"><a class="header" href="#嵌入-wasm-应用程序">嵌入 WASM 应用程序</a></h1>
<p>WasmEdge Go SDK 能<a href="https://github.com/second-state/WasmEdge-go-examples/tree/master/go_ReadFile">嵌入单独的 WebAssembly 应用程序</a> — 比如，一个带着 <code>main()</code> 函数，编译成 WebAssembly 的 Rust 应用程序。</p>
<p>我们的 <a href="https://github.com/second-state/WasmEdge-go-examples/tree/master/go_ReadFile/rust_readfile">demo Rust 应用程序</a>从一个文件中读取内容。注意，WebAssembly 程序的输入和输出数据现在是通过 STDIN 和 STDOUT 传递的。</p>
<pre><pre class="playground"><code class="language-rust">use std::env;
use std::fs::File;
use std::io::{self, BufRead};

fn main() {
  // 获取参数。
  let args: Vec&lt;String&gt; = env::args().collect();
  if args.len() &lt;= 1 {
    println!(&quot;Rust: ERROR - No input file name.&quot;);
    return;
  }

  // 打开文件。
  println!(&quot;Rust: Opening input file \&quot;{}\&quot;...&quot;, args[1]);
  let file = match File::open(&amp;args[1]) {
    Err(why) =&gt; {
      println!(&quot;Rust: ERROR - Open file \&quot;{}\&quot; failed: {}&quot;, args[1], why);
      return;
    },
    Ok(file) =&gt; file,
  };

  // 按行读取文件内容。
  let reader = io::BufReader::new(file);
  let mut texts:Vec&lt;String&gt; = Vec::new();
  for line in reader.lines() {
    if let Ok(text) = line {
      texts.push(text);
    }
  }
  println!(&quot;Rust: Read input file \&quot;{}\&quot; succeeded.&quot;, args[1]);

  // 获取 stdin 来打印内容。
  println!(&quot;Rust: Please input the line number to print the line of file.&quot;);
  let stdin = io::stdin();
  for line in stdin.lock().lines() {
    let input = line.unwrap();
    match input.parse::&lt;usize&gt;() {
      Ok(n) =&gt; if n &gt; 0 &amp;&amp; n &lt;= texts.len() {
        println!(&quot;{}&quot;, texts[n - 1]);
      } else {
        println!(&quot;Rust: ERROR - Line \&quot;{}\&quot; is out of range.&quot;, n);
      },
      Err(e) =&gt; println!(&quot;Rust: ERROR - Input \&quot;{}\&quot; is not an integer: {}&quot;, input, e),
    }
  }
  println!(&quot;Rust: Process end.&quot;);
}
</code></pre></pre>
<p>将应用程序编译成 WebAssembly。</p>
<pre><code class="language-bash">$ cd rust_readfile
$ cargo build --target wasm32-wasi
# 输出文件是 target/wasm32-wasi/debug/rust_readfile.wasm
</code></pre>
<p>我们在 Go 程序里面嵌入 WasmEdge 运行 WebAssembly 函数，这个 Go 程序源代码如下。</p>
<pre><code class="language-go">package main

import (
  &quot;os&quot;
  &quot;github.com/second-state/WasmEdge-go/wasmedge&quot;
)

func main() {
  wasmedge.SetLogErrorLevel()

  var conf = wasmedge.NewConfigure(wasmedge.REFERENCE_TYPES)
  conf.AddConfig(wasmedge.WASI)
  var vm = wasmedge.NewVMWithConfig(conf)
  var wasi = vm.GetImportObject(wasmedge.WASI)
  wasi.InitWasi(
    os.Args[1:],     // 参数
    os.Environ(),    // 环境变量
    []string{&quot;.:.&quot;}, // 目录映射
  )

  // 实例化 wasm。_start 指的是 wasm 程序的 main() 函数
  vm.RunWasmFile(os.Args[1], &quot;_start&quot;)

  vm.Release()
  conf.Release()
}
</code></pre>
<p>接下来，让我们用 WasmEdge Go SDK 构建 Go 应用程序。</p>
<pre><code class="language-bash">go get github.com/second-state/WasmEdge-go/wasmedge@v0.9.1
go build
</code></pre>
<p>运行 Golang 应用程序。</p>
<pre><code class="language-bash">$ ./read_file rust_readfile/target/wasm32-wasi/debug/rust_readfile.wasm file.txt
Rust: Opening input file &quot;file.txt&quot;...
Rust: Read input file &quot;file.txt&quot; succeeded.
Rust: Please input the line number to print the line of file.
# 输入 &quot;5&quot; 然后按下 Enter。
5
# `file.txt` 文件的第 5 行内容将被输出：
abcDEF___!@#$%^
# 要停止程序，发送 EOF (Ctrl + D)。
^D
# 输出将会打印停止信息：
Rust: Process end.
</code></pre>
<p>更多的例子可以在 <a href="https://github.com/second-state/WasmEdge-go-examples">WasmEdge-go-examples GitHub 仓库</a> 中找到。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="嵌入-wasm-函数"><a class="header" href="#嵌入-wasm-函数">嵌入 Wasm 函数</a></h1>
<p>WasmEdge Go SDK 允许将 WebAssembly 函数嵌入到一个 Go 主程序。可以使用 Go SDK API 来传递调用参数到嵌入的 WebAssembly 函数，然后捕获返回值。</p>
<p>然而，WebAssembly 规范本身只支持一些简单数据类型。 它<a href="https://medium.com/wasm/strings-in-webassembly-wasm-57a05c1ea333">不支持</a> 字符串和数组等类型。 为了将 Go 中的丰富类型传递给 WebAssembly，我们可以手动编码内存指针（<a href="embed/go/memory.html">点击这里</a>），或者使用管理数据交换的自动化工具。</p>
<p><a href="https://github.com/second-state/wasmedge-bindgen">wasmedge-bindgen</a> 项目为函数提供了 Rust 宏来接受和返回复杂的数据类型，然后让 Go 函数调用在 WasmEdge 中运行的此类 Rust 函数。
本章中演示的完整源代码 <a href="https://github.com/second-state/WasmEdge-go-examples/tree/master/wasmedge-bindgen/go_BindgenFuncs">可在此处获得</a>。</p>
<h2 id="将-rust-函数编译成-webassembly"><a class="header" href="#将-rust-函数编译成-webassembly">将 Rust 函数编译成 WebAssembly</a></h2>
<p>在 <a href="https://github.com/second-state/WasmEdge-go-examples/tree/master/wasmedge-bindgen/go_BindgenFuncs/rust_bindgen_funcs">Rust 项目</a> 中，你只需要用 “[wasmedge_bindgen] ”宏来注释 [你的函数](https ://github.com/second-state/WasmEdge-go-examples/blob/master/wasmedge-bindgen/go_BindgenFuncs/rust_bindgen_funcs/src/lib.rs) 。
这些带注释的函数将由 Rust 编译器自动检测并转换为可以从 <code>wasmedge-bindgen</code> GO SDK 调用的 WebAssembly 函数。
在下面的示例中，我们有几个 Rust 函数可以进行复杂的调用参数并返回复杂值。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use wasmedge_bindgen::*;
use wasmedge_bindgen_macro::*;
use num_integer::lcm;
use sha3::{Digest, Sha3_256, Keccak256};
use serde::{Serialize, Deserialize};

#[derive(Serialize, Deserialize, Debug)]
struct Point {
  x: f32,
  y: f32
}

#[derive(Serialize, Deserialize, Debug)]
struct Line {
  points: Vec&lt;Point&gt;,
  valid: bool,
  length: f32,
  desc: String
}

#[wasmedge_bindgen]
pub fn create_line(p1: String, p2: String, desc: String) -&gt; Result&lt;Vec&lt;u8&gt;, String&gt; {
  let point1: Point = serde_json::from_str(p1.as_str()).unwrap();
  let point2: Point = serde_json::from_str(p2.as_str()).unwrap();
  let length = ((point1.x - point2.x) * (point1.x - point2.x) + (point1.y - point2.y) * (point1.y - point2.y)).sqrt();

  let valid = if length == 0.0 { false } else { true };

  let line = Line { points: vec![point1, point2], valid: valid, length: length, desc: desc };

  return Ok(serde_json::to_vec(&amp;line).unwrap());
}

#[wasmedge_bindgen]
pub fn say(s: String) -&gt; Result&lt;Vec&lt;u8&gt;, String&gt; {
  let r = String::from(&quot;hello &quot;);
  return Ok((r + s.as_str()).as_bytes().to_vec());
}

#[wasmedge_bindgen]
pub fn obfusticate(s: String) -&gt; Result&lt;Vec&lt;u8&gt;, String&gt; {
  let r: String = (&amp;s).chars().map(|c| {
    match c {
      'A' ..= 'M' | 'a' ..= 'm' =&gt; ((c as u8) + 13) as char,
      'N' ..= 'Z' | 'n' ..= 'z' =&gt; ((c as u8) - 13) as char,
      _ =&gt; c
    }
  }).collect();
  Ok(r.as_bytes().to_vec())
}

#[wasmedge_bindgen]
pub fn lowest_common_multiple(a: i32, b: i32) -&gt; Result&lt;Vec&lt;u8&gt;, String&gt; {
  let r = lcm(a, b);
  return Ok(r.to_string().as_bytes().to_vec());
}

#[wasmedge_bindgen]
pub fn sha3_digest(v: Vec&lt;u8&gt;) -&gt; Result&lt;Vec&lt;u8&gt;, String&gt; {
  return Ok(Sha3_256::digest(&amp;v).as_slice().to_vec());
}

#[wasmedge_bindgen]
pub fn keccak_digest(s: Vec&lt;u8&gt;) -&gt; Result&lt;Vec&lt;u8&gt;, String&gt; {
  return Ok(Keccak256::digest(&amp;s).as_slice().to_vec());
}
<span class="boring">}
</span></code></pre></pre>
<p>你可以使用标准的 Cargo 命令构建 WebAssembly 字节码文件。</p>
<pre><code class="language-bash">$ cd rust_bindgen_funcs
$ cargo build --target wasm32-wasi --release

# 输出 WASM 将是 target/wasm32-wasi/release/rust_bindgen_funcs_lib.wasm.

$ cp target/wasm32-wasi/release/rust_bindgen_funcs_lib.wasm ../
$ cd ../
</code></pre>
<h2 id="go-host-程序"><a class="header" href="#go-host-程序">Go host 程序</a></h2>
<p>在 <a href="https://github.com/second-state/WasmEdge-go-examples/blob/master/wasmedge-bindgen/go_BindgenFuncs/bindgen_funcs.go">Go host 程序</a>中，你可以使用 WasmEdge Go SDK 创建和设置 WasmEdge VM。
但是，你现不应该调用 <code>vm.Instantiate()</code> 而应该调用<code>bindgen.Instantiate(vm)</code> 来实例化 VM 并返回 <code>bindgen</code> 对象。</p>
<pre><code class="language-go">func main() {
  // 预期的 Args[0]: 程序名 (./bindgen_funcs)
  // 预期的 Args[1]: wasm 文件 (rust_bindgen_funcs_lib.wasm))
  
  wasmedge.SetLogErrorLevel()
  var conf = wasmedge.NewConfigure(wasmedge.WASI)
  var vm = wasmedge.NewVMWithConfig(conf)
  var wasi = vm.GetImportObject(wasmedge.WASI)
  wasi.InitWasi(
    os.Args[1:],     // The args
    os.Environ(),    // The envs
    []string{&quot;.:.&quot;}, // The mapping preopens
  )
  vm.LoadWasmFile(os.Args[1])
  vm.Validate()

  // 实例化 bindgen 和 vm
  bg := bindgen.Instantiate(vm)
</code></pre>
<p>接下来，你可以通过 <code>bindgen</code> 对象调用 VM 中的任何 <code>[wasmedge_bindgen]</code> 注释函数。</p>
<pre><code class="language-go">  // create_line: string, string, string -&gt; string (输入已 JSON 字符串化)  
  res, err := bg.Execute(&quot;create_line&quot;, &quot;{\&quot;x\&quot;:2.5,\&quot;y\&quot;:7.8}&quot;, &quot;{\&quot;x\&quot;:2.5,\&quot;y\&quot;:5.8}&quot;, &quot;A thin red line&quot;)
  if err == nil {
    fmt.Println(&quot;Run bindgen -- create_line:&quot;, string(res))
  } else {
    fmt.Println(&quot;Run bindgen -- create_line FAILED&quot;, err)
  }

  // say: string -&gt; string
  res, err = bg.Execute(&quot;say&quot;, &quot;bindgen funcs test&quot;)
  if err == nil {
    fmt.Println(&quot;Run bindgen -- say:&quot;, string(res))
  } else {
    fmt.Println(&quot;Run bindgen -- say FAILED&quot;)
  }

  // obfusticate: string -&gt; string
  res, err = bg.Execute(&quot;obfusticate&quot;, &quot;A quick brown fox jumps over the lazy dog&quot;)
  if err == nil {
    fmt.Println(&quot;Run bindgen -- obfusticate:&quot;, string(res))
  } else {
    fmt.Println(&quot;Run bindgen -- obfusticate FAILED&quot;)
  }

  // lowest_common_multiple: i32, i32 -&gt; i32
  res, err = bg.Execute(&quot;lowest_common_multiple&quot;, int32(123), int32(2))
  if err == nil {
    num, _ := strconv.ParseInt(string(res), 10, 32)
    fmt.Println(&quot;Run bindgen -- lowest_common_multiple:&quot;, num)
  } else {
    fmt.Println(&quot;Run bindgen -- lowest_common_multiple FAILED&quot;)
  }

  // sha3_digest: array -&gt; array
  res, err = bg.Execute(&quot;sha3_digest&quot;, []byte(&quot;This is an important message&quot;))
  if err == nil {
    fmt.Println(&quot;Run bindgen -- sha3_digest:&quot;, res)
  } else {
    fmt.Println(&quot;Run bindgen -- sha3_digest FAILED&quot;)
  }

  // keccak_digest: array -&gt; array
  res, err = bg.Execute(&quot;keccak_digest&quot;, []byte(&quot;This is an important message&quot;))
  if err == nil {
    fmt.Println(&quot;Run bindgen -- keccak_digest:&quot;, res)
  } else {
    fmt.Println(&quot;Run bindgen -- keccak_digest FAILED&quot;)
  }

  bg.Release()
  vm.Release()
  conf.Release()
}
</code></pre>
<p>最后，你可以构建并运行 Go host 程序。</p>
<pre><code class="language-bash">go build
./bindgen_funcs rust_bindgen_funcs_lib.wasm
</code></pre>
<p>本示例的标准输出如下。</p>
<pre><code class="language-bash">Run bindgen -- create_line: {&quot;points&quot;:[{&quot;x&quot;:1.5,&quot;y&quot;:3.8},{&quot;x&quot;:2.5,&quot;y&quot;:5.8}],&quot;valid&quot;:true,&quot;length&quot;:2.2360682,&quot;desc&quot;:&quot;A thin red line&quot;}
Run bindgen -- say: hello bindgen funcs test
Run bindgen -- obfusticate: N dhvpx oebja sbk whzcf bire gur ynml qbt
Run bindgen -- lowest_common_multiple: 246
Run bindgen -- sha3_digest: [87 27 231 209 189 105 251 49 159 10 211 250 15 159 154 181 43 218 26 141 56 199 25 45 60 10 20 163 54 211 195 203]
Run bindgen -- keccak_digest: [126 194 241 200 151 116 227 33 216 99 159 22 107 3 177 169 216 191 114 156 174 193 32 159 246 228 245 133 52 75 55 27]
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pass-complex-data"><a class="header" href="#pass-complex-data">Pass complex data</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tensorflow-2"><a class="header" href="#tensorflow-2">Tensorflow</a></h1>
<p>在这一章节，我们将向你展示如何在 Rust 中创建一个用于图像分类的 Tensorflow 推理函数，然后将其嵌入到 Go 应用程序中。项目的源码可以在<a href="https://github.com/second-state/WasmEdge-go-examples/tree/master/wasmedge-bindgen/go_TfliteFood">这儿</a>查看。</p>
<h2 id="将-rust-函数编译成-webassembly-1"><a class="header" href="#将-rust-函数编译成-webassembly-1">将 Rust 函数编译成 WebAssembly</a></h2>
<p>用于图像分类的 Rust 函数在<a href="https://github.com/second-state/WasmEdge-go-examples/blob/master/wasmedge-bindgen/go_TfliteFood/rust_tflite_food/src/lib.rs">这儿</a>。它使用 <a href="embed/go/../../dev/rust/tensorflow.html">WasmEdge Tensorflow 扩展 API</a> 以及 <a href="embed/go/function.html">wasmedge_bindgen</a> 来传递所有调用参数。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[wasmedge_bindgen]
fn infer(image_data: Vec&lt;u8&gt;) -&gt; Result&lt;Vec&lt;u8&gt;, String&gt; {
  ... ...
  let flat_img = image::imageops::thumbnail(&amp;img, 192, 192);

  let model_data: &amp;[u8] = include_bytes!(&quot;lite-model_aiy_vision_classifier_food_V1_1.tflite&quot;);
  let labels = include_str!(&quot;aiy_food_V1_labelmap.txt&quot;);

  let mut session = wasmedge_tensorflow_interface::Session::new(
    model_data,
    wasmedge_tensorflow_interface::ModelType::TensorFlowLite,
  );
  session.add_input(&quot;input&quot;, &amp;flat_img, &amp;[1, 192, 192, 3]).run();
  let res_vec: Vec&lt;u8&gt; = session.get_output(&quot;MobilenetV1/Predictions/Softmax&quot;);
  ... ...
}
<span class="boring">}
</span></code></pre></pre>
<p>你可以使用标准的 <code>Cargo</code> 命令来将其构建成为一个 WebAssembly 函数。</p>
<pre><code class="language-bash">cd rust_tflite_food
cargo build --target wasm32-wasi --release
cp target/wasm32-wasi/release/rust_tflite_food_lib.wasm ../
cd ../
</code></pre>
<p>你也可以使用我们的 AOT 编译器 <code>wasmedgec</code> 来检测 WebAssembly 文件，以便让其运行的更快。<a href="embed/go/../../start/universal.html">学习更多</a>。</p>
<pre><code class="language-bash">wasmedgec rust_tflite_food_lib.wasm rust_tflite_food_lib.wasm
</code></pre>
<h2 id="go-host-应用程序"><a class="header" href="#go-host-应用程序">Go host 应用程序</a></h2>
<p><a href="https://github.com/second-state/WasmEdge-go-examples/blob/master/wasmedge-bindgen/go_TfliteFood/tflite_food.go">Go host 应用程序</a>的源码展示了如何用 Tensorflow 来扩展并实例化一个 WasmEdge runtime，以及如何将图片数据传递给 WasmEdge 中的 Rust 函数，以便来执行推理。</p>
<pre><code class="language-go">func main() {
  // Expected Args[0]: program name (./tflite_food)
  // Expected Args[1]: wasm file (rust_tflite_food_lib.wasm)
  // Expected Args[2]: input image name (food.jpg)

  wasmedge.SetLogErrorLevel()

  // Set Tensorflow not to print debug info
  os.Setenv(&quot;TF_CPP_MIN_LOG_LEVEL&quot;, &quot;3&quot;)
  os.Setenv(&quot;TF_CPP_MIN_VLOG_LEVEL&quot;, &quot;3&quot;)

  var conf = wasmedge.NewConfigure(wasmedge.WASI)
  var vm = wasmedge.NewVMWithConfig(conf)
  var wasi = vm.GetImportObject(wasmedge.WASI)
  wasi.InitWasi(
    os.Args[1:],     // The args
    os.Environ(),    // The envs
    []string{&quot;.:.&quot;}, // The mapping preopens
  )

  // Register WasmEdge-tensorflow
  var tfobj = wasmedge.NewTensorflowImportObject()
  var tfliteobj = wasmedge.NewTensorflowLiteImportObject()
  vm.RegisterImport(tfobj)
  vm.RegisterImport(tfliteobj)

  // Load and validate the wasm
  vm.LoadWasmFile(os.Args[1])
  vm.Validate()

  // Instantiate the bindgen and vm
  bg := bindgen.Instantiate(vm)

  img, _ := ioutil.ReadFile(os.Args[2])
  if res, err := bg.Execute(&quot;infer&quot;, img); err != nil {
    fmt.Println(err)
  } else {
    fmt.Println(string(res))
  }

  bg.Release()
  vm.Release()
  conf.Release()
  tfobj.Release()
  tfliteobj.Release()
}
</code></pre>
<h2 id="构建和运行"><a class="header" href="#构建和运行">构建和运行</a></h2>
<blockquote>
<p>你必须要在你的机器上安装带有 tensorflow 扩展的 WasmEdge。详情可查看<a href="embed/go/../../start/install.html">安装指南</a>。</p>
</blockquote>
<p>如下命令用 WasmEdge Go SDK 和它的 tensorflow 扩展，构建了 Go host 应用程序。</p>
<pre><code class="language-bash">go build -tags tensorflow
</code></pre>
<p>现在你就可以运行 Go 应用程序了。它在 WasmEdge 中调用 WebAssembly 函数，以对输入图片进行推理。</p>
<pre><code class="language-bash">./tflite_food rust_tflite_food_lib.wasm food.jpg
</code></pre>
<p>结果如下。</p>
<pre><code class="language-bash">Go: Args: [./tflite_food rust_tflite_food_lib.wasm food.jpg]
It is very likely a Hot dog in the picture
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="embed-bindgen-funcs"><a class="header" href="#embed-bindgen-funcs">Embed bindgen funcs</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="api-references-1"><a class="header" href="#api-references-1">API references</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="nodejs-sdk"><a class="header" href="#nodejs-sdk">Node.js SDK</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rust-sdk"><a class="header" href="#rust-sdk">Rust SDK</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="python-sdk"><a class="header" href="#python-sdk">Python SDK</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="用-kubernetes-管理-wasmedge-应用"><a class="header" href="#用-kubernetes-管理-wasmedge-应用">用 Kubernetes 管理 WasmEdge 应用</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="快速开始-2"><a class="header" href="#快速开始-2">快速开始</a></h1>
<p>我们为你创建了基于 Ubuntu 的脚本，以便你在标准 Kubernetes 设置中快速开始使用以下运行时组合。</p>
<table><thead><tr><th>CRI（高级）runtime</th><th>OCI（低级）runtime</th><th></th></tr></thead><tbody>
<tr><td>CRI-O</td><td>crun + WasmEdge</td><td><a href="https://github.com/second-state/wasmedge-containers-examples/blob/main/.github/workflows/kubernetes-crio.yml">脚本</a></td></tr>
<tr><td>containerd</td><td>crun + WasmEdge</td><td><a href="https://github.com/second-state/wasmedge-containers-examples/blob/main/.github/workflows/kubernetes-containerd.yml">脚本</a></td></tr>
</tbody></table>
<h2 id="cri-o-和-crun"><a class="header" href="#cri-o-和-crun">CRI-O 和 crun</a></h2>
<p>在 Ubuntu 20.04 上你可以使用 CRI-O <a href="https://github.com/second-state/wasmedge-containers-examples/blob/main/crio/install.sh">install.sh</a> 脚本来安装 CRI-O 和 <code>crun</code> 。</p>
<pre><code class="language-bash">wget -qO- https://raw.githubusercontent.com/second-state/wasmedge-containers-examples/main/crio/install.sh | bash
</code></pre>
<p>接下来，使用 <a href="https://github.com/second-state/wasmedge-containers-examples/blob/main/kubernetes_crio/install.sh">以下脚本</a> 安装 Kubernetes。</p>
<pre><code class="language-bash">wget -qO- https://raw.githubusercontent.com/second-state/wasmedge-containers-examples/main/kubernetes_crio/install.sh | bash
</code></pre>
<p><a href="https://github.com/second-state/wasmedge-containers-examples/blob/main/kubernetes_crio/simple_wasi_application.sh">simple_wasi_application.sh</a> 脚本展示了如何从 Docker Hub 拉取 <a href="kubernetes/demo/wasi.html">WebAssembly 应用程序</a> ，然后在 Kubernetes 中将其作为容器化应用程序运行。</p>
<pre><code class="language-bash">wget -qO- https://raw.githubusercontent.com/second-state/wasmedge-containers-examples/main/kubernetes_crio/simple_wasi_application.sh | bash
</code></pre>
<p>你应该会在控制台日志中看到 WebAssembly 程序打印的结果。<a href="https://github.com/second-state/wasmedge-containers-examples/runs/4186005677?check_suite_focus=true#step:6:3007">这里是一个例子</a>。</p>
<h2 id="containerd-和-crun"><a class="header" href="#containerd-和-crun">containerd 和 crun</a></h2>
<p>在 Ubuntu 20.04 上你可以使用 containerd <a href="https://github.com/second-state/wasmedge-containers-examples/blob/main/containerd/install.sh">install.sh</a> 脚本来安装 <code>containerd</code> 和 <code>crun</code>。</p>
<pre><code class="language-bash">wget -qO- https://raw.githubusercontent.com/second-state/wasmedge-containers-examples/main/containerd/install.sh | bash
</code></pre>
<p>接下来，使用 <a href="https://github.com/second-state/wasmedge-containers-examples/blob/main/kubernetes_containerd/install.sh">以下脚本</a> 安装 Kubernetes。</p>
<pre><code class="language-bash">wget -qO- https://raw.githubusercontent.com/second-state/wasmedge-containers-examples/main/kubernetes_containerd/install.sh | bash
</code></pre>
<p><a href="https://github.com/second-state/wasmedge-containers-examples/blob/main/kubernetes_containerd/simple_wasi_application.sh">simple_wasi_application.sh</a> 脚本展示了如何从 Docker Hub拉取 <a href="kubernetes/demo/wasi.html">WebAssembly 应用程序</a>，然后在 Kubernetes 中将其作为容器化应用程序运行。</p>
<pre><code class="language-bash">wget -qO- https://raw.githubusercontent.com/second-state/wasmedge-containers-examples/main/kubernetes_containerd/simple_wasi_application.sh | bash
</code></pre>
<p>你应该会在控制台日志中看到 WebAssembly 程序打印的结果。<a href="https://github.com/second-state/wasmedge-containers-examples/runs/4577789181?check_suite_focus=true#step:6:3010">这里是一个例子</a>。</p>
<p>继续阅读本章的其余部分，了解这些运行时的具体配置方式。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="demo-apps"><a class="header" href="#demo-apps">Demo apps</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="简单的-wasi-例子"><a class="header" href="#简单的-wasi-例子">简单的 WASI 例子</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="http-服务端实例"><a class="header" href="#http-服务端实例">HTTP 服务端实例</a></h1>
<p>让我们构建一个基于 WebAssembly 的 HTTP 服务容器镜像。</p>
<p>这个 HTTP 服务应用程序是基于 Rust 开发，并采用了 <a href="https://github.com/second-state/wasmedge_wasi_socket">WasmEdge 网络 socket API</a>。</p>
<p>Kubernetes 可以使用 CRI-O、Docker 和 Containerd 来管理 wasm 应用程序生命周期。</p>
<h2 id="先决条件"><a class="header" href="#先决条件">先决条件</a></h2>
<p>这是一个 Rust 示例，它需要你先安装 <a href="https://www.rust-lang.org/tools/install">Rust</a> 和 <a href="kubernetes/demo/../../start/install.html">WasmEdge</a> 以便可以编译运行 http 服务。</p>
<h2 id="下载样例代码"><a class="header" href="#下载样例代码">下载样例代码</a></h2>
<pre><code class="language-bash">mkdir http_server
cd http_server
wget -q https://raw.githubusercontent.com/second-state/wasmedge_wasi_socket/main/examples/http_server/Cargo.toml
mkdir src
cd src
wget -q https://raw.githubusercontent.com/second-state/wasmedge_wasi_socket/main/examples/http_server/src/main.rs
cd ../
</code></pre>
<h2 id="构建-wasm-字节码"><a class="header" href="#构建-wasm-字节码">构建 WASM 字节码</a></h2>
<pre><code class="language-bash">rustup target add wasm32-wasi
cargo build --target wasm32-wasi --release
</code></pre>
<p>wasm 字节码应用程序现在应该位于 <code>./target/wasm32-wasi/release/http_server.wasm</code> 目录下。
你现在可以使用 wasmedge 测试运行它，然后将其发布为容器镜像。</p>
<h2 id="在-wasm-字节码上申请执行权限"><a class="header" href="#在-wasm-字节码上申请执行权限">在 Wasm 字节码上申请执行权限</a></h2>
<pre><code class="language-bash">chmod +x ./target/wasm32-wasi/release/http_server.wasm
</code></pre>
<h2 id="使用-wasmedge-运行-http_server-应用程序字节码"><a class="header" href="#使用-wasmedge-运行-http_server-应用程序字节码">使用 wasmedge 运行 http_server 应用程序字节码</a></h2>
<p>当你在使用 wasmedge 来执行字节码并看到如下结果时，你已完成了将字节码打包到容器中的准备工作。</p>
<pre><code class="language-bash">$ wasmedge ./target/wasm32-wasi/release/http_server.wasm
new connection at 1234
</code></pre>
<p>你可以在另一个的终端窗口中测试这个服务端。</p>
<pre><code class="language-bash">$ curl -X POST http://127.0.0.1:1234 -d 'name=WasmEdge'
echo: name=WasmEdge
</code></pre>
<h2 id="创建-dockerfile"><a class="header" href="#创建-dockerfile">创建 Dockerfile</a></h2>
<p>在 <code>target/wasm32-wasi/release</code> 文件夹中创建一个命名为 <code>Dockerfile</code> 的文件，其内容如下：</p>
<pre><code class="language-dockerfile">FROM scratch
ADD http_server.wasm /
CMD [&quot;/http_server.wasm&quot;]
</code></pre>
<h2 id="创建一个带注释的容器镜像"><a class="header" href="#创建一个带注释的容器镜像">创建一个带注释的容器镜像</a></h2>
<blockquote>
<p>请注意，添加自定义注释仍然是 buildah 中的新功能。</p>
</blockquote>
<p><code>crun</code> 容器运行时可以启动上述基于 WebAssembly 的容器镜像。但它需要容器镜像上的 <code>module.wasm.image/variant=compat</code> 注释来表明它是一个没有客人操作系统（安装在虚拟机上的系统）的 WebAssembly 应用程序。你可以在<a href="https://github.com/containers/crun/blob/main/docs/wasm-wasi-example.md">官方 crun repo</a> 中找到详细信息。</p>
<p>要在容器镜像中添加 <code>module.wasm.image/variant=compat</code> 注释，你需要最新的 <a href="https://buildah.io/">buildah</a>。 目前，Docker 不支持此功能。请按照 <a href="https://github.com/containers/buildah/blob/main/install.md">buildah 的安装说明</a> 构建最新的 buildah 二进制文件。</p>
<h3 id="在-ubuntu-上编译并安装最新的-buildah"><a class="header" href="#在-ubuntu-上编译并安装最新的-buildah">在 Ubuntu 上编译并安装最新的 buildah</a></h3>
<p>在 Ubuntu zesty 和 xenial 上，使用这些命令为 buildah 做准备。</p>
<pre><code class="language-bash">sudo apt-get -y install software-properties-common

export OS=&quot;xUbuntu_20.04&quot;
sudo bash -c &quot;echo \&quot;deb https://download.opensuse.org/repositories/devel:/kubic:/libcontainers:/stable/$OS/ /\&quot; &gt; /etc/apt/sources.list.d/devel:kubic:libcontainers:stable.list&quot;
sudo bash -c &quot;curl -L https://download.opensuse.org/repositories/devel:/kubic:/libcontainers:/stable/$OS/Release.key | apt-key add -&quot;

sudo add-apt-repository -y ppa:alexlarsson/flatpak
sudo apt-get -y -qq update

sudo apt-get -y install bats git libapparmor-dev libdevmapper-dev libglib2.0-dev libgpgme-dev libseccomp-dev libselinux1-dev skopeo-containers go-md2man containers-common
sudo apt-get -y install golang-1.16 make
</code></pre>
<p>然后，按照下列步骤在 Ubuntu 上编译和安装 buildah。</p>
<pre><code class="language-bash">mkdir -p ~/buildah
cd ~/buildah
export GOPATH=`pwd`
git clone https://github.com/containers/buildah ./src/github.com/containers/buildah
cd ./src/github.com/containers/buildah
PATH=/usr/lib/go-1.16/bin:$PATH make
cp bin/buildah /usr/bin/buildah
buildah --help
</code></pre>
<h3 id="创建和发布具备-buildah-的容器镜像"><a class="header" href="#创建和发布具备-buildah-的容器镜像">创建和发布具备 buildah 的容器镜像</a></h3>
<p>在 <code>target/wasm32-wasi/release/</code> 文件夹下，执行下列指令。</p>
<pre><code class="language-bash">$ sudo buildah build --annotation &quot;module.wasm.image/variant=compat&quot; -t http_server .

#
# make sure docker is install and running
# systemctl status docker
# to make sure regular user can use docker
# sudo usermod -aG docker $USER#
# newgrp docker

# You may need to use docker login to create the `~/.docker/config.json` for auth.
#
# docker login

$ sudo buildah push --authfile ~/.docker/config.json http_server docker://docker.io/avengermojo/http_server:with-wasm-annotation
</code></pre>
<p>好了！ 现在你可以尝试在 <a href="kubernetes/demo/../cri/crio.html#run-a-http-server-app">CRI-O</a> 或 <a href="kubernetes/demo/../kubernetes/kubernetes.html#run-a-http-server-app">Kubernetes</a> 上运行它了！</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="container-runtimes"><a class="header" href="#container-runtimes">Container runtimes</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="crun"><a class="header" href="#crun">crun</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="runc"><a class="header" href="#runc">runc</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="youki"><a class="header" href="#youki">youki</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cri-runtimes"><a class="header" href="#cri-runtimes">CRI runtimes</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cri-o"><a class="header" href="#cri-o">CRI-O</a></h1>
<h2 id="快速开始-3"><a class="header" href="#快速开始-3">快速开始</a></h2>
<p><a href="https://github.com/second-state/wasmedge-containers-examples/">GitHub repo</a> 包含 CRI-O 相关示例的脚本和 Github Actions，以下是相关链接。</p>
<ul>
<li>WebAssembly 简单示例  <a href="https://github.com/second-state/wasmedge-containers-examples/blob/main/crio/README.md">Quick start</a> | <a href="https://github.com/second-state/wasmedge-containers-examples/blob/main/.github/workflows/crio.yml">Github Actions</a> | <a href="https://github.com/second-state/wasmedge-containers-examples/runs/4317457300?check_suite_focus=true#step:4:37">Successful run</a></li>
<li>HTTP 服务端示例 <a href="https://github.com/second-state/wasmedge-containers-examples/blob/main/crio/http_server/README.md">Quick start</a> | <a href="https://github.com/second-state/wasmedge-containers-examples/blob/main/.github/workflows/crio-server.yml">Github Actions</a> | <a href="https://github.com/second-state/wasmedge-containers-examples/runs/4317457313?check_suite_focus=true#step:4:54">Successful run</a></li>
</ul>
<p>在接下来的部分中，我们会展示如何使用这些脚本。</p>
<ul>
<li><a href="kubernetes/cri/crio.html#%E5%AE%89%E8%A3%85-cri-o">安装 CRI-O</a></li>
<li><a href="kubernetes/cri/crio.html#%E9%85%8D%E7%BD%AE-CRI-O-%E4%BB%A5%E4%BD%BF%E7%94%A8-crun">配置 CRI-O 和 crun</a></li>
<li><a href="kubernetes/cri/crio.html#%E8%BF%90%E8%A1%8C%E7%AE%80%E5%8D%95-WebAssembly-%E5%BA%94%E7%94%A8">示例一 :  WebAssembly 简单示例</a></li>
<li><a href="kubernetes/cri/crio.html#%E8%BF%90%E8%A1%8C-HTTP-%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%BA%94%E7%94%A8">示例二 : WebAssembly 中的 HTTP 服务端示例</a></li>
</ul>
<h2 id="安装-cri-o"><a class="header" href="#安装-cri-o">安装 CRI-O</a></h2>
<p>使用以下命令在你的系统上安装 CRI-O。</p>
<pre><code class="language-bash">export OS=&quot;xUbuntu_20.04&quot;
export VERSION=&quot;1.21&quot;
apt update
apt install -y libseccomp2 || sudo apt update -y libseccomp2
echo &quot;deb https://download.opensuse.org/repositories/devel:/kubic:/libcontainers:/stable/$OS/ /&quot; &gt; /etc/apt/sources.list.d/devel:kubic:libcontainers:stable.list
echo &quot;deb https://download.opensuse.org/repositories/devel:/kubic:/libcontainers:/stable:/cri-o:/$VERSION/$OS/ /&quot; &gt; /etc/apt/sources.list.d/devel:kubic:libcontainers:stable:cri-o:$VERSION.list

curl -L https://download.opensuse.org/repositories/devel:kubic:libcontainers:stable:cri-o:$VERSION/$OS/Release.key | apt-key add -
curl -L https://download.opensuse.org/repositories/devel:/kubic:/libcontainers:/stable/$OS/Release.key | apt-key add -

apt-get update
apt-get install criu libyajl2
apt-get install cri-o cri-o-runc cri-tools containernetworking-plugins
systemctl start crio
</code></pre>
<h2 id="配置-cri-o-以使用-crun"><a class="header" href="#配置-cri-o-以使用-crun">配置 CRI-O 以使用 crun</a></h2>
<p>CRI-O 默认使用 <code>runc</code> 运行时，我们需要修改配置以使用 <code>crun</code> 代替。
这需要添加到两个配置文件来完成。</p>
<blockquote>
<p>在运行下一步之前，请确保你已经构建并安装好了<a href="kubernetes/cri/../container/crun.html">支持 <code>WasmEdge</code> 的 <code>crun</code> 二进制文件</a>。</p>
</blockquote>
<p>首先，创建一个 <code>/etc/crio/crio.conf</code> 文件并添加以下内容，它会使 CRI-O 默认使用 <code>crun</code> 作为运行时。</p>
<pre><code class="language-conf">[crio.runtime]
default_runtime = &quot;crun&quot;
</code></pre>
<p><code>crun</code> 运行时在 <code>/etc/crio/crio.conf.d/01-crio-runc.conf</code> 文件中定义，按下面的内容修改此文件。</p>
<pre><code class="language-conf">[crio.runtime.runtimes.runc]
runtime_path = &quot;/usr/lib/cri-o-runc/sbin/runc&quot;
runtime_type = &quot;oci&quot;
runtime_root = &quot;/run/runc&quot;
# The above is the original content

# Add our crunw runtime here
[crio.runtime.runtimes.crun]
runtime_path = &quot;/usr/bin/crun&quot;
runtime_type = &quot;oci&quot;
runtime_root = &quot;/run/crun&quot;
</code></pre>
<p>接下来，重新启动 CRI-O 以应用配置更改。</p>
<pre><code class="language-bash">systemctl restart crio
</code></pre>
<h2 id="运行简单-webassembly-应用"><a class="header" href="#运行简单-webassembly-应用">运行简单 WebAssembly 应用</a></h2>
<p>现在，我们可以使用 CRI-O 运行一个简单的 WebAssembly 程序。
<a href="kubernetes/cri/../demo/wasi.html">另一篇文章</a> 解释了如何编译、打包和将 WebAssembly 程序作为容器镜像发布至 Docker hub。
在本节中，我们需要先使用 CRI-O 工具将这个基于 WebAssembly 的容器镜像从 Docker hub 中拉取下来。</p>
<pre><code class="language-bash">sudo crictl pull docker.io/hydai/wasm-wasi-example:with-wasm-annotation
</code></pre>
<p>接下来，我们需要创建两个简单的配置文件，指定 CRI-O 应该如何在 sandbox 中运行这个 WebAssembly 镜像。 我们已经有 <a href="https://github.com/second-state/wasmedge-containers-examples/blob/main/crio/container_wasi.json">container_wasi.json</a> 和 <a href="https://github.com/second-state/wasmedge-containers-examples/blob/main/crio/sandbox_config.json">sandbox_config.json</a> 这两个文件。你可以使用下面的命令将它们下载到本地目录。</p>
<pre><code class="language-bash">wget https://raw.githubusercontent.com/second-state/wasmedge-containers-examples/main/crio/sandbox_config.json
wget https://raw.githubusercontent.com/second-state/wasmedge-containers-examples/main/crio/container_wasi.json
</code></pre>
<p>现在你可以用 CRI-O 创建 pod 和容器。只需用本文的配置选项即可。</p>
<pre><code class="language-bash"># 创建 POD。输出会与示例不同。
$ sudo crictl runp sandbox_config.json
7992e75df00cc1cf4bff8bff660718139e3ad973c7180baceb9c84d074b516a4
# 设置一个辅助变量供之后使用。
$ POD_ID=7992e75df00cc1cf4bff8bff660718139e3ad973c7180baceb9c84d074b516a4

# 创建容器实例。输出会与示例不同。
$ sudo crictl create $POD_ID container_wasi.json sandbox_config.json
# 设置一个辅助变量供之后使用。
CONTAINER_ID=1d056e4a8a168f0c76af122d42c98510670255b16242e81f8e8bce8bd3a4476f
</code></pre>
<p>启动容器会执行 WebAssembly 程序， 你可以在控制台中看到输出。</p>
<pre><code class="language-bash"># 列出容器，容器状态应为 `Created`。
$ sudo crictl ps -a
CONTAINER           IMAGE                                          CREATED              STATE               NAME                     ATTEMPT             POD ID
1d056e4a8a168       hydai/wasm-wasi-example:with-wasm-annotation   About a minute ago   Created             podsandbox1-wasm-wasi   0                   7992e75df00cc

# 启动容器。
$ sudo crictl start $CONTAINER_ID

# 再次检查容器状态。
# 如果容器没有结束作业，你会看到它处于 Running 状态。
# 因为这个示例很小。此时你可能会看到已退出。
$ sudo crictl ps -a
CONTAINER           IMAGE                                          CREATED              STATE               NAME                     ATTEMPT             POD ID
1d056e4a8a168       hydai/wasm-wasi-example:with-wasm-annotation   About a minute ago   Running             podsandbox1-wasm-wasi   0                   7992e75df00cc

# 当容器完成作业时，你可以看到他的状态变为已退出。
$ sudo crictl ps -a
CONTAINER           IMAGE                                          CREATED              STATE               NAME                     ATTEMPT             POD ID
1d056e4a8a168       hydai/wasm-wasi-example:with-wasm-annotation   About a minute ago   Exited              podsandbox1-wasm-wasi   0                   7992e75df00cc

# 检查容器的日志，它应该显示 WebAssembly 程序的输出。
$ sudo crictl logs $CONTAINER_ID

Test 1: Print Random Number
Random number: 960251471

Test 2: Print Random Bytes
Random bytes: [50, 222, 62, 128, 120, 26, 64, 42, 210, 137, 176, 90, 60, 24, 183, 56, 150, 35, 209, 211, 141, 146, 2, 61, 215, 167, 194, 1, 15, 44, 156, 27, 179, 23, 241, 138, 71, 32, 173, 159, 180, 21, 198, 197, 247, 80, 35, 75, 245, 31, 6, 246, 23, 54, 9, 192, 3, 103, 72, 186, 39, 182, 248, 80, 146, 70, 244, 28, 166, 197, 17, 42, 109, 245, 83, 35, 106, 130, 233, 143, 90, 78, 155, 29, 230, 34, 58, 49, 234, 230, 145, 119, 83, 44, 111, 57, 164, 82, 120, 183, 194, 201, 133, 106, 3, 73, 164, 155, 224, 218, 73, 31, 54, 28, 124, 2, 38, 253, 114, 222, 217, 202, 59, 138, 155, 71, 178, 113]

Test 3: Call an echo function
Printed from wasi: This is from a main function
This is from a main function

Test 4: Print Environment Variables
The env vars are as follows.
PATH: /usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
TERM: xterm
HOSTNAME: crictl_host
PATH: /usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
The args are as follows.
/var/lib/containers/storage/overlay/006e7cf16e82dc7052994232c436991f429109edea14a8437e74f601b5ee1e83/merged/wasi_example_main.wasm
50000000

Test 5: Create a file `/tmp.txt` with content `This is in a file`

Test 6: Read the content from the previous file
File content is This is in a file

Test 7: Delete the previous file
</code></pre>
<p>接下来，你可尝试在 <a href="kubernetes/cri/../../kubernetes/kubernetes.html">Kubernetes</a> 中运行这个应用!</p>
<h2 id="运行-http-服务端应用"><a class="header" href="#运行-http-服务端应用"><strong>运行 HTTP 服务端应用</strong></a></h2>
<p>最后，我们可以在 CRI-O 中运行一个简单的基于 WebAssembly 的 HTTP 微服务。
<a href="kubernetes/cri/../demo/server.html">另一篇文章</a> 解释了如何编译、打包和将 WebAssembly 程序作为容器镜像发布至 Docker hub 。
在本节中，我们需要先使用 CRI-O 工具将这个基于 WebAssembly 的容器镜像从 Docker hub 中拉取下来。</p>
<pre><code class="language-bash">sudo crictl pull docker.io/avengermojo/http_server:with-wasm-annotation
</code></pre>
<p>接下来，我们需要创建两个简单的配置文件，指定 CRI-O 应该如何在 sandbox 中运行这个 WebAssembly 镜像。 我们已经有 <a href="https://raw.githubusercontent.com/second-state/wasmedge-containers-examples/main/crio/http_server/container_http_server.json">container_http_server.json</a> 和 <a href="https://github.com/second-state/wasmedge-containers-examples/blob/main/crio/sandbox_config.json">sandbox_config.json</a> 这两个文件。你可以使用下面的命令将它们下载到本地目录。</p>
<blockquote>
<p>HTTP 服务端示例和 WASI 简单示例使用的 <code>sandbox_config.json</code> 文件是相同的。 但另一个 <code>container_*.json</code> 文件是特定的，因为它包含应用程序的 Docker Hub 链接。</p>
</blockquote>
<pre><code class="language-bash">wget https://raw.githubusercontent.com/second-state/wasmedge-containers-examples/main/crio/sandbox_config.json
wget https://raw.githubusercontent.com/second-state/wasmedge-containers-examples/main/crio/http_server/container_http_server.json
</code></pre>
<p>现在你可以用 CRI-O 创建 pod 和容器。只需用本文的配置选项即可。</p>
<pre><code class="language-bash"># 创建 POD。输出会与示例不同。
$ sudo crictl runp sandbox_config.json
7992e75df00cc1cf4bff8bff660718139e3ad973c7180baceb9c84d074b516a4
# 设置一个辅助变量供之后使用。
$ POD_ID=7992e75df00cc1cf4bff8bff660718139e3ad973c7180baceb9c84d074b516a4

# 创建容器实例。输出会与示例不同。
$ sudo crictl create $POD_ID container_wasi.json sandbox_config.json
# 设置一个辅助变量供之后使用。
CONTAINER_ID=1d056e4a8a168f0c76af122d42c98510670255b16242e81f8e8bce8bd3a4476f
</code></pre>
<p>启动容器会执行 WebAssembly 程序， 你可以在控制台中看到输出。</p>
<pre><code class="language-bash"># 启动容器
$ sudo crictl start $CONTAINER_ID

# 检查容器状态。它应该正在运行。
# 如果没有，请等待几秒钟，然后再次检查。
$ sudo crictl ps -a
CONTAINER           IMAGE                                          CREATED                  STATE               NAME                ATTEMPT             POD ID
4eeddf8613691       avengermojo/http_server:with-wasm-annotation   Less than a second ago   Running             http_server         0                   1d84f30e7012e

# 检查容器的日志以查看 HTTP 服务器正在监听端口为 1234 。
$ sudo crictl logs $CONTAINER_ID
new connection at 1234

# 获取分配给容器的 IP 地址。
$ sudo crictl inspect $CONTAINER_ID | grep IP.0 | cut -d: -f 2 | cut -d'&quot;' -f 2
10.85.0.2

# 在该 IP 地址测试 HTTP 服务状态。
$ curl -d &quot;name=WasmEdge&quot; -X POST http://10.85.0.2:1234
echo: name=WasmEdge
</code></pre>
<p>接下来，你可尝试在 <a href="kubernetes/cri/../../kubernetes/kubernetes.html">Kubernetes</a> 中运行这个应用!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="containerd"><a class="header" href="#containerd">containerd</a></h1>
<h2 id="快速开始-4"><a class="header" href="#快速开始-4">快速开始</a></h2>
<p><a href="https://github.com/second-state/wasmedge-containers-examples/">GitHub repo</a>包含 containerd 相关示例的脚本和 Github Actions，以下是相关链接。</p>
<ul>
<li>WebAssembly 简单示例 <a href="https://github.com/second-state/wasmedge-containers-examples/blob/main/containerd/README.md">Quick start</a> | <a href="https://github.com/second-state/wasmedge-containers-examples/blob/main/.github/workflows/containerd.yml">Github Actions</a> | <a href="https://github.com/second-state/wasmedge-containers-examples/runs/4328930139?check_suite_focus=true#step:4:25">Successful run</a></li>
<li>HTTP 服务端示例 <a href="https://github.com/second-state/wasmedge-containers-examples/blob/main/containerd/http_server/README.md">Quick start</a> | <a href="https://github.com/second-state/wasmedge-containers-examples/blob/main/.github/workflows/containerd-server.yml">Github Actions</a> | <a href="https://github.com/second-state/wasmedge-containers-examples/runs/4328930141?check_suite_focus=true#step:4:44">Successful run</a></li>
</ul>
<p>在接下来的部分中，我们会展示如何使用这些脚本。</p>
<ul>
<li><a href="kubernetes/cri/containerd.html#%E5%AE%89%E8%A3%85-containerd">安装 containerd</a></li>
<li><a href="kubernetes/cri/containerd.html#%E8%BF%90%E8%A1%8C%E7%AE%80%E5%8D%95-WebAssembly-%E5%BA%94%E7%94%A8">示例一： WebAssembly 简单示例</a></li>
<li><a href="kubernetes/cri/containerd.html#%E8%BF%90%E8%A1%8C-HTTP-%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%BA%94%E7%94%A8">示例二： WebAssembly 中的 HTTP 服务端示例</a></li>
</ul>
<h2 id="安装-containerd"><a class="header" href="#安装-containerd">安装 containerd</a></h2>
<p>使用以下命令在您的系统上安装 containerd。</p>
<pre><code class="language-bash">export VERSION=&quot;1.5.7&quot;
echo -e &quot;Version: $VERSION&quot;
echo -e &quot;Installing libseccomp2 ...&quot;
sudo apt install -y libseccomp2
echo -e &quot;Installing wget&quot;
sudo apt install -y wget

wget https://github.com/containerd/containerd/releases/download/v${VERSION}/cri-containerd-cni-${VERSION}-linux-amd64.tar.gz
wget https://github.com/containerd/containerd/releases/download/v${VERSION}/cri-containerd-cni-${VERSION}-linux-amd64.tar.gz.sha256sum
sha256sum --check cri-containerd-cni-${VERSION}-linux-amd64.tar.gz.sha256sum

sudo tar --no-overwrite-dir -C / -xzf cri-containerd-cni-${VERSION}-linux-amd64.tar.gz
sudo systemctl daemon-reload
</code></pre>
<p>将 containerd 配置为使用 <code>crun</code> 作为底层 OCI runtime。
此处需要修改 <code>/etc/containerd/config.toml</code> 文件。</p>
<pre><code class="language-bash">sudo mkdir -p /etc/containerd/
sudo bash -c &quot;containerd config default &gt; /etc/containerd/config.toml&quot;
wget https://raw.githubusercontent.com/second-state/wasmedge-containers-examples/main/containerd/containerd_config.diff
sudo patch -d/ -p0 &lt; containerd_config.diff
</code></pre>
<p>启动 containerd 服务。</p>
<pre><code class="language-bash">sudo systemctl start containerd
</code></pre>
<p>在运行下一步之前，请确保你已经构建并安装好了<a href="kubernetes/cri/../container/crun.html">支持 <code>WasmEdge</code>的 <code>crun</code>二进制文件</a>。</p>
<h2 id="运行简单-webassembly-应用-1"><a class="header" href="#运行简单-webassembly-应用-1">运行简单 WebAssembly 应用</a></h2>
<p>现在，我们可以使用 containerd 运行一个简单的 WebAssembly 程序。
<a href="kubernetes/cri/../demo/wasi.html">另一篇文章</a> 解释了如何编译、打包和将 WebAssembly 程序作为容器镜像发布至 Docker hub 。
在本节中，我们需要先使用 containerd 工具将这个基于 WebAssembly 的容器镜像从 Docker hub 中拉取下来。</p>
<pre><code class="language-bash">sudo ctr i pull docker.io/hydai/wasm-wasi-example:with-wasm-annotation
</code></pre>
<p>现在，您可以使用 ctr（containerd cli 工具）运行此示例。</p>
<pre><code class="language-bash">sudo ctr run --rm --runc-binary crun --runtime io.containerd.runc.v2 --label module.wasm.image/variant=compat docker.io/hydai/wasm-wasi-example:with-wasm-annotation wasm-example /wasi_example_main.wasm 50000000
</code></pre>
<p>启动容器会执行 WebAssembly 程序， 您可以在控制台中看到输出。</p>
<pre><code class="language-bash">Creating POD ...
Random number: -1678124602
Random bytes: [12, 222, 246, 184, 139, 182, 97, 3, 74, 155, 107, 243, 20, 164, 175, 250, 60, 9, 98, 25, 244, 92, 224, 233, 221, 196, 112, 97, 151, 155, 19, 204, 54, 136, 171, 93, 204, 129, 177, 163, 187, 52, 33, 32, 63, 104, 128, 20, 204, 60, 40, 183, 236, 220, 130, 41, 74, 181, 103, 178, 43, 231, 92, 211, 219, 47, 223, 137, 70, 70, 132, 96, 208, 126, 142, 0, 133, 166, 112, 63, 126, 164, 122, 49, 94, 80, 26, 110, 124, 114, 108, 90, 62, 250, 195, 19, 189, 203, 175, 189, 236, 112, 203, 230, 104, 130, 150, 39, 113, 240, 17, 252, 115, 42, 12, 185, 62, 145, 161, 3, 37, 161, 195, 138, 232, 39, 235, 222]
Printed from wasi: This is from a main function
This is from a main function
The env vars are as follows.
The args are as follows.
/wasi_example_main.wasm
50000000
File content is This is in a file
</code></pre>
<p>接下来，你可尝试在 <a href="kubernetes/cri/../../kubernetes/kubernetes.html">Kubernetes</a>中运行这个应用!</p>
<h2 id="运行-http-服务端应用-1"><a class="header" href="#运行-http-服务端应用-1">运行 HTTP 服务端应用</a></h2>
<p>最后，我们可以在 containerd 中运行一个简单的基于 WebAssembly 的 HTTP 微服务。
<a href="kubernetes/cri/../demo/server.html">另一篇文章</a> 解释了如何编译、打包和将 WebAssembly 程序作为容器镜像发布至 Docker hub 。
在本节中，我们需要先使用 containerd 工具将这个基于 WebAssembly 的容器镜像从 Docker hub 中拉取下来。</p>
<pre><code class="language-bash">sudo ctr i pull docker.io/avengermojo/http_server:with-wasm-annotation
</code></pre>
<p>现在，您可以使用 ctr（containerd cli 工具）运行该示例。（请注意，我们需要加上 <code>--net-host</code> 参数来运行容器，以便可以从外部访问 WasmEdge 容器内的 HTTP server。）</p>
<pre><code class="language-bash">sudo ctr run --rm --net-host --runc-binary crun --runtime io.containerd.runc.v2 --label module.wasm.image/variant=compat docker.io/avengermojo/http_server:with-wasm-annotation http-server-example /http_server.wasm
</code></pre>
<p>启动容器会执行 WebAssembly 程序， 您可以在控制台中看到输出。</p>
<pre><code class="language-bash">new connection at 1234

# Test the HTTP service at that IP address
curl -d &quot;name=WasmEdge&quot; -X POST http://127.0.0.1:1234
echo: name=WasmEdge
</code></pre>
<p>接下来，你可尝试在 <a href="kubernetes/cri/../../kubernetes/kubernetes.html">Kubernetes</a> 中运行这个应用!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="kubernetes"><a class="header" href="#kubernetes">Kubernetes</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="kubernetes--cri-o"><a class="header" href="#kubernetes--cri-o">Kubernetes + CRI-O</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="kubernetes--containerd"><a class="header" href="#kubernetes--containerd">Kubernetes + containerd</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="kind"><a class="header" href="#kind">KinD</a></h1>
<p>KinD 是在 Docker 内部运行的 Kubernetes 发行版，非常适合本地开发或集成测试。</p>
<h2 id="快速开始-5"><a class="header" href="#快速开始-5">快速开始</a></h2>
<p>作为先决条件，我们第一步需要安装 KinD。为此，请参阅<a href="https://kind.sigs.k8s.io/docs/user/quick-start/#installing-from-release-binaries">快速入门指南</a>和<a href="https://kind.sigs.k8s.io/docs/user/quick-start/#installing-from-release-binaries">稳定版发布页面</a>来安装最新版本的 KinD CLI。</p>
<p>如果已经安装了 KinD，我们可以直接从<a href="https://github.com/Liquid-Reply/kind-crun-wasm">这里</a>中的示例开始：</p>
<pre><code class="language-bash"># Create a &quot;WASM in KinD&quot; Cluster
kind create cluster --image ghcr.io/liquid-reply/kind-crun-wasm:v1.23.0
# Run the example
kubectl run -it --rm --restart=Never wasi-demo --image=hydai/wasm-wasi-example:with-wasm-annotation --annotations=&quot;module.wasm.image/variant=compat&quot; /wasi_example_main.wasm 50000000
</code></pre>
<p>在这个章节的剩余部分，我们会介绍如何去创建一个带有 wasmedge 的支持 KinD 的节点镜像。</p>
<h2 id="编译-crun"><a class="header" href="#编译-crun">编译 crun</a></h2>
<p>KinD 使用 kindest/node 这个镜像作为控制平面和工作节点。该镜像包括作为 CRI 的 containerd 和作为 OCI 运行时的 runc。为了启用 WasmEdge 支持，我们将 runc 替换为 crun。</p>
<pre><code class="language-Dockerfile">FROM ubuntu:21.10 AS builder
WORKDIR /data
RUN DEBIAN_FRONTEND=noninteractive apt update \
    &amp;&amp; DEBIAN_FRONTEND=noninteractive apt install -y curl make git gcc build-essential pkgconf libtool libsystemd-dev libprotobuf-c-dev libcap-dev libseccomp-dev libyajl-dev go-md2man libtool autoconf python3 automake \
    &amp;&amp; curl https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/utils/install.sh | bash -s -- -p /usr/local \
    &amp;&amp; git clone --single-branch --branch feat/handler_per_container https://github.com/liquid-reply/crun \
    &amp;&amp; cd crun \
    &amp;&amp; ./autogen.sh \
    &amp;&amp; ./configure --with-wasmedge --enable-embedded-yajl\
    &amp;&amp; make 

...
</code></pre>
<p>现在我们在 <code>/data/crun/crun</code> 目录下有了一个新的可以支持 wasmedge 的 <code>crun</code> 二进制文件，我们可以在下一步中从这个容器中复制它。</p>
<h2 id="替代-crun-和配置-containerd"><a class="header" href="#替代-crun-和配置-containerd">替代 crun 和配置 containerd</a></h2>
<p>runc 和 crun 都实现了 OCI 运行时规范，并且它们具有相同的 CLI 参数。因此我们可以用之前创建的 crun-wasmedge 二进制文件替换 runc 二进制文件。</p>
<p>由于 crun 使用了一些共享库，我们需要安装 libyajl、wasmedge 和 criu 来使 crun 工作。</p>
<p>现在我们已经有了一个使用 crun 而不是 runc 的 KinD。现在我们只需要将两个配置更改即可。第一个是在 <code>/etc/containerd/config.toml</code> 中，我们添加了可以传递给运行时的 <code>pod_annotations</code>：</p>
<pre><code class="language-toml">[plugins.&quot;io.containerd.grpc.v1.cri&quot;.containerd.runtimes.runc]
  pod_annotations = [&quot;*.wasm.*&quot;, &quot;wasm.*&quot;, &quot;module.wasm.image/*&quot;, &quot;*.module.wasm.image&quot;, &quot;module.wasm.image/variant.*&quot;]
</code></pre>
<p>第二个是在 <code>/etc/containerd/cri-base.json</code> 中，我们删除了一个导致一些问题的 hook。</p>
<p>生成的 dockerfile 如下所示：</p>
<pre><code class="language-Dockerfile">...

FROM kindest/node:v1.23.0

COPY config.toml /etc/containerd/config.toml
COPY --from=builder /data/crun/crun /usr/local/sbin/runc
COPY --from=builder /usr/local/lib/libwasmedge_c.so /usr/local/lib/libwasmedge_c.so

RUN echo &quot;Installing Packages ...&quot; \
    &amp;&amp; bash -c 'cat &lt;&lt;&lt; $(jq &quot;del(.hooks.createContainer)&quot; /etc/containerd/cri-base.json) &gt; /etc/containerd/cri-base.json' \
    &amp;&amp; ldconfig
</code></pre>
<h2 id="编译和测试"><a class="header" href="#编译和测试">编译和测试</a></h2>
<p>最终我们构建了一个新的 <code>node-wasmedge</code> 镜像。为了测试它，我们从该图像创建一个 kind 集群并运行简单的应用程序示例。</p>
<pre><code class="language-bash">$ docker build -t node-wasmedge .
$ kind create cluster --image node-wasmedge
# Now you can run the example to validate your cluster
$ kubectl run -it --rm --restart=Never wasi-demo --image=hydai/wasm-wasi-example:with-wasm-annotation --annotations=&quot;module.wasm.image/variant=compat&quot; /wasi_example_main.wasm 50000000
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="为-kubeedge-创建一个-crun-示例"><a class="header" href="#为-kubeedge-创建一个-crun-示例">为 KubeEdge 创建一个 <code>crun</code> 示例</a></h1>
<h2 id="1-云端设置kubeedge-主节点"><a class="header" href="#1-云端设置kubeedge-主节点">1. 云端设置（KubeEdge 主节点）</a></h2>
<h3 id="安装-go"><a class="header" href="#安装-go">安装 Go</a></h3>
<pre><code class="language-bash">$ wget https://golang.org/dl/go1.17.3.linux-amd64.tar.gz
$ tar xzvf go1.17.3.linux-amd64.tar.gz

$ export PATH=/home/${user}/go/bin:$PATH
$ go version
go version go1.17.3 linux/amd64
</code></pre>
<h3 id="安装-cri-o-1"><a class="header" href="#安装-cri-o-1">安装 CRI-O</a></h3>
<p>请参阅 <a href="https://github.com/cri-o/cri-o/blob/main/install.md#install-packaged-versions-of-cri-o">CRI-O Installation Instructions</a>.</p>
<pre><code class="language-bash"># 创建 .conf 文件以在启动时加载模块
$ cat &lt;&lt;EOF | sudo tee /etc/modules-load.d/crio.conf
overlay
br_netfilter
EOF

$ sudo modprobe overlay
$ sudo modprobe br_netfilter

# 设置所需的 sysctl 参数，这些参数在重启后仍然存在。
$ cat &lt;&lt;EOF | sudo tee /etc/sysctl.d/99-kubernetes-cri.conf
net.bridge.bridge-nf-call-iptables  = 1
net.ipv4.ip_forward                 = 1
net.bridge.bridge-nf-call-ip6tables = 1
EOF

$ sudo sysctl --system
$ export OS=&quot;xUbuntu_20.04&quot;
$ export VERSION=&quot;1.21&quot;
$ cat &lt;&lt;EOF | sudo tee /etc/apt/sources.list.d/devel:kubic:libcontainers:stable.list
deb https://download.opensuse.org/repositories/devel:/kubic:/libcontainers:/stable/$OS/ /
EOF
$ cat &lt;&lt;EOF | sudo tee /etc/apt/sources.list.d/devel:kubic:libcontainers:stable:cri-o:$VERSION.list
deb http://download.opensuse.org/repositories/devel:/kubic:/libcontainers:/stable:/cri-o:/$VERSION/$OS/ /
EOF

$ curl -L https://download.opensuse.org/repositories/devel:/kubic:/libcontainers:/stable/$OS/Release.key | sudo apt-key --keyring /etc/apt/trusted.gpg.d/libcontainers.gpg add -
$ curl -L https://download.opensuse.org/repositories/devel:kubic:libcontainers:stable:cri-o:$VERSION/$OS/Release.key | sudo apt-key --keyring /etc/apt/trusted.gpg.d/libcontainers-cri-o.gpg add -

$ sudo apt-get update
$ sudo apt-get install cri-o cri-o-runc

$ sudo systemctl daemon-reload
$ sudo systemctl enable crio --now
$ sudo systemctl status cri-o
</code></pre>
<p>输出：</p>
<pre><code class="language-bash">$ sudo systemctl status cri-o
● crio.service - Container Runtime Interface for OCI (CRI-O)
     Loaded: loaded (/lib/systemd/system/crio.service; enabled; vendor preset: enabled)
     Active: active (running) since Mon 2021-12-06 13:46:29 UTC; 16h ago
       Docs: https://github.com/cri-o/cri-o
   Main PID: 6868 (crio)
      Tasks: 14
     Memory: 133.2M
     CGroup: /system.slice/crio.service
             └─6868 /usr/bin/crio

Dec 07 06:04:13 master crio[6868]: time=&quot;2021-12-07 06:04:13.694226800Z&quot; level=info msg=&quot;Checking image status: k8s.gcr.io/pause:3.4.1&quot; id=1dbb722e-f031-410c-9f45-5d4b5760163e name=/runtime.v1alpha2.ImageServic&gt;
Dec 07 06:04:13 master crio[6868]: time=&quot;2021-12-07 06:04:13.695739507Z&quot; level=info msg=&quot;Image status: &amp;{0xc00047fdc0 map[]}&quot; id=1dbb722e-f031-410c-9f45-5d4b5760163e name=/runtime.v1alpha2.ImageService/ImageSta&gt;
Dec 07 06:09:13 master crio[6868]: time=&quot;2021-12-07 06:09:13.698823984Z&quot; level=info msg=&quot;Checking image status: k8s.gcr.io/pause:3.4.1&quot; id=661b754b-48a4-401b-a03f-7f7a553c7eb6 name=/runtime.v1alpha2.ImageServic&gt;
Dec 07 06:09:13 master crio[6868]: time=&quot;2021-12-07 06:09:13.703259157Z&quot; level=info msg=&quot;Image status: &amp;{0xc0004d98f0 map[]}&quot; id=661b754b-48a4-401b-a03f-7f7a553c7eb6 name=/runtime.v1alpha2.ImageService/ImageSta&gt;
Dec 07 06:14:13 master crio[6868]: time=&quot;2021-12-07 06:14:13.707778419Z&quot; level=info msg=&quot;Checking image status: k8s.gcr.io/pause:3.4.1&quot; id=8c7e4d36-871a-452e-ab55-707053604077 name=/runtime.v1alpha2.ImageServic&gt;
Dec 07 06:14:13 master crio[6868]: time=&quot;2021-12-07 06:14:13.709379469Z&quot; level=info msg=&quot;Image status: &amp;{0xc000035030 map[]}&quot; id=8c7e4d36-871a-452e-ab55-707053604077 name=/runtime.v1alpha2.ImageService/ImageSta&gt;
Dec 07 06:19:13 master crio[6868]: time=&quot;2021-12-07 06:19:13.713158978Z&quot; level=info msg=&quot;Checking image status: k8s.gcr.io/pause:3.4.1&quot; id=827b6315-f145-4f76-b8da-31653d5892a2 name=/runtime.v1alpha2.ImageServic&gt;
Dec 07 06:19:13 master crio[6868]: time=&quot;2021-12-07 06:19:13.714030148Z&quot; level=info msg=&quot;Image status: &amp;{0xc000162bd0 map[]}&quot; id=827b6315-f145-4f76-b8da-31653d5892a2 name=/runtime.v1alpha2.ImageService/ImageSta&gt;
Dec 07 06:24:13 master crio[6868]: time=&quot;2021-12-07 06:24:13.716746612Z&quot; level=info msg=&quot;Checking image status: k8s.gcr.io/pause:3.4.1&quot; id=1d53a917-4d98-4723-9ea8-a2951a472cff name=/runtime.v1alpha2.ImageServic&gt;
Dec 07 06:24:13 master crio[6868]: time=&quot;2021-12-07 06:24:13.717381882Z&quot; level=info msg=&quot;Image status: &amp;{0xc00042ce00 map[]}&quot; id=1d53a917-4d98-4723-9ea8-a2951a472cff name=/runtime.v1alpha2.ImageService/ImageSta&gt;
</code></pre>
<h3 id="使用-k8s-kubeadm-安装和创建集群"><a class="header" href="#使用-k8s-kubeadm-安装和创建集群">使用 K8s Kubeadm 安装和创建集群</a></h3>
<p>请参阅 <a href="https://kubernetes.io/zh/docs/setup/production-environment/tools/kubeadm/create-cluster-kubeadm/">使用 kubeadm 创建集群</a>.</p>
<h4 id="安装-k8s"><a class="header" href="#安装-k8s">安装 K8s</a></h4>
<pre><code class="language-bash">sudo apt-get update
sudo apt-get install -y apt-transport-https curl
echo &quot;deb [signed-by=/usr/share/keyrings/kubernetes-archive-keyring.gpg] https://apt.kubernetes.io/ kubernetes-xenial main&quot; | sudo tee /etc/apt/sources.list.d/kubernetes.list

sudo apt update
K_VER=&quot;1.21.0-00&quot;
sudo apt install -y kubelet=${K_VER} kubectl=${K_VER} kubeadm=${K_VER}
sudo apt-mark hold kubelet kubeadm kubectl
</code></pre>
<h4 id="使用-kubeadm-创建集群"><a class="header" href="#使用-kubeadm-创建集群">使用 kubeadm 创建集群</a></h4>
<pre><code class="language-bash"># kubernetes 调度程序需要进行此设置。
$ sudo swapoff -a
$ sudo vim /etc/fstab
mark contain swapfile of row

$ cat /etc/cni/net.d/100-crio-bridge.conf
{
    &quot;cniVersion&quot;: &quot;0.3.1&quot;,
    &quot;name&quot;: &quot;crio&quot;,
    &quot;type&quot;: &quot;bridge&quot;,
    &quot;bridge&quot;: &quot;cni0&quot;,
    &quot;isGateway&quot;: true,
    &quot;ipMasq&quot;: true,
    &quot;hairpinMode&quot;: true,
    &quot;ipam&quot;: {
        &quot;type&quot;: &quot;host-local&quot;,
        &quot;routes&quot;: [
            { &quot;dst&quot;: &quot;0.0.0.0/0&quot; },
            { &quot;dst&quot;: &quot;1100:200::1/24&quot; }
        ],
        &quot;ranges&quot;: [
            [{ &quot;subnet&quot;: &quot;10.85.0.0/16&quot; }],
            [{ &quot;subnet&quot;: &quot;1100:200::/24&quot; }]
        ]
    }
}
$ export CIDR=10.85.0.0/16
$ sudo kubeadm init --apiserver-advertise-address=192.168.122.160 --pod-network-cidr=$CIDR --cri-socket=/var/run/crio/crio.sock

$ mkdir -p $HOME/.kube
$ sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config
$ sudo chown $(id -u):$(id -g) $HOME/.kube/config
</code></pre>
<p>输出：</p>
<pre><code class="language-bash">Your Kubernetes control-plane has initialized successfully!

To start using your cluster, you need to run the following as a regular user:

  mkdir -p $HOME/.kube
  sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config
  sudo chown $(id -u):$(id -g) $HOME/.kube/config

You should now deploy a Pod network to the cluster.
Run &quot;kubectl apply -f [podnetwork].yaml&quot; with one of the options listed at:
  /docs/concepts/cluster-administration/addons/

You can now join any number of machines by running the following on each node
as root:

  kubeadm join &lt;control-plane-host&gt;:&lt;control-plane-port&gt; --token &lt;token&gt; --discovery-token-ca-cert-hash sha256:&lt;hash&gt;
</code></pre>
<p>要让 kubectl 为你的非 root 用户工作，请运行这些命令，这些命令也是 kubeadm init 输出的一部分：</p>
<pre><code class="language-bash">mkdir -p $HOME/.kube
sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config
sudo chown $(id -u):$(id -g) $HOME/.kube/config
</code></pre>
<h3 id="设置-kubeedge-主节点"><a class="header" href="#设置-kubeedge-主节点">设置 KubeEdge 主节点</a></h3>
<p>请参阅 <a href="https://kubeedge.io/zh/docs/setup/keadm/">使用 Keadm 进行部署</a>。</p>
<p>重要提醒:</p>
<ol>
<li>kubeconfig 或 master 中的至少一项必须配置正确，才能用于验证 k8s 集群的版本等信息。</li>
<li>请确保边缘节点可以使用云节点的本地 IP 连接云节点，或者你需要使用 <code>--advertise-address</code> 标志指定云节点的公共 IP。</li>
<li><code>--advertise-address</code>（仅 1.3 版本起有效）为云端公开的地址（将添加到 CloudCore 证书的 SAN 中），默认值为本地IP。</li>
</ol>
<pre><code class="language-bash">wget https://github.com/kubeedge/kubeedge/releases/download/v1.8.0/keadm-v1.8.0-linux-amd64.tar.gz
tar xzvf keadm-v1.8.0-linux-amd64.tar.gz
cd keadm-v1.8.0-linux-amd64/keadm/
sudo ./keadm init --advertise-address=192.168.122.160 --kube-config=/home/${user}/.kube/config
</code></pre>
<p>输出：</p>
<pre><code class="language-bash">Kubernetes version verification passed, KubeEdge installation will start...
...
KubeEdge cloudcore is running, For logs visit:  /var/log/kubeedge/cloudcore.log
</code></pre>
<h2 id="2-设置边缘端kubeedge-工作节点"><a class="header" href="#2-设置边缘端kubeedge-工作节点">2. 设置边缘端（KubeEdge 工作节点）</a></h2>
<p>你可以使用 CRI-O install.sh 脚本 <code>crun</code> 在 Ubuntu 20.04 上安装 CRI-O。</p>
<pre><code class="language-bash">wget -qO- https://raw.githubusercontent.com/second-state/wasmedge-containers-examples/main/crio/install.sh | bash
</code></pre>
<h3 id="在工作节点安装-go"><a class="header" href="#在工作节点安装-go">在工作节点安装 Go</a></h3>
<pre><code class="language-bash">$ wget https://golang.org/dl/go1.17.3.linux-amd64.tar.gz
$ tar xzvf go1.17.3.linux-amd64.tar.gz

$ export PATH=/home/${user}/go/bin:$PATH
$ go version
go version go1.17.3 linux/amd64
</code></pre>
<h3 id="从云端获取令牌"><a class="header" href="#从云端获取令牌">从云端获取令牌</a></h3>
<p>在云端运行 <code>keadm gettoken</code> 会返回 token ，在加入边缘节点时使用。</p>
<pre><code class="language-bash">$ sudo ./keadm gettoken --kube-config=/home/${user}/.kube/config
27a37ef16159f7d3be8fae95d588b79b3adaaf92727b72659eb89758c66ffda2.eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJleHAiOjE1OTAyMTYwNzd9.JBj8LLYWXwbbvHKffJBpPd5CyxqapRQYDIXtFZErgYE
</code></pre>
<h3 id="下载-kubeedge-并加入边缘节点"><a class="header" href="#下载-kubeedge-并加入边缘节点">下载 Kubeedge 并加入边缘节点</a></h3>
<p>请参阅 <a href="https://kubeedge.io/zh/docs/advanced/cri/#cri-o">使用 CRI 设置不同的容器运行时</a> 和 <a href="https://kubeedge.io/zh/docs/setup/keadm/">使用 Keadm 部署</a>.</p>
<pre><code class="language-bash">$ wget https://github.com/kubeedge/kubeedge/releases/download/v1.8.0/keadm-v1.8.0-linux-amd64.tar.gz
$ tar xzvf keadm-v1.8.0-linux-amd64.tar.gz
$ cd keadm-v1.8.0-linux-amd64/keadm/

$ sudo ./keadm join \
--cloudcore-ipport=192.168.122.160:10000 \
--edgenode-name=edge \
--token=b4550d45b773c0480446277eed1358dcd8a02a0c214646a8082d775f9c447d81.eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJleHAiOjE2Mzg4ODUzNzd9.A9WOYJFrgL2swVGnydpb4gMojyvyoNPCXaA4rXGowqU \
--remote-runtime-endpoint=unix:///var/run/crio/crio.sock \
--runtimetype=remote \
--cgroupdriver=systemd
</code></pre>
<p>输出：</p>
<pre><code class="language-bash">Host has mosquit+ already installed and running. Hence skipping the installation steps !!!
...
KubeEdge edgecore is running, For logs visit:  /var/log/kubeedge/edgecore.log
</code></pre>
<h3 id="从云端获取边缘节点状态"><a class="header" href="#从云端获取边缘节点状态">从云端获取边缘节点状态</a></h3>
<p>输出：</p>
<pre><code class="language-bash">kubectl get node
NAME       STATUS    ROLES                  AGE   VERSION
edge       Ready     agent,edge             10s   v1.19.3-kubeedge-v1.8.2
master     Ready     control-plane,master   68m   v1.21.0
</code></pre>
<h2 id="3-启用-kubectl-日志功能"><a class="header" href="#3-启用-kubectl-日志功能">3. 启用 kubectl 日志功能</a></h2>
<p>在部署 metrics-server 之前，必须激活 kubectl 日志功能，请<a href="https://kubeedge.io/zh/docs/setup/keadm/#enable-kubectl-logs-feature">参阅这里</a>.</p>
<h2 id="4-运行一个简单的-webassembly-应用"><a class="header" href="#4-运行一个简单的-webassembly-应用">4. 运行一个简单的 WebAssembly 应用</a></h2>
<p>我们可以从 Kubernetes 集群中的 Docker Hub 运行基于 WebAssembly 的镜像。</p>
<h3 id="云端"><a class="header" href="#云端">云端</a></h3>
<pre><code class="language-bash">$ kubectl run -it --restart=Never wasi-demo --image=hydai/wasm-wasi-example:with-wasm-annotation --annotations=&quot;module.wasm.image/variant=compat&quot; /wasi_example_main.wasm 50000000

Random number: -1694733782
Random bytes: [6, 226, 176, 126, 136, 114, 90, 2, 216, 17, 241, 217, 143, 189, 123, 197, 17, 60, 49, 37, 71, 69, 67, 108, 66, 39, 105, 9, 6, 72, 232, 238, 102, 5, 148, 243, 249, 183, 52, 228, 54, 176, 63, 249, 216, 217, 46, 74, 88, 204, 130, 191, 182, 19, 118, 193, 77, 35, 189, 6, 139, 68, 163, 214, 231, 100, 138, 246, 185, 47, 37, 49, 3, 7, 176, 97, 68, 124, 20, 235, 145, 166, 142, 159, 114, 163, 186, 46, 161, 144, 191, 211, 69, 19, 179, 241, 8, 207, 8, 112, 80, 170, 33, 51, 251, 33, 105, 0, 178, 175, 129, 225, 112, 126, 102, 219, 106, 77, 242, 104, 198, 238, 193, 247, 23, 47, 22, 29]
Printed from wasi: This is from a main function
This is from a main function
The env vars are as follows.
The args are as follows.
/wasi_example_main.wasm
50000000
File content is This is in a file
</code></pre>
<p>WebAssembly 应用的 pod 成功部署到边缘节点。</p>
<pre><code class="language-bash">$ kubectl describe pod wasi-demo

Name:         wasi-demo
Namespace:    default
Priority:     0
Node:         edge/192.168.122.229
Start Time:   Mon, 06 Dec 2021 15:45:34 +0000
Labels:       run=wasi-demo
Annotations:  module.wasm.image/variant: compat
Status:       Succeeded
IP:           
IPs:          &lt;none&gt;
Containers:
  wasi-demo:
    Container ID:  cri-o://1ae4d0d7f671050331a17e9b61b5436bf97ad35ad0358bef043ab820aed81069
    Image:         hydai/wasm-wasi-example:with-wasm-annotation
    Image ID:      docker.io/hydai/wasm-wasi-example@sha256:525aab8d6ae8a317fd3e83cdac14b7883b92321c7bec72a545edf276bb2100d6
    Port:          &lt;none&gt;
    Host Port:     &lt;none&gt;
    Args:
      /wasi_example_main.wasm
      50000000
    State:          Terminated
      Reason:       Completed
      Exit Code:    0
      Started:      Mon, 06 Dec 2021 15:45:33 +0000
      Finished:     Mon, 06 Dec 2021 15:45:33 +0000
    Ready:          False
    Restart Count:  0
    Environment:    &lt;none&gt;
    Mounts:
      /var/run/secrets/kubernetes.io/serviceaccount from kube-api-access-bhszr (ro)
Conditions:
  Type           Status
  Initialized    True 
  Ready          False 
  PodScheduled   True 
Volumes:
  kube-api-access-bhszr:
    Type:                    Projected (a volume that contains injected data from multiple sources)
    TokenExpirationSeconds:  3607
    ConfigMapName:           kube-root-ca.crt
    ConfigMapOptional:       &lt;nil&gt;
    DownwardAPI:             true
QoS Class:                   BestEffort
Node-Selectors:              &lt;none&gt;
Tolerations:                 node.kubernetes.io/not-ready:NoExecute op=Exists for 300s
                             node.kubernetes.io/unreachable:NoExecute op=Exists for 300s
Events:
  Type    Reason     Age   From               Message
  ----    ------     ----  ----               -------
</code></pre>
<h3 id="边缘端"><a class="header" href="#边缘端">边缘端</a></h3>
<pre><code class="language-bash">$ sudo crictl ps -a
CONTAINER           IMAGE                                                                                           CREATED             STATE               NAME                ATTEMPT             POD ID
1ae4d0d7f6710       0423b8eb71e312b8aaa09a0f0b6976381ff567d5b1e5729bf9b9aa87bff1c9f3                                16 minutes ago      Exited              wasi-demo           0                   2bc2ac0c32eda
1e6c7cb6bc731       k8s.gcr.io/kube-proxy@sha256:2a25285ff19f9b4025c8e54dac42bb3cd9aceadc361f2570489b8d723cb77135   18 minutes ago      Running             kube-proxy          0                   8b7e7388ad866
</code></pre>
<p>就是这样。</p>
<h2 id="5-运行示例的录屏"><a class="header" href="#5-运行示例的录屏">5. 运行示例的录屏</a></h2>
<p><a href="https://asciinema.org/a/wkLOu6xnAOSAQdmYayumwrAvh"><img src="https://asciinema.org/a/wkLOu6xnAOSAQdmYayumwrAvh.svg" alt="asciicast" /></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="superedge"><a class="header" href="#superedge">SuperEdge</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="openyurt"><a class="header" href="#openyurt">OpenYurt</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="应用框架与平台"><a class="header" href="#应用框架与平台">应用框架与平台</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="service-mesh-与分布式框架"><a class="header" href="#service-mesh-与分布式框架">Service mesh 与分布式框架</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="dapr"><a class="header" href="#dapr">Dapr</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mosn"><a class="header" href="#mosn">MOSN</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="apache-eventmesh"><a class="header" href="#apache-eventmesh">Apache EventMesh</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="应用框架"><a class="header" href="#应用框架">应用框架</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="yomo"><a class="header" href="#yomo">YoMo</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="reactr"><a class="header" href="#reactr">Reactr</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="serverless-平台"><a class="header" href="#serverless-平台">Serverless 平台</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="vercel"><a class="header" href="#vercel">Vercel</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="netlify"><a class="header" href="#netlify">Netlify</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="aws"><a class="header" href="#aws">AWS</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tencent"><a class="header" href="#tencent">Tencent</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="second-state"><a class="header" href="#second-state">Second State</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="操作系统"><a class="header" href="#操作系统">操作系统</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="linux"><a class="header" href="#linux">Linux</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="windows"><a class="header" href="#windows">Windows</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mac"><a class="header" href="#mac">Mac</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="android"><a class="header" href="#android">Android</a></h1>
<p>在这一章，我们会演示怎么在 Android 上运行全套的 WasmEdge Runtime -- 包括 Tensorflow AI 推理，图像处理，等扩展。如果您需要自己为 Android 编译一个 WasmEdge Runtime，可以<a href="os/../extend/build_for_android.html">参考这个文档</a>。</p>
<h2 id="在-android-环境下安装-wasmedge-tensorflow-tools"><a class="header" href="#在-android-环境下安装-wasmedge-tensorflow-tools">在 Android 环境下安装 WasmEdge-TensorFlow-Tools</a></h2>
<p>本章节使用 WasmEdge-TensorFlow-Tools 的 pre-release 版本软件包，配合 Android 版本的 TensorFlow-Lite 动态链接库在 Android 平台上运行并测试。</p>
<h3 id="环境准备"><a class="header" href="#环境准备">环境准备</a></h3>
<h4 id="android-开发者选项"><a class="header" href="#android-开发者选项">Android 开发者选项</a></h4>
<p>目前 WasmEdge 仅支持 Android 平台的 arm64-v8a 架构，开发者需要准备 arm64-v8a 架构的 Android 模拟器或一台已经 <a href="https://developer.android.com/studio/debug/dev-options">启用开发者选项和 USB 调试</a> 的 Android 设备便于测试，最低系统版本为 Android 6.0。</p>
<h4 id="android-命令行工具"><a class="header" href="#android-命令行工具">Android 命令行工具</a></h4>
<p>Ubuntu 环境下，开发者可以通过 <code>apt-get</code> 获取 Android 平台调试工具 <code>adb</code> 。通过 <code>adb shell</code> 指令，开发者可以进入设备并使用命令行操作 Android 操作系统。</p>
<pre><code class="language-bash">$ sudo apt-get install adb
$ adb devices
* daemon not running; starting now at tcp:5037
* daemon started successfully
List of devices attached
c657c643 device
$ adb shell
sirius:/ $
</code></pre>
<h3 id="获取-wasmedge-tensorflow-tools-软件包"><a class="header" href="#获取-wasmedge-tensorflow-tools-软件包">获取 WasmEdge-TensorFlow-Tools 软件包</a></h3>
<p>获取 WasmEdge-TensorFlow-Tools 的 pre-release 版本软件包。</p>
<pre><code class="language-bash">$ wget https://github.com/second-state/WasmEdge-tensorflow-tools/releases/download/0.9.1-beta.2/WasmEdge-tensorflow-tools-0.9.1-beta.2-android_aarch64.tar.gz
$ mkdir WasmEdge-tensorflow-tools &amp;&amp; tar zxvf WasmEdge-tensorflow-tools-0.9.1-beta.2-android_aarch64.tar.gz -C WasmEdge-tensorflow-tools
show-tflite-tensor
wasmedge-tensorflow-lite
</code></pre>
<h3 id="获取-android-版本的-tensorflow-lite-动态链接库"><a class="header" href="#获取-android-版本的-tensorflow-lite-动态链接库">获取 Android 版本的 TensorFlow-Lite 动态链接库</a></h3>
<p>在 WasmEdge-TensorFlow-deps 中已经为用户提供了 Android 版本的 TensorFlow-Lite 动态链接库，用户可以直接下载并使用。</p>
<pre><code class="language-bash">$ wget https://github.com/second-state/WasmEdge-tensorflow-deps/releases/download/0.9.1-beta.2/WasmEdge-tensorflow-deps-TFLite-0.9.1-beta.2-android_aarch64.tar.gz
$ tar zxvf WasmEdge-tensorflow-deps-TFLite-0.9.1-beta.2-android_aarch64.tar.gz -C WasmEdge-tensorflow-tools
._libtensorflowlite_c.so
libtensorflowlite_c.so
</code></pre>
<p>将 WasmEdge-TensorFlow 的工具及其依赖一起推送到 Android 设备上。</p>
<pre><code class="language-bash">adb push WasmEdge-tensorflow-tools /data/local/tmp
</code></pre>
<h2 id="测试"><a class="header" href="#测试">测试</a></h2>
<h3 id="获取测试样例"><a class="header" href="#获取测试样例">获取测试样例</a></h3>
<p><a href="https://github.com/second-state/wasm-learning.git">wasm-learning</a> 中为用户提供了 WasmEdge-TensorFlow-Tools 的测试样例，在 <code>wasm-learning/rust/birds_v1</code> 中提供的例子是通过一张 jpg 图片来识别鸟的种类。</p>
<pre><code class="language-bash">git clone https://github.com/second-state/wasm-learning.git
cd wasm-learning/rust/birds_v1
</code></pre>
<p>Cargo 构建 wasm 源文件，生成的 wasm 文件位于 <code>target/wasm32-wasi/release/birds_v1.wasm</code> 。</p>
<pre><code class="language-bash">rustup target add wasm32-wasi
cargo build --release --target=wasm32-wasi
</code></pre>
<p>将测试需要的 wasm 源文件， tensorflow 模型以及 jpg 图片文件推送到 Android 设备上。</p>
<pre><code class="language-bash">adb push target/wasm32-wasi/release/birds_v1.wasm /data/local/tmp/WasmEdge-tensorflow-tools
adb push lite-model_aiy_vision_classifier_birds_V1_3.tflite /data/local/tmp/WasmEdge-tensorflow-tools
adb push bird.jpg /data/local/tmp/WasmEdge-tensorflow-tools
</code></pre>
<h3 id="运行-wasmedge-tensorflow-tools"><a class="header" href="#运行-wasmedge-tensorflow-tools">运行 WasmEdge-TensorFlow-Tools</a></h3>
<p>在命令行输入 <code>adb shell</code> 进入 Android 设备，查看 <code>/data/local/tmp/WasmEdge-tensorflow-tools</code> 文件夹下的工具及测试文件是否齐全。</p>
<pre><code class="language-bash">$ adb shell
sirius:/ $ cd /data/local/tmp/WasmEdge-tensorflow-tools
sirius:/data/local/tmp/WasmEdge-tensorflow-tools $ ls
bird.jpg               lite-model_aiy_vision_classifier_birds_V1_3.tflite 
birds_v1.wasm          show-tflite-tensor                                 
libtensorflowlite_c.so wasmedge-tensorflow-lite
</code></pre>
<p>链接 TensorFlow-Lite 动态依赖库，并使用 show-tflite-tensor 检查 TensorFlow-Lite 的可用性。</p>
<pre><code class="language-bash">sirius:/data/local/tmp/WasmEdge-tensorflow-tools $ export LD_LIBRARY_PATH=.:$LD_LIBRARY_PATH
sirius:/data/local/tmp/WasmEdge-tensorflow-tools $ chmod 777 show-tflite-tensor
sirius:/data/local/tmp/WasmEdge-tensorflow-tools $ ./show-tflite-tensor lite-model_aiy_vision_classifier_birds_V1_3.tflite
INFO: Initialized TensorFlow Lite runtime.
Input tensor nums: 1
    Input tensor name: module/hub_input/images_uint8
        dimensions: [1 , 224 , 224 , 3]
        data type: UInt8
        tensor byte size: 150528
Output tensor nums: 1
    Output tensor name: module/prediction
        dimensions: [1 , 965]
        data type: UInt8
        tensor byte size: 965
</code></pre>
<p>运行 wasmedge-tensorflow-lite 工具，识别 jpg 图片中鸟的种类。</p>
<pre><code class="language-bash">sirius:/data/local/tmp/WasmEdge-tensorflow-tools $ chmod 777 wasmedge-tensorflow-lite
sirius:/data/local/tmp/WasmEdge-tensorflow-tools $ ./wasmedge-tensorflow-lite --dir .:. birds_v1.wasm lite-model_aiy_vision_classifier_birds_V1_3.tflite bird.jpg
INFO: Initialized TensorFlow Lite runtime.
166 : 0.84705883
</code></pre>
<p>该输出结果表明：识别出的图片中鸟的种类<a href="https://github.com/second-state/wasm-learning/blob/master/rust/birds_v1/aiy_birds_V1_labels.txt#L166">索引为 166</a>，准确率为 84%。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sel4"><a class="header" href="#sel4">seL4</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="open-harmony"><a class="header" href="#open-harmony">Open Harmony</a></h1>
<h2 id="从源码在-openharmony-standard-上构建和测试-wasmedge"><a class="header" href="#从源码在-openharmony-standard-上构建和测试-wasmedge">从源码在 OpenHarmony Standard 上构建和测试 WasmEdge</a></h2>
<p>请参考这个教程来从源码在 OpenHarmony 标准系统中构建和测试 WasmEdge</p>
<h2 id="环境准备-1"><a class="header" href="#环境准备-1">环境准备</a></h2>
<h3 id="openharmony-标准系统"><a class="header" href="#openharmony-标准系统">OpenHarmony 标准系统</a></h3>
<p>OpenHarmony 标准系统为开发者提供的 Docker 环境将对应的编译工具链进行了封装，本文档主要介绍在 Docker 环境下构建 WasmEdge 的步骤.</p>
<p>OpenHarmony 源码的获取与编译可以参考文档 <a href="https://www.openharmony.cn/pages/00010102/">搭建Ubuntu环境-Docker方式</a></p>
<p>请注意，在构建 WasmEdge 前需要将 Openharmony 进行一次全量编译以便后续WasmEdge的交叉编译过程.</p>
<pre><code class="language-bash"># 获取到 docker 镜像后
$ docker run -it -v $(pwd):/home/openharmony openharmony-docker-standard:0.0.5
(root@xxxxxx:/home/openharmony/)$ ./build.sh --product-name Hi3516DV300
</code></pre>
<h2 id="获取源码"><a class="header" href="#获取源码">获取源码</a></h2>
<p>OpenHarmony 将三方库项目放在了 third_party 文件夹下，因此本文档在 third_party 文件夹下获取 WasmEdge 源码，用户可以根据需要更改路径并修改相关配置文件中的路径。</p>
<pre><code class="language-bash">$ docker run -it -v $(pwd):/home/openharmony openharmony-docker-standard:0.0.5
(root@xxxxxx:/home/openharmony)$ cd third_party
(root@xxxxxx:/home/openharmony/third_party)$ git clone https://github.com/WasmEdge/WasmEdge.git
(root@xxxxxx:/home/openharmony/third_party)$ cd WasmEdge
(root@xxxxxx:/home/openharmony/third_party/WasmEdge)$ 
</code></pre>
<h2 id="修改-openharmony-标准系统配置文件"><a class="header" href="#修改-openharmony-标准系统配置文件">修改 OpenHarmony 标准系统配置文件</a></h2>
<h3 id="添加-wasmedge-子系统配置"><a class="header" href="#添加-wasmedge-子系统配置">添加 WasmEdge 子系统配置</a></h3>
<p>修改 OpenHarmony 的 build 目录下的 <code>subsystem_config.json</code> 文件，添加 <code>wasmedge</code> 子系统。</p>
<pre><code class="language-json">{
  ...
  
  &quot;wasmedge&quot;: {
    &quot;path&quot;: &quot;third_party/WasmEdge&quot;,
    &quot;name&quot;: &quot;wasmedge&quot;
  },
  
  ...
}
</code></pre>
<h3 id="将组件添加到产品配置中"><a class="header" href="#将组件添加到产品配置中">将组件添加到产品配置中</a></h3>
<p>修改 OpenHarmony 产品配置文件，标准系统对应的配置文件：<code>productdefine/common/products/Hi3516DV300.json</code>。
在该配置文件中添加 <code>&quot;wasmedge:wasmedge&quot;:{}</code>，表示该产品中会编译并打包 wasmedge 子系统下的 <code>wasmedge</code> 模块到版本中。</p>
<pre><code class="language-json">{
  ...
  &quot;parts&quot;:{
    ...
    &quot;wasmedge:wasmedge&quot;:{}
  }
}
</code></pre>
<h2 id="构建-wasmedge"><a class="header" href="#构建-wasmedge">构建 WasmEdge</a></h2>
<h3 id="说明"><a class="header" href="#说明">说明</a></h3>
<p>在 OpenHarmony 中构建的 WasmEdge 目前仅支持 <code>wasmedge</code>，即 wasm 的通用运行时。</p>
<ul>
<li><code>wasmedge</code> 可以在解释器模式下执行一个 <code>WASM</code> 文件， 也可以在预编译模式下执行通用 Wasm 二进制格式文件， 目前还不支持在 OpenHarmony 中使用预编译模式 。</li>
</ul>
<h3 id="执行构建脚本"><a class="header" href="#执行构建脚本">执行构建脚本</a></h3>
<p>通过执行 WasmEdge 源码下的 <code>utils/build_for_ohos.sh</code> 命令行脚本，将自动执行以下工作：</p>
<ol>
<li>将 .gn 等 OpenHarmony 需要的构建配置文件移动到 WasmEdge 项目根目录。</li>
<li>使用 OpenHarmony 的编译工具链进行交叉编译构建 WasmEdge。</li>
<li>运行 OpenHarmony 的构建脚本 <code>build.sh</code> 进行全量编译，该步骤将 <code>wasmedge</code> 添加进 OpenHarmony OS。</li>
</ol>
<pre><code class="language-bash">$ docker run -it -v $(pwd):/home/openharmony openharmony-docker-standard:0.0.5
(root@xxxxxx:/home/openharmony)$ cd third_party/WasmEdge/utils/ohos
(root@xxxxxx:/home/openharmony/third_party/WasmEdge/utils/ohos)$ ./build_for_ohos.sh /home/openharmony
</code></pre>
<p>当显示以下信息时，表明编译完成.</p>
<pre><code class="language-bash">...

post_process
=====build Hi3516DV300 successful.
2021-12-15 03:18:50
++++++++++++++++++++++++++++++++++++++++

</code></pre>
<p>检查 <code>wasmedge</code> 是否编译打包进 OpenHarmony OS。</p>
<pre><code class="language-bash">(root@xxxxxx:/home/openharmony/third_party/WasmEdge/utils/ohos)$ cd /home/openharmony/out/ohos-arm-release/packages/phone/system/bin
(root@xxxxxx:/home/openharmony/out/ohos-arm-release/packages/phone/system/bin)$ ls 
</code></pre>
<p>当输出的文件名中存在 <code>wasmedge</code> ，表明成功加入 OpenHarmony OS。</p>
<h2 id="测试-1"><a class="header" href="#测试-1">测试</a></h2>
<h3 id="烧录镜像"><a class="header" href="#烧录镜像">烧录镜像</a></h3>
<p>将重新编译后的 OpenHarmony 标准系统镜像烧录进开发板，具体见 OpenHarmony 文档<a href="https://device.harmonyos.com/cn/docs/documentation/guide/hi3516_upload-0000001052148681">Hi3516DV300开发板烧录</a></p>
<h3 id="运行应用"><a class="header" href="#运行应用">运行应用</a></h3>
<p>在 OpenHarmony 标准系统中，WasmEdge 提供了测试样例，并写入了 system 镜像中，供用户进行测试。
通过串口工具连接上开发板并启动OpenHarmony标准系统后，用户可以进行以下测试。</p>
<pre><code class="language-bash">$ cd /system/usr/wasmedge_example
$ wasmedge hello.wasm 1 2 3
hello
1
2
3

$ wasmedge --reactor add.wasm add 2 2
4

$ wasmedge --reactor fibonacci.wasm fib 8
34

$ wasmedge --reactor factorial.wasm fac 12
479001600

$ cd js
$ wasmedge --dir .:. qjs.wasm hello.js 1 2 3
Hello 1 2 3
</code></pre>
<h2 id="开发"><a class="header" href="#开发">开发</a></h2>
<p>接下来，你可以使用 WasmEdge Runtime 在 OpenHarmony 标准系统中进行 WebAssembly 的相关开发工作。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="raspberry-pi-34"><a class="header" href="#raspberry-pi-34">Raspberry Pi 3/4</a></h1>
<p>Raspberry Pi 从 3 Model B 开始就使用 64-bit 处理器。WasmEdge 能够在 arm 64-bit 上运行，所以 WasmEdge 同样能够在 Raspberry Pi 上运行。你可以选择任何 64-bit Linux 发行版本，例如 Raspbian， Ubuntu 或者支持 ARM 的 Manjaro。当前文档已经在支持 ARM 的 Manjaro 发行版本和 Raspberry Pi 3 Model B 硬件上测试可行。</p>
<p>在 Raspberry Pi 上的安装步骤等同于<a href="https://wasmedge.org/book/en/start/install.html">安装文档</a>，执行过程也一样。以下有一个视频，通过安装 WasmEdge 和运行一个简单的 WebAssembly 模块实现两数相加的功能。</p>
<p><a href="https://asciinema.org/a/458453"><img src="https://asciinema.org/a/458453.svg" alt="asciicast" /></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="为-wasmedge-贡献代码"><a class="header" href="#为-wasmedge-贡献代码">为 WasmEdge 贡献代码</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="从源码构建和测试-wasmedge"><a class="header" href="#从源码构建和测试-wasmedge">从源码构建和测试 WasmEdge</a></h1>
<p>请参考这个教程来从源码构建和测试 WasmEdge</p>
<h2 id="获取源码-1"><a class="header" href="#获取源码-1">获取源码</a></h2>
<pre><code class="language-bash">git clone https://github.com/WasmEdge/WasmEdge.git
cd WasmEdge
</code></pre>
<h2 id="检查依赖"><a class="header" href="#检查依赖">检查依赖</a></h2>
<p>WasmEdge 会基于最新版本的 LLVM 来创建我们的每日构建。
如果你想从源码构建的话，需要自己手动来安装下面的这些依赖。你也可以直接使用我们提供的 Docker 镜像来构建， 它支持多个发行版本的 Linux 。</p>
<ul>
<li>LLVM 12.0.0 (&gt;= 10.0.0)</li>
<li>GCC 11.1.0 (&gt;= 9.4.0)</li>
</ul>
<h2 id="环境准备-2"><a class="header" href="#环境准备-2">环境准备</a></h2>
<h3 id="docker-镜像"><a class="header" href="#docker-镜像">Docker 镜像</a></h3>
<p>Dockerhub 上的仓库 <code>wasmedge/wasmedge</code></p>
<p>你可以使用下面的命令来获取我们最新的镜像：</p>
<pre><code class="language-bash">docker pull wasmedge/wasmedge # 等同于 wasmedge/wasmedge:latest
</code></pre>
<h4 id="可用的标签"><a class="header" href="#可用的标签">可用的标签</a></h4>
<table><thead><tr><th>标签名</th><th>体系结构</th><th>基于的操作系统</th><th>LLVM 版本</th><th>环境配置</th><th>兼容性</th><th>备注</th></tr></thead><tbody>
<tr><td><code>latest</code></td><td>x86_64</td><td>Ubuntu 20.04 LTS</td><td>12.0.0</td><td>CC=clang, CXX=clang++</td><td>Ubuntu 20.04+</td><td>这个是用于持续集成的，会一直使用最新的 Ubuntu 版本</td></tr>
<tr><td><code>ubuntu-build-gcc</code></td><td>x86_64</td><td>Ubuntu 20.04 LTS</td><td>12.0.0</td><td>CC=gcc, CXX=g++</td><td>Ubuntu 20.04+</td><td>这个是用于持续集成的，会一直使用最新的 Ubuntu 版本</td></tr>
<tr><td><code>ubuntu-build-clang</code></td><td>x86_64</td><td>Ubuntu 20.04 LTS</td><td>12.0.0</td><td>CC=clang, CXX=clang++</td><td>Ubuntu 20.04+</td><td>这个是用于持续集成的，会一直使用最新的 Ubuntu 版本</td></tr>
<tr><td><code>ubuntu2004_x86_64</code></td><td>x86_64</td><td>Ubuntu 20.04 LTS</td><td>10.0.0</td><td>CC=gcc, CXX=g++</td><td>Ubuntu 20.04+</td><td>这个提供给熟悉 Ubuntu 20.04 LTS 版本的开发者使用</td></tr>
<tr><td><code>manylinux2014_x86_64</code></td><td>x86_64</td><td>CentOS 7, 7.9.2009</td><td>12.0.0</td><td>CC=gcc, CXX=g++</td><td>Ubuntu 16.04+, CentOS 7+</td><td>这个提供给熟悉 CentOS x86_64 架构的开发者使用</td></tr>
<tr><td><code>manylinux2014_aarch64</code></td><td>aarch64</td><td>CentOS 7, 7.9.2009</td><td>12.0.0</td><td>CC=gcc, CXX=g++</td><td>Ubuntu 16.04+, CentOS 7+</td><td>这个提供给熟悉 CentOS aarch64 架构的开发者使用</td></tr>
<tr><td><code>manylinux2010_x86_64</code></td><td>x86_64</td><td>CentOS 6, 6.10</td><td>12.0.0</td><td>CC=gcc, CXX=g++</td><td>Ubuntu 14.04+, CentOS 6+</td><td>这个提供给熟悉基于 x86_64 架构的过时系统的开发者使用，后续不再维护</td></tr>
<tr><td><code>manylinux1_x86_64</code></td><td>x86_64</td><td>CentOS 5, 5.11</td><td>12.0.0</td><td>CC=gcc, CXX=g++</td><td>Ubuntu 14.04+, CentOS 5+</td><td>这个提供给熟悉基于 x86_64 架构的过时系统的开发者使用，后续不再维护</td></tr>
</tbody></table>
<h3 id="在-ubuntu-2004-上手动安装依赖"><a class="header" href="#在-ubuntu-2004-上手动安装依赖">在 Ubuntu 20.04 上手动安装依赖</a></h3>
<pre><code class="language-bash"># 工具和库
sudo apt install -y \
    software-properties-common \
    cmake \
    libboost-all-dev

# 你需要 llvm 来支持 wasmedgec 工具
sudo apt install -y \
    llvm-12-dev \
    liblld-12-dev

# WasmEdge 支持 clang++ 和 g++ 编译器
# 你可以选择其中任一个用来编译这个项目
# 如果你倾向于 GCC
sudo apt install -y gcc g++
# 或者你选择 clang
sudo apt install -y clang
</code></pre>
<h3 id="对过时操作系统的支持"><a class="header" href="#对过时操作系统的支持">对过时操作系统的支持</a></h3>
<p>我们的开发环境依赖于 <code>libLLVM-12</code> 和 <code>&gt;=GLIBCXX_3.4.33</code>。</p>
<p>如果用户的系统是比 Ubuntu 20.04 还早的版本，请使用我们定制的 docker 镜像来构建 WasmEdge 。
如果你需要的是在过时版本的操作系统上使用的二进制包，我们也提供了几个基于 manylinux* 发行版本的安装包。</p>
<table><thead><tr><th>可移植的 Linux 发行版标签</th><th>基础镜像</th><th>提供的依赖</th><th>Docker 镜像</th></tr></thead><tbody>
<tr><td><code>manylinux1</code></td><td>CentOS 5.11</td><td>GLIBC &lt;= 2.5</br>CXXABI &lt;= 3.4.8</br>GLIBCXX &lt;= 3.4.9</br>GCC &lt;= 4.2.0</td><td>wasmedge/wasmedge:manylinux1_x86_64</td></tr>
<tr><td><code>manylinux2010</code></td><td>CentOS 6.10</td><td>GLIBC &lt;= 2.12</br>CXXABI &lt;= 1.3.3</br>GLIBCXX &lt;= 3.4.13</br>GCC &lt;= 4.5.0</td><td>wasmedge/wasmedge:manylinux2010_x86_64</td></tr>
<tr><td><code>manylinux2014</code></td><td>CentOS 7.9</td><td>GLIBC &lt;= 2.17</br>CXXABI &lt;= 1.3.7</br>GLIBCXX &lt;= 3.4.19</br>GCC &lt;= 4.8.0</td><td>wasmedge/wasmedge:manylinux2014_x86_64</td></tr>
<tr><td><code>manylinux2014</code></td><td>CentOS 7.9</td><td>GLIBC &lt;= 2.17</br>CXXABI &lt;= 1.3.7</br>GLIBCXX &lt;= 3.4.19</br>GCC &lt;= 4.8.0</td><td>wasmedge/wasmedge:manylinux2014_aarch64</td></tr>
</tbody></table>
<h3 id="如果你不需要预编译运行时编译器"><a class="header" href="#如果你不需要预编译运行时编译器">如果你不需要预编译运行时/编译器</a></h3>
<p>如果用户不需要预编译运行时和编译器特性的话，可以将 CMAKE 配置项 <code>WASMEDGE_BUILD_AOT_RUNTIME</code> 设置成 <code>OFF</code>。</p>
<pre><code class="language-bash">cmake -DCMAKE_BUILD_TYPE=Release -DWASMEDGE_BUILD_AOT_RUNTIME=OFF ..
</code></pre>
<h2 id="构建-wasmedge-1"><a class="header" href="#构建-wasmedge-1">构建 WasmEdge</a></h2>
<p>WasmEdge 提供了丰富的工具来支撑更好的性能以及更多样的运行时环境，
编译完成后，你可以找到以下几个 WasmEdge 相关的工具：</p>
<ol>
<li><code>wasmedge</code> 是 wasm 的通用运行时。
<ul>
<li><code>wasmedge</code> 可以在解释器模式下执行一个 <code>WASM</code> 文件， 也可以在预编译模式下执行一个 WASM <code>so</code> 文件。</li>
<li>你可以通过将 CMAKE 配置项 <code>WASMEDGE_BUILD_TOOLS</code> 设置成 <code>OFF</code>来禁止所有工具的构建。</li>
</ul>
</li>
<li><code>wasmedgec</code> 是一个 <code>WASM</code> 预编译器。
<ul>
<li><code>wasmedgec</code> 将一个通用的 <code>WASM</code> 文件编译成 <code>so</code> 文件。</li>
<li>你可以通过将 CMAKE 配置项 <code>WASMEDGE_BUILD_AOT_RUNTIME</code> 设置成 <code>OFF</code>来禁止构建预编译器。</li>
</ul>
</li>
<li><code>libwasmedge_c.so</code> 是 WasmEdge C API 的共享库。
<ul>
<li><code>libwasmedge_c.so</code> 提供了访问预编译器和 WASM 运行时的 C 语言 API。</li>
<li>如果 <code>WASMEDGE_BUILD_AOT_RUNTIME</code> 配置项被设置成 <code>OFF</code>， 那么与预编译器相关的 API 都将会返回错误。</li>
</ul>
</li>
<li><code>ssvm-qitc</code> 是用来支持 AI 应用的，它支持基于 ONNX 格式的 AI 模型的 ONNC 运行时。
<ul>
<li>如果你想尝试使用 <code>ssvm-qitc</code>，请参考 <a href="https://github.com/ONNC/onnc-wasm">ONNC-Wasm</a> 项目来设置运行环境，并且运行几个示例。</li>
<li>这里是我们的 <a href="https://www.youtube.com/watch?v=cbiPuHMS-iQ">ONNC-Wasm 项目教程 （ YouTube 视频）</a> 。</li>
</ul>
</li>
</ol>
<pre><code class="language-bash"># 获取到 wasm docker 镜像后
docker run -it --rm \
    -v &lt;path/to/your/wasmedge/source/folder&gt;:/root/wasmedge \
    wasmedge/wasmedge:latest
# In docker
cd /root/wasmedge
mkdir -p build &amp;&amp; cd build
cmake -DCMAKE_BUILD_TYPE=Release -DWASMEDGE_BUILD_TESTS=ON .. &amp;&amp; make -j
</code></pre>
<h2 id="执行内置的测试"><a class="header" href="#执行内置的测试">执行内置的测试</a></h2>
<p>下面所提到的测试只有在构建配置 <code>WASMEDGE_BUILD_TESTS</code> 设置为 <code>ON</code> 的时候才有效。</p>
<p>用户可以通过这些测试来验证 WasmEdge 二进制包的正确性。</p>
<pre><code class="language-bash">cd &lt;path/to/wasmedge/build_folder&gt;
LD_LIBRARY_PATH=$(pwd)/lib/api ctest
</code></pre>
<h2 id="运行应用-1"><a class="header" href="#运行应用-1">运行应用</a></h2>
<p>接下来，参考 <a href="extend/../index.html">这个文档</a> 在 <code>wasmedge</code> 上运行 WebAssembly 字节码程序。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="用-mac-编译"><a class="header" href="#用-mac-编译">用 Mac 编译</a></h1>
<p>目前，WasmEdge 项目同时支持 Intel 和 M1 型号的 MacOS。然而，我们只在 Big Sur 和 Catalina 上进行测试和开发。</p>
<ul>
<li>型号
<ul>
<li>Intel</li>
<li>M1</li>
</ul>
</li>
<li>操作系统
<ul>
<li>Big Sur</li>
<li>Catalina</li>
</ul>
</li>
</ul>
<p>如果您想在 MacOS 上开发 WasmEdge，请按照这个教程从源码进行构建和测试。</p>
<h2 id="获取源码-2"><a class="header" href="#获取源码-2">获取源码</a></h2>
<pre><code class="language-bash">git clone https://github.com/WasmEdge/WasmEdge.git
cd WasmEdge
</code></pre>
<h2 id="依赖组件"><a class="header" href="#依赖组件">依赖组件</a></h2>
<p>WasmEdge 会基于最新版本的 LLVM 来创建我们的每日构建。如果你想从源码构建的话，需要自己手动来安装下面的这些依赖。</p>
<ul>
<li>LLVM 12.0.0 (&gt;= 10.0.0)，使用 brew 安装，请勿使用系统自带的 LLVM。</li>
<li>因为最新版本 brew 中的 LLVM 默认版本是 13。请使用 <code>llvm@12</code> 来调整 LLVM 的版本。</li>
</ul>
<h3 id="环境准备-3"><a class="header" href="#环境准备-3">环境准备</a></h3>
<pre><code class="language-bash"># 工具和库
$ brew install boost cmake ninja llvm@12
# 使用 brew 版本的 llvm，而不是系统自带的 LLVM。
$ export PATH=&quot;/usr/local/opt/llvm@12/bin:$PATH&quot;
$ export LDFLAGS=&quot;-L/usr/local/opt/llvm@12/lib -Wl，-rpath，/usr/local/opt/llvm@12/lib&quot;
$ export CPPFLAGS=&quot;-I/usr/local/opt/llvm@12/include&quot;
</code></pre>
<h3 id="如果你不需要预编译的运行时编译器"><a class="header" href="#如果你不需要预编译的运行时编译器">如果你不需要预编译的运行时/编译器</a></h3>
<p>如果你不需要预编译运行时和编译器特性的话，你可以将 CMake 配置项 <code>WASMEDGE_BUILD_AOT_RUNTIME</code> 设置成 <code>OFF</code>。</p>
<pre><code class="language-bash">cmake -DCMAKE_BUILD_TYPE=Release -DWASMEDGE_BUILD_AOT_RUNTIME=OFF ..
</code></pre>
<h2 id="构建-wasmedge-2"><a class="header" href="#构建-wasmedge-2">构建 WasmEdge</a></h2>
<p>WasmEdge 提供了丰富的工具来支撑更好的性能以及更多样的运行时环境，编译完成后，你可以找到以下几个 WasmEdge 相关的工具：</p>
<ol>
<li><code>wasmedge</code> 是 wasm 的通用运行时。
<ul>
<li><code>wasmedge</code> 可以在解释器模式下执行一个 <code>WASM</code> 文件，也可以在预编译模式下执行一个 WASM <code>dyld</code> 文件。</li>
<li>你可以通过将 CMake 配置项 <code>WASMEDGE_BUILD_TOOLS</code> 设置成 <code>OFF</code> 来禁止构建所有工具。</li>
</ul>
</li>
<li><code>wasmedgec</code> 是一个 <code>WASM</code> 预编译器。
<ul>
<li><code>wasmedgec</code> 将一个通用的 <code>WASM</code> 文件编译成 <code>dyld</code> 文件。</li>
<li>你可以通过将 CMake 配置项 <code>WASMEDGE_BUILD_AOT_RUNTIME</code> 设置成 <code>OFF</code> 来禁止构建预编译器。</li>
</ul>
</li>
<li><code>libwasmedge_c.dyld</code> 是 WasmEdge C API 的共享库。
<ul>
<li><code>libwasmedge_c.dyld</code> 提供了访问预编译器和 WASM 运行时的 C 语言 API。</li>
<li>如果 <code>WASMEDGE_BUILD_AOT_RUNTIME</code> 配置项被设置成 <code>OFF</code> ，那么与预编译器相关的 API 都将会返回错误。</li>
<li>你可以通过将 CMake 配置项 <code>WASMEDGE_BUILD_SHARED_LIB</code> 设置成 <code>OFF</code> 来禁止构建共享库。</li>
</ul>
</li>
</ol>
<pre><code class="language-bash">cmake -Bbuild -GNinja -DWASMEDGE_BUILD_PACKAGE=&quot;TGZ&quot; -DWASMEDGE_BUILD_TESTS=ON .
cmake --build build
</code></pre>
<h2 id="运行内置测试"><a class="header" href="#运行内置测试">运行内置测试</a></h2>
<p>以下内置测试只有在构建标志 <code>WASMEDGE_BUILD_TESTS</code> 设置为 <code>ON</code> 时才可用。</p>
<p>用户可以通过这些测试来验证 WasmEdge 二进制包的正确性。</p>
<pre><code class="language-bash">export DYLD_LIBRARY_PATH=&quot;$(pwd)/build/lib/api:$DYLD_LIBRARY_PATH&quot;
cmake --build build --target test
</code></pre>
<h2 id="运行应用程序"><a class="header" href="#运行应用程序">运行应用程序</a></h2>
<p>接下来，参考<a href="extend/../index.html">这个文档</a>在 <code>wasmedge</code> 上运行 WebAssembly 字节码程序。</p>
<h2 id="已知问题"><a class="header" href="#已知问题">已知问题</a></h2>
<p>以下测试无法在 MacOS 上通过，我们正在调查这些问题：</p>
<ul>
<li>wasmedgeAPIVMCoreTests</li>
<li>wasmedgeAPIStepsCoreTests</li>
<li>wasmedgeAPIAOTCoreTests</li>
<li>wasmedgeProcessTests</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="在-windows-10由源码构建"><a class="header" href="#在-windows-10由源码构建">在 Windows 10由源码构建</a></h1>
<p>WasmEdge 支持 Windows 10 。我们也同时提供了二进制安装包和库文件。</p>
<p>可以在<a href="https://github.com/WasmEdge/WasmEdge/blob/master/.github/workflows/build.yml#L266-L322">这里</a>查看详情。</p>
<p>如果想要在 Windows 10 上开发 WasmEdge，请继续阅读本文以进行从源码构建和测试。</p>
<p>下文中将以 <code>AOT</code> 代替 <code>ahead-of-time</code> ，<code>ahead-of-time</code> 的含义是将 WASM 文件提前编译为机器码。</p>
<h2 id="下载源代码"><a class="header" href="#下载源代码">下载源代码</a></h2>
<pre><code class="language-bash">git clone https://github.com/WasmEdge/WasmEdge.git
cd WasmEdge
</code></pre>
<h2 id="依赖说明"><a class="header" href="#依赖说明">依赖说明</a></h2>
<p>WasmEdge 尝试用最新的 LLVM 发行版本来创建我们的 nightly 版本。</p>
<p>需要以下自行安装以下依赖才能编译源码：</p>
<ul>
<li>Chocolatey，用来安装 cmake、ninja 和 vswhere</li>
<li>Windows SDK 19041</li>
<li>LLVM 13.0.0，预编译版本在下节中提供</li>
</ul>
<h3 id="下载依赖"><a class="header" href="#下载依赖">下载依赖</a></h3>
<pre><code class="language-powershell"># 下载工具
choco install cmake ninja vswhere

$vsPath = (vswhere -latest -property installationPath)
Import-Module (Join-Path $vsPath &quot;Common7\Tools\Microsoft.VisualStudio.DevShell.dll&quot;)
Enter-VsDevShell -VsInstallPath $vsPath -SkipAutomaticLocation -DevCmdArguments &quot;-arch=x64 -host_arch=x64 -winsdk=10.0.19041.0&quot;

# 下载我们提供的预编译好的 LLVM 13
$llvm = &quot;LLVM-13.0.0-win64.zip&quot;
curl -sLO https://github.com/WasmEdge/llvm-windows/releases/download/llvmorg-13.0.0/LLVM-13.0.0-win64.zip -o $llvm
Expand-Archive -Path $llvm

# 设置 LLVM 环境变量
$llvm_dir = &quot;$pwd\\LLVM-13.0.0-win64\\LLVM-13.0.0-win64\\lib\\cmake\\llvm&quot;
$Env:CC = &quot;clang-cl&quot;
$Env:CXX = &quot;clang-cl&quot;
</code></pre>
<h3 id="如果不需要构建aot运行时或者编译器"><a class="header" href="#如果不需要构建aot运行时或者编译器">如果不需要构建AOT运行时或者编译器</a></h3>
<p>如果不需要 AOT 运行时或者编译器，可以将 CMake 选项 <code>WASMEDGE_BUILD_AOT_RUNTIME</code>  设置为 <code>OFF</code>。</p>
<pre><code class="language-bash">cmake -DCMAKE_BUILD_TYPE=Release -DWASMEDGE_BUILD_AOT_RUNTIME=OFF ..
</code></pre>
<h2 id="构建-wasmedge-3"><a class="header" href="#构建-wasmedge-3">构建 WasmEdge</a></h2>
<p>为应对不同的性能需求，WasmEdge 提供了多种运行时环境和工具。</p>
<p>构建成功后，你可以找到这些 wasmedge 相关工具：</p>
<ol>
<li><code>wasmedge</code>  是一个通用的 wasm 运行时。
<ul>
<li><code>wasmedge</code>  可以解释执行 <code>WASM</code>  文件或者以 AOT 模式执行一个编译过的 WASM <code>dyld</code> 文件。</li>
<li>在构建 WasmEdge 时，可以设置 CMake 选项 <code>WASMEDGE_BUILD_TOOLS</code> 为<code>OFF</code> 来不构建所有工具。</li>
</ul>
</li>
<li><code>wasmedgec</code> 是一个 AOT <code>WASM</code> 编译器。
<ul>
<li><code>wasmedgec</code> 将一个 <code>WASM</code> 格式的文件编译为<code>dll</code> 格式文件。</li>
<li>如果你不需要构建 AOT 编译器，可以将 CMake 选项 <code>WASMEDGE_BUILD_AOT_RUNTIME</code>  设置为  <code>OFF</code> 。</li>
</ul>
</li>
<li><code>libwasmedge_c.dll</code> 是 WasmEdge 的 C API 共享库.
<ul>
<li><code>libwasmedge_c.dll</code> 为 AOT 编译器和 WASM 运行时提供 C API。</li>
<li>CMake 选项 <code>WASMEDGE_BUILD_AOT_RUNTIME</code> 设置为 <code>OFF</code> 后，调用与 AOT 编译器相关的 API 只会返回失败值。</li>
<li>如果你不需要构建共享库，可以将 CMake 选项 <code>WASMEDGE_BUILD_SHARED_LIB</code>  设置为 <code>OFF</code> 。</li>
</ul>
</li>
</ol>
<pre><code class="language-bash">$vsPath = (vswhere -latest -property installationPath)
Import-Module (Join-Path $vsPath &quot;Common7\Tools\Microsoft.VisualStudio.DevShell.dll&quot;)
Enter-VsDevShell -VsInstallPath $vsPath -SkipAutomaticLocation -DevCmdArguments &quot;-arch=x64 -host_arch=x64 -winsdk=10.0.19041.0&quot;

cmake -Bbuild -GNinja -DCMAKE_SYSTEM_VERSION=10.0.19041.0 -DCMAKE_MSVC_RUNTIME_LIBRARY=MultiThreadedDLL &quot;-DLLVM_DIR=$llvm_dir&quot; -DWASMEDGE_BUILD_TESTS=ON -DWASMEDGE_BUILD_PACKAGE=&quot;ZIP&quot; .
cmake --build build
</code></pre>
<h2 id="运行内置测试-1"><a class="header" href="#运行内置测试-1">运行内置测试</a></h2>
<p>以下内置测试仅在 CMake 编译选项 <code>WASMEDGE_BUILD_TESTS</code>  为 <code>ON</code> 时可用。</p>
<p>用户可以用这些测试来验证自己构建的 WasmEdge 二进制文件的正确性。</p>
<pre><code class="language-bash">$vsPath = (vswhere -latest -property installationPath)
Import-Module (Join-Path $vsPath &quot;Common7\Tools\Microsoft.VisualStudio.DevShell.dll&quot;)
Enter-VsDevShell -VsInstallPath $vsPath -SkipAutomaticLocation -DevCmdArguments &quot;-arch=x64 -host_arch=x64 -winsdk=10.0.19041.0&quot;

$Env:PATH += &quot;;$pwd\\build\\lib\\api&quot;
cd build
ctest --output-on-failure
cd -
</code></pre>
<h2 id="运行应用-2"><a class="header" href="#运行应用-2">运行应用</a></h2>
<p>下一步，请按照<a href="extend/run.html">该指导</a> 使用 <code>wasmedge</code> 运行 WebAssembly 字节码程序。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="为-android-编译"><a class="header" href="#为-android-编译">为 Android 编译</a></h1>
<h2 id="使用-android-ndk-构建和测试-wasmedge-命令行工具"><a class="header" href="#使用-android-ndk-构建和测试-wasmedge-命令行工具">使用 Android NDK 构建和测试 WasmEdge 命令行工具</a></h2>
<p>此教程指导使用 Android NDK 构建 Interpreter 模式的 WasmEdge ，并在 Android 设备中测试 wasmedge 命令行工具。</p>
<h3 id="环境准备-4"><a class="header" href="#环境准备-4">环境准备</a></h3>
<ul>
<li><a href="https://developer.android.com/ndk/downloads">Android NDK 23b</a>
<ul>
<li>下载到的 NDK 工具链需要解压到磁盘上</li>
</ul>
</li>
<li><a href="https://cmake.org/download/">CMake 3.21</a> 及以上版本
<ul>
<li>如果本机已安装 cmake，请检查版本是否符合要求</li>
</ul>
</li>
<li><a href="https://developer.android.com/studio/releases/platform-tools">ADB</a>
<ul>
<li>将下载到的 platform-tools 解压到磁盘上，adb 命令在 bin 目录中</li>
<li>如果您使用的是 debian/ubuntu 系统，可以通过 apt 安装 adb</li>
</ul>
</li>
<li>一台已经 <a href="https://developer.android.com/studio/debug/dev-options">启用开发者选项和 USB 调试</a> 的 Android 设备, 最低系统版本为 Android 6.0</li>
</ul>
<h3 id="构建-wasmedge-4"><a class="header" href="#构建-wasmedge-4">构建 WasmEdge</a></h3>
<ol>
<li>添加 NDK 目录路径到环境变量 <code>ANDROID_NDK_HOME=path/to/you/ndk/dir</code></li>
<li>执行 WasmEdge 源码路径下的 <code>utils/android/standalone/build_for_android.sh</code> 命令行脚本，将自动执行构建，构建结果在 WasmEdge 目录中的 build 目录</li>
</ol>
<h3 id="测试-2"><a class="header" href="#测试-2">测试</a></h3>
<h4 id="推送到-android-设备"><a class="header" href="#推送到-android-设备">推送到 Android 设备</a></h4>
<ol>
<li>
<p>将 Android 设备通过 USB 或 WLAN 连接到 PC 。您可以通过 <code>adb devices</code> 命令检查已连接的设备，可以获得类似如下显示：</p>
<pre><code class="language-bash">$ adb devices
List of devices attached
0a388e93      device
</code></pre>
</li>
<li>
<p>使用 <code>adb push</code>命令推送 build/tools/wasmedge 到 Android 设备的 /data/local/tmp 目录</p>
<pre><code class="language-bash">cd build
adb push ./tools/wasmedge /data/local/tmp  
</code></pre>
</li>
</ol>
<h4 id="在-android-设备中执行-wasmedge"><a class="header" href="#在-android-设备中执行-wasmedge">在 Android 设备中执行 WasmEdge</a></h4>
<ol>
<li>使用 <code>adb shell</code> 命令进入 Android 设备</li>
<li>测试运行 wasmedge 程序</li>
</ol>
<pre><code class="language-bash">$ cd /data/local/tmp/wasmedge/examples
$ ../wasmedge hello.wasm 1 2 3                                                           
hello
1
2
3

$ ../wasmedge --reactor add.wasm add 2 2
4

$ ../wasmedge --reactor fibonacci.wasm fib 8
34

$ ../wasmedge --reactor factorial.wasm fac 12
479001600

$ cd js
$ ./../wasmedge --dir .:. qjs.wasm hello.js 1 2 3
Hello 1 2 3
</code></pre>
<h3 id="注意-1"><a class="header" href="#注意-1">注意</a></h3>
<ul>
<li>Android 10 及以上系统版本，SELinux 限制普通 Android 应用程序使用 exec() 执行 home 目录中的可执行文件。<a href="https://android.googlesource.com/platform/system/sepolicy/+/08450264ae3f917f6b8e4091d6fedf84ef8d796f/private/untrusted_app_all.te#27">参考</a></li>
<li>Android SELinux 限制普通 Android 应用程序访问 /data/local/tmp 目录</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="wasmedge-插件-api"><a class="header" href="#wasmedge-插件-api">WasmEdge 插件 API</a></h1>
<p>WasmEdge 提供了一套基于 C++ 的 API 用来注册自定义扩展和 host 函数。虽然 WasmEdge 各种语言语言 SDK 允许将主机应用注册为主机功能函数，但插件 API 方式允许这种扩展被纳入 WasmEdge 自己的构建和发布过程。</p>
<p>事实上，WasmEdge 对 Tensorflow 、图像处理、键值存储等的扩展都是通过插件 API 实现的。插件 API 是你可以为 WasmEdge Runtime 本身贡献新功能的方式。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="host-functions"><a class="header" href="#host-functions">Host functions</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="external-references"><a class="header" href="#external-references">External references</a></h1>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
    </body>
</html>
