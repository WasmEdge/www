<!DOCTYPE HTML>
<html lang="zh" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>WasmEdge Runtime</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-NGPCK7VF2L"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-NGPCK7VF2L');
</script>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item "><a href="index.html"><strong aria-hidden="true">1.</strong> 快速开始</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="start/install.html"><strong aria-hidden="true">1.1.</strong> WasmEdge 的安装与卸载</a></li><li class="chapter-item "><a href="start/docker.html"><strong aria-hidden="true">1.2.</strong> 使用 Docker 进行 WasmEdge 应用程序开发</a></li><li class="chapter-item "><a href="start/cli.html"><strong aria-hidden="true">1.3.</strong> WasmEdge 命令行</a></li><li class="chapter-item "><a href="start/universal.html"><strong aria-hidden="true">1.4.</strong> 通用 wasm 二进制格式</a></li></ol></li><li class="chapter-item "><a href="intro.html"><strong aria-hidden="true">2.</strong> WasmEdge 介绍</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="intro/use.html"><strong aria-hidden="true">2.1.</strong> 应用场景</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="intro/use/runtime.html"><strong aria-hidden="true">2.1.1.</strong> 云原生的 runtime</a></li><li class="chapter-item "><a href="intro/use/js.html"><strong aria-hidden="true">2.1.2.</strong> JavaScript 或 DSL runtime</a></li><li class="chapter-item "><a href="intro/use/serverless.html"><strong aria-hidden="true">2.1.3.</strong> 公有云中的 Serverless 函数即服务</a></li><li class="chapter-item "><a href="intro/use/edge.html"><strong aria-hidden="true">2.1.4.</strong> 边缘计算</a></li><li class="chapter-item "><a href="intro/use/saas.html"><strong aria-hidden="true">2.1.5.</strong> SaaS 里的嵌入式函数</a></li></ol></li><li class="chapter-item "><a href="intro/features.html"><strong aria-hidden="true">2.2.</strong> WasmEdge 的优势与特点</a></li><li class="chapter-item "><a href="intro/standard.html"><strong aria-hidden="true">2.3.</strong> WebAssembly 的标准扩展</a></li><li class="chapter-item "><a href="intro/proprietary.html"><strong aria-hidden="true">2.4.</strong> WasmEdge 特有的扩展</a></li><li class="chapter-item "><a href="intro/integrations.html"><strong aria-hidden="true">2.5.</strong> 与外部框架的集成</a></li><li class="chapter-item "><a href="intro/faq.html"><strong aria-hidden="true">2.6.</strong> FAQ</a></li></ol></li><li class="chapter-item "><a href="dev.html"><strong aria-hidden="true">3.</strong> 开发 WasmEdge 应用</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="dev/rust.html"><strong aria-hidden="true">3.1.</strong> Rust</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="dev/rust/wasi.html"><strong aria-hidden="true">3.1.1.</strong> 使用操作系统服务</a></li><li class="chapter-item "><a href="dev/rust/tensorflow.html"><strong aria-hidden="true">3.1.2.</strong> Tensorflow 推理</a></li><li class="chapter-item "><a href="dev/rust/networking.html"><strong aria-hidden="true">3.1.3.</strong> 网络</a></li><li class="chapter-item "><a href="dev/rust/command.html"><strong aria-hidden="true">3.1.4.</strong> 使用命令行程序</a></li><li class="chapter-item "><a href="dev/rust/bindgen.html"><strong aria-hidden="true">3.1.5.</strong> rustwasmc</a></li></ol></li><li class="chapter-item "><a href="dev/js.html"><strong aria-hidden="true">3.2.</strong> JavaScript</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="dev/js/quickstart.html"><strong aria-hidden="true">3.2.1.</strong> 快速开始</a></li><li class="chapter-item "><a href="dev/js/networking.html"><strong aria-hidden="true">3.2.2.</strong> 网络</a></li><li class="chapter-item "><a href="dev/js/fetch.html"><strong aria-hidden="true">3.2.3.</strong> Fetch</a></li><li class="chapter-item "><a href="dev/js/tensorflow.html"><strong aria-hidden="true">3.2.4.</strong> Tensorflow 推理</a></li><li class="chapter-item "><a href="dev/js/ssr.html"><strong aria-hidden="true">3.2.5.</strong> 示例：React SSR</a></li><li class="chapter-item "><a href="dev/js/es6.html"><strong aria-hidden="true">3.2.6.</strong> ES6 模块</a></li><li class="chapter-item "><a href="dev/js/npm.html"><strong aria-hidden="true">3.2.7.</strong> NodeJS &amp; NPM 模块</a></li><li class="chapter-item "><a href="dev/js/rust.html"><strong aria-hidden="true">3.2.8.</strong> 用 Rust 实现 JS API</a></li></ol></li><li class="chapter-item "><a href="dev/python.html"><strong aria-hidden="true">3.3.</strong> Python</a></li><li class="chapter-item "><a href="dev/go.html"><strong aria-hidden="true">3.4.</strong> Go</a></li><li class="chapter-item "><a href="dev/swift.html"><strong aria-hidden="true">3.5.</strong> Swift</a></li><li class="chapter-item "><a href="dev/as.html"><strong aria-hidden="true">3.6.</strong> AssemblyScript</a></li><li class="chapter-item "><a href="dev/kotlin.html"><strong aria-hidden="true">3.7.</strong> Kotlin</a></li><li class="chapter-item "><a href="dev/grain.html"><strong aria-hidden="true">3.8.</strong> Grain</a></li></ol></li><li class="chapter-item "><a href="embed.html"><strong aria-hidden="true">4.</strong> 嵌入 WasmEdge 函数</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="embed/c.html"><strong aria-hidden="true">4.1.</strong> C SDK</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="embed/c/ref.html"><strong aria-hidden="true">4.1.1.</strong> API 参考文档</a></li></ol></li><li class="chapter-item "><a href="embed/go.html"><strong aria-hidden="true">4.2.</strong> Go SDK</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="embed/go/app.html"><strong aria-hidden="true">4.2.1.</strong> 嵌入 WASM 应用程序</a></li><li class="chapter-item "><a href="embed/go/function.html"><strong aria-hidden="true">4.2.2.</strong> 嵌入 WASM 函数</a></li><li class="chapter-item "><a href="embed/go/memory.html"><strong aria-hidden="true">4.2.3.</strong> 传递复杂参数</a></li><li class="chapter-item "><a href="embed/go/tensorflow.html"><strong aria-hidden="true">4.2.4.</strong> Tensorflow 调用</a></li><li class="chapter-item "><a href="embed/go/bindgen.html"><strong aria-hidden="true">4.2.5.</strong> 使用 wasm-bindgen</a></li><li class="chapter-item "><a href="embed/go/ref.html"><strong aria-hidden="true">4.2.6.</strong> API 参考文档</a></li></ol></li><li class="chapter-item "><a href="embed/node.html"><strong aria-hidden="true">4.3.</strong> Node.js SDK</a></li><li class="chapter-item "><a href="embed/rust.html"><strong aria-hidden="true">4.4.</strong> Rust SDK</a></li><li class="chapter-item "><a href="embed/python.html"><strong aria-hidden="true">4.5.</strong> Python SDK</a></li></ol></li><li class="chapter-item "><a href="kubernetes.html"><strong aria-hidden="true">5.</strong> 用 Kubernetes 管理 WasmEdge 应用</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="kubernetes/quickstart.html"><strong aria-hidden="true">5.1.</strong> 快速开始</a></li><li class="chapter-item "><a href="kubernetes/demo.html"><strong aria-hidden="true">5.2.</strong> 应用示例</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="kubernetes/demo/wasi.html"><strong aria-hidden="true">5.2.1.</strong> 简单的 WASI 例子</a></li><li class="chapter-item "><a href="kubernetes/demo/server.html"><strong aria-hidden="true">5.2.2.</strong> HTTP 微服务</a></li></ol></li><li class="chapter-item "><a href="kubernetes/container.html"><strong aria-hidden="true">5.3.</strong> 容器 runtimes</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="kubernetes/container/crun.html"><strong aria-hidden="true">5.3.1.</strong> crun</a></li><li class="chapter-item "><a href="kubernetes/container/runc.html"><strong aria-hidden="true">5.3.2.</strong> runc</a></li><li class="chapter-item "><a href="kubernetes/container/youki.html"><strong aria-hidden="true">5.3.3.</strong> youki</a></li></ol></li><li class="chapter-item "><a href="kubernetes/cri.html"><strong aria-hidden="true">5.4.</strong> CRI runtimes</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="kubernetes/cri/crio.html"><strong aria-hidden="true">5.4.1.</strong> CRI-O</a></li><li class="chapter-item "><a href="kubernetes/cri/containerd.html"><strong aria-hidden="true">5.4.2.</strong> containerd</a></li></ol></li><li class="chapter-item "><a href="kubernetes/kubernetes.html"><strong aria-hidden="true">5.5.</strong> Kubernetes</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="kubernetes/kubernetes/kubernetes-crio.html"><strong aria-hidden="true">5.5.1.</strong> Kubernetes + CRI-O</a></li><li class="chapter-item "><a href="kubernetes/kubernetes/kubernetes-containerd.html"><strong aria-hidden="true">5.5.2.</strong> Kubernetes + containerd</a></li><li class="chapter-item "><a href="kubernetes/kubernetes/kind.html"><strong aria-hidden="true">5.5.3.</strong> KinD</a></li><li class="chapter-item "><a href="kubernetes/kubernetes/kubeedge.html"><strong aria-hidden="true">5.5.4.</strong> KubeEdge</a></li><li class="chapter-item "><a href="kubernetes/kubernetes/superedge.html"><strong aria-hidden="true">5.5.5.</strong> SuperEdge</a></li><li class="chapter-item "><a href="kubernetes/kubernetes/openyurt.html"><strong aria-hidden="true">5.5.6.</strong> OpenYurt</a></li></ol></li></ol></li><li class="chapter-item "><a href="frameworks.html"><strong aria-hidden="true">6.</strong> 应用框架与平台</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="frameworks/mesh.html"><strong aria-hidden="true">6.1.</strong> Service mesh 与分布式框架</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="frameworks/mesh/dapr.html"><strong aria-hidden="true">6.1.1.</strong> Dapr</a></li><li class="chapter-item "><a href="frameworks/mesh/mosn.html"><strong aria-hidden="true">6.1.2.</strong> MOSN</a></li><li class="chapter-item "><a href="frameworks/mesh/eventmesh.html"><strong aria-hidden="true">6.1.3.</strong> Apache EventMesh</a></li></ol></li><li class="chapter-item "><a href="frameworks/app.html"><strong aria-hidden="true">6.2.</strong> 应用框架</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="frameworks/app/yomo.html"><strong aria-hidden="true">6.2.1.</strong> YoMo</a></li><li class="chapter-item "><a href="frameworks/app/reactr.html"><strong aria-hidden="true">6.2.2.</strong> Reactr</a></li></ol></li><li class="chapter-item "><a href="frameworks/serverless.html"><strong aria-hidden="true">6.3.</strong> Serverless 平台</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="frameworks/serverless/vercel.html"><strong aria-hidden="true">6.3.1.</strong> Vercel</a></li><li class="chapter-item "><a href="frameworks/serverless/netlify.html"><strong aria-hidden="true">6.3.2.</strong> Netlify</a></li><li class="chapter-item "><a href="frameworks/serverless/aws.html"><strong aria-hidden="true">6.3.3.</strong> AWS</a></li><li class="chapter-item "><a href="frameworks/serverless/tencent.html"><strong aria-hidden="true">6.3.4.</strong> Tencent</a></li><li class="chapter-item "><a href="frameworks/serverless/secondstate.html"><strong aria-hidden="true">6.3.5.</strong> Second State</a></li></ol></li></ol></li><li class="chapter-item "><a href="os.html"><strong aria-hidden="true">7.</strong> 操作系统</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="os/linux.html"><strong aria-hidden="true">7.1.</strong> Linux</a></li><li class="chapter-item "><a href="os/windows.html"><strong aria-hidden="true">7.2.</strong> Windows</a></li><li class="chapter-item "><a href="os/mac.html"><strong aria-hidden="true">7.3.</strong> Mac</a></li><li class="chapter-item "><a href="os/android.html"><strong aria-hidden="true">7.4.</strong> Android</a></li><li class="chapter-item "><a href="os/sel4.html"><strong aria-hidden="true">7.5.</strong> seL4</a></li><li class="chapter-item "><a href="os/openharmony.html"><strong aria-hidden="true">7.6.</strong> Open Harmony</a></li><li class="chapter-item "><a href="os/raspberrypi.html"><strong aria-hidden="true">7.7.</strong> Raspberry Pi</a></li></ol></li><li class="chapter-item "><a href="extend.html"><strong aria-hidden="true">8.</strong> 为 WasmEdge 贡献代码</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="extend/build.html"><strong aria-hidden="true">8.1.</strong> 编译 WasmEdge</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="extend/build_on_mac.html"><strong aria-hidden="true">8.1.1.</strong> 用 Mac 编译</a></li><li class="chapter-item "><a href="extend/build_on_windows.html"><strong aria-hidden="true">8.1.2.</strong> 用 Windows 编译</a></li><li class="chapter-item "><a href="extend/build_for_android.html"><strong aria-hidden="true">8.1.3.</strong> 为 Android 编译</a></li></ol></li><li class="chapter-item "><a href="extend/plugin.html"><strong aria-hidden="true">8.2.</strong> WasmEdge plug-in API</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="extend/plugin/hostfunction.html"><strong aria-hidden="true">8.2.1.</strong> Host 函数</a></li><li class="chapter-item "><a href="extend/plugin/externref.html"><strong aria-hidden="true">8.2.2.</strong> 外部引用</a></li></ol></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">WasmEdge Runtime</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/WasmEdge/WasmEdge" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="快速开始"><a class="header" href="#快速开始">快速开始</a></h1>
<p>WasmEdge 最简单的使用方式是通过 WasmEdge CLI。
开发者们能使用这个命令行工具来运行我们的 WebAssembly 和 JavaScript 示例程序。
之后，我们也可以使用该工具来创建新的 WasmEdge 程序，并将这些程序部署到不同的应用或者框架中运行。</p>
<h2 id="安装"><a class="header" href="#安装">安装</a></h2>
<p>你可以使用以下的单行命令来安装 WasmEdge。
你的系统必须预先安装 <code>git</code> 和 <code>curl</code>。</p>
<pre><code class="language-bash">curl -sSf https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/utils/install.sh | bash
</code></pre>
<p>如果你正在使用Windows 10，你可以使用Windows Package Manager Client (也称winget.exe)来安装WasmEdge。</p>
<pre><code class="language-bash">winget install wasmedge
</code></pre>
<p>如果你希望一并安装 <a href="https://www.secondstate.io/articles/wasi-tensorflow/">Tensorflow 和图像处理扩展</a>，请执行以下命令。它将尝试在你的系统上安装 Tensorflow 和图像共享库。</p>
<pre><code class="language-bash">curl -sSf https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/utils/install.sh | bash -s -- -e all
</code></pre>
<p>执行以下命令能使已安装的二进制文件在当前会话中可用。</p>
<pre><code class="language-bash">source $HOME/.wasmedge/env
</code></pre>
<h2 id="使用-docker-进行安装"><a class="header" href="#使用-docker-进行安装">使用 Docker 进行安装</a></h2>
<p>如果你使用的是 Docker，你可以直接运行 WasmEdge 应用开发镜像（<a href="https://hub.docker.com/repository/docker/wasmedge/appdev_x86_64">x86</a> 和 <a href="https://hub.docker.com/repository/docker/wasmedge/appdev_aarch64">arm64</a>）。这些镜像里包含快速开发 WasmEdge 所需的所有工具。</p>
<pre><code class="language-bash">$ docker pull wasmedge/appdev_x86_64:0.9.0
$ docker run --rm -v $(pwd):/app -it wasmedge/appdev_x86_64:0.9.0
(docker) #
</code></pre>
<h2 id="webassembly-示例"><a class="header" href="#webassembly-示例">WebAssembly 示例</a></h2>
<p>这里有几个 WebAssembly 字节码的示例供您试用新安装的 WasmEdge CLI。</p>
<h3 id="hello-world"><a class="header" href="#hello-world">Hello world</a></h3>
<p><a href="https://github.com/WasmEdge/WasmEdge/raw/master/tools/wasmedge/examples/hello.wasm">hello.wasm</a> 这个 WebAssembly 程序中包含一个 <code>main()</code> 函数。
<a href="https://github.com/second-state/wasm-learning/tree/master/cli/hello">查看该程序的 Rust 源码项目。</a>
它将打印 <code>hello</code>，以及所有的命令行参数。</p>
<pre><code class="language-bash">$ wasmedge hello.wasm second state
hello
second
state
</code></pre>
<h3 id="调用一个-rust-函数"><a class="header" href="#调用一个-rust-函数">调用一个 Rust 函数</a></h3>
<p><a href="https://github.com/WasmEdge/WasmEdge/raw/master/tools/wasmedge/examples/add.wasm">add.wasm</a> 这个 WebAssembly 程序包含一个 <code>add()</code> 函数。
<a href="https://github.com/second-state/wasm-learning/tree/master/cli/add">查看该程序的 Rust 源码项目。</a>
我们在反应器模式下使用 WasmEdge 来调用 <code>add()</code>，并给它 2 个整数作为输入参数。</p>
<pre><code class="language-bash">$ wasmedge --reactor add.wasm add 2 2
4
</code></pre>
<h3 id="调用一个-wat-函数"><a class="header" href="#调用一个-wat-函数">调用一个 WAT 函数</a></h3>
<p>我们手动创建了 <a href="https://github.com/WasmEdge/WasmEdge/raw/master/tools/wasmedge/examples/fibonacci.wat">fibonacci.wat</a> 程序，并使用了 <a href="https://github.com/WebAssembly/wabt">wat2wasm</a> 编译器来构建 <a href="https://github.com/WasmEdge/WasmEdge/raw/master/tools/wasmedge/examples/fibonacci.wasm">fibonacci.wasm</a> 这个 WebAssembly 程序。
它包含了一个 <code>fib()</code> 函数，这个函数以一个整数作为输入参数。我们在反应器模式下使用 WasmEdge 来调用这个导出函数。</p>
<pre><code class="language-bash">$ wasmedge --reactor fibonacci.wasm fib 10
89
</code></pre>
<h3 id="开启统计"><a class="header" href="#开启统计">开启统计</a></h3>
<p>CLI工具支持 <code>--enable-all-statistics</code> 标志，用于开启统计和 gas meter 的相关配置。</p>
<pre><code class="language-bash">$ wasmedge --enable-all-statistics hello.wasm second state
hello
second
state
[2021-12-09 16:03:33.261] [info] ====================  Statistics  ====================
[2021-12-09 16:03:33.261] [info]  Total execution time: 268266 ns
[2021-12-09 16:03:33.261] [info]  Wasm instructions execution time: 251610 ns
[2021-12-09 16:03:33.261] [info]  Host functions execution time: 16656 ns
[2021-12-09 16:03:33.261] [info]  Executed wasm instructions count: 20425
[2021-12-09 16:03:33.261] [info]  Gas costs: 20425
[2021-12-09 16:03:33.261] [info]  Instructions per second: 81177218
[2021-12-09 16:03:33.261] [info] =======================   End   ======================
</code></pre>
<h3 id="开启-gas-limit"><a class="header" href="#开启-gas-limit">开启 gas-limit</a></h3>
<p>CLI工具支持 <code>--gas-limit</code> 标志，用于控制执行的成本。</p>
<pre><code class="language-bash"># cd &lt;path/to/WasmEdge&gt;
$ cd tools/wasmedge/examples
# gas 足够时
$ wasmedge --enable-all-statistics --gas-limit 20425 hello.wasm second state
hello
second
state
[2021-12-09 16:03:33.261] [info] ====================  Statistics  ====================
[2021-12-09 16:03:33.261] [info]  Total execution time: 268266 ns
[2021-12-09 16:03:33.261] [info]  Wasm instructions execution time: 251610 ns
[2021-12-09 16:03:33.261] [info]  Host functions execution time: 16656 ns
[2021-12-09 16:03:33.261] [info]  Executed wasm instructions count: 20425
[2021-12-09 16:03:33.261] [info]  Gas costs: 20425
[2021-12-09 16:03:33.261] [info]  Instructions per second: 81177218
[2021-12-09 16:03:33.261] [info] =======================   End   ======================

# gas 不足时
$ wasmedge --enable-all-statistics --gas-limit 20 hello.wasm second state
[2021-12-23 15:19:06.690] [error] Cost exceeded limit. Force terminate the execution.
[2021-12-23 15:19:06.690] [error]     In instruction: ref.func (0xd2) , Bytecode offset: 0x00000000
[2021-12-23 15:19:06.690] [error]     At AST node: expression
[2021-12-23 15:19:06.690] [error]     At AST node: element segment
[2021-12-23 15:19:06.690] [error]     At AST node: element section
[2021-12-23 15:19:06.690] [error]     At AST node: module
[2021-12-23 15:19:06.690] [info] ====================  Statistics  ====================
[2021-12-23 15:19:06.690] [info]  Total execution time: 0 ns
[2021-12-23 15:19:06.690] [info]  Wasm instructions execution time: 0 ns
[2021-12-23 15:19:06.690] [info]  Host functions execution time: 0 ns
[2021-12-23 15:19:06.690] [info]  Executed wasm instructions count: 21
[2021-12-23 15:19:06.690] [info]  Gas costs: 20
</code></pre>
<h2 id="javascript-示例"><a class="header" href="#javascript-示例">JavaScript 示例</a></h2>
<p>WasmEdge 也可以作为一个高性能、安全、可扩展、易于部署且<a href="https://github.com/second-state/wasmedge-containers-examples">遵循 Kubernetes</a> 的 JavaScript 运行时。</p>
<p><a href="https://github.com/WasmEdge/WasmEdge/raw/master/tools/wasmedge/examples/js/qjs.wasm">qjs.wasm</a> 是一个被编译为 WebAssembly 的 JavaScript 解释器。
<a href="https://github.com/WasmEdge/WasmEdge/raw/master/tools/wasmedge/examples/js/hello.js">hello.js</a> 是一个非常简单的 JavaScript 程序。</p>
<pre><code class="language-bash">$ wasmedge --dir .:. qjs.wasm hello.js 1 2 3
Hello 1 2 3
</code></pre>
<p><a href="https://github.com/WasmEdge/WasmEdge/raw/master/tools/wasmedge/examples/js/qjs_tf.wasm">qjs_tf.wasm</a> 则是一个 WebAssembly 版本的 JavaScript 解释器（带有 <a href="https://www.secondstate.io/articles/wasi-tensorflow/">Tensorflow 扩展</a>）。
要想运行 <a href="https://github.com/WasmEdge/WasmEdge/raw/master/tools/wasmedge/examples/js/qjs_tf.wasm">qjs_tf.wasm</a>，你必须使用 <code>wasmedge-tensorflow-lite</code> 这个命令行工具；这个工具里内置了包含 Tensorflow 扩展的 WasmEdge 构建版本。
你可以下载一个<a href="https://github.com/second-state/wasmedge-quickjs/tree/main/example_js/tensorflow_lite_demo">基于 Tensorflow 的完整 JavaScript 示例</a>来对图像进行分类。</p>
<pre><code class="language-bash"># Download the Tensorflow example
$ wget https://raw.githubusercontent.com/second-state/wasmedge-quickjs/main/example_js/tensorflow_lite_demo/aiy_food_V1_labelmap.txt
$ wget https://raw.githubusercontent.com/second-state/wasmedge-quickjs/main/example_js/tensorflow_lite_demo/food.jpg
$ wget https://raw.githubusercontent.com/second-state/wasmedge-quickjs/main/example_js/tensorflow_lite_demo/lite-model_aiy_vision_classifier_food_V1_1.tflite
$ wget https://raw.githubusercontent.com/second-state/wasmedge-quickjs/main/example_js/tensorflow_lite_demo/main.js

$ wasmedge-tensorflow-lite --dir .:. qjs_tf.wasm main.js
label: Hot dog
confidence: 0.8941176470588236
</code></pre>
<p>继续阅读并学习 WasmEdge。</p>
<ul>
<li><a href="start/install.html">WasmEdge 的安装与卸载</a></li>
<li><a href="start/cli.html">WasmEdge 命令行</a></li>
<li><a href="intro/use.html">WasmEdge 应用场景</a></li>
<li><a href="intro/features.html">WasmEdge 的优势与特点</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="wasmedge-的安装与卸载"><a class="header" href="#wasmedge-的安装与卸载">WasmEdge 的安装与卸载</a></h1>
<h2 id="快速安装"><a class="header" href="#快速安装">快速安装</a></h2>
<p>安装 WasmEdge 最简单的方式是执行以下的命令（前提是你的系统已经安装了 <code>git</code> 和 <code>curl</code>）：</p>
<pre><code class="language-bash">curl -sSf https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/utils/install.sh | bash
</code></pre>
<p>如果你正在使用Windows 10，你可以使用Windows Package Manager Client (也称winget.exe)来安装WasmEdge。</p>
<pre><code class="language-bash">winget install wasmedge
</code></pre>
<p>如果你希望一并安装 <a href="https://www.secondstate.io/articles/wasi-tensorflow/">Tensorflow 和图像处理扩展</a>，请执行以下命令。它将尝试在你的系统上安装 Tensorflow 和图像共享库。</p>
<pre><code class="language-bash">curl -sSf https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/utils/install.sh | bash -s -- -e all
</code></pre>
<p>执行 <code>source $HOME/.wasmedge/env</code> 命令能使已安装的二进制文件在当前会话中可用。</p>
<p>**就这么简单！**你现在可以通过命令行使用 WasmEdge，或者直接将其作为应用打开。要想升级 WasmEdge，你只需要重新执行以上的命令，旧的文件将被覆盖。</p>
<h2 id="为所有用户安装-wasmedge"><a class="header" href="#为所有用户安装-wasmedge">为所有用户安装 WasmEdge</a></h2>
<p>在默认情况下，WasmEdge 将安装在 <code>$HOME/.wasmedge</code> 目录中。你也可以将它安装在系统目录中，如 <code>/usr/local</code>，以便所有用户都能使用 WasmEdge。要想指定一个安装路径，你可以在执行 <code>install.sh</code> 脚本时附上 <code>-p</code> 选项。由于文件将写入系统目录，你需要以 <code>root</code> 用户或 <code>sudo</code> 权限执行以下命令：</p>
<pre><code class="language-bash">curl -sSf https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/utils/install.sh | bash -s -- -p /usr/local
</code></pre>
<p>或者（包含图像扩展）：</p>
<pre><code class="language-bash">curl -sSf https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/utils/install.sh | bash -s -- -e all -p /usr/local
</code></pre>
<h2 id="安装指定版本的-wasmedge"><a class="header" href="#安装指定版本的-wasmedge">安装指定版本的 WasmEdge</a></h2>
<p>你可以将 <code>-v</code> 参数传递给 <code>install.sh</code> 脚本来安装指定版本的 WasmEdge（包括预发行版本和历史版本）。例子如下：</p>
<pre><code class="language-bash">curl -sSf https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/utils/install.sh | bash -s -- -e all -v 0.9.1
</code></pre>
<p>如果你对 <code>master</code> 分支的 <code>HEAD</code> 中的最新的构建感兴趣（也就是 WasmEdge 的 nightly 版本），你可以直接从 Github Action 的 CI artifact 中下载已发布的包。<a href="https://github.com/WasmEdge/WasmEdge/actions/runs/1521549504#artifacts">例子请看这里。</a></p>
<h2 id="安装内容"><a class="header" href="#安装内容">安装内容</a></h2>
<p>安装完成后，你将会得到以下的目录和文件。这里我们假设你将 WasmEdge 安装到 <code>$HOME/.wasmedge</code> 目录中。如果你想进行系统范围的安装，你也可以将安装目录更改为 <code>/usr/local</code>。</p>
<p>如果你使用winget来安装WasmEdge，安装目录在<code>C:\Program Files\WasmEdge</code>。</p>
<ul>
<li><code>$HOME/.wasmedge/bin</code> 目录包含 WasmEdge Runtime CLI 可执行文件。你可以拷贝这些文件并放置到任意目录中。
<ul>
<li><code>wasmedge</code> 工具是标准的 WasmEdge 运行时。你可以在命令行中使用它：<code>wasmedge --dir .:. app.wasm</code>。</li>
<li><code>wasmedgec</code> 工具是 AOT 编译器，它能将 <code>wasm</code> 文件编译为原生 <code>so</code> 文件：<code>wasmedgec app.wasm app.so</code>。之后，<code>wasmedge</code> 就能执行 <code>so</code> 文件了：<code>wasmedge --dir .:. app.so</code>。</li>
<li><code>wasmedge-tensorflow</code> 和 <code>wasmedge-tensorflow-lite</code> 工具是支持 WasmEdge Tensorflow SDK 的 WasmEdge 运行时。</li>
</ul>
</li>
<li><code>$HOME/.wasmedge/lib</code> 目录包含 WasmEdge 的共享库和依赖库。从主程序中启动 WasmEdge 程序和功能会用到这些文件。</li>
<li><code>$HOME/.wasmedge/include</code> 目录包含了 WasmEdge 的头文件。这些文件用于 WasmEdge SDK 中。</li>
</ul>
<h2 id="卸载"><a class="header" href="#卸载">卸载</a></h2>
<p>要想卸载 WasmEdge，你可以执行以下的命令：</p>
<pre><code class="language-bash">bash &lt;(curl -sSf https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/utils/uninstall.sh)
</code></pre>
<p>如果 <code>wasmedge</code> 这个二进制文件不在 <code>PATH</code> 中，且 WasmEdge 不是安装在默认的<code>$HOME/.wasmedge</code> 目录，那么你必须在执行命令时附上安装路径。</p>
<pre><code class="language-bash">bash &lt;(curl -sSf https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/utils/uninstall.sh) -p /path/to/parent/folder
</code></pre>
<p>如果你希望以非交互的方式卸载 WasmEdge，你可以附上 <code>--quick</code> 或 <code>-q</code> 选项。</p>
<pre><code class="language-bash">bash &lt;(curl -sSf https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/utils/uninstall.sh) -q
</code></pre>
<blockquote>
<p>如果 <code>wasmedge</code> 二进制文件的父目录中包含 <code>.wasmedge</code>，那么该目录将会被一并删除。举例来说，该脚本将会完全删除默认的 <code>$HOME/.wasmedge</code> 目录。</p>
</blockquote>
<p>如果你使用的是winget来安装WasmEdge，可以使用下面的命令卸载：</p>
<pre><code class="language-bash">winget uninstall wasmedge
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="使用-docker-进行-wasmedge-应用程序开发"><a class="header" href="#使用-docker-进行-wasmedge-应用程序开发">使用 Docker 进行 WasmEdge 应用程序开发</a></h1>
<p><code>appdev</code> Docker 镜像提供了一个完整的 WasmEdge 应用程序开发环境。要想使用该镜像，请执行以下操作。</p>
<h2 id="使用-x86_64-系统"><a class="header" href="#使用-x86_64-系统">使用 x86_64 系统</a></h2>
<pre><code class="language-bash">$ docker pull wasmedge/appdev_x86_64:0.9.0
$ docker run --rm -v $(pwd):/app -it wasmedge/appdev_x86_64:0.9.0
(docker) #
</code></pre>
<p>查看 <code>appdev</code> 的 <a href="https://github.com/WasmEdge/WasmEdge/blob/master/utils/docker/Dockerfile.appdev_x86_64">Dockerfile</a> 和 <a href="https://hub.docker.com/repository/docker/wasmedge/appdev_x86_64">Docker Hub 镜像</a>。</p>
<h2 id="使用-arm64-系统"><a class="header" href="#使用-arm64-系统">使用 arm64 系统</a></h2>
<pre><code class="language-bash">$ docker pull wasmedge/appdev_aarch64:0.9.0
$ docker run --rm -v $(pwd):/app -it wasmedge/appdev_aarch64:0.9.0
(docker) #
</code></pre>
<p>查看 <code>appdev</code> 的 <a href="https://github.com/WasmEdge/WasmEdge/blob/master/utils/docker/Dockerfile.appdev_aarch64">Dockerfile</a> 和 <a href="https://hub.docker.com/repository/docker/wasmedge/appdev_aarch64">Docker Hub 镜像</a>。</p>
<p>这个 <code>appdev</code> 镜像安装了以下组件：</p>
<ul>
<li>WasmEdge CLI 和共享库；</li>
<li>(仅限 x86_64 系统）包含 Tensorflow 扩展命令行和库的 WasmEdge；</li>
<li>Golang；</li>
<li>Rust；</li>
<li>包含 WasmEdge 插件的 Node.js；</li>
<li>在 <code>/root/examples/</code> 文件夹的一些示例。</li>
</ul>
<h2 id="一些示例"><a class="header" href="#一些示例">一些示例</a></h2>
<p>Hello World 示例。<a href="https://github.com/WasmEdge/WasmEdge/tree/master/tools/wasmedge/examples">查看更多。</a></p>
<pre><code class="language-bash">$ wasmedge hello.wasm world
hello
world
</code></pre>
<p>使用 AOT 来<strong>加快程序的运行速度</strong>。</p>
<pre><code class="language-bash">$ wasmedgec hello.wasm hello.wasm
$ wasmedge hello.wasm world
hello
world
</code></pre>
<p>以下是一些 JavaScript 示例。<a href="https://github.com/WasmEdge/WasmEdge/tree/master/tools/wasmedge/examples/js">查看更多。</a></p>
<pre><code class="language-bash">$ wasmedge --dir .:. qjs.wasm hello.js 1 2 3
Hello 1 2 3

$ wasmedge-tensorflow-lite --dir .:. qjs_tf.wasm tf_image_classify.js
label: Hot dog
confidence: 0.8941176470588236
</code></pre>
<h2 id="构建并发布-appdev-镜像"><a class="header" href="#构建并发布-appdev-镜像">构建并发布 <code>appdev</code> 镜像</a></h2>
<p>运行以下的命令来构建并发布 <code>appdev</code> 镜像：</p>
<h3 id="x86_64-系统"><a class="header" href="#x86_64-系统">x86_64 系统</a></h3>
<pre><code class="language-bash">docker build -t wasmedge/appdev_x86_64:0.9.0 -f Dockerfile.appdev_x86_64 ./
docker image push wasmedge/appdev_x86_64:0.9.0
</code></pre>
<h3 id="arm64--aarch64-系统"><a class="header" href="#arm64--aarch64-系统">ARM64 / aarch64 系统</a></h3>
<pre><code class="language-bash">docker build -t wasmedge/appdev_aarch64:0.9.0 -f Dockerfile.appdev_aarch64 ./
docker image push wasmedge/appdev_aarch64:0.9.0
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="wasmedge-命令行"><a class="header" href="#wasmedge-命令行">WasmEdge 命令行</a></h1>
<p>在<a href="start/install.html">安装 WasmEdge</a> 或启动 <a href="start/docker.html">WasmEdge appdev Docker 容器</a>后，我们可以通过多种方法运行已经编译好的 WebAssembly 程序。</p>
<h2 id="wasmedge"><a class="header" href="#wasmedge">wasmedge</a></h2>
<p><code>wasmedge</code> 二进制文件是一个用来运行 WebAssembly 程序应用的命令行工具（CLI）。</p>
<ul>
<li>假如 WebAssembly 程序包含一个 <code>main()</code> 函数，<code>wasmedge</code> 将在命令模式下将其作为独立程序执行。</li>
<li>假如 WebAssembly 程序包含一个或者多个公共函数，<code>wasmedge</code> 可以在 反应器模式下单独执行每个函数。</li>
</ul>
<h3 id="命令行选项"><a class="header" href="#命令行选项">命令行选项</a></h3>
<p><code>wasmedge</code> 的选项和标志如下所示：</p>
<ol>
<li>（可选）统计信息：
<ul>
<li>用 <code>--enable-time-measuring</code> 来展示执行时间；</li>
<li>用 <code>--enable-gas-measuring</code> 来展示 gas 的消耗量；</li>
<li>用 <code>--enable-instruction-count</code> 来展示执行的指令数量；</li>
<li>或者用 <code>--enable-all-statistics</code> 来启用所有的统计选项。</li>
</ul>
</li>
<li>（可选）资源限制：
<ul>
<li>用 <code>--gas-limit</code> 来限制执行所花费的 gas；</li>
<li>用 <code>--memory-page-limit</code> 来设置每一个内存实例的页限制（大小为 64 KiB）。</li>
</ul>
</li>
<li>(可选) 反应器模式：使用 <code>--reactor</code> 来启用反应器模式；在该模式下，<code>wasmedge</code> 将运行 WebAssembly 程序中指定的函数：
<ul>
<li>WasmEdge 将执行第一个参数（<code>ARG[0]</code>）所指定的函数名；</li>
<li>假如存在名为 <code>_initialize</code> 的导出函数，这个函数将最先以空参的方式执行。</li>
</ul>
</li>
<li>（可选）将目录绑定到 WASI 虚拟文件系统：
<ul>
<li>每一个目录都以 <code>--dir guest_path:host_path</code> 的方式指定。</li>
</ul>
</li>
<li>（可选）环境变量：
<ul>
<li>每一个变量都以 <code>--env NAME=VALUE</code> 的方式指定。</li>
</ul>
</li>
<li>Wasm 文件（<code>/path/to/wasm/file</code>）；</li>
<li>（可选）参数：
<ul>
<li>在反应器模式下，第一个参数将作为函数的名称，<code>ARG[0]</code> 后的其余参数将作为 <code>ARG[0]</code> 函数的参数；</li>
<li>在命令模式下，命令行参数将作为 <code>_start</code> 函数的参数；它们也被称为独立程序的命令行参数。</li>
</ul>
</li>
</ol>
<p>安装完毕后，你可以<a href="start/../index.html">查看并运行我们的示例</a>。</p>
<h2 id="wasmedgec"><a class="header" href="#wasmedgec">wasmedgec</a></h2>
<p><code>wasmedgec</code> 是一个将 WebAssembly 字节码编译成原生机器码的程序（即 AOT 编译器）。
编译好的机器码可以被<a href="start/universal.html">储存在原本的 <code>wasm</code> 文件中</a>，<code>wasmedge</code> 命令行将自动地选择可用的原生机器码。</p>
<p><code>wasmedgec</code> 的选项和标志如下所示：</p>
<ol>
<li>Wasm 输入文件（<code>/path/to/input/wasm/file</code>）；</li>
<li>输出文件的名称（<code>/path/to/output/file</code>）：
<ul>
<li>默认情况下，它将生成<a href="start/universal.html">通用 wasm 二进制格式</a>；</li>
<li>用户也可以通过指定 <code>.so</code>、<code>.dylib</code> 或者 <code>.dll</code> 扩展名来生成原生二进制文件。</li>
</ul>
</li>
</ol>
<pre><code class="language-bash"># 这很慢
wasmedge app.wasm

# AOT 编译
wasmedgec app.wasm app.wasm

# 现在就快多了
wasmedge app.wasm
</code></pre>
<p>在 Linux 系统上，它将会生成一个 <code>so</code> 共享库文件，然后由 <code>wasmedge</code> 运行时执行。</p>
<pre><code class="language-bash">wasmedgec app.wasm app.so
wasmedge app.so
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="通用-wasm-二进制格式"><a class="header" href="#通用-wasm-二进制格式">通用 wasm 二进制格式</a></h1>
<p>WasmEdge 可以将 AOT 编译的原生二进制包装到原始 wasm 文件中的自定义部分。我们将其称之为通用 wasm 二进制格式。</p>
<p>AOT 编译的 wasm 文件与任何 wasm 运行时兼容。然而，当 WasmEdge 运行时执行此 wasm 文件时，WasmEdge 将从自定义部分中提取原生二进制并执行它。</p>
<p>当然，用户仍然可以选择使用 <code>wasmedgec</code> AOT 编译器生成原生二进制文件。
WasmEdge 将以输出文件扩展名来确定生成的文件格式。举例来说，如果你将 <code>wasmedgec</code> 的输出文件扩展名设置为 <code>.so</code>，它将生成 Linux 共享库格式的原生二进制文件；否则，它将默认生成一个通用的 wasm 二进制文件。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="wasmedge-介绍"><a class="header" href="#wasmedge-介绍">WasmEdge 介绍</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="应用场景"><a class="header" href="#应用场景">应用场景</a></h1>
<p>WasmEdge 是由 CNCF 托管的云原生 WebAssembly runtime。它广泛应用于边缘计算、汽车、Jamstack、Serverless、SaaS、服务网格，乃至区块链应用。 WasmEdge 可以进行 AOT （提前编译）编译器优化，是当今市场上最快的 WebAssembly runtime 之一。</p>
<ul>
<li><a href="intro/use/runtime.html">云原生 runtime</a>
<ul>
<li>Dapr</li>
<li>Kubernetes</li>
</ul>
</li>
<li><a href="intro/use/js.html">JavaScript 或 DSL runtime</a>
<ul>
<li>JavaScript</li>
<li>用于图像识别的 DSL</li>
<li>用于聊天机器人的 DSL</li>
</ul>
</li>
<li><a href="intro/use/serverless.html">公有云中的 Serverless 函数即服务</a>
<ul>
<li>AWS Lambda</li>
<li>腾讯 Serverless 函数</li>
<li>Vercel Serverless 函数</li>
<li>Netlify Functions</li>
<li>Second State Functions</li>
</ul>
</li>
<li><a href="intro/use/edge.html">边缘计算</a>
<ul>
<li>YoMo Flow</li>
<li>seL4 micokernel and RTOS</li>
</ul>
</li>
<li><a href="intro/use/saas.html">用于 SaaS 的响应式函数</a>
<ul>
<li>Slack</li>
<li>飞书</li>
</ul>
</li>
</ul>
<p>如果关于 WasmEdge 有什么好主意，马上开 <a href="https://github.com/WasmEdge/WasmEdge/issues">一个 GitHub issue</a> 来一起讨论吧。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="云原生的-runtime"><a class="header" href="#云原生的-runtime">云原生的 runtime</a></h1>
<p>WasmEdge 可以通过其 <a href="intro/use/../../embed/c.html">C</a>, <a href="intro/use/../../embed/go.html">Go</a>, <a href="intro/use/../../embed/rust.html">Rust</a>, 和 <a href="intro/use/../../embed/node.html">JavaScript</a> 的 SDK 嵌入到云原生基础设施中。它也是一个符合 OCI 的 runtime ，可以由 <a href="https://www.secondstate.io/articles/manage-webassembly-apps-in-wasmedge-using-docker-tools/">CRI-O 和 Docker 工具直接管理</a> ，作为 Docker 的轻量级和高性能替代。</p>
<h2 id="dapr-分布式应用-runtime"><a class="header" href="#dapr-分布式应用-runtime">Dapr (分布式应用 Runtime)</a></h2>
<ul>
<li><a href="https://www.secondstate.io/articles/dapr-wasmedge-webassembly/">教程</a></li>
<li><a href="https://github.com/second-state/dapr-wasm">代码教程</a></li>
</ul>
<h2 id="service-mesh-开发进行中"><a class="header" href="#service-mesh-开发进行中">Service mesh (开发进行中)</a></h2>
<ul>
<li>Linkerd</li>
<li>MOSN</li>
<li>Envoy</li>
</ul>
<h2 id="编排和管理"><a class="header" href="#编排和管理">编排和管理</a></h2>
<ul>
<li><a href="https://www.secondstate.io/articles/manage-webassembly-apps-in-wasmedge-using-docker-tools/">Kubernetes</a></li>
<li>KubeEdge</li>
<li>SuperEdge</li>
<li>OpenYurt</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="javascript-或-dsl-runtime"><a class="header" href="#javascript-或-dsl-runtime">JavaScript 或 DSL runtime</a></h1>
<p>为了让 WebAssembly 被开发者广泛采用作为 runtime，它必须支持像 JavaScript 这样的“简单”语言。或者，更棒的是，通过其高级编译器工具链， WasmEdge 可以支持高性能 DSL（领域特定语言），这是专为特定任务设计的低代码解决方案。</p>
<h2 id="javascript"><a class="header" href="#javascript">JavaScript</a></h2>
<p>WasmEdge 可以通过嵌入 JS 执行引擎或解释器来充当云原生 JavaScript runtime 。它比在 Docker 中运行 JS 引擎更快更轻。 WasmEdge 支持 JS API 访问原生扩展库，例如网络 socket 、 tensorflow 和用户定义的共享库。它还允许将 JS 嵌入其他高性能语言（例如 Rust ）或使用 Rust/C 来实现 JS 函数。</p>
<ul>
<li>教程
<ul>
<li><a href="https://www.secondstate.io/articles/run-javascript-in-webassembly-with-wasmedge/">运行 JavaScript</a></li>
<li><a href="https://www.secondstate.io/articles/embed-javascript-in-rust/">在 Rust 中嵌入 JavaScript</a></li>
<li><a href="https://www.secondstate.io/articles/embed-rust-in-javascript/">用 Rust 函数创建 JavaScript API</a></li>
<li><a href="https://www.secondstate.io/articles/call-native-functions-from-javascript/">从 JavaScript调用 C 原生共享库函数</a></li>
</ul>
</li>
<li><a href="https://github.com/WasmEdge/WasmEdge/blob/master/tools/wasmedge/examples/js/README.md">例子</a></li>
<li><a href="https://github.com/second-state/wasmedge-quickjs">WasmEdge的内嵌 QuickJS 引擎</a></li>
</ul>
<h2 id="用于图片识别的-dsl"><a class="header" href="#用于图片识别的-dsl">用于图片识别的 DSL</a></h2>
<p>图像识别 DSL 是一种 YAML 格式，允许用户指定 tensorflow 模型及其参数。 WasmEdge 将图像作为 DSL 的输入并输出检测到的项目名称/标签。</p>
<ul>
<li>示例: <a href="https://github.com/second-state/wasm-learning/blob/master/cli/classify_yml/config/food.yml">运行 YMAL 以识别图片中的食品</a></li>
</ul>
<h2 id="用于聊天机器人的-dsl"><a class="header" href="#用于聊天机器人的-dsl">用于聊天机器人的 DSL</a></h2>
<p>聊天机器人 DSL 函数接受输入字符串并回复字符串进行响应。 DSL 指定了聊天机器人的内部状态转换，以及用于语言理解的 AI 模型。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="公有云中的-serverless-函数即服务"><a class="header" href="#公有云中的-serverless-函数即服务">公有云中的 Serverless 函数即服务</a></h1>
<p>WasmEdge 与现有的 Serverless 或 Jamstack 平台配合使用，为函数提供高性能、可移植和安全的 runtime。即使在这些平台上的 Docker 或 microVM 中运行，也能提供显著的好处。</p>
<h2 id="aws-lambda"><a class="header" href="#aws-lambda">AWS Lambda</a></h2>
<ul>
<li><a href="https://www.cncf.io/blog/2021/08/25/webassembly-serverless-functions-in-aws-lambda/">教程</a></li>
<li><a href="https://github.com/second-state/aws-lambda-wasm-runtime">代码模板</a></li>
</ul>
<h2 id="腾讯-serverless-函数"><a class="header" href="#腾讯-serverless-函数">腾讯 Serverless 函数</a></h2>
<ul>
<li><a href="https://my.oschina.net/u/4532842/blog/5172639">中文教程</a></li>
<li><a href="https://github.com/second-state/tencent-scf-wasm-runtime">代码模板</a></li>
</ul>
<h2 id="vercel-serverless-函数"><a class="header" href="#vercel-serverless-函数">Vercel Serverless 函数</a></h2>
<ul>
<li><a href="https://www.secondstate.io/articles/vercel-wasmedge-webassembly-rust/">教程</a></li>
<li><a href="https://github.com/second-state/vercel-wasm-runtime">代码模版</a></li>
</ul>
<h2 id="netlify-functions"><a class="header" href="#netlify-functions">Netlify Functions</a></h2>
<ul>
<li><a href="https://www.secondstate.io/articles/netlify-wasmedge-webassembly-rust-serverless/">教程</a></li>
<li><a href="https://github.com/second-state/netlify-wasm-runtime">代码模版</a></li>
</ul>
<h2 id="second-state-functions"><a class="header" href="#second-state-functions">Second State Functions</a></h2>
<ul>
<li><a href="https://www.secondstate.io/faas/">教程</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="边缘计算"><a class="header" href="#边缘计算">边缘计算</a></h1>
<p>WasmEdge 非常适合在任务关键的边缘设备或边缘网络上运行。</p>
<h2 id="yomo-flow"><a class="header" href="#yomo-flow">YoMo Flow</a></h2>
<p>YoMo 是一种用于远边缘（far edge）网络的高性能数据流框架。 WasmEdge 集成到 YoMo 中以运行用户定义的工作负载，例如在工厂装配线上进行的图像识别。</p>
<ul>
<li><a href="https://www.secondstate.io/articles/yomo-wasmedge-real-time-data-streams/">教程</a></li>
<li><a href="https://github.com/yomorun/yomo-wasmedge-tensorflow">代码模板</a></li>
</ul>
<h2 id="sel4-微内核操作系统"><a class="header" href="#sel4-微内核操作系统">seL4 微内核操作系统</a></h2>
<p>seL4 是一个高度安全的实时操作系统。 WasmEdge 是唯一可以在 seL4 上运行的 WebAssembly runtime，它以本机速度运行。我们还提供了一个管理工具来支持 wasm 模块的 OTA 部署。</p>
<ul>
<li><a href="https://github.com/second-state/wasmedge-seL4">Demo</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="saas-里的嵌入式函数"><a class="header" href="#saas-里的嵌入式函数">SaaS 里的嵌入式函数</a></h1>
<p>WasmEdge 可以使用 Serverless 函数而不是传统的网络 API 来支持定制的 SaaS 扩展或应用程序。这极大地提高了 SaaS 用户和开发者的生产力。</p>
<h2 id="slack"><a class="header" href="#slack">Slack</a></h2>
<ul>
<li><a href="http://reactor.secondstate.info/en/docs/user_guideline.html">为 Slack 创建 serverless 聊天机器人</a></li>
</ul>
<h2 id="飞书"><a class="header" href="#飞书">飞书</a></h2>
<p>飞书为字节跳动旗下的聊天软件。</p>
<ul>
<li><a href="http://reactor.secondstate.info/zh/docs/user_guideline.html">为飞书创建 serverless 聊天机器人</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="wasmedge-的优势与特点"><a class="header" href="#wasmedge-的优势与特点">WasmEdge 的优势与特点</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="webassembly-的标准扩展"><a class="header" href="#webassembly-的标准扩展">WebAssembly 的标准扩展</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="wasmedge-特有的扩展"><a class="header" href="#wasmedge-特有的扩展">WasmEdge 特有的扩展</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="wasmedge-特有的集成"><a class="header" href="#wasmedge-特有的集成">WasmEdge 特有的集成</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="faq"><a class="header" href="#faq">FAQ</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="开发-wasmedge-应用"><a class="header" href="#开发-wasmedge-应用">开发 WasmEdge 应用</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rust"><a class="header" href="#rust">Rust</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="使用操作系统服务"><a class="header" href="#使用操作系统服务">使用操作系统服务</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tensorflow"><a class="header" href="#tensorflow">Tensorflow</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="网络"><a class="header" href="#网络">网络</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="使用命令行程序"><a class="header" href="#使用命令行程序">使用命令行程序</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rustwasmc"><a class="header" href="#rustwasmc">rustwasmc</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="javascript-1"><a class="header" href="#javascript-1">JavaScript</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="快速开始-1"><a class="header" href="#快速开始-1">快速开始</a></h1>
<p>首先，让我们为 WasmEdge 构建一个基于 WebAssembly 的 JavaScript 解释器程序。这个程序基于 <a href="https://bellard.org/quickjs/">QuickJS</a> 和 WasmEdge 的一些扩展程序，比如 <a href="https://github.com/second-state/wasmedge_wasi_socket">network sockets</a> 和 <a href="https://www.secondstate.io/articles/wasi-tensorflow/">Tensorflow 推理</a>，并且这些扩展都是作为 JavaScript API 被合并到解释器中的。首先你需要<a href="https://www.rust-lang.org/tools/install">安装 rust</a> 来构建这个解释器。</p>
<blockquote>
<p>如果你只是想要使用这个解释器来运行 JavaScript 程序，那就可以跳过这部分了。否则，先确保你已经安装了 <a href="https://www.rust-lang.org/tools/install">Rust</a> 和 <a href="dev/js/../../start/install.html">WasmEdge</a>。</p>
</blockquote>
<p>Fork 或者克隆 <a href="https://github.com/second-state/wasmedge-quickjs">wasmedge-quickjs</a> 这个 Github repo 开始教程。</p>
<pre><code class="language-bash">git clone https://github.com/second-state/wasmedge-quickjs
</code></pre>
<p>按照这个 repo 中的介绍，你将能够为 WasmEdge 构建一个 JavaScript 解释器。</p>
<pre><code class="language-bash"># Install GCC
sudo apt update
sudo apt install build-essential

# Install wasm32-wasi target for Rust
rustup target add wasm32-wasi

# Build the QuickJS JavaScript interpreter
cargo build --target wasm32-wasi --release
</code></pre>
<p>构建成功后，基于 WebAssembly 的解释器程序位于 build target 目录中，你现在可以尝试执行一个简单的 &quot;hello world&quot; JavaScript 程序 (<a href="https://github.com/second-state/wasmedge-quickjs/blob/main/example_js/hello.js">example_js/hello.js</a>)，它会在终端中打印出命令行参数。</p>
<pre><code class="language-javascript">import * as os from 'os';
import * as std from 'std';

args = args.slice(1);
print('Hello', ...args);
setTimeout(() =&gt; {
  print('timeout 2s');
}, 2000);
</code></pre>
<p>接下来输入下面的命令在 WasmEdge 的 QuickJS runtime 运行 <code>hello.js</code> 文件。</p>
<pre><code class="language-bash">$ cd example_js
$ wasmedge --dir .:. ../target/wasm32-wasi/release/wasmedge_quickjs.wasm hello.js WasmEdge Runtime
Hello WasmEdge Runtime
</code></pre>
<blockquote>
<p>注意：命令行里的 <code>--dir .:.</code> 这个参数是为了让 <code>wasmedge</code> 命令有权限在文件系统中读取本地目录里的 <code>hello.js</code> 文件。我们将在下面的章节中继续用到 <code>--dir .:.</code> 这个参数。</p>
</blockquote>
<h2 id="更快地执行"><a class="header" href="#更快地执行">更快地执行</a></h2>
<p>WasmEdge 提供了一个 <code>wasmedgec</code> 实用程序来编绎并且添加一个本地机器代码部分到 <code>wasm</code> 文件中。你可以使用 <code>wasmedge</code> 来运行本地检测到的 <code>wasm</code> 文件，从而获得更快的性能。</p>
<pre><code class="language-bash">wasmedgec ../../target/wasm32-wasi/release/wasmedge_quickjs.wasm wasmedge_quickjs.wasm
wasmedge --dir .:. wasmedge_quickjs.wasm hello.js
</code></pre>
<p>接下来，我们将讨论关于在 WasmEdger 中使用 JavaScript 的更多高级案例。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="网络-1"><a class="header" href="#网络-1">网络</a></h1>
<p>QuickJS WasmEdge Runtime 支持 WasmEdge 的<a href="https://github.com/second-state/wasmedge_wasi_socket">网络 sockets 拓展</a>， 所以 JavaScript 程序也可以在网络上建立 HTTP 连接。此文将向你展示相关的 <a href="https://github.com/second-state/wasmedge-quickjs/blob/main/example_js/wasi_http_client.js">HTTP 客户端</a>和 <a href="https://github.com/second-state/wasmedge-quickjs/blob/main/example_js/wasi_http_echo.js">HTTP 服务端</a>例子.</p>
<blockquote>
<p>WasmEdge 的网络 API 是非阻塞的，所以能够开发出强异步 I/O 交互的应用。当网络请求 handler 正在创建一个对外的请求并等待服务应答的时候，应用仍然可以处理另外一个进来的请求。这让单线程应用可以并发处理多个请求。</p>
</blockquote>
<h2 id="javascript-客户端网络通讯例子"><a class="header" href="#javascript-客户端网络通讯例子">JavaScript 客户端网络通讯例子</a></h2>
<p>以下是一个使用 JavaScript 编写的异步客户端的例子。你可以在 <a href="https://github.com/second-state/wasmedge-quickjs/blob/main/example_js/wasi_http_client.js">example_js/wasi_http_client.js</a> 中找到源码。以下的代码会向你展示如何发送一个异步 HTTP GET 请求。</p>
<pre><code class="language-javascript">async function get_test() {
  try {
    let ss = await net.connect('152.136.235.225:80');
    let req = new http.WasiRequest();
    req.headers = { 'Host': '152.136.235.225' };
    req.uri = '/get?a=123';
    req.method = 'GET';
    ss.write(req.encode());
    print('wait get');
    await handle_response(ss);
    print('get end');

  } catch (e) {
    print('catch:', e);
  }
}
</code></pre>
<p>以上代码可以在等待服务端应答的同时处理其他任务。当服务端返回数据后，<code>handle_response()</code> 会被异步调用，处理好数据后就会将内容打印出来。</p>
<pre><code class="language-javascript">async function handle_response(s) {
  let buf = new http.Buffer();
  let resp = undefined;
  while (true) {
    buf.append(await s.read());
    if (resp == undefined) {
      resp = buf.parseResponse();
    }
    if (resp instanceof http.WasiResponse) {
      let resp_length = resp.bodyLength;
      if (typeof (resp_length) === &quot;number&quot;) {
        if (buf.length &gt;= resp.bodyLength) {
          print('resp.body');
          print(newStringFromUTF8(buf.buffer));
          break;
        }
      } else {
        throw new Error('no support');
      }
    }
  }
}
</code></pre>
<p>使用以下 CLI 命令，就可以在 WasmEdge runtime 中运行以上的 JavaScript 代码。</p>
<pre><code class="language-bash">cd example_js
wasmedge --dir .:. ../target/wasm32-wasi/release/wasmedge_quickjs.wasm wasi_http_client.js
</code></pre>
<p>将会有如下内容被打印出来。</p>
<pre><code class="language-json">{
  &quot;args&quot;: {
    &quot;a&quot;: &quot;123&quot;
  }, 
  &quot;data&quot;: &quot;hello&quot;, 
  &quot;files&quot;: {}, 
  &quot;form&quot;: {}, 
  &quot;headers&quot;: {
    &quot;Content-Length&quot;: &quot;5&quot;, 
    &quot;Host&quot;: &quot;152.136.235.225&quot;
  }, 
  &quot;json&quot;: null, 
  &quot;origin&quot;: &quot;20.124.39.106&quot;, 
  &quot;url&quot;: &quot;http://152.136.235.225/post?a=123&quot;
}
</code></pre>
<p>以上应用例子发出了两个 HTTP 请求，一个是 <code>GET</code> 请求另一个是 <code>POST</code> 请求。该应用会异步等待这两个请求的应答数据，并且哪一个先从服务端返回就先会处理哪个。从日志中你可以看到这两个请求的 handlers 是交错执行的。</p>
<h2 id="javascript-网络服务例子"><a class="header" href="#javascript-网络服务例子">JavaScript 网络服务例子</a></h2>
<p>以下的例子是使用 JavaScript 运行了一个监听 8000 端口的 TCP 服务器。接收到的网络请求都会被异步处理。你可以在 <a href="https://github.com/second-state/wasmedge-quickjs/blob/main/example_js/wasi_net_echo.js">example_js/wasi_net_echo.js</a> 中找到源码。</p>
<pre><code class="language-javascript">import * as net from 'wasi_net';

async function handle_client(cs) {
  while (true) {
    try {
      let d = await cs.read();
      if (d.byteLength &lt;= 0) {
        break;
      }
      let s = newStringFromUTF8(d);
      cs.write('echo:' + s);
    } catch (e) {
      print(e);
    }
  }
}

async function server_start() {
  let s = new net.WasiTcpServer(8000);
  for (var i = 0; i &lt; 100; i++) {
    let cs = await s.accept();
    handle_client(cs);
  }
}

server_start();
</code></pre>
<p>调用 <code>server_start()</code> 方法会在 8000 端口启动一个监听服务。当一个请求进入，会异步传给 <code>handle_client()</code> function 函数处理。这意味着当应用返回应答数据后，它又可以处理下一个进来的请求了。</p>
<p>使用以下 CLI 命令，就可以在 WasmEdge runtime 中运行这段 JavaScript 代码。因为它将作为一个服务运行，你最好是以后台应用的形式启动。</p>
<pre><code class="language-bash">cd example_js
nohup wasmedge --dir .:. ../target/wasm32-wasi/release/wasmedge_quickjs.wasm wasi_net_echo.js &amp;
</code></pre>
<p>然后你就可以向它发出网络请求，观察运行效果。</p>
<pre><code class="language-bash">$ curl -d &quot;WasmEdge&quot; -X POST http://localhost:8000
echo:WasmEdge
</code></pre>
<p>WasmEdge 的 <code>wasi_net</code> 包为 JavaScript 应用提供了一种自适应的动态网络栈。在很多高级用法中，我们基于这个包，设计了很多抽象良好的 API。在下一章节，我们会带着具体的常见应用，向你展示如何处理 HTTP 请求。在 <a href="dev/js/ssr.html">React 服务器渲染文章</a>中，我们还将会讨论一下如何基于这种异步网络的 API 来创建一个 React 服务器渲染功能。</p>
<h2 id="javascript-http-服务器例子"><a class="header" href="#javascript-http-服务器例子">JavaScript HTTP 服务器例子</a></h2>
<p>假如你已经知道服务器的请问和应答都是基于 HTTP 协议的，这里有一些增强方法可以帮到你更好地处理这些请求。你可以在 <a href="https://github.com/second-state/wasmedge-quickjs/blob/main/example_js/wasi_http_echo.js">example_js/wasi_http_echo.js</a> 中找到源码。</p>
<pre><code class="language-javascript">import * as http from 'wasi_http';
import * as net from 'wasi_net';

async function handle_client(cs, handler_req) {
  let buffer = new http.Buffer();

  while (true) {
    try {
      let d = await cs.read();
      if (d.byteLength &lt;= 0) {
        return;
      }
      buffer.append(d);
      let req = buffer.parseRequest();
      if (req instanceof http.WasiRequest) {
        handler_req(cs, req);
        break;
      }
    } catch (e) {
      print(e);
    }
  }
}

function handler_req(cs, req) {
  print(&quot;version=&quot;, req.version);
  print(&quot;uri=&quot;, req.uri);
  print(&quot;method=&quot;, req.method);
  print(&quot;headers=&quot;, Object.keys(req.headers));
  print(&quot;body=&quot;, newStringFromUTF8(req.body));

  let resp = new http.WasiResponse();
  let body = 'echo:' + newStringFromUTF8(req.body);
  let r = resp.encode(body);
  cs.write(r);
}

async function server_start() {
  try {
    let s = new net.WasiTcpServer(8000);
    for (var i = 0; i &lt; 100; i++) {
      let cs = await s.accept();
      try {
        handle_client(cs, handler_req);
      } catch (e) {
        print(e);
      }
    }
  } catch (e) {
    print(e);
  }
}

server_start();
</code></pre>
<p><code>server_start()</code> 方法会启动一个监听 8000 端口的服务。当请求进来，会被传给 <code>handle_client()</code> 方法来处理。当请求是合法的 HTTP 请求，对应的 handler 方法会调用 <code>handle_req()</code> 来解析对应的字段，组装新的 HTTP 应答，然后异步把应答数据发送回去。这意味着当应用发送完数据，又能继续处理下一个进来的请求了。</p>
<p>使用以下 CLI 命令，就可以在 WasmEdge runtime 中运行这段 JavaScript 代码。因为它将作为一个服务运行，你最好是以后台应用的形式运行。</p>
<pre><code class="language-bash">cd example_js
nohup wasmedge --dir .:. ../target/wasm32-wasi/release/wasmedge_quickjs.wasm wasi_http_echo.js &amp;
</code></pre>
<p>然后你就可以向它发出网络请求，观察运行效果。</p>
<pre><code class="language-bash">$ curl -d &quot;WasmEdge&quot; -X POST http://localhost:8000
echo:WasmEdge
</code></pre>
<p>在异步 HTTP 网络编程中，开发者可以安全并高效地在 WasmEdge 中使用 JavaScript 创建强交互的应用，例如数据库驱动的微服务。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="fetch-api"><a class="header" href="#fetch-api"><code>fetch</code> API</a></h1>
<p><code>fetch</code> API 被广泛用于浏览器和基于 Node 的 JavaScript 应用程序中，用来通过网络获取内容。WasmEdge QuickJS Runtime 在其非阻塞的 Aysnc Socket API 的基础上支持 <code>fetch</code> API。这使得很多 JS 的 API 和模块可以开箱即用。</p>
<p><a href="https://github.com/second-state/wasmedge-quickjs/blob/main/example_js/wasi_http_fetch.js">example_js/wasi_http_fetch.js</a> 例子展示了如何在 WasmEdge 中使用 <code>fetch</code> API。下面的代码片段显示了一个异步的 HTTP GET 请求。当程序等待和处理 GET 内容的时候，它可以开始另一个请求。</p>
<pre><code class="language-javascript">import { fetch } from 'http'

async function test_fetch() {
    try {
        let r = await fetch(&quot;http://152.136.235.225/get?id=1&quot;)
        print('test_fetch\n', await r.text())
    } catch (e) {
        print(e)
    }
}
test_fetch()
</code></pre>
<p>下面的代码片段显示了如何向远程服务器发送同步的 HTTP POST 请求。</p>
<pre><code class="language-javascript">async function test_fetch_post() {
    try {
        let r = await fetch(&quot;http://152.136.235.225/post&quot;, { method: 'post', 'body': 'post_body' })
        print('test_fetch_post\n', await r.text())
    } catch (e) {
        print(e)
    }
}
test_fetch_post()
</code></pre>
<p>如下是一个异步的 HTTP PUT 请求。</p>
<pre><code class="language-javascript">async function test_fetch_put() {
    try {
        let r = await fetch(&quot;http://152.136.235.225/put&quot;,
            {
                method: &quot;put&quot;,
                body: JSON.stringify({ a: 1 }),
                headers: { 'Context-type': 'application/json' }
            })
        print('test_fetch_put\n', await r.text())
    } catch (e) {
        print(e)
    }
}
test_fetch_put()
</code></pre>
<p>要运行这些例子，使用以下 WasmEdge CLI 命令。</p>
<pre><code class="language-bash">cd example_js
wasmedge --dir .:. ../target/wasm32-wasi/release/wasmedge_quickjs.wasm wasi_http_fetch.js
</code></pre>
<p>你可以看到打印到控制台的 HTTP 响应。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tensorflow-1"><a class="header" href="#tensorflow-1">TensorFlow</a></h1>
<p>解释器支持 WasmEdge TensorFlow lite 的推断扩展，从而使你的 JavaScript 能够运行 ImageNet 模型来进行图像分类。本文会向你展示如何在你的 javascript 程序中使用基于 WasmEdge 的 TensorFlow Rust SDK。</p>
<p>下面是一个 JavaScript 的示例。全部代码可参考这里 <a href="https://github.com/second-state/wasmedge-quickjs/tree/main/example_js/tensorflow_lite_demo">example_js/tensorflow_lite_demo/</a></p>
<pre><code class="language-javascript">import {Image} from 'image';
import * as std from 'std';
import {TensorflowLiteSession} from 'tensorflow_lite';

let img = new Image('food.jpg');
let img_rgb = img.to_rgb().resize(192, 192);
let rgb_pix = img_rgb.pixels();

let session = new TensorflowLiteSession(
    'lite-model_aiy_vision_classifier_food_V1_1.tflite');
session.add_input('input', rgb_pix);
session.run();
let output = session.get_output('MobilenetV1/Predictions/Softmax');
let output_view = new Uint8Array(output);
let max = 0;
let max_idx = 0;
for (var i in output_view) {
  let v = output_view[i];
  if (v &gt; max) {
    max = v;
    max_idx = i;
  }
}
let label_file = std.open('aiy_food_V1_labelmap.txt', 'r');
let label = '';
for (var i = 0; i &lt;= max_idx; i++) {
  label = label_file.getline();
}
label_file.close();

print('label:');
print(label);
print('confidence:');
print(max / 255);
</code></pre>
<p>为了在 WasmEdge runtime 中运行 JavaScript，你可以在 CLI 中执行如下操作，这样就可以重新构建一个包含 TensorFlow 的 QuickJS 引擎，然后就可以在 JavaScript 应用中调用 TensorFlow API 了。</p>
<pre><code class="language-bash">$ cargo build --target wasm32-wasi --release --features=tensorflow
... ...
$ cd example_js/tensorflow_lite_demo
$ wasmedge-tensorflow-lite --dir .:. ../../target/wasm32-wasi/release/wasmedge_quickjs.wasm main.js
label:
Hot dog
confidence:
0.8941176470588236
</code></pre>
<blockquote>
<p>注意: 命令行中的 <code>--dir .:.</code> 是为了给 wasmedge 开启本地文件读取权限， 以便正常读取到 <code>main.js</code> 文件.</p>
</blockquote>
<h2 id="注意"><a class="header" href="#注意">注意</a></h2>
<ul>
<li>编译器标志 <code>--features=tensorflow</code> 构建了一个包含 WasmEdge TensorFlow 扩展的 QuickJS 引擎。</li>
<li>程序 <code>wasmedge-tensorflow-lite</code> 是 WasmEdge 包的一部分。它是内含有 Tensorflow 扩展的 WasmEdge runtime。</li>
</ul>
<p>你现在应该可以看到食物的名字了，它被 TensorFlow lite ImageNet 模型识别出来了。</p>
<h2 id="使其更快"><a class="header" href="#使其更快">使其更快</a></h2>
<p>以上 Tensorflow 推断示例执行一次需要耗时 1-2 秒. 在 web 应用场景中虽然可以接受，但是仍然有改进空间。回想一下，WasmEdge 是如今最快的 WebAssembly runtime，这是由于它的提前编译（AOT, Ahead-of-time compiler）优化。WasmEdge 提供了一个 <code>wasmedgec</code> 实用程序去编译和添加原生机器码段，并放到 <code>wasm</code> 文件里，从而达到更快的性能。</p>
<p>以下示例采用了 <code>wasmedge</code> 和 <code>wasmedgec</code> 的扩展版本以支持 WasmEdge Tensorflow 扩展。</p>
<pre><code class="language-bash">$ cd example_js/tensorflow_lite_demo
$ wasmedgec-tensorflow ../../target/wasm32-wasi/release/wasmedge_quickjs.wasm wasmedge_quickjs.wasm
$ wasmedge-tensorflow-lite --dir .:. wasmedge_quickjs.wasm main.js
label:
Hot dog
confidence:
0.8941176470588236
</code></pre>
<p>你可以看到，图像识别任务在 0.1 秒内就完成了。它的性能至少提高了 10 倍。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="react-ssr"><a class="header" href="#react-ssr">React SSR</a></h1>
<p><a href="https://medium.com/jspoint/a-beginners-guide-to-react-server-side-rendering-ssr-bf3853841d55">React 服务端渲染（SSR）</a> 是 JavaScript 在 BFF（为前端提供服务的后端）函数中一种常见的使用场景。
和在浏览器中渲染 HTML DOM 元素的方式不同，这种技术使用 React 框架在服务端就生成了 HTML 元素，以此来加快应用的加载速度。
在 <a href="https://jamstack.org/">Jamstack</a> 应用中，这是使用 serverless 函数时一种较理想的方式。</p>
<p>在这篇文章中，我们将向你展示如何使用 WasmEdge 的 QuickJS 运行时来实现 React SSR 的能力。与 Docker + Linux + nodejs + v8 的方案相比，WasmEdge 要轻量得多（仅 1% 的占用），也更安全，能够提供更好的资源隔离和管理机制，并有着和非 JIT（同时是安全的）近似的性能。</p>
<p>本文将包含对静态渲染和流式渲染两种渲染方式的介绍。静态渲染相对容易理解和实现。而流式渲染则可以提供更好的用户体验，因为用户在浏览器前等待结果时，可以优先看到生成的部分内容。</p>
<h2 id="静态渲染"><a class="header" href="#静态渲染">静态渲染</a></h2>
<p>本示例的源代码可以在 GitHub 仓库的 <a href="https://github.com/second-state/wasmedge-quickjs/tree/main/example_js/react_ssr">example_js/react_ssr</a> 文件夹中找到。它展示了运行于 WasmEdge 的 JavaScript 应用程序，是如何编排 HTML 模板并将其渲染成 HTML 字符串的。</p>
<p>文件 <a href="https://github.com/second-state/wasmedge-quickjs/blob/main/example_js/react_ssr/component/Home.jsx">component/Home.jsx</a> 里是 React 的主页模板。</p>
<pre><code class="language-javascript">import React from 'react';
import Page from './Page.jsx';
class Home extends React.Component {
  render() {
    const { dataList = [] } = this.props;
    return (
      &lt;div&gt;
        &lt;div&gt;This is home&lt;/div&gt;
        &lt;Page&gt;&lt;/Page&gt;
      &lt;/div&gt;
    );
  }
};

export default Home;
</code></pre>
<p><code>Home.jsx</code> 中会包含 <a href="https://github.com/second-state/wasmedge-quickjs/blob/main/example_js/react_ssr/component/Page.jsx">Page.jsx</a> 提供的模板，作为页面的一部分。</p>
<pre><code class="language-javascript">import React from 'react';

class Page extends React.Component {
  render() {
    const { dataList = [] } = this.props;
    return (
      &lt;div&gt;
        &lt;div&gt;This is page&lt;/div&gt;
      &lt;/div&gt;
    );
  }
};

export default Page;
</code></pre>
<p>文件 <a href="https://github.com/second-state/wasmedge-quickjs/blob/main/example_js/react_ssr/main.js">main.js</a> 会调用 React 将模板渲染成 HTML。</p>
<pre><code class="language-javascript">import React from 'react';
import {renderToString} from 'react-dom/server';

import Home from './component/Home.jsx';

const content = renderToString(React.createElement(Home));
console.log(content);
</code></pre>
<p>目录中的 <a href="https://github.com/second-state/wasmedge-quickjs/blob/main/example_js/react_ssr/rollup.config.js">rollup.config.js</a> 文件和 <a href="https://github.com/second-state/wasmedge-quickjs/blob/main/example_js/react_ssr/package.json">package.json</a> 文件用于把 React SSR 的所有依赖和组件打包成一个 WasmEdge 可用的 JavaScript 文件。你可以使用 <code>npm</code> 命令来进行构建，构建产物会输出到 <code>dist/main.js</code> 文件里。</p>
<pre><code class="language-bash">npm install
npm run build
</code></pre>
<p>要运行这个例子，请在命令行中执行以下命令。你会看到，所有的模板成功合成了一个 HTML 字符串。</p>
<pre><code class="language-bash">$ cd example_js/react_ssr
$ wasmedge --dir .:. ../../target/wasm32-wasi/release/wasmedge_quickjs.wasm dist/main.js
&lt;div data-reactroot=&quot;&quot;&gt;&lt;div&gt;This is home&lt;/div&gt;&lt;div&gt;&lt;div&gt;This is page&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;
</code></pre>
<blockquote>
<p>注意： 命令行里的 <code>--dir .:.</code> 会给 WasmEdge 读取本地文件系统下目录的权限，以此读取 <code>dist/main.js</code> 文件。</p>
</blockquote>
<h2 id="流式渲染"><a class="header" href="#流式渲染">流式渲染</a></h2>
<p>本示例的源代码可以在 GitHub 仓库的 <a href="https://github.com/second-state/wasmedge-quickjs/tree/main/example_js/react_ssr_stream">example_js/react_ssr_stream</a> 文件夹中找到。它展示了运行于 WasmEdge 的 JavaScript 应用程序，是如何流式地把 HTML 模板渲染成 HTML 字符串的。</p>
<p>文件 <a href="https://github.com/second-state/wasmedge-quickjs/blob/main/example_js/react_ssr_stream/component/LazyHome.jsx">component/LazyHome.jsx</a> 是 React 的主页模板。当外层的 HTML 渲染好并返回给用户 2s 之后，它才会开始“懒”加载内层的页面模板。</p>
<pre><code class="language-javascript">import React, { Suspense } from 'react';

async function sleep(ms) {
  return new Promise((r, _) =&gt; {
    setTimeout(() =&gt; r(), ms)
  });
}

async function loadLazyPage() {
  await sleep(2000);
  return await import('./LazyPage.jsx');
}

class LazyHome extends React.Component {
  render() {
    let LazyPage1 = React.lazy(() =&gt; loadLazyPage());
    return (
      &lt;html lang=&quot;en&quot;&gt;
        &lt;head&gt;
          &lt;meta charSet=&quot;utf-8&quot; /&gt;
          &lt;title&gt;Title&lt;/title&gt;
        &lt;/head&gt;
        &lt;body&gt;
          &lt;div&gt;
            &lt;div&gt; This is LazyHome &lt;/div&gt;
            &lt;Suspense fallback={&lt;div&gt; loading... &lt;/div&gt;}&gt;
              &lt;LazyPage1 /&gt;
            &lt;/Suspense&gt;
          &lt;/div&gt;
        &lt;/body&gt;
      &lt;/html&gt;
    );
  }
}

export default LazyHome;
</code></pre>
<p><a href="https://github.com/second-state/wasmedge-quickjs/blob/main/example_js/react_ssr_stream/component/LazyPage.jsx">LazyPage.jsx</a> 里就是内层的模板。只有在外层页面返回给用户 2s 之后，它才会被渲染。</p>
<pre><code class="language-javascript">import React from 'react';

class LazyPage extends React.Component {
  render() {
    return (
      &lt;div&gt;
        &lt;div&gt;
          This is lazy page
        &lt;/div&gt;
      &lt;/div&gt;
    );
  }
}

export default LazyPage;
</code></pre>
<p><a href="https://github.com/second-state/wasmedge-quickjs/blob/main/example_js/react_ssr_stream/main.mjs">main.mjs</a> 文件会启动一个异步的 HTTP 服务器，然后把 HTML 页面渲染成多段放入响应。当一个 HTTP 请求进来的时候，<code>handle_client()</code> 函数就会被调用来渲染 HTML，并以流的形式返回结果。</p>
<pre><code class="language-javascript">import * as React from 'react';
import { renderToPipeableStream } from 'react-dom/server';
import * as http from 'wasi_http';
import * as net from 'wasi_net';

import LazyHome from './component/LazyHome.jsx';

async function handle_client(s) {
  let resp = new http.WasiResponse();
  resp.headers = {
    &quot;Content-Type&quot;: &quot;text/html; charset=utf-8&quot;
  }
  renderToPipeableStream(&lt;LazyHome /&gt;).pipe(resp.chunk(s));
}

async function server_start() {
  print('listen 8001...');
  let s = new net.WasiTcpServer(8001);
  for (var i = 0; i &lt; 100; i++) {
    let cs = await s.accept();
    handle_client(cs);
  }
}

server_start();
</code></pre>
<p>目录中的 <a href="https://github.com/second-state/wasmedge-quickjs/blob/main/example_js/react_ssr_stream/rollup.config.js">rollup.config.js</a> 文件和 <a href="https://github.com/second-state/wasmedge-quickjs/blob/main/example_js/react_ssr_stream/package.json">package.json</a> 文件用于把 React SSR 的所有依赖和组件打包成一个 WasmEdge 可用的 JavaScript 文件。你可以使用 <code>npm</code> 命令来进行构建，构建产物会输出到 <code>dist/main.js</code> 文件里。</p>
<pre><code class="language-bash">npm install
npm run build
</code></pre>
<p>要运行这个例子，请在命令行上执行以下命令来启动服务器。</p>
<pre><code class="language-bash">cd example_js/react_ssr_stream
nohup wasmedge --dir .:. ../../target/wasm32-wasi/release/wasmedge_quickjs.wasm dist/main.mjs &amp;
</code></pre>
<p>然后通过 <code>curl</code> 或浏览器发送一个 HTTP 请求。</p>
<pre><code class="language-bash">curl http://localhost:8001
</code></pre>
<p>结果如下所示。该服务首先返回一个 HTML 页面，里面包含一个空的内层部分（即 <code>loading</code> 部分）。然后在 2s 后返回内层部分的 HTML 内容，以及将它显示出来的 JavaScript 代码。</p>
<pre><code class="language-bash">  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current
                                 Dload  Upload   Total   Spent    Left  Speed

  0     0    0     0    0     0      0      0 --:--:-- --:--:-- --:--:--     0
100   211    0   211    0     0   1029      0 --:--:-- --:--:-- --:--:--  1024
100   275    0   275    0     0    221      0 --:--:--  0:00:01 --:--:--   220
100   547    0   547    0     0    245      0 --:--:--  0:00:02 --:--:--   245
100  1020    0  1020    0     0    413      0 --:--:--  0:00:02 --:--:--   413

&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;&lt;meta charSet=&quot;utf-8&quot;/&gt;&lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div&gt;&lt;div&gt; This is LazyHome &lt;/div&gt;&lt;!--$?--&gt;&lt;template id=&quot;B:0&quot;&gt;&lt;/template&gt;&lt;div&gt; loading... &lt;/div&gt;&lt;!--/$--&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;&lt;div hidden id=&quot;S:0&quot;&gt;&lt;template id=&quot;P:1&quot;&gt;&lt;/template&gt;&lt;/div&gt;&lt;div hidden id=&quot;S:1&quot;&gt;&lt;div&gt;&lt;div&gt;This is lazy page&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;script&gt;function $RS(a,b){a=document.getElementById(a);b=document.getElementById(b);for(a.parentNode.removeChild(a);a.firstChild;)b.parentNode.insertBefore(a.firstChild,b);b.parentNode.removeChild(b)};$RS(&quot;S:1&quot;,&quot;P:1&quot;)&lt;/script&gt;&lt;script&gt;function $RC(a,b){a=document.getElementById(a);b=document.getElementById(b);b.parentNode.removeChild(b);if(a){a=a.previousSibling;var f=a.parentNode,c=a.nextSibling,e=0;do{if(c&amp;&amp;8===c.nodeType){var d=c.data;if(&quot;/$&quot;===d)if(0===e)break;else e--;else&quot;$&quot;!==d&amp;&amp;&quot;$?&quot;!==d&amp;&amp;&quot;$!&quot;!==d||e++}d=c.nextSibling;f.removeChild(c);c=d}while(c);for(;b.firstChild;)f.insertBefore(b.firstChild,c);a.data=&quot;$&quot;;a._reactRetry&amp;&amp;a._reactRetry()}};$RC(&quot;B:0&quot;,&quot;S:0&quot;)&lt;/script&gt;
</code></pre>
<p>流式 SSR 的示例充分利用了 WasmEdge 独特的处理异步网络的能力以及对 ES6 module 的支持（rollup 打包的 JS 文件中包含了 ES6 的模块）。你可以在本书中阅读更多有关 <a href="dev/js/networking.html">异步网络</a> 和 <a href="dev/js/es6.html">ES6</a> 的知识。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="es6-模块"><a class="header" href="#es6-模块">ES6 模块</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="nodejs--npm-模块"><a class="header" href="#nodejs--npm-模块">NodeJS &amp; NPM 模块</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="用-rust-实现-js-api"><a class="header" href="#用-rust-实现-js-api">用 Rust 实现 JS API</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="python"><a class="header" href="#python">Python</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="go"><a class="header" href="#go">Go</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="swift"><a class="header" href="#swift">Swift</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="assemblyscript"><a class="header" href="#assemblyscript">AssemblyScript</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="kotlin"><a class="header" href="#kotlin">Kotlin</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="grain"><a class="header" href="#grain">Grain</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="嵌入-wasmedge-函数"><a class="header" href="#嵌入-wasmedge-函数">嵌入 WasmEdge 函数</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="wasmedge-c-sdk"><a class="header" href="#wasmedge-c-sdk">WasmEdge C SDK</a></h1>
<p>文档 <a href="https://github.com/WasmEdge/WasmEdge/blob/master/include/api/wasmedge/wasmedge.h">WasmEdge C API</a> 里提供了访问 WasmEdge 运行时的接口。以下内容是关于如何使用 WasmEdge C API 的简单说明。如果要了解 WasmEdge C API 的更多细节，请参考<a href="embed/c/ref.html">完整的文档</a>。</p>
<h2 id="wasmedge-运行时快速指南"><a class="header" href="#wasmedge-运行时快速指南">WasmEdge 运行时快速指南</a></h2>
<p>以下是运行一个 WASM 文件的示例。
假设 WASM 文件<a href="https://github.com/WasmEdge/WasmEdge/raw/master/tools/wasmedge/examples/fibonacci.wasm"><code>fibonacci.wasm</code></a>已经被拷贝到当前目录，并且 C 文件 <code>test_wasmedge.c</code> 的源代码如下所示：</p>
<pre><code class="language-c">#include &lt;wasmedge/wasmedge.h&gt;
#include &lt;stdio.h&gt;
int main(int Argc, const char* Argv[]) {
  /* 创建配置上下文以及 WASI 支持。 */
  /* 除非你需要使用 WASI，否则这步不是必须的。 */
  WasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();
  WasmEdge_ConfigureAddHostRegistration(ConfCxt, WasmEdge_HostRegistration_Wasi);
  /* 创建VM的时候可以提供空的配置。*/
  WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(ConfCxt, NULL);

  /* 参数以及返回的数组。 */
  WasmEdge_Value Params[1] = { WasmEdge_ValueGenI32(32) };
  WasmEdge_Value Returns[1];
  /* 要调用的函数名。 */
  WasmEdge_String FuncName = WasmEdge_StringCreateByCString(&quot;fib&quot;);
  /* 运行文件里的 WASM 函数。 */
  WasmEdge_Result Res = WasmEdge_VMRunWasmFromFile(VMCxt, Argv[1], FuncName, Params, 1, Returns, 1);

  if (WasmEdge_ResultOK(Res)) {
    printf(&quot;Get result: %d\n&quot;, WasmEdge_ValueGetI32(Returns[0]));
  } else {
    printf(&quot;Error message: %s\n&quot;, WasmEdge_ResultGetMessage(Res));
  }

  /* 资源析构。 */
  WasmEdge_VMDelete(VMCxt);
  WasmEdge_ConfigureDelete(ConfCxt);
  WasmEdge_StringDelete(FuncName);
  return 0;
}
</code></pre>
<p>接下来你可以编译并且运行它：（索引从 0 开始的情况下，斐波那契数列的的第 32 个数值是 3524578 ）</p>
<pre><code class="language-bash">$ gcc test_wasmedge.c -lwasmedge_c -o test_wasmedge
$ ./test_wasmedge fibonacci.wasm
Get result: 3524578
</code></pre>
<p>如果要了解 API 的细节，请参考 <a href="https://github.com/WasmEdge/WasmEdge/blob/master/include/api/wasmedge/wasmedge.h">API 头文件</a>.</p>
<h2 id="wasmedge-aot-编译器快速指南"><a class="header" href="#wasmedge-aot-编译器快速指南">WasmEdge AOT 编译器快速指南</a></h2>
<p>假设 WASM 文件 <a href="https://github.com/WasmEdge/WasmEdge/raw/master/tools/wasmedge/examples/fibonacci.wasm"><code>fibonacci.wasm</code></a> 已经被拷贝到当前目录，并且 C 文件 <code>test_wasmedge_compiler.c</code> 的代码如下所示：</p>
<pre><code class="language-c">#include &lt;wasmedge/wasmedge.h&gt;
#include &lt;stdio.h&gt;
int main(int Argc, const char* Argv[]) {
  /* 创建配置上下文。 */
  WasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();
  /* ... 通过配置上下文调整配置。 */
  /* 结果。 */
  WasmEdge_Result Res;

  /* 创建编译器上下文。配置上下文可以为空。 */
  WasmEdge_CompilerContext *CompilerCxt = WasmEdge_CompilerCreate(ConfCxt);
  /* 根据指定的输入和输出路径来编译 WASM 文件。 */
  Res = WasmEdge_CompilerCompile(CompilerCxt, Argv[1], Argv[2]);
  if (!WasmEdge_ResultOK(Res)) {
    printf(&quot;Compilation failed: %s\n&quot;, WasmEdge_ResultGetMessage(Res));
    return 1;
  }

  WasmEdge_CompilerDelete(CompilerCxt);
  WasmEdge_ConfigureDelete(ConfCxt);
  return 0;
}
</code></pre>
<p>接下来你可以编译和运行它（输出的文件是 &quot;fibonacci.wasm.so&quot; ）：</p>
<pre><code class="language-bash">$ gcc test_wasmedge_compiler.c -lwasmedge_c -o test_wasmedge_compiler
$ ./test_wasmedge_compiler fibonacci.wasm fibonacci.wasm.so
[2021-07-02 11:08:08.651] [info] compile start
[2021-07-02 11:08:08.653] [info] verify start
[2021-07-02 11:08:08.653] [info] optimize start
[2021-07-02 11:08:08.670] [info] codegen start
[2021-07-02 11:08:08.706] [info] compile done
</code></pre>
<p>编译后的的 WASM 文件也可以直接作为 WasmEdge 运行时的输入。
以下是解释模式和 AOT 模式的一个对比：</p>
<pre><code class="language-bash">$ time ./test_wasmedge fibonacci.wasm
Get result: 5702887

real 0m2.715s
user 0m2.700s
sys 0m0.008s

$ time ./test_wasmedge fibonacci.wasm.so
Get result: 5702887

real 0m0.036s
user 0m0.022s
sys 0m0.011s
</code></pre>
<p>如果要了解这些 API 的细节，请参考<a href="https://github.com/WasmEdge/WasmEdge/blob/master/include/api/wasmedge/wasmedge.h">API 头文件</a>。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="api-references"><a class="header" href="#api-references">API references</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="wasmedge-go-sdk"><a class="header" href="#wasmedge-go-sdk">WasmEdge Go SDK</a></h1>
<p>这是一份如何使用 WasmEdge Go API 的指南。你可以通过 WasmEdge Go API 将 WasmEdge 嵌入在你的 Go 应用程序中。</p>
<h2 id="快速开始-2"><a class="header" href="#快速开始-2">快速开始</a></h2>
<p>WasmEdge-go 要求 Go 语言版本 &gt;= 1.15。在安装之前请检查你的 Go 语言版本。你可以<a href="https://golang.org/dl/">从这里下载 Go 语言</a>。</p>
<pre><code class="language-bash">$ go version
go version go1.16.5 linux/amd64
</code></pre>
<p>同时，请确保你已经安装了和 <code>WasmEdge-go</code> 同一发布版本的 <a href="embed/../start/install.html">WasmEdge 共享库</a>。</p>
<pre><code class="language-bash">wget -qO- https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/utils/install.sh | bash -s -- -v 0.9.1
</code></pre>
<p>如果你需要 <code>WasmEdge-go</code> 的 <code>TensorFlow</code> 或 <code>Image</code> 扩展，请安装带有这些扩展的 <code>WasmEdge</code> ：</p>
<pre><code class="language-bash">wget -qO- https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/utils/install.sh | bash -s -- -v 0.9.1 -e tensorflow,image
</code></pre>
<p>注意 <code>TensorFlow</code> 和 <code>Image</code> 扩展仅支持 <code>Linux</code> 平台。</p>
<p>安装 <code>WasmEdge-go</code> 包并在你的 Go 项目目录下构建：</p>
<pre><code class="language-bash">go get github.com/second-state/WasmEdge-go/wasmedge@v0.9.1
go build
</code></pre>
<h2 id="wasmedge-go-扩展"><a class="header" href="#wasmedge-go-扩展">WasmEdge-go 扩展</a></h2>
<p>默认情况下， <code>WasmEdge-go</code> 只打开基本运行时。</p>
<p><code>WasmEdge-go</code> 有以下扩展：</p>
<ul>
<li>
<p>TensorFlow</p>
<ul>
<li>
<p>该扩展支持 <a href="https://github.com/second-state/WasmEdge-tensorflow">WasmEdge-tensorflow</a> 中的 host 函数。</p>
</li>
<li>
<p>若要安装 <code>tensorflow</code> 扩展。请在 WasmEdge 安装器命令中使用 <code>-e tensorflow</code> 标志。</p>
</li>
<li>
<p>若使用该扩展，在构建时需要打上 <code>tensorflow</code> 标签：</p>
<pre><code class="language-bash">go build -tags tensorflow
</code></pre>
</li>
</ul>
</li>
<li>
<p>Image</p>
<ul>
<li>
<p>该扩展支持 <a href="https://github.com/second-state/WasmEdge-image">WasmEdge-image</a> 中的 host 函数。</p>
</li>
<li>
<p>若要安装 <code>image</code> 扩展。请在 WasmEdge 安装器命令中使用 <code>-e image</code> 标志。</p>
</li>
<li>
<p>若使用该扩展，在构建时需要打上 <code>image</code> 标签：</p>
<pre><code class="language-bash">go build -tags image
</code></pre>
</li>
</ul>
</li>
</ul>
<p>你也可以在构建的时候打开多个扩展：</p>
<pre><code class="language-bash">go build -tags image,tensorflow
</code></pre>
<p>有关示例，请参考 <a href="https://github.com/second-state/WasmEdge-go-examples/">示例仓库</a>。</p>
<h3 id="go-中的-wasmedge-aot-编译器"><a class="header" href="#go-中的-wasmedge-aot-编译器">Go 中的 WasmEdge AOT 编译器</a></h3>
<p><a href="https://github.com/second-state/WasmEdge-go-examples/tree/master/go_WasmAOT">go_WasmAOT 示例</a> 演示了如何通过一个 Go 应用程序将一个 WASM 文件编译成本机二进制文件文件（AOT 编译）。</p>
<h2 id="相关示例"><a class="header" href="#相关示例">相关示例</a></h2>
<ul>
<li><a href="embed/go/app.html">嵌入一个独立的 Wasm 应用</a></li>
<li><a href="embed/go/function.html">嵌入一个 Wasm 函数</a></li>
<li><a href="embed/go/memory.html">将复杂的参数传递到 Wasm 函数</a></li>
<li><a href="embed/go/tensorflow.html">嵌入一个 Tensorflow 推理函数</a></li>
<li><a href="embed/go/bindgen.html">嵌入一个 bindgen 函数</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="嵌入-wasm-应用程序"><a class="header" href="#嵌入-wasm-应用程序">嵌入 WASM 应用程序</a></h1>
<p>WasmEdge Go SDK 能<a href="https://github.com/second-state/WasmEdge-go-examples/tree/master/go_ReadFile">嵌入单独的 WebAssembly 应用程序</a> — 比如，一个带着 <code>main()</code> 函数，编译成 WebAssembly 的 Rust 应用程序。</p>
<p>我们的 <a href="https://github.com/second-state/WasmEdge-go-examples/tree/master/go_ReadFile/rust_readfile">demo Rust 应用程序</a>从一个文件中读取内容。注意，WebAssembly 程序的输入和输出数据现在是通过 STDIN 和 STDOUT 传递的。</p>
<pre><pre class="playground"><code class="language-rust">use std::env;
use std::fs::File;
use std::io::{self, BufRead};

fn main() {
  // 获取参数。
  let args: Vec&lt;String&gt; = env::args().collect();
  if args.len() &lt;= 1 {
    println!(&quot;Rust: ERROR - No input file name.&quot;);
    return;
  }

  // 打开文件。
  println!(&quot;Rust: Opening input file \&quot;{}\&quot;...&quot;, args[1]);
  let file = match File::open(&amp;args[1]) {
    Err(why) =&gt; {
      println!(&quot;Rust: ERROR - Open file \&quot;{}\&quot; failed: {}&quot;, args[1], why);
      return;
    },
    Ok(file) =&gt; file,
  };

  // 按行读取文件内容。
  let reader = io::BufReader::new(file);
  let mut texts:Vec&lt;String&gt; = Vec::new();
  for line in reader.lines() {
    if let Ok(text) = line {
      texts.push(text);
    }
  }
  println!(&quot;Rust: Read input file \&quot;{}\&quot; succeeded.&quot;, args[1]);

  // 获取 stdin 来打印内容。
  println!(&quot;Rust: Please input the line number to print the line of file.&quot;);
  let stdin = io::stdin();
  for line in stdin.lock().lines() {
    let input = line.unwrap();
    match input.parse::&lt;usize&gt;() {
      Ok(n) =&gt; if n &gt; 0 &amp;&amp; n &lt;= texts.len() {
        println!(&quot;{}&quot;, texts[n - 1]);
      } else {
        println!(&quot;Rust: ERROR - Line \&quot;{}\&quot; is out of range.&quot;, n);
      },
      Err(e) =&gt; println!(&quot;Rust: ERROR - Input \&quot;{}\&quot; is not an integer: {}&quot;, input, e),
    }
  }
  println!(&quot;Rust: Process end.&quot;);
}
</code></pre></pre>
<p>将应用程序编译成 WebAssembly。</p>
<pre><code class="language-bash">$ cd rust_readfile
$ cargo build --target wasm32-wasi
# 输出文件是 target/wasm32-wasi/debug/rust_readfile.wasm
</code></pre>
<p>我们在 Go 程序里面嵌入 WasmEdge 运行 WebAssembly 函数，这个 Go 程序源代码如下。</p>
<pre><code class="language-go">package main

import (
  &quot;os&quot;
  &quot;github.com/second-state/WasmEdge-go/wasmedge&quot;
)

func main() {
  wasmedge.SetLogErrorLevel()

  var conf = wasmedge.NewConfigure(wasmedge.REFERENCE_TYPES)
  conf.AddConfig(wasmedge.WASI)
  var vm = wasmedge.NewVMWithConfig(conf)
  var wasi = vm.GetImportObject(wasmedge.WASI)
  wasi.InitWasi(
    os.Args[1:],     // 参数
    os.Environ(),    // 环境变量
    []string{&quot;.:.&quot;}, // 目录映射
  )

  // 实例化 wasm。_start 指的是 wasm 程序的 main() 函数
  vm.RunWasmFile(os.Args[1], &quot;_start&quot;)

  vm.Release()
  conf.Release()
}
</code></pre>
<p>接下来，让我们用 WasmEdge Go SDK 构建 Go 应用程序。</p>
<pre><code class="language-bash">go get github.com/second-state/WasmEdge-go/wasmedge@v0.9.1
go build
</code></pre>
<p>运行 Golang 应用程序。</p>
<pre><code class="language-bash">$ ./read_file rust_readfile/target/wasm32-wasi/debug/rust_readfile.wasm file.txt
Rust: Opening input file &quot;file.txt&quot;...
Rust: Read input file &quot;file.txt&quot; succeeded.
Rust: Please input the line number to print the line of file.
# 输入 &quot;5&quot; 然后按下 Enter。
5
# `file.txt` 文件的第 5 行内容将被输出：
abcDEF___!@#$%^
# 要停止程序，发送 EOF (Ctrl + D)。
^D
# 输出将会打印停止信息：
Rust: Process end.
</code></pre>
<p>更多的例子可以在 <a href="https://github.com/second-state/WasmEdge-go-examples">WasmEdge-go-examples GitHub 仓库</a> 中找到。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="嵌入-wasm-函数"><a class="header" href="#嵌入-wasm-函数">嵌入 Wasm 函数</a></h1>
<p>WasmEdge Go SDK 允许将 WebAssembly 函数嵌入到一个 Go 主程序。可以使用 Go SDK API 来传递调用参数到嵌入的 WebAssembly 函数，然后捕获返回值。</p>
<p>然而，WebAssembly 规范本身只支持一些简单数据类型。 它<a href="https://medium.com/wasm/strings-in-webassembly-wasm-57a05c1ea333">不支持</a> 字符串和数组等类型。 为了将 Go 中的丰富类型传递给 WebAssembly，我们可以手动编码内存指针（<a href="embed/go/memory.html">点击这里</a>），或者使用管理数据交换的自动化工具。</p>
<p><a href="https://github.com/second-state/wasmedge-bindgen">wasmedge-bindgen</a> 项目为函数提供了 Rust 宏来接受和返回复杂的数据类型，然后让 Go 函数调用在 WasmEdge 中运行的此类 Rust 函数。
本章中演示的完整源代码 <a href="https://github.com/second-state/WasmEdge-go-examples/tree/master/wasmedge-bindgen/go_BindgenFuncs">可在此处获得</a>。</p>
<h2 id="将-rust-函数编译成-webassembly"><a class="header" href="#将-rust-函数编译成-webassembly">将 Rust 函数编译成 WebAssembly</a></h2>
<p>在 <a href="https://github.com/second-state/WasmEdge-go-examples/tree/master/wasmedge-bindgen/go_BindgenFuncs/rust_bindgen_funcs">Rust 项目</a> 中，你只需要用 “[wasmedge_bindgen] ”宏来注释 [你的函数](https ://github.com/second-state/WasmEdge-go-examples/blob/master/wasmedge-bindgen/go_BindgenFuncs/rust_bindgen_funcs/src/lib.rs) 。
这些带注释的函数将由 Rust 编译器自动检测并转换为可以从 <code>wasmedge-bindgen</code> GO SDK 调用的 WebAssembly 函数。
在下面的示例中，我们有几个 Rust 函数可以进行复杂的调用参数并返回复杂值。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use wasmedge_bindgen::*;
use wasmedge_bindgen_macro::*;
use num_integer::lcm;
use sha3::{Digest, Sha3_256, Keccak256};
use serde::{Serialize, Deserialize};

#[derive(Serialize, Deserialize, Debug)]
struct Point {
  x: f32,
  y: f32
}

#[derive(Serialize, Deserialize, Debug)]
struct Line {
  points: Vec&lt;Point&gt;,
  valid: bool,
  length: f32,
  desc: String
}

#[wasmedge_bindgen]
pub fn create_line(p1: String, p2: String, desc: String) -&gt; Result&lt;Vec&lt;u8&gt;, String&gt; {
  let point1: Point = serde_json::from_str(p1.as_str()).unwrap();
  let point2: Point = serde_json::from_str(p2.as_str()).unwrap();
  let length = ((point1.x - point2.x) * (point1.x - point2.x) + (point1.y - point2.y) * (point1.y - point2.y)).sqrt();

  let valid = if length == 0.0 { false } else { true };

  let line = Line { points: vec![point1, point2], valid: valid, length: length, desc: desc };

  return Ok(serde_json::to_vec(&amp;line).unwrap());
}

#[wasmedge_bindgen]
pub fn say(s: String) -&gt; Result&lt;Vec&lt;u8&gt;, String&gt; {
  let r = String::from(&quot;hello &quot;);
  return Ok((r + s.as_str()).as_bytes().to_vec());
}

#[wasmedge_bindgen]
pub fn obfusticate(s: String) -&gt; Result&lt;Vec&lt;u8&gt;, String&gt; {
  let r: String = (&amp;s).chars().map(|c| {
    match c {
      'A' ..= 'M' | 'a' ..= 'm' =&gt; ((c as u8) + 13) as char,
      'N' ..= 'Z' | 'n' ..= 'z' =&gt; ((c as u8) - 13) as char,
      _ =&gt; c
    }
  }).collect();
  Ok(r.as_bytes().to_vec())
}

#[wasmedge_bindgen]
pub fn lowest_common_multiple(a: i32, b: i32) -&gt; Result&lt;Vec&lt;u8&gt;, String&gt; {
  let r = lcm(a, b);
  return Ok(r.to_string().as_bytes().to_vec());
}

#[wasmedge_bindgen]
pub fn sha3_digest(v: Vec&lt;u8&gt;) -&gt; Result&lt;Vec&lt;u8&gt;, String&gt; {
  return Ok(Sha3_256::digest(&amp;v).as_slice().to_vec());
}

#[wasmedge_bindgen]
pub fn keccak_digest(s: Vec&lt;u8&gt;) -&gt; Result&lt;Vec&lt;u8&gt;, String&gt; {
  return Ok(Keccak256::digest(&amp;s).as_slice().to_vec());
}
<span class="boring">}
</span></code></pre></pre>
<p>你可以使用标准的 Cargo 命令构建 WebAssembly 字节码文件。</p>
<pre><code class="language-bash">$ cd rust_bindgen_funcs
$ cargo build --target wasm32-wasi --release

# 输出 WASM 将是 target/wasm32-wasi/release/rust_bindgen_funcs_lib.wasm.

$ cp target/wasm32-wasi/release/rust_bindgen_funcs_lib.wasm ../
$ cd ../
</code></pre>
<h2 id="go-host-程序"><a class="header" href="#go-host-程序">Go host 程序</a></h2>
<p>在 <a href="https://github.com/second-state/WasmEdge-go-examples/blob/master/wasmedge-bindgen/go_BindgenFuncs/bindgen_funcs.go">Go host 程序</a>中，你可以使用 WasmEdge Go SDK 创建和设置 WasmEdge VM。
但是，你现不应该调用 <code>vm.Instantiate()</code> 而应该调用<code>bindgen.Instantiate(vm)</code> 来实例化 VM 并返回 <code>bindgen</code> 对象。</p>
<pre><code class="language-go">func main() {
  // 预期的 Args[0]: 程序名 (./bindgen_funcs)
  // 预期的 Args[1]: wasm 文件 (rust_bindgen_funcs_lib.wasm))
  
  wasmedge.SetLogErrorLevel()
  var conf = wasmedge.NewConfigure(wasmedge.WASI)
  var vm = wasmedge.NewVMWithConfig(conf)
  var wasi = vm.GetImportObject(wasmedge.WASI)
  wasi.InitWasi(
    os.Args[1:],     // The args
    os.Environ(),    // The envs
    []string{&quot;.:.&quot;}, // The mapping preopens
  )
  vm.LoadWasmFile(os.Args[1])
  vm.Validate()

  // 实例化 bindgen 和 vm
  bg := bindgen.Instantiate(vm)
</code></pre>
<p>接下来，你可以通过 <code>bindgen</code> 对象调用 VM 中的任何 <code>[wasmedge_bindgen]</code> 注释函数。</p>
<pre><code class="language-go">  // create_line: string, string, string -&gt; string (输入已 JSON 字符串化)  
  res, err := bg.Execute(&quot;create_line&quot;, &quot;{\&quot;x\&quot;:2.5,\&quot;y\&quot;:7.8}&quot;, &quot;{\&quot;x\&quot;:2.5,\&quot;y\&quot;:5.8}&quot;, &quot;A thin red line&quot;)
  if err == nil {
    fmt.Println(&quot;Run bindgen -- create_line:&quot;, string(res))
  } else {
    fmt.Println(&quot;Run bindgen -- create_line FAILED&quot;, err)
  }

  // say: string -&gt; string
  res, err = bg.Execute(&quot;say&quot;, &quot;bindgen funcs test&quot;)
  if err == nil {
    fmt.Println(&quot;Run bindgen -- say:&quot;, string(res))
  } else {
    fmt.Println(&quot;Run bindgen -- say FAILED&quot;)
  }

  // obfusticate: string -&gt; string
  res, err = bg.Execute(&quot;obfusticate&quot;, &quot;A quick brown fox jumps over the lazy dog&quot;)
  if err == nil {
    fmt.Println(&quot;Run bindgen -- obfusticate:&quot;, string(res))
  } else {
    fmt.Println(&quot;Run bindgen -- obfusticate FAILED&quot;)
  }

  // lowest_common_multiple: i32, i32 -&gt; i32
  res, err = bg.Execute(&quot;lowest_common_multiple&quot;, int32(123), int32(2))
  if err == nil {
    num, _ := strconv.ParseInt(string(res), 10, 32)
    fmt.Println(&quot;Run bindgen -- lowest_common_multiple:&quot;, num)
  } else {
    fmt.Println(&quot;Run bindgen -- lowest_common_multiple FAILED&quot;)
  }

  // sha3_digest: array -&gt; array
  res, err = bg.Execute(&quot;sha3_digest&quot;, []byte(&quot;This is an important message&quot;))
  if err == nil {
    fmt.Println(&quot;Run bindgen -- sha3_digest:&quot;, res)
  } else {
    fmt.Println(&quot;Run bindgen -- sha3_digest FAILED&quot;)
  }

  // keccak_digest: array -&gt; array
  res, err = bg.Execute(&quot;keccak_digest&quot;, []byte(&quot;This is an important message&quot;))
  if err == nil {
    fmt.Println(&quot;Run bindgen -- keccak_digest:&quot;, res)
  } else {
    fmt.Println(&quot;Run bindgen -- keccak_digest FAILED&quot;)
  }

  bg.Release()
  vm.Release()
  conf.Release()
}
</code></pre>
<p>最后，你可以构建并运行 Go host 程序。</p>
<pre><code class="language-bash">go build
./bindgen_funcs rust_bindgen_funcs_lib.wasm
</code></pre>
<p>本示例的标准输出如下。</p>
<pre><code class="language-bash">Run bindgen -- create_line: {&quot;points&quot;:[{&quot;x&quot;:1.5,&quot;y&quot;:3.8},{&quot;x&quot;:2.5,&quot;y&quot;:5.8}],&quot;valid&quot;:true,&quot;length&quot;:2.2360682,&quot;desc&quot;:&quot;A thin red line&quot;}
Run bindgen -- say: hello bindgen funcs test
Run bindgen -- obfusticate: N dhvpx oebja sbk whzcf bire gur ynml qbt
Run bindgen -- lowest_common_multiple: 246
Run bindgen -- sha3_digest: [87 27 231 209 189 105 251 49 159 10 211 250 15 159 154 181 43 218 26 141 56 199 25 45 60 10 20 163 54 211 195 203]
Run bindgen -- keccak_digest: [126 194 241 200 151 116 227 33 216 99 159 22 107 3 177 169 216 191 114 156 174 193 32 159 246 228 245 133 52 75 55 27]
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pass-complex-data"><a class="header" href="#pass-complex-data">Pass complex data</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tensorflow-2"><a class="header" href="#tensorflow-2">Tensorflow</a></h1>
<p>在这一章节，我们将向你展示如何在 Rust 中创建一个用于图像分类的 Tensorflow 推理函数，然后将其嵌入到 Go 应用程序中。项目的源码可以在<a href="https://github.com/second-state/WasmEdge-go-examples/tree/master/wasmedge-bindgen/go_TfliteFood">这儿</a>查看。</p>
<h2 id="将-rust-函数编译成-webassembly-1"><a class="header" href="#将-rust-函数编译成-webassembly-1">将 Rust 函数编译成 WebAssembly</a></h2>
<p>用于图像分类的 Rust 函数在<a href="https://github.com/second-state/WasmEdge-go-examples/blob/master/wasmedge-bindgen/go_TfliteFood/rust_tflite_food/src/lib.rs">这儿</a>。它使用 <a href="embed/go/../../dev/rust/tensorflow.html">WasmEdge Tensorflow 扩展 API</a> 以及 <a href="embed/go/function.html">wasmedge_bindgen</a> 来传递所有调用参数。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[wasmedge_bindgen]
fn infer(image_data: Vec&lt;u8&gt;) -&gt; Result&lt;Vec&lt;u8&gt;, String&gt; {
  ... ...
  let flat_img = image::imageops::thumbnail(&amp;img, 192, 192);

  let model_data: &amp;[u8] = include_bytes!(&quot;lite-model_aiy_vision_classifier_food_V1_1.tflite&quot;);
  let labels = include_str!(&quot;aiy_food_V1_labelmap.txt&quot;);

  let mut session = wasmedge_tensorflow_interface::Session::new(
    model_data,
    wasmedge_tensorflow_interface::ModelType::TensorFlowLite,
  );
  session.add_input(&quot;input&quot;, &amp;flat_img, &amp;[1, 192, 192, 3]).run();
  let res_vec: Vec&lt;u8&gt; = session.get_output(&quot;MobilenetV1/Predictions/Softmax&quot;);
  ... ...
}
<span class="boring">}
</span></code></pre></pre>
<p>你可以使用标准的 <code>Cargo</code> 命令来将其构建成为一个 WebAssembly 函数。</p>
<pre><code class="language-bash">cd rust_tflite_food
cargo build --target wasm32-wasi --release
cp target/wasm32-wasi/release/rust_tflite_food_lib.wasm ../
cd ../
</code></pre>
<p>你也可以使用我们的 AOT 编译器 <code>wasmedgec</code> 来检测 WebAssembly 文件，以便让其运行的更快。<a href="embed/go/../../start/universal.html">学习更多</a>。</p>
<pre><code class="language-bash">wasmedgec rust_tflite_food_lib.wasm rust_tflite_food_lib.wasm
</code></pre>
<h2 id="go-host-应用程序"><a class="header" href="#go-host-应用程序">Go host 应用程序</a></h2>
<p><a href="https://github.com/second-state/WasmEdge-go-examples/blob/master/wasmedge-bindgen/go_TfliteFood/tflite_food.go">Go host 应用程序</a>的源码展示了如何用 Tensorflow 来扩展并实例化一个 WasmEdge runtime，以及如何将图片数据传递给 WasmEdge 中的 Rust 函数，以便来执行推理。</p>
<pre><code class="language-go">func main() {
  // Expected Args[0]: program name (./tflite_food)
  // Expected Args[1]: wasm file (rust_tflite_food_lib.wasm)
  // Expected Args[2]: input image name (food.jpg)

  wasmedge.SetLogErrorLevel()

  // Set Tensorflow not to print debug info
  os.Setenv(&quot;TF_CPP_MIN_LOG_LEVEL&quot;, &quot;3&quot;)
  os.Setenv(&quot;TF_CPP_MIN_VLOG_LEVEL&quot;, &quot;3&quot;)

  var conf = wasmedge.NewConfigure(wasmedge.WASI)
  var vm = wasmedge.NewVMWithConfig(conf)
  var wasi = vm.GetImportObject(wasmedge.WASI)
  wasi.InitWasi(
    os.Args[1:],     // The args
    os.Environ(),    // The envs
    []string{&quot;.:.&quot;}, // The mapping preopens
  )

  // Register WasmEdge-tensorflow
  var tfobj = wasmedge.NewTensorflowImportObject()
  var tfliteobj = wasmedge.NewTensorflowLiteImportObject()
  vm.RegisterImport(tfobj)
  vm.RegisterImport(tfliteobj)

  // Load and validate the wasm
  vm.LoadWasmFile(os.Args[1])
  vm.Validate()

  // Instantiate the bindgen and vm
  bg := bindgen.Instantiate(vm)

  img, _ := ioutil.ReadFile(os.Args[2])
  if res, err := bg.Execute(&quot;infer&quot;, img); err != nil {
    fmt.Println(err)
  } else {
    fmt.Println(string(res))
  }

  bg.Release()
  vm.Release()
  conf.Release()
  tfobj.Release()
  tfliteobj.Release()
}
</code></pre>
<h2 id="构建和运行"><a class="header" href="#构建和运行">构建和运行</a></h2>
<blockquote>
<p>你必须要在你的机器上安装带有 tensorflow 扩展的 WasmEdge。详情可查看<a href="embed/go/../../start/install.html">安装指南</a>。</p>
</blockquote>
<p>如下命令用 WasmEdge Go SDK 和它的 tensorflow 扩展，构建了 Go host 应用程序。</p>
<pre><code class="language-bash">go build -tags tensorflow
</code></pre>
<p>现在你就可以运行 Go 应用程序了。它在 WasmEdge 中调用 WebAssembly 函数，以对输入图片进行推理。</p>
<pre><code class="language-bash">./tflite_food rust_tflite_food_lib.wasm food.jpg
</code></pre>
<p>结果如下。</p>
<pre><code class="language-bash">Go: Args: [./tflite_food rust_tflite_food_lib.wasm food.jpg]
It is very likely a Hot dog in the picture
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="embed-bindgen-funcs"><a class="header" href="#embed-bindgen-funcs">Embed bindgen funcs</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="api-references-1"><a class="header" href="#api-references-1">API references</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="nodejs-sdk"><a class="header" href="#nodejs-sdk">Node.js SDK</a></h1>
<p>在这篇教程中，我会向你展示如何通过 WasmEdge Node.js SDK 将用 Rust 写的 WebAssembly 函数合并进 Node.js 的服务端应用程序
中。这个方法可以将 Rust 的<strong>性能</strong>，WebAssembly 的<strong>安全性</strong>和<strong>可移植性</strong>，和 JavaScript 的<strong>易用性</strong>结合。一个典型的应用程序就像这样。</p>
<ul>
<li>host 应用程序是一个用 JavaScript 写的 Node.js web 应用程序，它可以调用 WebAssembly 函数。</li>
<li>WebAssembly 字节码程序是用 Rust 写的，运行在 WasmEdge Runtime，可以被 Node.js web 应用程序调用。</li>
</ul>
<blockquote>
<p><a href="https://github.com/second-state/wasmedge-nodejs-starter/fork">Fork 这个 Github 仓库</a>来开始写代码！</p>
</blockquote>
<h2 id="先决条件"><a class="header" href="#先决条件">先决条件</a></h2>
<p>为了搭建一个包含 Rust 和 WebAssembly 的高性能 Node.js 环境，你需要如下准备：</p>
<ul>
<li>一个现代的 Linux 发行版, 比如 Ubuntu Server 20.04 LTS</li>
<li><a href="https://www.rust-lang.org/tools/install">Rust 语言</a></li>
<li><a href="https://nodejs.org/en/download/package-manager/">Node.js</a></li>
<li>Node.js 的 <a href="embed/../start/install.html#install-wasmedge-for-node.js">WasmEdge Runtime</a></li>
<li><a href="embed//dev/rust/bindgen.html">rustwasmc 编译器工具链</a></li>
</ul>
<h3 id="docker"><a class="header" href="#docker">Docker</a></h3>
<p>最简单的启动方式就是使用 Docker 来搭建开发环境。只需要<a href="https://github.com/second-state/wasmedge-nodejs-starter/">克隆这个模板</a>到你的电脑，然后运行如下 Docker 命令：</p>
<pre><code class="language-bash"># 克隆代码到本地
$ git clone https://github.com/second-state/wasmedge-nodejs-starter
$ cd wasmedge-nodejs-starter

# 启动 Docker 容器
$ docker pull wasmedge/appdev_x86_64:0.8.2
$ docker run -p 3000:3000 --rm -it -v $(pwd):/app wasmedge/appdev_x86_64:0.8.2
(docker) $ cd /app
</code></pre>
<p>好了，你现在可以编译和运行代码了。</p>
<h3 id="没有-docker-的手动启动"><a class="header" href="#没有-docker-的手动启动">没有 Docker 的手动启动</a></h3>
<p>命令如下。</p>
<pre><code class="language-bash"># 安装 Rust
$ curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh
$ source $HOME/.cargo/env
$ rustup override set 1.50.0

# 安装 Node.js 和 npm
$ curl -sL https://deb.nodesource.com/setup_14.x |  bash
$ sudo apt-get install -y nodejs npm

# 安装 rustwasmc 工具链
$ npm install -g rustwasmc # 如果权限有问题，加上 --unsafe-perm

# WasmEdge 需要的系统依赖
$ sudo apt-get update
$ sudo apt-get -y upgrade
$ sudo apt install -y build-essential curl wget git vim libboost-all-dev llvm-dev liblld-10-dev

# 安装 WasmEdge 需要的 nodejs addon 
$ npm install wasmedge-core
$ npm install wasmedge-extensions
</code></pre>
<blockquote>
<p>WasmEdge Runtime 需要最新版本的 <code>libstdc++</code>。 Ubuntu 20.04 LTS 已经有最新的库了。 如果你使用的是比较老的 Linux 发行版中，有一些选项需要升级，<a href="https://www.secondstate.io/articles/ubuntu-req-ssvm-20200715/">更详细的信息在这儿</a>。</p>
</blockquote>
<p>然后，克隆示例源代码仓库。</p>
<pre><code class="language-bash">git clone https://github.com/second-state/wasmedge-nodejs-starter
cd wasmedge-nodejs-starter
</code></pre>
<h2 id="hello-world-1"><a class="header" href="#hello-world-1">Hello World</a></h2>
<p>第一个示例是一个 hello world，向你展示应用程序的各个部分如何组合在一起。</p>
<h3 id="rust-写的-webassembly-程序"><a class="header" href="#rust-写的-webassembly-程序">Rust 写的 WebAssembly 程序</a></h3>
<p>在这个例子中，Rust 程序将输入的字符串添加到 “hello” 后面。下面是 Rust 程序内容，位于 src/lib.rs。你可以在这个库文件中定义多个外部方法，所有的这些方法都可以在 host JavaScript 应用中通过 WebAssembly 调用。记得需要给每个函数添加 <code>#[wasm_bindgen]</code> 注解，这样 <a href="https://github.com/second-state/rustwasmc">rustwasmc</a> 就知道在构建时为这些函数生成正确的 JavaScript 到 Rust 接口。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use wasm_bindgen::prelude::*;

#[wasm_bindgen]
pub fn say(s: String) -&gt; String {
  let r = String::from(&quot;hello &quot;);
  return r + &amp;s;
}
<span class="boring">}
</span></code></pre></pre>
<p>然后你可以将 Rust 源代码编译成 WebAssembly 字节码，并且生成相应的 JavaScript 模块供 Node.js host 环境调用。</p>
<pre><code class="language-bash">rustwasmc build
</code></pre>
<p>生成的文件在 <code>pkg/</code> 目录下，<code>.wasm</code> 文件是 WebAssembly 字节码程序，<code>.js</code> 文件是 JavaScript 模块。</p>
<h3 id="nodejs-host-应用程序"><a class="header" href="#nodejs-host-应用程序">Node.js host 应用程序</a></h3>
<p>然后进入 <code>node</code> 文件夹下，检查 JavaScript 程序 <code>app.js</code>。有了生成的 <code>wasmedge_nodejs_starter_lib.js</code> 模块，就很容易写出调用 WebAssembly 函数的 JavaScript 了。下面是 node 应用程序 <code>app.js</code>。简单的从生成的模块中引入 <code>say()</code> 函数。 node 应用程序从 HTTP GET 请求中拿到 <code>name</code> 参数后返回 “hello <code>name</code>”。</p>
<pre><code class="language-javascript">const { say } = require('../pkg/wasmedge_nodejs_starter_lib.js');

const http = require('http');
const url = require('url');
const hostname = '127.0.0.1';
const port = 3000;

const server = http.createServer((req, res) =&gt; {
  const queryObject = url.parse(req.url,true).query;
  res.statusCode = 200;
  res.setHeader('Content-Type', 'text/plain');
  res.end(say(queryObject['name']));
});

server.listen(port, hostname, () =&gt; {
  console.log(`Server running at http://${hostname}:${port}/`);
});
</code></pre>
<p>像下面一样启动 Node.js 应用程序。</p>
<pre><code class="language-bash">$ node node/app.js
Server running at http://127.0.0.1:3000/
</code></pre>
<p>然后，你可以在另外一个终端窗口中测试。</p>
<pre><code class="language-bash">$ curl http://127.0.0.1:3000/?name=Wasm
hello Wasm
</code></pre>
<h2 id="完整的-web-应用程序"><a class="header" href="#完整的-web-应用程序">完整的 web 应用程序</a></h2>
<p>下面的例子展示了一个计算二次方程根的 web 应用程序，请在这里查看<a href="https://github.com/second-state/wasm-learning/tree/master/nodejs/quadratic">完整源代码</a>.</p>
<p>用户在 web 表单中输入 <code>a</code>, <code>b</code>, <code>c</code> 三个值，web 应用程序调用 web 服务 <code>/solve</code>，计算出二次方程的根。</p>
<pre><code class="language-src">a*X^2 + b*X + c = 0
</code></pre>
<p><code>X</code> 的根展示在输入表单下面。</p>
<p><img src="https://www.secondstate.io/articles/getting-started-with-rust-function-01.png" alt="getting-started-with-rust-function" /></p>
<p><a href="https://github.com/second-state/wasm-learning/blob/master/nodejs/quadratic/node/public/index.html">HTML 文件</a> 包含提交 web 表单到 <code>/solve</code> 的客户端 JavaScript，并且将结果放到页面的 <code>#roots</code> HTML 元素里。</p>
<pre><code class="language-javascript">$(function() {
    var options = {
      target: '#roots',
      url: &quot;/solve&quot;,
      type: &quot;post&quot;
    };
    $('#solve').ajaxForm(options);
});
</code></pre>
<p><code>/solve</code> URL 端点后的 <a href="https://github.com/second-state/wasm-learning/blob/master/nodejs/quadratic/node/server.js">Node.js 应用程序</a>如下所示。他从输入表单中读取数据，将他们作为数组传递给 <code>solve</code> 函数，将返回结果放到 HTTP 返回内容中。</p>
<pre><code class="language-javascript">app.post('/solve', function (req, res) {
  var a = parseFloat(req.body.a);
  var b = parseFloat(req.body.b);
  var c = parseFloat(req.body.c);
  res.send(solve([a, b, c]))
})
</code></pre>
<p><a href="https://github.com/second-state/wasm-learning/blob/master/nodejs/quadratic/src/lib.rs">用 Rust 写的 <code>solve</code> 函数</a>，运行在 WasmEdge Runtime。如果 JavaScript 端的调用参数是数组，Rust 函数接收到一个封装数组的 JSON 对象。在 Rust 代码中，我们首先解码 JSON，执行计算，然后返回一个 JSON 字符串的结果。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[wasm_bindgen]
pub fn solve(params: &amp;str) -&gt; String {
  let ps: (f32, f32, f32) = serde_json::from_str(&amp;params).unwrap();
  let discriminant: f32 = (ps.1 * ps.1) - (4. * ps.0 * ps.2);
  let mut solution: (f32, f32) = (0., 0.);
  if discriminant &gt;= 0. {
    solution.0 = (((-1.) * ps.1) + discriminant.sqrt()) / (2. * ps.0);
    solution.1 = (((-1.) * ps.1) - discriminant.sqrt()) / (2. * ps.0);
    return serde_json::to_string(&amp;solution).unwrap();
  } else {
    return String::from(&quot;not real numbers&quot;);
  }
}
<span class="boring">}
</span></code></pre></pre>
<p>让我们试试。</p>
<pre><code class="language-bash">rustwasmc build
npm install express # 这个应用程序需要 Node.js 的 express 框架
node node/server.js
</code></pre>
<p>在 web 浏览器中，输入 <code>http://ip-addr:8080/</code> 来获取应用程序。注意：如果你使用的是 Docker，确保 Docker 容器中的 8080 端口映射到宿主的 8080 端口。</p>
<p>这就是二次方程的例子。</p>
<h2 id="更多例子"><a class="header" href="#更多例子">更多例子</a></h2>
<p>在 Rust 和 JavaScript 之间除了可以传递字符串值外， <code>rustwasmc</code> 工具支持下面的数据类型。</p>
<ul>
<li>Rust 调用参数可以是 <code>i32</code>、<code>String</code>、<code>&amp;str</code>、<code>Vec&lt;u8&gt;</code> 和 <code>&amp;[u8]</code> 的组合。</li>
<li>返回值可能是 <code>i32</code> 或者 <code>String</code> 或者 <code>Vec&lt;u8&gt;</code> 或者 void。</li>
<li>对于复杂的数据结构，比如结构体，你可以使用 JSON 字符串来传递数据。</li>
</ul>
<blockquote>
<p>支持了 JSON，你可以用任意数量的输入参数调用 Rust 函数，并返回任意数量、任意类型的结果。</p>
</blockquote>
<p><a href="https://github.com/second-state/wasm-learning/tree/master/nodejs/functions">函数示例</a>中的 Rust 程序 <code>src/lib.rs</code> 演示了如何传递多个不同类型的调用参数和返回结果。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[wasm_bindgen]
pub fn obfusticate(s: String) -&gt; String {
  (&amp;s).chars().map(|c| {
    match c {
      'A' ..= 'M' | 'a' ..= 'm' =&gt; ((c as u8) + 13) as char,
      'N' ..= 'Z' | 'n' ..= 'z' =&gt; ((c as u8) - 13) as char,
      _ =&gt; c
    }
  }).collect()
}

#[wasm_bindgen]
pub fn lowest_common_denominator(a: i32, b: i32) -&gt; i32 {
  let r = lcm(a, b);
  return r;
}

#[wasm_bindgen]
pub fn sha3_digest(v: Vec&lt;u8&gt;) -&gt; Vec&lt;u8&gt; {
  return Sha3_256::digest(&amp;v).as_slice().to_vec();
}

#[wasm_bindgen]
pub fn keccak_digest(s: &amp;[u8]) -&gt; Vec&lt;u8&gt; {
  return Keccak256::digest(s).as_slice().to_vec();
}
<span class="boring">}
</span></code></pre></pre>
<p>最有意思的可能是 <code>create_line()</code> 函数。它需要两个 JSON 字符串，每一个都代表一个 <code>Point</code> 结构，返回一个 JSON 字符串代表 <code>Line</code> 结构。注意，<code>Point</code> 和 <code>Line</code> 结构都使用了 <code>Serialize</code> 和 <code>Deserialize</code> 注解，这样 Rust 编译器就会自动生成必要的代码来支持和 JSON 字符串之间的转换。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use wasm_bindgen::prelude::*;
use serde::{Serialize, Deserialize};

#[derive(Serialize, Deserialize, Debug)]
struct Point {
  x: f32, 
  y: f32
}

#[derive(Serialize, Deserialize, Debug)]
struct Line {
  points: Vec&lt;Point&gt;,
  valid: bool,
  length: f32,
  desc: String
}

#[wasm_bindgen]
pub fn create_line (p1: &amp;str, p2: &amp;str, desc: &amp;str) -&gt; String {
  let point1: Point = serde_json::from_str(p1).unwrap();
  let point2: Point = serde_json::from_str(p2).unwrap();
  let length = ((point1.x - point2.x) * (point1.x - point2.x) + (point1.y - point2.y) * (point1.y - point2.y)).sqrt();

  let valid = if length == 0.0 { false } else { true };
  let line = Line { points: vec![point1, point2], valid: valid, length: length, desc: desc.to_string() };
  return serde_json::to_string(&amp;line).unwrap();
}

#[wasm_bindgen]
pub fn say(s: &amp;str) -&gt; String {
  let r = String::from(&quot;hello &quot;);
  return r + s;
}
<span class="boring">}
</span></code></pre></pre>
<p>然后，让我们来检查下 JavaScript 程序 <a href="https://github.com/second-state/wasm-learning/blob/master/nodejs/functions/node/app.js"><code>app.js</code></a>，它展示了如何调用 Rust 函数。你可以看到，<code>String</code> 和 <code>&amp;str</code> 在 JavaScript 是简单的字符串，<code>i32</code> 是数字，<code>Vec&lt;u8&gt;</code> 或者 <code>&amp;[8]</code> 是 JavaScript <code>Uint8Array</code>。JavaScript 对象在传入或者从 Rust 函数结果返回需要通过 <code>JSON.stringify()</code> 或者 <code>JSON.parse()</code> 转换。</p>
<pre><code class="language-javascript">const { say, obfusticate, lowest_common_denominator, sha3_digest, keccak_digest, create_line } = require('./functions_lib.js');

var util = require('util');
const encoder = new util.TextEncoder();
console.hex = (d) =&gt; console.log((Object(d).buffer instanceof ArrayBuffer ? new Uint8Array(d.buffer) : typeof d === 'string' ? (new util.TextEncoder('utf-8')).encode(d) : new Uint8ClampedArray(d)).reduce((p, c, i, a) =&gt; p + (i % 16 === 0 ? i.toString(16).padStart(6, 0) + '  ' : ' ') + c.toString(16).padStart(2, 0) + (i === a.length - 1 || i % 16 === 15 ?  ' '.repeat((15 - i % 16) * 3) + Array.from(a).splice(i - i % 16, 16).reduce((r, v) =&gt; r + (v &gt; 31 &amp;&amp; v &lt; 127 || v &gt; 159 ? String.fromCharCode(v) : '.'), '  ') + '\n' : ''), ''));

console.log( say(&quot;WasmEdge&quot;) );
console.log( obfusticate(&quot;A quick brown fox jumps over the lazy dog&quot;) );
console.log( lowest_common_denominator(123, 2) );
console.hex( sha3_digest(encoder.encode(&quot;This is an important message&quot;)) );
console.hex( keccak_digest(encoder.encode(&quot;This is an important message&quot;)) );

var p1 = {x:1.5, y:3.8};
var p2 = {x:2.5, y:5.8};
var line = JSON.parse(create_line(JSON.stringify(p1), JSON.stringify(p2), &quot;A thin red line&quot;));
console.log( line );
</code></pre>
<p>在运行 <code>rustwasmc</code> 来构建 Rust 库后，在 Node.js 环境中运行 <code>app.js</code> 会产生如下结果。</p>
<pre><code class="language-bash">$ rustwasmc build
... Building the wasm file and JS shim file in pkg/ ...

$ node node/app.js
hello WasmEdge
N dhvpx oebja sbk whzcf bire gur ynml qbt
246
000000  57 1b e7 d1 bd 69 fb 31 9f 0a d3 fa 0f 9f 9a b5  W.çÑ½iû1..Óú...µ
000010  2b da 1a 8d 38 c7 19 2d 3c 0a 14 a3 36 d3 c3 cb  +Ú..8Ç.-&lt;..£6ÓÃË

000000  7e c2 f1 c8 97 74 e3 21 d8 63 9f 16 6b 03 b1 a9  ~ÂñÈ.tã!Øc..k.±©
000010  d8 bf 72 9c ae c1 20 9f f6 e4 f5 85 34 4b 37 1b  Ø¿r.®Á .öäõ.4K7.

{ points: [ { x: 1.5, y: 3.8 }, { x: 2.5, y: 5.8 } ],
  valid: true,
  length: 2.2360682,
  desc: 'A thin red line' }  
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rust-sdk"><a class="header" href="#rust-sdk">Rust SDK</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="python-sdk"><a class="header" href="#python-sdk">Python SDK</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="用-kubernetes-管理-wasmedge-应用"><a class="header" href="#用-kubernetes-管理-wasmedge-应用">用 Kubernetes 管理 WasmEdge 应用</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="快速开始-3"><a class="header" href="#快速开始-3">快速开始</a></h1>
<p>我们为你创建了基于 Ubuntu 的脚本，以便你在标准 Kubernetes 设置中快速开始使用以下运行时组合。</p>
<table><thead><tr><th>CRI（高级）runtime</th><th>OCI（低级）runtime</th><th></th></tr></thead><tbody>
<tr><td>CRI-O</td><td>crun + WasmEdge</td><td><a href="https://github.com/second-state/wasmedge-containers-examples/blob/main/.github/workflows/kubernetes-crio.yml">脚本</a></td></tr>
<tr><td>containerd</td><td>crun + WasmEdge</td><td><a href="https://github.com/second-state/wasmedge-containers-examples/blob/main/.github/workflows/kubernetes-containerd.yml">脚本</a></td></tr>
</tbody></table>
<h2 id="cri-o-和-crun"><a class="header" href="#cri-o-和-crun">CRI-O 和 crun</a></h2>
<p>在 Ubuntu 20.04 上你可以使用 CRI-O <a href="https://github.com/second-state/wasmedge-containers-examples/blob/main/crio/install.sh">install.sh</a> 脚本来安装 CRI-O 和 <code>crun</code> 。</p>
<pre><code class="language-bash">wget -qO- https://raw.githubusercontent.com/second-state/wasmedge-containers-examples/main/crio/install.sh | bash
</code></pre>
<p>接下来，使用 <a href="https://github.com/second-state/wasmedge-containers-examples/blob/main/kubernetes_crio/install.sh">以下脚本</a> 安装 Kubernetes。</p>
<pre><code class="language-bash">wget -qO- https://raw.githubusercontent.com/second-state/wasmedge-containers-examples/main/kubernetes_crio/install.sh | bash
</code></pre>
<p><a href="https://github.com/second-state/wasmedge-containers-examples/blob/main/kubernetes_crio/simple_wasi_application.sh">simple_wasi_application.sh</a> 脚本展示了如何从 Docker Hub 拉取 <a href="kubernetes/demo/wasi.html">WebAssembly 应用程序</a> ，然后在 Kubernetes 中将其作为容器化应用程序运行。</p>
<pre><code class="language-bash">wget -qO- https://raw.githubusercontent.com/second-state/wasmedge-containers-examples/main/kubernetes_crio/simple_wasi_application.sh | bash
</code></pre>
<p>你应该会在控制台日志中看到 WebAssembly 程序打印的结果。<a href="https://github.com/second-state/wasmedge-containers-examples/runs/4186005677?check_suite_focus=true#step:6:3007">这里是一个例子</a>。</p>
<h2 id="containerd-和-crun"><a class="header" href="#containerd-和-crun">containerd 和 crun</a></h2>
<p>在 Ubuntu 20.04 上你可以使用 containerd <a href="https://github.com/second-state/wasmedge-containers-examples/blob/main/containerd/install.sh">install.sh</a> 脚本来安装 <code>containerd</code> 和 <code>crun</code>。</p>
<pre><code class="language-bash">wget -qO- https://raw.githubusercontent.com/second-state/wasmedge-containers-examples/main/containerd/install.sh | bash
</code></pre>
<p>接下来，使用 <a href="https://github.com/second-state/wasmedge-containers-examples/blob/main/kubernetes_containerd/install.sh">以下脚本</a> 安装 Kubernetes。</p>
<pre><code class="language-bash">wget -qO- https://raw.githubusercontent.com/second-state/wasmedge-containers-examples/main/kubernetes_containerd/install.sh | bash
</code></pre>
<p><a href="https://github.com/second-state/wasmedge-containers-examples/blob/main/kubernetes_containerd/simple_wasi_application.sh">simple_wasi_application.sh</a> 脚本展示了如何从 Docker Hub拉取 <a href="kubernetes/demo/wasi.html">WebAssembly 应用程序</a>，然后在 Kubernetes 中将其作为容器化应用程序运行。</p>
<pre><code class="language-bash">wget -qO- https://raw.githubusercontent.com/second-state/wasmedge-containers-examples/main/kubernetes_containerd/simple_wasi_application.sh | bash
</code></pre>
<p>你应该会在控制台日志中看到 WebAssembly 程序打印的结果。<a href="https://github.com/second-state/wasmedge-containers-examples/runs/4577789181?check_suite_focus=true#step:6:3010">这里是一个例子</a>。</p>
<p>继续阅读本章的其余部分，了解这些运行时的具体配置方式。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="demo-apps"><a class="header" href="#demo-apps">Demo apps</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="一个简单的-wasi-例子"><a class="header" href="#一个简单的-wasi-例子">一个简单的 WASI 例子</a></h1>
<p>在这篇文章中，我会向你展示如何去构建一个 WebAssemblely 应用的容器镜像。然后可以通过 Kubernetes 生态系统工具（例如 CRI-O、Docker、crun 和 Kubernetes）来启动和管理它。</p>
<h2 id="先决条件-1"><a class="header" href="#先决条件-1">先决条件</a></h2>
<blockquote>
<p>如果你只是想要一个 wasm 字节码文件作为容器镜像进行测试，你可以跳过构建步骤，只需<a href="https://github.com/second-state/wasm-learning/blob/master/cli/wasi/wasi_example_main.wasm">在此处下载 wasm 文件</a>。</p>
</blockquote>
<p>首先，请按照这些简单的说明来<a href="https://www.rust-lang.org/tools/install">安装 Rust</a>。</p>
<h2 id="下载样例代码"><a class="header" href="#下载样例代码">下载样例代码</a></h2>
<pre><code class="language-bash">git clone https://github.com/second-state/wasm-learning
cd wasm-learning/cli/wasi
</code></pre>
<h2 id="构建-wasm-字节码"><a class="header" href="#构建-wasm-字节码">构建 WASM 字节码</a></h2>
<pre><code class="language-bash">rustup target add wasm32-wasi
cargo build --target wasm32-wasi --release
</code></pre>
<p>wasm 字节码应用程序位于 <code>target/wasm32-wasi/release/wasi_example_main.wasm</code> 文件中。你现在可以将其发布并用作容器镜像。</p>
<h2 id="申请-wasm-字节码的执行权限"><a class="header" href="#申请-wasm-字节码的执行权限">申请 Wasm 字节码的执行权限</a></h2>
<pre><code class="language-bash">chmod +x target/wasm32-wasi/release/wasi_example_main.wasm
</code></pre>
<h2 id="创建-dockerfile"><a class="header" href="#创建-dockerfile">创建 Dockerfile</a></h2>
<p>在 <code>target/wasm32-wasi/release</code> 文件夹中创建一个命名为 <code>Dockerfile</code> 的文件，其内容如下：</p>
<pre><code class="language-dockerfile">FROM scratch
ADD wasi_example_main.wasm /
CMD [&quot;/wasi_example_main.wasm&quot;]
</code></pre>
<h2 id="创建一个带注释的容器镜像"><a class="header" href="#创建一个带注释的容器镜像">创建一个带注释的容器镜像</a></h2>
<blockquote>
<p>请注意，添加自定义注释仍然是 buildah 中的新功能。</p>
</blockquote>
<p><code>crun</code> 容器运行时可以启动上述基于 WebAssembly 的容器镜像。但它需要容器镜像上的 <code>module.wasm.image/variant=compat</code> 注释来表明它是一个没有客人操作系统（安装在虚拟机上的系统）的 WebAssembly 应用程序。你可以在<a href="https://github.com/containers/crun/blob/main/docs/wasm-wasi-example.md">官方 crun repo</a> 中找到详细信息。</p>
<p>要在容器镜像中添加 <code>module.wasm.image/variant=compat</code> 注释，你需要最新的 <a href="https://buildah.io/">buildah</a>。 目前，Docker 不支持此功能。请按照 <a href="https://github.com/containers/buildah/blob/main/install.md">buildah 的安装说明</a> 构建最新的 buildah 二进制文件。</p>
<h3 id="在-ubuntu-上编译并安装最新的-buildah"><a class="header" href="#在-ubuntu-上编译并安装最新的-buildah">在 Ubuntu 上编译并安装最新的 buildah</a></h3>
<p>在 Ubuntu zesty 和 xenial 上，使用这些命令为 buildah 做准备。</p>
<pre><code class="language-bash">sudo apt-get -y install software-properties-common

export OS=&quot;xUbuntu_20.04&quot;
sudo bash -c &quot;echo \&quot;deb https://download.opensuse.org/repositories/devel:/kubic:/libcontainers:/stable/$OS/ /\&quot; &gt; /etc/apt/sources.list.d/devel:kubic:libcontainers:stable.list&quot;
sudo bash -c &quot;curl -L https://download.opensuse.org/repositories/devel:/kubic:/libcontainers:/stable/$OS/Release.key | apt-key add -&quot;

sudo add-apt-repository -y ppa:alexlarsson/flatpak
sudo apt-get -y -qq update
sudo apt-get -y install bats git libapparmor-dev libdevmapper-dev libglib2.0-dev libgpgme-dev libseccomp-dev libselinux1-dev skopeo-containers go-md2man containers-common
sudo apt-get -y install golang-1.16 make
</code></pre>
<p>然后，按照下列步骤在 Ubuntu 上编译和安装 buildah。</p>
<pre><code class="language-bash">mkdir -p ~/buildah
cd ~/buildah
export GOPATH=`pwd`
git clone https://github.com/containers/buildah ./src/github.com/containers/buildah
cd ./src/github.com/containers/buildah
PATH=/usr/lib/go-1.16/bin:$PATH make
cp bin/buildah /usr/bin/buildah
buildah --help
</code></pre>
<h3 id="创建和发布具备-buildah-的容器镜像"><a class="header" href="#创建和发布具备-buildah-的容器镜像">创建和发布具备 buildah 的容器镜像</a></h3>
<p>在 <code>target/wasm32-wasi/release/</code> 文件夹下，执行下列指令。</p>
<pre><code class="language-bash">$ sudo buildah build --annotation &quot;module.wasm.image/variant=compat&quot; -t wasm-wasi-example .
# make sure docker is install and running
# systemctl status docker
# to make sure regular user can use docker
# sudo usermod -aG docker $USER
# newgrp docker

# You may need to use docker login to create the `~/.docker/config.json` for auth.
$ sudo buildah push --authfile ~/.docker/config.json wasm-wasi-example docker://docker.io/hydai/wasm-wasi-example:with-wasm-annotation
</code></pre>
<p>好了！ 现在你可以尝试在 <a href="kubernetes/demo/../cri/crio.html#run-a-http-server-app">CRI-O</a> 或 <a href="kubernetes/demo/../kubernetes/kubernetes.html#run-a-http-server-app">Kubernetes</a> 上运行它了！</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="http-服务端实例"><a class="header" href="#http-服务端实例">HTTP 服务端实例</a></h1>
<p>让我们构建一个基于 WebAssembly 的 HTTP 服务容器镜像。</p>
<p>这个 HTTP 服务应用程序是基于 Rust 开发，并采用了 <a href="https://github.com/second-state/wasmedge_wasi_socket">WasmEdge 网络 socket API</a>。</p>
<p>Kubernetes 可以使用 CRI-O、Docker 和 Containerd 来管理 wasm 应用程序生命周期。</p>
<h2 id="先决条件-2"><a class="header" href="#先决条件-2">先决条件</a></h2>
<p>这是一个 Rust 示例，它需要你先安装 <a href="https://www.rust-lang.org/tools/install">Rust</a> 和 <a href="kubernetes/demo/../../start/install.html">WasmEdge</a> 以便可以编译运行 http 服务。</p>
<h2 id="下载样例代码-1"><a class="header" href="#下载样例代码-1">下载样例代码</a></h2>
<pre><code class="language-bash">mkdir http_server
cd http_server
wget -q https://raw.githubusercontent.com/second-state/wasmedge_wasi_socket/main/examples/http_server/Cargo.toml
mkdir src
cd src
wget -q https://raw.githubusercontent.com/second-state/wasmedge_wasi_socket/main/examples/http_server/src/main.rs
cd ../
</code></pre>
<h2 id="构建-wasm-字节码-1"><a class="header" href="#构建-wasm-字节码-1">构建 WASM 字节码</a></h2>
<pre><code class="language-bash">rustup target add wasm32-wasi
cargo build --target wasm32-wasi --release
</code></pre>
<p>wasm 字节码应用程序现在应该位于 <code>./target/wasm32-wasi/release/http_server.wasm</code> 目录下。
你现在可以使用 wasmedge 测试运行它，然后将其发布为容器镜像。</p>
<h2 id="在-wasm-字节码上申请执行权限"><a class="header" href="#在-wasm-字节码上申请执行权限">在 Wasm 字节码上申请执行权限</a></h2>
<pre><code class="language-bash">chmod +x ./target/wasm32-wasi/release/http_server.wasm
</code></pre>
<h2 id="使用-wasmedge-运行-http_server-应用程序字节码"><a class="header" href="#使用-wasmedge-运行-http_server-应用程序字节码">使用 wasmedge 运行 http_server 应用程序字节码</a></h2>
<p>当你在使用 wasmedge 来执行字节码并看到如下结果时，你已完成了将字节码打包到容器中的准备工作。</p>
<pre><code class="language-bash">$ wasmedge ./target/wasm32-wasi/release/http_server.wasm
new connection at 1234
</code></pre>
<p>你可以在另一个的终端窗口中测试这个服务端。</p>
<pre><code class="language-bash">$ curl -X POST http://127.0.0.1:1234 -d 'name=WasmEdge'
echo: name=WasmEdge
</code></pre>
<h2 id="创建-dockerfile-1"><a class="header" href="#创建-dockerfile-1">创建 Dockerfile</a></h2>
<p>在 <code>target/wasm32-wasi/release</code> 文件夹中创建一个命名为 <code>Dockerfile</code> 的文件，其内容如下：</p>
<pre><code class="language-dockerfile">FROM scratch
ADD http_server.wasm /
CMD [&quot;/http_server.wasm&quot;]
</code></pre>
<h2 id="创建一个带注释的容器镜像-1"><a class="header" href="#创建一个带注释的容器镜像-1">创建一个带注释的容器镜像</a></h2>
<blockquote>
<p>请注意，添加自定义注释仍然是 buildah 中的新功能。</p>
</blockquote>
<p><code>crun</code> 容器运行时可以启动上述基于 WebAssembly 的容器镜像。但它需要容器镜像上的 <code>module.wasm.image/variant=compat</code> 注释来表明它是一个没有客人操作系统（安装在虚拟机上的系统）的 WebAssembly 应用程序。你可以在<a href="https://github.com/containers/crun/blob/main/docs/wasm-wasi-example.md">官方 crun repo</a> 中找到详细信息。</p>
<p>要在容器镜像中添加 <code>module.wasm.image/variant=compat</code> 注释，你需要最新的 <a href="https://buildah.io/">buildah</a>。 目前，Docker 不支持此功能。请按照 <a href="https://github.com/containers/buildah/blob/main/install.md">buildah 的安装说明</a> 构建最新的 buildah 二进制文件。</p>
<h3 id="在-ubuntu-上编译并安装最新的-buildah-1"><a class="header" href="#在-ubuntu-上编译并安装最新的-buildah-1">在 Ubuntu 上编译并安装最新的 buildah</a></h3>
<p>在 Ubuntu zesty 和 xenial 上，使用这些命令为 buildah 做准备。</p>
<pre><code class="language-bash">sudo apt-get -y install software-properties-common

export OS=&quot;xUbuntu_20.04&quot;
sudo bash -c &quot;echo \&quot;deb https://download.opensuse.org/repositories/devel:/kubic:/libcontainers:/stable/$OS/ /\&quot; &gt; /etc/apt/sources.list.d/devel:kubic:libcontainers:stable.list&quot;
sudo bash -c &quot;curl -L https://download.opensuse.org/repositories/devel:/kubic:/libcontainers:/stable/$OS/Release.key | apt-key add -&quot;

sudo add-apt-repository -y ppa:alexlarsson/flatpak
sudo apt-get -y -qq update

sudo apt-get -y install bats git libapparmor-dev libdevmapper-dev libglib2.0-dev libgpgme-dev libseccomp-dev libselinux1-dev skopeo-containers go-md2man containers-common
sudo apt-get -y install golang-1.16 make
</code></pre>
<p>然后，按照下列步骤在 Ubuntu 上编译和安装 buildah。</p>
<pre><code class="language-bash">mkdir -p ~/buildah
cd ~/buildah
export GOPATH=`pwd`
git clone https://github.com/containers/buildah ./src/github.com/containers/buildah
cd ./src/github.com/containers/buildah
PATH=/usr/lib/go-1.16/bin:$PATH make
cp bin/buildah /usr/bin/buildah
buildah --help
</code></pre>
<h3 id="创建和发布具备-buildah-的容器镜像-1"><a class="header" href="#创建和发布具备-buildah-的容器镜像-1">创建和发布具备 buildah 的容器镜像</a></h3>
<p>在 <code>target/wasm32-wasi/release/</code> 文件夹下，执行下列指令。</p>
<pre><code class="language-bash">$ sudo buildah build --annotation &quot;module.wasm.image/variant=compat&quot; -t http_server .

#
# make sure docker is install and running
# systemctl status docker
# to make sure regular user can use docker
# sudo usermod -aG docker $USER#
# newgrp docker

# You may need to use docker login to create the `~/.docker/config.json` for auth.
#
# docker login

$ sudo buildah push --authfile ~/.docker/config.json http_server docker://docker.io/avengermojo/http_server:with-wasm-annotation
</code></pre>
<p>好了！ 现在你可以尝试在 <a href="kubernetes/demo/../cri/crio.html#run-a-http-server-app">CRI-O</a> 或 <a href="kubernetes/demo/../kubernetes/kubernetes.html#run-a-http-server-app">Kubernetes</a> 上运行它了！</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="容器运行时"><a class="header" href="#容器运行时">容器运行时</a></h1>
<p>容器镜像可以由任何与开放容器标准（OCI）兼容的容器运行时（runtime）启动，例如：</p>
<ul>
<li><a href="kubernetes/container/crun.html">crun</a>：高性能的轻量级容器运行时，用 C 语言编写</li>
<li><a href="kubernetes/container/runc.html">runc</a>：应用广泛的容器运行时，用 Go 语言编写</li>
<li><a href="kubernetes/container/youki.html">youki</a>：兼容 OCI 的容器运行时实现，用 Rust 编写</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="crun"><a class="header" href="#crun">crun</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="runc"><a class="header" href="#runc">runc</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="youki"><a class="header" href="#youki">youki</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cri-runtimes"><a class="header" href="#cri-runtimes">CRI runtimes</a></h1>
<p>高级容器运行时，例如 <a href="https://cri-o.io/">CRI-O</a> 和 <a href="https://containerd.io/">containerd</a>，从注册表拉取容器镜像(例如，Docker Hub)，在磁盘上管理这些镜像，并启动一个低级容器运行时来运行容器进程。
在本章节中，你可以看到一些针对 CRI-O 和 containerd 的具体教程。</p>
<ul>
<li><a href="kubernetes/cri/crio.html">CRI-O</a></li>
<li><a href="kubernetes/cri/containerd.html">containerd</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cri-o"><a class="header" href="#cri-o">CRI-O</a></h1>
<h2 id="快速开始-4"><a class="header" href="#快速开始-4">快速开始</a></h2>
<p><a href="https://github.com/second-state/wasmedge-containers-examples/">GitHub repo</a> 包含 CRI-O 相关示例的脚本和 Github Actions，以下是相关链接。</p>
<ul>
<li>WebAssembly 简单示例  <a href="https://github.com/second-state/wasmedge-containers-examples/blob/main/crio/README.md">Quick start</a> | <a href="https://github.com/second-state/wasmedge-containers-examples/blob/main/.github/workflows/crio.yml">Github Actions</a> | <a href="https://github.com/second-state/wasmedge-containers-examples/runs/4317457300?check_suite_focus=true#step:4:37">Successful run</a></li>
<li>HTTP 服务端示例 <a href="https://github.com/second-state/wasmedge-containers-examples/blob/main/crio/http_server/README.md">Quick start</a> | <a href="https://github.com/second-state/wasmedge-containers-examples/blob/main/.github/workflows/crio-server.yml">Github Actions</a> | <a href="https://github.com/second-state/wasmedge-containers-examples/runs/4317457313?check_suite_focus=true#step:4:54">Successful run</a></li>
</ul>
<p>在接下来的部分中，我们会展示如何使用这些脚本。</p>
<ul>
<li><a href="kubernetes/cri/crio.html#%E5%AE%89%E8%A3%85-cri-o">安装 CRI-O</a></li>
<li><a href="kubernetes/cri/crio.html#%E9%85%8D%E7%BD%AE-CRI-O-%E4%BB%A5%E4%BD%BF%E7%94%A8-crun">配置 CRI-O 和 crun</a></li>
<li><a href="kubernetes/cri/crio.html#%E8%BF%90%E8%A1%8C%E7%AE%80%E5%8D%95-WebAssembly-%E5%BA%94%E7%94%A8">示例一 :  WebAssembly 简单示例</a></li>
<li><a href="kubernetes/cri/crio.html#%E8%BF%90%E8%A1%8C-HTTP-%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%BA%94%E7%94%A8">示例二 : WebAssembly 中的 HTTP 服务端示例</a></li>
</ul>
<h2 id="安装-cri-o"><a class="header" href="#安装-cri-o">安装 CRI-O</a></h2>
<p>使用以下命令在你的系统上安装 CRI-O。</p>
<pre><code class="language-bash">export OS=&quot;xUbuntu_20.04&quot;
export VERSION=&quot;1.21&quot;
apt update
apt install -y libseccomp2 || sudo apt update -y libseccomp2
echo &quot;deb https://download.opensuse.org/repositories/devel:/kubic:/libcontainers:/stable/$OS/ /&quot; &gt; /etc/apt/sources.list.d/devel:kubic:libcontainers:stable.list
echo &quot;deb https://download.opensuse.org/repositories/devel:/kubic:/libcontainers:/stable:/cri-o:/$VERSION/$OS/ /&quot; &gt; /etc/apt/sources.list.d/devel:kubic:libcontainers:stable:cri-o:$VERSION.list

curl -L https://download.opensuse.org/repositories/devel:kubic:libcontainers:stable:cri-o:$VERSION/$OS/Release.key | apt-key add -
curl -L https://download.opensuse.org/repositories/devel:/kubic:/libcontainers:/stable/$OS/Release.key | apt-key add -

apt-get update
apt-get install criu libyajl2
apt-get install cri-o cri-o-runc cri-tools containernetworking-plugins
systemctl start crio
</code></pre>
<h2 id="配置-cri-o-以使用-crun"><a class="header" href="#配置-cri-o-以使用-crun">配置 CRI-O 以使用 crun</a></h2>
<p>CRI-O 默认使用 <code>runc</code> 运行时，我们需要修改配置以使用 <code>crun</code> 代替。
这需要添加到两个配置文件来完成。</p>
<blockquote>
<p>在运行下一步之前，请确保你已经构建并安装好了<a href="kubernetes/cri/../container/crun.html">支持 <code>WasmEdge</code> 的 <code>crun</code> 二进制文件</a>。</p>
</blockquote>
<p>首先，创建一个 <code>/etc/crio/crio.conf</code> 文件并添加以下内容，它会使 CRI-O 默认使用 <code>crun</code> 作为运行时。</p>
<pre><code class="language-conf">[crio.runtime]
default_runtime = &quot;crun&quot;
</code></pre>
<p><code>crun</code> 运行时在 <code>/etc/crio/crio.conf.d/01-crio-runc.conf</code> 文件中定义，按下面的内容修改此文件。</p>
<pre><code class="language-conf">[crio.runtime.runtimes.runc]
runtime_path = &quot;/usr/lib/cri-o-runc/sbin/runc&quot;
runtime_type = &quot;oci&quot;
runtime_root = &quot;/run/runc&quot;
# The above is the original content

# Add our crunw runtime here
[crio.runtime.runtimes.crun]
runtime_path = &quot;/usr/bin/crun&quot;
runtime_type = &quot;oci&quot;
runtime_root = &quot;/run/crun&quot;
</code></pre>
<p>接下来，重新启动 CRI-O 以应用配置更改。</p>
<pre><code class="language-bash">systemctl restart crio
</code></pre>
<h2 id="运行简单-webassembly-应用"><a class="header" href="#运行简单-webassembly-应用">运行简单 WebAssembly 应用</a></h2>
<p>现在，我们可以使用 CRI-O 运行一个简单的 WebAssembly 程序。
<a href="kubernetes/cri/../demo/wasi.html">另一篇文章</a> 解释了如何编译、打包和将 WebAssembly 程序作为容器镜像发布至 Docker hub。
在本节中，我们需要先使用 CRI-O 工具将这个基于 WebAssembly 的容器镜像从 Docker hub 中拉取下来。</p>
<pre><code class="language-bash">sudo crictl pull docker.io/hydai/wasm-wasi-example:with-wasm-annotation
</code></pre>
<p>接下来，我们需要创建两个简单的配置文件，指定 CRI-O 应该如何在 sandbox 中运行这个 WebAssembly 镜像。 我们已经有 <a href="https://github.com/second-state/wasmedge-containers-examples/blob/main/crio/container_wasi.json">container_wasi.json</a> 和 <a href="https://github.com/second-state/wasmedge-containers-examples/blob/main/crio/sandbox_config.json">sandbox_config.json</a> 这两个文件。你可以使用下面的命令将它们下载到本地目录。</p>
<pre><code class="language-bash">wget https://raw.githubusercontent.com/second-state/wasmedge-containers-examples/main/crio/sandbox_config.json
wget https://raw.githubusercontent.com/second-state/wasmedge-containers-examples/main/crio/container_wasi.json
</code></pre>
<p>现在你可以用 CRI-O 创建 pod 和容器。只需用本文的配置选项即可。</p>
<pre><code class="language-bash"># 创建 POD。输出会与示例不同。
$ sudo crictl runp sandbox_config.json
7992e75df00cc1cf4bff8bff660718139e3ad973c7180baceb9c84d074b516a4
# 设置一个辅助变量供之后使用。
$ POD_ID=7992e75df00cc1cf4bff8bff660718139e3ad973c7180baceb9c84d074b516a4

# 创建容器实例。输出会与示例不同。
$ sudo crictl create $POD_ID container_wasi.json sandbox_config.json
# 设置一个辅助变量供之后使用。
CONTAINER_ID=1d056e4a8a168f0c76af122d42c98510670255b16242e81f8e8bce8bd3a4476f
</code></pre>
<p>启动容器会执行 WebAssembly 程序， 你可以在控制台中看到输出。</p>
<pre><code class="language-bash"># 列出容器，容器状态应为 `Created`。
$ sudo crictl ps -a
CONTAINER           IMAGE                                          CREATED              STATE               NAME                     ATTEMPT             POD ID
1d056e4a8a168       hydai/wasm-wasi-example:with-wasm-annotation   About a minute ago   Created             podsandbox1-wasm-wasi   0                   7992e75df00cc

# 启动容器。
$ sudo crictl start $CONTAINER_ID

# 再次检查容器状态。
# 如果容器没有结束作业，你会看到它处于 Running 状态。
# 因为这个示例很小。此时你可能会看到已退出。
$ sudo crictl ps -a
CONTAINER           IMAGE                                          CREATED              STATE               NAME                     ATTEMPT             POD ID
1d056e4a8a168       hydai/wasm-wasi-example:with-wasm-annotation   About a minute ago   Running             podsandbox1-wasm-wasi   0                   7992e75df00cc

# 当容器完成作业时，你可以看到他的状态变为已退出。
$ sudo crictl ps -a
CONTAINER           IMAGE                                          CREATED              STATE               NAME                     ATTEMPT             POD ID
1d056e4a8a168       hydai/wasm-wasi-example:with-wasm-annotation   About a minute ago   Exited              podsandbox1-wasm-wasi   0                   7992e75df00cc

# 检查容器的日志，它应该显示 WebAssembly 程序的输出。
$ sudo crictl logs $CONTAINER_ID

Test 1: Print Random Number
Random number: 960251471

Test 2: Print Random Bytes
Random bytes: [50, 222, 62, 128, 120, 26, 64, 42, 210, 137, 176, 90, 60, 24, 183, 56, 150, 35, 209, 211, 141, 146, 2, 61, 215, 167, 194, 1, 15, 44, 156, 27, 179, 23, 241, 138, 71, 32, 173, 159, 180, 21, 198, 197, 247, 80, 35, 75, 245, 31, 6, 246, 23, 54, 9, 192, 3, 103, 72, 186, 39, 182, 248, 80, 146, 70, 244, 28, 166, 197, 17, 42, 109, 245, 83, 35, 106, 130, 233, 143, 90, 78, 155, 29, 230, 34, 58, 49, 234, 230, 145, 119, 83, 44, 111, 57, 164, 82, 120, 183, 194, 201, 133, 106, 3, 73, 164, 155, 224, 218, 73, 31, 54, 28, 124, 2, 38, 253, 114, 222, 217, 202, 59, 138, 155, 71, 178, 113]

Test 3: Call an echo function
Printed from wasi: This is from a main function
This is from a main function

Test 4: Print Environment Variables
The env vars are as follows.
PATH: /usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
TERM: xterm
HOSTNAME: crictl_host
PATH: /usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
The args are as follows.
/var/lib/containers/storage/overlay/006e7cf16e82dc7052994232c436991f429109edea14a8437e74f601b5ee1e83/merged/wasi_example_main.wasm
50000000

Test 5: Create a file `/tmp.txt` with content `This is in a file`

Test 6: Read the content from the previous file
File content is This is in a file

Test 7: Delete the previous file
</code></pre>
<p>接下来，你可尝试在 <a href="kubernetes/cri/../../kubernetes/kubernetes.html">Kubernetes</a> 中运行这个应用!</p>
<h2 id="运行-http-服务端应用"><a class="header" href="#运行-http-服务端应用"><strong>运行 HTTP 服务端应用</strong></a></h2>
<p>最后，我们可以在 CRI-O 中运行一个简单的基于 WebAssembly 的 HTTP 微服务。
<a href="kubernetes/cri/../demo/server.html">另一篇文章</a> 解释了如何编译、打包和将 WebAssembly 程序作为容器镜像发布至 Docker hub 。
在本节中，我们需要先使用 CRI-O 工具将这个基于 WebAssembly 的容器镜像从 Docker hub 中拉取下来。</p>
<pre><code class="language-bash">sudo crictl pull docker.io/avengermojo/http_server:with-wasm-annotation
</code></pre>
<p>接下来，我们需要创建两个简单的配置文件，指定 CRI-O 应该如何在 sandbox 中运行这个 WebAssembly 镜像。 我们已经有 <a href="https://raw.githubusercontent.com/second-state/wasmedge-containers-examples/main/crio/http_server/container_http_server.json">container_http_server.json</a> 和 <a href="https://github.com/second-state/wasmedge-containers-examples/blob/main/crio/sandbox_config.json">sandbox_config.json</a> 这两个文件。你可以使用下面的命令将它们下载到本地目录。</p>
<blockquote>
<p>HTTP 服务端示例和 WASI 简单示例使用的 <code>sandbox_config.json</code> 文件是相同的。 但另一个 <code>container_*.json</code> 文件是特定的，因为它包含应用程序的 Docker Hub 链接。</p>
</blockquote>
<pre><code class="language-bash">wget https://raw.githubusercontent.com/second-state/wasmedge-containers-examples/main/crio/sandbox_config.json
wget https://raw.githubusercontent.com/second-state/wasmedge-containers-examples/main/crio/http_server/container_http_server.json
</code></pre>
<p>现在你可以用 CRI-O 创建 pod 和容器。只需用本文的配置选项即可。</p>
<pre><code class="language-bash"># 创建 POD。输出会与示例不同。
$ sudo crictl runp sandbox_config.json
7992e75df00cc1cf4bff8bff660718139e3ad973c7180baceb9c84d074b516a4
# 设置一个辅助变量供之后使用。
$ POD_ID=7992e75df00cc1cf4bff8bff660718139e3ad973c7180baceb9c84d074b516a4

# 创建容器实例。输出会与示例不同。
$ sudo crictl create $POD_ID container_wasi.json sandbox_config.json
# 设置一个辅助变量供之后使用。
CONTAINER_ID=1d056e4a8a168f0c76af122d42c98510670255b16242e81f8e8bce8bd3a4476f
</code></pre>
<p>启动容器会执行 WebAssembly 程序， 你可以在控制台中看到输出。</p>
<pre><code class="language-bash"># 启动容器
$ sudo crictl start $CONTAINER_ID

# 检查容器状态。它应该正在运行。
# 如果没有，请等待几秒钟，然后再次检查。
$ sudo crictl ps -a
CONTAINER           IMAGE                                          CREATED                  STATE               NAME                ATTEMPT             POD ID
4eeddf8613691       avengermojo/http_server:with-wasm-annotation   Less than a second ago   Running             http_server         0                   1d84f30e7012e

# 检查容器的日志以查看 HTTP 服务器正在监听端口为 1234 。
$ sudo crictl logs $CONTAINER_ID
new connection at 1234

# 获取分配给容器的 IP 地址。
$ sudo crictl inspect $CONTAINER_ID | grep IP.0 | cut -d: -f 2 | cut -d'&quot;' -f 2
10.85.0.2

# 在该 IP 地址测试 HTTP 服务状态。
$ curl -d &quot;name=WasmEdge&quot; -X POST http://10.85.0.2:1234
echo: name=WasmEdge
</code></pre>
<p>接下来，你可尝试在 <a href="kubernetes/cri/../../kubernetes/kubernetes.html">Kubernetes</a> 中运行这个应用!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="containerd"><a class="header" href="#containerd">containerd</a></h1>
<h2 id="快速开始-5"><a class="header" href="#快速开始-5">快速开始</a></h2>
<p><a href="https://github.com/second-state/wasmedge-containers-examples/">GitHub repo</a>包含 containerd 相关示例的脚本和 Github Actions，以下是相关链接。</p>
<ul>
<li>WebAssembly 简单示例 <a href="https://github.com/second-state/wasmedge-containers-examples/blob/main/containerd/README.md">Quick start</a> | <a href="https://github.com/second-state/wasmedge-containers-examples/blob/main/.github/workflows/containerd.yml">Github Actions</a> | <a href="https://github.com/second-state/wasmedge-containers-examples/runs/4328930139?check_suite_focus=true#step:4:25">Successful run</a></li>
<li>HTTP 服务端示例 <a href="https://github.com/second-state/wasmedge-containers-examples/blob/main/containerd/http_server/README.md">Quick start</a> | <a href="https://github.com/second-state/wasmedge-containers-examples/blob/main/.github/workflows/containerd-server.yml">Github Actions</a> | <a href="https://github.com/second-state/wasmedge-containers-examples/runs/4328930141?check_suite_focus=true#step:4:44">Successful run</a></li>
</ul>
<p>在接下来的部分中，我们会展示如何使用这些脚本。</p>
<ul>
<li><a href="kubernetes/cri/containerd.html#%E5%AE%89%E8%A3%85-containerd">安装 containerd</a></li>
<li><a href="kubernetes/cri/containerd.html#%E8%BF%90%E8%A1%8C%E7%AE%80%E5%8D%95-WebAssembly-%E5%BA%94%E7%94%A8">示例一： WebAssembly 简单示例</a></li>
<li><a href="kubernetes/cri/containerd.html#%E8%BF%90%E8%A1%8C-HTTP-%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%BA%94%E7%94%A8">示例二： WebAssembly 中的 HTTP 服务端示例</a></li>
</ul>
<h2 id="安装-containerd"><a class="header" href="#安装-containerd">安装 containerd</a></h2>
<p>使用以下命令在您的系统上安装 containerd。</p>
<pre><code class="language-bash">export VERSION=&quot;1.5.7&quot;
echo -e &quot;Version: $VERSION&quot;
echo -e &quot;Installing libseccomp2 ...&quot;
sudo apt install -y libseccomp2
echo -e &quot;Installing wget&quot;
sudo apt install -y wget

wget https://github.com/containerd/containerd/releases/download/v${VERSION}/cri-containerd-cni-${VERSION}-linux-amd64.tar.gz
wget https://github.com/containerd/containerd/releases/download/v${VERSION}/cri-containerd-cni-${VERSION}-linux-amd64.tar.gz.sha256sum
sha256sum --check cri-containerd-cni-${VERSION}-linux-amd64.tar.gz.sha256sum

sudo tar --no-overwrite-dir -C / -xzf cri-containerd-cni-${VERSION}-linux-amd64.tar.gz
sudo systemctl daemon-reload
</code></pre>
<p>将 containerd 配置为使用 <code>crun</code> 作为底层 OCI runtime。
此处需要修改 <code>/etc/containerd/config.toml</code> 文件。</p>
<pre><code class="language-bash">sudo mkdir -p /etc/containerd/
sudo bash -c &quot;containerd config default &gt; /etc/containerd/config.toml&quot;
wget https://raw.githubusercontent.com/second-state/wasmedge-containers-examples/main/containerd/containerd_config.diff
sudo patch -d/ -p0 &lt; containerd_config.diff
</code></pre>
<p>启动 containerd 服务。</p>
<pre><code class="language-bash">sudo systemctl start containerd
</code></pre>
<p>在运行下一步之前，请确保你已经构建并安装好了<a href="kubernetes/cri/../container/crun.html">支持 <code>WasmEdge</code>的 <code>crun</code>二进制文件</a>。</p>
<h2 id="运行简单-webassembly-应用-1"><a class="header" href="#运行简单-webassembly-应用-1">运行简单 WebAssembly 应用</a></h2>
<p>现在，我们可以使用 containerd 运行一个简单的 WebAssembly 程序。
<a href="kubernetes/cri/../demo/wasi.html">另一篇文章</a> 解释了如何编译、打包和将 WebAssembly 程序作为容器镜像发布至 Docker hub 。
在本节中，我们需要先使用 containerd 工具将这个基于 WebAssembly 的容器镜像从 Docker hub 中拉取下来。</p>
<pre><code class="language-bash">sudo ctr i pull docker.io/hydai/wasm-wasi-example:with-wasm-annotation
</code></pre>
<p>现在，您可以使用 ctr（containerd cli 工具）运行此示例。</p>
<pre><code class="language-bash">sudo ctr run --rm --runc-binary crun --runtime io.containerd.runc.v2 --label module.wasm.image/variant=compat docker.io/hydai/wasm-wasi-example:with-wasm-annotation wasm-example /wasi_example_main.wasm 50000000
</code></pre>
<p>启动容器会执行 WebAssembly 程序， 您可以在控制台中看到输出。</p>
<pre><code class="language-bash">Creating POD ...
Random number: -1678124602
Random bytes: [12, 222, 246, 184, 139, 182, 97, 3, 74, 155, 107, 243, 20, 164, 175, 250, 60, 9, 98, 25, 244, 92, 224, 233, 221, 196, 112, 97, 151, 155, 19, 204, 54, 136, 171, 93, 204, 129, 177, 163, 187, 52, 33, 32, 63, 104, 128, 20, 204, 60, 40, 183, 236, 220, 130, 41, 74, 181, 103, 178, 43, 231, 92, 211, 219, 47, 223, 137, 70, 70, 132, 96, 208, 126, 142, 0, 133, 166, 112, 63, 126, 164, 122, 49, 94, 80, 26, 110, 124, 114, 108, 90, 62, 250, 195, 19, 189, 203, 175, 189, 236, 112, 203, 230, 104, 130, 150, 39, 113, 240, 17, 252, 115, 42, 12, 185, 62, 145, 161, 3, 37, 161, 195, 138, 232, 39, 235, 222]
Printed from wasi: This is from a main function
This is from a main function
The env vars are as follows.
The args are as follows.
/wasi_example_main.wasm
50000000
File content is This is in a file
</code></pre>
<p>接下来，你可尝试在 <a href="kubernetes/cri/../../kubernetes/kubernetes.html">Kubernetes</a>中运行这个应用!</p>
<h2 id="运行-http-服务端应用-1"><a class="header" href="#运行-http-服务端应用-1">运行 HTTP 服务端应用</a></h2>
<p>最后，我们可以在 containerd 中运行一个简单的基于 WebAssembly 的 HTTP 微服务。
<a href="kubernetes/cri/../demo/server.html">另一篇文章</a> 解释了如何编译、打包和将 WebAssembly 程序作为容器镜像发布至 Docker hub 。
在本节中，我们需要先使用 containerd 工具将这个基于 WebAssembly 的容器镜像从 Docker hub 中拉取下来。</p>
<pre><code class="language-bash">sudo ctr i pull docker.io/avengermojo/http_server:with-wasm-annotation
</code></pre>
<p>现在，您可以使用 ctr（containerd cli 工具）运行该示例。（请注意，我们需要加上 <code>--net-host</code> 参数来运行容器，以便可以从外部访问 WasmEdge 容器内的 HTTP server。）</p>
<pre><code class="language-bash">sudo ctr run --rm --net-host --runc-binary crun --runtime io.containerd.runc.v2 --label module.wasm.image/variant=compat docker.io/avengermojo/http_server:with-wasm-annotation http-server-example /http_server.wasm
</code></pre>
<p>启动容器会执行 WebAssembly 程序， 您可以在控制台中看到输出。</p>
<pre><code class="language-bash">new connection at 1234

# Test the HTTP service at that IP address
curl -d &quot;name=WasmEdge&quot; -X POST http://127.0.0.1:1234
echo: name=WasmEdge
</code></pre>
<p>接下来，你可尝试在 <a href="kubernetes/cri/../../kubernetes/kubernetes.html">Kubernetes</a> 中运行这个应用!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="kubernetes"><a class="header" href="#kubernetes">Kubernetes</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="kubernetes--cri-o"><a class="header" href="#kubernetes--cri-o">Kubernetes + CRI-O</a></h1>
<h2 id="快速开始-6"><a class="header" href="#快速开始-6">快速开始</a></h2>
<p><a href="https://github.com/second-state/wasmedge-containers-examples/">这个 GitHub 仓库</a> 中包含了使用 Kubernetes + CRI-O 运行示例程序所需的脚本和 Github Actions 配置文件。</p>
<ul>
<li>
<p>简单示例程序 <a href="https://github.com/second-state/wasmedge-containers-examples/blob/main/kubernetes_crio/README.md">快速开始</a> | <a href="https://github.com/second-state/wasmedge-containers-examples/blob/main/.github/workflows/kubernetes-crio.yml">查看 Github Actions 配置文件</a> | <a href="https://github.com/second-state/wasmedge-containers-examples/runs/4328930134?check_suite_focus=true#step:6:3007">查看运行结果</a></p>
</li>
<li>
<p>基于 WebAssembly 的 HTTP 服务 <a href="https://github.com/second-state/wasmedge-containers-examples/blob/main/kubernetes_crio/http_server/README.md">快速开始</a> | <a href="https://github.com/second-state/wasmedge-containers-examples/blob/main/.github/workflows/kubernetes-crio-server.yml">查看 Github Actions 配置文件</a> | <a href="https://github.com/second-state/wasmedge-containers-examples/runs/4577789182?check_suite_focus=true#step:6:3030">查看运行结果</a></p>
</li>
</ul>
<p>本节接下来的部分将详细地解释其中的细节。你需要先 <a href="kubernetes/kubernetes/../cri/crio.html">安装并配置好 CRI-O</a> 才能使用 WasmEdge 容器镜像。</p>
<h2 id="安装和启动-kubernetes"><a class="header" href="#安装和启动-kubernetes">安装和启动 Kubernetes</a></h2>
<p>在终端窗口运行下面的脚本，就可以在本地开发环境中安装和启动一个 Kubernetes。</p>
<pre><code class="language-bash"># 安装 go
$ wget https://golang.org/dl/go1.17.1.linux-amd64.tar.gz
$ sudo rm -rf /usr/local/go
sudo tar -C /usr/local -xzf go1.17.1.linux-amd64.tar.gz
source /home/${USER}/.profile

# 克隆 k8s
git clone https://github.com/kubernetes/kubernetes.git
cd kubernetes
git checkout v1.22.2

# 用 k8s 中的安装脚本安装 etcd
sudo CGROUP_DRIVER=systemd CONTAINER_RUNTIME=remote CONTAINER_RUNTIME_ENDPOINT='unix:///var/run/crio/crio.sock' ./hack/install-etcd.sh
export PATH=&quot;/home/${USER}/kubernetes/third_party/etcd:${PATH}&quot;
sudo cp third_party/etcd/etcd* /usr/local/bin/

# 以上命令运行完毕以后，系统中就可以找到以下文件：/usr/local/bin/etcd  /usr/local/bin/etcdctl  /usr/local/bin/etcdutl 

# 用 CRI-O 构建运行 k8s
sudo apt-get install -y build-essential
sudo CGROUP_DRIVER=systemd CONTAINER_RUNTIME=remote CONTAINER_RUNTIME_ENDPOINT='unix:///var/run/crio/crio.sock' ./hack/local-up-cluster.sh

... ...
Local Kubernetes cluster is running. Press Ctrl-C to shut it down.
</code></pre>
<p>此时<strong>不要</strong>关闭终端，因为 Kubernetes 正在运行中！</p>
<h2 id="在-kubernetes-中运行-webassembly-容器镜像"><a class="header" href="#在-kubernetes-中运行-webassembly-容器镜像">在 Kubernetes 中运行 WebAssembly 容器镜像</a></h2>
<p>本节的内容介绍了如何在 Kubernetes 中，以 pod 中的容器的形式来运行 WebAssembly 程序。我们需要打开另一个终端。</p>
<pre><code class="language-bash">$ export KUBERNETES_PROVIDER=local

$ sudo cluster/kubectl.sh config set-cluster local --server=https://localhost:6443 --certificate-authority=/var/run/kubernetes/server-ca.crt
$ sudo cluster/kubectl.sh config set-credentials myself --client-key=/var/run/kubernetes/client-admin.key --client-certificate=/var/run/kubernetes/client-admin.crt
$ sudo cluster/kubectl.sh config set-context local --cluster=local --user=myself
$ sudo cluster/kubectl.sh config use-context local
$ sudo cluster/kubectl.sh
</code></pre>
<p>检查一下集群状态，看看集群有没有正常运行。</p>
<pre><code class="language-bash">$ sudo cluster/kubectl.sh cluster-info

# 运行命令后预计会有以下输出
Cluster &quot;local&quot; set.
User &quot;myself&quot; set.
Context &quot;local&quot; created.
Switched to context &quot;local&quot;.
Kubernetes control plane is running at https://localhost:6443
CoreDNS is running at https://localhost:6443/api/v1/namespaces/kube-system/services/kube-dns:dns/proxy

To further debug and diagnose cluster problems, use 'kubectl cluster-info dump'.
</code></pre>
<h3 id="简单的-webassembly-应用"><a class="header" href="#简单的-webassembly-应用">简单的 WebAssembly 应用</a></h3>
<p><a href="kubernetes/kubernetes/../demo/wasi.html">这篇文章</a> 描述了如何编译、打包一个简单的 WebAssembly WASI 程序，以及将它以容器镜像的形式发布到 Docker hub 的完整过程。</p>
<pre><code class="language-bash">$ sudo cluster/kubectl.sh run -it --rm --restart=Never wasi-demo --image=hydai/wasm-wasi-example:with-wasm-annotation --annotations=&quot;module.wasm.image/variant=compat&quot; /wasi_example_main.wasm 50000000
</code></pre>
<p>容器化后的应用程序的输出会被打印到控制台上。</p>
<pre><code class="language-bash">Random number: 401583443
Random bytes: [192, 226, 162, 92, 129, 17, 186, 164, 239, 84, 98, 255, 209, 79, 51, 227, 103, 83, 253, 31, 78, 239, 33, 218, 68, 208, 91, 56, 37, 200, 32, 12, 106, 101, 241, 78, 161, 16, 240, 158, 42, 24, 29, 121, 78, 19, 157, 185, 32, 162, 95, 214, 175, 46, 170, 100, 212, 33, 27, 190, 139, 121, 121, 222, 230, 125, 251, 21, 210, 246, 215, 127, 176, 224, 38, 184, 201, 74, 76, 133, 233, 129, 48, 239, 106, 164, 190, 29, 118, 71, 79, 203, 92, 71, 68, 96, 33, 240, 228, 62, 45, 196, 149, 21, 23, 143, 169, 163, 136, 206, 214, 244, 26, 194, 25, 101, 8, 236, 247, 5, 164, 117, 40, 220, 52, 217, 92, 179]
Printed from wasi: This is from a main function
This is from a main function
The env vars are as follows.
The args are as follows.
/wasi_example_main.wasm
50000000
File content is This is in a file
pod &quot;wasi-demo-2&quot; deleted
</code></pre>
<h3 id="基于-webassembly-的-http-服务"><a class="header" href="#基于-webassembly-的-http-服务">基于 WebAssembly 的 HTTP 服务</a></h3>
<p><a href="kubernetes/kubernetes/../demo/server.html">这篇文章</a> 描述了如何编译、打包一个基于 WebAssembly 的 HTTP 服务应用程序，以及将它以容器镜像的形式发布到 Docker hub 的完整过程。由于运行 HTTP 服务的容器需要 Kubernetes 提供网络支持，我们需要用 <a href="https://github.com/second-state/wasmedge-containers-examples/blob/main/kubernetes_crio/http_server/k8s-http_server.yaml">k8s-http_server.yaml</a> 文件设定具体的配置。</p>
<pre><code class="language-yaml">apiVersion: v1
kind: Pod
metadata:
  name: http-server
  namespace: default
  annotations:
    module.wasm.image/variant: compat
spec:
  hostNetwork: true
  containers:
  - name: http-server
    image: avengermojo/http_server:with-wasm-annotation
    command: [ &quot;/http_server.wasm&quot; ]
    ports:
    - containerPort: 1234
      protocol: TCP
    livenessProbe:
      tcpSocket:
        port: 1234
      initialDelaySeconds: 3
      periodSeconds: 30
</code></pre>
<p>输入下面的命令，可以使用上面的 <code>k8s-http_server.yaml</code> 文件，从 Docker Hub 拉取并运行基于 WebAssembly 的镜像。</p>
<pre><code class="language-bash">$ sudo ./kubernetes/cluster/kubectl.sh apply -f k8s-http_server.yaml
</code></pre>
<p>然后运行以下命令，查看运行中的容器应用程序和他们的 IP 地址。我们在 yaml 配置中用的是 <code>hostNetwork</code> 网络，所以 HTTP 服务器镜像会在 IP 为 <code>127.0.0.1</code> 的本地网络中运行。</p>
<pre><code class="language-bash">$ sudo cluster/kubectl.sh get pod --all-namespaces -o wide

NAMESPACE     NAME                       READY   STATUS             RESTARTS      AGE   IP          NODE        NOMINATED NODE   READINESS GATES
default       http-server                1/1     Running            1 (26s ago)     60s     127.0.0.1   127.0.0.1   &lt;none&gt;           &lt;none&gt;
</code></pre>
<p>现在，我们可以用 <code>curl</code> 命令来访问 HTTP 服务了。</p>
<pre><code class="language-bash">$ curl -d &quot;name=WasmEdge&quot; -X POST http://127.0.0.1:1234
echo: name=WasmEdge
</code></pre>
<p>搞定！</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="kubernetes--containerd"><a class="header" href="#kubernetes--containerd">Kubernetes + containerd</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="kind"><a class="header" href="#kind">KinD</a></h1>
<p>KinD 是在 Docker 内部运行的 Kubernetes 发行版，非常适合本地开发或集成测试。</p>
<h2 id="快速开始-7"><a class="header" href="#快速开始-7">快速开始</a></h2>
<p>作为先决条件，我们第一步需要安装 KinD。为此，请参阅<a href="https://kind.sigs.k8s.io/docs/user/quick-start/#installing-from-release-binaries">快速入门指南</a>和<a href="https://kind.sigs.k8s.io/docs/user/quick-start/#installing-from-release-binaries">稳定版发布页面</a>来安装最新版本的 KinD CLI。</p>
<p>如果已经安装了 KinD，我们可以直接从<a href="https://github.com/Liquid-Reply/kind-crun-wasm">这里</a>中的示例开始：</p>
<pre><code class="language-bash"># Create a &quot;WASM in KinD&quot; Cluster
kind create cluster --image ghcr.io/liquid-reply/kind-crun-wasm:v1.23.0
# Run the example
kubectl run -it --rm --restart=Never wasi-demo --image=hydai/wasm-wasi-example:with-wasm-annotation --annotations=&quot;module.wasm.image/variant=compat&quot; /wasi_example_main.wasm 50000000
</code></pre>
<p>在这个章节的剩余部分，我们会介绍如何去创建一个带有 wasmedge 的支持 KinD 的节点镜像。</p>
<h2 id="编译-crun"><a class="header" href="#编译-crun">编译 crun</a></h2>
<p>KinD 使用 kindest/node 这个镜像作为控制平面和工作节点。该镜像包括作为 CRI 的 containerd 和作为 OCI 运行时的 runc。为了启用 WasmEdge 支持，我们将 runc 替换为 crun。</p>
<pre><code class="language-Dockerfile">FROM ubuntu:21.10 AS builder
WORKDIR /data
RUN DEBIAN_FRONTEND=noninteractive apt update \
    &amp;&amp; DEBIAN_FRONTEND=noninteractive apt install -y curl make git gcc build-essential pkgconf libtool libsystemd-dev libprotobuf-c-dev libcap-dev libseccomp-dev libyajl-dev go-md2man libtool autoconf python3 automake \
    &amp;&amp; curl https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/utils/install.sh | bash -s -- -p /usr/local \
    &amp;&amp; git clone --single-branch --branch feat/handler_per_container https://github.com/liquid-reply/crun \
    &amp;&amp; cd crun \
    &amp;&amp; ./autogen.sh \
    &amp;&amp; ./configure --with-wasmedge --enable-embedded-yajl\
    &amp;&amp; make 

...
</code></pre>
<p>现在我们在 <code>/data/crun/crun</code> 目录下有了一个新的可以支持 wasmedge 的 <code>crun</code> 二进制文件，我们可以在下一步中从这个容器中复制它。</p>
<h2 id="替代-crun-和配置-containerd"><a class="header" href="#替代-crun-和配置-containerd">替代 crun 和配置 containerd</a></h2>
<p>runc 和 crun 都实现了 OCI 运行时规范，并且它们具有相同的 CLI 参数。因此我们可以用之前创建的 crun-wasmedge 二进制文件替换 runc 二进制文件。</p>
<p>由于 crun 使用了一些共享库，我们需要安装 libyajl、wasmedge 和 criu 来使 crun 工作。</p>
<p>现在我们已经有了一个使用 crun 而不是 runc 的 KinD。现在我们只需要将两个配置更改即可。第一个是在 <code>/etc/containerd/config.toml</code> 中，我们添加了可以传递给运行时的 <code>pod_annotations</code>：</p>
<pre><code class="language-toml">[plugins.&quot;io.containerd.grpc.v1.cri&quot;.containerd.runtimes.runc]
  pod_annotations = [&quot;*.wasm.*&quot;, &quot;wasm.*&quot;, &quot;module.wasm.image/*&quot;, &quot;*.module.wasm.image&quot;, &quot;module.wasm.image/variant.*&quot;]
</code></pre>
<p>第二个是在 <code>/etc/containerd/cri-base.json</code> 中，我们删除了一个导致一些问题的 hook。</p>
<p>生成的 dockerfile 如下所示：</p>
<pre><code class="language-Dockerfile">...

FROM kindest/node:v1.23.0

COPY config.toml /etc/containerd/config.toml
COPY --from=builder /data/crun/crun /usr/local/sbin/runc
COPY --from=builder /usr/local/lib/libwasmedge_c.so /usr/local/lib/libwasmedge_c.so

RUN echo &quot;Installing Packages ...&quot; \
    &amp;&amp; bash -c 'cat &lt;&lt;&lt; $(jq &quot;del(.hooks.createContainer)&quot; /etc/containerd/cri-base.json) &gt; /etc/containerd/cri-base.json' \
    &amp;&amp; ldconfig
</code></pre>
<h2 id="编译和测试"><a class="header" href="#编译和测试">编译和测试</a></h2>
<p>最终我们构建了一个新的 <code>node-wasmedge</code> 镜像。为了测试它，我们从该图像创建一个 kind 集群并运行简单的应用程序示例。</p>
<pre><code class="language-bash">$ docker build -t node-wasmedge .
$ kind create cluster --image node-wasmedge
# Now you can run the example to validate your cluster
$ kubectl run -it --rm --restart=Never wasi-demo --image=hydai/wasm-wasi-example:with-wasm-annotation --annotations=&quot;module.wasm.image/variant=compat&quot; /wasi_example_main.wasm 50000000
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="为-kubeedge-创建一个-crun-示例"><a class="header" href="#为-kubeedge-创建一个-crun-示例">为 KubeEdge 创建一个 <code>crun</code> 示例</a></h1>
<h2 id="1-云端设置kubeedge-主节点"><a class="header" href="#1-云端设置kubeedge-主节点">1. 云端设置（KubeEdge 主节点）</a></h2>
<h3 id="安装-go"><a class="header" href="#安装-go">安装 Go</a></h3>
<pre><code class="language-bash">$ wget https://golang.org/dl/go1.17.3.linux-amd64.tar.gz
$ tar xzvf go1.17.3.linux-amd64.tar.gz

$ export PATH=/home/${user}/go/bin:$PATH
$ go version
go version go1.17.3 linux/amd64
</code></pre>
<h3 id="安装-cri-o-1"><a class="header" href="#安装-cri-o-1">安装 CRI-O</a></h3>
<p>请参阅 <a href="https://github.com/cri-o/cri-o/blob/main/install.md#install-packaged-versions-of-cri-o">CRI-O Installation Instructions</a>.</p>
<pre><code class="language-bash"># 创建 .conf 文件以在启动时加载模块
$ cat &lt;&lt;EOF | sudo tee /etc/modules-load.d/crio.conf
overlay
br_netfilter
EOF

$ sudo modprobe overlay
$ sudo modprobe br_netfilter

# 设置所需的 sysctl 参数，这些参数在重启后仍然存在。
$ cat &lt;&lt;EOF | sudo tee /etc/sysctl.d/99-kubernetes-cri.conf
net.bridge.bridge-nf-call-iptables  = 1
net.ipv4.ip_forward                 = 1
net.bridge.bridge-nf-call-ip6tables = 1
EOF

$ sudo sysctl --system
$ export OS=&quot;xUbuntu_20.04&quot;
$ export VERSION=&quot;1.21&quot;
$ cat &lt;&lt;EOF | sudo tee /etc/apt/sources.list.d/devel:kubic:libcontainers:stable.list
deb https://download.opensuse.org/repositories/devel:/kubic:/libcontainers:/stable/$OS/ /
EOF
$ cat &lt;&lt;EOF | sudo tee /etc/apt/sources.list.d/devel:kubic:libcontainers:stable:cri-o:$VERSION.list
deb http://download.opensuse.org/repositories/devel:/kubic:/libcontainers:/stable:/cri-o:/$VERSION/$OS/ /
EOF

$ curl -L https://download.opensuse.org/repositories/devel:/kubic:/libcontainers:/stable/$OS/Release.key | sudo apt-key --keyring /etc/apt/trusted.gpg.d/libcontainers.gpg add -
$ curl -L https://download.opensuse.org/repositories/devel:kubic:libcontainers:stable:cri-o:$VERSION/$OS/Release.key | sudo apt-key --keyring /etc/apt/trusted.gpg.d/libcontainers-cri-o.gpg add -

$ sudo apt-get update
$ sudo apt-get install cri-o cri-o-runc

$ sudo systemctl daemon-reload
$ sudo systemctl enable crio --now
$ sudo systemctl status cri-o
</code></pre>
<p>输出：</p>
<pre><code class="language-bash">$ sudo systemctl status cri-o
● crio.service - Container Runtime Interface for OCI (CRI-O)
     Loaded: loaded (/lib/systemd/system/crio.service; enabled; vendor preset: enabled)
     Active: active (running) since Mon 2021-12-06 13:46:29 UTC; 16h ago
       Docs: https://github.com/cri-o/cri-o
   Main PID: 6868 (crio)
      Tasks: 14
     Memory: 133.2M
     CGroup: /system.slice/crio.service
             └─6868 /usr/bin/crio

Dec 07 06:04:13 master crio[6868]: time=&quot;2021-12-07 06:04:13.694226800Z&quot; level=info msg=&quot;Checking image status: k8s.gcr.io/pause:3.4.1&quot; id=1dbb722e-f031-410c-9f45-5d4b5760163e name=/runtime.v1alpha2.ImageServic&gt;
Dec 07 06:04:13 master crio[6868]: time=&quot;2021-12-07 06:04:13.695739507Z&quot; level=info msg=&quot;Image status: &amp;{0xc00047fdc0 map[]}&quot; id=1dbb722e-f031-410c-9f45-5d4b5760163e name=/runtime.v1alpha2.ImageService/ImageSta&gt;
Dec 07 06:09:13 master crio[6868]: time=&quot;2021-12-07 06:09:13.698823984Z&quot; level=info msg=&quot;Checking image status: k8s.gcr.io/pause:3.4.1&quot; id=661b754b-48a4-401b-a03f-7f7a553c7eb6 name=/runtime.v1alpha2.ImageServic&gt;
Dec 07 06:09:13 master crio[6868]: time=&quot;2021-12-07 06:09:13.703259157Z&quot; level=info msg=&quot;Image status: &amp;{0xc0004d98f0 map[]}&quot; id=661b754b-48a4-401b-a03f-7f7a553c7eb6 name=/runtime.v1alpha2.ImageService/ImageSta&gt;
Dec 07 06:14:13 master crio[6868]: time=&quot;2021-12-07 06:14:13.707778419Z&quot; level=info msg=&quot;Checking image status: k8s.gcr.io/pause:3.4.1&quot; id=8c7e4d36-871a-452e-ab55-707053604077 name=/runtime.v1alpha2.ImageServic&gt;
Dec 07 06:14:13 master crio[6868]: time=&quot;2021-12-07 06:14:13.709379469Z&quot; level=info msg=&quot;Image status: &amp;{0xc000035030 map[]}&quot; id=8c7e4d36-871a-452e-ab55-707053604077 name=/runtime.v1alpha2.ImageService/ImageSta&gt;
Dec 07 06:19:13 master crio[6868]: time=&quot;2021-12-07 06:19:13.713158978Z&quot; level=info msg=&quot;Checking image status: k8s.gcr.io/pause:3.4.1&quot; id=827b6315-f145-4f76-b8da-31653d5892a2 name=/runtime.v1alpha2.ImageServic&gt;
Dec 07 06:19:13 master crio[6868]: time=&quot;2021-12-07 06:19:13.714030148Z&quot; level=info msg=&quot;Image status: &amp;{0xc000162bd0 map[]}&quot; id=827b6315-f145-4f76-b8da-31653d5892a2 name=/runtime.v1alpha2.ImageService/ImageSta&gt;
Dec 07 06:24:13 master crio[6868]: time=&quot;2021-12-07 06:24:13.716746612Z&quot; level=info msg=&quot;Checking image status: k8s.gcr.io/pause:3.4.1&quot; id=1d53a917-4d98-4723-9ea8-a2951a472cff name=/runtime.v1alpha2.ImageServic&gt;
Dec 07 06:24:13 master crio[6868]: time=&quot;2021-12-07 06:24:13.717381882Z&quot; level=info msg=&quot;Image status: &amp;{0xc00042ce00 map[]}&quot; id=1d53a917-4d98-4723-9ea8-a2951a472cff name=/runtime.v1alpha2.ImageService/ImageSta&gt;
</code></pre>
<h3 id="使用-k8s-kubeadm-安装和创建集群"><a class="header" href="#使用-k8s-kubeadm-安装和创建集群">使用 K8s Kubeadm 安装和创建集群</a></h3>
<p>请参阅 <a href="https://kubernetes.io/zh/docs/setup/production-environment/tools/kubeadm/create-cluster-kubeadm/">使用 kubeadm 创建集群</a>.</p>
<h4 id="安装-k8s"><a class="header" href="#安装-k8s">安装 K8s</a></h4>
<pre><code class="language-bash">sudo apt-get update
sudo apt-get install -y apt-transport-https curl
echo &quot;deb [signed-by=/usr/share/keyrings/kubernetes-archive-keyring.gpg] https://apt.kubernetes.io/ kubernetes-xenial main&quot; | sudo tee /etc/apt/sources.list.d/kubernetes.list

sudo apt update
K_VER=&quot;1.21.0-00&quot;
sudo apt install -y kubelet=${K_VER} kubectl=${K_VER} kubeadm=${K_VER}
sudo apt-mark hold kubelet kubeadm kubectl
</code></pre>
<h4 id="使用-kubeadm-创建集群"><a class="header" href="#使用-kubeadm-创建集群">使用 kubeadm 创建集群</a></h4>
<pre><code class="language-bash"># kubernetes 调度程序需要进行此设置。
$ sudo swapoff -a
$ sudo vim /etc/fstab
mark contain swapfile of row

$ cat /etc/cni/net.d/100-crio-bridge.conf
{
    &quot;cniVersion&quot;: &quot;0.3.1&quot;,
    &quot;name&quot;: &quot;crio&quot;,
    &quot;type&quot;: &quot;bridge&quot;,
    &quot;bridge&quot;: &quot;cni0&quot;,
    &quot;isGateway&quot;: true,
    &quot;ipMasq&quot;: true,
    &quot;hairpinMode&quot;: true,
    &quot;ipam&quot;: {
        &quot;type&quot;: &quot;host-local&quot;,
        &quot;routes&quot;: [
            { &quot;dst&quot;: &quot;0.0.0.0/0&quot; },
            { &quot;dst&quot;: &quot;1100:200::1/24&quot; }
        ],
        &quot;ranges&quot;: [
            [{ &quot;subnet&quot;: &quot;10.85.0.0/16&quot; }],
            [{ &quot;subnet&quot;: &quot;1100:200::/24&quot; }]
        ]
    }
}
$ export CIDR=10.85.0.0/16
$ sudo kubeadm init --apiserver-advertise-address=192.168.122.160 --pod-network-cidr=$CIDR --cri-socket=/var/run/crio/crio.sock

$ mkdir -p $HOME/.kube
$ sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config
$ sudo chown $(id -u):$(id -g) $HOME/.kube/config
</code></pre>
<p>输出：</p>
<pre><code class="language-bash">Your Kubernetes control-plane has initialized successfully!

To start using your cluster, you need to run the following as a regular user:

  mkdir -p $HOME/.kube
  sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config
  sudo chown $(id -u):$(id -g) $HOME/.kube/config

You should now deploy a Pod network to the cluster.
Run &quot;kubectl apply -f [podnetwork].yaml&quot; with one of the options listed at:
  /docs/concepts/cluster-administration/addons/

You can now join any number of machines by running the following on each node
as root:

  kubeadm join &lt;control-plane-host&gt;:&lt;control-plane-port&gt; --token &lt;token&gt; --discovery-token-ca-cert-hash sha256:&lt;hash&gt;
</code></pre>
<p>要让 kubectl 为你的非 root 用户工作，请运行这些命令，这些命令也是 kubeadm init 输出的一部分：</p>
<pre><code class="language-bash">mkdir -p $HOME/.kube
sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config
sudo chown $(id -u):$(id -g) $HOME/.kube/config
</code></pre>
<h3 id="设置-kubeedge-主节点"><a class="header" href="#设置-kubeedge-主节点">设置 KubeEdge 主节点</a></h3>
<p>请参阅 <a href="https://kubeedge.io/zh/docs/setup/keadm/">使用 Keadm 进行部署</a>。</p>
<p>重要提醒:</p>
<ol>
<li>kubeconfig 或 master 中的至少一项必须配置正确，才能用于验证 k8s 集群的版本等信息。</li>
<li>请确保边缘节点可以使用云节点的本地 IP 连接云节点，或者你需要使用 <code>--advertise-address</code> 标志指定云节点的公共 IP。</li>
<li><code>--advertise-address</code>（仅 1.3 版本起有效）为云端公开的地址（将添加到 CloudCore 证书的 SAN 中），默认值为本地IP。</li>
</ol>
<pre><code class="language-bash">wget https://github.com/kubeedge/kubeedge/releases/download/v1.8.0/keadm-v1.8.0-linux-amd64.tar.gz
tar xzvf keadm-v1.8.0-linux-amd64.tar.gz
cd keadm-v1.8.0-linux-amd64/keadm/
sudo ./keadm init --advertise-address=192.168.122.160 --kube-config=/home/${user}/.kube/config
</code></pre>
<p>输出：</p>
<pre><code class="language-bash">Kubernetes version verification passed, KubeEdge installation will start...
...
KubeEdge cloudcore is running, For logs visit:  /var/log/kubeedge/cloudcore.log
</code></pre>
<h2 id="2-设置边缘端kubeedge-工作节点"><a class="header" href="#2-设置边缘端kubeedge-工作节点">2. 设置边缘端（KubeEdge 工作节点）</a></h2>
<p>你可以使用 CRI-O install.sh 脚本 <code>crun</code> 在 Ubuntu 20.04 上安装 CRI-O。</p>
<pre><code class="language-bash">wget -qO- https://raw.githubusercontent.com/second-state/wasmedge-containers-examples/main/crio/install.sh | bash
</code></pre>
<h3 id="在工作节点安装-go"><a class="header" href="#在工作节点安装-go">在工作节点安装 Go</a></h3>
<pre><code class="language-bash">$ wget https://golang.org/dl/go1.17.3.linux-amd64.tar.gz
$ tar xzvf go1.17.3.linux-amd64.tar.gz

$ export PATH=/home/${user}/go/bin:$PATH
$ go version
go version go1.17.3 linux/amd64
</code></pre>
<h3 id="从云端获取令牌"><a class="header" href="#从云端获取令牌">从云端获取令牌</a></h3>
<p>在云端运行 <code>keadm gettoken</code> 会返回 token ，在加入边缘节点时使用。</p>
<pre><code class="language-bash">$ sudo ./keadm gettoken --kube-config=/home/${user}/.kube/config
27a37ef16159f7d3be8fae95d588b79b3adaaf92727b72659eb89758c66ffda2.eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJleHAiOjE1OTAyMTYwNzd9.JBj8LLYWXwbbvHKffJBpPd5CyxqapRQYDIXtFZErgYE
</code></pre>
<h3 id="下载-kubeedge-并加入边缘节点"><a class="header" href="#下载-kubeedge-并加入边缘节点">下载 Kubeedge 并加入边缘节点</a></h3>
<p>请参阅 <a href="https://kubeedge.io/zh/docs/advanced/cri/#cri-o">使用 CRI 设置不同的容器运行时</a> 和 <a href="https://kubeedge.io/zh/docs/setup/keadm/">使用 Keadm 部署</a>.</p>
<pre><code class="language-bash">$ wget https://github.com/kubeedge/kubeedge/releases/download/v1.8.0/keadm-v1.8.0-linux-amd64.tar.gz
$ tar xzvf keadm-v1.8.0-linux-amd64.tar.gz
$ cd keadm-v1.8.0-linux-amd64/keadm/

$ sudo ./keadm join \
--cloudcore-ipport=192.168.122.160:10000 \
--edgenode-name=edge \
--token=b4550d45b773c0480446277eed1358dcd8a02a0c214646a8082d775f9c447d81.eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJleHAiOjE2Mzg4ODUzNzd9.A9WOYJFrgL2swVGnydpb4gMojyvyoNPCXaA4rXGowqU \
--remote-runtime-endpoint=unix:///var/run/crio/crio.sock \
--runtimetype=remote \
--cgroupdriver=systemd
</code></pre>
<p>输出：</p>
<pre><code class="language-bash">Host has mosquit+ already installed and running. Hence skipping the installation steps !!!
...
KubeEdge edgecore is running, For logs visit:  /var/log/kubeedge/edgecore.log
</code></pre>
<h3 id="从云端获取边缘节点状态"><a class="header" href="#从云端获取边缘节点状态">从云端获取边缘节点状态</a></h3>
<p>输出：</p>
<pre><code class="language-bash">kubectl get node
NAME       STATUS    ROLES                  AGE   VERSION
edge       Ready     agent,edge             10s   v1.19.3-kubeedge-v1.8.2
master     Ready     control-plane,master   68m   v1.21.0
</code></pre>
<h2 id="3-启用-kubectl-日志功能"><a class="header" href="#3-启用-kubectl-日志功能">3. 启用 kubectl 日志功能</a></h2>
<p>在部署 metrics-server 之前，必须激活 kubectl 日志功能，请<a href="https://kubeedge.io/zh/docs/setup/keadm/#enable-kubectl-logs-feature">参阅这里</a>.</p>
<h2 id="4-运行一个简单的-webassembly-应用"><a class="header" href="#4-运行一个简单的-webassembly-应用">4. 运行一个简单的 WebAssembly 应用</a></h2>
<p>我们可以从 Kubernetes 集群中的 Docker Hub 运行基于 WebAssembly 的镜像。</p>
<h3 id="云端"><a class="header" href="#云端">云端</a></h3>
<pre><code class="language-bash">$ kubectl run -it --restart=Never wasi-demo --image=hydai/wasm-wasi-example:with-wasm-annotation --annotations=&quot;module.wasm.image/variant=compat&quot; /wasi_example_main.wasm 50000000

Random number: -1694733782
Random bytes: [6, 226, 176, 126, 136, 114, 90, 2, 216, 17, 241, 217, 143, 189, 123, 197, 17, 60, 49, 37, 71, 69, 67, 108, 66, 39, 105, 9, 6, 72, 232, 238, 102, 5, 148, 243, 249, 183, 52, 228, 54, 176, 63, 249, 216, 217, 46, 74, 88, 204, 130, 191, 182, 19, 118, 193, 77, 35, 189, 6, 139, 68, 163, 214, 231, 100, 138, 246, 185, 47, 37, 49, 3, 7, 176, 97, 68, 124, 20, 235, 145, 166, 142, 159, 114, 163, 186, 46, 161, 144, 191, 211, 69, 19, 179, 241, 8, 207, 8, 112, 80, 170, 33, 51, 251, 33, 105, 0, 178, 175, 129, 225, 112, 126, 102, 219, 106, 77, 242, 104, 198, 238, 193, 247, 23, 47, 22, 29]
Printed from wasi: This is from a main function
This is from a main function
The env vars are as follows.
The args are as follows.
/wasi_example_main.wasm
50000000
File content is This is in a file
</code></pre>
<p>WebAssembly 应用的 pod 成功部署到边缘节点。</p>
<pre><code class="language-bash">$ kubectl describe pod wasi-demo

Name:         wasi-demo
Namespace:    default
Priority:     0
Node:         edge/192.168.122.229
Start Time:   Mon, 06 Dec 2021 15:45:34 +0000
Labels:       run=wasi-demo
Annotations:  module.wasm.image/variant: compat
Status:       Succeeded
IP:           
IPs:          &lt;none&gt;
Containers:
  wasi-demo:
    Container ID:  cri-o://1ae4d0d7f671050331a17e9b61b5436bf97ad35ad0358bef043ab820aed81069
    Image:         hydai/wasm-wasi-example:with-wasm-annotation
    Image ID:      docker.io/hydai/wasm-wasi-example@sha256:525aab8d6ae8a317fd3e83cdac14b7883b92321c7bec72a545edf276bb2100d6
    Port:          &lt;none&gt;
    Host Port:     &lt;none&gt;
    Args:
      /wasi_example_main.wasm
      50000000
    State:          Terminated
      Reason:       Completed
      Exit Code:    0
      Started:      Mon, 06 Dec 2021 15:45:33 +0000
      Finished:     Mon, 06 Dec 2021 15:45:33 +0000
    Ready:          False
    Restart Count:  0
    Environment:    &lt;none&gt;
    Mounts:
      /var/run/secrets/kubernetes.io/serviceaccount from kube-api-access-bhszr (ro)
Conditions:
  Type           Status
  Initialized    True 
  Ready          False 
  PodScheduled   True 
Volumes:
  kube-api-access-bhszr:
    Type:                    Projected (a volume that contains injected data from multiple sources)
    TokenExpirationSeconds:  3607
    ConfigMapName:           kube-root-ca.crt
    ConfigMapOptional:       &lt;nil&gt;
    DownwardAPI:             true
QoS Class:                   BestEffort
Node-Selectors:              &lt;none&gt;
Tolerations:                 node.kubernetes.io/not-ready:NoExecute op=Exists for 300s
                             node.kubernetes.io/unreachable:NoExecute op=Exists for 300s
Events:
  Type    Reason     Age   From               Message
  ----    ------     ----  ----               -------
</code></pre>
<h3 id="边缘端"><a class="header" href="#边缘端">边缘端</a></h3>
<pre><code class="language-bash">$ sudo crictl ps -a
CONTAINER           IMAGE                                                                                           CREATED             STATE               NAME                ATTEMPT             POD ID
1ae4d0d7f6710       0423b8eb71e312b8aaa09a0f0b6976381ff567d5b1e5729bf9b9aa87bff1c9f3                                16 minutes ago      Exited              wasi-demo           0                   2bc2ac0c32eda
1e6c7cb6bc731       k8s.gcr.io/kube-proxy@sha256:2a25285ff19f9b4025c8e54dac42bb3cd9aceadc361f2570489b8d723cb77135   18 minutes ago      Running             kube-proxy          0                   8b7e7388ad866
</code></pre>
<p>就是这样。</p>
<h2 id="5-运行示例的录屏"><a class="header" href="#5-运行示例的录屏">5. 运行示例的录屏</a></h2>
<p><a href="https://asciinema.org/a/wkLOu6xnAOSAQdmYayumwrAvh"><img src="https://asciinema.org/a/wkLOu6xnAOSAQdmYayumwrAvh.svg" alt="asciicast" /></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="superedge"><a class="header" href="#superedge">SuperEdge</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="openyurt--containerd--crun"><a class="header" href="#openyurt--containerd--crun">OpenYurt + containerd + crun</a></h1>
<p>在这篇文章中，我们将介绍如何在 <a href="https://github.com/openyurtio/openyurt">OpenYurt</a>  边缘计算框架下，使用 containerd 去运行一个简单的 WasmEdge 的 demo</p>
<h2 id="搭建一个-openyurt-集群"><a class="header" href="#搭建一个-openyurt-集群">搭建一个 OpenYurt 集群</a></h2>
<p>这里，我们介绍两种不同的方式来搭建一个 OpenYurt 集群。
第一个是从零开始搭建，先搭建出一个 kubernetes 集群，然后使用 <code>yurtctl convert</code> 将
这个 kubernetes 集群转化为 OpenYurt 集群；
第二个是使用 <a href="https://openyurt.io/docs/installation/openyurt-experience-center/overview">OpenYurt 体验中心</a>   提供的能力，即只要在 OpenYurt 体验中心注册一个账户，即可拥有一个 OpenYurt 集群，如果需要接入新的节点到 OpenYurt 集群中，只需要使用
<code>yurtctl join</code> 命令加入节点。</p>
<h3 id="前置准备"><a class="header" href="#前置准备">前置准备</a></h3>
<table><thead><tr><th></th><th>OS/kernel</th><th>私网IP/ 公网IP</th></tr></thead><tbody>
<tr><td>Master</td><td>Ubuntu  20.04.3 LTS/5.4.0-91-generic</td><td>192.168.3.169/120.55.126.18</td></tr>
<tr><td>Node</td><td>Ubuntu  20.04.3 LTS/5.4.0-91-generic</td><td>192.168.3.170/121.43.113.152</td></tr>
</tbody></table>
<p>由于操作系统的不同，下面的步骤可能有一些微小的变动，主要是关于 <a href="https://github.com/openyurtio/openyurt">OpenYurt</a>  和 <a href="https://github.com/containers/crun">crun</a>  的安装。</p>
<p>因为我们使用 <code>yurtctl convert</code> 命令将 K8s 集群转化成 OpenYurt 集群，因此我们应该首先搭建一个 kubernetes 集群。当然， OpenYurt 也提供了一个简单的方法， <code>yurtctl init/join</code> 可以允许我们不搭建 kubernetes 集群，直接创建一个 OpenYurt 集群出来。
更多关于 <code>yurtctl convert/revert</code> 的介绍可以参考文章<a href="https://openyurt.io/docs/installation/yurtctl-convert-revert">Conversion between OpenYurt and Kubernetes:<code>yurtctl convert/revert</code></a> ，
而关于 <code>yurtctl init/join</code> 的介绍可以参考文章 <a href="https://openyurt.io/docs/installation/yurtctl-init-join">how use <code>Yurtctl init/join</code></a></p>
<ul>
<li>关闭节点 swap 分区</li>
</ul>
<pre><code class="language-shell">sudo swapoff -a
//verify    
free -m
</code></pre>
<ul>
<li>配置节点 IP 与 DNS 映射</li>
</ul>
<pre><code class="language-shell">192.168.3.169  oy-master 
120.55.126.18  oy-master
92.168.3.170   oy-node
121.43.113.152 oy-node
</code></pre>
<ul>
<li>加载内核模块 br_netfilter</li>
</ul>
<pre><code class="language-shell">sudo modprobe br_netfilter     
lsmod | grep br_netfilter    //确认加载
</code></pre>
<ul>
<li>调整内核参数，创建 k8s.conf</li>
</ul>
<pre><code class="language-shell">cat &lt;&lt;EOF | sudo tee /etc/sysctl.d/k8s.conf
net.bridge.bridge-nf-call-ip6tables = 1
net.bridge.bridge-nf-call-iptables = 1
EOF
sudo sysctl --system
</code></pre>
<ul>
<li>设置 rp-filter 值，将文件 /etc/sysctl.d/10-network-security.conf 中两个参数的值由2改为1，且将 /proc/sys/net/ipv4/ip_forward 设置为1</li>
</ul>
<pre><code class="language-shell">sudo vi /etc/sysctl.d/10-network-security.conf
echo 1 &gt; /proc/sys/net/ipv4/ip_forward
sudo sysctl --system
</code></pre>
<h4 id="安装-containerd-1"><a class="header" href="#安装-containerd-1">安装 containerd</a></h4>
<ul>
<li>安装 containerd</li>
</ul>
<pre><code class="language-shell">export VERSION=&quot;1.5.7&quot;
echo -e &quot;Version: $VERSION&quot;
echo -e &quot;Installing libseccomp2 ...&quot;
sudo apt install -y libseccomp2
echo -e &quot;Installing wget&quot;
sudo apt install -y wget

wget https://github.com/containerd/containerd/releases/download/v${VERSION}/cri-containerd-cni-${VERSION}-linux-amd64.tar.gz
wget https://github.com/containerd/containerd/releases/download/v${VERSION}/cri-containerd-cni-${VERSION}-linux-amd64.tar.gz.sha256sum
sha256sum --check cri-containerd-cni-${VERSION}-linux-amd64.tar.gz.sha256sum

sudo tar --no-overwrite-dir -C / -xzf cri-containerd-cni-${VERSION}-linux-amd64.tar.gz
sudo systemctl daemon-reload
</code></pre>
<ul>
<li>配置 containerd 文件 /etc/containerd/config.toml，修改 plugin 中参数，将其中的 runc 改为 crun，添加 pod_annotation</li>
</ul>
<pre><code class="language-shell">udo mkdir -p /etc/containerd/
sudo bash -c &quot;containerd config default &gt; /etc/containerd/config.toml&quot;
wget https://raw.githubusercontent.com/second-state/wasmedge-containers-examples/main/containerd/containerd_config.diff
sudo patch -d/ -p0 &lt; containerd_config.diff
</code></pre>
<ul>
<li>重启 containerd 服务：</li>
</ul>
<pre><code class="language-shell">systemctl start containerd
</code></pre>
<h4 id="安装-wasmedge"><a class="header" href="#安装-wasmedge">安装 WasmEdge</a></h4>
<p>使用 WasmEdge 提供的<a href="https://wasmedge.org/book/en/start/install.html">安装脚本</a> 在你的边缘节点上安装 WasmEdge</p>
<pre><code class="language-shell">curl -sSf https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/utils/install.sh | bash
</code></pre>
<h4 id="编译安装-crun"><a class="header" href="#编译安装-crun">编译、安装 crun</a></h4>
<p>我们需要一个在边缘节点支持 WasmEdge 的 crun 二进制文件。最直接的方法就是自己从源码编译。首先，需要确保在 ubuntu 系统上安装 crun 依赖。对于其他的 Linux 发行版，请参考<a href="https://github.com/containers/crun#readme">文章</a></p>
<ul>
<li>编译需要的依赖</li>
</ul>
<pre><code class="language-shell">sudo apt update
sudo apt install -y make git gcc build-essential pkgconf libtool \
  libsystemd-dev libprotobuf-c-dev libcap-dev libseccomp-dev libyajl-dev \
  go-md2man libtool autoconf python3 automake
</code></pre>
<ul>
<li>配置、编译、安装支持 WasmEdge 的 crun</li>
</ul>
<pre><code class="language-shell">it clone https://github.com/containers/crun
cd crun
./autogen.sh
./configure --with-wasmedge
make
sudo make install
</code></pre>
<h3 id="从零搭建一个-openyurt-集群"><a class="header" href="#从零搭建一个-openyurt-集群">从零搭建一个 OpenYurt 集群</a></h3>
<p>在这个 demo 中，我们使用两台虚拟机来搭建 OpenYurt 集群，一台模拟云端节点 Master，一台模拟边缘节点 Node，由这样两个节点构成最简单的 OpenYurt 集群系统。</p>
<h4 id="搭建一个-kubernetes-集群"><a class="header" href="#搭建一个-kubernetes-集群">搭建一个 kubernetes 集群</a></h4>
<pre><code class="language-shell">$ sudo apt-get update &amp;&amp; sudo apt-get install -y ca-certificates curl software-properties-common apt-transport-https
// add K8s source
$ curl -s https://mirrors.aliyun.com/kubernetes/apt/doc/apt-key.gpg | sudo apt-key add -
$ sudo tee /etc/apt/sources.list.d/kubernetes.list &lt;&lt;EOF
$ deb https://mirrors.aliyun.com/kubernetes/apt/ kubernetes-xenial main
// install K8s components 1.18.9
$ sudo apt-get update &amp;&amp; sudo apt-get install -y kubelet=1.18.9-00 kubeadm=1.18.9-00 kubectl=1.18.9-00 
// Initialize the master node
$ sudo kubeadm init --pod-network-cidr 172.16.0.0/16 \
--apiserver-advertise-address=192.168.3.167 \
--image-repository registry.cn-hangzhou.aliyuncs.com/google_containers
// join the work node
$ kubeadm join 192.168.3.167:6443 --token 3zefbt.99e6denc1cxpk9fg \
   --discovery-token-ca-cert-hash sha256:8077d4e7dd6eee64a999d56866ae4336073ed5ffc3f23281d757276b08b9b195
</code></pre>
<h4 id="安装-yurtctl"><a class="header" href="#安装-yurtctl">安装 yurtctl</a></h4>
<p>使用下面命令来安装 yurtctl，借助 yurtctl 命令行工具，我们可以安装/卸载 OpenYurt 集群，也可以用于在 kubernetes 集群和 OpenYurt 集群转化。</p>
<pre><code class="language-shell">git clone https://github.com/openyurtio/openyurt.git
cd openyurt
make build WHAT=cmd/yurtctl
</code></pre>
<h4 id="安装-openyurt-组件"><a class="header" href="#安装-openyurt-组件">安装 OpenYurt 组件</a></h4>
<p>OpenYurt 包括多个组件。YurtHub 是节点和 kube-apiserver 之间的流量代理，边缘节点上部署的 YurtHub 能够缓存来自云端的数据信息。
Yurt controller 是对上游节点控制器的补充，以支持边缘计算需求。TunnelServer 通过反向代理与运行在每个
边缘节点上的 TunnelAgent 守护进程连接，以在云端节点控制平面和连接到内网的边缘节点之间建立安全的网络访问。
更详细的信息可以参考 <a href="https://github.com/openyurtio/openyurt">OpenYurt Docs</a></p>
<pre><code class="language-shell">yurtctl convert --deploy-yurttunnel --cloud-nodes oy-master --provider kubeadm\
--yurt-controller-manager-image=&quot;openyurt/yurt-controller-manager:v0.5.0&quot;\
--yurt-tunnel-agent-image=&quot;openyurt/yurt-tunnel-agent:v0.5.0&quot;\
--yurt-tunnel-server-image=&quot;openyurt/yurt-tunnel-server:v0.5.0&quot;\
--node-servant-image=&quot;openyurt/node-servant:latest&quot;\
--yurthub-image=&quot;openyurt/yurthub:v0.5.0&quot;
</code></pre>
<p>实际上，我们更推荐安装 OpenYurt0.6.0 版本，而且已经验证通过。关于如何安装该版本，可以参考<a href="https://github.com/openyurtio/openyurt/releases/tag/v0.6.0">文章</a></p>
<h3 id="利用-openyurt-体验中心快速搭建一个-openyurt-集群"><a class="header" href="#利用-openyurt-体验中心快速搭建一个-openyurt-集群">利用 OpenYurt 体验中心快速搭建一个 OpenYurt 集群</a></h3>
<p>下面，我们将介绍一种快速搭建 OpenYurt 集群的方法，你只需要在 OpenYurt 体验中心注册一个账户，就可以拥有一个 OpenYurt 集群。如果你想接入一个边缘节点到你创建的 OpenYurt 集群中，
根据提示使用 <code>yurtctl join</code> 命令即可。更多关于 OpenYurt 体验中心的介绍，可以参考<a href="https://github.com/openyurtio/openyurt/releases/tag/v0.6.0">文章</a></p>
<h2 id="运行一个简单的-webassembly-应用"><a class="header" href="#运行一个简单的-webassembly-应用">运行一个简单的 WebAssembly 应用</a></h2>
<p>这一部分我们将在 OpenYurt 集群 pod 中的一个容器里运行 WebAssembly 应用。首先我们需要从 Docker Hub 拉取基于 WebAssembly 容器镜像，如果你对如何编译、打包以及发布一个基于
WebAssembly 的容器镜像感兴趣，可以阅读 <a href="https://wasmedge.org/book/en/kubernetes/demo/wasi.html">WasmEdge Book</a></p>
<p>在验证 OpenYurt 上运行 WasmEdge 应用的时候，我们参考了之前关于 <a href="https://wasmedge.org/book/en/kubernetes/kubernetes.html">kubernetes 的验证</a> ，</p>
<p>需要注意的是由于命令 <code>kubectl run</code> 在1.18.9版本上缺少 annotations 参数，我们需要修改命令行的内容。
如果你使用的是 OpenYurt 体验中心，默认情况下搭建的 OpenYurt 的版本是0.6.0，对应的 Kubernetes 版本是1.20.11。</p>
<pre><code class="language-shell">// kubectl 1.18.9
$ sudo kubectl run -it --rm --restart=Never wasi-demo --image=hydai/wasm-wasi-example:with-wasm-annotation  --overrides='{&quot;kind&quot;:&quot;Pod&quot;,&quot;metadata&quot;:{&quot;annotations&quot;:{&quot;module.wasm.image/variant&quot;:&quot;compat&quot;}} , &quot;apiVersion&quot;:&quot;v1&quot;, &quot;spec&quot;: {&quot;hostNetwork&quot;: true}}' /wasi_example_main.wasm 50000000
// kubectl 1.20.11
$ sudo kubectl run -it --rm --restart=Never wasi-demo --image=hydai/wasm-wasi-example:with-wasm-annotation --annotations=&quot;module.wasm.image/variant=compat&quot; --overrides='{&quot;kind&quot;:&quot;Pod&quot;, &quot;apiVersion&quot;:&quot;v1&quot;, &quot;spec&quot;: {&quot;hostNetwork&quot;: true}}' /wasi_example_main.wasm 50000000
</code></pre>
<p>容器化应用的结果将会在控制台上输出，对应不同 Kubernetes 版本，得到的结果都是相同的。</p>
<pre><code class="language-shell">Random number: 1123434661
Random bytes: [25, 169, 202, 211, 22, 29, 128, 133, 168, 185, 114, 161, 48, 154, 56, 54, 99, 5, 229, 161, 225, 47, 85, 133, 90, 61, 156, 86, 3, 14, 10, 69, 185, 225, 226, 181, 141, 67, 44, 121, 157, 98, 247, 148, 201, 248, 236, 190, 217, 245, 131, 68, 124, 28, 193, 143, 215, 32, 184, 50, 71, 92, 148, 35, 180, 112, 125, 12, 152, 111, 32, 30, 86, 15, 107, 225, 39, 30, 178, 215, 182, 113, 216, 137, 98, 189, 72, 68, 107, 246, 108, 210, 148, 191, 28, 40, 233, 200, 222, 132, 247, 207, 239, 32, 79, 238, 18, 62, 67, 114, 186, 6, 212, 215, 31, 13, 53, 138, 97, 169, 28, 183, 235, 221, 218, 81, 84, 235]
Printed from wasi: This is from a main function
This is from a main function
The env vars are as follows.
The args are as follows.
/wasi_example_main.wasm
50000000
File content is This is in a file
pod &quot;wasi-demo&quot; deleted
</code></pre>
<p>我们可以使用如下命令检查 pod 的状态</p>
<pre><code class="language-shell">crictl ps -a
</code></pre>
<p>输出结果如下：</p>
<pre><code class="language-shell">CONTAINER           IMAGE               CREATED             STATE               NAME                 ATTEMPT             POD ID
0c176ed65599a       0423b8eb71e31       8 seconds ago       Exited              wasi-demo  
</code></pre>
<p>至此，在 OpenYurt 上运行一个基于 WasmEdge 应用的简单 demo 已经完成了。如果你在实验的过程中遇到问题或者有一些建议，非常欢迎来到我们项目的 github 上提交 issue，让我们知道你的想法。</p>
<ul>
<li>WasmEdge GitHub repo: https://github.com/WasmEdge/WasmEdge</li>
<li>OpenYurt GitHub repo: https://github.com/openyurtio/openyurt</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="应用框架与平台"><a class="header" href="#应用框架与平台">应用框架与平台</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="service-mesh-与分布式框架"><a class="header" href="#service-mesh-与分布式框架">Service mesh 与分布式框架</a></h1>
<p>WasmEdge 可以作为 sidecar 微服务的轻量级运行时，也可以作为 Docker 替代方案的 API 代理。</p>
<h2 id="sidecar-微服务"><a class="header" href="#sidecar-微服务">Sidecar 微服务</a></h2>
<p>对于支持多个应用程序运行时的 sidecar 框架，我们可以通过其 C、Go、Rust 或 Node.js SDK 将 WasmEdge 应用程序简单地嵌入到 sidecar 中。 另外，WasmEdge 应用程序可以直接由容器工具管理并充当 sidecar 微服务。</p>
<ul>
<li><a href="frameworks/mesh/dapr.html">Dapr</a> 展示了如何将 WasmEdge 微服务作为 Dapr sidecar 运行。</li>
<li><a href="frameworks/mesh/evenmesh.html">Apache EventMesh</a> 展示了如何将 WasmEdge 微服务作为 Apache EventMesh sidecar 运行</li>
</ul>
<h2 id="api-porxy-的扩展"><a class="header" href="#api-porxy-的扩展">API porxy 的扩展</a></h2>
<p>API proxy 是服务网格中的另一个关键组件。 它以保持系统可扩展性的方式管理 API 请求并将其定向到 sidecar。 开发人员需要编写这些代理脚本，以根据不断变化的基础设施和运营要求来路由流量。 看到用户希望使用 WebAssembly 而不是 LUA 脚本语言的广泛需求，社区一起创建了 proxy-wasm 规范。 它定义了 WebAssembly 运行时必须支持的插入 proxy 的主机接口。 WasmEdge 现在已经支持 proxy-wasm。</p>
<ul>
<li><a href="frameworks/mesh/mosn.html">MOSN</a> 展示了如何使用 WasmEdge 作为 MOSN 的扩展。</li>
</ul>
<p>如果你对 WasmEdge 和微服务有一些好的想法，请随时在 <a href="https://github.com/WasmEdge/WasmEdge">WasmEdge</a> GitHub 存储库上创建问题或 PR！</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="dapr"><a class="header" href="#dapr">Dapr</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mosn"><a class="header" href="#mosn">MOSN</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="apache-eventmesh"><a class="header" href="#apache-eventmesh">Apache EventMesh</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="应用框架"><a class="header" href="#应用框架">应用框架</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="yomo"><a class="header" href="#yomo">YoMo</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="reactr"><a class="header" href="#reactr">Reactr</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="serverless-平台"><a class="header" href="#serverless-平台">Serverless 平台</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="vercel"><a class="header" href="#vercel">Vercel</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="netlify"><a class="header" href="#netlify">Netlify</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="aws"><a class="header" href="#aws">AWS</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tencent"><a class="header" href="#tencent">Tencent</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="second-state"><a class="header" href="#second-state">Second State</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="操作系统"><a class="header" href="#操作系统">操作系统</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="linux"><a class="header" href="#linux">Linux</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="windows"><a class="header" href="#windows">Windows</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mac"><a class="header" href="#mac">Mac</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="android"><a class="header" href="#android">Android</a></h1>
<p>在 WasmEdge 发布版本中具有用于 Android 操作系统的预构建二进制文件。但是，WasmEdge installer 不支持 Android。 用户必须将发布文件下载到计算机，然后使用 <code>adb</code> 工具将文件传输到 Android 设备或模拟器。我们将向您展示如何做到这一点。</p>
<blockquote>
<p>如果您更喜欢自己构建适用于 Android 的 WasmEdge Runtime 二进制文件，可以参考 <a href="os/../extend/build_for_android.html">build WasmEdge for Android</a> 文档。</p>
</blockquote>
<ul>
<li><a href="os/android/cli.html">适用于 Android 的 WasmEdge CLI 工具</a></li>
<li><a href="os/android/ndk.html">从 NDK 原生应用调用 WasmEdge 函数</a></li>
<li><a href="os/android/studio.html">从 Android APK 应用调用 WasmEdge 函数</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sel4"><a class="header" href="#sel4">seL4</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="open-harmony"><a class="header" href="#open-harmony">Open Harmony</a></h1>
<h2 id="从源码在-openharmony-standard-上构建和测试-wasmedge"><a class="header" href="#从源码在-openharmony-standard-上构建和测试-wasmedge">从源码在 OpenHarmony Standard 上构建和测试 WasmEdge</a></h2>
<p>请参考这个教程来从源码在 OpenHarmony 标准系统中构建和测试 WasmEdge</p>
<h2 id="环境准备"><a class="header" href="#环境准备">环境准备</a></h2>
<h3 id="openharmony-标准系统"><a class="header" href="#openharmony-标准系统">OpenHarmony 标准系统</a></h3>
<p>OpenHarmony 标准系统为开发者提供的 Docker 环境将对应的编译工具链进行了封装，本文档主要介绍在 Docker 环境下构建 WasmEdge 的步骤.</p>
<p>OpenHarmony 源码的获取与编译可以参考文档 <a href="https://www.openharmony.cn/pages/00010102/">搭建Ubuntu环境-Docker方式</a></p>
<p>请注意，在构建 WasmEdge 前需要将 Openharmony 进行一次全量编译以便后续WasmEdge的交叉编译过程.</p>
<pre><code class="language-bash"># 获取到 docker 镜像后
$ docker run -it -v $(pwd):/home/openharmony openharmony-docker-standard:0.0.5
(root@xxxxxx:/home/openharmony/)$ ./build.sh --product-name Hi3516DV300
</code></pre>
<h2 id="获取源码"><a class="header" href="#获取源码">获取源码</a></h2>
<p>OpenHarmony 将三方库项目放在了 third_party 文件夹下，因此本文档在 third_party 文件夹下获取 WasmEdge 源码，用户可以根据需要更改路径并修改相关配置文件中的路径。</p>
<pre><code class="language-bash">$ docker run -it -v $(pwd):/home/openharmony openharmony-docker-standard:0.0.5
(root@xxxxxx:/home/openharmony)$ cd third_party
(root@xxxxxx:/home/openharmony/third_party)$ git clone https://github.com/WasmEdge/WasmEdge.git
(root@xxxxxx:/home/openharmony/third_party)$ cd WasmEdge
(root@xxxxxx:/home/openharmony/third_party/WasmEdge)$ 
</code></pre>
<h2 id="修改-openharmony-标准系统配置文件"><a class="header" href="#修改-openharmony-标准系统配置文件">修改 OpenHarmony 标准系统配置文件</a></h2>
<h3 id="添加-wasmedge-子系统配置"><a class="header" href="#添加-wasmedge-子系统配置">添加 WasmEdge 子系统配置</a></h3>
<p>修改 OpenHarmony 的 build 目录下的 <code>subsystem_config.json</code> 文件，添加 <code>wasmedge</code> 子系统。</p>
<pre><code class="language-json">{
  ...
  
  &quot;wasmedge&quot;: {
    &quot;path&quot;: &quot;third_party/WasmEdge&quot;,
    &quot;name&quot;: &quot;wasmedge&quot;
  },
  
  ...
}
</code></pre>
<h3 id="将组件添加到产品配置中"><a class="header" href="#将组件添加到产品配置中">将组件添加到产品配置中</a></h3>
<p>修改 OpenHarmony 产品配置文件，标准系统对应的配置文件：<code>productdefine/common/products/Hi3516DV300.json</code>。
在该配置文件中添加 <code>&quot;wasmedge:wasmedge&quot;:{}</code>，表示该产品中会编译并打包 wasmedge 子系统下的 <code>wasmedge</code> 模块到版本中。</p>
<pre><code class="language-json">{
  ...
  &quot;parts&quot;:{
    ...
    &quot;wasmedge:wasmedge&quot;:{}
  }
}
</code></pre>
<h2 id="构建-wasmedge"><a class="header" href="#构建-wasmedge">构建 WasmEdge</a></h2>
<h3 id="说明"><a class="header" href="#说明">说明</a></h3>
<p>在 OpenHarmony 中构建的 WasmEdge 目前仅支持 <code>wasmedge</code>，即 wasm 的通用运行时。</p>
<ul>
<li><code>wasmedge</code> 可以在解释器模式下执行一个 <code>WASM</code> 文件， 也可以在预编译模式下执行通用 Wasm 二进制格式文件， 目前还不支持在 OpenHarmony 中使用预编译模式 。</li>
</ul>
<h3 id="执行构建脚本"><a class="header" href="#执行构建脚本">执行构建脚本</a></h3>
<p>通过执行 WasmEdge 源码下的 <code>utils/build_for_ohos.sh</code> 命令行脚本，将自动执行以下工作：</p>
<ol>
<li>将 .gn 等 OpenHarmony 需要的构建配置文件移动到 WasmEdge 项目根目录。</li>
<li>使用 OpenHarmony 的编译工具链进行交叉编译构建 WasmEdge。</li>
<li>运行 OpenHarmony 的构建脚本 <code>build.sh</code> 进行全量编译，该步骤将 <code>wasmedge</code> 添加进 OpenHarmony OS。</li>
</ol>
<pre><code class="language-bash">$ docker run -it -v $(pwd):/home/openharmony openharmony-docker-standard:0.0.5
(root@xxxxxx:/home/openharmony)$ cd third_party/WasmEdge/utils/ohos
(root@xxxxxx:/home/openharmony/third_party/WasmEdge/utils/ohos)$ ./build_for_ohos.sh /home/openharmony
</code></pre>
<p>当显示以下信息时，表明编译完成.</p>
<pre><code class="language-bash">...

post_process
=====build Hi3516DV300 successful.
2021-12-15 03:18:50
++++++++++++++++++++++++++++++++++++++++

</code></pre>
<p>检查 <code>wasmedge</code> 是否编译打包进 OpenHarmony OS。</p>
<pre><code class="language-bash">(root@xxxxxx:/home/openharmony/third_party/WasmEdge/utils/ohos)$ cd /home/openharmony/out/ohos-arm-release/packages/phone/system/bin
(root@xxxxxx:/home/openharmony/out/ohos-arm-release/packages/phone/system/bin)$ ls 
</code></pre>
<p>当输出的文件名中存在 <code>wasmedge</code> ，表明成功加入 OpenHarmony OS。</p>
<h2 id="测试"><a class="header" href="#测试">测试</a></h2>
<h3 id="烧录镜像"><a class="header" href="#烧录镜像">烧录镜像</a></h3>
<p>将重新编译后的 OpenHarmony 标准系统镜像烧录进开发板，具体见 OpenHarmony 文档<a href="https://device.harmonyos.com/cn/docs/documentation/guide/hi3516_upload-0000001052148681">Hi3516DV300开发板烧录</a></p>
<h3 id="运行应用"><a class="header" href="#运行应用">运行应用</a></h3>
<p>在 OpenHarmony 标准系统中，WasmEdge 提供了测试样例，并写入了 system 镜像中，供用户进行测试。
通过串口工具连接上开发板并启动OpenHarmony标准系统后，用户可以进行以下测试。</p>
<pre><code class="language-bash">$ cd /system/usr/wasmedge_example
$ wasmedge hello.wasm 1 2 3
hello
1
2
3

$ wasmedge --reactor add.wasm add 2 2
4

$ wasmedge --reactor fibonacci.wasm fib 8
34

$ wasmedge --reactor factorial.wasm fac 12
479001600

$ cd js
$ wasmedge --dir .:. qjs.wasm hello.js 1 2 3
Hello 1 2 3
</code></pre>
<h2 id="开发"><a class="header" href="#开发">开发</a></h2>
<p>接下来，你可以使用 WasmEdge Runtime 在 OpenHarmony 标准系统中进行 WebAssembly 的相关开发工作。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="raspberry-pi-34"><a class="header" href="#raspberry-pi-34">Raspberry Pi 3/4</a></h1>
<p>Raspberry Pi 从 3 Model B 开始就使用 64-bit 处理器。WasmEdge 能够在 arm 64-bit 上运行，所以 WasmEdge 同样能够在 Raspberry Pi 上运行。你可以选择任何 64-bit Linux 发行版本，例如 Raspbian， Ubuntu 或者支持 ARM 的 Manjaro。当前文档已经在支持 ARM 的 Manjaro 发行版本和 Raspberry Pi 3 Model B 硬件上测试可行。</p>
<p>在 Raspberry Pi 上的安装步骤等同于<a href="https://wasmedge.org/book/en/start/install.html">安装文档</a>，执行过程也一样。以下有一个视频，通过安装 WasmEdge 和运行一个简单的 WebAssembly 模块实现两数相加的功能。</p>
<p><a href="https://asciinema.org/a/458453"><img src="https://asciinema.org/a/458453.svg" alt="asciicast" /></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="为-wasmedge-贡献代码"><a class="header" href="#为-wasmedge-贡献代码">为 WasmEdge 贡献代码</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="从源码构建和测试-wasmedge"><a class="header" href="#从源码构建和测试-wasmedge">从源码构建和测试 WasmEdge</a></h1>
<p>请参考这个教程来从源码构建和测试 WasmEdge</p>
<h2 id="获取源码-1"><a class="header" href="#获取源码-1">获取源码</a></h2>
<pre><code class="language-bash">git clone https://github.com/WasmEdge/WasmEdge.git
cd WasmEdge
</code></pre>
<h2 id="检查依赖"><a class="header" href="#检查依赖">检查依赖</a></h2>
<p>WasmEdge 会基于最新版本的 LLVM 来创建我们的每日构建。
如果你想从源码构建的话，需要自己手动来安装下面的这些依赖。你也可以直接使用我们提供的 Docker 镜像来构建， 它支持多个发行版本的 Linux 。</p>
<ul>
<li>LLVM 12.0.0 (&gt;= 10.0.0)</li>
<li>GCC 11.1.0 (&gt;= 9.4.0)</li>
</ul>
<h2 id="环境准备-1"><a class="header" href="#环境准备-1">环境准备</a></h2>
<h3 id="docker-镜像"><a class="header" href="#docker-镜像">Docker 镜像</a></h3>
<p>Dockerhub 上的仓库 <code>wasmedge/wasmedge</code></p>
<p>你可以使用下面的命令来获取我们最新的镜像：</p>
<pre><code class="language-bash">docker pull wasmedge/wasmedge # 等同于 wasmedge/wasmedge:latest
</code></pre>
<h4 id="可用的标签"><a class="header" href="#可用的标签">可用的标签</a></h4>
<table><thead><tr><th>标签名</th><th>体系结构</th><th>基于的操作系统</th><th>LLVM 版本</th><th>环境配置</th><th>兼容性</th><th>备注</th></tr></thead><tbody>
<tr><td><code>latest</code></td><td>x86_64</td><td>Ubuntu 20.04 LTS</td><td>12.0.0</td><td>CC=clang, CXX=clang++</td><td>Ubuntu 20.04+</td><td>这个是用于持续集成的，会一直使用最新的 Ubuntu 版本</td></tr>
<tr><td><code>ubuntu-build-gcc</code></td><td>x86_64</td><td>Ubuntu 20.04 LTS</td><td>12.0.0</td><td>CC=gcc, CXX=g++</td><td>Ubuntu 20.04+</td><td>这个是用于持续集成的，会一直使用最新的 Ubuntu 版本</td></tr>
<tr><td><code>ubuntu-build-clang</code></td><td>x86_64</td><td>Ubuntu 20.04 LTS</td><td>12.0.0</td><td>CC=clang, CXX=clang++</td><td>Ubuntu 20.04+</td><td>这个是用于持续集成的，会一直使用最新的 Ubuntu 版本</td></tr>
<tr><td><code>ubuntu2004_x86_64</code></td><td>x86_64</td><td>Ubuntu 20.04 LTS</td><td>10.0.0</td><td>CC=gcc, CXX=g++</td><td>Ubuntu 20.04+</td><td>这个提供给熟悉 Ubuntu 20.04 LTS 版本的开发者使用</td></tr>
<tr><td><code>manylinux2014_x86_64</code></td><td>x86_64</td><td>CentOS 7, 7.9.2009</td><td>12.0.0</td><td>CC=gcc, CXX=g++</td><td>Ubuntu 16.04+, CentOS 7+</td><td>这个提供给熟悉 CentOS x86_64 架构的开发者使用</td></tr>
<tr><td><code>manylinux2014_aarch64</code></td><td>aarch64</td><td>CentOS 7, 7.9.2009</td><td>12.0.0</td><td>CC=gcc, CXX=g++</td><td>Ubuntu 16.04+, CentOS 7+</td><td>这个提供给熟悉 CentOS aarch64 架构的开发者使用</td></tr>
<tr><td><code>manylinux2010_x86_64</code></td><td>x86_64</td><td>CentOS 6, 6.10</td><td>12.0.0</td><td>CC=gcc, CXX=g++</td><td>Ubuntu 14.04+, CentOS 6+</td><td>这个提供给熟悉基于 x86_64 架构的过时系统的开发者使用，后续不再维护</td></tr>
<tr><td><code>manylinux1_x86_64</code></td><td>x86_64</td><td>CentOS 5, 5.11</td><td>12.0.0</td><td>CC=gcc, CXX=g++</td><td>Ubuntu 14.04+, CentOS 5+</td><td>这个提供给熟悉基于 x86_64 架构的过时系统的开发者使用，后续不再维护</td></tr>
</tbody></table>
<h3 id="在-ubuntu-2004-上手动安装依赖"><a class="header" href="#在-ubuntu-2004-上手动安装依赖">在 Ubuntu 20.04 上手动安装依赖</a></h3>
<pre><code class="language-bash"># 工具和库
sudo apt install -y \
    software-properties-common \
    cmake \
    libboost-all-dev

# 你需要 llvm 来支持 wasmedgec 工具
sudo apt install -y \
    llvm-12-dev \
    liblld-12-dev

# WasmEdge 支持 clang++ 和 g++ 编译器
# 你可以选择其中任一个用来编译这个项目
# 如果你倾向于 GCC
sudo apt install -y gcc g++
# 或者你选择 clang
sudo apt install -y clang
</code></pre>
<h3 id="对过时操作系统的支持"><a class="header" href="#对过时操作系统的支持">对过时操作系统的支持</a></h3>
<p>我们的开发环境依赖于 <code>libLLVM-12</code> 和 <code>&gt;=GLIBCXX_3.4.33</code>。</p>
<p>如果用户的系统是比 Ubuntu 20.04 还早的版本，请使用我们定制的 docker 镜像来构建 WasmEdge 。
如果你需要的是在过时版本的操作系统上使用的二进制包，我们也提供了几个基于 manylinux* 发行版本的安装包。</p>
<table><thead><tr><th>可移植的 Linux 发行版标签</th><th>基础镜像</th><th>提供的依赖</th><th>Docker 镜像</th></tr></thead><tbody>
<tr><td><code>manylinux1</code></td><td>CentOS 5.11</td><td>GLIBC &lt;= 2.5</br>CXXABI &lt;= 3.4.8</br>GLIBCXX &lt;= 3.4.9</br>GCC &lt;= 4.2.0</td><td>wasmedge/wasmedge:manylinux1_x86_64</td></tr>
<tr><td><code>manylinux2010</code></td><td>CentOS 6.10</td><td>GLIBC &lt;= 2.12</br>CXXABI &lt;= 1.3.3</br>GLIBCXX &lt;= 3.4.13</br>GCC &lt;= 4.5.0</td><td>wasmedge/wasmedge:manylinux2010_x86_64</td></tr>
<tr><td><code>manylinux2014</code></td><td>CentOS 7.9</td><td>GLIBC &lt;= 2.17</br>CXXABI &lt;= 1.3.7</br>GLIBCXX &lt;= 3.4.19</br>GCC &lt;= 4.8.0</td><td>wasmedge/wasmedge:manylinux2014_x86_64</td></tr>
<tr><td><code>manylinux2014</code></td><td>CentOS 7.9</td><td>GLIBC &lt;= 2.17</br>CXXABI &lt;= 1.3.7</br>GLIBCXX &lt;= 3.4.19</br>GCC &lt;= 4.8.0</td><td>wasmedge/wasmedge:manylinux2014_aarch64</td></tr>
</tbody></table>
<h3 id="如果你不需要预编译运行时编译器"><a class="header" href="#如果你不需要预编译运行时编译器">如果你不需要预编译运行时/编译器</a></h3>
<p>如果用户不需要预编译运行时和编译器特性的话，可以将 CMAKE 配置项 <code>WASMEDGE_BUILD_AOT_RUNTIME</code> 设置成 <code>OFF</code>。</p>
<pre><code class="language-bash">cmake -DCMAKE_BUILD_TYPE=Release -DWASMEDGE_BUILD_AOT_RUNTIME=OFF ..
</code></pre>
<h2 id="构建-wasmedge-1"><a class="header" href="#构建-wasmedge-1">构建 WasmEdge</a></h2>
<p>WasmEdge 提供了丰富的工具来支撑更好的性能以及更多样的运行时环境，
编译完成后，你可以找到以下几个 WasmEdge 相关的工具：</p>
<ol>
<li><code>wasmedge</code> 是 wasm 的通用运行时。
<ul>
<li><code>wasmedge</code> 可以在解释器模式下执行一个 <code>WASM</code> 文件， 也可以在预编译模式下执行一个 WASM <code>so</code> 文件。</li>
<li>你可以通过将 CMAKE 配置项 <code>WASMEDGE_BUILD_TOOLS</code> 设置成 <code>OFF</code>来禁止所有工具的构建。</li>
</ul>
</li>
<li><code>wasmedgec</code> 是一个 <code>WASM</code> 预编译器。
<ul>
<li><code>wasmedgec</code> 将一个通用的 <code>WASM</code> 文件编译成 <code>so</code> 文件。</li>
<li>你可以通过将 CMAKE 配置项 <code>WASMEDGE_BUILD_AOT_RUNTIME</code> 设置成 <code>OFF</code>来禁止构建预编译器。</li>
</ul>
</li>
<li><code>libwasmedge_c.so</code> 是 WasmEdge C API 的共享库。
<ul>
<li><code>libwasmedge_c.so</code> 提供了访问预编译器和 WASM 运行时的 C 语言 API。</li>
<li>如果 <code>WASMEDGE_BUILD_AOT_RUNTIME</code> 配置项被设置成 <code>OFF</code>， 那么与预编译器相关的 API 都将会返回错误。</li>
</ul>
</li>
<li><code>ssvm-qitc</code> 是用来支持 AI 应用的，它支持基于 ONNX 格式的 AI 模型的 ONNC 运行时。
<ul>
<li>如果你想尝试使用 <code>ssvm-qitc</code>，请参考 <a href="https://github.com/ONNC/onnc-wasm">ONNC-Wasm</a> 项目来设置运行环境，并且运行几个示例。</li>
<li>这里是我们的 <a href="https://www.youtube.com/watch?v=cbiPuHMS-iQ">ONNC-Wasm 项目教程 （ YouTube 视频）</a> 。</li>
</ul>
</li>
</ol>
<pre><code class="language-bash"># 获取到 wasm docker 镜像后
docker run -it --rm \
    -v &lt;path/to/your/wasmedge/source/folder&gt;:/root/wasmedge \
    wasmedge/wasmedge:latest
# In docker
cd /root/wasmedge
mkdir -p build &amp;&amp; cd build
cmake -DCMAKE_BUILD_TYPE=Release -DWASMEDGE_BUILD_TESTS=ON .. &amp;&amp; make -j
</code></pre>
<h2 id="执行内置的测试"><a class="header" href="#执行内置的测试">执行内置的测试</a></h2>
<p>下面所提到的测试只有在构建配置 <code>WASMEDGE_BUILD_TESTS</code> 设置为 <code>ON</code> 的时候才有效。</p>
<p>用户可以通过这些测试来验证 WasmEdge 二进制包的正确性。</p>
<pre><code class="language-bash">cd &lt;path/to/wasmedge/build_folder&gt;
LD_LIBRARY_PATH=$(pwd)/lib/api ctest
</code></pre>
<h2 id="运行应用-1"><a class="header" href="#运行应用-1">运行应用</a></h2>
<p>接下来，参考 <a href="extend/../index.html">这个文档</a> 在 <code>wasmedge</code> 上运行 WebAssembly 字节码程序。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="用-mac-编译"><a class="header" href="#用-mac-编译">用 Mac 编译</a></h1>
<p>目前，WasmEdge 项目同时支持 Intel 和 M1 型号的 MacOS。然而，我们只在 Big Sur 和 Catalina 上进行测试和开发。</p>
<ul>
<li>型号
<ul>
<li>Intel</li>
<li>M1</li>
</ul>
</li>
<li>操作系统
<ul>
<li>Big Sur</li>
<li>Catalina</li>
</ul>
</li>
</ul>
<p>如果您想在 MacOS 上开发 WasmEdge，请按照这个教程从源码进行构建和测试。</p>
<h2 id="获取源码-2"><a class="header" href="#获取源码-2">获取源码</a></h2>
<pre><code class="language-bash">git clone https://github.com/WasmEdge/WasmEdge.git
cd WasmEdge
</code></pre>
<h2 id="依赖组件"><a class="header" href="#依赖组件">依赖组件</a></h2>
<p>WasmEdge 会基于最新版本的 LLVM 来创建我们的每日构建。如果你想从源码构建的话，需要自己手动来安装下面的这些依赖。</p>
<ul>
<li>LLVM 12.0.0 (&gt;= 10.0.0)，使用 brew 安装，请勿使用系统自带的 LLVM。</li>
<li>因为最新版本 brew 中的 LLVM 默认版本是 13。请使用 <code>llvm@12</code> 来调整 LLVM 的版本。</li>
</ul>
<h3 id="环境准备-2"><a class="header" href="#环境准备-2">环境准备</a></h3>
<pre><code class="language-bash"># 工具和库
$ brew install boost cmake ninja llvm@12
# 使用 brew 版本的 llvm，而不是系统自带的 LLVM。
$ export PATH=&quot;/usr/local/opt/llvm@12/bin:$PATH&quot;
$ export LDFLAGS=&quot;-L/usr/local/opt/llvm@12/lib -Wl，-rpath，/usr/local/opt/llvm@12/lib&quot;
$ export CPPFLAGS=&quot;-I/usr/local/opt/llvm@12/include&quot;
</code></pre>
<h3 id="如果你不需要预编译的运行时编译器"><a class="header" href="#如果你不需要预编译的运行时编译器">如果你不需要预编译的运行时/编译器</a></h3>
<p>如果你不需要预编译运行时和编译器特性的话，你可以将 CMake 配置项 <code>WASMEDGE_BUILD_AOT_RUNTIME</code> 设置成 <code>OFF</code>。</p>
<pre><code class="language-bash">cmake -DCMAKE_BUILD_TYPE=Release -DWASMEDGE_BUILD_AOT_RUNTIME=OFF ..
</code></pre>
<h2 id="构建-wasmedge-2"><a class="header" href="#构建-wasmedge-2">构建 WasmEdge</a></h2>
<p>WasmEdge 提供了丰富的工具来支撑更好的性能以及更多样的运行时环境，编译完成后，你可以找到以下几个 WasmEdge 相关的工具：</p>
<ol>
<li><code>wasmedge</code> 是 wasm 的通用运行时。
<ul>
<li><code>wasmedge</code> 可以在解释器模式下执行一个 <code>WASM</code> 文件，也可以在预编译模式下执行一个 WASM <code>dyld</code> 文件。</li>
<li>你可以通过将 CMake 配置项 <code>WASMEDGE_BUILD_TOOLS</code> 设置成 <code>OFF</code> 来禁止构建所有工具。</li>
</ul>
</li>
<li><code>wasmedgec</code> 是一个 <code>WASM</code> 预编译器。
<ul>
<li><code>wasmedgec</code> 将一个通用的 <code>WASM</code> 文件编译成 <code>dyld</code> 文件。</li>
<li>你可以通过将 CMake 配置项 <code>WASMEDGE_BUILD_AOT_RUNTIME</code> 设置成 <code>OFF</code> 来禁止构建预编译器。</li>
</ul>
</li>
<li><code>libwasmedge_c.dyld</code> 是 WasmEdge C API 的共享库。
<ul>
<li><code>libwasmedge_c.dyld</code> 提供了访问预编译器和 WASM 运行时的 C 语言 API。</li>
<li>如果 <code>WASMEDGE_BUILD_AOT_RUNTIME</code> 配置项被设置成 <code>OFF</code> ，那么与预编译器相关的 API 都将会返回错误。</li>
<li>你可以通过将 CMake 配置项 <code>WASMEDGE_BUILD_SHARED_LIB</code> 设置成 <code>OFF</code> 来禁止构建共享库。</li>
</ul>
</li>
</ol>
<pre><code class="language-bash">cmake -Bbuild -GNinja -DWASMEDGE_BUILD_PACKAGE=&quot;TGZ&quot; -DWASMEDGE_BUILD_TESTS=ON .
cmake --build build
</code></pre>
<h2 id="运行内置测试"><a class="header" href="#运行内置测试">运行内置测试</a></h2>
<p>以下内置测试只有在构建标志 <code>WASMEDGE_BUILD_TESTS</code> 设置为 <code>ON</code> 时才可用。</p>
<p>用户可以通过这些测试来验证 WasmEdge 二进制包的正确性。</p>
<pre><code class="language-bash">export DYLD_LIBRARY_PATH=&quot;$(pwd)/build/lib/api:$DYLD_LIBRARY_PATH&quot;
cmake --build build --target test
</code></pre>
<h2 id="运行应用程序"><a class="header" href="#运行应用程序">运行应用程序</a></h2>
<p>接下来，参考<a href="extend/../index.html">这个文档</a>在 <code>wasmedge</code> 上运行 WebAssembly 字节码程序。</p>
<h2 id="已知问题"><a class="header" href="#已知问题">已知问题</a></h2>
<p>以下测试无法在 MacOS 上通过，我们正在调查这些问题：</p>
<ul>
<li>wasmedgeAPIVMCoreTests</li>
<li>wasmedgeAPIStepsCoreTests</li>
<li>wasmedgeAPIAOTCoreTests</li>
<li>wasmedgeProcessTests</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="在-windows-10由源码构建"><a class="header" href="#在-windows-10由源码构建">在 Windows 10由源码构建</a></h1>
<p>WasmEdge 支持 Windows 10 。我们也同时提供了二进制安装包和库文件。</p>
<p>可以在<a href="https://github.com/WasmEdge/WasmEdge/blob/master/.github/workflows/build.yml#L266-L322">这里</a>查看详情。</p>
<p>如果想要在 Windows 10 上开发 WasmEdge，请继续阅读本文以进行从源码构建和测试。</p>
<p>下文中将以 <code>AOT</code> 代替 <code>ahead-of-time</code> ，<code>ahead-of-time</code> 的含义是将 WASM 文件提前编译为机器码。</p>
<h2 id="下载源代码"><a class="header" href="#下载源代码">下载源代码</a></h2>
<pre><code class="language-bash">git clone https://github.com/WasmEdge/WasmEdge.git
cd WasmEdge
</code></pre>
<h2 id="依赖说明"><a class="header" href="#依赖说明">依赖说明</a></h2>
<p>WasmEdge 尝试用最新的 LLVM 发行版本来创建我们的 nightly 版本。</p>
<p>需要以下自行安装以下依赖才能编译源码：</p>
<ul>
<li>Chocolatey，用来安装 cmake、ninja 和 vswhere</li>
<li>Windows SDK 19041</li>
<li>LLVM 13.0.0，预编译版本在下节中提供</li>
</ul>
<h3 id="下载依赖"><a class="header" href="#下载依赖">下载依赖</a></h3>
<pre><code class="language-powershell"># 下载工具
choco install cmake ninja vswhere

$vsPath = (vswhere -latest -property installationPath)
Import-Module (Join-Path $vsPath &quot;Common7\Tools\Microsoft.VisualStudio.DevShell.dll&quot;)
Enter-VsDevShell -VsInstallPath $vsPath -SkipAutomaticLocation -DevCmdArguments &quot;-arch=x64 -host_arch=x64 -winsdk=10.0.19041.0&quot;

# 下载我们提供的预编译好的 LLVM 13
$llvm = &quot;LLVM-13.0.0-win64.zip&quot;
curl -sLO https://github.com/WasmEdge/llvm-windows/releases/download/llvmorg-13.0.0/LLVM-13.0.0-win64.zip -o $llvm
Expand-Archive -Path $llvm

# 设置 LLVM 环境变量
$llvm_dir = &quot;$pwd\\LLVM-13.0.0-win64\\LLVM-13.0.0-win64\\lib\\cmake\\llvm&quot;
$Env:CC = &quot;clang-cl&quot;
$Env:CXX = &quot;clang-cl&quot;
</code></pre>
<h3 id="如果不需要构建aot运行时或者编译器"><a class="header" href="#如果不需要构建aot运行时或者编译器">如果不需要构建AOT运行时或者编译器</a></h3>
<p>如果不需要 AOT 运行时或者编译器，可以将 CMake 选项 <code>WASMEDGE_BUILD_AOT_RUNTIME</code>  设置为 <code>OFF</code>。</p>
<pre><code class="language-bash">cmake -DCMAKE_BUILD_TYPE=Release -DWASMEDGE_BUILD_AOT_RUNTIME=OFF ..
</code></pre>
<h2 id="构建-wasmedge-3"><a class="header" href="#构建-wasmedge-3">构建 WasmEdge</a></h2>
<p>为应对不同的性能需求，WasmEdge 提供了多种运行时环境和工具。</p>
<p>构建成功后，你可以找到这些 wasmedge 相关工具：</p>
<ol>
<li><code>wasmedge</code>  是一个通用的 wasm 运行时。
<ul>
<li><code>wasmedge</code>  可以解释执行 <code>WASM</code>  文件或者以 AOT 模式执行一个编译过的 WASM <code>dyld</code> 文件。</li>
<li>在构建 WasmEdge 时，可以设置 CMake 选项 <code>WASMEDGE_BUILD_TOOLS</code> 为<code>OFF</code> 来不构建所有工具。</li>
</ul>
</li>
<li><code>wasmedgec</code> 是一个 AOT <code>WASM</code> 编译器。
<ul>
<li><code>wasmedgec</code> 将一个 <code>WASM</code> 格式的文件编译为<code>dll</code> 格式文件。</li>
<li>如果你不需要构建 AOT 编译器，可以将 CMake 选项 <code>WASMEDGE_BUILD_AOT_RUNTIME</code>  设置为  <code>OFF</code> 。</li>
</ul>
</li>
<li><code>libwasmedge_c.dll</code> 是 WasmEdge 的 C API 共享库.
<ul>
<li><code>libwasmedge_c.dll</code> 为 AOT 编译器和 WASM 运行时提供 C API。</li>
<li>CMake 选项 <code>WASMEDGE_BUILD_AOT_RUNTIME</code> 设置为 <code>OFF</code> 后，调用与 AOT 编译器相关的 API 只会返回失败值。</li>
<li>如果你不需要构建共享库，可以将 CMake 选项 <code>WASMEDGE_BUILD_SHARED_LIB</code>  设置为 <code>OFF</code> 。</li>
</ul>
</li>
</ol>
<pre><code class="language-bash">$vsPath = (vswhere -latest -property installationPath)
Import-Module (Join-Path $vsPath &quot;Common7\Tools\Microsoft.VisualStudio.DevShell.dll&quot;)
Enter-VsDevShell -VsInstallPath $vsPath -SkipAutomaticLocation -DevCmdArguments &quot;-arch=x64 -host_arch=x64 -winsdk=10.0.19041.0&quot;

cmake -Bbuild -GNinja -DCMAKE_SYSTEM_VERSION=10.0.19041.0 -DCMAKE_MSVC_RUNTIME_LIBRARY=MultiThreadedDLL &quot;-DLLVM_DIR=$llvm_dir&quot; -DWASMEDGE_BUILD_TESTS=ON -DWASMEDGE_BUILD_PACKAGE=&quot;ZIP&quot; .
cmake --build build
</code></pre>
<h2 id="运行内置测试-1"><a class="header" href="#运行内置测试-1">运行内置测试</a></h2>
<p>以下内置测试仅在 CMake 编译选项 <code>WASMEDGE_BUILD_TESTS</code>  为 <code>ON</code> 时可用。</p>
<p>用户可以用这些测试来验证自己构建的 WasmEdge 二进制文件的正确性。</p>
<pre><code class="language-bash">$vsPath = (vswhere -latest -property installationPath)
Import-Module (Join-Path $vsPath &quot;Common7\Tools\Microsoft.VisualStudio.DevShell.dll&quot;)
Enter-VsDevShell -VsInstallPath $vsPath -SkipAutomaticLocation -DevCmdArguments &quot;-arch=x64 -host_arch=x64 -winsdk=10.0.19041.0&quot;

$Env:PATH += &quot;;$pwd\\build\\lib\\api&quot;
cd build
ctest --output-on-failure
cd -
</code></pre>
<h2 id="运行应用-2"><a class="header" href="#运行应用-2">运行应用</a></h2>
<p>下一步，请按照<a href="extend/run.html">该指导</a> 使用 <code>wasmedge</code> 运行 WebAssembly 字节码程序。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="为-android-编译"><a class="header" href="#为-android-编译">为 Android 编译</a></h1>
<h2 id="使用-android-ndk-构建和测试-wasmedge-命令行工具"><a class="header" href="#使用-android-ndk-构建和测试-wasmedge-命令行工具">使用 Android NDK 构建和测试 WasmEdge 命令行工具</a></h2>
<p>此教程指导使用 Android NDK 构建 Interpreter 模式的 WasmEdge ，并在 Android 设备中测试 wasmedge 命令行工具。</p>
<h3 id="环境准备-3"><a class="header" href="#环境准备-3">环境准备</a></h3>
<ul>
<li><a href="https://developer.android.com/ndk/downloads">Android NDK 23b</a>
<ul>
<li>下载到的 NDK 工具链需要解压到磁盘上</li>
</ul>
</li>
<li><a href="https://cmake.org/download/">CMake 3.21</a> 及以上版本
<ul>
<li>如果本机已安装 cmake，请检查版本是否符合要求</li>
</ul>
</li>
<li><a href="https://developer.android.com/studio/releases/platform-tools">ADB</a>
<ul>
<li>将下载到的 platform-tools 解压到磁盘上，adb 命令在 bin 目录中</li>
<li>如果您使用的是 debian/ubuntu 系统，可以通过 apt 安装 adb</li>
</ul>
</li>
<li>一台已经 <a href="https://developer.android.com/studio/debug/dev-options">启用开发者选项和 USB 调试</a> 的 Android 设备, 最低系统版本为 Android 6.0</li>
</ul>
<h3 id="构建-wasmedge-4"><a class="header" href="#构建-wasmedge-4">构建 WasmEdge</a></h3>
<ol>
<li>添加 NDK 目录路径到环境变量 <code>ANDROID_NDK_HOME=path/to/you/ndk/dir</code></li>
<li>执行 WasmEdge 源码路径下的 <code>utils/android/standalone/build_for_android.sh</code> 命令行脚本，将自动执行构建，构建结果在 WasmEdge 目录中的 build 目录</li>
</ol>
<h3 id="测试-1"><a class="header" href="#测试-1">测试</a></h3>
<h4 id="推送到-android-设备"><a class="header" href="#推送到-android-设备">推送到 Android 设备</a></h4>
<ol>
<li>
<p>将 Android 设备通过 USB 或 WLAN 连接到 PC 。您可以通过 <code>adb devices</code> 命令检查已连接的设备，可以获得类似如下显示：</p>
<pre><code class="language-bash">$ adb devices
List of devices attached
0a388e93      device
</code></pre>
</li>
<li>
<p>使用 <code>adb push</code>命令推送 build/tools/wasmedge 到 Android 设备的 /data/local/tmp 目录</p>
<pre><code class="language-bash">cd build
adb push ./tools/wasmedge /data/local/tmp  
</code></pre>
</li>
</ol>
<h4 id="在-android-设备中执行-wasmedge"><a class="header" href="#在-android-设备中执行-wasmedge">在 Android 设备中执行 WasmEdge</a></h4>
<ol>
<li>使用 <code>adb shell</code> 命令进入 Android 设备</li>
<li>测试运行 wasmedge 程序</li>
</ol>
<pre><code class="language-bash">$ cd /data/local/tmp/wasmedge/examples
$ ../wasmedge hello.wasm 1 2 3                                                           
hello
1
2
3

$ ../wasmedge --reactor add.wasm add 2 2
4

$ ../wasmedge --reactor fibonacci.wasm fib 8
34

$ ../wasmedge --reactor factorial.wasm fac 12
479001600

$ cd js
$ ./../wasmedge --dir .:. qjs.wasm hello.js 1 2 3
Hello 1 2 3
</code></pre>
<h3 id="注意-1"><a class="header" href="#注意-1">注意</a></h3>
<ul>
<li>Android 10 及以上系统版本，SELinux 限制普通 Android 应用程序使用 exec() 执行 home 目录中的可执行文件。<a href="https://android.googlesource.com/platform/system/sepolicy/+/08450264ae3f917f6b8e4091d6fedf84ef8d796f/private/untrusted_app_all.te#27">参考</a></li>
<li>Android SELinux 限制普通 Android 应用程序访问 /data/local/tmp 目录</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="wasmedge-插件-api"><a class="header" href="#wasmedge-插件-api">WasmEdge 插件 API</a></h1>
<p>WasmEdge 提供了一套基于 C++ 的 API 用来注册自定义扩展和 host 函数。虽然 WasmEdge 的各种语言 SDK 允许将主机应用注册为主机功能函数，但插件 API 方式允许这种扩展被纳入 WasmEdge 自己的构建和发布过程。</p>
<p>事实上，WasmEdge 对 Tensorflow 、图像处理、键值存储等的扩展都是通过插件 API 实现的。插件 API 是你可以为 WasmEdge Runtime 本身贡献新功能的方式。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="host-函数"><a class="header" href="#host-函数">Host 函数</a></h1>
<p><a href="https://webassembly.github.io/spec/core/exec/runtime.html#syntax-hostfunc">Host 函数</a> 是在 WebAssembly 之外的函数，它们以导入的方式传递到 WASM 模块中。以下步骤是将 <code>host module</code> 注册到 WasmEdge runtime 的示例。</p>
<p>此示例适用于使用 C++ 编写的 WasmEdge 项目的源代码编译。如果开发者想使用C/C++ 和 WasmEdge C API 来实现 host 函数，而不用 WasmEdge 项目进行编译，请参阅 <a href="extend/plugin/../../embed/c/ref.html#host-functions">C API 文档</a>。</p>
<h2 id="host-实例定义"><a class="header" href="#host-实例定义">Host 实例定义</a></h2>
<p>WasmEdge 支持以导入的形式注册 <code>host function</code> 、<code>memory</code> 、<code>table</code> 和 <code>global</code> 等实例。
详情请参阅 <code>include/host/wasi/</code> 和 <code>test/core/spectest.h</code> 中的示例。</p>
<h3 id="函数"><a class="header" href="#函数">函数</a></h3>
<p>可以按照如下方式声明一个简单的 host 函数类：</p>
<pre><code class="language-cpp">#include &quot;common/errcode.h&quot;
#include &quot;runtime/hostfunc.h&quot;
#include &quot;runtime/instance/memory.h&quot;

namespace WasmEdge {
namespace Host {

class TestHost : public Runtime::HostFunction&lt;TestHost&gt; {
public:
  Expect&lt;uint32_t&gt; body(Runtime::Instance::MemoryInstance *MemInst, uint32_t Param1, float Param2);
};

} // namespace Host
} // namespace WasmEdge
</code></pre>
<p>在上述示例中，返回类型 <code>Expect&lt;T&gt;</code> 表示该 host 函数的预期返回类型 <code>T</code>。 <code>Param1</code> 和 <code>Param2</code> 的类型表示此 host 函数的参数类型。 host 函数仅支持 WASM 的内置类型（如 <code>uint32_t</code>、 <code>uint64_t</code>、 <code>float</code> 以及 <code>double</code>）。在实例化时会生成 <code>vec(valtype) -&gt; resulttype</code> 的函数签名，它能被 WASM 模块导入。</p>
<p>注意：目前 host 函数仅支持单个返回值。</p>
<p>另一种情况是传递需要由 <code>host function</code> 体访问的环境或信息。 以下示例展示了如何实现 host 函数集群：</p>
<pre><code class="language-cpp">#include &quot;common/errcode.h&quot;
#include &quot;runtime/hostfunc.h&quot;
#include &quot;runtime/instance/memory.h&quot;
#include &lt;vector&gt;

namespace WasmEdge {
namespace Host {

template &lt;typename T&gt; class TestCluster : public Runtime::HostFunction&lt;T&gt; {
public:
  TestCluster(std::vector&lt;uint8_t&gt; &amp;Vec) : Data(Vec) {}

protected:
  std::vector&lt;uint8_t&gt; &amp;Data;
};

class TestHost1 : public TestCluster&lt;TestHost1&gt; {
public:
  TestHost1(std::vector&lt;uint8_t&gt; &amp;Vec) : TestCluster(Vec) {}
  Expect&lt;uint32_t&gt; body(Runtime::Instance::MemoryInstance *MemInst, uint32_t Param1, float Param2) {
    /// Operations to `Data` ...
    return {};
  }
};

class TestHost2 : public TestCluster&lt;TestHost2&gt; {
public:
  TestHost2(std::vector&lt;uint8_t&gt; &amp;Vec) : TestCluster(Vec) {}
  Expect&lt;uint64_t&gt; body(Runtime::Instance::MemoryInstance *MemInst, uint64_t Param1, double Param2) {
    /// Operations to `Data` ...
    return {};
  }
};

} // namespace Host
} // namespace WasmEdge
</code></pre>
<h3 id="表-内存-以及全局实例"><a class="header" href="#表-内存-以及全局实例">表、 内存、 以及全局实例</a></h3>
<p>要创建 <code>host table</code>、 <code>memory</code> 以及 <code>global</code> 实例，唯一的办法就是使用 <code>host module</code> 中它们各自的构造器来创建。以下关于 <code>host module</code> 的章节将提供更详细的示例。</p>
<h2 id="host-modules-host-模块"><a class="header" href="#host-modules-host-模块">Host Modules/ host 模块</a></h2>
<p><code>Host module</code> 是一个可以注册到 WasmEdge runtime 的对象。<code>Host module</code> 包含了 <code>host functions</code>、 <code>tables</code>、 <code>memories</code>、 <code>globals</code> 以及其它用户自定义的数据。WasmEdge 提供 API 来注册 <code>host modules</code>。在注册后，<code>host modules</code> 中的这些 host 实例可以被 WASM 模块所导入。</p>
<h3 id="声明"><a class="header" href="#声明">声明</a></h3>
<p><code>Host module</code> 提供了导出的模块名称，并且可以包含自定义数据。 构建 <code>host modules</code> 时需要填写模块名称。</p>
<pre><code class="language-cpp">#include &quot;common/errcode.h&quot;
#include &quot;runtime/hostfunc.h&quot;
#include &quot;runtime/importobj.h&quot;

namespace WasmEdge {
namespace Host {

class TestModule : public Runtime::ImportObject {
public:
  TestModule() : ImportObject(&quot;test&quot;);
  virtual ~TestModule() = default;
};

} // namespace Host
} // namespace WasmEdge
</code></pre>
<h3 id="添加实例"><a class="header" href="#添加实例">添加实例</a></h3>
<p><code>Host module</code> 提供了以下四种方法 <code>addHostFunc()</code>、 <code>addHostTable()</code>、 <code>addHostMemory()</code> 和 <code>addHostGlobal()</code> 来插入具有唯一名称的实例。插入操作可以在构造器中完成。下面的示例代码中还展示了如何创建 <code>host memories</code>、 <code>tables</code> 和 <code>globals</code>。</p>
<pre><code class="language-cpp">#include &quot;common/errcode.h&quot;
#include &quot;runtime/hostfunc.h&quot;
#include &quot;runtime/importobj.h&quot;
#include &lt;memory&gt;
#include &lt;vector&gt;

namespace WasmEdge {
namespace Host {

template &lt;typename T&gt; class TestCluster : public Runtime::HostFunction&lt;T&gt; {
public:
  TestCluster(std::vector&lt;uint8_t&gt; &amp;Vec) : Data(Vec) {}

protected:
  std::vector&lt;uint8_t&gt; &amp;Data;
};

class TestHost1 : public TestCluster&lt;TestHost1&gt; {
public:
  TestHost1(std::vector&lt;uint8_t&gt; &amp;Vec) : TestCluster(Vec) {}
  Expect&lt;uint32_t&gt; body(Runtime::Instance::MemoryInstance *MemInst, uint32_t Param1, float Param2) {
    /// Operations to `Data` ...
    return {};
  }
};

class TestHost2 : public TestCluster&lt;TestHost2&gt; {
public:
  TestHost2(std::vector&lt;uint8_t&gt; &amp;Vec) : TestCluster(Vec) {}
  Expect&lt;uint64_t&gt; body(Runtime::Instance::MemoryInstance *MemInst, uint64_t Param1, double Param2) {
    /// Operations to `Data` ...
    return {};
  }
};

class TestModule : public Runtime::ImportObject {
public:
  TestModule(std::vector&lt;uint8_t&gt; &amp;Vec) : ImportObject(&quot;test&quot;), Data(Vec) {
    /// Add function instances with exporting name
    addHostFunc(&quot;test_func1&quot;, std::make_unique&lt;TestHost1&gt;(Data));
    addHostFunc(&quot;test_func2&quot;, std::make_unique&lt;TestHost2&gt;(Data));

    /// Add table instance with exporting name
    addHostTable(&quot;table&quot;, std::make_unique&lt;Runtime::Instance::TableInstance&gt;(
                              TableType(RefType::FuncRef, 10, 20)));

    /// Add memory instance with exporting name
    addHostMemory(&quot;memory&quot;, std::make_unique&lt;Runtime::Instance::MemoryInstance&gt;(
                                MemoryType(1, 2)));

    /// Add global instance with exporting name
    addHostGlobal(&quot;global_i32&quot;,
                  std::make_unique&lt;Runtime::Instance::GlobalInstance&gt;(
                      GlobalType(ValType::I32, ValMut::Const), uint32_t(666)));
    addHostGlobal(&quot;global_i64&quot;,
                  std::make_unique&lt;Runtime::Instance::GlobalInstance&gt;(
                      GlobalType(ValType::I64, ValMut::Const), uint64_t(666)));
    addHostGlobal(&quot;global_f32&quot;,
                  std::make_unique&lt;Runtime::Instance::GlobalInstance&gt;(
                      GlobalType(ValType::F32, ValMut::Const), float(666)));
    addHostGlobal(&quot;global_f64&quot;,
                  std::make_unique&lt;Runtime::Instance::GlobalInstance&gt;(
                      GlobalType(ValType::F64, ValMut::Const), double(666)));
  }
  virtual ~TestModule() = default;

private:
  std::vector&lt;uint8_t&gt; &amp;Data;
};

} // namespace Host
} // namespace WasmEdge
</code></pre>
<p><code>Host module</code> 提供了以下四种方法 <code>getFuncs()</code>、 <code>getTables()</code>、 <code>getMems()</code> 和 <code>getGlobals()</code> 用来通过唯一的导出名称搜索已注册的实例。更多细节和 APIs 请参阅 <code>include/runtime/importobj.h</code>。</p>
<h3 id="在-wasmedge-中注册-host-module"><a class="header" href="#在-wasmedge-中注册-host-module">在 WasmEdge 中注册 host module</a></h3>
<p>用户可以通过 <code>WasmEdge::VM::registerModule()</code> API 来注册 <code>host module</code>。</p>
<pre><code class="language-cpp">#include &quot;common/configure.h&quot;
#include &quot;vm/vm.h&quot;
#include &lt;vector&gt;

WasmEdge::Configure Conf;
WasmEdge::VM::VM VM(Conf);
std::vector&lt;uint8_t&gt; Data;
WasmEdge::Host::TestModule TestMod(Data);
VM.registerModule(TestMod);
</code></pre>
<h3 id="在-cmakefile-中链接库以及包含目录"><a class="header" href="#在-cmakefile-中链接库以及包含目录">在 CMakeFile 中链接库以及包含目录</a></h3>
<p>为了从 WasmEdge 的包含目录中查找头文件以及链接静态库，CMakeFile 需要如下设置</p>
<pre><code class="language-cmake">add_library(wasmedgeHostModuleTest  # Static library name of host modules
  test.cpp  # Path to host modules cpp files
)

target_include_directories(wasmedgeHostModuleTest
  PUBLIC
  ${Boost_INCLUDE_DIRS}
  ${PROJECT_SOURCE_DIR}/include
)
</code></pre>
<h2 id="host-函数体实现"><a class="header" href="#host-函数体实现">host 函数体实现</a></h2>
<p>以下是一些实现 host 函数体的小技巧。</p>
<h3 id="使用时检查-memory-实例"><a class="header" href="#使用时检查-memory-实例">使用时检查 Memory 实例</a></h3>
<p>Host 函数能够访问 WASM 内存，这些内存通常以 <code>MemoryInstance *</code> 参数的形式被传递。 当发生<a href="https://webassembly.github.io/spec/core/exec/instructions.html#function-calls">函数调用</a> 时，被调用函数所属的带有模块的帧将被压入<code>堆栈</code>。 在 host 函数的例子中，堆栈顶部栈帧中的内存实例将作为 host 函数体的参数被传递。然而，一个 WASM 模块中可以不包含内存实例。因此，用户在访问时应检查内存实例指针是否为空指针。</p>
<h3 id="预期返回"><a class="header" href="#预期返回">预期返回</a></h3>
<p>在我们的机制里， <code>include/common/errcode.h</code> 中声明的 <code>Expect&lt;T&gt;</code> 被用作函数体的结果类型。在 <code>Expect&lt;void&gt;</code> 的情况下，预期场景需要 <code>return {};</code> 。其它情况下， 预期场景需要 <code>return Value;</code> ，其中 <code>Value</code> 是 <code>T</code> 类型的一个变量。如果出现意外情况，用户可以调用 <code>return Unexpect(Code);</code> 来返回一个错误，其中 <code>Code</code> 是枚举 <code>ErrCode</code> 的一个元素。</p>
<h3 id="强制终止"><a class="header" href="#强制终止">强制终止</a></h3>
<p>WasmEdge 提供了一种在 host 函数中终止 WASM 执行的方法。开发者可以返回 <code>ErrCode::Terminated</code>  来触发当前执行的强制终止，并将 <code>ErrCode::Terminated</code>  传递给 host 函数的调用者。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="external-references"><a class="header" href="#external-references">External references</a></h1>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
    </body>
</html>
