<!DOCTYPE HTML>
<html lang="zh" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>WasmEdge Runtime</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-NGPCK7VF2L"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-NGPCK7VF2L');
</script>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item "><a href="index.html"><strong aria-hidden="true">1.</strong> 快速开始</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="start/install.html"><strong aria-hidden="true">1.1.</strong> WasmEdge 的安装与卸载</a></li><li class="chapter-item "><a href="start/docker.html"><strong aria-hidden="true">1.2.</strong> 使用 Docker 进行 WasmEdge 应用程序开发</a></li><li class="chapter-item "><a href="start/cli.html"><strong aria-hidden="true">1.3.</strong> WasmEdge 命令行</a></li><li class="chapter-item "><a href="start/universal.html"><strong aria-hidden="true">1.4.</strong> 通用 wasm 二进制格式</a></li></ol></li><li class="chapter-item "><a href="intro.html"><strong aria-hidden="true">2.</strong> WasmEdge 介绍</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="intro/use.html"><strong aria-hidden="true">2.1.</strong> 应用场景</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="intro/use/runtime.html"><strong aria-hidden="true">2.1.1.</strong> 云原生的 runtime</a></li><li class="chapter-item "><a href="intro/use/js.html"><strong aria-hidden="true">2.1.2.</strong> JavaScript 或 DSL runtime</a></li><li class="chapter-item "><a href="intro/use/serverless.html"><strong aria-hidden="true">2.1.3.</strong> 公有云中的 Serverless 函数即服务</a></li><li class="chapter-item "><a href="intro/use/edge.html"><strong aria-hidden="true">2.1.4.</strong> 边缘计算</a></li><li class="chapter-item "><a href="intro/use/saas.html"><strong aria-hidden="true">2.1.5.</strong> SaaS 里的嵌入式函数</a></li></ol></li><li class="chapter-item "><a href="intro/features.html"><strong aria-hidden="true">2.2.</strong> WasmEdge 的优势与特点</a></li><li class="chapter-item "><a href="intro/standard.html"><strong aria-hidden="true">2.3.</strong> WebAssembly 的标准扩展</a></li><li class="chapter-item "><a href="intro/proprietary.html"><strong aria-hidden="true">2.4.</strong> WasmEdge 特有的扩展</a></li><li class="chapter-item "><a href="intro/integrations.html"><strong aria-hidden="true">2.5.</strong> 与外部框架的集成</a></li><li class="chapter-item "><a href="intro/faq.html"><strong aria-hidden="true">2.6.</strong> FAQ</a></li></ol></li><li class="chapter-item "><a href="dev.html"><strong aria-hidden="true">3.</strong> 开发 WasmEdge 应用</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="dev/rust.html"><strong aria-hidden="true">3.1.</strong> Rust</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="dev/rust/bindgen.html"><strong aria-hidden="true">3.1.1.</strong> 调用 Rust 函数</a></li><li class="chapter-item "><a href="dev/rust/wasi.html"><strong aria-hidden="true">3.1.2.</strong> 使用操作系统服务</a></li><li class="chapter-item "><a href="dev/rust/tensorflow.html"><strong aria-hidden="true">3.1.3.</strong> Tensorflow</a></li><li class="chapter-item "><a href="dev/rust/networking.html"><strong aria-hidden="true">3.1.4.</strong> 简单的 HTTP 客户端和服务器</a></li><li class="chapter-item "><a href="dev/rust/networking-nonblocking.html"><strong aria-hidden="true">3.1.5.</strong> 非阻塞网络应用</a></li><li class="chapter-item "><a href="dev/rust/ssr.html"><strong aria-hidden="true">3.1.6.</strong> 服务端渲染</a></li><li class="chapter-item "><a href="dev/rust/command.html"><strong aria-hidden="true">3.1.7.</strong> 命令行接口</a></li></ol></li><li class="chapter-item "><a href="dev/js.html"><strong aria-hidden="true">3.2.</strong> JavaScript</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="dev/js/quickstart.html"><strong aria-hidden="true">3.2.1.</strong> 快速开始</a></li><li class="chapter-item "><a href="dev/js/networking.html"><strong aria-hidden="true">3.2.2.</strong> 网络</a></li><li class="chapter-item "><a href="dev/js/fetch.html"><strong aria-hidden="true">3.2.3.</strong> Fetch</a></li><li class="chapter-item "><a href="dev/js/tensorflow.html"><strong aria-hidden="true">3.2.4.</strong> Tensorflow 推理</a></li><li class="chapter-item "><a href="dev/js/ssr.html"><strong aria-hidden="true">3.2.5.</strong> 示例：React SSR</a></li><li class="chapter-item "><a href="dev/js/es6.html"><strong aria-hidden="true">3.2.6.</strong> ES6 模块</a></li><li class="chapter-item "><a href="dev/js/npm.html"><strong aria-hidden="true">3.2.7.</strong> NodeJS & NPM 模块</a></li><li class="chapter-item "><a href="dev/js/rust.html"><strong aria-hidden="true">3.2.8.</strong> 用 Rust 实现 JS API</a></li></ol></li><li class="chapter-item "><a href="dev/python.html"><strong aria-hidden="true">3.3.</strong> Python</a></li><li class="chapter-item "><a href="dev/go.html"><strong aria-hidden="true">3.4.</strong> Go</a></li><li class="chapter-item "><a href="dev/swift.html"><strong aria-hidden="true">3.5.</strong> Swift</a></li><li class="chapter-item "><a href="dev/as.html"><strong aria-hidden="true">3.6.</strong> AssemblyScript</a></li><li class="chapter-item "><a href="dev/kotlin.html"><strong aria-hidden="true">3.7.</strong> Kotlin</a></li><li class="chapter-item "><a href="dev/grain.html"><strong aria-hidden="true">3.8.</strong> Grain</a></li></ol></li><li class="chapter-item "><a href="embed.html"><strong aria-hidden="true">4.</strong> 嵌入 WasmEdge 函数</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="embed/c.html"><strong aria-hidden="true">4.1.</strong> C SDK</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="embed/c/ref.html"><strong aria-hidden="true">4.1.1.</strong> API 参考文档</a></li></ol></li><li class="chapter-item "><a href="embed/go.html"><strong aria-hidden="true">4.2.</strong> Go SDK</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="embed/go/app.html"><strong aria-hidden="true">4.2.1.</strong> 嵌入 WASM 应用程序</a></li><li class="chapter-item "><a href="embed/go/function.html"><strong aria-hidden="true">4.2.2.</strong> 嵌入 WASM 函数</a></li><li class="chapter-item "><a href="embed/go/memory.html"><strong aria-hidden="true">4.2.3.</strong> 传递复杂参数</a></li><li class="chapter-item "><a href="embed/go/tensorflow.html"><strong aria-hidden="true">4.2.4.</strong> Tensorflow 调用</a></li><li class="chapter-item "><a href="embed/go/host_function.html"><strong aria-hidden="true">4.2.5.</strong> 编写 Host Function</a></li><li class="chapter-item "><a href="embed/go/bindgen.html"><strong aria-hidden="true">4.2.6.</strong> 使用 wasm-bindgen</a></li><li class="chapter-item "><a href="embed/go/ref.html"><strong aria-hidden="true">4.2.7.</strong> API 参考文档</a></li></ol></li><li class="chapter-item "><a href="embed/node.html"><strong aria-hidden="true">4.3.</strong> Node.js SDK</a></li><li class="chapter-item "><a href="embed/rust.html"><strong aria-hidden="true">4.4.</strong> Rust SDK</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="embed/rust/sys_run_host_func.html"><strong aria-hidden="true">4.4.1.</strong> 使用 WasmEdge 底层 Rust API 运行 WebAssembly 函数</a></li><li class="chapter-item "><a href="embed/rust/concurrent_fib.html"><strong aria-hidden="true">4.4.2.</strong> 并行计算斐波那契数</a></li></ol></li><li class="chapter-item "><a href="embed/python.html"><strong aria-hidden="true">4.5.</strong> Python SDK</a></li></ol></li><li class="chapter-item "><a href="kubernetes.html"><strong aria-hidden="true">5.</strong> 用 Kubernetes 管理 WasmEdge 应用</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="kubernetes/quickstart.html"><strong aria-hidden="true">5.1.</strong> 快速开始</a></li><li class="chapter-item "><a href="kubernetes/demo.html"><strong aria-hidden="true">5.2.</strong> 应用示例</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="kubernetes/demo/wasi.html"><strong aria-hidden="true">5.2.1.</strong> 简单的 WASI 例子</a></li><li class="chapter-item "><a href="kubernetes/demo/server.html"><strong aria-hidden="true">5.2.2.</strong> HTTP 微服务</a></li></ol></li><li class="chapter-item "><a href="kubernetes/container.html"><strong aria-hidden="true">5.3.</strong> 容器 runtimes</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="kubernetes/container/crun.html"><strong aria-hidden="true">5.3.1.</strong> crun</a></li><li class="chapter-item "><a href="kubernetes/container/runc.html"><strong aria-hidden="true">5.3.2.</strong> runc</a></li><li class="chapter-item "><a href="kubernetes/container/youki.html"><strong aria-hidden="true">5.3.3.</strong> youki</a></li></ol></li><li class="chapter-item "><a href="kubernetes/cri.html"><strong aria-hidden="true">5.4.</strong> CRI runtimes</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="kubernetes/cri/crio.html"><strong aria-hidden="true">5.4.1.</strong> CRI-O</a></li><li class="chapter-item "><a href="kubernetes/cri/containerd.html"><strong aria-hidden="true">5.4.2.</strong> containerd</a></li></ol></li><li class="chapter-item "><a href="kubernetes/kubernetes.html"><strong aria-hidden="true">5.5.</strong> Kubernetes</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="kubernetes/kubernetes/kubernetes-crio.html"><strong aria-hidden="true">5.5.1.</strong> Kubernetes + CRI-O</a></li><li class="chapter-item "><a href="kubernetes/kubernetes/kubernetes-containerd.html"><strong aria-hidden="true">5.5.2.</strong> Kubernetes + containerd</a></li><li class="chapter-item "><a href="kubernetes/kubernetes/kind.html"><strong aria-hidden="true">5.5.3.</strong> KinD</a></li><li class="chapter-item "><a href="kubernetes/kubernetes/kubeedge.html"><strong aria-hidden="true">5.5.4.</strong> KubeEdge</a></li><li class="chapter-item "><a href="kubernetes/kubernetes/superedge.html"><strong aria-hidden="true">5.5.5.</strong> SuperEdge</a></li><li class="chapter-item "><a href="kubernetes/kubernetes/openyurt.html"><strong aria-hidden="true">5.5.6.</strong> OpenYurt</a></li><li class="chapter-item "><a href="kubernetes/kubernetes/knative.html"><strong aria-hidden="true">5.5.7.</strong> Knative</a></li></ol></li></ol></li><li class="chapter-item "><a href="frameworks.html"><strong aria-hidden="true">6.</strong> 应用框架与平台</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="frameworks/mesh.html"><strong aria-hidden="true">6.1.</strong> Service mesh 与分布式框架</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="frameworks/mesh/dapr.html"><strong aria-hidden="true">6.1.1.</strong> Dapr</a></li><li class="chapter-item "><a href="frameworks/mesh/mosn.html"><strong aria-hidden="true">6.1.2.</strong> MOSN</a></li><li class="chapter-item "><a href="frameworks/mesh/eventmesh.html"><strong aria-hidden="true">6.1.3.</strong> Apache EventMesh</a></li></ol></li><li class="chapter-item "><a href="frameworks/app.html"><strong aria-hidden="true">6.2.</strong> 应用框架</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="frameworks/app/yomo.html"><strong aria-hidden="true">6.2.1.</strong> YoMo</a></li><li class="chapter-item "><a href="frameworks/app/reactr.html"><strong aria-hidden="true">6.2.2.</strong> Reactr</a></li></ol></li><li class="chapter-item "><a href="frameworks/serverless.html"><strong aria-hidden="true">6.3.</strong> Serverless 平台</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="frameworks/serverless/vercel.html"><strong aria-hidden="true">6.3.1.</strong> Vercel</a></li><li class="chapter-item "><a href="frameworks/serverless/netlify.html"><strong aria-hidden="true">6.3.2.</strong> Netlify</a></li><li class="chapter-item "><a href="frameworks/serverless/aws.html"><strong aria-hidden="true">6.3.3.</strong> AWS</a></li><li class="chapter-item "><a href="frameworks/serverless/tencent.html"><strong aria-hidden="true">6.3.4.</strong> Tencent</a></li><li class="chapter-item "><a href="frameworks/serverless/secondstate.html"><strong aria-hidden="true">6.3.5.</strong> Second State</a></li></ol></li></ol></li><li class="chapter-item "><a href="os.html"><strong aria-hidden="true">7.</strong> 操作系统</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="os/linux.html"><strong aria-hidden="true">7.1.</strong> Linux</a></li><li class="chapter-item "><a href="os/windows.html"><strong aria-hidden="true">7.2.</strong> Windows</a></li><li class="chapter-item "><a href="os/mac.html"><strong aria-hidden="true">7.3.</strong> Mac</a></li><li class="chapter-item "><a href="os/android.html"><strong aria-hidden="true">7.4.</strong> Android</a></li><li class="chapter-item "><a href="os/sel4.html"><strong aria-hidden="true">7.5.</strong> seL4</a></li><li class="chapter-item "><a href="os/openharmony.html"><strong aria-hidden="true">7.6.</strong> Open Harmony</a></li><li class="chapter-item "><a href="os/raspberrypi.html"><strong aria-hidden="true">7.7.</strong> Raspberry Pi</a></li></ol></li><li class="chapter-item "><a href="extend.html"><strong aria-hidden="true">8.</strong> 为 WasmEdge 贡献代码</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="extend/build.html"><strong aria-hidden="true">8.1.</strong> 编译 WasmEdge</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="extend/build_on_mac.html"><strong aria-hidden="true">8.1.1.</strong> 用 Mac 编译</a></li><li class="chapter-item "><a href="extend/build_on_windows.html"><strong aria-hidden="true">8.1.2.</strong> 用 Windows 编译</a></li><li class="chapter-item "><a href="extend/build_for_android.html"><strong aria-hidden="true">8.1.3.</strong> 为 Android 编译</a></li></ol></li><li class="chapter-item "><a href="extend/plugin.html"><strong aria-hidden="true">8.2.</strong> WasmEdge plug-in API</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="extend/plugin/hostfunction.html"><strong aria-hidden="true">8.2.1.</strong> Host 函数</a></li><li class="chapter-item "><a href="extend/plugin/externref.html"><strong aria-hidden="true">8.2.2.</strong> 外部引用</a></li></ol></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">WasmEdge Runtime</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/WasmEdge/WasmEdge" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="快速开始"><a class="header" href="#快速开始">快速开始</a></h1>
<p>WasmEdge 最简单的使用方式是通过 WasmEdge CLI。
开发者们能使用这个命令行工具来运行我们的 WebAssembly 和 JavaScript 示例程序。
之后，我们也可以使用该工具来创建新的 WasmEdge 程序，并将这些程序部署到不同的应用或者框架中运行。</p>
<h2 id="安装"><a class="header" href="#安装">安装</a></h2>
<p>你可以使用以下的单行命令来安装 WasmEdge。
你的系统必须预先安装 <code>git</code> 和 <code>curl</code>。</p>
<pre><code class="language-bash">curl -sSf https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/utils/install.sh | bash
</code></pre>
<p>如果你正在使用Windows 10，你可以使用Windows Package Manager Client (也称winget.exe)来安装WasmEdge。</p>
<pre><code class="language-bash">winget install wasmedge
</code></pre>
<p>如果你希望一并安装 <a href="https://www.secondstate.io/articles/wasi-tensorflow/">Tensorflow 和图像处理扩展</a>，请执行以下命令。它将尝试在你的系统上安装 Tensorflow 和图像共享库。</p>
<pre><code class="language-bash">curl -sSf https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/utils/install.sh | bash -s -- -e all
</code></pre>
<p>执行以下命令能使已安装的二进制文件在当前会话中可用。</p>
<pre><code class="language-bash">source $HOME/.wasmedge/env
</code></pre>
<h2 id="使用-docker-进行安装"><a class="header" href="#使用-docker-进行安装">使用 Docker 进行安装</a></h2>
<p>如果你使用的是 Docker，你可以直接运行 WasmEdge 应用开发镜像（<a href="https://hub.docker.com/repository/docker/wasmedge/appdev_x86_64">x86</a> 和 <a href="https://hub.docker.com/repository/docker/wasmedge/appdev_aarch64">arm64</a>）。这些镜像里包含快速开发 WasmEdge 所需的所有工具。</p>
<pre><code class="language-bash">$ docker pull wasmedge/appdev_x86_64:0.9.0
$ docker run --rm -v $(pwd):/app -it wasmedge/appdev_x86_64:0.9.0
(docker) #
</code></pre>
<h2 id="webassembly-示例"><a class="header" href="#webassembly-示例">WebAssembly 示例</a></h2>
<p>这里有几个 WebAssembly 字节码的示例供您试用新安装的 WasmEdge CLI。</p>
<h3 id="hello-world"><a class="header" href="#hello-world">Hello world</a></h3>
<p><a href="https://github.com/WasmEdge/WasmEdge/raw/master/examples/wasm/hello.wasm">hello.wasm</a> 这个 WebAssembly 程序中包含一个 <code>main()</code> 函数。
<a href="https://github.com/second-state/wasm-learning/tree/master/cli/hello">查看该程序的 Rust 源码项目。</a>
它将打印 <code>hello</code>，以及所有的命令行参数。</p>
<pre><code class="language-bash">$ wasmedge hello.wasm second state
hello
second
state
</code></pre>
<h3 id="调用一个-rust-函数"><a class="header" href="#调用一个-rust-函数">调用一个 Rust 函数</a></h3>
<p><a href="https://github.com/WasmEdge/WasmEdge/raw/master/examples/wasm/add.wasm">add.wasm</a> 这个 WebAssembly 程序包含一个 <code>add()</code> 函数。
<a href="https://github.com/second-state/wasm-learning/tree/master/cli/add">查看该程序的 Rust 源码项目。</a>
我们在反应器模式下使用 WasmEdge 来调用 <code>add()</code>，并给它 2 个整数作为输入参数。</p>
<pre><code class="language-bash">$ wasmedge --reactor add.wasm add 2 2
4
</code></pre>
<h3 id="调用一个-wat-函数"><a class="header" href="#调用一个-wat-函数">调用一个 WAT 函数</a></h3>
<p>我们手动创建了 <a href="https://github.com/WasmEdge/WasmEdge/raw/master/examples/wasm/fibonacci.wat">fibonacci.wat</a> 程序，并使用了 <a href="https://github.com/WebAssembly/wabt">wat2wasm</a> 编译器来构建 <a href="https://github.com/WasmEdge/WasmEdge/raw/master/examples/wasm/fibonacci.wasm">fibonacci.wasm</a> 这个 WebAssembly 程序。
它包含了一个 <code>fib()</code> 函数，这个函数以一个整数作为输入参数。我们在反应器模式下使用 WasmEdge 来调用这个导出函数。</p>
<pre><code class="language-bash">$ wasmedge --reactor fibonacci.wasm fib 10
89
</code></pre>
<h3 id="开启统计"><a class="header" href="#开启统计">开启统计</a></h3>
<p>CLI工具支持 <code>--enable-all-statistics</code> 标志，用于开启统计和 gas meter 的相关配置。</p>
<pre><code class="language-bash">$ wasmedge --enable-all-statistics hello.wasm second state
hello
second
state
[2021-12-09 16:03:33.261] [info] ====================  Statistics  ====================
[2021-12-09 16:03:33.261] [info]  Total execution time: 268266 ns
[2021-12-09 16:03:33.261] [info]  Wasm instructions execution time: 251610 ns
[2021-12-09 16:03:33.261] [info]  Host functions execution time: 16656 ns
[2021-12-09 16:03:33.261] [info]  Executed wasm instructions count: 20425
[2021-12-09 16:03:33.261] [info]  Gas costs: 20425
[2021-12-09 16:03:33.261] [info]  Instructions per second: 81177218
[2021-12-09 16:03:33.261] [info] =======================   End   ======================
</code></pre>
<h3 id="开启-gas-limit"><a class="header" href="#开启-gas-limit">开启 gas-limit</a></h3>
<p>CLI工具支持 <code>--gas-limit</code> 标志，用于控制执行的成本。</p>
<pre><code class="language-bash"># cd &lt;path/to/WasmEdge&gt;
$ cd examples/wasm
# gas 足够时
$ wasmedge --enable-all-statistics --gas-limit 20425 hello.wasm second state
hello
second
state
[2021-12-09 16:03:33.261] [info] ====================  Statistics  ====================
[2021-12-09 16:03:33.261] [info]  Total execution time: 268266 ns
[2021-12-09 16:03:33.261] [info]  Wasm instructions execution time: 251610 ns
[2021-12-09 16:03:33.261] [info]  Host functions execution time: 16656 ns
[2021-12-09 16:03:33.261] [info]  Executed wasm instructions count: 20425
[2021-12-09 16:03:33.261] [info]  Gas costs: 20425
[2021-12-09 16:03:33.261] [info]  Instructions per second: 81177218
[2021-12-09 16:03:33.261] [info] =======================   End   ======================

# gas 不足时
$ wasmedge --enable-all-statistics --gas-limit 20 hello.wasm second state
[2021-12-23 15:19:06.690] [error] Cost exceeded limit. Force terminate the execution.
[2021-12-23 15:19:06.690] [error]     In instruction: ref.func (0xd2) , Bytecode offset: 0x00000000
[2021-12-23 15:19:06.690] [error]     At AST node: expression
[2021-12-23 15:19:06.690] [error]     At AST node: element segment
[2021-12-23 15:19:06.690] [error]     At AST node: element section
[2021-12-23 15:19:06.690] [error]     At AST node: module
[2021-12-23 15:19:06.690] [info] ====================  Statistics  ====================
[2021-12-23 15:19:06.690] [info]  Total execution time: 0 ns
[2021-12-23 15:19:06.690] [info]  Wasm instructions execution time: 0 ns
[2021-12-23 15:19:06.690] [info]  Host functions execution time: 0 ns
[2021-12-23 15:19:06.690] [info]  Executed wasm instructions count: 21
[2021-12-23 15:19:06.690] [info]  Gas costs: 20
</code></pre>
<h2 id="javascript-示例"><a class="header" href="#javascript-示例">JavaScript 示例</a></h2>
<p>WasmEdge 也可以作为一个高性能、安全、可扩展、易于部署且<a href="https://github.com/second-state/wasmedge-containers-examples">遵循 Kubernetes</a> 的 JavaScript 运行时。</p>
<p><a href="https://github.com/WasmEdge/WasmEdge/raw/master/examples/js/qjs.wasm">qjs.wasm</a> 是一个被编译为 WebAssembly 的 JavaScript 解释器。
<a href="https://github.com/WasmEdge/WasmEdge/raw/master/examples/js/hello.js">hello.js</a> 是一个非常简单的 JavaScript 程序。</p>
<pre><code class="language-bash">$ wasmedge --dir .:. qjs.wasm hello.js 1 2 3
Hello 1 2 3
</code></pre>
<p><a href="https://github.com/WasmEdge/WasmEdge/raw/master/examples/js/qjs_tf.wasm">qjs_tf.wasm</a> 则是一个 WebAssembly 版本的 JavaScript 解释器（带有 <a href="https://www.secondstate.io/articles/wasi-tensorflow/">Tensorflow 扩展</a>）。
要想运行 <a href="https://github.com/WasmEdge/WasmEdge/raw/master/examples/js/qjs_tf.wasm">qjs_tf.wasm</a>，你必须使用 <code>wasmedge-tensorflow-lite</code> 这个命令行工具；这个工具里内置了包含 Tensorflow 扩展的 WasmEdge 构建版本。
你可以下载一个<a href="https://github.com/second-state/wasmedge-quickjs/tree/main/example_js/tensorflow_lite_demo">基于 Tensorflow 的完整 JavaScript 示例</a>来对图像进行分类。</p>
<pre><code class="language-bash"># Download the Tensorflow example
$ wget https://raw.githubusercontent.com/second-state/wasmedge-quickjs/main/example_js/tensorflow_lite_demo/aiy_food_V1_labelmap.txt
$ wget https://raw.githubusercontent.com/second-state/wasmedge-quickjs/main/example_js/tensorflow_lite_demo/food.jpg
$ wget https://raw.githubusercontent.com/second-state/wasmedge-quickjs/main/example_js/tensorflow_lite_demo/lite-model_aiy_vision_classifier_food_V1_1.tflite
$ wget https://raw.githubusercontent.com/second-state/wasmedge-quickjs/main/example_js/tensorflow_lite_demo/main.js

$ wasmedge-tensorflow-lite --dir .:. qjs_tf.wasm main.js
label: Hot dog
confidence: 0.8941176470588236
</code></pre>
<p>继续阅读并学习 WasmEdge。</p>
<ul>
<li><a href="start/install.html">WasmEdge 的安装与卸载</a></li>
<li><a href="start/cli.html">WasmEdge 命令行</a></li>
<li><a href="intro/use.html">WasmEdge 应用场景</a></li>
<li><a href="intro/features.html">WasmEdge 的优势与特点</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="wasmedge-的安装与卸载"><a class="header" href="#wasmedge-的安装与卸载">WasmEdge 的安装与卸载</a></h1>
<h2 id="快速安装"><a class="header" href="#快速安装">快速安装</a></h2>
<p>安装 WasmEdge 最简单的方式是执行以下的命令（前提是你的系统已经安装了 <code>git</code> 和 <code>curl</code>）：</p>
<pre><code class="language-bash">curl -sSf https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/utils/install.sh | bash
</code></pre>
<p>如果你正在使用Windows 10，你可以使用Windows Package Manager Client (也称winget.exe)来安装WasmEdge。</p>
<pre><code class="language-bash">winget install wasmedge
</code></pre>
<p>如果你希望一并安装 <a href="https://www.secondstate.io/articles/wasi-tensorflow/">Tensorflow 和图像处理扩展</a>，请执行以下命令。它将尝试在你的系统上安装 Tensorflow 和图像共享库。</p>
<pre><code class="language-bash">curl -sSf https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/utils/install.sh | bash -s -- -e all
</code></pre>
<p>执行 <code>source $HOME/.wasmedge/env</code> 命令能使已安装的二进制文件在当前会话中可用。</p>
<p>**就这么简单！**你现在可以通过命令行使用 WasmEdge，或者直接将其作为应用打开。要想升级 WasmEdge，你只需要重新执行以上的命令，旧的文件将被覆盖。</p>
<h2 id="为所有用户安装-wasmedge"><a class="header" href="#为所有用户安装-wasmedge">为所有用户安装 WasmEdge</a></h2>
<p>在默认情况下，WasmEdge 将安装在 <code>$HOME/.wasmedge</code> 目录中。你也可以将它安装在系统目录中，如 <code>/usr/local</code>，以便所有用户都能使用 WasmEdge。要想指定一个安装路径，你可以在执行 <code>install.sh</code> 脚本时附上 <code>-p</code> 选项。由于文件将写入系统目录，你需要以 <code>root</code> 用户或 <code>sudo</code> 权限执行以下命令：</p>
<pre><code class="language-bash">curl -sSf https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/utils/install.sh | bash -s -- -p /usr/local
</code></pre>
<p>或者（包含图像扩展）：</p>
<pre><code class="language-bash">curl -sSf https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/utils/install.sh | bash -s -- -e all -p /usr/local
</code></pre>
<h2 id="安装指定版本的-wasmedge"><a class="header" href="#安装指定版本的-wasmedge">安装指定版本的 WasmEdge</a></h2>
<p>你可以将 <code>-v</code> 参数传递给 <code>install.sh</code> 脚本来安装指定版本的 WasmEdge（包括预发行版本和历史版本）。例子如下：</p>
<pre><code class="language-bash">curl -sSf https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/utils/install.sh | bash -s -- -e all -v 0.9.1
</code></pre>
<p>如果你对 <code>master</code> 分支的 <code>HEAD</code> 中的最新的构建感兴趣（也就是 WasmEdge 的 nightly 版本），你可以直接从 Github Action 的 CI artifact 中下载已发布的包。<a href="https://github.com/WasmEdge/WasmEdge/actions/runs/1521549504#artifacts">例子请看这里。</a></p>
<h2 id="安装内容"><a class="header" href="#安装内容">安装内容</a></h2>
<p>安装完成后，你将会得到以下的目录和文件。这里我们假设你将 WasmEdge 安装到 <code>$HOME/.wasmedge</code> 目录中。如果你想进行系统范围的安装，你也可以将安装目录更改为 <code>/usr/local</code>。</p>
<p>如果你使用winget来安装WasmEdge，安装目录在<code>C:\Program Files\WasmEdge</code>。</p>
<ul>
<li><code>$HOME/.wasmedge/bin</code> 目录包含 WasmEdge Runtime CLI 可执行文件。你可以拷贝这些文件并放置到任意目录中。
<ul>
<li><code>wasmedge</code> 工具是标准的 WasmEdge 运行时。你可以在命令行中使用它：<code>wasmedge --dir .:. app.wasm</code>。</li>
<li><code>wasmedgec</code> 工具是 AOT 编译器，它能将 <code>wasm</code> 文件编译为原生 <code>so</code> 文件：<code>wasmedgec app.wasm app.so</code>。之后，<code>wasmedge</code> 就能执行 <code>so</code> 文件了：<code>wasmedge --dir .:. app.so</code>。</li>
<li><code>wasmedge-tensorflow</code> 和 <code>wasmedge-tensorflow-lite</code> 工具是支持 WasmEdge Tensorflow SDK 的 WasmEdge 运行时。</li>
</ul>
</li>
<li><code>$HOME/.wasmedge/lib</code> 目录包含 WasmEdge 的共享库和依赖库。从主程序中启动 WasmEdge 程序和功能会用到这些文件。</li>
<li><code>$HOME/.wasmedge/include</code> 目录包含了 WasmEdge 的头文件。这些文件用于 WasmEdge SDK 中。</li>
</ul>
<h2 id="卸载"><a class="header" href="#卸载">卸载</a></h2>
<p>要想卸载 WasmEdge，你可以执行以下的命令：</p>
<pre><code class="language-bash">bash &lt;(curl -sSf https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/utils/uninstall.sh)
</code></pre>
<p>如果 <code>wasmedge</code> 这个二进制文件不在 <code>PATH</code> 中，且 WasmEdge 不是安装在默认的<code>$HOME/.wasmedge</code> 目录，那么你必须在执行命令时附上安装路径。</p>
<pre><code class="language-bash">bash &lt;(curl -sSf https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/utils/uninstall.sh) -p /path/to/parent/folder
</code></pre>
<p>如果你希望以非交互的方式卸载 WasmEdge，你可以附上 <code>--quick</code> 或 <code>-q</code> 选项。</p>
<pre><code class="language-bash">bash &lt;(curl -sSf https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/utils/uninstall.sh) -q
</code></pre>
<blockquote>
<p>如果 <code>wasmedge</code> 二进制文件的父目录中包含 <code>.wasmedge</code>，那么该目录将会被一并删除。举例来说，该脚本将会完全删除默认的 <code>$HOME/.wasmedge</code> 目录。</p>
</blockquote>
<p>如果你使用的是winget来安装WasmEdge，可以使用下面的命令卸载：</p>
<pre><code class="language-bash">winget uninstall wasmedge
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="使用-docker-进行-wasmedge-应用程序开发"><a class="header" href="#使用-docker-进行-wasmedge-应用程序开发">使用 Docker 进行 WasmEdge 应用程序开发</a></h1>
<p><code>appdev</code> Docker 镜像提供了一个完整的 WasmEdge 应用程序开发环境。要想使用该镜像，请执行以下操作。</p>
<h2 id="使用-x86_64-系统"><a class="header" href="#使用-x86_64-系统">使用 x86_64 系统</a></h2>
<pre><code class="language-bash">$ docker pull wasmedge/appdev_x86_64:0.9.0
$ docker run --rm -v $(pwd):/app -it wasmedge/appdev_x86_64:0.9.0
(docker) #
</code></pre>
<p>查看 <code>appdev</code> 的 <a href="https://github.com/WasmEdge/WasmEdge/blob/master/utils/docker/Dockerfile.appdev_x86_64">Dockerfile</a> 和 <a href="https://hub.docker.com/repository/docker/wasmedge/appdev_x86_64">Docker Hub 镜像</a>。</p>
<h2 id="使用-arm64-系统"><a class="header" href="#使用-arm64-系统">使用 arm64 系统</a></h2>
<pre><code class="language-bash">$ docker pull wasmedge/appdev_aarch64:0.9.0
$ docker run --rm -v $(pwd):/app -it wasmedge/appdev_aarch64:0.9.0
(docker) #
</code></pre>
<p>查看 <code>appdev</code> 的 <a href="https://github.com/WasmEdge/WasmEdge/blob/master/utils/docker/Dockerfile.appdev_aarch64">Dockerfile</a> 和 <a href="https://hub.docker.com/repository/docker/wasmedge/appdev_aarch64">Docker Hub 镜像</a>。</p>
<p>这个 <code>appdev</code> 镜像安装了以下组件：</p>
<ul>
<li>WasmEdge CLI 和共享库；</li>
<li>(仅限 x86_64 系统）包含 Tensorflow 扩展命令行和库的 WasmEdge；</li>
<li>Golang；</li>
<li>Rust；</li>
<li>包含 WasmEdge 插件的 Node.js；</li>
<li>在 <code>/root/examples/</code> 文件夹的一些示例。</li>
</ul>
<h2 id="一些示例"><a class="header" href="#一些示例">一些示例</a></h2>
<p>Hello World 示例。<a href="https://github.com/WasmEdge/WasmEdge/tree/master/tools/wasmedge/examples">查看更多。</a></p>
<pre><code class="language-bash">$ wasmedge hello.wasm world
hello
world
</code></pre>
<p>使用 AOT 来<strong>加快程序的运行速度</strong>。</p>
<pre><code class="language-bash">$ wasmedgec hello.wasm hello.wasm
$ wasmedge hello.wasm world
hello
world
</code></pre>
<p>以下是一些 JavaScript 示例。<a href="https://github.com/WasmEdge/WasmEdge/tree/master/tools/wasmedge/examples/js">查看更多。</a></p>
<pre><code class="language-bash">$ wasmedge --dir .:. qjs.wasm hello.js 1 2 3
Hello 1 2 3

$ wasmedge-tensorflow-lite --dir .:. qjs_tf.wasm tf_image_classify.js
label: Hot dog
confidence: 0.8941176470588236
</code></pre>
<h2 id="构建并发布-appdev-镜像"><a class="header" href="#构建并发布-appdev-镜像">构建并发布 <code>appdev</code> 镜像</a></h2>
<p>运行以下的命令来构建并发布 <code>appdev</code> 镜像：</p>
<h3 id="x86_64-系统"><a class="header" href="#x86_64-系统">x86_64 系统</a></h3>
<pre><code class="language-bash">docker build -t wasmedge/appdev_x86_64:0.9.0 -f Dockerfile.appdev_x86_64 ./
docker image push wasmedge/appdev_x86_64:0.9.0
</code></pre>
<h3 id="arm64--aarch64-系统"><a class="header" href="#arm64--aarch64-系统">ARM64 / aarch64 系统</a></h3>
<pre><code class="language-bash">docker build -t wasmedge/appdev_aarch64:0.9.0 -f Dockerfile.appdev_aarch64 ./
docker image push wasmedge/appdev_aarch64:0.9.0
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="wasmedge-命令行"><a class="header" href="#wasmedge-命令行">WasmEdge 命令行</a></h1>
<p>在<a href="start/install.html">安装 WasmEdge</a> 或启动 <a href="start/docker.html">WasmEdge appdev Docker 容器</a>后，我们可以通过多种方法运行已经编译好的 WebAssembly 程序。</p>
<h2 id="wasmedge"><a class="header" href="#wasmedge">wasmedge</a></h2>
<p><code>wasmedge</code> 二进制文件是一个用来运行 WebAssembly 程序应用的命令行工具（CLI）。</p>
<ul>
<li>假如 WebAssembly 程序包含一个 <code>main()</code> 函数，<code>wasmedge</code> 将在命令模式下将其作为独立程序执行。</li>
<li>假如 WebAssembly 程序包含一个或者多个公共函数，<code>wasmedge</code> 可以在 反应器模式下单独执行每个函数。</li>
</ul>
<h3 id="命令行选项"><a class="header" href="#命令行选项">命令行选项</a></h3>
<p><code>wasmedge</code> 的选项和标志如下所示：</p>
<ol>
<li>（可选）统计信息：
<ul>
<li>用 <code>--enable-time-measuring</code> 来展示执行时间；</li>
<li>用 <code>--enable-gas-measuring</code> 来展示 gas 的消耗量；</li>
<li>用 <code>--enable-instruction-count</code> 来展示执行的指令数量；</li>
<li>或者用 <code>--enable-all-statistics</code> 来启用所有的统计选项。</li>
</ul>
</li>
<li>（可选）资源限制：
<ul>
<li>用 <code>--gas-limit</code> 来限制执行所花费的 gas；</li>
<li>用 <code>--memory-page-limit</code> 来设置每一个内存实例的页限制（大小为 64 KiB）。</li>
</ul>
</li>
<li>(可选) 反应器模式：使用 <code>--reactor</code> 来启用反应器模式；在该模式下，<code>wasmedge</code> 将运行 WebAssembly 程序中指定的函数：
<ul>
<li>WasmEdge 将执行第一个参数（<code>ARG[0]</code>）所指定的函数名；</li>
<li>假如存在名为 <code>_initialize</code> 的导出函数，这个函数将最先以空参的方式执行。</li>
</ul>
</li>
<li>（可选）将目录绑定到 WASI 虚拟文件系统：
<ul>
<li>每一个目录都以 <code>--dir guest_path:host_path</code> 的方式指定。</li>
</ul>
</li>
<li>（可选）环境变量：
<ul>
<li>每一个变量都以 <code>--env NAME=VALUE</code> 的方式指定。</li>
</ul>
</li>
<li>Wasm 文件（<code>/path/to/wasm/file</code>）；</li>
<li>（可选）参数：
<ul>
<li>在反应器模式下，第一个参数将作为函数的名称，<code>ARG[0]</code> 后的其余参数将作为 <code>ARG[0]</code> 函数的参数；</li>
<li>在命令模式下，命令行参数将作为 <code>_start</code> 函数的参数；它们也被称为独立程序的命令行参数。</li>
</ul>
</li>
</ol>
<p>安装完毕后，你可以<a href="start/../index.html">查看并运行我们的示例</a>。</p>
<h2 id="wasmedgec"><a class="header" href="#wasmedgec">wasmedgec</a></h2>
<p><code>wasmedgec</code> 是一个将 WebAssembly 字节码编译成原生机器码的程序（即 AOT 编译器）。
编译好的机器码可以被<a href="start/universal.html">储存在原本的 <code>wasm</code> 文件中</a>，<code>wasmedge</code> 命令行将自动地选择可用的原生机器码。</p>
<p><code>wasmedgec</code> 的选项和标志如下所示：</p>
<ol>
<li>Wasm 输入文件（<code>/path/to/input/wasm/file</code>）；</li>
<li>输出文件的名称（<code>/path/to/output/file</code>）：
<ul>
<li>默认情况下，它将生成<a href="start/universal.html">通用 wasm 二进制格式</a>；</li>
<li>用户也可以通过指定 <code>.so</code>、<code>.dylib</code> 或者 <code>.dll</code> 扩展名来生成原生二进制文件。</li>
</ul>
</li>
</ol>
<pre><code class="language-bash"># 这很慢
wasmedge app.wasm

# AOT 编译
wasmedgec app.wasm app.wasm

# 现在就快多了
wasmedge app.wasm
</code></pre>
<p>在 Linux 系统上，它将会生成一个 <code>so</code> 共享库文件，然后由 <code>wasmedge</code> 运行时执行。</p>
<pre><code class="language-bash">wasmedgec app.wasm app.so
wasmedge app.so
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="通用-wasm-二进制格式"><a class="header" href="#通用-wasm-二进制格式">通用 wasm 二进制格式</a></h1>
<p>WasmEdge 可以将 AOT 编译的原生二进制包装到原始 wasm 文件中的自定义部分。我们将其称之为通用 wasm 二进制格式。</p>
<p>AOT 编译的 wasm 文件与任何 wasm 运行时兼容。然而，当 WasmEdge 运行时执行此 wasm 文件时，WasmEdge 将从自定义部分中提取原生二进制并执行它。</p>
<p>当然，用户仍然可以选择使用 <code>wasmedgec</code> AOT 编译器生成原生二进制文件。
WasmEdge 将以输出文件扩展名来确定生成的文件格式。举例来说，如果你将 <code>wasmedgec</code> 的输出文件扩展名设置为 <code>.so</code>，它将生成 Linux 共享库格式的原生二进制文件；否则，它将默认生成一个通用的 wasm 二进制文件。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="wasmedge-介绍"><a class="header" href="#wasmedge-介绍">WasmEdge 介绍</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="应用场景"><a class="header" href="#应用场景">应用场景</a></h1>
<p>WasmEdge 是由 CNCF 托管的云原生 WebAssembly runtime。它广泛应用于边缘计算、汽车、Jamstack、Serverless、SaaS、服务网格，乃至区块链应用。 WasmEdge 可以进行 AOT （提前编译）编译器优化，是当今市场上最快的 WebAssembly runtime 之一。</p>
<ul>
<li><a href="intro/use/runtime.html">云原生 runtime</a>
<ul>
<li>Dapr</li>
<li>Kubernetes</li>
</ul>
</li>
<li><a href="intro/use/js.html">JavaScript 或 DSL runtime</a>
<ul>
<li>JavaScript</li>
<li>用于图像识别的 DSL</li>
<li>用于聊天机器人的 DSL</li>
</ul>
</li>
<li><a href="intro/use/serverless.html">公有云中的 Serverless 函数即服务</a>
<ul>
<li>AWS Lambda</li>
<li>腾讯 Serverless 函数</li>
<li>Vercel Serverless 函数</li>
<li>Netlify Functions</li>
<li>Second State Functions</li>
</ul>
</li>
<li><a href="intro/use/edge.html">边缘计算</a>
<ul>
<li>YoMo Flow</li>
<li>seL4 micokernel and RTOS</li>
</ul>
</li>
<li><a href="intro/use/saas.html">用于 SaaS 的响应式函数</a>
<ul>
<li>Slack</li>
<li>飞书</li>
</ul>
</li>
</ul>
<p>如果关于 WasmEdge 有什么好主意，马上开 <a href="https://github.com/WasmEdge/WasmEdge/issues">一个 GitHub issue</a> 来一起讨论吧。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="云原生的-runtime"><a class="header" href="#云原生的-runtime">云原生的 runtime</a></h1>
<p>WasmEdge 可以通过其 <a href="intro/use/../../embed/c.html">C</a>, <a href="intro/use/../../embed/go.html">Go</a>, <a href="intro/use/../../embed/rust.html">Rust</a>, 和 <a href="intro/use/../../embed/node.html">JavaScript</a> 的 SDK 嵌入到云原生基础设施中。它也是一个符合 OCI 的 runtime ，可以由 <a href="https://www.secondstate.io/articles/manage-webassembly-apps-in-wasmedge-using-docker-tools/">CRI-O 和 Docker 工具直接管理</a> ，作为 Docker 的轻量级和高性能替代。</p>
<h2 id="dapr-分布式应用-runtime"><a class="header" href="#dapr-分布式应用-runtime">Dapr (分布式应用 Runtime)</a></h2>
<ul>
<li><a href="https://www.secondstate.io/articles/dapr-wasmedge-webassembly/">教程</a></li>
<li><a href="https://github.com/second-state/dapr-wasm">代码教程</a></li>
</ul>
<h2 id="service-mesh-开发进行中"><a class="header" href="#service-mesh-开发进行中">Service mesh (开发进行中)</a></h2>
<ul>
<li>Linkerd</li>
<li>MOSN</li>
<li>Envoy</li>
</ul>
<h2 id="编排和管理"><a class="header" href="#编排和管理">编排和管理</a></h2>
<ul>
<li><a href="https://www.secondstate.io/articles/manage-webassembly-apps-in-wasmedge-using-docker-tools/">Kubernetes</a></li>
<li>KubeEdge</li>
<li>SuperEdge</li>
<li>OpenYurt</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="javascript-或-dsl-runtime"><a class="header" href="#javascript-或-dsl-runtime">JavaScript 或 DSL runtime</a></h1>
<p>为了让 WebAssembly 被开发者广泛采用作为 runtime，它必须支持像 JavaScript 这样的“简单”语言。或者，更棒的是，通过其高级编译器工具链， WasmEdge 可以支持高性能 DSL（领域特定语言），这是专为特定任务设计的低代码解决方案。</p>
<h2 id="javascript"><a class="header" href="#javascript">JavaScript</a></h2>
<p>WasmEdge 可以通过嵌入 JS 执行引擎或解释器来充当云原生 JavaScript runtime 。它比在 Docker 中运行 JS 引擎更快更轻。 WasmEdge 支持 JS API 访问原生扩展库，例如网络 socket 、 tensorflow 和用户定义的共享库。它还允许将 JS 嵌入其他高性能语言（例如 Rust ）或使用 Rust/C 来实现 JS 函数。</p>
<ul>
<li>教程
<ul>
<li><a href="https://www.secondstate.io/articles/run-javascript-in-webassembly-with-wasmedge/">运行 JavaScript</a></li>
<li><a href="https://www.secondstate.io/articles/embed-javascript-in-rust/">在 Rust 中嵌入 JavaScript</a></li>
<li><a href="https://www.secondstate.io/articles/embed-rust-in-javascript/">用 Rust 函数创建 JavaScript API</a></li>
<li><a href="https://www.secondstate.io/articles/call-native-functions-from-javascript/">从 JavaScript调用 C 原生共享库函数</a></li>
</ul>
</li>
<li><a href="https://github.com/WasmEdge/WasmEdge/blob/master/examples/js/README.md">例子</a></li>
<li><a href="https://github.com/second-state/wasmedge-quickjs">WasmEdge的内嵌 QuickJS 引擎</a></li>
</ul>
<h2 id="用于图片识别的-dsl"><a class="header" href="#用于图片识别的-dsl">用于图片识别的 DSL</a></h2>
<p>图像识别 DSL 是一种 YAML 格式，允许用户指定 tensorflow 模型及其参数。 WasmEdge 将图像作为 DSL 的输入并输出检测到的项目名称/标签。</p>
<ul>
<li>示例: <a href="https://github.com/second-state/wasm-learning/blob/master/cli/classify_yml/config/food.yml">运行 YMAL 以识别图片中的食品</a></li>
</ul>
<h2 id="用于聊天机器人的-dsl"><a class="header" href="#用于聊天机器人的-dsl">用于聊天机器人的 DSL</a></h2>
<p>聊天机器人 DSL 函数接受输入字符串并回复字符串进行响应。 DSL 指定了聊天机器人的内部状态转换，以及用于语言理解的 AI 模型。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="公有云中的-serverless-函数即服务"><a class="header" href="#公有云中的-serverless-函数即服务">公有云中的 Serverless 函数即服务</a></h1>
<p>WasmEdge 与现有的 Serverless 或 Jamstack 平台配合使用，为函数提供高性能、可移植和安全的 runtime。即使在这些平台上的 Docker 或 microVM 中运行，也能提供显著的好处。</p>
<h2 id="aws-lambda"><a class="header" href="#aws-lambda">AWS Lambda</a></h2>
<ul>
<li><a href="https://www.cncf.io/blog/2021/08/25/webassembly-serverless-functions-in-aws-lambda/">教程</a></li>
<li><a href="https://github.com/second-state/aws-lambda-wasm-runtime">代码模板</a></li>
</ul>
<h2 id="腾讯-serverless-函数"><a class="header" href="#腾讯-serverless-函数">腾讯 Serverless 函数</a></h2>
<ul>
<li><a href="https://my.oschina.net/u/4532842/blog/5172639">中文教程</a></li>
<li><a href="https://github.com/second-state/tencent-scf-wasm-runtime">代码模板</a></li>
</ul>
<h2 id="vercel-serverless-函数"><a class="header" href="#vercel-serverless-函数">Vercel Serverless 函数</a></h2>
<ul>
<li><a href="https://www.secondstate.io/articles/vercel-wasmedge-webassembly-rust/">教程</a></li>
<li><a href="https://github.com/second-state/vercel-wasm-runtime">代码模版</a></li>
</ul>
<h2 id="netlify-functions"><a class="header" href="#netlify-functions">Netlify Functions</a></h2>
<ul>
<li><a href="https://www.secondstate.io/articles/netlify-wasmedge-webassembly-rust-serverless/">教程</a></li>
<li><a href="https://github.com/second-state/netlify-wasm-runtime">代码模版</a></li>
</ul>
<h2 id="second-state-functions"><a class="header" href="#second-state-functions">Second State Functions</a></h2>
<ul>
<li><a href="https://www.secondstate.io/faas/">教程</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="边缘计算"><a class="header" href="#边缘计算">边缘计算</a></h1>
<p>WasmEdge 非常适合在任务关键的边缘设备或边缘网络上运行。</p>
<h2 id="yomo-flow"><a class="header" href="#yomo-flow">YoMo Flow</a></h2>
<p>YoMo 是一种用于远边缘（far edge）网络的高性能数据流框架。 WasmEdge 集成到 YoMo 中以运行用户定义的工作负载，例如在工厂装配线上进行的图像识别。</p>
<ul>
<li><a href="https://www.secondstate.io/articles/yomo-wasmedge-real-time-data-streams/">教程</a></li>
<li><a href="https://github.com/yomorun/yomo-wasmedge-tensorflow">代码模板</a></li>
</ul>
<h2 id="sel4-微内核操作系统"><a class="header" href="#sel4-微内核操作系统">seL4 微内核操作系统</a></h2>
<p>seL4 是一个高度安全的实时操作系统。 WasmEdge 是唯一可以在 seL4 上运行的 WebAssembly runtime，它以本机速度运行。我们还提供了一个管理工具来支持 wasm 模块的 OTA 部署。</p>
<ul>
<li><a href="https://github.com/second-state/wasmedge-seL4">Demo</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="saas-里的嵌入式函数"><a class="header" href="#saas-里的嵌入式函数">SaaS 里的嵌入式函数</a></h1>
<p>WasmEdge 可以使用 Serverless 函数而不是传统的网络 API 来支持定制的 SaaS 扩展或应用程序。这极大地提高了 SaaS 用户和开发者的生产力。</p>
<h2 id="slack"><a class="header" href="#slack">Slack</a></h2>
<ul>
<li><a href="http://reactor.secondstate.info/en/docs/user_guideline.html">为 Slack 创建 serverless 聊天机器人</a></li>
</ul>
<h2 id="飞书"><a class="header" href="#飞书">飞书</a></h2>
<p>飞书为字节跳动旗下的聊天软件。</p>
<ul>
<li><a href="http://reactor.secondstate.info/zh/docs/user_guideline.html">为飞书创建 serverless 聊天机器人</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="wasmedge-的优势与特点"><a class="header" href="#wasmedge-的优势与特点">WasmEdge 的优势与特点</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="webassembly-的标准扩展"><a class="header" href="#webassembly-的标准扩展">WebAssembly 的标准扩展</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="wasmedge-特有的扩展"><a class="header" href="#wasmedge-特有的扩展">WasmEdge 特有的扩展</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="wasmedge-特有的集成"><a class="header" href="#wasmedge-特有的集成">WasmEdge 特有的集成</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="faq"><a class="header" href="#faq">FAQ</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="开发-wasmedge-应用"><a class="header" href="#开发-wasmedge-应用">开发 WasmEdge 应用</a></h1>
<p>WebAssembly 的一个关键点就是它支持多种编程语言。WebAssembly 是一个可控的运行时，支持多种编程语言，包含 C/C++、 Rust、 Go、 Swift、 Kotlin、 AssemblyScript、 Grain，甚至还有 JavaScript 和 Python。</p>
<ul>
<li>对于编译型语言（比如 C 和 Rust）来说，WasmEdge WebAssembly 提供了一个相比于原生客户端（NaCl）更安全的、受保护的、隔离的并且容器化的运行时。</li>
<li>对于解释型语言或者是受控型语言（比如 JavaScript 和 Python）来说，WasmEdge WebAssembly 提供了一个比 Docker + 客人操作系统（Guest OS） + 原生解释器这种组合更安全、快速、轻量且容器化的运行时。</li>
</ul>
<p>在这一章中，我们将讨论如何在 WasmEdge 中运行由不同语言编写的应用程序。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rust"><a class="header" href="#rust">Rust</a></h1>
<p>在 WebAssembly 生态中，Rust 是一等公民编程语言之一。对开发者来说，所有编译为 WebAssembly 的 WasmEdge 拓展都有相对应的 Rust 的开发接口。
在这一章节中，我们将会向你展示如何将你的 Rust 应用程序编译为 WASM 字节码，并且在 WasmEdge Runtime 中运行它。</p>
<h2 id="前置条件"><a class="header" href="#前置条件">前置条件</a></h2>
<p>开始前，你需要安装 <a href="https://www.rust-lang.org/tools/install">Rust</a> 以及  <a href="dev/../start/install.html">WasmEdge</a>。
同时你也应该将 <code>wasm32-wasi</code> 添加到 Rust 工具链中。</p>
<pre><code class="language-bash">rustup target add wasm32-wasi
</code></pre>
<h2 id="hello-world-1"><a class="header" href="#hello-world-1">Hello world</a></h2>
<p>Hello world 示例是一个独立的 Rust 应用程序，可以被 <a href="dev/../start/cli.html">WasmEdge 命令行接口</a> 执行。它的<a href="https://github.com/second-state/wasm-learning/tree/master/cli/hello">源代码在这里</a>。</p>
<p>如下是 <a href="https://github.com/second-state/wasm-learning/blob/master/cli/hello/src/main.rs">main.rs</a> 的完整代码，它将输出在运行的时候接收到的命令行参数。</p>
<pre><pre class="playground"><code class="language-rust">use std::env;

fn main() {
  println!(&quot;hello&quot;);
  for argument in env::args().skip(1) {
    println!(&quot;{}&quot;, argument);
  }
}
</code></pre></pre>
<h3 id="hello-world-构建-wasm-字节码"><a class="header" href="#hello-world-构建-wasm-字节码">Hello world： 构建 WASM 字节码</a></h3>
<pre><code class="language-bash">cargo build --target wasm32-wasi
</code></pre>
<h3 id="hello-world-在命令行中运行应用程序"><a class="header" href="#hello-world-在命令行中运行应用程序">Hello world： 在命令行中运行应用程序</a></h3>
<p>我们将使用 <code>wasmedge</code> 命令来运行这个程序。</p>
<pre><code class="language-bash">$ wasmedge target/wasm32-wasi/debug/hello.wasm second state
hello
second
state
</code></pre>
<h2 id="一个简单的函数"><a class="header" href="#一个简单的函数">一个简单的函数</a></h2>
<p><a href="https://github.com/second-state/wasm-learning/tree/master/cli/add">add 示例</a>是一个 Rust 库函数，可以被 <a href="dev/../start/cli.html">WasmEdge 命令行接口</a> 接口在 <code>--reactor</code> 模式下执行。</p>
<p>如下是 <a href="https://github.com/second-state/wasm-learning/blob/master/cli/add/src/lib.rs">lib.rs</a> 的完整代码，它将输出在运行的时候接收到的命令行参数。
它提供了一个简单的 <code>add()</code> 函数。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[no_mangle]
pub fn add(a: i32, b: i32) -&gt; i32 {
  return a + b;
}
<span class="boring">}
</span></code></pre></pre>
<h3 id="一个简单的函数-构建-wasm-字节码"><a class="header" href="#一个简单的函数-构建-wasm-字节码">一个简单的函数： 构建 WASM 字节码</a></h3>
<pre><code class="language-bash">cargo build --target wasm32-wasi
</code></pre>
<h3 id="一个简单的函数-在命令行中运行应用程序"><a class="header" href="#一个简单的函数-在命令行中运行应用程序">一个简单的函数： 在命令行中运行应用程序</a></h3>
<p>我们将使用 WasmEdge 的 <code>--reactor</code> 模式来运行这个程序。我们将函数的名字以及它的输入参数作为命令行参数。</p>
<pre><code class="language-bash">$ wasmedge --reactor target/wasm32-wasi/debug/add.wasm add 2 2
4
</code></pre>
<h2 id="传递复杂的参数"><a class="header" href="#传递复杂的参数">传递复杂的参数</a></h2>
<p>当然，在大多数情况下，你不会使用命令行参数来调用函数。
相反地，你可能会需要使用一个 <a href="dev/../../embed.html">WasmEdge 提供的语言 SDK</a> 来调用函数、传递参数以及接收返回值。
以下是一些关于复杂参数和返回值的 SDK 示例。</p>
<ul>
<li><a href="dev/../embed/go/function.html">在 GO 程序中使用 wasmedge-bindgen</a></li>
<li><a href="dev/../embed/go/memory.html">在 GO 程序中直接传递内存</a></li>
</ul>
<h2 id="提升性能"><a class="header" href="#提升性能">提升性能</a></h2>
<p>如果要让这些应用程序达到原生 Rust 的性能，你可以使用 <code>wasmedgec</code> 命令对 <code>wasm</code> 程序进行提前编译（AOT），然后使用 <code>wasmedge</code> 命令运行它。</p>
<pre><code class="language-bash">$ wasmedgec hello.wasm hello.wasm

$ wasmedge hello.wasm second state
hello
second
state
</code></pre>
<p>对于 <code>--reactor</code> 模式，</p>
<pre><code class="language-bash">$ wasmedgec add.wasm add.wasm

$ wasmedge --reactor add.wasm add 2 2
4
</code></pre>
<h2 id="更多资料"><a class="header" href="#更多资料">更多资料</a></h2>
<ul>
<li><a href="dev/rust/wasi.html">通过 WASI 访问系统服务</a> 展示了 WebAssembly 程序如何访问底层系统服务，比如文件系统和环境变量。</li>
<li><a href="dev/rust/tensorflow.html">Tensorflow</a> 展示了如何使用 WasmEdge Tensorflow Rust SDK 来为 WebAssembly 创建基于 Tensorflow 的 AI 推理应用程序。</li>
<li><a href="dev/rust/networking.html">简单的网络通信</a> 展示了如何使用 WasmEdge 网络通信 Rust SDK 来创建简单的 HTTP 客户端以及服务端应用程序。</li>
<li><a href="dev/rust/networking-nonblocking.html">非阻塞的网络通信</a> 展示了如何使用 WasmEdge 网络通信 Rust SDK 来创建一个高性能、非阻塞、并发连接的网络应用程序。</li>
<li><a href="dev/rust/ssr.html">服务器端渲染</a> 展示了如何使用 Rust 构建一个可交互的 Web 程序，并在服务器上使用 WasmEdge 来渲染 HTML DOM UI。用来渲染 HTML DOM 的 Rust 源代码会被编译为 WebAssembly，在浏览器中或是服务器上运行。</li>
<li><a href="dev/rust/command.html">命令接口</a> 展示了如何使用 WasmEdge 命令行接口 Rust SDK 来为 WebAssembly 创建原生的命令行应用程序。</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="调用-rust-函数"><a class="header" href="#调用-rust-函数">调用 Rust 函数</a></h1>
<p>如果你的 Rust 程序包含 <code>main()</code> 函数，你可以将它编译成 WASM 字节码，然后像运行一个独立应用程序一样使用 <code>wasmedge</code> 命令行工具来运行它。然而，更常见的使用场景是将一个 Rust 函数编译成 WASM 字节码，然后在其他宿主程序中调用它。这被称为嵌入的 WASM 函数。宿主应用程序使用 WasmEdge 语言 SDK （比如，<a href="dev/rust/../../embed/go.html">Go</a>、 <a href="dev/rust/../../embed/rust.html">Rust</a>、 <a href="dev/rust/../../embed/c.html">C</a>、 <a href="dev/rust/../../embed/go.html">Python</a> 以及 <a href="dev/rust/../../embed/node.html">Node.js</a>）来运行由 Rust 源代码编译而来的 WASM 函数。</p>
<p>所有的 WasmEdge 语言 SDK 都支持简单的函数调用。但是，WASM 规范只支持一些基础的数据类型作为参数和返回值。当 Rust 函数被编译成 WASM 时，<code>wasmedge-bindgen</code> 会把 Rust 函数的调用参数和返回值都转换为简单的整型。比如，字符串将被自动转换为两个整型，它的内存地址和它的长度，这些类型可以被标准的 WASM 规范接受。在 Rust 中这很容易完成，只需要给你的函数添加 <code>#[wasmedge-bindgen]</code> 宏就可以。你可以使用标准的 Rust 编译工具链（比如，最新的 <code>Cargo</code>）来编译添加宏之后的 Rust 代码。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use wasmedge_bindgen::*;
use wasmedge_bindgen_macro::*;

#[wasmedge_bindgen]
pub fn say(s: String) -&gt; Result&lt;Vec&lt;u8&gt;, String&gt; {
  let r = String::from(&quot;hello &quot;);
  return Ok((r + s.as_str()).as_bytes().to_vec());
}
<span class="boring">}
</span></code></pre></pre>
<p>当然，一旦上述 Rust 代码被编译为 WASM，<code>say()</code> 函数将不再接受 <code>String</code> 作为参数，也不会再返回 <code>Vec&lt;u8&gt;</code>。因此，调用者（也就是宿主应用程序）必须在调用前将调用参数解构为内存指针，并在调用之后使用内存指针组装返回值。这些操作可以由 WasmEdge 语言 SDK 自动完成。如果需要一个包含 Rust WASM 函数以及 Go 宿主程序的完整的示例，请参照我们在 Go SDK 文档中的教程。</p>
<p><strong><a href="dev/rust/../../embed/go/function.html">一个完整的 wasmedge-bindgen 示例，使用 Rust (WASM) 和 Go (宿主)</a></strong></p>
<p>当然，开发者可以选择自己实现 <code>wasmdege-bindgen</code> 的工作，直接传递内存指针。如果你对使用这种方式来调用 Rust 编译成的 WASM 函数感兴趣，请参照我们在 <a href="dev/rust/../../embed/go/memory.html">Go SDK 中的示例</a>。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="使用操作系统服务"><a class="header" href="#使用操作系统服务">使用操作系统服务</a></h1>
<p>WASI（WebAssembly 系统接口）标准被设计来让 WebAssembly 应用程序可以访问操作系统服务。
Rust 编译器中的 <code>wasm32-wasi</code> 目标支持 WASI。
在这一部分中，我们将使用<a href="https://github.com/second-state/wasm-learning/tree/master/cli/wasi">一个示例工程</a>来展示如何使用 Rust 的标准库来访问操作系统服务。</p>
<h2 id="随机数"><a class="header" href="#随机数">随机数</a></h2>
<p>WebAssembly 虚拟机是一个纯软件实现，它不具有生成随机数必须的硬件资源。这就是 WASI 为 WebAssembly 定义了一个从宿主操作系统获取一个随机种子的函数的原因。作为一个 Rust 开发者，你需要做的只是使用受欢迎的 <code>rand</code> 或者 <code>getrandom</code> 包。得益于 <code>wasm32-wasi</code> 编译器后端，这些包将在 WebAssembly 字节码中生成正确的 WASI 调用。如下是 <code>Cargo.toml</code> 中的依赖部分。</p>
<pre><code class="language-toml">[dependencies]
rand = &quot;0.7.3&quot;
getrandom = &quot;0.1.14&quot;
</code></pre>
<p>如下是在 WebAssembly 生成随机数的 Rust 代码。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use rand::prelude::*;

pub fn get_random_i32() -&gt; i32 {
  let x: i32 = random();
  return x;
}

pub fn get_random_bytes() -&gt; Vec&lt;u8&gt; {
  let mut rng = thread_rng();
  let mut arr = [0u8; 128];
  rng.fill(&amp;mut arr[..]);
  return arr.to_vec();
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="从-rust-中输出和调试"><a class="header" href="#从-rust-中输出和调试">从 Rust 中输出和调试</a></h2>
<p>Rust 中的 <code>println!</code> 宏同样可以用在 WASI 中。下面的语句向运行 WasmEdge 的进程的 <code>STDOUT</code> 输出。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn echo(content: &amp;str) -&gt; String {
  println!(&quot;Printed from wasi: {}&quot;, content);
  return content.to_string();
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="参数以及环境变量"><a class="header" href="#参数以及环境变量">参数以及环境变量</a></h2>
<p>在 WasmEdge 应用程序中，你可以传递命令行参数并且获取操作系统环境变量。
在 Rust 中你可以使用 <code>env::args()</code> 和 <code>env::vars()</code> 访问他们。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::env;

pub fn print_env() {
  println!(&quot;The env vars are as follows.&quot;);
  for (key, value) in env::vars() {
    println!(&quot;{}: {}&quot;, key, value);
  }

  println!(&quot;The args are as follows.&quot;);
  for argument in env::args() {
    println!(&quot;{}&quot;, argument);
  }
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="读写文件"><a class="header" href="#读写文件">读写文件</a></h2>
<p>WASI 让你可以通过标准的 Rust <code>std::fs</code> 接口来访问宿主的文件系统。
在 Rust 程序中，你通过相对路径来操作文件，相对路径的根目录可以在启动 WasmEdge Runtime 的时候被指定。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fs;
use std::fs::File;
use std::io::{Write, Read};

pub fn create_file(path: &amp;str, content: &amp;str) {
  let mut output = File::create(path).unwrap();
  output.write_all(content.as_bytes()).unwrap();
}

pub fn read_file(path: &amp;str) -&gt; String {
  let mut f = File::open(path).unwrap();
  let mut s = String::new();
  match f.read_to_string(&amp;mut s) {
    Ok(_) =&gt; s,
    Err(e) =&gt; e.to_string(),
  }
}

pub fn del_file(path: &amp;str) {
  fs::remove_file(path).expect(&quot;Unable to delete&quot;);
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="包含-main-的应用程序"><a class="header" href="#包含-main-的应用程序">包含 main() 的应用程序</a></h2>
<p>包含 <code>main()</code> 函数的 Rust 程序可以被编译为一个独立的 WebAssembly 程序。</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
  println!(&quot;Random number: {}&quot;, get_random_i32());
  println!(&quot;Random bytes: {:?}&quot;, get_random_bytes());
  println!(&quot;{}&quot;, echo(&quot;This is from a main function&quot;));
  print_env();
  create_file(&quot;tmp.txt&quot;, &quot;This is in a file&quot;);
  println!(&quot;File content is {}&quot;, read_file(&quot;tmp.txt&quot;));
  del_file(&quot;tmp.txt&quot;);
}
</code></pre></pre>
<p>使用如下的命令来编译 <a href="https://github.com/second-state/wasm-learning/tree/master/cli/wasi">Rust 工程</a>。</p>
<pre><code class="language-bash">cargo build --target wasm32-wasi
</code></pre>
<p>使用如下命令在 <code>wasmedge</code> 中运行它。<code>--dir</code> 选项将命令行当前的目录映射为 ＷebAssembly 程序中文件系统的当前目录。</p>
<pre><code class="language-bash">$ wasmedge --dir .:. target/wasm32-wasi/debug/wasi.wasm hello
Random number: -68634548
Random bytes: [87, 117, 194, 122, 74, 189, 29, 1, 113, 26, 90, 6, 151, 20, 11, 169, 131, 212, 161, 220, 216, 190, 77, 234, 30, 10, 159, 7, 14, 89, 81, 111, 247, 136, 39, 195, 83, 90, 153, 225, 66, 16, 150, 217, 137, 172, 216, 203, 251, 37, 4, 27, 32, 57, 76, 237, 99, 147, 24, 175, 208, 157, 3, 220, 46, 224, 199, 153, 144, 96, 120, 89, 160, 38, 171, 239, 87, 218, 41, 184, 220, 78, 157, 57, 229, 198, 222, 72, 219, 118, 237, 27, 229, 28, 51, 116, 88, 101, 40, 139, 160, 51, 156, 102, 66, 233, 101, 50, 131, 9, 253, 186, 73, 148, 85, 36, 155, 254, 168, 202, 23, 96, 181, 99, 120, 136, 28, 147]
This is from a main function
The env vars are as follows.
... ...
The args are as follows.
target/wasm32-wasi/debug/wasi.wasm
hello
File content is This is in a file
</code></pre>
<h2 id="函数"><a class="header" href="#函数">函数</a></h2>
<p>正如<a href="dev/rust/../rust.html#%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E5%87%BD%E6%95%B0">我们之前看到的</a>，你可以在 Rust <code>lib.rs</code> 中创建 WebAssembly 函数。在这些函数中，你同样可以使用 WASI 函数。然而，需要注意的是，没有 <code>main()</code> 函数的情况下，你将会需要显式地调用一个辅助函数来初始化环境，以此让 WASI 函数正常工作。
在 Cargo.toml 中添加一个辅助包，这样的话 WASI 初始化代码将会应用在你导出的的公开库函数上。</p>
<pre><code class="language-toml">[dependencies]
... ...
wasmedge-wasi-helper = &quot;=0.2.0&quot;
</code></pre>
<p>在访问任何参数和环境变量或者操作任何文件之前，我们需要调用 _initialize() 函数。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn print_env() -&gt; i32 {
  _initialize();
  ... ...
}

pub fn create_file(path: &amp;str, content: &amp;str) -&gt; String {
  _initialize();
  ... ...
}

pub fn read_file(path: &amp;str) -&gt; String {
  _initialize();
  ... ...
}

pub fn del_file(path: &amp;str) -&gt; String {
  _initialize();
  ... ...
}
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tensorflow"><a class="header" href="#tensorflow">Tensorflow</a></h1>
<p>AI 推理是一个计算密集任务，可以从 Rust 和 WebAssembly 的速度中受益颇多。然而，标准的 WebAssembly 沙箱只提供了对原生操作系统和硬件非常有限的访问权限，比如多核 CPU、GPU 和专用的 AI 推理芯片。对 AI 的负载来说，它也不理想。</p>
<p>WebAssembly 系统接口（WASI）提供了一种设计模式，可以让沙箱中的 WebAssembly 程序安全地访问原生宿主函数。WasmEdge Runtime 拓展了 WASI 的模型，支持在 WebAssembly 程序中直接访问原生 Tensorflow 的库。<a href="https://github.com/second-state/wasmedge_tensorflow_interface">WasmEdge Tensorflow Rust SDK</a> 提供了安全、便携、易用的方式，以本地速度来运行 Tensorflow。</p>
<blockquote>
<p>如果你对 Rust 不熟悉，可以尝试我们的<a href="https://github.com/second-state/wasm-learning/tree/master/cli/classify_yml">实验性的 DSL AI 推理示例</a>和 <a href="dev/rust/../js/tensorflow.html">JavaScript 示例</a>。</p>
</blockquote>
<h2 id="目录"><a class="header" href="#目录">目录</a></h2>
<ul>
<li><a href="dev/rust/tensorflow.html#a-rust-example">一个 Rust 示例</a></li>
<li><a href="dev/rust/tensorflow.html#deployment-options">部署选项</a></li>
</ul>
<h2 id="一个-rust-示例"><a class="header" href="#一个-rust-示例">一个 Rust 示例</a></h2>
<h3 id="前置条件-1"><a class="header" href="#前置条件-1">前置条件</a></h3>
<p>你需要安装 <a href="dev/rust/../../start/install.html">WasmEdge</a> 和 <a href="https://www.rust-lang.org/tools/install">Rust</a>.</p>
<h3 id="构建"><a class="header" href="#构建">构建</a></h3>
<p>克隆示例代码.</p>
<pre><code class="language-bash">git clone https://github.com/second-state/wasm-learning/
cd cli/tflite
</code></pre>
<p>使用 Rust <code>Cargo</code> 来构建 WebAssembly 目标。</p>
<pre><code class="language-bash">rustup target add wasm32-wasi
cargo build --target wasm32-wasi --release
</code></pre>
<h3 id="运行"><a class="header" href="#运行">运行</a></h3>
<p><code>wasmedge-tensorflow-lite</code> 工具是 WasmEdge 构建的，包含 Tensorflow 和 Tensorflow Lite 拓展。</p>
<pre><code class="language-bash">$ wasmedge-tensorflow-lite target/wasm32-wasi/release/classify.wasm &lt; grace_hopper.jpg
It is very likely a &lt;a href='https://www.google.com/search?q=military uniform'&gt;military uniform&lt;/a&gt; in the picture
</code></pre>
<h3 id="让它运行得更快"><a class="header" href="#让它运行得更快">让它运行得更快</a></h3>
<p>为了让 Tensorflow 推理可以运行得<em>更快</em>，你可以将它预先编译（AOT）为原生机器码，然后使用 WasmEdge 沙箱来运行原生代码。</p>
<pre><code class="language-bash">$ wasmedgec target/wasm32-wasi/release/classify.wasm classify.wasm
$ wasmedge-tensorflow-lite classify.wasm &lt; grace_hopper.jpg
It is very likely a &lt;a href='https://www.google.com/search?q=military uniform'&gt;military uniform&lt;/a&gt; in the picture
</code></pre>
<h3 id="浏览代码"><a class="header" href="#浏览代码">浏览代码</a></h3>
<p>使用 WasmEdge Tensorflow API 是很直观的。你可以在 <a href="https://github.com/second-state/wasm-learning/blob/master/cli/tflite/src/main.rs"><code>main.rs</code></a> 中阅读完整的源代码。</p>
<p>首先，它加载了在 ImageNet 上训练好的 TFLite 模型文件，以及对应的标签文件。标签文件中存储了模型输出的数值与待分类对象的英文名字的映射。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>  let model_data: &amp;[u8] = include_bytes!(&quot;models/mobilenet_v1_1.0_224/mobilenet_v1_1.0_224_quant.tflite&quot;);
  let labels = include_str!(&quot;models/mobilenet_v1_1.0_224/labels_mobilenet_quant_v1_224.txt&quot;);
<span class="boring">}
</span></code></pre></pre>
<p>接下来，它从 <code>STDIN</code> 加载图像，并将其转换为 Tensorflow Lite 模型所要求的格式。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>  let mut buf = Vec::new();
  io::stdin().read_to_end(&amp;mut buf).unwrap();

  let flat_img = wasmedge_tensorflow_interface::load_jpg_image_to_rgb8(&amp;buf, 224, 224);
<span class="boring">}
</span></code></pre></pre>
<p>然后，程序运行了 TFLite 模型，输入模型所需的张量（这里指图像），接收模型的输出（这里指一个包含了数字的数组）。每一个数字都对应了标签文件中的一个对象的概率。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>  let mut session = wasmedge_tensorflow_interface::Session::new(&amp;model_data, wasmedge_tensorflow_interface::ModelType::TensorFlowLite);
  session.add_input(&quot;input&quot;, &amp;flat_img, &amp;[1, 224, 224, 3])
         .run();
  let res_vec: Vec&lt;u8&gt; = session.get_output(&quot;MobilenetV1/Predictions/Reshape_1&quot;);
<span class="boring">}
</span></code></pre></pre>
<p>让我们找到有最大概率的对象，然后在标签文件中查找它的名字。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>  let mut i = 0;
  let mut max_index: i32 = -1;
  let mut max_value: u8 = 0;
  while i &lt; res_vec.len() {
    let cur = res_vec[i];
    if cur &gt; max_value {
      max_value = cur;
      max_index = i as i32;
    }
    i += 1;
  }

  let mut label_lines = labels.lines();
  for _i in 0..max_index {
    label_lines.next();
  }
<span class="boring">}
</span></code></pre></pre>
<p>最终，它向 <code>STDOUT</code> 输出了结果。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>  let class_name = label_lines.next().unwrap().to_string();
  if max_value &gt; 50 {
    println!(&quot;It {} a &lt;a href='https://www.google.com/search?q={}'&gt;{}&lt;/a&gt; in the picture&quot;, confidence.to_string(), class_name, class_name);
  } else {
    println!(&quot;It does not appears to be any food item in the picture.&quot;);
  }
<span class="boring">}
</span></code></pre></pre>
<h2 id="部署选项"><a class="header" href="#部署选项">部署选项</a></h2>
<p>以下的所有教程都使用了 <a href="https://github.com/second-state/wasmedge_tensorflow_interface">Tensorflow 的 WasmEdge Rust API</a> 来创建 AI 推理函数。这些 Rust 函数被编译成 WebAssembly 然后随着 WasmEdge 一起被部署在云上。</p>
<h3 id="serverless-函数"><a class="header" href="#serverless-函数">Serverless 函数</a></h3>
<p>以下的教程展示了如何在公有云的 Serverless 平台上部署使用 Rust 编写的 WebAssembly 程序。WasmEdge Runtime 在这些平台上的 Docker 容器中运行。每一个 Serverless 平台都提供了让 WasmEdge Runtime 通过 <code>STDIN</code> 和 <code>STDOUT</code> 获取并输出数据的接口。</p>
<ul>
<li><a href="https://www.secondstate.io/articles/vercel-wasmedge-webassembly-rust/">Vercel Serverless 函数</a></li>
<li><a href="https://www.secondstate.io/articles/netlify-wasmedge-webassembly-rust-serverless/">Netlify 函数</a></li>
<li><a href="https://github.com/second-state/aws-lambda-wasm-runtime">AWS Lambda</a></li>
<li><a href="https://github.com/second-state/tencent-scf-wasm-runtime">腾讯 Serverless 函数</a> (中文)</li>
</ul>
<h3 id="second-sate-faas-和-nodejs"><a class="header" href="#second-sate-faas-和-nodejs">Second Sate FaaS 和 Node.js</a></h3>
<p>以下的教程展示了如何在 Second State FaaS 平台上部署使用 Rust 编写的 WebAssembly 程序。由于 FaaS 服务在 Node.js 上运行，你可以按照这些教程在你自己的 Node.js 服务器上运行这些函数。</p>
<ul>
<li><a href="https://www.secondstate.io/articles/faas-image-classification/">Tensorflow：使用 MobileNet 来进行图像分类</a> | <a href="https://second-state.github.io/wasm-learning/faas/mobilenet/html/index.html">在线演示</a></li>
<li><a href="https://www.secondstate.io/articles/faas-face-detection/">Tensorflow：使用 MTCNN 模型来进行人脸识别</a> | <a href="https://second-state.github.io/wasm-learning/faas/mtcnn/html/index.html">在线演示</a></li>
</ul>
<h3 id="服务网格"><a class="header" href="#服务网格">服务网格</a></h3>
<p>以下的教程展示了如何将使用 Rust 编写的 WebAssembly 函数和程序部署为 sidecar 微服务。</p>
<ul>
<li><a href="https://github.com/second-state/dapr-wasm">Dapr 模板</a>展示了如何使用 Go 和 Rust 来构建、部署 Dapr  sidecar 应用。然后这些 sidecar 应用使用 WasmEdge SDK 来启动处理微服务负载的 WebAssembly 程序。</li>
</ul>
<h3 id="数据流框架"><a class="header" href="#数据流框架">数据流框架</a></h3>
<p>以下的教程展示了如何将使用 Rust 编写的 WebAssembly 函数和程序部署为嵌入在为 AIoT 建立的数据流框架中的处理函数。</p>
<ul>
<li><a href="https://www.secondstate.io/articles/yomo-wasmedge-real-time-data-streams/">YoMo 模板</a>启动了 WasmEdge Runtime 来处理来自一个智能工厂的摄像头数据流中的图像数据。</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="简单网络通信"><a class="header" href="#简单网络通信">简单网络通信</a></h1>
<p><a href="https://github.com/second-state/wasmedge_wasi_socket">wasmedge_wasi_socket</a> 让 Rust 开发者可以创建简单的网络通信应用程序，然后将它编译为在 WasmEdge Runtime 中运行的 WebAssembly。WasmEdge 的一项关键特性便是对非阻塞套接字的支持，可以让一个单线程的 WASM 应用程序处理并发的网络请求。比如，当程序在等待一个连接传输的数据时，它可以开始或处理另一个连接。</p>
<p>在本章节中，我们将从一个简单的 HTTP 客户端以及服务器示例开始。然后在下个章节中，我们会介绍更为复杂的非阻塞示例。也会介绍对于 HTTPS 请求的支持。</p>
<h2 id="http-客户端示例"><a class="header" href="#http-客户端示例">HTTP 客户端示例</a></h2>
<p>HTTP 客户端的<a href="https://github.com/second-state/wasmedge_wasi_socket/tree/main/examples/http_client">源代码</a> 如下。</p>
<pre><pre class="playground"><code class="language-rust">use wasmedge_http_req::request;

fn main() {
  let mut writer = Vec::new(); //container for body of a response
  let res = request::get(&quot;http://127.0.0.1:1234/get&quot;, &amp;mut writer).unwrap();

  println!(&quot;GET&quot;);
  println!(&quot;Status: {} {}&quot;, res.status_code(), res.reason());
  println!(&quot;Headers {}&quot;, res.headers());
  println!(&quot;{}&quot;, String::from_utf8_lossy(&amp;writer));

  let mut writer = Vec::new(); //container for body of a response
  const BODY: &amp;[u8; 27] = b&quot;field1=value1&amp;field2=value2&quot;;
  // let res = request::post(&quot;https://httpbin.org/post&quot;, BODY, &amp;mut writer).unwrap();
  // no https , no dns
  let res = request::post(&quot;http://127.0.0.1:1234/post&quot;, BODY, &amp;mut writer).unwrap();

  println!(&quot;POST&quot;);
  println!(&quot;Status: {} {}&quot;, res.status_code(), res.reason());
  println!(&quot;Headers {}&quot;, res.headers());
  println!(&quot;{}&quot;, String::from_utf8_lossy(&amp;writer));
}
</code></pre></pre>
<p>使用如下命令来编译 Rust 程序。</p>
<pre><code class="language-bash">cargo build --target wasm32-wasi --release
</code></pre>
<p>使用如下命令在 WasmEdge 中运行程序。</p>
<pre><code class="language-bash">wasmedge target/wasm32-wasi/release/http_client.wasm
</code></pre>
<h2 id="http-服务器示例"><a class="header" href="#http-服务器示例">HTTP 服务器示例</a></h2>
<p>HTTP 服务器的<a href="https://github.com/second-state/wasmedge_wasi_socket/tree/main/examples/http_server">源代码</a> 如下。</p>
<pre><pre class="playground"><code class="language-rust">use bytecodec::DecodeExt;
use httpcodec::{HttpVersion, ReasonPhrase, Request, RequestDecoder, Response, StatusCode};
use std::io::{Read, Write};
#[cfg(feature = &quot;std&quot;)]
use std::net::{Shutdown, TcpListener, TcpStream};
#[cfg(not(feature = &quot;std&quot;))]
use wasmedge_wasi_socket::{Shutdown, TcpListener, TcpStream};

fn handle_http(req: Request&lt;String&gt;) -&gt; bytecodec::Result&lt;Response&lt;String&gt;&gt; {
  Ok(Response::new(
    HttpVersion::V1_0,
    StatusCode::new(200)?,
    ReasonPhrase::new(&quot;&quot;)?,
    format!(&quot;echo: {}&quot;, req.body()),
  ))
}

fn handle_client(mut stream: TcpStream) -&gt; std::io::Result&lt;()&gt; {
  let mut buff = [0u8; 1024];
  let mut data = Vec::new();

  loop {
    let n = stream.read(&amp;mut buff)?;
    data.extend_from_slice(&amp;buff[0..n]);
    if n &lt; 1024 {
      break;
    }
  }

  let mut decoder =
    RequestDecoder::&lt;httpcodec::BodyDecoder&lt;bytecodec::bytes::Utf8Decoder&gt;&gt;::default();

  let req = match decoder.decode_from_bytes(data.as_slice()) {
    Ok(req) =&gt; handle_http(req),
    Err(e) =&gt; Err(e),
  };

  let r = match req {
    Ok(r) =&gt; r,
    Err(e) =&gt; {
      let err = format!(&quot;{:?}&quot;, e);
      Response::new(
        HttpVersion::V1_0,
        StatusCode::new(500).unwrap(),
        ReasonPhrase::new(err.as_str()).unwrap(),
        err.clone(),
      )
    }
  };

  let write_buf = r.to_string();
  stream.write(write_buf.as_bytes())?;
  stream.shutdown(Shutdown::Both)?;
  Ok(())
}

fn main() -&gt; std::io::Result&lt;()&gt; {
  let port = std::env::var(&quot;PORT&quot;).unwrap_or(1234.to_string());
  println!(&quot;new connection at {}&quot;, port);
  let listener = TcpListener::bind(format!(&quot;0.0.0.0:{}&quot;, port))?;
  loop {
    let _ = handle_client(listener.accept()?.0);
  }
}
</code></pre></pre>
<p>使用如下命令来编译 Rust 程序。</p>
<pre><code class="language-bash">cargo build --target wasm32-wasi --release
</code></pre>
<p>使用如下命令在 WasmEdge 中运行程序。</p>
<pre><code class="language-bash">$ wasmedge target/wasm32-wasi/release/http_server.wasm
new connection at 1234
</code></pre>
<p>你可以用 <code>curl</code> 发送一个 HTTP 请求，来测试 HTTP 服务器。</p>
<pre><code class="language-bash">$ curl -d &quot;name=WasmEdge&quot; -X POST http://127.0.0.1:1234
echo: name=WasmEdge
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="非阻塞的网络通信"><a class="header" href="#非阻塞的网络通信">非阻塞的网络通信</a></h1>
<p>尽管上一章节中的 HTTP 连接实现起来很容易，但他们并不适合在生产环境使用。如果程序一次只允许一个连接开启（阻塞），CPU 将不得不等待缓慢的网络。非阻塞 I/O 意味着程序可以同时保持多个连接开启，并处理这些连接传输的数据。程序可以轮询这些开启的连接，或是等待输入的数据触发异步函数。这将让 I/O 密集的程序在单线程环境中运行得非常快。在这一章中，我们将介绍轮询和异步编程模型。</p>
<h2 id="非阻塞-http-客户端示例"><a class="header" href="#非阻塞-http-客户端示例">非阻塞 HTTP 客户端示例</a></h2>
<p>非阻塞的 HTTP 客户端程序的<a href="https://github.com/second-state/wasmedge_wasi_socket/tree/main/examples/nonblock_http_client">源代码在这里</a>。下面的 <code>main()</code> 函数开启了两个 HTTP 连接。它同时保持两个连接开启，并轮流查看是否有数据传输进来。换句话说，这两个连接并不会相互阻塞。他们的数据在传输进来的时候被同时（或者轮流）处理。</p>
<pre><pre class="playground"><code class="language-rust">use httparse::{Response, EMPTY_HEADER};
use std::io::{self, Read, Write};
use std::str::from_utf8;
use wasmedge_wasi_socket::TcpStream;

fn main() {
    let req = &quot;GET / HTTP/1.0\n\n&quot;;
    let mut first_connection = TcpStream::connect(&quot;127.0.0.1:80&quot;).unwrap();
    first_connection.set_nonblocking(true).unwrap();
    first_connection.write_all(req.as_bytes()).unwrap();

    let mut second_connection = TcpStream::connect(&quot;127.0.0.1:80&quot;).unwrap();
    second_connection.set_nonblocking(true).unwrap();
    second_connection.write_all(req.as_bytes()).unwrap();

    let mut first_buf = vec![0; 4096];
    let mut first_bytes_read = 0;
    let mut second_buf = vec![0; 4096];
    let mut second_bytes_read = 0;

    loop {
        let mut first_complete = false;
        let mut second_complete = false;
        if !first_complete {
            match read_data(&amp;mut first_connection, &amp;mut first_buf, first_bytes_read) {
                Ok((bytes_read, false)) =&gt; {
                    first_bytes_read = bytes_read;
                }
                Ok((bytes_read, true)) =&gt; {
                    println!(&quot;First connection completed&quot;);
                    if bytes_read != 0 {
                        parse_data(&amp;first_buf, bytes_read);
                    }
                    first_complete = true;
                }
                Err(e) =&gt; {
                    println!(&quot;First connection error: {}&quot;, e);
                    first_complete = true;
                }
            }
        }
        if !second_complete {
            match read_data(&amp;mut second_connection, &amp;mut second_buf, second_bytes_read) {
                Ok((bytes_read, false)) =&gt; {
                    second_bytes_read = bytes_read;
                }
                Ok((bytes_read, true)) =&gt; {
                    println!(&quot;Second connection completed&quot;);
                    if bytes_read != 0 {
                        parse_data(&amp;second_buf, bytes_read);
                    }
                    second_complete = true;
                }
                Err(e) =&gt; {
                    println!(&quot;Second connection error: {}&quot;, e);
                    second_complete = true;
                }
            }
        }
        if first_complete &amp;&amp; second_complete {
            break;
        }
    }
}
</code></pre></pre>
<p>使用如下命令来编译 Rust 程序。</p>
<pre><code class="language-bash">cargo build --target wasm32-wasi --release
</code></pre>
<p>使用如下命令在 WasmEdge 中运行程序。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>wasmedge target/wasm32-wasi/release/nonblock_http_client.wasm
<span class="boring">}
</span></code></pre></pre>
<h2 id="非阻塞-http-服务器示例"><a class="header" href="#非阻塞-http-服务器示例">非阻塞 HTTP 服务器示例</a></h2>
<p>非阻塞的 HTTP 服务器程序的 <a href="https://github.com/second-state/wasmedge_wasi_socket/tree/main/examples/poll_http_server">源代码在这里</a>。下面的 <code>main()</code> 函数开启了一个 HTTP 服务器。它同时从多个开启的连接中接收事件，并通过调用注册在每个连接的异步处理函数来处理这些事件。服务器可以同时从多个开启的连接中处理事件。</p>
<pre><pre class="playground"><code class="language-rust">fn main() -&gt; std::io::Result&lt;()&gt; {
    let mut poll = Poll::new();
    let server = TcpListener::bind(&quot;127.0.0.1:1234&quot;, true)?;
    println!(&quot;Listening on 127.0.0.1:1234&quot;);
    let mut connections = HashMap::new();
    let mut handlers = HashMap::new();
    const SERVER: Token = Token(0);
    let mut unique_token = Token(SERVER.0 + 1);

    poll.register(&amp;server, SERVER, Interest::Read);

    loop {
        let events = poll.poll().unwrap();

        for event in events {
            match event.token {
                SERVER =&gt; loop {
                    let (connection, address) = match server.accept(FDFLAGS_NONBLOCK) {
                        Ok((connection, address)) =&gt; (connection, address),
                        Err(ref e) if e.kind() == std::io::ErrorKind::WouldBlock =&gt; break,
                        Err(e) =&gt; panic!(&quot;accept error: {}&quot;, e),
                    };

                    println!(&quot;Accepted connection from: {}&quot;, address);

                    let token = unique_token.add();
                    poll.register(&amp;connection, token, Interest::Read);
                    connections.insert(token, connection);
                },
                token =&gt; {
                    let done = if let Some(connection) = connections.get_mut(&amp;token) {
                        let handler = match handlers.get_mut(&amp;token) {
                            Some(handler) =&gt; handler,
                            None =&gt; {
                                let handler = Handler::new();
                                handlers.insert(token, handler);
                                handlers.get_mut(&amp;token).unwrap()
                            }
                        };
                        handle_connection(&amp;mut poll, connection, handler, &amp;event)?
                    } else {
                        false
                    };
                    if done {
                        if let Some(connection) = connections.remove(&amp;token) {
                            connection.shutdown(Shutdown::Both)?;
                            poll.unregister(&amp;connection);
                            handlers.remove(&amp;token);
                        }
                    }
                }
            }
        }
    }
}
</code></pre></pre>
<p><code>handle_connection()</code> 函数处理来自于开启的连接的数据。当前它只是将请求的内容写回响应中。这同样是以异步的形式完成的，意味着 <code>handle_connection()</code> 函数为响应创建了一个事件，然后将事件放入了一个队列中。主程序循环处理这些事件，并在等待来自其他连接的数据时发送这些响应。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn handle_connection(
    poll: &amp;mut Poll,
    connection: &amp;mut TcpStream,
    handler: &amp;mut Handler,
    event: &amp;Event,
) -&gt; io::Result&lt;bool&gt; {
    if event.is_readable() {
        let mut connection_closed = false;
        let mut received_data = vec![0; 4096];
        let mut bytes_read = 0;
        loop {
            match connection.read(&amp;mut received_data[bytes_read..]) {
                Ok(0) =&gt; {
                    connection_closed = true;
                    break;
                }
                Ok(n) =&gt; {
                    bytes_read += n;
                    if bytes_read == received_data.len() {
                        received_data.resize(received_data.len() + 1024, 0);
                    }
                }
                Err(ref err) if would_block(err) =&gt; {
                    if bytes_read != 0 {
                        let received_data = &amp;received_data[..bytes_read];
                        let mut bs: parsed::stream::ByteStream =
                            match String::from_utf8(received_data.to_vec()) {
                                Ok(s) =&gt; s,
                                Err(_) =&gt; {
                                    continue;
                                }
                            }
                            .into();
                        let req = match parsed::http::parse_http_request(&amp;mut bs) {
                            Some(req) =&gt; req,
                            None =&gt; {
                                break;
                            }
                        };
                        for header in req.headers.iter() {
                            if header.name.eq(&quot;Conntent-Length&quot;) {
                                let content_length = header.value.parse::&lt;usize&gt;().unwrap();
                                if content_length &gt; received_data.len() {
                                    return Ok(true);
                                }
                            }
                        }
                        println!(
                            &quot;{:?} request: {:?} {:?}&quot;,
                            connection.peer_addr().unwrap(),
                            req.method,
                            req.path
                        );
                        let res = Response {
                            protocol: &quot;HTTP/1.1&quot;.to_string(),
                            code: 200,
                            message: &quot;OK&quot;.to_string(),
                            headers: vec![
                                Header {
                                    name: &quot;Content-Length&quot;.to_string(),
                                    value: req.content.len().to_string(),
                                },
                                Header {
                                    name: &quot;Connection&quot;.to_string(),
                                    value: &quot;close&quot;.to_string(),
                                },
                            ],
                            content: req.content,
                        };

                        handler.response = Some(res.into());

                        poll.reregister(connection, event.token, Interest::Write);
                        break;
                    } else {
                        println!(&quot;Empty request&quot;);
                        return Ok(true);
                    }
                }
                Err(ref err) if interrupted(err) =&gt; continue,
                Err(err) =&gt; return Err(err),
            }
        }

        if connection_closed {
            println!(&quot;Connection closed&quot;);
            return Ok(true);
        }
    }

    if event.is_writable() &amp;&amp; handler.response.is_some() {
        let resp = handler.response.clone().unwrap();
        match connection.write(resp.as_bytes()) {
            Ok(n) if n &lt; resp.len() =&gt; return Err(io::ErrorKind::WriteZero.into()),
            Ok(_) =&gt; {
                return Ok(true);
            }
            Err(ref err) if would_block(err) =&gt; {}
            Err(ref err) if interrupted(err) =&gt; {
                return handle_connection(poll, connection, handler, event)
            }
            Err(err) =&gt; return Err(err),
        }
    }

    Ok(false)
}
<span class="boring">}
</span></code></pre></pre>
<p>使用如下命令来编译 Rust 程序。</p>
<pre><code class="language-bash">cargo build --target wasm32-wasi --release
</code></pre>
<p>使用如下命令在 WasmEdge 中运行程序。</p>
<pre><code class="language-bash">$ wasmedge target/wasm32-wasi/release/poll_http_server.wasm
new connection at 1234
</code></pre>
<p>你可以用 <code>curl</code> 发送一个 HTTP 请求，来测试 HTTP 服务器。</p>
<pre><code class="language-bash">$ curl -d &quot;name=WasmEdge&quot; -X POST http://127.0.0.1:1234
echo: name=WasmEdge
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="服务器端渲染"><a class="header" href="#服务器端渲染">服务器端渲染</a></h1>
<p>前端框架让开发者可以使用高级语言和组件模型来创建 Web 应用程序。Web 应用程序需要被构建成静态网页，才能在浏览器中渲染。尽管很多前端框架是基于 JavaScript 的，比如 React 和 Vue，但是随着 Rust 吸引了更多的开发者，基于 Rust 的框架也在不断涌现。这些前端框架使用由 Rust 编译而成的 WebAssembly 来渲染 HTML DOM UI。他们使用 <a href="https://github.com/rustwasm/wasm-bindgen">wasm-bindgen</a> 来绑定 Rust 与 HTML DOM。这些框架都把 <code>.wasm</code> 文件发送到浏览器，在客户端渲染 UI，但其中的一些框架提供了对<a href="https://en.wikipedia.org/wiki/Server-side_scripting">服务端渲染</a>的支持。这意味着我们在服务器上运行 WebAssembly 代码，并构建 HTML DOM UI，然后将 HTML 内容发送到浏览器，以此在较慢的设备和网络环境下获得更好的性能以及更快的启动速度。</p>
<blockquote>
<p>如果你对 JavaScript 技术栈以及服务端渲染框架感兴趣，比如 React，请查看我们关于 <a href="dev/rust/../js/ssr.html">JavaScript 服务端渲染的章节</a>。</p>
</blockquote>
<p>本文将探索如何在服务器上使用 WasmEdge 来渲染 Web UI。
我们选择使用 <a href="https://github.com/chinedufn/percy">Percy</a>，因为它在服务端渲染以及<a href="https://en.wikipedia.org/wiki/Hydration_(web_development)">混合开发</a>领域较为成熟。Percy 同样提供了一个服务端渲染的<a href="https://github.com/chinedufn/percy/tree/master/examples/isomorphic">示例</a>。我们强烈建议你先去阅读这个示例，弄清楚它是如何工作的。Percy 默认的服务端渲染设置使用了一个原生的 Rust Web 服务器。对于服务器来说，Rust 代码被编译为原生机器码。然后，为了在服务器上运行用户的应用程序，我们需要一个沙箱。尽管我们可以在一个 Linux 容器（Docker）中运行原生代码，一个更高效且更快的方法是使用服务器上的 WebAssembly 虚拟机来运行编译好的代码，尤其是考虑到我们渲染的代码已经被编译成了 WebAssembly。</p>
<p>现在，让我们看一下在一个 WasmEdge 服务器上运行一个 Percy 服务端渲染的服务的步骤。</p>
<p>假设我们在 <code>examples/isomorphic</code> 文件夹中，创建一个新的包，和已有的 <code>server</code> 在同一个文件夹中。</p>
<pre><code class="language-bash">cargo new server-wasmedge
</code></pre>
<p>当你把新的包加入到工作区时，你会收到一个警告，因此需要在 <code>[workspace]</code> 的 <code>members</code> 中插入下面这行。文件位于 <code>../../Cargo.toml</code>。</p>
<pre><code class="language-toml">&quot;examples/isomorphic/server-wasmedge&quot;
</code></pre>
<p>趁文件还开着，将这两行放在文件底部：</p>
<pre><code class="language-toml">[patch.crates-io]
wasm-bindgen = { git = &quot;https://github.com/KernelErr/wasm-bindgen.git&quot;, branch = &quot;wasi-compat&quot; }
</code></pre>
<blockquote>
<p>为什么我们需要一个 fork 的 <code>wasm-bindgen</code>？这是因为在浏览器中， <code>wasm-bindgen</code> 是将 Rust 和 HTML 连接起来必须的胶水。然而在服务器上，我们需要将 Rust 代码编译为针对 <code>wasm32-wasi</code> 目标的代码，这与 <code>wasm-bindgen</code> 是不兼容的。我们 fork 版本的 <code>wasm-bindgen</code> 有一些条件配置，可以为 <code>wasm32-wasi</code> 目标移除其生成的 .wasm 文件中的浏览器特定代码。</p>
</blockquote>
<p>然后使用如下内容覆盖我们刚创建包的 <code>Cargo.toml</code>。</p>
<pre><code class="language-toml">[package]
name = &quot;isomorphic-server-wasmedge&quot;
version = &quot;0.1.0&quot;
edition = &quot;2021&quot;

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]
wasmedge_wasi_socket = &quot;0&quot;
querystring = &quot;1.1.0&quot;
parsed = { version = &quot;0.3&quot;, features = [&quot;http&quot;] }
anyhow = &quot;1&quot;
serde = { version = &quot;1.0&quot;, features = [&quot;derive&quot;] }
isomorphic-app = { path = &quot;../app&quot; } 
</code></pre>
<p><code>wasmedge_wasi_socket</code> 包是 WasmEdge 的 Socket 接口。这个工程还在开发中。下一步将 <code>index.html</code> 文件复制到包的根目录。</p>
<pre><code class="language-bash">cp server/src/index.html server-wasmedge/src/
</code></pre>
<p>让我们用 Rust 代码在 WasmEdge 中创建一个 Web 服务！ <code>main.rs</code> 程序监听到来的请求，并通过流发送响应。</p>
<pre><pre class="playground"><code class="language-rust">use std::io::Write;
use wasmedge_wasi_socket::{Shutdown, TcpListener};

mod handler;
mod mime;
mod response;

fn main() {
    let server = TcpListener::bind(&quot;127.0.0.1:3000&quot;, false).unwrap();
    println!(&quot;Server listening on 127.0.0.1:3000&quot;);

    // Simple single thread HTTP server
    // For server with Pool support, see https://github.com/second-state/wasmedge_wasi_socket/tree/main/examples/poll_http_server
    loop {
        let (mut stream, addr) = server.accept(0).unwrap();
        println!(&quot;Accepted connection from {}&quot;, addr);
        match handler::handle_req(&amp;mut stream, addr) {
            Ok((res, binary)) =&gt; {
                let res: String = res.into();
                let bytes = res.as_bytes();
                stream.write_all(bytes).unwrap();
                if let Some(binary) = binary {
                    stream.write_all(&amp;binary).unwrap();
                }
            }
            Err(e) =&gt; {
                println!(&quot;Error: {:?}&quot;, e);
            }
        };
        stream.shutdown(Shutdown::Both).unwrap();
    }
}
</code></pre></pre>
<p><code>handler.rs</code> 中的代码解析收到的数据，并返回对应的响应。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use crate::response;
use anyhow::Result;
use parsed::http::Response;
use std::io::Read;
use wasmedge_wasi_socket::{SocketAddr, TcpStream};

pub fn handle_req(stream: &amp;mut TcpStream, addr: SocketAddr) -&gt; Result&lt;(Response, Option&lt;Vec&lt;u8&gt;&gt;)&gt; {
    let mut buf = [0u8; 1024];
    let mut received_data: Vec&lt;u8&gt; = Vec::new();

    loop {
        let n = stream.read(&amp;mut buf)?;
        received_data.extend_from_slice(&amp;buf[..n]);
        if n &lt; 1024 {
            break;
        }
    }

    let mut bs: parsed::stream::ByteStream = match String::from_utf8(received_data) {
        Ok(s) =&gt; s.into(),
        Err(_) =&gt; return Ok((response::bad_request(), None)),
    };

    let req = match parsed::http::parse_http_request(&amp;mut bs) {
        Some(req) =&gt; req,
        None =&gt; return Ok((response::bad_request(), None)),
    };

    println!(&quot;{:?} request: {:?} {:?}&quot;, addr, req.method, req.path);

    let mut path_split = req.path.split(&quot;?&quot;);
    let path = path_split.next().unwrap_or(&quot;/&quot;);
    let query_str = path_split.next().unwrap_or(&quot;&quot;);
    let query = querystring::querify(&amp;query_str);
    let mut init_count: Option&lt;u32&gt; = None;
    for (k, v) in query {
        if k.eq(&quot;init&quot;) {
            match v.parse::&lt;u32&gt;() {
                Ok(v) =&gt; init_count = Some(v),
                Err(_) =&gt; return Ok((response::bad_request(), None)),
            }
        }
    }

    let (res, binary) = if path.starts_with(&quot;/static&quot;) {
        response::file(&amp;path)
    } else {
        // render page
        response::ssr(&amp;path, init_count)
    }
    .unwrap_or_else(|_| response::internal_error());

    Ok((res, binary))
}
<span class="boring">}
</span></code></pre></pre>
<p><code>response.rs</code> 中的代码将静态资源和服务器渲染的内容打包成响应对象。
对后者来说，你可以看到服务端渲染发生于 <code>app.render().to_string()</code>，产生的字符串替换掉了 HTML 中的占位符。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use crate::mime::MimeType;
use anyhow::Result;
use parsed::http::{Header, Response};
use std::fs::{read};
use std::path::Path;
use isomorphic_app::App;

const HTML_PLACEHOLDER: &amp;str = &quot;#HTML_INSERTED_HERE_BY_SERVER#&quot;;
const STATE_PLACEHOLDER: &amp;str = &quot;#INITIAL_STATE_JSON#&quot;;

pub fn ssr(path: &amp;str, init: Option&lt;u32&gt;) -&gt; Result&lt;(Response, Option&lt;Vec&lt;u8&gt;&gt;)&gt; {
    let html = format!(&quot;{}&quot;, include_str!(&quot;./index.html&quot;));

    let app = App::new(init.unwrap_or(1001), path.to_string());
    let state = app.store.borrow();

    let html = html.replace(HTML_PLACEHOLDER, &amp;app.render().to_string());
    let html = html.replace(STATE_PLACEHOLDER, &amp;state.to_json());

    Ok((Response {
        protocol: &quot;HTTP/1.0&quot;.to_string(),
        code: 200,
        message: &quot;OK&quot;.to_string(),
        headers: vec![
            Header {
                name: &quot;content-type&quot;.to_string(),
                value: MimeType::from_ext(&quot;html&quot;).get(),
            },
            Header {
                name: &quot;content-length&quot;.to_string(),
                value: html.len().to_string(),
            },
        ],
        content: html.into_bytes(),
    }, None))
}

/// Get raw file content
pub fn file(path: &amp;str) -&gt; Result&lt;(Response, Option&lt;Vec&lt;u8&gt;&gt;)&gt; {
    let path = Path::new(&amp;path);
    if path.exists() {
        let content_type: MimeType = match path.extension() {
            Some(ext) =&gt; MimeType::from_ext(ext.to_str().get_or_insert(&quot;&quot;)),
            None =&gt; MimeType::from_ext(&quot;&quot;),
        };
        let content = read(path)?;

        Ok((Response {
            protocol: &quot;HTTP/1.0&quot;.to_string(),
            code: 200,
            message: &quot;OK&quot;.to_string(),
            headers: vec![
                Header {
                    name: &quot;content-type&quot;.to_string(),
                    value: content_type.get(),
                },
                Header {
                    name: &quot;content-length&quot;.to_string(),
                    value: content.len().to_string(),
                },
            ],
            content: vec![],
        }, Some(content)))
    } else {
        Ok((Response {
            protocol: &quot;HTTP/1.0&quot;.to_string(),
            code: 404,
            message: &quot;Not Found&quot;.to_string(),
            headers: vec![],
            content: vec![],
        }, None))
    }
}

/// Bad Request
pub fn bad_request() -&gt; Response {
    Response {
        protocol: &quot;HTTP/1.0&quot;.to_string(),
        code: 400,
        message: &quot;Bad Request&quot;.to_string(),
        headers: vec![],
        content: vec![],
    }
}

/// Internal Server Error
pub fn internal_error() -&gt; (Response, Option&lt;Vec&lt;u8&gt;&gt;) {
    (Response {
        protocol: &quot;HTTP/1.0&quot;.to_owned(),
        code: 500,
        message: &quot;Internal Server Error&quot;.to_owned(),
        headers: vec![],
        content: vec![],
    }, None)
}
<span class="boring">}
</span></code></pre></pre>
<p><code>mime.rs</code> 中的代码将资源文件的拓展名映射成 MIME 类型。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct MimeType {
    pub r#type: String,
}

impl MimeType {
    pub fn new(r#type: &amp;str) -&gt; Self {
        MimeType {
            r#type: r#type.to_string(),
        }
    }

    pub fn from_ext(ext: &amp;str) -&gt; Self {
        match ext {
            &quot;html&quot; =&gt; MimeType::new(&quot;text/html&quot;),
            &quot;css&quot; =&gt; MimeType::new(&quot;text/css&quot;),
            &quot;map&quot; =&gt; MimeType::new(&quot;application/json&quot;),
            &quot;js&quot; =&gt; MimeType::new(&quot;application/javascript&quot;),
            &quot;json&quot; =&gt; MimeType::new(&quot;application/json&quot;),
            &quot;svg&quot; =&gt; MimeType::new(&quot;image/svg+xml&quot;),
            &quot;wasm&quot; =&gt; MimeType::new(&quot;application/wasm&quot;),
            _ =&gt; MimeType::new(&quot;text/plain&quot;),
        }
    }

    pub fn get(self) -&gt; String {
        self.r#type
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>就这么多！ 现在让我们来构建并运行 Web 应用程序。如果你对原来的示例进行了测试，那你可能已经编译好了客户端的 WebAssembly。</p>
<pre><code class="language-bash">cd client
./build-wasm.sh
</code></pre>
<p>接下来，构建并运行服务器。</p>
<pre><code class="language-bash">cd ../server-wasmedge
cargo build --target wasm32-wasi
OUTPUT_CSS=&quot;$(pwd)/../client/build/app.css&quot; wasmedge --dir /static:../client/build ../../../target/wasm32-wasi/debug/isomorphic-server-wasmedge.wasm
</code></pre>
<p>访问 <code>http://127.0.0.1:3000</code> 你就会发现 Web 应用程序在正常工作。</p>
<p>并且，你可以将所有这些步骤放进一个脚本 <code>../start-wasmedge.sh</code> 里。</p>
<pre><code class="language-bash">#!/bin/bash

cd $(dirname $0)

cd ./client

./build-wasm.sh

cd ../server-wasmedge

OUTPUT_CSS=&quot;$(pwd)/../client/build/app.css&quot; cargo run -p isomorphic-server-wasmedge
</code></pre>
<p>然后将下面这些内容放入 <code>.cargo/config.toml</code> 中。</p>
<pre><code class="language-toml">[build]
target = &quot;wasm32-wasi&quot;

[target.wasm32-wasi]
runner = &quot;wasmedge --dir /static:../client/build&quot; 
</code></pre>
<p>在这之后，只需要运行一个命令 <code>./start-wasmedge.sh</code> 就可以执行所有任务，构建并运行我们的 Web 应用程序！</p>
<p>我们也 fork 了 Percy 仓库，为你创建了一个可以直接构建的<a href="https://github.com/second-state/percy/tree/master/examples/isomorphic/server-wasmedge">示例</a>。尽情享受编程的乐趣吧！</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="使用命令行程序"><a class="header" href="#使用命令行程序">使用命令行程序</a></h1>
<p>WASI 通过一个被称为“基于能力的安全”的细粒度安全模型让 WebAssembly 程序可以调用宿主操作系统的标准库函数。WebAssembly 虚拟机所有者可以在虚拟机启动的时候给 VM 赋予访问宿主系统资源的权限。程序默认不能访问任何没有被显式允许访问的资源，比如文件夹。</p>
<p>但为什么要将我们自己限制在标准库函数上呢？ 我们可以用同样的方法在 WebAssembly 中调用任何宿主函数。WasmEdge 提供了一个类似 WASI 的拓展，可以访问在宿主操作系统中的任何命令行程序。</p>
<p>这些命令行程序可以</p>
<ul>
<li>从命令行参数中获取输入，包括 <code>STDIN</code> 流。</li>
<li>通过 <code>STDOUT</code> 流来返回值和数据。</li>
</ul>
<p>开发者可以使用我们的 Rust 接口库来访问这个功能。确保你在 <code>Cargo.toml</code> 中添加了这个依赖项。</p>
<pre><code class="language-toml">[dependencies]
rust_process_interface_library = &quot;0.1.3&quot;
</code></pre>
<p>现在你可以在 Rust 应用程序中使用这个接口启动一个新的进程，来运行操作系统中的命令行程序，通过 <code>arg()</code> 方法或者 <code>STDIN</code> 传入参数，并通过 <code>STDOUT</code> 接收返回值。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut cmd = Command::new(&quot;http_proxy&quot;);

cmd.arg(&quot;post&quot;)
   .arg(&quot;https://api.sendgrid.com/v3/mail/send&quot;)
   .arg(auth_header);  
cmd.stdin_u8vec(payload.to_string().as_bytes());

let out = cmd.output();
<span class="boring">}
</span></code></pre></pre>
<p>然后编译这个 Rust 函数为 WebAssembly，并在 WasmEdge 中运行。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="javascript-1"><a class="header" href="#javascript-1">JavaScript</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="快速开始-1"><a class="header" href="#快速开始-1">快速开始</a></h1>
<p>首先，让我们为 WasmEdge 构建一个基于 WebAssembly 的 JavaScript 解释器程序。这个程序基于 <a href="https://bellard.org/quickjs/">QuickJS</a> 和 WasmEdge 的一些扩展程序，比如 <a href="https://github.com/second-state/wasmedge_wasi_socket">network sockets</a> 和 <a href="https://www.secondstate.io/articles/wasi-tensorflow/">Tensorflow 推理</a>，并且这些扩展都是作为 JavaScript API 被合并到解释器中的。首先你需要<a href="https://www.rust-lang.org/tools/install">安装 rust</a> 来构建这个解释器。</p>
<blockquote>
<p>如果你只是想要使用这个解释器来运行 JavaScript 程序，那就可以跳过这部分了。否则，先确保你已经安装了 <a href="https://www.rust-lang.org/tools/install">Rust</a> 和 <a href="dev/js/../../start/install.html">WasmEdge</a>。</p>
</blockquote>
<p>Fork 或者克隆 <a href="https://github.com/second-state/wasmedge-quickjs">wasmedge-quickjs</a> 这个 Github repo 开始教程。</p>
<pre><code class="language-bash">git clone https://github.com/second-state/wasmedge-quickjs
</code></pre>
<p>按照这个 repo 中的介绍，你将能够为 WasmEdge 构建一个 JavaScript 解释器。</p>
<pre><code class="language-bash"># Install GCC
sudo apt update
sudo apt install build-essential

# Install wasm32-wasi target for Rust
rustup target add wasm32-wasi

# Build the QuickJS JavaScript interpreter
cargo build --target wasm32-wasi --release
</code></pre>
<p>构建成功后，基于 WebAssembly 的解释器程序位于 build target 目录中，你现在可以尝试执行一个简单的 &quot;hello world&quot; JavaScript 程序 (<a href="https://github.com/second-state/wasmedge-quickjs/blob/main/example_js/hello.js">example_js/hello.js</a>)，它会在终端中打印出命令行参数。</p>
<pre><code class="language-javascript">import * as os from 'os';
import * as std from 'std';

args = args.slice(1);
print('Hello', ...args);
setTimeout(() =&gt; {
  print('timeout 2s');
}, 2000);
</code></pre>
<p>接下来输入下面的命令在 WasmEdge 的 QuickJS runtime 运行 <code>hello.js</code> 文件。</p>
<pre><code class="language-bash">$ cd example_js
$ wasmedge --dir .:. ../target/wasm32-wasi/release/wasmedge_quickjs.wasm hello.js WasmEdge Runtime
Hello WasmEdge Runtime
</code></pre>
<blockquote>
<p>注意：命令行里的 <code>--dir .:.</code> 这个参数是为了让 <code>wasmedge</code> 命令有权限在文件系统中读取本地目录里的 <code>hello.js</code> 文件。我们将在下面的章节中继续用到 <code>--dir .:.</code> 这个参数。</p>
</blockquote>
<h2 id="更快地执行"><a class="header" href="#更快地执行">更快地执行</a></h2>
<p>WasmEdge 提供了一个 <code>wasmedgec</code> 实用程序来编绎并且添加一个本地机器代码部分到 <code>wasm</code> 文件中。你可以使用 <code>wasmedge</code> 来运行本地检测到的 <code>wasm</code> 文件，从而获得更快的性能。</p>
<pre><code class="language-bash">wasmedgec ../../target/wasm32-wasi/release/wasmedge_quickjs.wasm wasmedge_quickjs.wasm
wasmedge --dir .:. wasmedge_quickjs.wasm hello.js
</code></pre>
<p>接下来，我们将讨论关于在 WasmEdger 中使用 JavaScript 的更多高级案例。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="网络"><a class="header" href="#网络">网络</a></h1>
<p>QuickJS WasmEdge Runtime 支持 WasmEdge 的<a href="https://github.com/second-state/wasmedge_wasi_socket">网络 sockets 拓展</a>， 所以 JavaScript 程序也可以在网络上建立 HTTP 连接。此文将向你展示相关的 <a href="https://github.com/second-state/wasmedge-quickjs/blob/main/example_js/wasi_http_client.js">HTTP 客户端</a>和 <a href="https://github.com/second-state/wasmedge-quickjs/blob/main/example_js/wasi_http_echo.js">HTTP 服务端</a>例子.</p>
<blockquote>
<p>WasmEdge 的网络 API 是非阻塞的，所以能够开发出强异步 I/O 交互的应用。当网络请求 handler 正在创建一个对外的请求并等待服务应答的时候，应用仍然可以处理另外一个进来的请求。这让单线程应用可以并发处理多个请求。</p>
</blockquote>
<h2 id="javascript-客户端网络通讯例子"><a class="header" href="#javascript-客户端网络通讯例子">JavaScript 客户端网络通讯例子</a></h2>
<p>以下是一个使用 JavaScript 编写的异步客户端的例子。你可以在 <a href="https://github.com/second-state/wasmedge-quickjs/blob/main/example_js/wasi_http_client.js">example_js/wasi_http_client.js</a> 中找到源码。以下的代码会向你展示如何发送一个异步 HTTP GET 请求。</p>
<pre><code class="language-javascript">async function get_test() {
  try {
    let ss = await net.connect('152.136.235.225:80');
    let req = new http.WasiRequest();
    req.headers = { 'Host': '152.136.235.225' };
    req.uri = '/get?a=123';
    req.method = 'GET';
    ss.write(req.encode());
    print('wait get');
    await handle_response(ss);
    print('get end');

  } catch (e) {
    print('catch:', e);
  }
}
</code></pre>
<p>以上代码可以在等待服务端应答的同时处理其他任务。当服务端返回数据后，<code>handle_response()</code> 会被异步调用，处理好数据后就会将内容打印出来。</p>
<pre><code class="language-javascript">async function handle_response(s) {
  let buf = new http.Buffer();
  let resp = undefined;
  while (true) {
    buf.append(await s.read());
    if (resp == undefined) {
      resp = buf.parseResponse();
    }
    if (resp instanceof http.WasiResponse) {
      let resp_length = resp.bodyLength;
      if (typeof (resp_length) === &quot;number&quot;) {
        if (buf.length &gt;= resp.bodyLength) {
          print('resp.body');
          print(newStringFromUTF8(buf.buffer));
          break;
        }
      } else {
        throw new Error('no support');
      }
    }
  }
}
</code></pre>
<p>使用以下 CLI 命令，就可以在 WasmEdge runtime 中运行以上的 JavaScript 代码。</p>
<pre><code class="language-bash">cd example_js
wasmedge --dir .:. ../target/wasm32-wasi/release/wasmedge_quickjs.wasm wasi_http_client.js
</code></pre>
<p>将会有如下内容被打印出来。</p>
<pre><code class="language-json">{
  &quot;args&quot;: {
    &quot;a&quot;: &quot;123&quot;
  }, 
  &quot;data&quot;: &quot;hello&quot;, 
  &quot;files&quot;: {}, 
  &quot;form&quot;: {}, 
  &quot;headers&quot;: {
    &quot;Content-Length&quot;: &quot;5&quot;, 
    &quot;Host&quot;: &quot;152.136.235.225&quot;
  }, 
  &quot;json&quot;: null, 
  &quot;origin&quot;: &quot;20.124.39.106&quot;, 
  &quot;url&quot;: &quot;http://152.136.235.225/post?a=123&quot;
}
</code></pre>
<p>以上应用例子发出了两个 HTTP 请求，一个是 <code>GET</code> 请求另一个是 <code>POST</code> 请求。该应用会异步等待这两个请求的应答数据，并且哪一个先从服务端返回就先会处理哪个。从日志中你可以看到这两个请求的 handlers 是交错执行的。</p>
<h2 id="javascript-网络服务例子"><a class="header" href="#javascript-网络服务例子">JavaScript 网络服务例子</a></h2>
<p>以下的例子是使用 JavaScript 运行了一个监听 8000 端口的 TCP 服务器。接收到的网络请求都会被异步处理。你可以在 <a href="https://github.com/second-state/wasmedge-quickjs/blob/main/example_js/wasi_net_echo.js">example_js/wasi_net_echo.js</a> 中找到源码。</p>
<pre><code class="language-javascript">import * as net from 'wasi_net';

async function handle_client(cs) {
  while (true) {
    try {
      let d = await cs.read();
      if (d.byteLength &lt;= 0) {
        break;
      }
      let s = newStringFromUTF8(d);
      cs.write('echo:' + s);
    } catch (e) {
      print(e);
    }
  }
}

async function server_start() {
  let s = new net.WasiTcpServer(8000);
  for (var i = 0; i &lt; 100; i++) {
    let cs = await s.accept();
    handle_client(cs);
  }
}

server_start();
</code></pre>
<p>调用 <code>server_start()</code> 方法会在 8000 端口启动一个监听服务。当一个请求进入，会异步传给 <code>handle_client()</code> function 函数处理。这意味着当应用返回应答数据后，它又可以处理下一个进来的请求了。</p>
<p>使用以下 CLI 命令，就可以在 WasmEdge runtime 中运行这段 JavaScript 代码。因为它将作为一个服务运行，你最好是以后台应用的形式启动。</p>
<pre><code class="language-bash">cd example_js
nohup wasmedge --dir .:. ../target/wasm32-wasi/release/wasmedge_quickjs.wasm wasi_net_echo.js &amp;
</code></pre>
<p>然后你就可以向它发出网络请求，观察运行效果。</p>
<pre><code class="language-bash">$ curl -d &quot;WasmEdge&quot; -X POST http://localhost:8000
echo:WasmEdge
</code></pre>
<p>WasmEdge 的 <code>wasi_net</code> 包为 JavaScript 应用提供了一种自适应的动态网络栈。在很多高级用法中，我们基于这个包，设计了很多抽象良好的 API。在下一章节，我们会带着具体的常见应用，向你展示如何处理 HTTP 请求。在 <a href="dev/js/ssr.html">React 服务器渲染文章</a>中，我们还将会讨论一下如何基于这种异步网络的 API 来创建一个 React 服务器渲染功能。</p>
<h2 id="javascript-http-服务器例子"><a class="header" href="#javascript-http-服务器例子">JavaScript HTTP 服务器例子</a></h2>
<p>假如你已经知道服务器的请问和应答都是基于 HTTP 协议的，这里有一些增强方法可以帮到你更好地处理这些请求。你可以在 <a href="https://github.com/second-state/wasmedge-quickjs/blob/main/example_js/wasi_http_echo.js">example_js/wasi_http_echo.js</a> 中找到源码。</p>
<pre><code class="language-javascript">import * as http from 'wasi_http';
import * as net from 'wasi_net';

async function handle_client(cs, handler_req) {
  let buffer = new http.Buffer();

  while (true) {
    try {
      let d = await cs.read();
      if (d.byteLength &lt;= 0) {
        return;
      }
      buffer.append(d);
      let req = buffer.parseRequest();
      if (req instanceof http.WasiRequest) {
        handler_req(cs, req);
        break;
      }
    } catch (e) {
      print(e);
    }
  }
}

function handler_req(cs, req) {
  print(&quot;version=&quot;, req.version);
  print(&quot;uri=&quot;, req.uri);
  print(&quot;method=&quot;, req.method);
  print(&quot;headers=&quot;, Object.keys(req.headers));
  print(&quot;body=&quot;, newStringFromUTF8(req.body));

  let resp = new http.WasiResponse();
  let body = 'echo:' + newStringFromUTF8(req.body);
  let r = resp.encode(body);
  cs.write(r);
}

async function server_start() {
  try {
    let s = new net.WasiTcpServer(8000);
    for (var i = 0; i &lt; 100; i++) {
      let cs = await s.accept();
      try {
        handle_client(cs, handler_req);
      } catch (e) {
        print(e);
      }
    }
  } catch (e) {
    print(e);
  }
}

server_start();
</code></pre>
<p><code>server_start()</code> 方法会启动一个监听 8000 端口的服务。当请求进来，会被传给 <code>handle_client()</code> 方法来处理。当请求是合法的 HTTP 请求，对应的 handler 方法会调用 <code>handle_req()</code> 来解析对应的字段，组装新的 HTTP 应答，然后异步把应答数据发送回去。这意味着当应用发送完数据，又能继续处理下一个进来的请求了。</p>
<p>使用以下 CLI 命令，就可以在 WasmEdge runtime 中运行这段 JavaScript 代码。因为它将作为一个服务运行，你最好是以后台应用的形式运行。</p>
<pre><code class="language-bash">cd example_js
nohup wasmedge --dir .:. ../target/wasm32-wasi/release/wasmedge_quickjs.wasm wasi_http_echo.js &amp;
</code></pre>
<p>然后你就可以向它发出网络请求，观察运行效果。</p>
<pre><code class="language-bash">$ curl -d &quot;WasmEdge&quot; -X POST http://localhost:8000
echo:WasmEdge
</code></pre>
<p>在异步 HTTP 网络编程中，开发者可以安全并高效地在 WasmEdge 中使用 JavaScript 创建强交互的应用，例如数据库驱动的微服务。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="fetch-api"><a class="header" href="#fetch-api"><code>fetch</code> API</a></h1>
<p><code>fetch</code> API 被广泛用于浏览器和基于 Node 的 JavaScript 应用程序中，用来通过网络获取内容。WasmEdge QuickJS Runtime 在其非阻塞的 Aysnc Socket API 的基础上支持 <code>fetch</code> API。这使得很多 JS 的 API 和模块可以开箱即用。</p>
<p><a href="https://github.com/second-state/wasmedge-quickjs/blob/main/example_js/wasi_http_fetch.js">example_js/wasi_http_fetch.js</a> 例子展示了如何在 WasmEdge 中使用 <code>fetch</code> API。下面的代码片段显示了一个异步的 HTTP GET 请求。当程序等待和处理 GET 内容的时候，它可以开始另一个请求。</p>
<pre><code class="language-javascript">import { fetch } from 'http'

async function test_fetch() {
    try {
        let r = await fetch(&quot;http://152.136.235.225/get?id=1&quot;)
        print('test_fetch\n', await r.text())
    } catch (e) {
        print(e)
    }
}
test_fetch()
</code></pre>
<p>下面的代码片段显示了如何向远程服务器发送同步的 HTTP POST 请求。</p>
<pre><code class="language-javascript">async function test_fetch_post() {
    try {
        let r = await fetch(&quot;http://152.136.235.225/post&quot;, { method: 'post', 'body': 'post_body' })
        print('test_fetch_post\n', await r.text())
    } catch (e) {
        print(e)
    }
}
test_fetch_post()
</code></pre>
<p>如下是一个异步的 HTTP PUT 请求。</p>
<pre><code class="language-javascript">async function test_fetch_put() {
    try {
        let r = await fetch(&quot;http://152.136.235.225/put&quot;,
            {
                method: &quot;put&quot;,
                body: JSON.stringify({ a: 1 }),
                headers: { 'Context-type': 'application/json' }
            })
        print('test_fetch_put\n', await r.text())
    } catch (e) {
        print(e)
    }
}
test_fetch_put()
</code></pre>
<p>要运行这些例子，使用以下 WasmEdge CLI 命令。</p>
<pre><code class="language-bash">cd example_js
wasmedge --dir .:. ../target/wasm32-wasi/release/wasmedge_quickjs.wasm wasi_http_fetch.js
</code></pre>
<p>你可以看到打印到控制台的 HTTP 响应。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tensorflow-1"><a class="header" href="#tensorflow-1">TensorFlow</a></h1>
<p>解释器支持 WasmEdge TensorFlow lite 的推断扩展，从而使你的 JavaScript 能够运行 ImageNet 模型来进行图像分类。本文会向你展示如何在你的 javascript 程序中使用基于 WasmEdge 的 TensorFlow Rust SDK。</p>
<p>下面是一个 JavaScript 的示例。全部代码可参考这里 <a href="https://github.com/second-state/wasmedge-quickjs/tree/main/example_js/tensorflow_lite_demo">example_js/tensorflow_lite_demo/</a></p>
<pre><code class="language-javascript">import {Image} from 'image';
import * as std from 'std';
import {TensorflowLiteSession} from 'tensorflow_lite';

let img = new Image('food.jpg');
let img_rgb = img.to_rgb().resize(192, 192);
let rgb_pix = img_rgb.pixels();

let session = new TensorflowLiteSession(
    'lite-model_aiy_vision_classifier_food_V1_1.tflite');
session.add_input('input', rgb_pix);
session.run();
let output = session.get_output('MobilenetV1/Predictions/Softmax');
let output_view = new Uint8Array(output);
let max = 0;
let max_idx = 0;
for (var i in output_view) {
  let v = output_view[i];
  if (v &gt; max) {
    max = v;
    max_idx = i;
  }
}
let label_file = std.open('aiy_food_V1_labelmap.txt', 'r');
let label = '';
for (var i = 0; i &lt;= max_idx; i++) {
  label = label_file.getline();
}
label_file.close();

print('label:');
print(label);
print('confidence:');
print(max / 255);
</code></pre>
<p>为了在 WasmEdge runtime 中运行 JavaScript，你可以在 CLI 中执行如下操作，这样就可以重新构建一个包含 TensorFlow 的 QuickJS 引擎，然后就可以在 JavaScript 应用中调用 TensorFlow API 了。</p>
<pre><code class="language-bash">$ cargo build --target wasm32-wasi --release --features=tensorflow
... ...
$ cd example_js/tensorflow_lite_demo
$ wasmedge-tensorflow-lite --dir .:. ../../target/wasm32-wasi/release/wasmedge_quickjs.wasm main.js
label:
Hot dog
confidence:
0.8941176470588236
</code></pre>
<blockquote>
<p>注意: 命令行中的 <code>--dir .:.</code> 是为了给 wasmedge 开启本地文件读取权限， 以便正常读取到 <code>main.js</code> 文件.</p>
</blockquote>
<h2 id="注意"><a class="header" href="#注意">注意</a></h2>
<ul>
<li>编译器标志 <code>--features=tensorflow</code> 构建了一个包含 WasmEdge TensorFlow 扩展的 QuickJS 引擎。</li>
<li>程序 <code>wasmedge-tensorflow-lite</code> 是 WasmEdge 包的一部分。它是内含有 Tensorflow 扩展的 WasmEdge runtime。</li>
</ul>
<p>你现在应该可以看到食物的名字了，它被 TensorFlow lite ImageNet 模型识别出来了。</p>
<h2 id="使其更快"><a class="header" href="#使其更快">使其更快</a></h2>
<p>以上 Tensorflow 推断示例执行一次需要耗时 1-2 秒. 在 web 应用场景中虽然可以接受，但是仍然有改进空间。回想一下，WasmEdge 是如今最快的 WebAssembly runtime，这是由于它的提前编译（AOT, Ahead-of-time compiler）优化。WasmEdge 提供了一个 <code>wasmedgec</code> 实用程序去编译和添加原生机器码段，并放到 <code>wasm</code> 文件里，从而达到更快的性能。</p>
<p>以下示例采用了 <code>wasmedge</code> 和 <code>wasmedgec</code> 的扩展版本以支持 WasmEdge Tensorflow 扩展。</p>
<pre><code class="language-bash">$ cd example_js/tensorflow_lite_demo
$ wasmedgec-tensorflow ../../target/wasm32-wasi/release/wasmedge_quickjs.wasm wasmedge_quickjs.wasm
$ wasmedge-tensorflow-lite --dir .:. wasmedge_quickjs.wasm main.js
label:
Hot dog
confidence:
0.8941176470588236
</code></pre>
<p>你可以看到，图像识别任务在 0.1 秒内就完成了。它的性能至少提高了 10 倍。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="react-ssr"><a class="header" href="#react-ssr">React SSR</a></h1>
<p><a href="https://medium.com/jspoint/a-beginners-guide-to-react-server-side-rendering-ssr-bf3853841d55">React 服务端渲染（SSR）</a> 是 JavaScript 在 BFF（为前端提供服务的后端）函数中一种常见的使用场景。
和在浏览器中渲染 HTML DOM 元素的方式不同，这种技术使用 React 框架在服务端就生成了 HTML 元素，以此来加快应用的加载速度。
在 <a href="https://jamstack.org/">Jamstack</a> 应用中，这是使用 serverless 函数时一种较理想的方式。</p>
<p>在这篇文章中，我们将向你展示如何使用 WasmEdge 的 QuickJS 运行时来实现 React SSR 的能力。与 Docker + Linux + nodejs + v8 的方案相比，WasmEdge 要轻量得多（仅 1% 的占用），也更安全，能够提供更好的资源隔离和管理机制，并有着和非 JIT（同时是安全的）近似的性能。</p>
<p>本文将包含对静态渲染和流式渲染两种渲染方式的介绍。静态渲染相对容易理解和实现。而流式渲染则可以提供更好的用户体验，因为用户在浏览器前等待结果时，可以优先看到生成的部分内容。</p>
<h2 id="静态渲染"><a class="header" href="#静态渲染">静态渲染</a></h2>
<p>本示例的源代码可以在 GitHub 仓库的 <a href="https://github.com/second-state/wasmedge-quickjs/tree/main/example_js/react_ssr">example_js/react_ssr</a> 文件夹中找到。它展示了运行于 WasmEdge 的 JavaScript 应用程序，是如何编排 HTML 模板并将其渲染成 HTML 字符串的。</p>
<p>文件 <a href="https://github.com/second-state/wasmedge-quickjs/blob/main/example_js/react_ssr/component/Home.jsx">component/Home.jsx</a> 里是 React 的主页模板。</p>
<pre><code class="language-javascript">import React from 'react';
import Page from './Page.jsx';
class Home extends React.Component {
  render() {
    const { dataList = [] } = this.props;
    return (
      &lt;div&gt;
        &lt;div&gt;This is home&lt;/div&gt;
        &lt;Page&gt;&lt;/Page&gt;
      &lt;/div&gt;
    );
  }
};

export default Home;
</code></pre>
<p><code>Home.jsx</code> 中会包含 <a href="https://github.com/second-state/wasmedge-quickjs/blob/main/example_js/react_ssr/component/Page.jsx">Page.jsx</a> 提供的模板，作为页面的一部分。</p>
<pre><code class="language-javascript">import React from 'react';

class Page extends React.Component {
  render() {
    const { dataList = [] } = this.props;
    return (
      &lt;div&gt;
        &lt;div&gt;This is page&lt;/div&gt;
      &lt;/div&gt;
    );
  }
};

export default Page;
</code></pre>
<p>文件 <a href="https://github.com/second-state/wasmedge-quickjs/blob/main/example_js/react_ssr/main.js">main.js</a> 会调用 React 将模板渲染成 HTML。</p>
<pre><code class="language-javascript">import React from 'react';
import {renderToString} from 'react-dom/server';

import Home from './component/Home.jsx';

const content = renderToString(React.createElement(Home));
console.log(content);
</code></pre>
<p>目录中的 <a href="https://github.com/second-state/wasmedge-quickjs/blob/main/example_js/react_ssr/rollup.config.js">rollup.config.js</a> 文件和 <a href="https://github.com/second-state/wasmedge-quickjs/blob/main/example_js/react_ssr/package.json">package.json</a> 文件用于把 React SSR 的所有依赖和组件打包成一个 WasmEdge 可用的 JavaScript 文件。你可以使用 <code>npm</code> 命令来进行构建，构建产物会输出到 <code>dist/main.js</code> 文件里。</p>
<pre><code class="language-bash">npm install
npm run build
</code></pre>
<p>要运行这个例子，请在命令行中执行以下命令。你会看到，所有的模板成功合成了一个 HTML 字符串。</p>
<pre><code class="language-bash">$ cd example_js/react_ssr
$ wasmedge --dir .:. ../../target/wasm32-wasi/release/wasmedge_quickjs.wasm dist/main.js
&lt;div data-reactroot=&quot;&quot;&gt;&lt;div&gt;This is home&lt;/div&gt;&lt;div&gt;&lt;div&gt;This is page&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;
</code></pre>
<blockquote>
<p>注意： 命令行里的 <code>--dir .:.</code> 会给 WasmEdge 读取本地文件系统下目录的权限，以此读取 <code>dist/main.js</code> 文件。</p>
</blockquote>
<h2 id="流式渲染"><a class="header" href="#流式渲染">流式渲染</a></h2>
<p>本示例的源代码可以在 GitHub 仓库的 <a href="https://github.com/second-state/wasmedge-quickjs/tree/main/example_js/react_ssr_stream">example_js/react_ssr_stream</a> 文件夹中找到。它展示了运行于 WasmEdge 的 JavaScript 应用程序，是如何流式地把 HTML 模板渲染成 HTML 字符串的。</p>
<p>文件 <a href="https://github.com/second-state/wasmedge-quickjs/blob/main/example_js/react_ssr_stream/component/LazyHome.jsx">component/LazyHome.jsx</a> 是 React 的主页模板。当外层的 HTML 渲染好并返回给用户 2s 之后，它才会开始“懒”加载内层的页面模板。</p>
<pre><code class="language-javascript">import React, { Suspense } from 'react';

async function sleep(ms) {
  return new Promise((r, _) =&gt; {
    setTimeout(() =&gt; r(), ms)
  });
}

async function loadLazyPage() {
  await sleep(2000);
  return await import('./LazyPage.jsx');
}

class LazyHome extends React.Component {
  render() {
    let LazyPage1 = React.lazy(() =&gt; loadLazyPage());
    return (
      &lt;html lang=&quot;en&quot;&gt;
        &lt;head&gt;
          &lt;meta charSet=&quot;utf-8&quot; /&gt;
          &lt;title&gt;Title&lt;/title&gt;
        &lt;/head&gt;
        &lt;body&gt;
          &lt;div&gt;
            &lt;div&gt; This is LazyHome &lt;/div&gt;
            &lt;Suspense fallback={&lt;div&gt; loading... &lt;/div&gt;}&gt;
              &lt;LazyPage1 /&gt;
            &lt;/Suspense&gt;
          &lt;/div&gt;
        &lt;/body&gt;
      &lt;/html&gt;
    );
  }
}

export default LazyHome;
</code></pre>
<p><a href="https://github.com/second-state/wasmedge-quickjs/blob/main/example_js/react_ssr_stream/component/LazyPage.jsx">LazyPage.jsx</a> 里就是内层的模板。只有在外层页面返回给用户 2s 之后，它才会被渲染。</p>
<pre><code class="language-javascript">import React from 'react';

class LazyPage extends React.Component {
  render() {
    return (
      &lt;div&gt;
        &lt;div&gt;
          This is lazy page
        &lt;/div&gt;
      &lt;/div&gt;
    );
  }
}

export default LazyPage;
</code></pre>
<p><a href="https://github.com/second-state/wasmedge-quickjs/blob/main/example_js/react_ssr_stream/main.mjs">main.mjs</a> 文件会启动一个异步的 HTTP 服务器，然后把 HTML 页面渲染成多段放入响应。当一个 HTTP 请求进来的时候，<code>handle_client()</code> 函数就会被调用来渲染 HTML，并以流的形式返回结果。</p>
<pre><code class="language-javascript">import * as React from 'react';
import { renderToPipeableStream } from 'react-dom/server';
import * as http from 'wasi_http';
import * as net from 'wasi_net';

import LazyHome from './component/LazyHome.jsx';

async function handle_client(s) {
  let resp = new http.WasiResponse();
  resp.headers = {
    &quot;Content-Type&quot;: &quot;text/html; charset=utf-8&quot;
  }
  renderToPipeableStream(&lt;LazyHome /&gt;).pipe(resp.chunk(s));
}

async function server_start() {
  print('listen 8001...');
  let s = new net.WasiTcpServer(8001);
  for (var i = 0; i &lt; 100; i++) {
    let cs = await s.accept();
    handle_client(cs);
  }
}

server_start();
</code></pre>
<p>目录中的 <a href="https://github.com/second-state/wasmedge-quickjs/blob/main/example_js/react_ssr_stream/rollup.config.js">rollup.config.js</a> 文件和 <a href="https://github.com/second-state/wasmedge-quickjs/blob/main/example_js/react_ssr_stream/package.json">package.json</a> 文件用于把 React SSR 的所有依赖和组件打包成一个 WasmEdge 可用的 JavaScript 文件。你可以使用 <code>npm</code> 命令来进行构建，构建产物会输出到 <code>dist/main.js</code> 文件里。</p>
<pre><code class="language-bash">npm install
npm run build
</code></pre>
<p>要运行这个例子，请在命令行上执行以下命令来启动服务器。</p>
<pre><code class="language-bash">cd example_js/react_ssr_stream
nohup wasmedge --dir .:. ../../target/wasm32-wasi/release/wasmedge_quickjs.wasm dist/main.mjs &amp;
</code></pre>
<p>然后通过 <code>curl</code> 或浏览器发送一个 HTTP 请求。</p>
<pre><code class="language-bash">curl http://localhost:8001
</code></pre>
<p>结果如下所示。该服务首先返回一个 HTML 页面，里面包含一个空的内层部分（即 <code>loading</code> 部分）。然后在 2s 后返回内层部分的 HTML 内容，以及将它显示出来的 JavaScript 代码。</p>
<pre><code class="language-bash">  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current
                                 Dload  Upload   Total   Spent    Left  Speed

  0     0    0     0    0     0      0      0 --:--:-- --:--:-- --:--:--     0
100   211    0   211    0     0   1029      0 --:--:-- --:--:-- --:--:--  1024
100   275    0   275    0     0    221      0 --:--:--  0:00:01 --:--:--   220
100   547    0   547    0     0    245      0 --:--:--  0:00:02 --:--:--   245
100  1020    0  1020    0     0    413      0 --:--:--  0:00:02 --:--:--   413

&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;&lt;meta charSet=&quot;utf-8&quot;/&gt;&lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div&gt;&lt;div&gt; This is LazyHome &lt;/div&gt;&lt;!--$?--&gt;&lt;template id=&quot;B:0&quot;&gt;&lt;/template&gt;&lt;div&gt; loading... &lt;/div&gt;&lt;!--/$--&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;&lt;div hidden id=&quot;S:0&quot;&gt;&lt;template id=&quot;P:1&quot;&gt;&lt;/template&gt;&lt;/div&gt;&lt;div hidden id=&quot;S:1&quot;&gt;&lt;div&gt;&lt;div&gt;This is lazy page&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;script&gt;function $RS(a,b){a=document.getElementById(a);b=document.getElementById(b);for(a.parentNode.removeChild(a);a.firstChild;)b.parentNode.insertBefore(a.firstChild,b);b.parentNode.removeChild(b)};$RS(&quot;S:1&quot;,&quot;P:1&quot;)&lt;/script&gt;&lt;script&gt;function $RC(a,b){a=document.getElementById(a);b=document.getElementById(b);b.parentNode.removeChild(b);if(a){a=a.previousSibling;var f=a.parentNode,c=a.nextSibling,e=0;do{if(c&amp;&amp;8===c.nodeType){var d=c.data;if(&quot;/$&quot;===d)if(0===e)break;else e--;else&quot;$&quot;!==d&amp;&amp;&quot;$?&quot;!==d&amp;&amp;&quot;$!&quot;!==d||e++}d=c.nextSibling;f.removeChild(c);c=d}while(c);for(;b.firstChild;)f.insertBefore(b.firstChild,c);a.data=&quot;$&quot;;a._reactRetry&amp;&amp;a._reactRetry()}};$RC(&quot;B:0&quot;,&quot;S:0&quot;)&lt;/script&gt;
</code></pre>
<p>流式 SSR 的示例充分利用了 WasmEdge 独特的处理异步网络的能力以及对 ES6 module 的支持（rollup 打包的 JS 文件中包含了 ES6 的模块）。你可以在本书中阅读更多有关 <a href="dev/js/networking.html">异步网络</a> 和 <a href="dev/js/es6.html">ES6</a> 的知识。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="es6-模块"><a class="header" href="#es6-模块">ES6 模块</a></h1>
<p>WasmEdge QuickJS runtime 提供了对 ES6 模块的支持。我们在 <a href="dev/js/ssr.html">React SSR</a> 例子中使用的 rollup 命令实际上是将  CommonJS 和 NPM 模块转换并且捆绑为 ES6 模块，以便它们可以在 WasmEdge QuickJS 中执行。这篇文章将告诉你如何在 WasmEdge 中使用 ES6 模块。</p>
<p>我们将以 <a href="https://github.com/second-state/wasmedge-quickjs/tree/main/example_js/es6_module_demo">example_js/es6_module_demo</a> 文件夹中的例子为例。该文件夹中的 <a href="https://github.com/second-state/wasmedge-quickjs/blob/main/example_js/es6_module_demo/module_def.js">module_def.js</a> 文件定义并导出了一个简单的 JS 函数。</p>
<pre><code class="language-javascript">function hello(){
  console.log('hello from module_def.js');
}

export {hello};
</code></pre>
<p><a href="https://github.com/second-state/wasmedge-quickjs/blob/main/example_js/es6_module_demo/module_def_async.js">module_def_async.js</a> 文件定义并导出了一个 aysnc 函数和一个变量。</p>
<pre><code class="language-javascript">export async function hello() {
  console.log('hello from module_def_async.js');
  return 'module_def_async.js : return value';
}

export var something = 'async thing';
</code></pre>
<p><a href="https://github.com/second-state/wasmedge-quickjs/blob/main/example_js/es6_module_demo/demo.js">demo.js</a> 文件从这些模块导入函数和变量并执行这些函数。</p>
<pre><code class="language-javascript">import {hello as module_def_hello} from './module_def.js';

module_def_hello();

var f = async () =&gt; {
  let {hello, something} = await import('./module_def_async.js');
  await hello();
  console.log('./module_def_async.js `something` is ', something);
};

f();
</code></pre>
<p>要运行这个例子，你可以在 CLI 上做如下操作。</p>
<pre><code class="language-javascript">$ cd example_js/es6_module_demo
$ wasmedge --dir .:. ../../target/wasm32-wasi/release/wasmedge_quickjs.wasm demo.js
hello from module_def.js
hello from module_def_async.js
./module_def_async.js `something` is  async thing
</code></pre>
<blockquote>
<p>注意：命令行中的 <code>--dir .:.</code> 是为了赋予 wasmedge 权限，让其读取文件系统中 <code>demo.js</code> 文件的本地目录。</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="nodejs-和-npm-模块"><a class="header" href="#nodejs-和-npm-模块">NodeJS 和 NPM 模块</a></h1>
<p>使用 <a href="https://rollupjs.org/guide/en/">rollup.js</a>，我们也可以在 WasmEdge 上运行 CommonJS (CJS) 和 NodeJS (NPM) 模块。 <a href="https://github.com/second-state/wasmedge-quickjs/blob/main/example_js/simple_common_js_demo/npm_main.js">simple_common_js_demo/npm_main.js</a> 演示展示了它是如何工作的。它使用了第三方的 <code>md5</code> 和 <code>mathjs</code> 模块。</p>
<pre><code class="language-javascript">const md5 = require('md5');
console.log('md5(message)=', md5('message'));

const {sqrt} = require('mathjs');
console.log('sqrt(-4)=', sqrt(-4).toString());
</code></pre>
<p>为运行上述代码，我们必须先使用 <a href="https://rollupjs.org/guide/en/">rollup.js</a> 工具将所有依赖项构建到一个文件中。在此过程中，<code>rollup.js</code> 将 CommonJS 模块转换为 <a href="dev/js/es6.html">WasmEdge 兼容的 ES6 模块</a>。构建脚本是 <a href="https://github.com/second-state/wasmedge-quickjs/blob/main/example_js/simple_common_js_demo/rollup.config.js">rollup.config.js</a>。</p>
<pre><code class="language-javascript">const {babel} = require('@rollup/plugin-babel');
const nodeResolve = require('@rollup/plugin-node-resolve');
const commonjs = require('@rollup/plugin-commonjs');
const replace = require('@rollup/plugin-replace');

const globals = require('rollup-plugin-node-globals');
const builtins = require('rollup-plugin-node-builtins');
const plugin_async = require('rollup-plugin-async');

const babelOptions = {
  'presets': ['@babel/preset-react']
};

module.exports = [
  {
    input: './npm_main.js',
    output: {
      inlineDynamicImports: true,
      file: 'dist/npm_main.mjs',
      format: 'esm',
    },
    external: ['process', 'wasi_net','std'],
    plugins: [
      plugin_async(),
      nodeResolve(),
      commonjs({ignoreDynamicRequires: false}),
      babel(babelOptions),
      globals(),
      builtins(),
      replace({
        'process.env.NODE_ENV': JSON.stringify('production'),
        'process.env.NODE_DEBUG': JSON.stringify(''),
      }),
    ],
  },
];
</code></pre>
<p><a href="https://github.com/second-state/wasmedge-quickjs/blob/main/example_js/simple_common_js_demo/package.json">package.json</a> 文件指定了 <code>rollup.js</code> 依赖项和命令，以构建 <a href="https://github.com/second-state/wasmedge-quickjs/blob/main/example_js/simple_common_js_demo/npm_main.js">npm_main.js</a> 演示程序成一个包。</p>
<pre><code class="language-json">{
  &quot;dependencies&quot;: {
    &quot;mathjs&quot;: &quot;^9.5.1&quot;,
    &quot;md5&quot;: &quot;^2.3.0&quot;
  },
  &quot;devDependencies&quot;: {
    &quot;@babel/core&quot;: &quot;^7.16.5&quot;,
    &quot;@babel/preset-env&quot;: &quot;^7.16.5&quot;,
    &quot;@babel/preset-react&quot;: &quot;^7.16.5&quot;,
    &quot;@rollup/plugin-babel&quot;: &quot;^5.3.0&quot;,
    &quot;@rollup/plugin-commonjs&quot;: &quot;^21.0.1&quot;,
    &quot;@rollup/plugin-node-resolve&quot;: &quot;^7.1.3&quot;,
    &quot;@rollup/plugin-replace&quot;: &quot;^3.0.0&quot;,
    &quot;rollup&quot;: &quot;^2.60.1&quot;,
    &quot;rollup-plugin-babel&quot;: &quot;^4.4.0&quot;,
    &quot;rollup-plugin-node-builtins&quot;: &quot;^2.1.2&quot;,
    &quot;rollup-plugin-node-globals&quot;: &quot;^1.4.0&quot;,
    &quot;rollup-plugin-async&quot;: &quot;^1.2.0&quot;
  },
  &quot;scripts&quot;: {
    &quot;build&quot;: &quot;rollup -c rollup.config.js&quot;
  }
}
</code></pre>
<p>运行以下 NPM 命令将 <a href="https://github.com/second-state/wasmedge-quickjs/blob/main/example_js/simple_common_js_demo/npm_main.js">npm_main.js</a> 演示程序构建到 <code>dist/npm_main.mjs</code> 中。</p>
<pre><code class="language-bash">npm install
npm run build
</code></pre>
<p>在 WasmEdge CLI 中运行结果 JS 文件，如下所示。</p>
<pre><code class="language-bash">$ wasmedge --dir .:. ../../target/wasm32-wasi/release/wasmedge_quickjs.wasm dist/npm_main.mjs
md5(message)= 78e731027d8fd50ed642340b7c9a63b3
sqrt(-4)= 2i
</code></pre>
<p>你可以通过这种方式在 WasmEdge 中导入和运行任何纯 JS NPM 包。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="用-rust-实现-js-api"><a class="header" href="#用-rust-实现-js-api">用 Rust 实现 JS API</a></h1>
<p>对于 JavaScript 开发者来说，将 Rust 函数结合到 JavaScript API 中是非常有用的。这样做，使得开发者在用&quot;纯 JavaScript&quot;编写程序的同时，也可使用高性能的 Rust 函数。你可以使用 <a href="https://github.com/WasmEdge/WasmEdge">WasmEdge Runtime</a> 做到这一点。</p>
<p>在开始之前，克隆 GitHub 仓库 <a href="https://github.com/second-state/wasmedge-quickjs/">wasmedge-quickjs</a>，并切换到目录 <code>examples/embed_js</code>。该操作如下所示。</p>
<pre><code class="language-bash">git clone https://github.com/second-state/wasmedge-quickjs
cd examples/embed_js
</code></pre>
<blockquote>
<p>你必须安装有 <a href="https://www.rust-lang.org/tools/install">Rust</a> 和 <a href="dev/js/../../start/install.html">WasmEdge</a> 以构建与运行我们展示给你的示例。</p>
</blockquote>
<p>对于如何将 JavaScript 嵌入到 Rust 中，<code>embed_js</code> 列出了几个不同的例子。你可以按如下的命令构建并运行这些示例。</p>
<pre><code class="language-bash">cargo build --target wasm32-wasi --release
wasmedge --dir .:. target/wasm32-wasi/release/embed_js.wasm
</code></pre>
<blockquote>
<p>注：命令行中的 <code>--dir .:.</code> 给予了 wasmedge 读取文件系统的本地目录的权限。</p>
</blockquote>
<h2 id="创建一个-javascript-函数-api"><a class="header" href="#创建一个-javascript-函数-api">创建一个 JavaScript 函数 API</a></h2>
<p>下面这个代码片段定义了一个 Rust 函数，该函数可以作为一个 API 结合到 JavaScript 解释器中。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn run_rust_function(ctx: &amp;mut Context) {

  struct HelloFn;
  impl JsFn for HelloFn {
    fn call(_ctx: &amp;mut Context, _this_val: JsValue, argv: &amp;[JsValue]) -&gt; JsValue {
      println!(&quot;hello from rust&quot;);
      println!(&quot;argv={:?}&quot;, argv);
      JsValue::UnDefined
    }
  }
  
  ...
}
<span class="boring">}
</span></code></pre></pre>
<p>下面的代码展示了如何把这个 Rust 函数添加到 JavaScript 解释器中，并为该函数的 JavaScript API 指定一个签名 <code>hi()</code>，随之在 JavaScript 代码中调用它。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn run_rust_function(ctx: &amp;mut Context) {
  ...
  
  let f = ctx.new_function::&lt;HelloFn&gt;(&quot;hello&quot;);
  ctx.get_global().set(&quot;hi&quot;, f.into());
  let code = r#&quot;hi(1,2,3)&quot;#;
  let r = ctx.eval_global_str(code);
  println!(&quot;return value:{:?}&quot;, r);
}
<span class="boring">}
</span></code></pre></pre>
<p>执行的结果如下所示。</p>
<pre><code class="language-bash">hello from rust
argv=[Int(1), Int(2), Int(3)]
return value:UnDefined
</code></pre>
<p>通过这个方法，你可以创建出一个带有自定义 API 函数的 JavaScript 解释器。这个解释器是运行在 WasmEdge 里的，并且可以通过 CLI 或者网络来执行调用了这些 API 函数的 JavaScript 代码。</p>
<h2 id="创建一个-javascript-对象-api"><a class="header" href="#创建一个-javascript-对象-api">创建一个 JavaScript 对象 API</a></h2>
<p>在 JavaScript API 的设计中，我们有时需要提供一个封装了数据以及函数的对象。在下面的示例中，我们为 JavaScript API 定义了一个 Rust 函数。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn rust_new_object_and_js_call(ctx: &amp;mut Context) {
  struct ObjectFn;
  impl JsFn for ObjectFn {
    fn call(_ctx: &amp;mut Context, this_val: JsValue, argv: &amp;[JsValue]) -&gt; JsValue {
      println!(&quot;hello from rust&quot;);
      println!(&quot;argv={:?}&quot;, argv);
      if let JsValue::Object(obj) = this_val {
        let obj_map = obj.to_map();
        println!(&quot;this={:#?}&quot;, obj_map);
      }
      JsValue::UnDefined
    }
  }

  ...
}
<span class="boring">}
</span></code></pre></pre>
<p>然后，我们在 Rust 端创建一个&quot;对象&quot;，设置它的数据域，然后将该 Rust 函数注册为关联到该对象的 JavaScript 函数。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut obj = ctx.new_object();
obj.set(&quot;a&quot;, 1.into());
obj.set(&quot;b&quot;, ctx.new_string(&quot;abc&quot;).into());

let f = ctx.new_function::&lt;ObjectFn&gt;(&quot;anything&quot;);
obj.set(&quot;f&quot;, f.into());
<span class="boring">}
</span></code></pre></pre>
<p>接下来，我们使这个 Rust &quot;对象&quot; 能在 JavaScript 解释器中作为 JavaScript 对象 <code>test_obj</code> 使用。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>ctx.get_global().set(&quot;test_obj&quot;, obj.into());
<span class="boring">}
</span></code></pre></pre>
<p>在 JavaScript 代码中，你可以直接将 <code>test_obj</code> 作为 API 的一部分使用了。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let code = r#&quot;
  print('test_obj keys=',Object.keys(test_obj))
  print('test_obj.a=',test_obj.a)
  print('test_obj.b=',test_obj.b)
  test_obj.f(1,2,3,&quot;hi&quot;)
&quot;#;

ctx.eval_global_str(code);
<span class="boring">}
</span></code></pre></pre>
<p>代码执行的结果如下。</p>
<pre><code class="language-bash">test_obj keys= a,b,f
test_obj.a= 1
test_obj.b= abc
hello from rust
argv=[Int(1), Int(2), Int(3), String(JsString(hi))]
this=Ok(
  {
    &quot;a&quot;: Int(
      1,
    ),
    &quot;b&quot;: String(
      JsString(
        abc,
      ),
    ),
    &quot;f&quot;: Function(
      JsFunction(
        function anything() {
          [native code]
        },
      ),
    ),
  },
)
</code></pre>
<h2 id="一个完整的-javascript-对象-api"><a class="header" href="#一个完整的-javascript-对象-api">一个完整的 JavaScript 对象 API</a></h2>
<p>在前面的示例中，我们简单地演示了如何用 Rust 创建 JavaScript API。在这个例子中，我们将会创建一个完整的 Rust 模块并让它成为一个 JavaScript 对象 API。这个项目在文件夹 <a href="https://github.com/second-state/wasmedge-quickjs/tree/main/examples/embed_rust_module">examples/embed_rust_module</a> 中。你可以构建并将其当做一个标准的 Rust 应用，在 WasmEdge 中运行它。</p>
<pre><code class="language-bash">cargo build --target wasm32-wasi --release
wasmedge --dir .:. target/wasm32-wasi/release/embed_rust_module.wasm
</code></pre>
<p>该对象的 Rust 实现，如下面这个模块所示。它含有数据域、构造函数、访问器、设置器以及函数。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>mod point {
  use wasmedge_quickjs::*;

  #[derive(Debug)]
  struct Point(i32, i32);

  struct PointDef;

  impl JsClassDef&lt;Point&gt; for PointDef {
    const CLASS_NAME: &amp;'static str = &quot;Point\0&quot;;
    const CONSTRUCTOR_ARGC: u8 = 2;

    fn constructor(_: &amp;mut Context, argv: &amp;[JsValue]) -&gt; Option&lt;Point&gt; {
      println!(&quot;rust-&gt; new Point {:?}&quot;, argv);
      let x = argv.get(0);
      let y = argv.get(1);
      if let ((Some(JsValue::Int(ref x)), Some(JsValue::Int(ref y)))) = (x, y) {
        Some(Point(*x, *y))
      } else {
        None
      }
    }

    fn proto_init(p: &amp;mut JsClassProto&lt;Point, PointDef&gt;) {
      struct X;
      impl JsClassGetterSetter&lt;Point&gt; for X {
        const NAME: &amp;'static str = &quot;x\0&quot;;

        fn getter(_: &amp;mut Context, this_val: &amp;mut Point) -&gt; JsValue {
          println!(&quot;rust-&gt; get x&quot;);
          this_val.0.into()
        }

        fn setter(_: &amp;mut Context, this_val: &amp;mut Point, val: JsValue) {
          println!(&quot;rust-&gt; set x:{:?}&quot;, val);
          if let JsValue::Int(x) = val {
            this_val.0 = x
          }
        }
      }

      struct Y;
      impl JsClassGetterSetter&lt;Point&gt; for Y {
        const NAME: &amp;'static str = &quot;y\0&quot;;

        fn getter(_: &amp;mut Context, this_val: &amp;mut Point) -&gt; JsValue {
          println!(&quot;rust-&gt; get y&quot;);
          this_val.1.into()
        }

        fn setter(_: &amp;mut Context, this_val: &amp;mut Point, val: JsValue) {
          println!(&quot;rust-&gt; set y:{:?}&quot;, val);
          if let JsValue::Int(y) = val {
            this_val.1 = y
          }
        }
      }

      struct FnPrint;
      impl JsMethod&lt;Point&gt; for FnPrint {
        const NAME: &amp;'static str = &quot;pprint\0&quot;;
        const LEN: u8 = 0;

        fn call(_: &amp;mut Context, this_val: &amp;mut Point, _argv: &amp;[JsValue]) -&gt; JsValue {
          println!(&quot;rust-&gt; pprint: {:?}&quot;, this_val);
          JsValue::Int(1)
        }
      }

      p.add_getter_setter(X);
      p.add_getter_setter(Y);
      p.add_function(FnPrint);
    }
  }

  struct PointModule;
  impl ModuleInit for PointModule {
    fn init_module(ctx: &amp;mut Context, m: &amp;mut JsModuleDef) {
      m.add_export(&quot;Point\0&quot;, PointDef::class_value(ctx));
    }
  }

  pub fn init_point_module(ctx: &amp;mut Context) {
    ctx.register_class(PointDef);
    ctx.register_module(&quot;point\0&quot;, PointModule, &amp;[&quot;Point\0&quot;]);
  }
}
<span class="boring">}
</span></code></pre></pre>
<p>在解释器的实现中，我们先调用 <code>point::init_point_module</code> 以将 Rust 模块注册到 JavaScript 的上下文中，然后运行一个使用了对象 <code>point</code> 的 JavaScript 程序。</p>
<pre><pre class="playground"><code class="language-rust">use wasmedge_quickjs::*;
fn main() {
  let mut ctx = Context::new();
  point::init_point_module(&amp;mut ctx);

  let code = r#&quot;
    import('point').then((point)=&gt;{
    let p0 = new point.Point(1,2)
    print(&quot;js-&gt;&quot;,p0.x,p0.y)
    p0.pprint()
    try{
      let p = new point.Point()
      print(&quot;js-&gt; p:&quot;,p)
      print(&quot;js-&gt;&quot;,p.x,p.y)
      p.x=2
      p.pprint()
    } catch(e) {
      print(&quot;An error has been caught&quot;);
      print(e)
    }  
    })
  &quot;#;

  ctx.eval_global_str(code);
  ctx.promise_loop_poll();
}
</code></pre></pre>
<p>上面这个应用的执行结果如下所示。</p>
<pre><code class="language-bash">rust-&gt; new Point [Int(1), Int(2)]
rust-&gt; get x
rust-&gt; get y
js-&gt; 1 2
rust-&gt; pprint: Point(1, 2)
rust-&gt; new Point []
js-&gt; p: undefined
An error has been caught
TypeError: cannot read property 'x' of undefined
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="python"><a class="header" href="#python">Python</a></h1>
<p>Python 运行时已经有几种不同的语言实现，其中一些支持 WebAssembly。本文档将描述如何在 WasmEdge 上运行 <a href="https://github.com/RustPython/RustPython">RustPython</a> 来执行 Python 程序。</p>
<h2 id="编译-rustpython"><a class="header" href="#编译-rustpython">编译 RustPython</a></h2>
<p>要编译 RustPython，你应该在你的机器上安装 Rust 工具链。并且应该启用 <code>wasm32-wasi</code> 平台支持。</p>
<pre><code class="language-bash">rustup target add wasm32-wasi
</code></pre>
<p>然后你可以使用下面的命令来克隆和编译 RustPython：</p>
<pre><code class="language-bash">git clone https://github.com/RustPython/RustPython.git
cd RustPython
cargo build --release --target wasm32-wasi --features=&quot;freeze-stdlib&quot;
</code></pre>
<p>为了能够在二进制文件中包含 Python 标准库，需要启用 <code>freeze-stdlib</code> 特性。输出文件可以在 <code>target/wasm32-wasi/release/rustpython.wasm</code> 找到。</p>
<h2 id="aot-编译"><a class="header" href="#aot-编译">AOT 编译</a></h2>
<p>WasmEdge 支持将 WebAssembly 字节码程序编译为机器码以获得更好的性能。强烈建议在运行前将 RustPython 编译为机器码。</p>
<pre><code class="language-bash">wasmedgec ./target/wasm32-wasi/release/rustpython.wasm ./target/wasm32-wasi/release/rustpython.wasm
</code></pre>
<p>从 0.9.0 开始，WasmEdge引入了<a href="https://wasmedge.org/book/en/start/universal.html">通用 Wasm 二进制格式</a>。所以你可以使用 <code>.wasm</code> 扩展来生成跨运行时兼容的格式，或者使用 <code>.so</code> 来生成 Linux 共享库格式。</p>
<h2 id="运行-1"><a class="header" href="#运行-1">运行</a></h2>
<pre><code class="language-bash">wasmedge ./target/wasm32-wasi/release/rustpython.wasm
</code></pre>
<p>然后你可以在 WebAssembly 中得到一个 Python shell 交互解释器！</p>
<h2 id="授予文件系统访问权限"><a class="header" href="#授予文件系统访问权限">授予文件系统访问权限</a></h2>
<p>可以预先打开目录，让 WASI 程序有权限读写真机上存储的文件。以下命令将当前工作目录挂载到 WASI 虚拟文件系统。</p>
<pre><code class="language-bash">wasmedge --dir .:. ./target/wasm32-wasi/release/rustpython.wasm
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="go"><a class="header" href="#go">Go</a></h1>
<p>在 WasmEdge 中运行 Go 程序的最佳方式是使用 <a href="https://tinygo.org/">TinyGo</a> 将 Go 源代码编译为 WebAssembly。在本文中，我们将向你展示如何操作。</p>
<h2 id="安装-tinygo"><a class="header" href="#安装-tinygo">安装 TinyGo</a></h2>
<p>在安装 TinyGo 之前，你的机器上必须已经安装了 <a href="https://go.dev/doc/install">Go</a>。建议使用 Go v1.17 或更高版本。
对于 x86 处理器上的 Ubuntu 或其他基于 Debian 的 Linux 系统，你可以使用以下命令行来安装 TinyGo。其他平台请参考 <a href="https://tinygo.org/getting-started/install/">TinyGo 文档</a>。</p>
<pre><code class="language-bash">wget https://github.com/tinygo-org/tinygo/releases/download/v0.21.0/tinygo_0.21.0_amd64.deb
sudo dpkg -i tinygo_0.21.0_amd64.deb`
</code></pre>
<p>接下来，运行以下命令行检查是否安装成功。</p>
<pre><code class="language-bash">$ tinygo version
tinygo version 0.21.0 linux/amd64 (using go version go1.16.7 and LLVM version 11.0.0)
</code></pre>
<h2 id="hello-world-2"><a class="header" href="#hello-world-2">Hello world</a></h2>
<p>以下是个简单的 Go 应用程序，<code>main()</code> 函数主要用来向控制台打印一条消息。
<code>main.go</code> 文件中的源代码如下：</p>
<pre><code class="language-go">package main

func main() {
  println(&quot;Hello TinyGo from WasmEdge!&quot;)
}
</code></pre>
<blockquote>
<p>在 <code>main()</code> 函数中，你可以使用 Go 标准 API 读取/写入文件，以及访问命令行参数和 <code>env</code> 变量。</p>
</blockquote>
<h3 id="hello-world编译和构建"><a class="header" href="#hello-world编译和构建">Hello world：编译和构建</a></h3>
<p>接下来，使用 TinyGo 将 <code>main.go</code> 程序编译为 WebAssembly。</p>
<pre><code class="language-bash">tinygo build -o hello.wasm -target wasi main.go
</code></pre>
<p>你将在同一目录中看到一个名为 <code>hello.wasm</code> 的文件。这是一个 WebAssembly 字节码文件。</p>
<h3 id="hello-world运行"><a class="header" href="#hello-world运行">Hello world：运行</a></h3>
<p>你可以使用 <a href="dev/../start/cli.html">WasmEdge命令行</a> 运行。</p>
<pre><code class="language-bash">$ wasmedge hello.wasm
Hello TinyGo from WasmEdge!
</code></pre>
<h2 id="一个简单的函数-1"><a class="header" href="#一个简单的函数-1">一个简单的函数</a></h2>
<p>第二个例子是一个 Go 函数，输入一个参数，计算一个斐波那契数。但是，为了让 Go 应用程序设置对操作系统的正确权限（例如，获得命令行参数的权限），你必须在源代码中包含一个空的 <code>main()</code> 函数。</p>
<pre><code class="language-go">package main

func main(){
}

//export fibArray
func fibArray(n int32) int32{
  arr := make([]int32, n)
  for i := int32(0); i &lt; n; i++ {
    switch {
    case i &lt; 2:
      arr[i] = i
    default:
      arr[i] = arr[i-1] + arr[i-2]
    }
  }
  return arr[n-1]
}
</code></pre>
<h3 id="一个简单的函数编译和构建"><a class="header" href="#一个简单的函数编译和构建">一个简单的函数：编译和构建</a></h3>
<p>接下来，使用 TinyGo 将 <code>main.go</code> 程序编译为 WebAssembly。</p>
<pre><code class="language-bash">tinygo build -o fib.wasm -target wasi main.go
</code></pre>
<p>你将在同一目录中看到一个名为 <code>fib.wasm</code> 的文件。这是一个 WebAssembly 字节码文件。</p>
<h3 id="一个简单的函数运行"><a class="header" href="#一个简单的函数运行">一个简单的函数：运行</a></h3>
<p>你可以使用 <a href="dev/../start/cli.html">WasmEdge命令行</a> 在其 <code>--reactor</code> 模式下运行它。
<code>wasm</code> 文件后面的命令行参数是函数名及其调用参数。</p>
<pre><code class="language-bash">$ wasmedge --reactor fib.wasm fibArray 10
34
</code></pre>
<h2 id="性能提升"><a class="header" href="#性能提升">性能提升</a></h2>
<p>要为这些应用程序达到原生 Go 性能，你可以使用 <code>wasmedgec</code> 命令来 AOT 编译 <code>wasm</code> 程序，然后使用 <code>wasmedge</code> 命令运行它。</p>
<pre><code class="language-bash">$ wasmedgec hello.wasm hello.wasm

$ wasmedge hello.wasm
Hello TinyGo from WasmEdge!
</code></pre>
<p>对于 <code>--reactor</code> 模式，</p>
<pre><code class="language-bash">$ wasmedgec fib.wasm fib.wasm

$ wasmedge --reactor fib.wasm fibArray 10
34
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="swift"><a class="header" href="#swift">Swift</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="assemblyscript"><a class="header" href="#assemblyscript">AssemblyScript</a></h1>
<p><a href="https://www.assemblyscript.org/">AssemblyScript</a> 是一种为 WebAssembly 设计的类 TypeScript 语言。 AssemblyScript 程序可以很容易地编译成 WebAssembly。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="kotlin"><a class="header" href="#kotlin">Kotlin</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="grain"><a class="header" href="#grain">Grain</a></h1>
<p><a href="https://grain-lang.org/">Grain</a> 是为 WebAssembly 设计的强类型语言。 查看它的 <a href="https://grain-lang.org/docs/guide/hello_world">Hello world</a> 示例。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="嵌入-wasmedge-函数"><a class="header" href="#嵌入-wasmedge-函数">嵌入 WasmEdge 函数</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="wasmedge-c-sdk"><a class="header" href="#wasmedge-c-sdk">WasmEdge C SDK</a></h1>
<p>文档 <a href="https://github.com/WasmEdge/WasmEdge/blob/master/include/api/wasmedge/wasmedge.h">WasmEdge C API</a> 里提供了访问 WasmEdge 运行时的接口。以下内容是关于如何使用 WasmEdge C API 的简单说明。如果要了解 WasmEdge C API 的更多细节，请参考<a href="embed/c/ref.html">完整的文档</a>。</p>
<h2 id="wasmedge-运行时快速指南"><a class="header" href="#wasmedge-运行时快速指南">WasmEdge 运行时快速指南</a></h2>
<p>以下是运行一个 WASM 文件的示例。
假设 WASM 文件<a href="https://github.com/WasmEdge/WasmEdge/raw/master/examples/wasm/fibonacci.wasm"><code>fibonacci.wasm</code></a>已经被拷贝到当前目录，并且 C 文件 <code>test_wasmedge.c</code> 的源代码如下所示：</p>
<pre><code class="language-c">#include &lt;wasmedge/wasmedge.h&gt;
#include &lt;stdio.h&gt;
int main(int Argc, const char* Argv[]) {
  /* 创建配置上下文以及 WASI 支持。 */
  /* 除非你需要使用 WASI，否则这步不是必须的。 */
  WasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();
  WasmEdge_ConfigureAddHostRegistration(ConfCxt, WasmEdge_HostRegistration_Wasi);
  /* 创建VM的时候可以提供空的配置。*/
  WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(ConfCxt, NULL);

  /* 参数以及返回的数组。 */
  WasmEdge_Value Params[1] = { WasmEdge_ValueGenI32(32) };
  WasmEdge_Value Returns[1];
  /* 要调用的函数名。 */
  WasmEdge_String FuncName = WasmEdge_StringCreateByCString(&quot;fib&quot;);
  /* 运行文件里的 WASM 函数。 */
  WasmEdge_Result Res = WasmEdge_VMRunWasmFromFile(VMCxt, Argv[1], FuncName, Params, 1, Returns, 1);

  if (WasmEdge_ResultOK(Res)) {
    printf(&quot;Get result: %d\n&quot;, WasmEdge_ValueGetI32(Returns[0]));
  } else {
    printf(&quot;Error message: %s\n&quot;, WasmEdge_ResultGetMessage(Res));
  }

  /* 资源析构。 */
  WasmEdge_VMDelete(VMCxt);
  WasmEdge_ConfigureDelete(ConfCxt);
  WasmEdge_StringDelete(FuncName);
  return 0;
}
</code></pre>
<p>接下来你可以编译并且运行它：（索引从 0 开始的情况下，斐波那契数列的的第 32 个数值是 3524578 ）</p>
<pre><code class="language-bash">$ gcc test_wasmedge.c -lwasmedge -o test_wasmedge
$ ./test_wasmedge fibonacci.wasm
Get result: 3524578
</code></pre>
<p>如果要了解 API 的细节，请参考 <a href="https://github.com/WasmEdge/WasmEdge/blob/master/include/api/wasmedge/wasmedge.h">API 头文件</a>.</p>
<h2 id="wasmedge-aot-编译器快速指南"><a class="header" href="#wasmedge-aot-编译器快速指南">WasmEdge AOT 编译器快速指南</a></h2>
<p>假设 WASM 文件 <a href="https://github.com/WasmEdge/WasmEdge/raw/master/examples/wasm/fibonacci.wasm"><code>fibonacci.wasm</code></a> 已经被拷贝到当前目录，并且 C 文件 <code>test_wasmedge_compiler.c</code> 的代码如下所示：</p>
<pre><code class="language-c">#include &lt;wasmedge/wasmedge.h&gt;
#include &lt;stdio.h&gt;
int main(int Argc, const char* Argv[]) {
  /* 创建配置上下文。 */
  WasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();
  /* ... 通过配置上下文调整配置。 */
  /* 结果。 */
  WasmEdge_Result Res;

  /* 创建编译器上下文。配置上下文可以为空。 */
  WasmEdge_CompilerContext *CompilerCxt = WasmEdge_CompilerCreate(ConfCxt);
  /* 根据指定的输入和输出路径来编译 WASM 文件。 */
  Res = WasmEdge_CompilerCompile(CompilerCxt, Argv[1], Argv[2]);
  if (!WasmEdge_ResultOK(Res)) {
    printf(&quot;Compilation failed: %s\n&quot;, WasmEdge_ResultGetMessage(Res));
    return 1;
  }

  WasmEdge_CompilerDelete(CompilerCxt);
  WasmEdge_ConfigureDelete(ConfCxt);
  return 0;
}
</code></pre>
<p>接下来你可以编译和运行它（输出的文件是 &quot;fibonacci.wasm.so&quot; ）：</p>
<pre><code class="language-bash">$ gcc test_wasmedge_compiler.c -lwasmedge -o test_wasmedge_compiler
$ ./test_wasmedge_compiler fibonacci.wasm fibonacci.wasm.so
[2021-07-02 11:08:08.651] [info] compile start
[2021-07-02 11:08:08.653] [info] verify start
[2021-07-02 11:08:08.653] [info] optimize start
[2021-07-02 11:08:08.670] [info] codegen start
[2021-07-02 11:08:08.706] [info] compile done
</code></pre>
<p>编译后的的 WASM 文件也可以直接作为 WasmEdge 运行时的输入。
以下是解释模式和 AOT 模式的一个对比：</p>
<pre><code class="language-bash">$ time ./test_wasmedge fibonacci.wasm
Get result: 5702887

real 0m2.715s
user 0m2.700s
sys 0m0.008s

$ time ./test_wasmedge fibonacci.wasm.so
Get result: 5702887

real 0m0.036s
user 0m0.022s
sys 0m0.011s
</code></pre>
<p>如果要了解这些 API 的细节，请参考<a href="https://github.com/WasmEdge/WasmEdge/blob/master/include/api/wasmedge/wasmedge.h">API 头文件</a>。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="api-references"><a class="header" href="#api-references">API references</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="wasmedge-go-sdk"><a class="header" href="#wasmedge-go-sdk">WasmEdge Go SDK</a></h1>
<p>这是一份如何使用 WasmEdge Go API 的指南。你可以通过 WasmEdge Go API 将 WasmEdge 嵌入在你的 Go 应用程序中。</p>
<h2 id="快速开始-2"><a class="header" href="#快速开始-2">快速开始</a></h2>
<p>WasmEdge-go 要求 Go 语言版本 &gt;= 1.16。在安装之前请检查你的 Go 语言版本。你可以<a href="https://golang.org/dl/">从这里下载 Go 语言</a>。</p>
<pre><code class="language-bash">$ go version
go version go1.16.5 linux/amd64
</code></pre>
<p>同时，请确保你已经安装了和 <code>WasmEdge-go</code> 同一发布版本的 <a href="embed/../start/install.html">WasmEdge 共享库</a>。</p>
<pre><code class="language-bash">curl -sSf https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/utils/install.sh | bash -s -- -v 0.10.0
</code></pre>
<p>如果你需要 <code>WasmEdge-go</code> 的 <code>TensorFlow</code> 或 <code>Image</code> 扩展，请安装带有这些扩展的 <code>WasmEdge</code> ：</p>
<pre><code class="language-bash">curl -sSf https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/utils/install.sh | bash -s -- -v 0.10.0 -e tensorflow,image
</code></pre>
<p>注意 <code>TensorFlow</code> 和 <code>Image</code> 扩展仅支持 <code>Linux</code> 平台。</p>
<p>安装 <code>WasmEdge-go</code> 包并在你的 Go 项目目录下构建：</p>
<pre><code class="language-bash">go get github.com/second-state/WasmEdge-go/wasmedge@v0.10.0
go build
</code></pre>
<h2 id="wasmedge-go-扩展"><a class="header" href="#wasmedge-go-扩展">WasmEdge-go 扩展</a></h2>
<p>默认情况下， <code>WasmEdge-go</code> 只打开基本运行时。</p>
<p><code>WasmEdge-go</code> 有以下扩展：</p>
<ul>
<li>
<p>TensorFlow</p>
<ul>
<li>
<p>该扩展支持 <a href="https://github.com/second-state/WasmEdge-tensorflow">WasmEdge-tensorflow</a> 中的 host 函数。</p>
</li>
<li>
<p>若要安装 <code>tensorflow</code> 扩展。请在 WasmEdge 安装器命令中使用 <code>-e tensorflow</code> 标志。</p>
</li>
<li>
<p>若使用该扩展，在构建时需要打上 <code>tensorflow</code> 标签：</p>
<pre><code class="language-bash">go build -tags tensorflow
</code></pre>
</li>
</ul>
</li>
<li>
<p>Image</p>
<ul>
<li>
<p>该扩展支持 <a href="https://github.com/second-state/WasmEdge-image">WasmEdge-image</a> 中的 host 函数。</p>
</li>
<li>
<p>若要安装 <code>image</code> 扩展。请在 WasmEdge 安装器命令中使用 <code>-e image</code> 标志。</p>
</li>
<li>
<p>若使用该扩展，在构建时需要打上 <code>image</code> 标签：</p>
<pre><code class="language-bash">go build -tags image
</code></pre>
</li>
</ul>
</li>
</ul>
<p>你也可以在构建的时候打开多个扩展：</p>
<pre><code class="language-bash">go build -tags image,tensorflow
</code></pre>
<p>有关示例，请参考 <a href="https://github.com/second-state/WasmEdge-go-examples/">示例仓库</a>。</p>
<h3 id="go-中的-wasmedge-aot-编译器"><a class="header" href="#go-中的-wasmedge-aot-编译器">Go 中的 WasmEdge AOT 编译器</a></h3>
<p><a href="https://github.com/second-state/WasmEdge-go-examples/tree/master/go_WasmAOT">go_WasmAOT 示例</a> 演示了如何通过一个 Go 应用程序将一个 WASM 文件编译成本机二进制文件（AOT 编译）。</p>
<h2 id="相关示例"><a class="header" href="#相关示例">相关示例</a></h2>
<ul>
<li><a href="embed/go/app.html">嵌入一个独立的 Wasm 应用</a></li>
<li><a href="embed/go/function.html">嵌入一个 Wasm 函数</a></li>
<li><a href="embed/go/memory.html">将复杂的参数传递到 Wasm 函数</a></li>
<li><a href="embed/go/tensorflow.html">嵌入一个 Tensorflow 推理函数</a></li>
<li><a href="embed/go/bindgen.html">嵌入一个 bindgen 函数</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="嵌入-wasm-应用程序"><a class="header" href="#嵌入-wasm-应用程序">嵌入 WASM 应用程序</a></h1>
<p>WasmEdge Go SDK 能<a href="https://github.com/second-state/WasmEdge-go-examples/tree/master/go_ReadFile">嵌入单独的 WebAssembly 应用程序</a> — 比如，一个带着 <code>main()</code> 函数，编译成 WebAssembly 的 Rust 应用程序。</p>
<p>我们的 <a href="https://github.com/second-state/WasmEdge-go-examples/tree/master/go_ReadFile/rust_readfile">demo Rust 应用程序</a>从一个文件中读取内容。注意，WebAssembly 程序的输入和输出数据现在是通过 STDIN 和 STDOUT 传递的。</p>
<pre><pre class="playground"><code class="language-rust">use std::env;
use std::fs::File;
use std::io::{self, BufRead};

fn main() {
  // 获取参数。
  let args: Vec&lt;String&gt; = env::args().collect();
  if args.len() &lt;= 1 {
    println!(&quot;Rust: ERROR - No input file name.&quot;);
    return;
  }

  // 打开文件。
  println!(&quot;Rust: Opening input file \&quot;{}\&quot;...&quot;, args[1]);
  let file = match File::open(&amp;args[1]) {
    Err(why) =&gt; {
      println!(&quot;Rust: ERROR - Open file \&quot;{}\&quot; failed: {}&quot;, args[1], why);
      return;
    },
    Ok(file) =&gt; file,
  };

  // 按行读取文件内容。
  let reader = io::BufReader::new(file);
  let mut texts:Vec&lt;String&gt; = Vec::new();
  for line in reader.lines() {
    if let Ok(text) = line {
      texts.push(text);
    }
  }
  println!(&quot;Rust: Read input file \&quot;{}\&quot; succeeded.&quot;, args[1]);

  // 获取 stdin 来打印内容。
  println!(&quot;Rust: Please input the line number to print the line of file.&quot;);
  let stdin = io::stdin();
  for line in stdin.lock().lines() {
    let input = line.unwrap();
    match input.parse::&lt;usize&gt;() {
      Ok(n) =&gt; if n &gt; 0 &amp;&amp; n &lt;= texts.len() {
        println!(&quot;{}&quot;, texts[n - 1]);
      } else {
        println!(&quot;Rust: ERROR - Line \&quot;{}\&quot; is out of range.&quot;, n);
      },
      Err(e) =&gt; println!(&quot;Rust: ERROR - Input \&quot;{}\&quot; is not an integer: {}&quot;, input, e),
    }
  }
  println!(&quot;Rust: Process end.&quot;);
}
</code></pre></pre>
<p>将应用程序编译成 WebAssembly。</p>
<pre><code class="language-bash">$ cd rust_readfile
$ cargo build --target wasm32-wasi
# 输出文件是 target/wasm32-wasi/debug/rust_readfile.wasm
</code></pre>
<p>我们在 Go 程序里面嵌入 WasmEdge 运行 WebAssembly 函数，这个 Go 程序源代码如下。</p>
<pre><code class="language-go">package main

import (
  &quot;os&quot;
  &quot;github.com/second-state/WasmEdge-go/wasmedge&quot;
)

func main() {
  wasmedge.SetLogErrorLevel()

  var conf = wasmedge.NewConfigure(wasmedge.REFERENCE_TYPES)
  conf.AddConfig(wasmedge.WASI)
  var vm = wasmedge.NewVMWithConfig(conf)
  var wasi = vm.GetImportModule(wasmedge.WASI)
  wasi.InitWasi(
    os.Args[1:],     // 参数
    os.Environ(),    // 环境变量
    []string{&quot;.:.&quot;}, // 目录映射
  )

  // 实例化 wasm。_start 指的是 wasm 程序的 main() 函数
  vm.RunWasmFile(os.Args[1], &quot;_start&quot;)

  vm.Release()
  conf.Release()
}
</code></pre>
<p>接下来，让我们用 WasmEdge Go SDK 构建 Go 应用程序。</p>
<pre><code class="language-bash">go get github.com/second-state/WasmEdge-go/wasmedge@v0.10.0
go build
</code></pre>
<p>运行 Golang 应用程序。</p>
<pre><code class="language-bash">$ ./read_file rust_readfile/target/wasm32-wasi/debug/rust_readfile.wasm file.txt
Rust: Opening input file &quot;file.txt&quot;...
Rust: Read input file &quot;file.txt&quot; succeeded.
Rust: Please input the line number to print the line of file.
# 输入 &quot;5&quot; 然后按下 Enter。
5
# `file.txt` 文件的第 5 行内容将被输出：
abcDEF___!@#$%^
# 要停止程序，发送 EOF (Ctrl + D)。
^D
# 输出将会打印停止信息：
Rust: Process end.
</code></pre>
<p>更多的例子可以在 <a href="https://github.com/second-state/WasmEdge-go-examples">WasmEdge-go-examples GitHub 仓库</a> 中找到。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="嵌入-wasm-函数"><a class="header" href="#嵌入-wasm-函数">嵌入 Wasm 函数</a></h1>
<p>WasmEdge Go SDK 允许将 WebAssembly 函数嵌入到一个 Go 主程序。可以使用 Go SDK API 来传递调用参数到嵌入的 WebAssembly 函数，然后捕获返回值。</p>
<p>然而，WebAssembly 规范本身只支持一些简单数据类型。 它<a href="https://medium.com/wasm/strings-in-webassembly-wasm-57a05c1ea333">不支持</a> 字符串和数组等类型。 为了将 Go 中的丰富类型传递给 WebAssembly，我们可以手动编码内存指针（<a href="embed/go/memory.html">点击这里</a>），或者使用管理数据交换的自动化工具。</p>
<p><a href="https://github.com/second-state/wasmedge-bindgen">wasmedge-bindgen</a> 项目为函数提供了 Rust 宏来接受和返回复杂的数据类型，然后让 Go 函数调用在 WasmEdge 中运行的此类 Rust 函数。
本章中演示的完整源代码 <a href="https://github.com/second-state/WasmEdge-go-examples/tree/master/wasmedge-bindgen/go_BindgenFuncs">可在此处获得</a>。</p>
<h2 id="将-rust-函数编译成-webassembly"><a class="header" href="#将-rust-函数编译成-webassembly">将 Rust 函数编译成 WebAssembly</a></h2>
<p>在 <a href="https://github.com/second-state/WasmEdge-go-examples/tree/master/wasmedge-bindgen/go_BindgenFuncs/rust_bindgen_funcs">Rust 项目</a> 中，你只需要用 “[wasmedge_bindgen] ”宏来注释 [你的函数](https ://github.com/second-state/WasmEdge-go-examples/blob/master/wasmedge-bindgen/go_BindgenFuncs/rust_bindgen_funcs/src/lib.rs) 。
这些带注释的函数将由 Rust 编译器自动检测并转换为可以从 <code>wasmedge-bindgen</code> GO SDK 调用的 WebAssembly 函数。
在下面的示例中，我们有几个 Rust 函数可以进行复杂的调用参数并返回复杂值。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use wasmedge_bindgen::*;
use wasmedge_bindgen_macro::*;
use num_integer::lcm;
use sha3::{Digest, Sha3_256, Keccak256};
use serde::{Serialize, Deserialize};

#[derive(Serialize, Deserialize, Debug)]
struct Point {
  x: f32,
  y: f32
}

#[derive(Serialize, Deserialize, Debug)]
struct Line {
  points: Vec&lt;Point&gt;,
  valid: bool,
  length: f32,
  desc: String
}

#[wasmedge_bindgen]
pub fn create_line(p1: String, p2: String, desc: String) -&gt; Result&lt;Vec&lt;u8&gt;, String&gt; {
  let point1: Point = serde_json::from_str(p1.as_str()).unwrap();
  let point2: Point = serde_json::from_str(p2.as_str()).unwrap();
  let length = ((point1.x - point2.x) * (point1.x - point2.x) + (point1.y - point2.y) * (point1.y - point2.y)).sqrt();

  let valid = if length == 0.0 { false } else { true };

  let line = Line { points: vec![point1, point2], valid: valid, length: length, desc: desc };

  return Ok(serde_json::to_vec(&amp;line).unwrap());
}

#[wasmedge_bindgen]
pub fn say(s: String) -&gt; Result&lt;Vec&lt;u8&gt;, String&gt; {
  let r = String::from(&quot;hello &quot;);
  return Ok((r + s.as_str()).as_bytes().to_vec());
}

#[wasmedge_bindgen]
pub fn obfusticate(s: String) -&gt; Result&lt;Vec&lt;u8&gt;, String&gt; {
  let r: String = (&amp;s).chars().map(|c| {
    match c {
      'A' ..= 'M' | 'a' ..= 'm' =&gt; ((c as u8) + 13) as char,
      'N' ..= 'Z' | 'n' ..= 'z' =&gt; ((c as u8) - 13) as char,
      _ =&gt; c
    }
  }).collect();
  Ok(r.as_bytes().to_vec())
}

#[wasmedge_bindgen]
pub fn lowest_common_multiple(a: i32, b: i32) -&gt; Result&lt;Vec&lt;u8&gt;, String&gt; {
  let r = lcm(a, b);
  return Ok(r.to_string().as_bytes().to_vec());
}

#[wasmedge_bindgen]
pub fn sha3_digest(v: Vec&lt;u8&gt;) -&gt; Result&lt;Vec&lt;u8&gt;, String&gt; {
  return Ok(Sha3_256::digest(&amp;v).as_slice().to_vec());
}

#[wasmedge_bindgen]
pub fn keccak_digest(s: Vec&lt;u8&gt;) -&gt; Result&lt;Vec&lt;u8&gt;, String&gt; {
  return Ok(Keccak256::digest(&amp;s).as_slice().to_vec());
}
<span class="boring">}
</span></code></pre></pre>
<p>你可以使用标准的 Cargo 命令构建 WebAssembly 字节码文件。</p>
<pre><code class="language-bash">$ cd rust_bindgen_funcs
$ cargo build --target wasm32-wasi --release

# 输出 WASM 将是 target/wasm32-wasi/release/rust_bindgen_funcs_lib.wasm.

$ cp target/wasm32-wasi/release/rust_bindgen_funcs_lib.wasm ../
$ cd ../
</code></pre>
<h2 id="go-host-程序"><a class="header" href="#go-host-程序">Go host 程序</a></h2>
<p>在 <a href="https://github.com/second-state/WasmEdge-go-examples/blob/master/wasmedge-bindgen/go_BindgenFuncs/bindgen_funcs.go">Go host 程序</a>中，你可以使用 WasmEdge Go SDK 创建和设置 WasmEdge VM。
但是，你现不应该调用 <code>vm.Instantiate()</code> 而应该调用<code>bindgen.Instantiate(vm)</code> 来实例化 VM 并返回 <code>bindgen</code> 对象。</p>
<pre><code class="language-go">func main() {
  // 预期的 Args[0]: 程序名 (./bindgen_funcs)
  // 预期的 Args[1]: wasm 文件 (rust_bindgen_funcs_lib.wasm))
  
  wasmedge.SetLogErrorLevel()
  var conf = wasmedge.NewConfigure(wasmedge.WASI)
  var vm = wasmedge.NewVMWithConfig(conf)
  var wasi = vm.GetImportModule(wasmedge.WASI)
  wasi.InitWasi(
    os.Args[1:],     // The args
    os.Environ(),    // The envs
    []string{&quot;.:.&quot;}, // The mapping preopens
  )
  vm.LoadWasmFile(os.Args[1])
  vm.Validate()

  // 实例化 bindgen 和 vm
  bg := bindgen.Instantiate(vm)
</code></pre>
<p>接下来，你可以通过 <code>bindgen</code> 对象调用 VM 中的任何 <code>[wasmedge_bindgen]</code> 注释函数。</p>
<pre><code class="language-go">  // create_line: string, string, string -&gt; string (输入已 JSON 字符串化)  
  res, err := bg.Execute(&quot;create_line&quot;, &quot;{\&quot;x\&quot;:2.5,\&quot;y\&quot;:7.8}&quot;, &quot;{\&quot;x\&quot;:2.5,\&quot;y\&quot;:5.8}&quot;, &quot;A thin red line&quot;)
  if err == nil {
    fmt.Println(&quot;Run bindgen -- create_line:&quot;, string(res))
  } else {
    fmt.Println(&quot;Run bindgen -- create_line FAILED&quot;, err)
  }

  // say: string -&gt; string
  res, err = bg.Execute(&quot;say&quot;, &quot;bindgen funcs test&quot;)
  if err == nil {
    fmt.Println(&quot;Run bindgen -- say:&quot;, string(res))
  } else {
    fmt.Println(&quot;Run bindgen -- say FAILED&quot;)
  }

  // obfusticate: string -&gt; string
  res, err = bg.Execute(&quot;obfusticate&quot;, &quot;A quick brown fox jumps over the lazy dog&quot;)
  if err == nil {
    fmt.Println(&quot;Run bindgen -- obfusticate:&quot;, string(res))
  } else {
    fmt.Println(&quot;Run bindgen -- obfusticate FAILED&quot;)
  }

  // lowest_common_multiple: i32, i32 -&gt; i32
  res, err = bg.Execute(&quot;lowest_common_multiple&quot;, int32(123), int32(2))
  if err == nil {
    num, _ := strconv.ParseInt(string(res), 10, 32)
    fmt.Println(&quot;Run bindgen -- lowest_common_multiple:&quot;, num)
  } else {
    fmt.Println(&quot;Run bindgen -- lowest_common_multiple FAILED&quot;)
  }

  // sha3_digest: array -&gt; array
  res, err = bg.Execute(&quot;sha3_digest&quot;, []byte(&quot;This is an important message&quot;))
  if err == nil {
    fmt.Println(&quot;Run bindgen -- sha3_digest:&quot;, res)
  } else {
    fmt.Println(&quot;Run bindgen -- sha3_digest FAILED&quot;)
  }

  // keccak_digest: array -&gt; array
  res, err = bg.Execute(&quot;keccak_digest&quot;, []byte(&quot;This is an important message&quot;))
  if err == nil {
    fmt.Println(&quot;Run bindgen -- keccak_digest:&quot;, res)
  } else {
    fmt.Println(&quot;Run bindgen -- keccak_digest FAILED&quot;)
  }

  bg.Release()
  vm.Release()
  conf.Release()
}
</code></pre>
<p>最后，你可以构建并运行 Go host 程序。</p>
<pre><code class="language-bash">go build
./bindgen_funcs rust_bindgen_funcs_lib.wasm
</code></pre>
<p>本示例的标准输出如下。</p>
<pre><code class="language-bash">Run bindgen -- create_line: {&quot;points&quot;:[{&quot;x&quot;:1.5,&quot;y&quot;:3.8},{&quot;x&quot;:2.5,&quot;y&quot;:5.8}],&quot;valid&quot;:true,&quot;length&quot;:2.2360682,&quot;desc&quot;:&quot;A thin red line&quot;}
Run bindgen -- say: hello bindgen funcs test
Run bindgen -- obfusticate: N dhvpx oebja sbk whzcf bire gur ynml qbt
Run bindgen -- lowest_common_multiple: 246
Run bindgen -- sha3_digest: [87 27 231 209 189 105 251 49 159 10 211 250 15 159 154 181 43 218 26 141 56 199 25 45 60 10 20 163 54 211 195 203]
Run bindgen -- keccak_digest: [126 194 241 200 151 116 227 33 216 99 159 22 107 3 177 169 216 191 114 156 174 193 32 159 246 228 245 133 52 75 55 27]
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="将复杂参数传递给-wasm-函数"><a class="header" href="#将复杂参数传递给-wasm-函数">将复杂参数传递给 Wasm 函数</a></h1>
<p>WebAssembly 规范的一个问题是它只支持非常有限的数据类型。如果要嵌入具有复杂调用参数或返回值的 WebAssembly 函数，则需要同时在 Go SDK 和 WebAssembly 函数端管理内存指针。此类复杂的调用参数和返回值包括字符串和字节数组等动态内存结构。在本节中，我们将讨论几个示例：</p>
<ul>
<li><a href="embed/go/memory.html#%E5%B0%86%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%BC%A0%E9%80%92%E7%BB%99-rust-%E5%87%BD%E6%95%B0">将字符串传递给 Rust 函数</a></li>
<li><a href="embed/go/memory.html#%E5%B0%86%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%BC%A0%E9%80%92%E7%BB%99-tinygo-%E5%87%BD%E6%95%B0">将字符串传递给 TinyGo 函数</a></li>
<li><a href="embed/go/memory.html#%E5%B0%86%E5%AD%97%E8%8A%82%E4%BC%A0%E9%80%92%E7%BB%99-rust-%E5%87%BD%E6%95%B0">将字节传递给 Rust 函数</a></li>
<li><a href="embed/go/memory.html#%E5%B0%86%E5%AD%97%E8%8A%82%E4%BC%A0%E9%80%92%E7%BB%99-tinygo-%E5%87%BD%E6%95%B0">将字节传递给 TinyGo 函数</a></li>
</ul>
<h2 id="将字符串传递给-rust-函数"><a class="header" href="#将字符串传递给-rust-函数">将字符串传递给 Rust 函数</a></h2>
<p>在<a href="https://github.com/second-state/WasmEdge-go-examples/tree/master/go_MemoryGreet">此示例</a>中，我们将演示如何从 Go 应用程序调用<a href="https://github.com/second-state/WasmEdge-go-examples/blob/master/go_MemoryGreet/rust_memory_greet/src/lib.rs">基于 Rust 的 WebAssembly 函数</a>。特别是，我们将讨论如何传递字符串数据。</p>
<blockquote>
<p>在 WebAssembly 中向 Rust 函数传递和返回复杂值的另一种方法是使用 <code>wasm-bindgen</code> 编译器工具。你可以在<a href="embed/go/bindgen.html">这里</a>了解更多。</p>
</blockquote>
<p>Rust 函数获取字符串的内存指针，并自己构造 Rust 字符串。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::ffi::{CStr, CString};
use std::mem;
use std::os::raw::{c_char, c_void};

#[no_mangle]
pub extern fn allocate(size: usize) -&gt; *mut c_void {
  let mut buffer = Vec::with_capacity(size);
  let pointer = buffer.as_mut_ptr();
  mem::forget(buffer);

  pointer as *mut c_void
}

#[no_mangle]
pub extern fn deallocate(pointer: *mut c_void, capacity: usize) {
  unsafe {
    let _ = Vec::from_raw_parts(pointer, 0, capacity);
  }
}

#[no_mangle]
pub extern fn greet(subject: *mut c_char) -&gt; *mut c_char {
  let subject = unsafe { CStr::from_ptr(subject).to_bytes().to_vec() };
  let mut output = b&quot;Hello, &quot;.to_vec();
  output.extend(&amp;subject);
  output.extend(&amp;[b'!']);

  unsafe { CString::from_vec_unchecked(output) }.into_raw()
}
<span class="boring">}
</span></code></pre></pre>
<p>使用标准 Rust 编译器工具将 Rust 源代码编译成 WebAssembly 字节码应用程序：</p>
<pre><code class="language-bash">cd rust_memory_greet
cargo build --target wasm32-wasi
# 输出的 WASM 将是 `target/wasm32-wasi/debug/rust_memory_greet_lib.wasm`.
</code></pre>
<p><a href="https://github.com/second-state/WasmEdge-go-examples/blob/master/go_MemoryGreet/greet_memory.go">Go SDK 应用程序</a>必须从 WasmEdge 虚拟机中调用 <code>allocate</code> 以获得一个指向字符串参数的指针。然后它将用这个指针调用 Rust 中的 <code>greet</code> 函数。在该函数返回后，Go 应用程序将调用 <code>deallocate</code> 来释放内存空间。</p>
<pre><code class="language-go">package main

import (
  &quot;fmt&quot;
  &quot;os&quot;
  &quot;strings&quot;

  &quot;github.com/second-state/WasmEdge-go/wasmedge&quot;
)

func main() {
  wasmedge.SetLogErrorLevel()
  conf := wasmedge.NewConfigure(wasmedge.WASI)
  store := wasmedge.NewStore()
  vm := wasmedge.NewVMWithConfigAndStore(conf, store)

  wasi := vm.GetImportModule(wasmedge.WASI)
  wasi.InitWasi(
    os.Args[1:],
    os.Environ(),
    []string{&quot;.:.&quot;},
  )

  err := vm.LoadWasmFile(os.Args[1])
  if err != nil {
    fmt.Println(&quot;failed to load wasm&quot;)
  }
  vm.Validate()
  vm.Instantiate()

  subject := &quot;WasmEdge&quot;
  lengthOfSubject := len(subject)

  // 为 subject 分配内存，并获得其指针
  // 包括一个字节，用于我们在下面添加的 NULL 结束符
  allocateResult, _ := vm.Execute(&quot;allocate&quot;, int32(lengthOfSubject+1))
  inputPointer := allocateResult[0].(int32)

  // 将 subject 写入内存
  mem := store.FindMemory(&quot;memory&quot;)
  memData, _ := mem.GetData(uint(inputPointer), uint(lengthOfSubject+1))
  copy(memData, subject)

  // C-字符串，以 NULL 结束
  memData[lengthOfSubject] = 0

  // 运行 `greet` 函数。给出指向 subject 的指针
  greetResult, _ := vm.Execute(&quot;greet&quot;, inputPointer)
  outputPointer := greetResult[0].(int32)

  pageSize := mem.GetPageSize()
  // 读取 `greet` 函数的结果
  memData, _ = mem.GetData(uint(0), uint(pageSize * 65536))
  nth := 0
  var output strings.Builder

  for {
    if memData[int(outputPointer) + nth] == 0 {
      break
    }

    output.WriteByte(memData[int(outputPointer) + nth])
    nth++
  }

  lengthOfOutput := nth

  fmt.Println(output.String())

  // 释放 subject 以及 output
  vm.Execute(&quot;deallocate&quot;, inputPointer, int32(lengthOfSubject+1))
  vm.Execute(&quot;deallocate&quot;, outputPointer, int32(lengthOfOutput+1))

  vm.Release()
  store.Release()
  conf.Release()
}
</code></pre>
<p>要构建 Go SDK 示例，请运行以下命令：</p>
<pre><code class="language-bash">go get github.com/second-state/WasmEdge-go/wasmedge@v0.10.0
go build greet_memory.go
</code></pre>
<p>现在你可以使用 Go 应用程序来运行从 Rust 编译的 WebAssembly 插件：</p>
<pre><code class="language-bash">$ ./greet_memory rust_memory_greet_lib.wasm
Hello, WasmEdge!
</code></pre>
<h2 id="将字符串传递给-tinygo-函数"><a class="header" href="#将字符串传递给-tinygo-函数">将字符串传递给 TinyGo 函数</a></h2>
<p>在<a href="https://github.com/second-state/WasmEdge-go-examples/tree/master/go_MemoryGreetTinyGo">此示例</a>中，我们将演示如何从 Go 应用程序调用<a href="https://github.com/second-state/WasmEdge-go-examples/blob/master/go_MemoryGreetTinyGo/greet.go">基于 TinyGo 的 WebAssembly 函数</a>。</p>
<p>TinyGo 函数获取字符串的内存指针，并自己构造 TinyGo 字符串。</p>
<blockquote>
<p>编译 WebAssembly 程序需要 <code>main()</code> 为空，才能正确设置 WASI。</p>
</blockquote>
<pre><code class="language-go">package main

import (
  &quot;strings&quot;
  &quot;unsafe&quot;
)

func main() {}

// 导出 greet
func greet(subject *int32) *byte {
  nth := 0
  var subjectStr strings.Builder
  pointer := uintptr(unsafe.Pointer(subject))
  for {
    s := *(*int32)(unsafe.Pointer(pointer + uintptr(nth)))
    if s == 0 {
      break;
    }

    subjectStr.WriteByte(byte(s))
    nth++
  }

  output := subjectStr.String()
  output = &quot;Hello, &quot; + output + &quot;!&quot;

  return &amp;(([]byte)(output)[0])
}
</code></pre>
<p>使用 TinyGo 编译器工具将 Go 源代码编译成 WebAssembly 字节码应用程序：</p>
<pre><code class="language-bash">tinygo build -o greet.wasm -target wasi greet.go
</code></pre>
<p><a href="https://github.com/second-state/WasmEdge-go-examples/blob/master/go_MemoryGreetTinyGo/greet_memory.go">Go SDK 应用程序</a>必须从 WasmEdge 虚拟机中调用 <code>malloc</code> 以获得一个指向字符串参数的指针。然后它将用这个指针调用 TinyGo 中的 <code>greet</code> 函数。在该函数返回后，Go 应用程序将调用 <code>free</code> 来释放内存空间。</p>
<pre><code class="language-go">package main

import (
  &quot;fmt&quot;
  &quot;os&quot;
  &quot;strings&quot;

  &quot;github.com/second-state/WasmEdge-go/wasmedge&quot;
)

func main() {
  wasmedge.SetLogErrorLevel()
  conf := wasmedge.NewConfigure(wasmedge.WASI)
  store := wasmedge.NewStore()
  vm := wasmedge.NewVMWithConfigAndStore(conf, store)

  wasi := vm.GetImportModule(wasmedge.WASI)
  wasi.InitWasi(
    os.Args[1:],
    os.Environ(),
    []string{&quot;.:.&quot;},
  )

  err := vm.LoadWasmFile(os.Args[1])
  if err != nil {
    fmt.Println(&quot;failed to load wasm&quot;)
  }
  vm.Validate()
  vm.Instantiate()

  subject := &quot;WasmEdge&quot;
  lengthOfSubject := len(subject)

  // 为 subject 分配内存，并获得其指针
  // 包括一个字节，用于我们在下面添加的 NULL 结束符
  allocateResult, _ := vm.Execute(&quot;malloc&quot;, int32(lengthOfSubject+1))
  inputPointer := allocateResult[0].(int32)

  // 将 subject 写入内存
  mem := store.FindMemory(&quot;memory&quot;)
  memData, _ := mem.GetData(uint(inputPointer), uint(lengthOfSubject+1))
  copy(memData, subject)

  // C-字符串，以 NULL 结束
  memData[lengthOfSubject] = 0

  // 运行 `greet` 函数。给出指向 subject 的指针
  greetResult, _ := vm.Execute(&quot;greet&quot;, inputPointer)
  outputPointer := greetResult[0].(int32)

  pageSize := mem.GetPageSize()
  // 读取 `greet` 函数的结果
  memData, _ = mem.GetData(uint(0), uint(pageSize * 65536))
  nth := 0
  var output strings.Builder

  for {
    if memData[int(outputPointer) + nth] == 0 {
      break
    }

    output.WriteByte(memData[int(outputPointer) + nth])
    nth++
  }

  fmt.Println(output.String())

  // 释放 subject 以及 output
  vm.Execute(&quot;free&quot;, inputPointer)
  vm.Execute(&quot;free&quot;, outputPointer)

  vm.Release()
  store.Release()
  conf.Release()
}
</code></pre>
<p>要构建 Go SDK 示例，请运行以下命令：</p>
<pre><code class="language-bash">go get github.com/second-state/WasmEdge-go/wasmedge@v0.10.0
go build greet_memory.go
</code></pre>
<p>现在你可以使用 Go 应用程序运行从 TinyGo 编译的 WebAssembly 插件：</p>
<pre><code class="language-bash">$ ./greet_memory greet.wasm
Hello, WasmEdge!
</code></pre>
<h2 id="将字节传递给-rust-函数"><a class="header" href="#将字节传递给-rust-函数">将字节传递给 Rust 函数</a></h2>
<p>在<a href="https://github.com/second-state/WasmEdge-go-examples/tree/master/go_AccessMemory">此示例</a>中，我们将演示如何调用<a href="https://github.com/second-state/WasmEdge-go-examples/blob/master/go_AccessMemory/rust_access_memory/src/lib.rs">基于 Rust 的 WebAssembly 函数</a>，并在 Go 应用程序中传入和传出数组。</p>
<blockquote>
<p>在 WebAssembly 中向 Rust 函数传递和返回复杂值的另一种方法是使用 <code>wasm-bindgen</code> 编译器工具。你可以在<a href="embed/go/bindgen.html">这里</a>了解更多。</p>
</blockquote>
<p><code>fib_array()</code> 函数将一个数组作为调用参数，并用斐波那契数列填充它。或者，<code>fib_array_return_memory()</code> 函数返回一个斐波那契数列数组。</p>
<p>对于调用参数中的数组，Rust 函数 <code>fib_array()</code> 需要一个内存指针并使用 <code>from_raw_parts</code> 构造 Rust <code>Vec</code>。对于数组的返回值，Rust 函数 <code>fib_array_return_memory()</code> 只是返回指针。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::mem;
use std::os::raw::{c_void, c_int};

#[no_mangle]
pub extern fn allocate(size: usize) -&gt; *mut c_void {
  let mut buffer = Vec::with_capacity(size);
  let pointer = buffer.as_mut_ptr();
  mem::forget(buffer);

  pointer as *mut c_void
}

#[no_mangle]
pub extern fn deallocate(pointer: *mut c_void, capacity: usize) {
  unsafe {
    let _ = Vec::from_raw_parts(pointer, 0, capacity);
  }
}

#[no_mangle]
pub extern fn fib_array(n: i32, p: *mut c_int) -&gt; i32 {
  unsafe {
    let mut arr = Vec::&lt;i32&gt;::from_raw_parts(p, 0, (4*n) as usize);
    for i in 0..n {
      if i &lt; 2 {
        arr.push(i);
      } else {
        arr.push(arr[(i - 1) as usize] + arr[(i - 2) as usize]);
      }
    }
    let r = arr[(n - 1) as usize];
    mem::forget(arr);
    r
  }
}

#[no_mangle]
pub extern fn fib_array_return_memory(n: i32) -&gt; *mut c_int {
  let mut arr = Vec::with_capacity((4 * n) as usize);
  let pointer = arr.as_mut_ptr();
  for i in 0..n {
    if i &lt; 2 {
      arr.push(i);
    } else {
      arr.push(arr[(i - 1) as usize] + arr[(i - 2) as usize]);
    }
  }
  mem::forget(arr);
  pointer
}
<span class="boring">}
</span></code></pre></pre>
<p>使用标准 Rust 编译器工具将 Rust 源代码编译成 WebAssembly 字节码应用程序：</p>
<pre><code class="language-bash">cd rust_access_memory
cargo build --target wasm32-wasi
# 输出的 WASM 将是 target/wasm32-wasi/debug/rust_access_memory_lib.wasm.
</code></pre>
<p><a href="https://github.com/second-state/WasmEdge-go-examples/blob/master/go_AccessMemory/run.go">Go SDK 应用程序</a>必须从 WasmEdge 虚拟机中调用 <code>allocate</code> ，以获得一个指向数组的指针。然后它将调用 Rust 中的<code>fib_array()</code>函数并传入指针。在函数返回后，Go 应用程序将使用 WasmEdge 的 <code>store</code> API，从调用参数（ <code>fib_array()</code> ）或返回值（ <code>fib_array_return_memory()</code> ）中的指针构建一个数组。Go 应用最终会调用 <code>deallocate</code> 来释放内存空间。</p>
<pre><code class="language-go">package main

import (
  &quot;fmt&quot;
  &quot;os&quot;
  &quot;unsafe&quot;

  &quot;github.com/second-state/WasmEdge-go/wasmedge&quot;
)

func main() {
  wasmedge.SetLogErrorLevel()
  conf := wasmedge.NewConfigure(wasmedge.WASI)
  store := wasmedge.NewStore()
  vm := wasmedge.NewVMWithConfigAndStore(conf, store)

  wasi := vm.GetImportModule(wasmedge.WASI)
  wasi.InitWasi(
    os.Args[1:],
    os.Environ(),
    []string{&quot;.:.&quot;},
  )

  err := vm.LoadWasmFile(os.Args[1])
  if err != nil {
    fmt.Println(&quot;failed to load wasm&quot;)
  }
  vm.Validate()
  vm.Instantiate()

  n := int32(10)

  p, err := vm.Execute(&quot;allocate&quot;, 4 * n)
  if err != nil {
    fmt.Println(&quot;allocate failed:&quot;, err)
  }

  fib, err := vm.Execute(&quot;fib_array&quot;, n, p[0])
  if err != nil {
    fmt.Println(&quot;fib_rray failed:&quot;, err)
  } else {
    fmt.Println(&quot;fib_array() returned:&quot;, fib[0])
    fmt.Printf(&quot;fib_array memory at: %p\n&quot;, unsafe.Pointer((uintptr)(p[0].(int32))))
    mem := store.FindMemory(&quot;memory&quot;)
    if mem != nil {
      // int32 占用 4 个字节
      fibArray, err := mem.GetData(uint(p[0].(int32)), uint(n * 4))
      if err == nil &amp;&amp; fibArray != nil {
        fmt.Println(&quot;fibArray:&quot;, fibArray)
      }
    }
  }

  fibP, err := vm.Execute(&quot;fib_array_return_memory&quot;, n)
  if err != nil {
    fmt.Println(&quot;fib_array_return_memory failed:&quot;, err)
  } else {
    fmt.Printf(&quot;fib_array_return_memory memory at: %p\n&quot;, unsafe.Pointer((uintptr)(fibP[0].(int32))))
    mem := store.FindMemory(&quot;memory&quot;)
    if mem != nil {
      // int32 占用 4 个字节
      fibArrayReturnMemory, err := mem.GetData(uint(fibP[0].(int32)), uint(n * 4))
      if err == nil &amp;&amp; fibArrayReturnMemory != nil {
        fmt.Println(&quot;fibArrayReturnMemory:&quot;, fibArrayReturnMemory)
      }
    }
  }

  _, err = vm.Execute(&quot;deallocate&quot;, p[0].(int32), 4 * n)
  if err != nil {
    fmt.Println(&quot;free failed:&quot;, err)
  }


  exitcode := wasi.WasiGetExitCode()
  if exitcode != 0 {
    fmt.Println(&quot;Go: Running wasm failed, exit code:&quot;, exitcode)
  }

  vm.Release()
  store.Release()
  conf.Release()
}
</code></pre>
<p>为了构建 Go SDK 示例，请运行以下命令：</p>
<pre><code class="language-bash">go get github.com/second-state/WasmEdge-go/wasmedge@v0.10.0
go build run.go
</code></pre>
<p>现在你可以使用 Go 应用程序运行从 Rust 编译的 WebAssembly 插件：</p>
<pre><code class="language-bash">$ ./run rust_access_memory_lib.wasm
fib_array() returned: 34
fib_array memory at: 0x102d80
fibArray: [0 0 0 0 1 0 0 0 1 0 0 0 2 0 0 0 3 0 0 0 5 0 0 0 8 0 0 0 13 0 0 0 21 0 0 0 34 0 0 0]
fib_array_return_memory memory at: 0x105430
fibArrayReturnMemory: [0 0 0 0 1 0 0 0 1 0 0 0 2 0 0 0 3 0 0 0 5 0 0 0 8 0 0 0 13 0 0 0 21 0 0 0 34 0 0 0]
</code></pre>
<h2 id="将字节传递给-tinygo-函数"><a class="header" href="#将字节传递给-tinygo-函数">将字节传递给 TinyGo 函数</a></h2>
<p>在<a href="https://github.com/second-state/WasmEdge-go-examples/tree/master/go_AccessMemoryTinyGo">此示例</a>中，我们将演示如何调用<a href="https://github.com/second-state/WasmEdge-go-examples/blob/master/go_AccessMemoryTinyGo/fib.go">基于 TinyGo 的 WebAssembly 函数</a>以及将数组传入和传出 Go 应用程序。</p>
<p>函数 <code>fibArray</code> 接收一个数组作为调用参数，并将其填入一个斐波那契数列。或者，<code>fibArrayReturnMemory</code> 函数返回斐波那契数列的数组。</p>
<pre><code class="language-go">package main

import (
  &quot;fmt&quot;
  &quot;unsafe&quot;
)

func main() {
  println(&quot;in main&quot;)
  n := int32(10)
  arr := make([]int32, n)
  arrP := &amp;arr[0]
  fmt.Printf(&quot;call fibArray(%d, %p) = %d\n&quot;, n, arrP, fibArray(n, arrP))
  fmt.Printf(&quot;call fibArrayReturnMemory(%d) return %p\n&quot;, n, fibArrayReturnMemory(n))
}

// 导出 fibArray
func fibArray(n int32, p *int32) int32 {
  arr := unsafe.Slice(p, n)
  for i := int32(0); i &lt; n; i++ {
    switch {
    case i &lt; 2:
      arr[i] = i
    default:
      arr[i] = arr[i-1] + arr[i-2]
    }
  }
  return arr[n-1]
}

// 导出 fibArrayReturnMemory
func fibArrayReturnMemory(n int32) *int32 {
  arr := make([]int32, n)
  for i := int32(0); i &lt; n; i++ {
    switch {
    case i &lt; 2:
      arr[i] = i
    default:
      arr[i] = arr[i-1] + arr[i-2]
    }
  }
  return &amp;arr[0]
}
</code></pre>
<p>使用 TinyGo 编译器工具将 Go 源代码编译成 WebAssembly 字节码应用程序：</p>
<pre><code class="language-bash">tinygo build -o fib.wasm -target wasi fib.go
</code></pre>
<p><a href="https://github.com/second-state/WasmEdge-go-examples/blob/master/go_AccessMemoryTinyGo/run.go">Go SDK 应用程序</a> 必须从 WasmEdge 虚拟机中调用 <code>malloc</code> 以获得指向数组的指针。然后它将用这个指针调用TinyGo中的 <code>fibArray()</code> 函数。在函数返回后，Go应用程序使用 WasmEdge SDK 的 <code>store</code> API，从调用参数（ <code>fibArray()</code> ）或返回值（ <code>fibArrayReturnMemory()</code> ）中的指针构建一个数组。Go应用程序最终会调用 <code>free</code> 来释放内存空间。</p>
<pre><code class="language-go">package main

import (
  &quot;fmt&quot;
  &quot;os&quot;
  &quot;unsafe&quot;

  &quot;github.com/second-state/WasmEdge-go/wasmedge&quot;
)

func main() {
  wasmedge.SetLogErrorLevel()
  conf := wasmedge.NewConfigure(wasmedge.WASI)
  store := wasmedge.NewStore()
  vm := wasmedge.NewVMWithConfigAndStore(conf, store)

  wasi := vm.GetImportModule(wasmedge.WASI)
  wasi.InitWasi(
    os.Args[1:],
    os.Environ(),
    []string{&quot;.:.&quot;},
  )

  err := vm.LoadWasmFile(os.Args[1])
  if err != nil {
    fmt.Println(&quot;failed to load wasm&quot;)
  }
  vm.Validate()
  vm.Instantiate()

  n := int32(10)

  p, err := vm.Execute(&quot;malloc&quot;, n)
  if err != nil {
    fmt.Println(&quot;malloc failed:&quot;, err)
  }

  fib, err := vm.Execute(&quot;fibArray&quot;, n, p[0])
  if err != nil {
    fmt.Println(&quot;fibArray failed:&quot;, err)
  } else {
    fmt.Println(&quot;fibArray() returned:&quot;, fib[0])
    fmt.Printf(&quot;fibArray memory at: %p\n&quot;, unsafe.Pointer((uintptr)(p[0].(int32))))
    mem := store.FindMemory(&quot;memory&quot;)
    if mem != nil {
      // int32 占用 4 个字节
      fibArray, err := mem.GetData(uint(p[0].(int32)), uint(n * 4))
      if err == nil &amp;&amp; fibArray != nil {
        fmt.Println(&quot;fibArray:&quot;, fibArray)
      }
    }
  }

  fibP, err := vm.Execute(&quot;fibArrayReturnMemory&quot;, n)
  if err != nil {
    fmt.Println(&quot;fibArrayReturnMemory failed:&quot;, err)
  } else {
    fmt.Printf(&quot;fibArrayReturnMemory memory at: %p\n&quot;, unsafe.Pointer((uintptr)(fibP[0].(int32))))
    mem := store.FindMemory(&quot;memory&quot;)
    if mem != nil {
      // int32 占用 4 个字节
      fibArrayReturnMemory, err := mem.GetData(uint(fibP[0].(int32)), uint(n * 4))
      if err == nil &amp;&amp; fibArrayReturnMemory != nil {
        fmt.Println(&quot;fibArrayReturnMemory:&quot;, fibArrayReturnMemory)
      }
    }
  }

  _, err = vm.Execute(&quot;free&quot;, p...)
  if err != nil {
    fmt.Println(&quot;free failed:&quot;, err)
  }

  exitcode := wasi.WasiGetExitCode()
  if exitcode != 0 {
    fmt.Println(&quot;Go: Running wasm failed, exit code:&quot;, exitcode)
  }

  vm.Release()
  store.Release()
  conf.Release()
}
</code></pre>
<p>要构建 Go SDK 示例，请运行以下命令：</p>
<pre><code class="language-bash">go get github.com/second-state/WasmEdge-go/wasmedge@v0.10.0
go build run.go
</code></pre>
<p>现在你可以使用 Go 应用程序运行从 TinyGo 编译的 WebAssembly 插件：</p>
<pre><code class="language-bash">$ ./run fib.wasm
fibArray() returned: 34
fibArray memory at: 0x14d3c
fibArray: [0 0 0 0 1 0 0 0 1 0 0 0 2 0 0 0 3 0 0 0 5 0 0 0 8 0 0 0 13 0 0 0 21 0 0 0 34 0 0 0]
fibArrayReturnMemory memory at: 0x14d4c
fibArrayReturnMemory: [0 0 0 0 1 0 0 0 1 0 0 0 2 0 0 0 3 0 0 0 5 0 0 0 8 0 0 0 13 0 0 0 21 0 0 0 34 0 0 0]
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tensorflow-2"><a class="header" href="#tensorflow-2">Tensorflow</a></h1>
<p>在这一章节，我们将向你展示如何在 Rust 中创建一个用于图像分类的 Tensorflow 推理函数，然后将其嵌入到 Go 应用程序中。项目的源码可以在<a href="https://github.com/second-state/WasmEdge-go-examples/tree/master/wasmedge-bindgen/go_TfliteFood">这儿</a>查看。</p>
<h2 id="将-rust-函数编译成-webassembly-1"><a class="header" href="#将-rust-函数编译成-webassembly-1">将 Rust 函数编译成 WebAssembly</a></h2>
<p>用于图像分类的 Rust 函数在<a href="https://github.com/second-state/WasmEdge-go-examples/blob/master/wasmedge-bindgen/go_TfliteFood/rust_tflite_food/src/lib.rs">这儿</a>。它使用 <a href="embed/go/../../dev/rust/tensorflow.html">WasmEdge Tensorflow 扩展 API</a> 以及 <a href="embed/go/function.html">wasmedge_bindgen</a> 来传递所有调用参数。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[wasmedge_bindgen]
fn infer(image_data: Vec&lt;u8&gt;) -&gt; Result&lt;Vec&lt;u8&gt;, String&gt; {
  ... ...
  let flat_img = image::imageops::thumbnail(&amp;img, 192, 192);

  let model_data: &amp;[u8] = include_bytes!(&quot;lite-model_aiy_vision_classifier_food_V1_1.tflite&quot;);
  let labels = include_str!(&quot;aiy_food_V1_labelmap.txt&quot;);

  let mut session = wasmedge_tensorflow_interface::Session::new(
    model_data,
    wasmedge_tensorflow_interface::ModelType::TensorFlowLite,
  );
  session.add_input(&quot;input&quot;, &amp;flat_img, &amp;[1, 192, 192, 3]).run();
  let res_vec: Vec&lt;u8&gt; = session.get_output(&quot;MobilenetV1/Predictions/Softmax&quot;);
  ... ...
}
<span class="boring">}
</span></code></pre></pre>
<p>你可以使用标准的 <code>Cargo</code> 命令来将其构建成为一个 WebAssembly 函数。</p>
<pre><code class="language-bash">cd rust_tflite_food
cargo build --target wasm32-wasi --release
cp target/wasm32-wasi/release/rust_tflite_food_lib.wasm ../
cd ../
</code></pre>
<p>你也可以使用我们的 AOT 编译器 <code>wasmedgec</code> 来检测 WebAssembly 文件，以便让其运行的更快。<a href="embed/go/../../start/universal.html">学习更多</a>。</p>
<pre><code class="language-bash">wasmedgec rust_tflite_food_lib.wasm rust_tflite_food_lib.wasm
</code></pre>
<h2 id="go-host-应用程序"><a class="header" href="#go-host-应用程序">Go host 应用程序</a></h2>
<p><a href="https://github.com/second-state/WasmEdge-go-examples/blob/master/wasmedge-bindgen/go_TfliteFood/tflite_food.go">Go host 应用程序</a>的源码展示了如何用 Tensorflow 来扩展并实例化一个 WasmEdge runtime，以及如何将图片数据传递给 WasmEdge 中的 Rust 函数，以便来执行推理。</p>
<pre><code class="language-go">func main() {
  // Expected Args[0]: program name (./tflite_food)
  // Expected Args[1]: wasm file (rust_tflite_food_lib.wasm)
  // Expected Args[2]: input image name (food.jpg)

  wasmedge.SetLogErrorLevel()

  // Set Tensorflow not to print debug info
  os.Setenv(&quot;TF_CPP_MIN_LOG_LEVEL&quot;, &quot;3&quot;)
  os.Setenv(&quot;TF_CPP_MIN_VLOG_LEVEL&quot;, &quot;3&quot;)

  var conf = wasmedge.NewConfigure(wasmedge.WASI)
  var vm = wasmedge.NewVMWithConfig(conf)
  var wasi = vm.GetImportModule(wasmedge.WASI)
  wasi.InitWasi(
    os.Args[1:],     // The args
    os.Environ(),    // The envs
    []string{&quot;.:.&quot;}, // The mapping preopens
  )

  // Register WasmEdge-tensorflow
  var tfmod = wasmedge.NewTensorflowModule()
  var tflitemod = wasmedge.NewTensorflowLiteModule()
  vm.RegisterModule(tfmod)
  vm.RegisterModule(tflitemod)

  // Load and validate the wasm
  vm.LoadWasmFile(os.Args[1])
  vm.Validate()

  // Instantiate the bindgen and vm
  bg := bindgen.Instantiate(vm)

  img, _ := ioutil.ReadFile(os.Args[2])
  if res, err := bg.Execute(&quot;infer&quot;, img); err != nil {
    fmt.Println(err)
  } else {
    fmt.Println(string(res))
  }

  bg.Release()
  vm.Release()
  conf.Release()
  tfmod.Release()
  tflitemod.Release()
}
</code></pre>
<h2 id="构建和运行"><a class="header" href="#构建和运行">构建和运行</a></h2>
<blockquote>
<p>你必须要在你的机器上安装带有 tensorflow 扩展的 WasmEdge。详情可查看<a href="embed/go/../../start/install.html">安装指南</a>。</p>
</blockquote>
<p>如下命令用 WasmEdge Go SDK 和它的 tensorflow 扩展，构建了 Go host 应用程序。</p>
<pre><code class="language-bash">go build -tags tensorflow
</code></pre>
<p>现在你就可以运行 Go 应用程序了。它在 WasmEdge 中调用 WebAssembly 函数，以对输入图片进行推理。</p>
<pre><code class="language-bash">./tflite_food rust_tflite_food_lib.wasm food.jpg
</code></pre>
<p>结果如下。</p>
<pre><code class="language-bash">Go: Args: [./tflite_food rust_tflite_food_lib.wasm food.jpg]
It is very likely a Hot dog in the picture
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="如何用-go-编写-host-function"><a class="header" href="#如何用-go-编写-host-function">如何用 Go 编写 Host Function</a></h1>
<p><strong>This file is needed to update to 0.10.0 and translate into English.</strong></p>
<h2 id="什么是-host-function"><a class="header" href="#什么是-host-function">什么是 Host Function</a></h2>
<p>顾名思义, Host Function 就是定义在 Host 程序中的函数. 对于 Wasm 来说, Host Function 可以做为导入段 <code>import</code> 被注册到一个模块 <code>module</code> 中, 之后便可以在 Wasm 运行时被调用.</p>
<p>Wasm 目前的能力有限，但那些 Wasm 本身做不了的事情, 都可以依靠 Host Function 来解决, 这极大地扩展了 Wasm 的能力范围.</p>
<p><a href="https://github.com/WasmEdge/WasmEdge">WasmEdge</a> 在标准之外做的扩展基本都是依赖 Host Function 做的的，比如，<a href="https://wasmedge.org/book/en/dev/rust/tensorflow.html">WasmEdge</a> 提供的 <a href="https://github.com/second-state/wasmedge_tensorflow_interface">Tensorflow API</a>, 是使用 Host Function 实现的，也因此实现了以原生速度运行 AI 推理的目标。</p>
<p>Networking socket 也是使用 host function 实现的，因此我们可以在 <a href="https://wasmedge.org/book/en/dev/rust/networking-nonblocking.html">WasmEdge 运行异步 HTTP 客户端和服务器</a>，弥补了 WebAssembly 在网络上的不足。</p>
<p>再比如 <a href="https://www.fastly.com/blog/edge-programming-rust-web-assembly">Fastly</a> 使用 Host Function 为 Wasm 增加了 Http Request 和 Key-value store 等接口, 进而增添了扩展功能。</p>
<h2 id="如何编写简单的-host-function"><a class="header" href="#如何编写简单的-host-function">如何编写简单的 Host Function</a></h2>
<p>让我们从一个最简单的例子入手, 来看看如何在一个 Go 程序里编写 Host function。</p>
<p>先来编写一个简单的 rust 程序。国际惯例，<code>Cargo.toml</code> 不能少。</p>
<p><code>Cargo.toml</code>:</p>
<pre><code class="language-toml">[package]
name = &quot;rust_host_func&quot;
version = &quot;0.1.0&quot;
edition = &quot;2021&quot;

[lib]
crate-type = [&quot;cdylib&quot;, &quot;rlib&quot;]

[dependencies]
</code></pre>
<p>再来看看 Rust 代码是什么样的。</p>
<p><code>lib.rs</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>extern &quot;C&quot; {
  fn add(a: i32, b: i32) -&gt; i32;
}

#[no_mangle]
pub unsafe extern fn run() -&gt; i32 {
  add(1, 2)
}
<span class="boring">}
</span></code></pre></pre>
<p>上述程序中的 <code>add</code> 函数被声明在 <code>extern &quot;C&quot;</code> 中, 这就是一个 Host Function。我们使用如下命令将这段 Rust 程序编译为 wasm:</p>
<pre><code class="language-bash">cargo build --target wasm32-wasi --release
</code></pre>
<p>然后我们使用 <code>wasm2wat</code> 来查看 wasm 文件的导入段:</p>
<pre><code class="language-bash">wasm2wat target/wasm32-wasi/release/rust_host_func.wasm | grep import
</code></pre>
<p>输出如下:</p>
<pre><code class="language-bash">  (import &quot;env&quot; &quot;add&quot; (func $add (type 0)))
</code></pre>
<p>可以看到 <code>add</code> 函数被放到了默认名称为 <code>env</code> 的模块的导入段中.</p>
<p>接下来我们来看如何使用 <a href="https://github.com/second-state/WasmEdge-go">WasmEdge-go</a> SDK 来执行这段 wasm 程序.</p>
<p><code>hostfunc.go</code>:</p>
<pre><code class="language-go">package main

import (
  &quot;fmt&quot;
  &quot;os&quot;

  &quot;github.com/second-state/WasmEdge-go/wasmedge&quot;
)

func add(_ interface{}, _ *wasmedge.Memory, params []interface{}) ([]interface{}, wasmedge.Result) {
  // 将从 wasm 传过来的两个参数做加法运算
  return []interface{}{params[0].(int32) + params[1].(int32)}, wasmedge.Result_Success
}

func main() {
  vm := wasmedge.NewVM()
 
  // 使用默认名称 env 构建导入段对象
  obj := wasmedge.NewImportObject(&quot;env&quot;)

  // 构建 Host Function 的参数和返回值类型
  funcAddType := wasmedge.NewFunctionType(
    []wasmedge.ValType{
      wasmedge.ValType_I32,
      wasmedge.ValType_I32,
    },
    []wasmedge.ValType{
      wasmedge.ValType_I32,
    })
  hostAdd := wasmedge.NewFunction(funcAddType, add, nil, 0)
 
  // 将 Host Function 加入到导入段对象中
  // 注意第一个参数 `add` 是 rust 中定义的外部函数的名称
  obj.AddFunction(&quot;add&quot;, hostAdd)

  // 注册导入段对象
  vm.RegisterImport(obj)

  // 加载, 验证并实例化 wasm 程序
  vm.LoadWasmFile(os.Args[1])
  vm.Validate()
  vm.Instantiate()

  // 执行 wasm 导出的函数并取得返回值
  r, _ := vm.Execute(&quot;run&quot;)
  fmt.Printf(&quot;%d&quot;, r[0].(int32))

  obj.Release()
  vm.Release()
}

</code></pre>
<p>编译并执行:</p>
<pre><code class="language-bash">go build
./hostfunc rust_host_func.wasm
</code></pre>
<p>程序输出 <code>3</code> 。</p>
<p>这样我们就完成了一个最简单的在 Host 中定义 Function, 并在 wasm 中调用的例子。</p>
<p>下面让我们尝试用 Host Function 做一些更有趣的事情.</p>
<h2 id="传递复杂类型"><a class="header" href="#传递复杂类型">传递复杂类型</a></h2>
<p>受 Wasm 里数据类型的制约, Host Function 只能传递如 int32 等少数几种基本类型的数据, 这就会大大限制 Host Function 的应用范围. 那有没有什么办法能让我们传递如 string 等复杂数据类型的数据呢？答案是当然可以， 下面我们就通过一个例子看看是如何做到的。</p>
<p>在这个例子中, 我们要统计 <code>https://www.google.com</code> 的网页源代码中 <code>google</code> 出现的次数。
例子的源代码在<a href="https://github.com/second-state/WasmEdge-go-examples/tree/master/go_HostFunc">这里</a>.</p>
<p>还是先上 Rust 代码。<code>Cargo.toml</code> 是必不可少的，只是我在这里省略了。</p>
<p><code>lib.rs</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>extern &quot;C&quot; {
  fn fetch(url_pointer: *const u8, url_length: i32) -&gt; i32;
  fn write_mem(pointer: *const u8);
}

#[no_mangle]
pub unsafe extern fn run() -&gt; i32 {
  let url = &quot;https://www.google.com&quot;;
  let pointer = url.as_bytes().as_ptr();

  // call host function to fetch the source code, return the result length
  let res_len = fetch(pointer, url.len() as i32) as usize;

  // malloc memory
  let mut buffer = Vec::with_capacity(res_len);
  let pointer = buffer.as_mut_ptr();

  // call host function to write source code to the memory
  write_mem(pointer);

  // find occurrences from source code
  buffer.set_len(res_len);
  let str = std::str::from_utf8(&amp;buffer).unwrap();
  str.matches(&quot;google&quot;).count() as i32
}
<span class="boring">}
</span></code></pre></pre>
<p>在这段代码中, 引入了两个 Host Function:</p>
<ul>
<li><code>fetch</code> 用于发送 http 请求以获取网页源代码</li>
<li><code>write_mem</code> 用于把网页源代码写到 wasm 的内存</li>
</ul>
<p>你可能已经看出来了, 要在 Host Function 里传递 string, 实际是通过传递这段 string 所在内存指针和长度来实现的. <code>fetch</code> 接收两个参数, 他们就分别是字符串 <code>https://www.google.com</code> 的指针和字节长度.</p>
<p><code>fetch</code> 在获取到源代码后, 将源码的字节长度做为返回值返回。Rust 在分配了此长度的内存后, 将内存指针传递给 <code>write_mem</code>, host 将源码写入到这段内存, 进而达到了返回 string 的目的.</p>
<p>编译的过程同上不再赘述, 接下来展示如何使用 <a href="https://github.com/second-state/WasmEdge-go">WasmEdge-go</a> SDK 来执行这段 Wasm 程序。</p>
<p><code>hostfun.go</code>:</p>
<pre><code class="language-go">package main

import (
  &quot;fmt&quot;
  &quot;io&quot;
  &quot;os&quot;
  &quot;net/http&quot;

  &quot;github.com/second-state/WasmEdge-go/wasmedge&quot;
)

type host struct {
  fetchResult []byte
}

// do the http fetch
func fetch(url string) []byte {
  resp, err := http.Get(string(url))
  if err != nil {
    return nil
  }
  defer resp.Body.Close()
  body, err := io.ReadAll(resp.Body)
  if err != nil {
    return nil
  }

  return body
}

// Host function for fetching
func (h *host) fetch(_ interface{}, mem *wasmedge.Memory, params []interface{}) ([]interface{}, wasmedge.Result) {
  // get url from memory
  pointer := params[0].(int32)
  size := params[1].(int32)
  data, _ := mem.GetData(uint(pointer), uint(size))
  url := make([]byte, size)

  copy(url, data)

  respBody := fetch(string(url))

  if respBody == nil {
    return nil, wasmedge.Result_Fail
  }

  // store the source code
  h.fetchResult = respBody

  return []interface{}{len(respBody)}, wasmedge.Result_Success
}

// Host function for writting memory
func (h *host) writeMem(_ interface{}, mem *wasmedge.Memory, params []interface{}) ([]interface{}, wasmedge.Result) {
  // write source code to memory
  pointer := params[0].(int32)
  mem.SetData(h.fetchResult, uint(pointer), uint(len(h.fetchResult)))

  return nil, wasmedge.Result_Success
}

func main() {
  conf := wasmedge.NewConfigure(wasmedge.WASI)
  vm := wasmedge.NewVMWithConfig(conf)
  obj := wasmedge.NewImportObject(&quot;env&quot;)

  h := host{}
  // Add host functions into the import object
  funcFetchType := wasmedge.NewFunctionType(
    []wasmedge.ValType{
      wasmedge.ValType_I32,
      wasmedge.ValType_I32,
    },
    []wasmedge.ValType{
      wasmedge.ValType_I32,
    })

  hostFetch := wasmedge.NewFunction(funcFetchType, h.fetch, nil, 0)
  obj.AddFunction(&quot;fetch&quot;, hostFetch)

  funcWriteType := wasmedge.NewFunctionType(
    []wasmedge.ValType{
      wasmedge.ValType_I32
    },
    []wasmedge.ValType{})
  hostWrite := wasmedge.NewFunction(funcWriteType, h.writeMem, nil, 0)
  obj.AddFunction(&quot;write_mem&quot;, hostWrite)

  vm.RegisterImport(obj)

  vm.LoadWasmFile(os.Args[1])
  vm.Validate()
  vm.Instantiate()

  r, _ := vm.Execute(&quot;run&quot;)
  fmt.Printf(&quot;There are %d 'google' in source code of google.com\n&quot;, r[0])

  obj.Release()
  vm.Release()
  conf.Release()
}

</code></pre>
<p>有了对 Rust 代码的理解, 这段 go 代码其实就很容易理解了。 比较关键的就是对 Wasm 内存的存取:</p>
<ul>
<li><code>mem.GetData(uint(pointer), uint(size))</code> 取得 Wasm 中网页的 url</li>
<li><code>mem.SetData(h.fetchResult, uint(pointer), uint(len(h.fetchResult)))</code> 将网页源码写入 wasm 内存</li>
</ul>
<p>这个例子的编译执行步骤和前一个例子一模一样, 最后执行的结果是:</p>
<p><code>There are 79 'google' in source code of google.com</code></p>
<h2 id="结语"><a class="header" href="#结语">结语</a></h2>
<p>通过以上两个例子的抛砖引玉, 相信你已经对 Host Function 有了一个初步印象。
虽然因为 Wasm 的诸多限制, 在开发体验上还不太理想, 但随着我们对工具及库的不断完善, 将会为 Wasm 的应用场景带来无尽可能。</p>
<p>欢迎持续关注 <a href="https://wasmedge.org">WasmEdge</a> 项目, 谢谢。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="嵌入-bindgen-函数"><a class="header" href="#嵌入-bindgen-函数">嵌入 bindgen 函数</a></h1>
<blockquote>
<p>本章节中讨论的 <code>wasm_bindgen</code> 方法已经废弃，我们推荐你查看 <a href="embed/go/function.html">wasmedge_bindgen</a>，或者直接传入内存指针；</p>
</blockquote>
<p>在这个例子中，我们将演示如何从 Go 应用中调用一些非常简单的 WebAssembly 函数。这些<a href="https://github.com/second-state/WasmEdge-go-examples/blob/master/go_BindgenFuncs/rust_bindgen_funcs/src/lib.rs">函数</a>都是基于  Rust 语言编写，并且调用参数和返回值都比较复杂。编译工具需要函数声明  <code>#[wasm_bindgen]</code> 宏才能自动生成正确的代码，以便支持从 Go 中传递调用参数给 WebAssembly。</p>
<p>WebAssembly 规范只支持几种开箱即用的简单数据类型，并不支持字符串和数组类型。为了实现在 Go 中向 WebAssembly 传递更丰富的类型，编译器需要将其转换成简单的整数。比如，将一个字符串转换成内存地址和字符串长度。<code>wasm_bindgen</code> 工具嵌入在 <a href="embed/go/../../dev/rust/bindgen.html">rustwasmc</a> 中自动执行转换。</p>
<blockquote>
<p>在编写本文档的时候，我们要求 Rust 编译器必须是 1.50 或者以下的版本，这样才能够让 WebAssembly 函数与 WasmEdge 的 Go API 正常工作。当接口类型规范最终确定并完成支持后，我们会尽快迁移到<a href="https://github.com/WasmEdge/WasmEdge/issues/264">最新的 Rust 版本</a>。</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use wasm_bindgen::prelude::*;
use num_integer::lcm;
use sha3::{Digest, Sha3_256, Keccak256};

#[wasm_bindgen]
pub fn say(s: &amp;str) -&gt; String {
  let r = String::from(&quot;hello &quot;);
  return r + s;
}

#[wasm_bindgen]
pub fn obfusticate(s: String) -&gt; String {
  (&amp;s).chars().map(|c| {
    match c {
      'A' ..= 'M' | 'a' ..= 'm' =&gt; ((c as u8) + 13) as char,
      'N' ..= 'Z' | 'n' ..= 'z' =&gt; ((c as u8) - 13) as char,
      _ =&gt; c
    }
  }).collect()
}

#[wasm_bindgen]
pub fn lowest_common_multiple(a: i32, b: i32) -&gt; i32 {
  let r = lcm(a, b);
  return r;
}

#[wasm_bindgen]
pub fn sha3_digest(v: Vec&lt;u8&gt;) -&gt; Vec&lt;u8&gt; {
  return Sha3_256::digest(&amp;v).as_slice().to_vec();
}

#[wasm_bindgen]
pub fn keccak_digest(s: &amp;[u8]) -&gt; Vec&lt;u8&gt; {
  return Keccak256::digest(s).as_slice().to_vec();
}
<span class="boring">}
</span></code></pre></pre>
<p>首先，我们使用 <a href="https://github.com/WasmEdge/WasmEdge/blob/master/docs/book/en/src/dev/rust/bindgen.md">rustwasmc</a> 工具将 Rust 源代码编译成字节码。</p>
<pre><code class="language-bash">$ rustup default 1.50.0
$ cd rust_bindgen_funcs
$ rustwasmc build
# The output WASM will be pkg/rust_bindgen_funcs_lib_bg.wasm
</code></pre>
<p>我们在 Go 程序里面嵌入 WasmEdge 运行 WebAssembly 函数，<a href="https://github.com/second-state/WasmEdge-go-examples/blob/master/go_BindgenFuncs/bindgen_funcs.go">Go 程序源码如下</a>，<code>ExecuteBindgen()</code> 函数调用 <code>#[wasm_bindgen]</code> 转换后的 WebAssembly 函数并传递调用参数。</p>
<pre><code class="language-go">package main

import (
  &quot;fmt&quot;
  &quot;os&quot;
  &quot;github.com/second-state/WasmEdge-go/wasmedge&quot;
)

func main() {
  // Expected Args[0]: program name (./bindgen_funcs)
  // Expected Args[1]: wasm or wasm-so file (rust_bindgen_funcs_lib_bg.wasm))

  wasmedge.SetLogErrorLevel()

  var conf = wasmedge.NewConfigure(wasmedge.WASI)
  var vm = wasmedge.NewVMWithConfig(conf)
  var wasi = vm.GetImportModule(wasmedge.WASI)
  wasi.InitWasi(
    os.Args[1:],     // The args
    os.Environ(),    // The envs
    []string{&quot;.:.&quot;}, // The mapping directories
  )

  // Instantiate wasm
  vm.LoadWasmFile(os.Args[1])
  vm.Validate()
  vm.Instantiate()

  // Run bindgen functions
  var res interface{}
  var err error
  
  res, err = vm.ExecuteBindgen(&quot;say&quot;, wasmedge.Bindgen_return_array, []byte(&quot;bindgen funcs test&quot;))
  if err == nil {
    fmt.Println(&quot;Run bindgen -- say:&quot;, string(res.([]byte)))
  } 
  res, err = vm.ExecuteBindgen(&quot;obfusticate&quot;, wasmedge.Bindgen_return_array, []byte(&quot;A quick brown fox jumps over the lazy dog&quot;))
  if err == nil {
    fmt.Println(&quot;Run bindgen -- obfusticate:&quot;, string(res.([]byte)))
  } 
  res, err = vm.ExecuteBindgen(&quot;lowest_common_multiple&quot;, wasmedge.Bindgen_return_i32, int32(123), int32(2))
  if err == nil {
    fmt.Println(&quot;Run bindgen -- lowest_common_multiple:&quot;, res.(int32))
  } 
  res, err = vm.ExecuteBindgen(&quot;sha3_digest&quot;, wasmedge.Bindgen_return_array, []byte(&quot;This is an important message&quot;))
  if err == nil {
    fmt.Println(&quot;Run bindgen -- sha3_digest:&quot;, res.([]byte))
  } 
  res, err = vm.ExecuteBindgen(&quot;keccak_digest&quot;, wasmedge.Bindgen_return_array, []byte(&quot;This is an important message&quot;))
  if err == nil {
    fmt.Println(&quot;Run bindgen -- keccak_digest:&quot;, res.([]byte))
  } 

  vm.Release()
  conf.Release()
}
</code></pre>
<p>接下来，让我们用 WasmEdge Go SDK 来构建 Go 应用。</p>
<pre><code class="language-bash">go get github.com/second-state/WasmEdge-go/wasmedge@v0.10.0
go build
</code></pre>
<p>执行 Go 应用程序，该应用将在 WasmEdge runtime 中执行嵌入的 WebAssembly 函数。</p>
<pre><code class="language-bash">$ ./bindgen_funcs rust_bindgen_funcs/pkg/rust_bindgen_funcs_lib_bg.wasm
Run bindgen -- say: hello bindgen funcs test
Run bindgen -- obfusticate: N dhvpx oebja sbk whzcf bire gur ynml qbt
Run bindgen -- lowest_common_multiple: 246
Run bindgen -- sha3_digest: [87 27 231 209 189 105 251 49 159 10 211 250 15 159 154 181 43 218 26 141 56 199 25 45 60 10 20 163 54 211 195 203]
Run bindgen -- keccak_digest: [126 194 241 200 151 116 227 33 216 99 159 22 107 3 177 169 216 191 114 156 174 193 32 159 246 228 245 133 52 75 55 27]
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="wasmedge-go-api-参考"><a class="header" href="#wasmedge-go-api-参考">WasmEdge Go API 参考</a></h1>
<p>以下是使用 WasmEdge-Go SDK 的指南。</p>
<h2 id="目录-1"><a class="header" href="#目录-1">目录</a></h2>
<ul>
<li><a href="embed/go/ref.html#%E5%BC%80%E5%A7%8B">开始</a>
<ul>
<li><a href="embed/go/ref.html#WasmEdge-%E5%AE%89%E8%A3%85">WasmEdge 安装</a></li>
<li><a href="embed/go/ref.html#%E8%8E%B7%E5%8F%96-WasmEdge-go">获取 WasmEdge-go</a></li>
<li><a href="embed/go/ref.html#WasmEdge-go-%E6%89%A9%E5%B1%95">WasmEdge-go 扩展</a></li>
<li><a href="embed/go/ref.html#%E4%BD%BF%E7%94%A8-wasm-bindgen-%E5%B5%8C%E5%85%A5%E5%87%BD%E6%95%B0%E7%9A%84%E7%A4%BA%E4%BE%8B">使用 wasm-bindgen 嵌入函数的示例</a></li>
<li><a href="embed/go/ref.html#%E5%AE%8C%E6%95%B4%E7%9A%84-WASI-%E5%BA%94%E7%94%A8%E7%A4%BA%E4%BE%8B">完整的 WASI 应用示例</a></li>
</ul>
</li>
<li><a href="embed/go/ref.html#WasmEdge-go-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86">WasmEdge-go 基础知识</a>
<ul>
<li><a href="embed/go/ref.html#%E7%89%88%E6%9C%AC">版本</a></li>
<li><a href="embed/go/ref.html#%E6%97%A5%E5%BF%97%E8%AE%BE%E7%BD%AE">日志设置</a></li>
<li><a href="embed/go/ref.html#%E5%80%BC%E7%B1%BB%E5%9E%8B">值类型</a></li>
<li><a href="embed/go/ref.html#%E7%BB%93%E6%9E%9C">结果</a></li>
<li><a href="embed/go/ref.html#%E4%B8%8A%E4%B8%8B%E6%96%87%E5%8F%8A%E5%85%B6%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F">上下文及其生命周期</a></li>
<li><a href="embed/go/ref.html#WASM-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84">WASM 数据结构</a></li>
<li><a href="embed/go/ref.html#%E9%85%8D%E7%BD%AE">配置</a></li>
</ul>
</li>
<li><a href="embed/go/ref.html#WasmEdge-VM">WasmEdge VM</a>
<ul>
<li><a href="embed/go/ref.html#%E5%B8%A6%E6%9C%89-VM-%E5%AF%B9%E8%B1%A1%E7%9A%84-WASM-%E6%89%A7%E8%A1%8C%E7%A4%BA%E4%BE%8B">带有 VM 对象的 WASM 执行示例</a></li>
<li><a href="embed/go/ref.html#%E5%88%9B%E5%BB%BA%E8%99%9A%E6%8B%9F%E6%9C%BA">创建虚拟机</a></li>
<li><a href="embed/go/ref.html#%E9%A2%84%E6%B3%A8%E5%86%8C">预注册</a></li>
<li><a href="embed/go/ref.html#Host-%E6%A8%A1%E5%9D%97%E6%B3%A8%E5%86%8C">Host 模块注册</a></li>
<li><a href="embed/go/ref.html#WASM-%E6%B3%A8%E5%86%8C%E5%92%8C%E6%89%A7%E8%A1%8C">WASM 注册和执行</a></li>
<li><a href="embed/go/ref.html#%E5%AE%9E%E4%BE%8B%E8%B7%9F%E8%B8%AA">实例跟踪</a></li>
</ul>
</li>
<li><a href="embed/go/ref.html#WasmEdge-Runtime">WasmEdge Runtime</a>
<ul>
<li><a href="embed/go/ref.html#WASM-%E6%89%A7%E8%A1%8C%E7%A4%BA%E4%BE%8B%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E7%A8%8B">WASM 执行示例手把手教程</a></li>
<li><a href="embed/go/ref.html#%E5%8A%A0%E8%BD%BD%E5%99%A8">加载器</a></li>
<li><a href="embed/go/ref.html#%E9%AA%8C%E8%AF%81%E5%99%A8">验证器</a></li>
<li><a href="embed/go/ref.html#%E6%89%A7%E8%A1%8C%E8%80%85">执行者</a></li>
<li><a href="embed/go/ref.html#AST-%E6%A8%A1%E5%9D%97">AST 模块</a></li>
<li><a href="embed/go/ref.html#Store">Store</a></li>
<li><a href="embed/go/ref.html#%E5%AE%9E%E4%BE%8B">实例</a></li>
<li><a href="embed/go/ref.html#Host-%E5%87%BD%E6%95%B0">Host 函数</a></li>
</ul>
</li>
<li><a href="embed/go/ref.html#WasmEdge-AOT-%E7%BC%96%E8%AF%91%E5%99%A8">WasmEdge AOT 编译器</a>
<ul>
<li><a href="embed/go/ref.html#%E7%BC%96%E8%AF%91%E7%A4%BA%E4%BE%8B">编译示例</a></li>
<li><a href="embed/go/%E7%BC%96%E8%AF%91%E5%99%A8%E9%80%89%E9%A1%B9">编译器选项</a></li>
</ul>
</li>
</ul>
<h2 id="开始"><a class="header" href="#开始">开始</a></h2>
<p>WasmEdge-go 需要 golang 版本 &gt;= 1.15。请在安装前检查你的 golang 版本。你可以 <a href="https://golang.org/dl/">在这里下载 golang</a> 。</p>
<pre><code class="language-bash">go version
go version go1.16.5 linux/amd64
</code></pre>
<h3 id="wasmedge-安装"><a class="header" href="#wasmedge-安装">WasmEdge 安装</a></h3>
<p>你必须安装相同版本的 <a href="embed/go/start/install.html">WasmEdge 共享库</a> 与 <code>WasmEdge-go</code> 发行版或预发行版。</p>
<pre><code class="language-bash">curl -sSf https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/utils/install.sh | bash -s -- -v 0.9.1
</code></pre>
<p>如果你需要使用 <code>WasmEdge-go</code> 的 <code>TensorFlow</code> 或 <code>Image</code> 扩展，请安装带有扩展的 <code>WasmEdge</code>：</p>
<pre><code class="language-bash">curl -sSf https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/utils/install.sh | bash -s -- -e tf,image -v 0.9.1
</code></pre>
<p>请注意，<code>TensorFlow</code> 和 <code>Image</code> 扩展仅适用于 <code>Linux</code> 平台。 安装后，你可以使用 <code>source</code> 命令更新包含和链接搜索路径。</p>
<h3 id="获取-wasmedge-go"><a class="header" href="#获取-wasmedge-go">获取 WasmEdge-go</a></h3>
<p>安装 WasmEdge 后，你可以获取 <code>WasmEdge-go</code> 包并在你的 Go 项目目录中构建它。</p>
<pre><code class="language-bash">go get github.com/second-state/WasmEdge-go/wasmedge@v0.9.1
go build
</code></pre>
<h3 id="wasmedge-go-扩展-1"><a class="header" href="#wasmedge-go-扩展-1">WasmEdge-go 扩展</a></h3>
<p>默认情况下，<code>WasmEdge-go</code> 只开启基本 Runtime 。</p>
<p><code>WasmEdge-go</code> 有以下扩展（仅在 Linux 平台上）：</p>
<ul>
<li>
<p>Tensorflow</p>
<ul>
<li>
<p>此扩展支持 <a href="https://github.com/second-state/WasmEdge-tensorflow">WasmEdge-tensorflow</a> 中的 Host 函数。</p>
</li>
<li>
<p>如果需要 <code>TensorFlow</code> 扩展。请使用 <code>-e tensorflow</code> 命令安装 <code>WasmEdge</code>。</p>
</li>
<li>
<p>要使用此扩展，构建时需要标签 <code>tensorflow</code>：</p>
<pre><code class="language-bash">go build -tags tensorflow
</code></pre>
</li>
</ul>
</li>
<li>
<p>Image</p>
<ul>
<li>
<p>此扩展支持 <a href="https://github.com/second-state/WasmEdge-image">WasmEdge-image</a> 中的 Host 函数。</p>
</li>
<li>
<p>如果需要 <code>Image</code> 扩展。请使用 <code>-e image</code> 命令安装 <code>WasmEdge</code>。</p>
</li>
<li>
<p>为了使用这个扩展，构建时需要标签 <code>image</code>：</p>
<pre><code class="language-bash">go build -tags image
</code></pre>
</li>
</ul>
</li>
</ul>
<p>你还可以在构建时开启多个扩展：</p>
<pre><code class="language-bash">go build -tags image,tensorflow
</code></pre>
<h3 id="使用-wasm-bindgen-嵌入函数的示例"><a class="header" href="#使用-wasm-bindgen-嵌入函数的示例">使用 wasm-bindgen 嵌入函数的示例</a></h3>
<p>在<a href="https://github.com/second-state/WasmEdge-go-examples/tree/master/go_BindgenFuncs">这个示例</a> 中，我们将演示如何从 Golang 应用程序中使用 wasm-bindgen 调用一些简单的 WebAssembly 函数. <a href="https://github.com/second-state/WasmEdge-go-examples/blob/master/go_BindgenFuncs/rust_bindgen_funcs/src/lib.rs">函数</a> 是用 Rust 编写的，需要复杂的调用参数和返回值。 编译器工具需要 <code>#[wasm_bindgen]</code> 宏来自动生成正确的代码，以将调用参数从 Golang 传递到 WebAssembly。</p>
<p>注意：目前，我们需要 Rust 编译器版本 1.50 或更低版本才能使 WebAssembly 函数与 WasmEdge 的 Golang API 一起使用。一旦接口类型规范最终确定并得到支持，我们将<a href="https://github.com/WasmEdge/WasmEdge/issues/264">赶上最新的 Rust</a> 编译器版本。</p>
<p>注意：WebAssembly 仅支持一些开箱即用的简单数据类型。它<a href="https://medium.com/wasm/strings-in-webassembly-wasm-57a05c1ea333">不支持</a> 字符串和数组等类型。为了将 Golang 中的丰富类型传递给 WebAssembly，编译器需要将它们转换为简单的整数。例如，它将字符串转换为整数内存地址和整数长度。嵌入在 rustwasmc 中的 <code>wasm-bindgen</code> 工具会自动执行此转换。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use wasm_bindgen::prelude::*;
use num_integer::lcm;
use sha3::{Digest, Sha3_256, Keccak256};

#[wasm_bindgen]
pub fn say(s: &amp;str) -&gt; String {
  let r = String::from(&quot;hello &quot;);
  return r + s;
}

#[wasm_bindgen]
pub fn obfusticate(s: String) -&gt; String {
  (&amp;s).chars().map(|c| {
    match c {
      'A' ..= 'M' | 'a' ..= 'm' =&gt; ((c as u8) + 13) as char,
      'N' ..= 'Z' | 'n' ..= 'z' =&gt; ((c as u8) - 13) as char,
      _ =&gt; c
    }
  }).collect()
}

#[wasm_bindgen]
pub fn lowest_common_multiple(a: i32, b: i32) -&gt; i32 {
  let r = lcm(a, b);
  return r;
}

#[wasm_bindgen]
pub fn sha3_digest(v: Vec&lt;u8&gt;) -&gt; Vec&lt;u8&gt; {
  return Sha3_256::digest(&amp;v).as_slice().to_vec();
}

#[wasm_bindgen]
pub fn keccak_digest(s: &amp;[u8]) -&gt; Vec&lt;u8&gt; {
  return Keccak256::digest(s).as_slice().to_vec();
}
<span class="boring">}
</span></code></pre></pre>
<p>首先，我们使用 <a href="embed/go/dev/rust/bindgen.html"><code>rustwasmc</code> 工具</a> 将 Rust 源代码编译为 WebAssembly 字节码函数。注意这里 Rust 版本要用 1.50 或更低版本的。</p>
<pre><code class="language-bash">rustup default 1.50.0
cd rust_bindgen_funcs
rustwasmc build
# 生成的 WASM 在 pkg/rust_bindgen_funcs_lib_bg.wasm
</code></pre>
<p>在 WasmEdge 中运行 WebAssembly 函数的 <a href="https://github.com/second-state/WasmEdge-go-examples/blob/master/go_BindgenFuncs/bindgen_funcs.go">Golang 源码</a> 如下。<code>ExecuteBindgen()</code> 函数调用 WebAssembly 函数并在 <code>wasm-bindgen</code> 支持下传递参数。</p>
<pre><code class="language-go">package main

import (
    &quot;fmt&quot;
    &quot;os&quot;

    &quot;github.com/second-state/WasmEdge-go/wasmedge&quot;
)

func main() {
    // Expected Args[0]: program name (./bindgen_funcs)
    // Expected Args[1]: wasm or wasm-so file (rust_bindgen_funcs_lib_bg.wasm)
    wasmedge.SetLogErrorLevel()

    var conf = wasmedge.NewConfigure(wasmedge.WASI)
    var vm = wasmedge.NewVMWithConfig(conf)
    var wasi = vm.GetImportObject(wasmedge.WASI)
    wasi.InitWasi(
        os.Args[1:],     // The args
        os.Environ(),    // The envs
        []string{&quot;.:.&quot;}, // The mapping directories
    )

    // Instantiate wasm
    vm.LoadWasmFile(os.Args[1])
    vm.Validate()
    vm.Instantiate()

    // Run bindgen functions
    var res interface{}
    var err error
    
    res, err = vm.ExecuteBindgen(&quot;say&quot;, wasmedge.Bindgen_return_array, []byte(&quot;bindgen funcs test&quot;))
    if err == nil {
        fmt.Println(&quot;Run bindgen -- say:&quot;, string(res.([]byte)))
    } 
    res, err = vm.ExecuteBindgen(&quot;obfusticate&quot;, wasmedge.Bindgen_return_array, []byte(&quot;A quick brown fox jumps over the lazy dog&quot;))
    if err == nil {
        fmt.Println(&quot;Run bindgen -- obfusticate:&quot;, string(res.([]byte)))
    } 
    res, err = vm.ExecuteBindgen(&quot;lowest_common_multiple&quot;, wasmedge.Bindgen_return_i32, int32(123), int32(2))
    if err == nil {
        fmt.Println(&quot;Run bindgen -- lowest_common_multiple:&quot;, res.(int32))
    } 
    res, err = vm.ExecuteBindgen(&quot;sha3_digest&quot;, wasmedge.Bindgen_return_array, []byte(&quot;This is an important message&quot;))
    if err == nil {
        fmt.Println(&quot;Run bindgen -- sha3_digest:&quot;, res.([]byte))
    } 
    res, err = vm.ExecuteBindgen(&quot;keccak_digest&quot;, wasmedge.Bindgen_return_array, []byte(&quot;This is an important message&quot;))
    if err == nil {
        fmt.Println(&quot;Run bindgen -- keccak_digest:&quot;, res.([]byte))
    } 

    vm.Release()
    conf.Release()
}
</code></pre>
<p>接下来，使用 WasmEdge Golang SDK 构建 Golang 应用程序。</p>
<pre><code class="language-bash">go get github.com/second-state/WasmEdge-go/wasmedge@v0.9.1
go build
</code></pre>
<p>运行 Golang 应用程序，WebAssembly 函数将在 WasmEdge Runtime 中执行 。</p>
<pre><code class="language-bash">$ ./bindgen_funcs rust_bindgen_funcs/pkg/rust_bindgen_funcs_lib_bg.wasm
Run bindgen -- say: hello bindgen funcs test
Run bindgen -- obfusticate: N dhvpx oebja sbk whzcf bire gur ynml qbt
Run bindgen -- lowest_common_multiple: 246
Run bindgen -- sha3_digest: [87 27 231 209 189 105 251 49 159 10 211 250 15 159 154 181 43 218 26 141 56 199 25 45 60 10 20 163 54 211 195 203]
Run bindgen -- keccak_digest: [126 194 241 200 151 116 227 33 216 99 159 22 107 3 177 169 216 191 114 156 174 193 32 159 246 228 245 133 52 75 55 27]
</code></pre>
<h3 id="完整的-wasi-应用示例"><a class="header" href="#完整的-wasi-应用示例">完整的 WASI 应用示例</a></h3>
<p>注意：你可以使用最新的 Rust 编译器创建一个带有 <code>main.rs</code> 函数的独立 WasmEdge 应用程序，然后将其嵌入到 Golang 应用程序中。</p>
<p>除函数之外，WasmEdge Golang SDK 还可以<a href="https://github.com/second-state/WasmEdge-go-examples/tree/master/go_ReadFile">嵌入独立的 WebAssembly 应用程序</a> — 比如：带有 <code>main( )</code> 的 Rust 函数编译成 WebAssembly。</p>
<p>我们用一个读取文件内容的 <a href="https://github.com/second-state/WasmEdge-go-examples/tree/master/go_ReadFile/rust_readfile">Rust 应用</a> 作为 demo。注意这里不需要 <code>#[wasm_bindgen]</code>，因为 WebAssembly 程序的 WASI 支持 <code>main()</code> 函数的 <code>argv</code> 输入和 <code>exit code</code> 输出。</p>
<pre><pre class="playground"><code class="language-rust">use std::env;
use std::fs::File;
use std::io::{self, BufRead};

fn main() {
    // Get the argv.
    let args: Vec&lt;String&gt; = env::args().collect();
    if args.len() &lt;= 1 {
        println!(&quot;Rust: ERROR - No input file name.&quot;);
        return;
    }

    // Open the file.
    println!(&quot;Rust: Opening input file \&quot;{}\&quot;...&quot;, args[1]);
    let file = match File::open(&amp;args[1]) {
        Err(why) =&gt; {
            println!(&quot;Rust: ERROR - Open file \&quot;{}\&quot; failed: {}&quot;, args[1], why);
            return;
        },
        Ok(file) =&gt; file,
    };

    // Read lines.
    let reader = io::BufReader::new(file);
    let mut texts:Vec&lt;String&gt; = Vec::new();
    for line in reader.lines() {
        if let Ok(text) = line {
            texts.push(text);
        }
    }
    println!(&quot;Rust: Read input file \&quot;{}\&quot; succeeded.&quot;, args[1]);

    // Get stdin to print lines.
    println!(&quot;Rust: Please input the line number to print the line of file.&quot;);
    let stdin = io::stdin();
    for line in stdin.lock().lines() {
        let input = line.unwrap();
        match input.parse::&lt;usize&gt;() {
            Ok(n) =&gt; if n &gt; 0 &amp;&amp; n &lt;= texts.len() {
                println!(&quot;{}&quot;, texts[n - 1]);
            } else {
                println!(&quot;Rust: ERROR - Line \&quot;{}\&quot; is out of range.&quot;, n);
            },
            Err(e) =&gt; println!(&quot;Rust: ERROR - Input \&quot;{}\&quot; is not an integer: {}&quot;, input, e),
        }
    }
    println!(&quot;Rust: Process end.&quot;);
}
</code></pre></pre>
<p>使用 rustwasmc 工具将应用程序编译成 WebAssembly。</p>
<pre><code class="language-bash">cd rust_readfile
rustwasmc build
# 输出文件将位于 `pkg/rust_readfile.wasm`。
</code></pre>
<p>或者你可以直接通过 <code>cargo</code> 将应用程序编译成 WebAssembly：</p>
<pre><code class="language-bash">cd rust_readfile
# 需要添加 `wasm32-wasi` 目标。
rustup target add wasm32-wasi
cargo build --release --target=wasm32-wasi
#  输出的 wasm 将位于 `target/wasm32-wasi/release/rust_readfile.wasm`。
</code></pre>
<p>在 Go 程序里面嵌入 WasmEdge 运行 WebAssembly 函数，Go 程序代码如下。</p>
<pre><code class="language-go">package main

import (
    &quot;os&quot;

    &quot;github.com/second-state/WasmEdge-go/wasmedge&quot;
)

func main() {
    wasmedge.SetLogErrorLevel()

    var conf = wasmedge.NewConfigure(wasmedge.REFERENCE_TYPES)
    conf.AddConfig(wasmedge.WASI)
    var vm = wasmedge.NewVMWithConfig(conf)
    var wasi = vm.GetImportObject(wasmedge.WASI)
    wasi.InitWasi(
        os.Args[1:],     // The args
        os.Environ(),    // The envs
        []string{&quot;.:.&quot;}, // The mapping directories
    )

    // Instantiate and run WASM &quot;_start&quot; function, which refers to the main() function
    vm.RunWasmFile(os.Args[1], &quot;_start&quot;)

    vm.Release()
    conf.Release()
}
</code></pre>
<p>接下来，使用 WasmEdge Golang SDK 构建 Golang 应用程序。</p>
<pre><code class="language-bash">go get github.com/second-state/WasmEdge-go/wasmedge@v0.9.1
go build
</code></pre>
<p>运行 Golang 应用程序。</p>
<pre><code class="language-bash">$ ./read_file rust_readfile/pkg/rust_readfile.wasm file.txt
Rust: Opening input file &quot;file.txt&quot;...
Rust: Read input file &quot;file.txt&quot; succeeded.
Rust: Please input the line number to print the line of file.
# 输入“5”并回车。
5
# 将打印 `file.txt` 的第 5 行：
abcDEF___!@#$%^
# To terminate the program, send the EOF (Ctrl + D).
^D
# 输出将打印终止消息：
Rust: Process end.
</code></pre>
<p>更多示例请参考<a href="https://github.com/second-state/WasmEdge-go-examples/">示例仓库</a> 。</p>
<h2 id="wasmedge-go-基础知识"><a class="header" href="#wasmedge-go-基础知识">WasmEdge-go 基础知识</a></h2>
<p>在本部分中，我们将介绍 WasmEdge-go API 和数据结构的实用程序和概念。</p>
<h3 id="版本"><a class="header" href="#版本">版本</a></h3>
<p><code>Version</code> 相关的 API 可以检查安装的 WasmEdge 共享库版本。</p>
<pre><code class="language-go">import &quot;github.com/second-state/WasmEdge-go/wasmedge&quot;

verstr := wasmedge.GetVersion() // Will be `string` of WasmEdge version.
vermajor := wasmedge.GetVersionMajor() // Will be `uint` of WasmEdge major version number.
verminor := wasmedge.GetVersionMinor() // Will be `uint` of WasmEdge minor version number.
verpatch := wasmedge.GetVersionPatch() // Will be `uint` of WasmEdge patch version number.
</code></pre>
<h3 id="日志设置"><a class="header" href="#日志设置">日志设置</a></h3>
<p><code>wasmedge.SetLogErrorLevel()</code> 和 <code>wasmedge.SetLogDebugLevel()</code> API 可以将日志系统设置为调试级别或错误级别。默认情况下，是错误级别，调试信息会被隐藏。</p>
<h3 id="值类型"><a class="header" href="#值类型">值类型</a></h3>
<p>在 WasmEdge-go 中，API 会自动对内置类型进行转换，并为引用类型实现数据结构。</p>
<ol>
<li>
<p>数字类型：<code>i32</code>、<code>i64</code>、<code>f32</code>和<code>f64</code></p>
<ul>
<li>将值传递给 WASM 时，自动将 <code>uint32</code> 和 <code>int32</code> 转换为 <code>i32</code>。</li>
<li>将值传递给 WASM 时，自动将 <code>uint64</code> 和 <code>int64</code> 转换为 <code>i64</code>。</li>
<li>在 32 位系统中将值传递给 WASM 时，会自动将 <code>uint</code> 和 <code>int</code> 转换为 <code>i32</code>。</li>
<li>在 64 位系统中将值传递给 WASM 时，自动将 <code>uint</code> 和 <code>int</code> 转换为 <code>i64</code>。</li>
<li>将值传递给 WASM 时自动将 <code>float32</code> 转换为 <code>f32</code>。</li>
<li>将值传递给 WASM 时自动将 <code>float64</code> 转换为 <code>f64</code>。</li>
<li>得到结果时，将 WASM 的 <code>i32</code> 转换为 <code>int32</code>。</li>
<li>得到结果时将 WASM 的 <code>i64</code> 转换为 <code>int64</code>。</li>
<li>获取结果时将 WASM 中的 <code>f32</code> 转换为 <code>float32</code>。</li>
<li>获取结果时将 WASM 中的 <code>f64</code> 转换为 <code>float64</code>。</li>
</ul>
</li>
<li>
<p>数字类型：为 <code>SIMD</code> 提案实现的 <code>v128</code></p>
<p>你应该使用 <code>wasmedge.NewV128()</code> 生成 <code>v128</code> 值，并使用 <code>wasmedge.GetV128()</code> 获取值。</p>
<pre><code class="language-go">val := wasmedge.NewV128(uint64(1234), uint64(5678))
high, low := val.GetVal()
// `high` 为 uint64(1234)，`low` 为 uint64(5678)
</code></pre>
</li>
<li>
<p>引用类型：为 <code>Reference-Types</code> 提案实现的 <code>FuncRef</code> 和 <code>ExternRef</code></p>
<pre><code class="language-go">funcref := wasmedge.NewFuncRef(10)
// 创建一个函数索引为 10 的 `FuncRef`。

num := 1234
// `num` 是一个 `int`。
externref := wasmedge.NewExternRef(&amp;num)
// 创建一个引用 `num` 的 `ExternRef`。
num = 5678
// 修改 `num` 为 5678。
numref := externref.GetRef().(*int)
// 从 `ExternRef` 获取原始引用。
fmt.Println(*numref)
// 将打印 `5678`。
numref.Release()
// 应该调用 `Release` 方法。
</code></pre>
</li>
</ol>
<h3 id="结果"><a class="header" href="#结果">结果</a></h3>
<p><code>Result</code> 对象指定执行状态。你可以使用 <code>Error()</code> 函数来获取错误信息。</p>
<pre><code class="language-go">// 假设 `vm` 是一个 `wasmedge.VM` 对象。
res, err = vm.Execute(...) // 忽略参数的细节。
// 假设 `res, err` 是使用 `vm` 执行函数的返回值。
if err != nil {
    fmt.Println(&quot;Error message:&quot;, err.Error())
}
</code></pre>
<h3 id="上下文及其生命周期"><a class="header" href="#上下文及其生命周期">上下文及其生命周期</a></h3>
<p><code>VM</code>、<code>Store</code>、<code>Function</code> 等对象是由 WasmEdge 共享库中的 <code>Context</code> 组成的。
所有的上下文都可以通过调用对应的 <code>New</code> API 来创建，你也应该调用上下文对应的 <code>Release</code> 函数来释放资源。
请注意，对于从其他上下文检索但不是从 <code>New</code> API 创建的上下文，不需要调用 <code>Release</code> 函数。</p>
<pre><code class="language-go">// 创建一个配置。
conf := wasmedge.NewConfigure()
// 立即释放 `conf`。
conf.Release()
</code></pre>
<p>其他上下文的细节将在后面介绍。</p>
<h3 id="wasm-数据结构"><a class="header" href="#wasm-数据结构">WASM 数据结构</a></h3>
<p>WASM 数据结构用于创建实例或可以从实例上下文中查询。
实例创建的细节将在 <a href="embed/go/ref.html#Instances">Instances</a> 中介绍。</p>
<ol>
<li>
<p>限制</p>
<p><code>Limit</code> 结构表示最小值和最大值数据结构。</p>
<pre><code class="language-go">lim1 := wasmedge.NewLimit(12)
fmt.Println(lim1.HasMax())
// 将打印 `false`。
fmt.Println(lim1.GetMin())
// 将打印 `12`。

lim2 := wasmedge.NewLimitWithMax(15, 50)
fmt.Println(lim2.HasMax())
// 将打印 `true`。
fmt.Println(lim2.GetMin())
// 将打印 `15`。
fmt.Println(lim2.GetMax())
// 将打印 `50`。
</code></pre>
</li>
<li>
<p>函数类型上下文</p>
<p><code>FunctionType</code> 是一个持有函数类型上下文的对象，用于创建 <code>Function</code>，检查 <code>Function</code> 实例的值类型，或者从 VM 中获取具有函数名称的函数类型。
你可以使用 <code>FunctionType</code> API 来获取参数或返回值类型信息。</p>
<pre><code class="language-go">functype := wasmedge.NewFunctionType(
    []wasmedge.ValType{
        wasmedge.ValType_ExternRef,
        wasmedge.ValType_I32,
        wasmedge.ValType_I64,
    }, []wasmedge.ValType{
        wasmedge.ValType_F32,
        wasmedge.ValType_F64,
    })

plen := functype.GetParametersLength()
// `plen` 将是 3。
rlen := functype.GetReturnsLength()
// `rlen` 将是 2。
plist := functype.GetParameters()
// `plist` 将是 `[]wasmedge.ValType{wasmedge.ValType_ExternRef, wasmedge.ValType_I32, wasmedge.ValType_I64}`。
rlist := functype.GetReturns()
// `rlist` 将是 `[]wasmedge.ValType{wasmedge.ValType_F32, wasmedge.ValType_F64}`。

functype.Release()
</code></pre>
</li>
<li>
<p>表类型上下文</p>
<p><code>TableType</code> 是一个持有表类型上下文的对象，用于创建 <code>Table</code> 实例或从 <code>Table</code> 实例获取信息。</p>
<pre><code class="language-go">lim := wasmedge.NewLimit(12)
tabtype := wasmedge.NewTableType(wasmedge.RefType_ExternRef, lim)

rtype := tabtype.GetRefType()
// `rtype` 将是 `wasmedge.RefType_ExternRef`。
getlim := tabtype.GetLimit()
// `getlim` 与 `lim` 的值相同。

tabtype.Release()
</code></pre>
</li>
<li>
<p>内存类型上下文</p>
<p><code>MemoryType</code> 是一个保存内存类型上下文的对象，用于创建 <code>Memory</code> 实例或从 <code>Memory</code> 实例获取信息。</p>
<pre><code class="language-go">lim := wasmedge.NewLimit(1)
memtype := wasmedge.NewMemoryType(lim)

getlim := memtype.GetLimit()
// `getlim` 与 `lim` 的值相同。

memtype.Release()
</code></pre>
</li>
<li>
<p>全局类型上下文</p>
<p><code>GlobalType</code> 是一个持有全局类型上下文的对象，用于创建 <code>Global</code> 实例或从 <code>Global</code> 实例获取信息。</p>
<pre><code class="language-go">globtype := wasmedge.NewGlobalType(wasmedge.ValType_F64, wasmedge.ValMut_Var)

vtype := globtype.GetValType()
// `vtype` 将是 `wasmedge.ValType_F64`。
vmut := globtype.GetMutability()
// `vmut` 将是 `wasmedge.ValMut_Var`。

globtype.Release()
</code></pre>
</li>
<li>
<p>引入类型上下文</p>
<p><code>ImportType</code> 是一个包含导入类型上下文的对象，用于从 <a href="embed/go/ref.html#AST-Module">AST 模块</a> 获取导入信息。你可以从 <code>ImportType</code> 对象中获取外部类型（<code>function</code>、<code>table</code>、<code>memory</code> 或 <code>global</code>）、导入模块名称和外部名称。查询 <code>ImportType</code> 对象的详细信息将在 <a href="embed/go/ref.html#AST-Module">AST 模块</a> 中介绍。</p>
<pre><code class="language-go">var ast *wasmedge.AST = ...
// 假设 `Loader` 返回 `ast` 作为 WASM 文件的加载结果。
imptypelist := ast.ListImports()
// 假设 `imptypelist` 是从 `ast` 中列出的用于导入的数组。

for i, imptype := range imptypelist {
    exttype := imptype.GetExternalType()
    // `exttype` 必须是 `wasmedge.ExternType_Function`、`wasmedge.ExternType_Table` 之一，
    // wasmedge.ExternType_Memory`，或 `wasmedge.ExternType_Global`。

    modname := imptype.GetModuleName()
    extname := imptype.GetExternalName()
    // 获取导入的模块名称和外部名称。

    extval := imptype.GetExternalValue()
    // `extval` 是 `interface{}` 的类型，表示 `*wasmedge.FunctionType` 之一，
    // `*wasmedge.TableType`、`*wasmedge.MemoryType` 或 `*wasmedge.GlobalType`。
}
</code></pre>
</li>
<li>
<p>导出类型上下文</p>
<p><code>ExportType</code> 是一个持有导出类型上下文的对象，用于从 <a href="embed/go/ref.html#AST-Module">AST 模块</a> 获取导出信息。你可以从 <code>Export Type</code> 上下文中获取外部类型（<code>function</code>、<code>table</code>、<code>memory</code> 或 <code>global</code>）和外部名称。关于查询 <code>ExportType</code> 对象的详细信息将在 <a href="embed/go/ref.html#AST-Module">AST 模块</a> 中介绍。</p>
<pre><code class="language-go">var ast *wasmedge.AST = ...
// 假设 `Loader` 返回 `ast` 作为 WASM 文件的加载结果。
exptypelist := ast.ListExports()
// 假设 `exptypelist` 是从 `ast` 中列出的用于导出的数组。

for i, exptype := range exptypelist {
    exttype := exptype.GetExternalType()
    // `exttype` 必须是 `wasmedge.ExternType_Function`、`wasmedge.ExternType_Table` 之一，
    // wasmedge.ExternType_Memory`，或 `wasmedge.ExternType_Global`。

    extname := exptype.GetExternalName()
    // 获取导出的外部名称。

    extval := exptype.GetExternalValue()
    // `extval` 是 `interface{}` 的类型，表示 `*wasmedge.FunctionType` 之一，
    // `*wasmedge.TableType`、`*wasmedge.MemoryType` 或 `*wasmedge.GlobalType`。
}
</code></pre>
</li>
</ol>
<h3 id="配置"><a class="header" href="#配置">配置</a></h3>
<p>配置对象 <code>wasmedge.Configure</code> 管理 <code>Loader</code>、<code>Validator</code>、<code>Executor</code>、<code>VM</code> 和 <code>Compiler</code> 的配置。你可以调整 proposals 配置、VM Host 预注册（比如 <code>WASI</code>）和 AOT 编译器选项的设置，然后应用 <code>Configure</code> 对象来创建其他 Runtime 对象。</p>
<ol>
<li>
<p>配置</p>
<p>WasmEdge 支持打开或关闭 WebAssembly proposals。此配置在使用 <code>Configure</code> 对象创建的任何上下文中都有效。</p>
<pre><code class="language-go">const (
    IMPORT_EXPORT_MUT_GLOBALS         = Proposal(C.WasmEdge_Proposal_ImportExportMutGlobals)
    NON_TRAP_FLOAT_TO_INT_CONVERSIONS = Proposal(C.WasmEdge_Proposal_NonTrapFloatToIntConversions)
    SIGN_EXTENSION_OPERATORS          = Proposal(C.WasmEdge_Proposal_SignExtensionOperators)
    MULTI_VALUE                       = Proposal(C.WasmEdge_Proposal_MultiValue)
    BULK_MEMORY_OPERATIONS            = Proposal(C.WasmEdge_Proposal_BulkMemoryOperations)
    REFERENCE_TYPES                   = Proposal(C.WasmEdge_Proposal_ReferenceTypes)
    SIMD                              = Proposal(C.WasmEdge_Proposal_SIMD)
    TAIL_CALL                         = Proposal(C.WasmEdge_Proposal_TailCall)
    ANNOTATIONS                       = Proposal(C.WasmEdge_Proposal_Annotations)
    MEMORY64                          = Proposal(C.WasmEdge_Proposal_Memory64)
    THREADS                           = Proposal(C.WasmEdge_Proposal_Threads)
    EXCEPTION_HANDLING                = Proposal(C.WasmEdge_Proposal_ExceptionHandling)
    FUNCTION_REFERENCES               = Proposal(C.WasmEdge_Proposal_FunctionReferences)
)
</code></pre>
<p>你可以在 <code>Configure</code> 对象中添加或删除提案。</p>
<pre><code class="language-go">// 默认情况下，以下提案最初已开启：
// * IMPORT_EXPORT_MUT_GLOBALS
// * NON_TRAP_FLOAT_TO_INT_CONVERSIONS
// * SIGN_EXTENSION_OPERATORS
// * MULTI_VALUE
// * BULK_MEMORY_OPERATIONS
// * REFERENCE_TYPES
// * SIMD
conf := wasmedge.NewConfigure()
// 你也可以将提案作为参数传递：
// conf := wasmedge.NewConfigure(wasmedge.SIMD, wasmedge.BULK_MEMORY_OPERATIONS)
conf.AddConfig(wasmedge.SIMD)
conf.RemoveConfig(wasmedge.REFERENCE_TYPES)
is_bulkmem := conf.HasConfig(wasmedge.BULK_MEMORY_OPERATIONS)
// `is_bulkmem` 将是 `true`。
conf.Release()
</code></pre>
</li>
<li>
<p>Host 注册</p>
<p>此配置用于 <code>VM</code> 上下文以打开 <code>WASI</code> 或 <code>wasmedge_process</code> 支持，并且仅在 <code>VM</code> 对象中有效。</p>
<pre><code class="language-go">const (
    WASI = HostRegistration(C.WasmEdge_HostRegistration_Wasi)
    WasmEdge_PROCESS = HostRegistration(C.WasmEdge_HostRegistration_WasmEdge_Process)
)
</code></pre>
<p>详情将在 <a href="embed/go/ref.html###%E9%A2%84%E6%B3%A8%E5%86%8C">VM上下文的预注册</a> 中介绍。</p>
<pre><code class="language-go">conf := wasmedge.NewConfigure()
// 你也可以将提案作为参数传递：
// conf := wasmedge.NewConfigure(wasmedge.WASI)
conf.AddConfig(wasmedge.WASI)
conf.Release()
</code></pre>
</li>
<li>
<p>最大内存页数</p>
<p>你可以通过这个配置来限制内存实例的页面大小。当在 WASM 执行中增加内存实例的页面大小并超过限制大小时，会失败。此配置仅在 <code>Executor</code> 和 <code>VM</code> 对象中有效。</p>
<pre><code class="language-go">conf := wasmedge.NewConfigure()

pagesize := conf.GetMaxMemoryPage()

// 默认情况下，每个内存实例的最大内存页大小为 65536。
conf.SetMaxMemoryPage(1234)
pagesize := conf.GetMaxMemoryPage()
// `pagesize` 将是 1234。

conf.Release()
</code></pre>
</li>
<li>
<p>AOT 编译器选项</p>
<p>AOT 编译器选项配置有关优化级别、输出格式、转储 IR 和通用二进制文件的行为。</p>
<pre><code class="language-go">const (
    // 禁用尽可能多的优化。
    CompilerOptLevel_O0 = CompilerOptimizationLevel(C.WasmEdge_CompilerOptimizationLevel_O0)
    // 在不破坏可调试性的情况下快速优化。
    CompilerOptLevel_O1 = CompilerOptimizationLevel(C.WasmEdge_CompilerOptimizationLevel_O1)
    // 在不触发显着增量编译时间或代码大小增长的情况下尽可能地优化快速执行。
    CompilerOptLevel_O2 = CompilerOptimizationLevel(C.WasmEdge_CompilerOptimizationLevel_O2)
    // 尽可能优化快速执行。
    CompilerOptLevel_O3 = CompilerOptimizationLevel(C.WasmEdge_CompilerOptimizationLevel_O3)
    // 代码越小越好，而不会触发显着的编译时间增量或执行时间减慢。
    CompilerOptLevel_Os = CompilerOptimizationLevel(C.WasmEdge_CompilerOptimizationLevel_Os)
    // 代码越小越好。
    CompilerOptLevel_Oz = CompilerOptimizationLevel(C.WasmEdge_CompilerOptimizationLevel_Oz)
)

const (
    // 原生动态库格式。
    CompilerOutputFormat_Native = CompilerOutputFormat(C.WasmEdge_CompilerOutputFormat_Native)
    // WebAssembly 与自定义部分中的 AOT 编译代码。
    CompilerOutputFormat_Wasm = CompilerOutputFormat(C.WasmEdge_CompilerOutputFormat_Wasm)
)
</code></pre>
<p>这些配置仅在 <code>Compiler</code> 上下文中有效。</p>
<pre><code class="language-go">conf := wasmedge.NewConfigure()

// 默认优化级别为O3。
conf.SetCompilerOptimizationLevel(wasmedge.CompilerOptLevel_O2)
// 默认情况下，输出格式为通用 WASM。
conf.SetCompilerOutputFormat(wasmedge.CompilerOutputFormat_Native)
// 默认情况下，转储 IR 为 `false`。
conf.SetCompilerDumpIR(true)
// 默认情况下，通用二进制文件是 `false`。
conf.SetCompilerGenericBinary(true)

conf.Release()
</code></pre>
</li>
<li>
<p>统计选项</p>
<p>统计选项配置有关 Runtime 和 AOT 编译器中的指令计数、成本测量和时间测量的行为。
这些配置在 <code>Compiler</code>、<code>VM</code> 和 <code>Executor</code> 对象中有效。</p>
<pre><code class="language-go">conf := wasmedge.NewConfigure()

// 默认情况下，在运行已编译的 WASM 或纯 WASM 时，指令计数为 `false`。
conf.SetStatisticsInstructionCounting(true)
// 默认情况下，运行已编译的 WASM 或纯 WASM 时，成本度量为 `false`。
conf.SetStatisticsTimeMeasuring(true)
// 默认情况下，运行已编译的 WASM 或纯 WASM 时，时间测量为 `false`。
conf.SetStatisticsCostMeasuring(true)

conf.Release()
</code></pre>
</li>
</ol>
<h2 id="wasmedge-vm"><a class="header" href="#wasmedge-vm">WasmEdge VM</a></h2>
<p>在本部分中，我们将介绍 <code>wasmedge.VM</code> 对象的功能，并展示执行 WASM 功能的示例。</p>
<h3 id="带有-vm-对象的-wasm-执行示例"><a class="header" href="#带有-vm-对象的-wasm-执行示例">带有 VM 对象的 WASM 执行示例</a></h3>
<p>下面是使用 WASM 运行斐波那契的示例。
这个例子使用了 <a href="embed/go/../tools/wasmedge/examples/fibonacci.wasm">fibonacci.wasm</a>，对应的 WAT 文件在 <a href="embed/go/../tools/wasmedge/examples/fibonacci.wat">fibonacci.wat</a>。</p>
<pre><code class="language-wasm">(module
 (export &quot;fib&quot; (func $fib))
 (func $fib (param $n i32) (result i32)
  (if
   (i32.lt_s (get_local $n)(i32.const 2))
   (return (i32.const 1))
  )
  (return
   (i32.add
    (call $fib (i32.sub (get_local $n)(i32.const 2)))
    (call $fib (i32.sub (get_local $n)(i32.const 1)))
   )
  )
 )
)
</code></pre>
<ol>
<li>
<p>快速运行 WASM 函数</p>
<p>首先新建一个 Go 项目：</p>
<pre><code class="language-bash">mkdir wasmedge_test &amp;&amp; cd wasmedge_test
go mod init wasmedge_test
</code></pre>
<p>假设将 WASM 文件 <a href="embed/go/../tools/wasmedge/examples/fibonacci.wasm"><code>fibonacci.wasm</code></a> 复制到当前的 <code>wasmedge_test</code> 目录中，然后创建并编辑 Go 文件 <code>main.go</code>，如下所示：</p>
<pre><code class="language-go">package main

import (
    &quot;fmt&quot;

    &quot;github.com/second-state/WasmEdge-go/wasmedge&quot;
)

func main() {
    // 设置日志级别。
    wasmedge.SetLogErrorLevel()

    // 创建配置上下文并添加 WASI 支持。
    // 除非你需要 WASI 支持，否则此步骤不是必需的。
    conf := wasmedge.NewConfigure(wasmedge.WASI)
    // 使用配置创建虚拟机。
    vm := wasmedge.NewVMWithConfig(conf)

    res, err := vm.RunWasmFile(&quot;fibonacci.wasm&quot;, &quot;fib&quot;, uint32(21))
    if err == nil {
        fmt.Println(&quot;Get fibonacci[21]:&quot;, res[0].(int32))
    } else {
        fmt.Println(&quot;Run failed:&quot;, err.Error())
    }

    vm.Release()
    conf.Release()
}
</code></pre>
<p>然后，你可以使用 WasmEdge Golang SDK 构建和运行 Golang 应用程序：（第 21 个斐波那契数在从 0 开始的索引中为 17711）</p>
<pre><code class="language-bash">$ go get github.com/second-state/WasmEdge-go/wasmedge@v0.9.1
$ go build
$ ./wasmedge_test
Get fibonacci[21]: 17711
</code></pre>
</li>
<li>
<p>手动实例化和运行 WASM 函数</p>
<p>除了上面的示例，你还可以使用 <code>VM</code> 对象 API 逐步运行 WASM 函数：</p>
<pre><code class="language-go">package main

import (
    &quot;fmt&quot;

    &quot;github.com/second-state/WasmEdge-go/wasmedge&quot;
)

func main() {
    // 设置日志级别。
    wasmedge.SetLogErrorLevel()

    // 创建虚拟机。
    vm := wasmedge.NewVM()
    var err error
    var res []interface{}

    // 第 1 步：加载 WASM 文件。
    err = vm.LoadWasmFile(&quot;fibonacci.wasm&quot;)
    if err != nil {
        fmt.Println(&quot;Load WASM from file FAILED:&quot;, err.Error())
        return
    }

    // 第 2 步：验证 WASM 模块。
    err = vm.Validate()
    if err != nil {
        fmt.Println(&quot;Validation FAILED:&quot;, err.Error())
        return
    }

    // 第 3 步：实例化 WASM 模块。
    err = vm.Instantiate()
    // 你可以加载、验证和实例化另一个 WASM 模块替换实例化的。在这种情况下，旧模块将被清除，但注册的模块仍然保留。
    if err != nil {
        fmt.Println(&quot;Instantiation FAILED:&quot;, err.Error())
        return
    }

    // 第 4 步：执行 WASM 函数。参数：(funcname, args...)
    res, err = vm.Execute(&quot;fib&quot;, uint32(25))
    // 你可以在实例化后重复执行函数。
    if err == nil {
        fmt.Println(&quot;Get fibonacci[25]:&quot;, res[0].(int32))
    } else {
        fmt.Println(&quot;Run failed:&quot;, err.Error())
    }

    vm.Release()
}
</code></pre>
<p>然后你可以构建并运行：（第 25 个斐波那契数是 121393，基于 0 的索引）</p>
<pre><code class="language-bash">$ go build
$ ./wasmedge_test
Get fibonacci[25]: 121393
</code></pre>
<p>下图解释了 <code>VM</code> 对象的状态。</p>
<pre><code class="language-text">                       |========================|
              |-------&gt;|      虚拟机: 已初始化     |
              |        |========================|
              |                    |
              |                 LoadWasm
              |                    |
              |                    v
              |        |========================|
              |--------|       虚拟机: 已加载     |&lt;-------|
              |        |========================|        |
              |              |            ^              |
              |              验证          |              |
             清理             |          加载 WASM        |
              |              v            |            加载WASM
              |        |========================|        |
              |--------|      虚拟机: 已验证      |        |
              |        |========================|        |
              |              |            ^              |
              |            实例化          |              |
              |              |         RegisterMoulde    |
              |              v            |              |
              |        |========================|        |
              |--------|    虚拟机: 实例化        |--------|
                       |========================|
                             |            ^
                             |            |
                             --------------
                Instantiate, Execute, ExecuteRegistered,
                ExecuteBindgen, ExecuteBindgenRegistered
</code></pre>
<p><code>VM</code> 上下文的状态在创建时会是 <code>Inited</code>。
成功加载 WASM 后，状态将为 <code>Loaded</code>。
成功验证 WASM 后，状态将为 <code>Validated</code>。
WASM实例化成功后，状态为 <code>Instantiated</code>，你可以调用函数了。
你可以在任何状态下注册 WASM 或导入对象，但需要再次实例化 WASM。
你也可以在任何状态下加载 WASM，并且在函数调用之前应该验证和实例化 WASM 模块。
当处于 <code>Instantiated</code> 状态时，你可以再次实例化 WASM 模块以重置旧的 WASM Runtime 结构。</p>
</li>
<li>
<p>Wasm-bindgen 支持</p>
<p><code>(*VM).ExecuteBindgen</code> 和 <code>(*VM).ExecuteBindgenRegistered</code> 是支持 <code>wasm-bindgen</code> 函数执行的特殊函数。在 WasmEdge-go 中，我们支持以下 <code>wasm-bindgen</code> 函数的返回类型：</p>
<pre><code class="language-go">type bindgen int

const (
    Bindgen_return_void bindgen = iota
    Bindgen_return_i32 bindgen = iota
    Bindgen_return_i64 bindgen = iota
    Bindgen_return_array bindgen = iota
)
</code></pre>
<p>并且只接受 <code>int32</code>、<code>uint32</code>、<code>int64</code>、<code>uint64</code> 和 <code>[]byte</code> 参数。每个 <code>wasm-bindgen</code> 函数最多只有 1 个返回值。</p>
<pre><code class="language-go">// 以 wasm-bindgen 为例。
var res interface{}
var err error
res, err = vm.ExecuteBindgen(
    &quot;lowest_common_multiple&quot;,       // Function name
    wasmedge.Bindgen_return_i32,    // Return type: int32
    int32(123), int32(2)            // Parameters: int32, int32
)
if err == nil {
    fmt.Println(&quot;Run bindgen -- lowest_common_multiple:&quot;, res.(int32))
} 
res, err = vm.ExecuteBindgen(
    &quot;sha3_digest&quot;,                          // Function name
    wasmedge.Bindgen_return_array,          // Return type: []byte
    []byte(&quot;This is an important message&quot;)  // Parameter: []byte
)
if err == nil {
    fmt.Println(&quot;Run bindgen -- sha3_digest:&quot;, res.([]byte))
} 
</code></pre>
<p>有关完整示例，请参阅 <a href="embed/go/ref.html#%E4%BD%BF%E7%94%A8-wasm-bindgen-%E5%B5%8C%E5%85%A5%E5%87%BD%E6%95%B0%E7%9A%84%E7%A4%BA%E4%BE%8B">上面的示例</a>。</p>
</li>
</ol>
<h3 id="创建-vm"><a class="header" href="#创建-vm">创建 VM</a></h3>
<p><code>VM</code> 的创建 API 接收 <code>Configure</code> 对象和 <code>Store</code> 对象。
请注意，如果 <code>VM</code> 使用外部 <code>Store</code> 对象创建，则 <code>VM</code> 将在该 <code>Store</code> 对象上执行 WASM。如果将<code>Store</code>对象设置成多个<code>VM</code>对象，在执行时可能会造成数据冲突。
<code>Store</code> 对象的详细信息将在 <a href="embed/go/ref.html#Store">Store</a> 中介绍。</p>
<pre><code class="language-go">conf := wasmedge.NewConfigure()
store := wasmedge.NewStore()

// 使用默认配置和存储创建 VM。
vm := wasmedge.NewVM()
vm.Release()

// 使用指定的配置和默认存储创建 VM。
vm = wasmedge.NewVMWithConfig(conf)
vm.Release()

// 使用默认配置和指定存储创建 VM。
vm = wasmedge.NewVMWithStore(store)
vm.Release()

// 使用指定的配置和存储创建一个 VM。
vm = wasmedge.NewVMWithConfigAndStore(conf, store)
vm.Release()

conf.Release()
store.Release()
</code></pre>
<h3 id="预注册"><a class="header" href="#预注册">预注册</a></h3>
<p>WasmEdge 提供以下内置预注册。</p>
<ol>
<li>
<p><a href="https://github.com/WebAssembly/WASI">WASI（WebAssembly 系统接口）</a></p>
<p>你可以在 <code>Configure</code> 对象中开启对 VM 的 WASI 支持。</p>
<pre><code class="language-go">conf := wasmedge.NewConfigure(wasmedge.WASI)
// 或者你可以通过 `(*Configure).AddConfig` 将 `wasmedge.WASI` 设置到配置对象中。
vm := wasmedge.NewVMWithConfig(conf)
vm.Release()

// 以下 API 可以从 VM 对象中检索预注册导入对象。
// 如果未在配置中设置相应的预注册，此 API 将返回 `nil`。
wasiconf := conf.GetImportObject(wasmedge.WASI)
// 初始化 WASI。
wasiconf.InitWasi(/* ... 忽略 */)

conf.Release()
</code></pre>
<p>也可以从 API 创建 WASI 导入对象。详细内容将在 <a href="embed/go/ref.html#Host-%E5%87%BD%E6%95%B0">Host 函数</a> 和 <a href="embed/go/ref.html#Host-%E6%A8%A1%E5%9D%97%E6%B3%A8%E5%86%8C">Host 模块注册</a> 中介绍。</p>
</li>
<li>
<p><a href="https://crates.io/crates/wasmedge_process_interface">WasmEdge_Process</a></p>
<p>此预注册适用于 WasmEdge 在 <code>Rust</code> 源上的流程接口。
开启此预注册后，VM 将支持 <code>wasmedge_process</code> Host 函数。</p>
<pre><code class="language-go">conf := wasmedge.NewConfigure(wasmedge.WasmEdge_PROCESS)
vm := wasmedge.NewVMWithConfig(conf)
vm.Release()

// 以下 API 可以从 VM 对象中检索预注册导入对象。
// 如果未在配置中设置相应的预注册，此 API 将返回 `nil`。
procconf := conf.GetImportObject(wasmedge.WasmEdge_PROCESS)
// 初始化 WasmEdge_Process。
procconf.InitWasmEdgeProcess(/* ... 忽略 */)

conf.Release()
</code></pre>
<p>也可以从 API 创建 WasmEdge_Process 导入对象。详细内容将在 <a href="embed/go/ref.html#Host-%E5%87%BD%E6%95%B0">Host 函数</a> 和 <a href="embed/go/ref.html#Host-%E6%A8%A1%E5%9D%97%E9%A2%84%E6%B3%A8%E5%86%8C">Host 模块预注册</a> 中介绍。</p>
</li>
</ol>
<h3 id="host-模块注册"><a class="header" href="#host-模块注册">Host 模块注册</a></h3>
<p><a href="https://webassembly.github.io/spec/core/exec/runtime.html#syntax-hostfunc">Host 函数</a> 是 WebAssembly 之外的函数，并作为导入传递给 WASM 模块。 在 WasmEdge-go 中，Host 函数被组合成 Host 模块作为带有模块名称的 <code>ImportObject</code> 对象。详情请参考 <a href="embed/go/ref.html#Host-%E5%87%BD%E6%95%B0">WasmEdge Runtime 中的 Host 函数</a>。在本章中，我们展示了将 host 函数注册到 <code>VM</code> 对象中的示例。</p>
<pre><code class="language-go">vm := wasmedge.NewVM()
// 你也可以通过此 API 创建和注册 WASI Host 模块。
wasiobj := wasmedge.NewWasiImportObject(/* ... 忽略 ... */)

res := vm.RegisterImport(wasiobj)
// 应该检查结果状态。

vm.Release()
// 应该释放创建的导入对象。
wasiobj.Release()
</code></pre>
<h3 id="wasm-注册和执行"><a class="header" href="#wasm-注册和执行">WASM 注册和执行</a></h3>
<p>在 WebAssembly 中，WASM 模块中的实例可以被导出，也可以被其他 WASM 模块导入。WasmEdge VM 提供 API 供注册和导出任何 WASM 模块，并执行注册的 WASM 模块中的函数或 host 函数。</p>
<ol>
<li>
<p>使用导出的模块名称注册 WASM 模块</p>
<p>除非导入对象已经包含模块名称，否则每个 WASM 模块在注册时都应该唯一命名。下面展示了示例。</p>
<p>首先新建一个 Go 项目：</p>
<pre><code class="language-bash">mkdir wasmedge_test &amp;&amp; cd wasmedge_test
go mod init wasmedge_test
</code></pre>
<p>假设 WASM 文件 <a href="embed/go/../tools/wasmedge/examples/fibonacci.wasm"><code>fibonacci.wasm</code></a> 被复制到当前目录。
然后创建并编辑 Go 文件 <code>main.go</code>，如下所示：</p>
<pre><code class="language-go">package main

import &quot;github.com/second-state/WasmEdge-go/wasmedge&quot;

func main() {
    // 创建虚拟机。
    vm := wasmedge.NewVM()

    var err error
    err = vm.RegisterWasmFile(&quot;module_name&quot;, &quot;fibonacci.wasm&quot;)
    // 你可以通过 `[]byte` 注册 WASM 模块 `(*VM).RegisterWasmBuffer` 函数，或来自 `AST` 对象 `(*VM).RegisterAST` 函数。应该检查结果状态。如果 WASM 模块实例化失败或模块名称冲突。
    vm.Release()
}
</code></pre>
</li>
<li>
<p>执行注册的 WASM 模块中的功能</p>
<p>编辑 Go 文件 <code>main.go</code>，如下所示：</p>
<pre><code class="language-go">package main

import (
    &quot;fmt&quot;

    &quot;github.com/second-state/WasmEdge-go/wasmedge&quot;
)

func main() {
    // 创建虚拟机。
    vm := wasmedge.NewVM()

   var res []interface{}
    var err error
    // 使用模块名称 mod 将 WASM 模块从文件注册到 VM。
    err = vm.RegisterWasmFile(&quot;mod&quot;, &quot;fibonacci.wasm&quot;)
    // 你可以通过 `[]byte` 注册 WASM 模块 `(*VM).RegisterWasmBuffer` 函数，或来自 `AST` 对象 `(*VM).RegisterAST` 函数。
    if err != nil {
        fmt.Println(&quot;WASM registration failed:&quot;, err.Error())
        return
    }
    // `fibonacci.wasm` 中的函数 `fib` 与模块一起导出名称 `mod`。与 host 函数一样，其他模块可以导入函数 `mod fib`.

    // 在注册模块中执行 WASM 函数。
    // 与函数的执行不同，注册的函数可以在没有 `(*VM).Instantiate` 的情况下调用，因为 WASM 模块是注册时实例化。
    // 你也可以通过这个 API 直接调用 host 函数。
    res, err = vm.ExecuteRegistered(&quot;mod&quot;, &quot;fib&quot;, int32(25))
    if err == nil {
        fmt.Println(&quot;Get fibonacci[25]:&quot;, res[0].(int32))
    } else {
        fmt.Println(&quot;Run failed:&quot;, err.Error())
    }

    vm.Release()
}
</code></pre>
<p>然后你可以构建并运行：（第 25 个斐波那契数是 121393，基于 0 的索引）</p>
<pre><code class="language-bash">$ go get github.com/second-state/WasmEdge-go/wasmedge@v0.9.1
$ go build
$ ./wasmedge_test
Get fibonacci[25]: 121393
</code></pre>
</li>
</ol>
<h3 id="实例跟踪"><a class="header" href="#实例跟踪">实例跟踪</a></h3>
<p>有时你可能需要获取 WASM runtime 的实例。<code>VM</code> 对象提供 API 来检索实例。</p>
<ol>
<li>
<p>Store</p>
<p>如果在创建 <code>VM</code> 对象时没有分配 <code>Store</code> 对象，则 <code>VM</code> 上下文将分配并拥有一个 <code>Store</code>。</p>
<pre><code class="language-go">vm := wasmedge.NewVM()
store := vm.GetStore()
// 对象应该 __NOT__ 通过调用 `(*Store).Release` 被删除。
vm.Release()
</code></pre>
<p>你还可以使用 <code>Store</code> 对象创建 <code>VM</code> 对象。在这种情况下，你应该保证 <code>Store</code> 对象不能在 <code>VM</code> 对象之前被释放。有关 <code>Store</code> API 的详细信息，请参阅 <a href="embed/go/ref.html#Store">Store Objects</a>。</p>
<pre><code class="language-go">store := wasmedge.NewStore()
vm := wasmedge.NewVMWithStore(store)

storemock := vm.GetStore()
// `store` 和 `storemock` 的内部存储上下文是相同的。

vm.Release()
store.Release()
</code></pre>
</li>
<li>
<p>列出导出的函数</p>
<p>WASM 模块实例化后，你可以使用 <code>(*VM).Execute</code> 函数调用导出的 WASM 函数。为此，你可能需要有关导出的 WASM 函数列表的信息。
有关函数类型的详细信息，请参阅 <a href="embed/go/ref.html#Instances">Runtime 实例</a>。</p>
<p>假设创建了一个新的 Go 项目，如下所示：</p>
<pre><code class="language-bash">mkdir wasmedge_test &amp;&amp; cd wasmedge_test
go mod init wasmedge_test
</code></pre>
<p>然后假设将 WASM 文件 <a href="embed/go/../tools/wasmedge/examples/fibonacci.wasm"><code>fibonacci.wasm</code></a> 复制到当前目录，并创建并编辑 Go 文件 <code>main.go</code>：</p>
<pre><code class="language-go">package main

import (
    &quot;fmt&quot;

    &quot;github.com/second-state/WasmEdge-go/wasmedge&quot;
)

func main() {
    // 创建虚拟机。
    vm := wasmedge.NewVM()

    // 第 1 步：加载 WASM 文件。
    err := vm.LoadWasmFile(&quot;fibonacci.wasm&quot;)
    if err != nil {
        fmt.Println(&quot;Load WASM from file FAILED:&quot;, err.Error())
        return
    }

    // 第 2 步：验证 WASM 模块。
    err = vm.Validate()
    if err != nil {
        fmt.Println(&quot;Validation FAILED:&quot;, err.Error())
        return
    }

    // 第 3 步：实例化 WASM 模块。
    err = vm.Instantiate()
    if err != nil {
        fmt.Println(&quot;Instantiation FAILED:&quot;, err.Error())
        return
    }

    // 列出导出函数的名称和函数类型。
    funcnames, functypes := vm.GetFunctionList()
    for _, fname := range funcnames {
        fmt.Println(&quot;Exported function name:&quot;, fname)
    }
    for _, ftype := range functypes {
        // `ftype` 是 `funcnames` 数组中相同索引的 `FunctionType` 对象。
        // 你应该 __NOT__ 调用 `ftype.Release()`。
    }

    vm.Release()
}
</code></pre>
<p>然后你可以构建并运行：（ <code>fibonacci.wasm</code> 中唯一导出的函数是 <code>fib</code> ）</p>
<pre><code class="language-bash">$ go get github.com/second-state/WasmEdge-go/wasmedge@v0.9.1
$ go build
$ ./wasmedge_test
Exported function name: fib
</code></pre>
<p>如果你想在注册的 WASM 模块中获取导出的函数名，请从 <code>VM</code> 对象中获取 <code>Store</code> 对象，参考 <a href="embed/go/ref.html#Store">Store Contexts</a> 的 API 按模块列出注册的函数名称。</p>
</li>
<li>
<p>获取函数类型</p>
<p><code>VM</code> 对象提供 API 以通过函数名称查找函数类型。
有关函数类型的详细信息，请参阅 <a href="embed/go/ref.html#Instances">Runtime 实例</a>。</p>
<pre><code class="language-go">// 假设一个 WASM 模块在 `vm` 中实例化，它是一个 `wasmedge.VM` 对象。
functype := vm.GetFunctionType(&quot;fib&quot;)
// 你可以通过
// `(*VM).GetFunctionTypeRegistered` API，带有函数名和模块名。
// 如果未找到该函数，这些 API 将返回 `nil`。
// 你应该__NOT__调用返回对象的`(*FunctionType).Release`函数。
</code></pre>
</li>
</ol>
<h2 id="wasmedge-runtime"><a class="header" href="#wasmedge-runtime">WasmEdge Runtime</a></h2>
<p>接下来，我们将一步步的介绍 WasmEdge Runtime。</p>
<h3 id="wasm-执行示例手把手教程"><a class="header" href="#wasm-执行示例手把手教程">WASM 执行示例手把手教程</a></h3>
<p>除了通过 <a href="embed/go/ref.html#WasmEdge-VM"><code>VM</code> 对象</a> 快速执行 WASM 之外，你还可以通过 <code>Loader</code>、<code>Validator</code>、<code>Executor</code> 和 <code>Store</code> 执行、初始化 WASM。</p>
<p>假设创建了一个新的 Go 项目，如下所示：</p>
<pre><code class="language-bash">mkdir wasmedge_test &amp;&amp; cd wasmedge_test
go mod init wasmedge_test
</code></pre>
<p>然后将 WASM 文件 <a href="embed/go/../tools/wasmedge/examples/fibonacci.wasm"><code>fibonacci.wasm</code></a> 复制到当前目录，创建并编辑 Go 文件 <code>main.go</code>：</p>
<pre><code class="language-go">package main

import (
    &quot;fmt&quot;

    &quot;github.com/second-state/WasmEdge-go/wasmedge&quot;
)

func main() {
    // 将日志级别设置为调试以打印统计信息。
    wasmedge.SetLogDebugLevel()
    // 创建配置对象。如果你使用默认配置，则不需要这样做。
    conf := wasmedge.NewConfigure()
    // 打开 runtime 指令计数和时间测量。
    conf.SetStatisticsInstructionCounting(true)
    conf.SetStatisticsTimeMeasuring(true)
    // 创建统计对象。如果不需要 runtime 的统计信息，这不是必需的。
    stat := wasmedge.NewStatistics()
    // 创建存储对象。store 对象是 WASM runtime 结构的核心。
    store := wasmedge.NewStore()

    var err error
    var res []interface{}
    var ast *wasmedge.AST
    // 创建加载器对象。
    // 对于使用默认配置创建加载器，你可以使用 `wasmedge.NewLoader()` 代替。
    loader := wasmedge.NewLoaderWithConfig(conf)
    // 创建验证器对象。
    // 对于使用默认配置创建验证器，你可以使用 `wasmedge.NewValidator()` 代替。
    validator := wasmedge.NewValidatorWithConfig(conf)
    // 创建执行器对象。
    // 对于使用默认配置且没有统计信息的执行器创建，你可以使用 `wasmedge.NewExecutor()` 代替。
    executor := wasmedge.NewExecutorWithConfigAndStatistics(conf, stat)

    // 加载 WASM 文件或编译后的 WASM 文件并转换为 AST 模块对象。
    ast, err = loader.LoadFile(&quot;fibonacci.wasm&quot;)
    if err != nil {
        fmt.Println(&quot;Load WASM from file FAILED:&quot;, err.Error())
        return
    }
    // 验证 WASM 模块。
    err = validator.Validate(ast)
    if err != nil {
        fmt.Println(&quot;Validation FAILED:&quot;, err.Error())
        return
    }
    // 将 WASM 模块实例化为 Store 对象。
    err = executor.Instantiate(store, ast)
    if err != nil {
        fmt.Println(&quot;Instantiation FAILED:&quot;, err.Error())
        return
    }

    // 尝试列出实例化的 WASM 模块的导出函数。
    funcnames := store.ListFunction()
    for _, fname := range funcnames {
        fmt.Println(&quot;Exported function name:&quot;, fname)
    }

    // 调用 WASM 函数。
    res, err = executor.Invoke(store, &quot;fib&quot;, int32(30))
    if err == nil {
        fmt.Println(&quot;Get fibonacci[30]:&quot;, res[0].(int32))
    } else {
        fmt.Println(&quot;Run failed:&quot;, err.Error())
    }

    // 资源释放。
    conf.Release()
    stat.Release()
    ast.Release()
    loader.Release()
    validator.Release()
    executor.Release()
    store.Release()
}
</code></pre>
<p>然后你可以构建并运行：（从 30 开始的第 18 个斐波那契数是 1346269 ）</p>
<pre><code class="language-bash">$ go get github.com/second-state/WasmEdge-go/wasmedge@v0.9.1
$ go build
$ ./wasmedge_test
Exported function name: fib
[2021-11-24 18:53:01.451] [debug]  Execution succeeded.
[2021-11-24 18:53:01.452] [debug]
 ====================  Statistics  ====================
 Total execution time: 556372295 ns
 Wasm instructions execution time: 556372295 ns
 Host functions execution time: 0 ns
 Executed wasm instructions count: 28271634
 Gas costs: 0
 Instructions per second: 50814237
Get fibonacci[30]: 1346269
</code></pre>
<h3 id="加载器"><a class="header" href="#加载器">加载器</a></h3>
<p><code>Loader</code> 对象从文件或缓冲区加载 WASM 二进制文件。
支持 <a href="embed/go/ref.html#WasmEdge-AOT-Compiler">WasmEdge AOT Compiler</a> 中的 WASM 和已编译的 WASM。</p>
<pre><code class="language-go">var buf []byte
// ... 将 WASM 代码读取到 `buf`。

// 你可以在配置对象中调整设置。
conf := wasmedge.NewConfigure()
// 创建加载器对象。
// 对于使用默认配置创建加载器，你可以使用 `wasmedge.NewLoader()` 代替。
loader := wasmedge.NewLoaderWithConfig(conf)
conf.Release()

// 从文件中加载 WASM 或已编译的 WASM。
ast, err := loader.LoadFile(&quot;fibonacci.wasm&quot;)
if err != nil {
    fmt.Println(&quot;Load WASM from file FAILED:&quot;, err.Error())
} else {
    // 应该释放输出的 AST 对象。
    ast.Release()
}

// 从缓冲区加载 WASM 或编译后的 WASM
ast, err = loader.LoadBuffer(buf)
if err != nil {
    fmt.Println(&quot;Load WASM from buffer FAILED:&quot;, err.Error())
} else {
    // 应该释放输出的 AST 对象。
    ast.Release()   
}

loader.Release()
</code></pre>
<h3 id="验证器"><a class="header" href="#验证器">验证器</a></h3>
<p><code>Validator</code> 对象可以验证 WASM 模块。<br />
每个 WASM 模块都应该在实例化之前进行验证。</p>
<pre><code class="language-go">// ...
// 假设 `ast` 是加载器上下文的输出 `*wasmedge.AST` 对象。
// 假设 `conf` 是 `*wasmedge.Configure` 对象。

// 创建验证器上下文。
// 对于使用默认配置创建验证器，你可以使用 `wasmedge.NewValidator()` 代替。
validator := wasmedge.NewValidatorWithConfig(conf)

err := validator.Validate(ast)
if err != nil {
    fmt.Println(&quot;Validation FAILED:&quot;, err.Error())
}

validator.Release()
</code></pre>
<h3 id="执行器"><a class="header" href="#执行器">执行器</a></h3>
<p><code>Executor</code> 对象是 WASM 和编译型 WASM 的执行器。
这个对象应该基于 <code>Store</code> 对象工作。<code>Store</code> 对象的详细信息，请参考 <a href="embed/go/ref.html#Store">下一章</a>。</p>
<ol>
<li>
<p>注册模块</p>
<p>与 <code>VM</code> 对象中的<a href="embed/go/ref.html#Host-%E6%A8%A1%E5%9D%97%E9%A2%84%E6%B3%A8%E5%86%8C">Host 模块注册</a>或<a href="embed/go/ref.html#WASM-Registrations-And-Executions">导入 WASM 模块</a>相同，你可以注册 <code>ImportObject</code> 或 <code>AST</code> 对象通过 <code>Executor</code> API 进入 <code>Store</code> 对象。
有关导入对象的详细信息，请参阅<a href="embed/go/ref.html#Host-%E5%87%BD%E6%95%B0">Host 函数</a>。</p>
<pre><code class="language-go">// ...
// 假设 `ast` 是加载器的输出 `*wasmedge.AST` 对象并且通过了验证。
// 假设 `conf` 是 `*wasmedge.Configure` 对象。

// 创建统计对象。如果不需要统计数据，则无需此步骤。
stat := wasmedge.NewStatistics()
// 创建执行器对象。
// 使用默认配置创建执行器，没有统计信息，你可以使用 `wasmedge.NewExecutor()` 代替。
executor := wasmedge.NewExecutorWithConfigAndStatistics(conf, stat)
// 创建存储对象。store 是 WASM runtime 结构的核心。
store := wasmedge.NewStore()

// 使用导出模块名称 mod 将加载的 WASM `ast` 注册到 store 中。
res := executor.RegisterModule(store, ast, &quot;mod&quot;)
if err != nil {
    fmt.Println(&quot;WASM registration FAILED:&quot;, err.Error())
    return
}

// 假设 `impobj` 是 Host 函数的 `*wasmedge.ImportObject`。
impobj := ...
err = executor.RegisterImport(store, impobj)
if err != nil {
    fmt.Println(&quot;Import object registration FAILED:&quot;, err.Error())
    return
}

executor.Release()
stat.Release()
store.Release()
impobj.Release()
</code></pre>
</li>
<li>
<p>实例化模块</p>
<p>WASM 或已编译的 WASM 模块应在函数调用之前实例化。请注意，你只能将一个模块实例化到 <code>Store</code> 对象中，在这种情况下，旧的实例化模块将被清除。在实例化 WASM 模块之前，请检查 <a href="https://webassembly.github.io/spec/core/syntax/modules.html#syntax-import">import section</a> 以确保将导入注册到 <code>Store</code> 对象中.</p>
<pre><code class="language-go">// ...
// 假设 `ast` 是加载器的输出 `*wasmedge.AST` 对象并且通过了验证。
// 假设 `conf` 是 `*wasmedge.Configure` 对象。

// 创建统计对象。如果统计数据，则无需此步骤不需要。
stat := wasmedge.NewStatistics()
// 创建执行器对象。
// 使用默认配置创建执行器，没有统计信息，
// 你可以使用 `wasmedge.NewExecutor()` 代替。
executor := wasmedge.NewExecutorWithConfigAndStatistics(conf, stat)
// 创建存储对象。store 是 WASM Runtime 结构的核心。
store := wasmedge.NewStore()

// 实例化 WASM 模块。
err := executor.Instantiate(stpre, ast)
if err != nil {
    fmt.Println(&quot;WASM instantiation FAILED:&quot;, err.Error())
    return
}

executor.Release()
stat.Release()
store.Release()
</code></pre>
</li>
<li>
<p>调用函数</p>
<p>与通过 <code>VM</code> 对象调用函数一样，你可以调用实例化或注册的模块的函数。API <code>(*Executor).Invoke</code> 和 <code>(*Executor).InvokeRegistered</code> 与 <code>VM</code> 对象的 API 类似。有关详细信息，请参阅 <a href="embed/go/ref.html#WASM-Execution-Example-With-VM-Object">VM 上下文工作流</a>。</p>
</li>
</ol>
<h3 id="ast-模块"><a class="header" href="#ast-模块">AST 模块</a></h3>
<p><code>AST</code> 对象表示从 WASM 文件或缓冲区加载的结构。从 <a href="embed/go/ref.html#Loader">Loader</a> 加载一个 WASM 文件或缓冲区后会得到这个对象。在实例化之前，你还可以查询 <code>AST</code> 对象的导入和导出。</p>
<pre><code class="language-go">ast := ...
// 假设 WASM 从 loader 加载到 `*wasmedge.AST` 对象中。

// 列出导入。
imports := ast.ListImports()
for _, import := range imports {
    fmt.Println(&quot;Import:&quot;, import.GetModuleName(), import.GetExternalName())
}

// 列出导出。
exports := ast.ListExports()
for _, export := range exports {
    fmt.Println(&quot;Export:&quot;, export.GetExternalName())
}


ast.Release()
</code></pre>
<h3 id="store"><a class="header" href="#store">Store</a></h3>
<p><a href="https://webassembly.github.io/spec/core/exec/runtime.html#store">Store</a> 是 runtime 结构，用于表示在抽象机（Abstract Machine）的生命周期分配的所有 <code>Function</code>、 <code>Table</code>、<code>Memory</code> 和 <code>Global</code> 实例。
WasmEdge-go 中的 Store 对象提供了 API 来列出导出的实例及其名称或通过导出的名称查找实例。要将实例添加到 <code>Store</code> 对象中，请通过 <code>Executor</code> API 实例化或注册 WASM 模块或 <code>ImportObject</code> 对象。</p>
<ol>
<li>
<p>列出实例</p>
<pre><code class="language-go">store := wasmedge.NewStore()
// ...
// 通过 `*wasmedge.Executor` 对象实例化一个 WASM 模块。
// ...

// 尝试列出实例化的 WASM 模块的导出函数。
// 这里以函数实例为例。
funcnames := store.ListFunction()
for _, name := range funcnames {
    fmt.Println(&quot;Exported function name:&quot;, name)
}

store.Release()
</code></pre>
<p>你可以通过 <code>(*Store).ListFunctionRegistered()</code> API 列出已注册模块的函数实例导出名称和模块名称。</p>
</li>
<li>
<p>查找实例</p>
<pre><code class="language-go">store := wasmedge.NewStore()
// ...
// 通过 `*wasmedge.Executor` 对象实例化一个 WASM 模块。
// ...

// 尝试查找实例化的 WASM 模块的导出函数。
// 这里以函数实例为例。
funcobj := store.FindFunction(&quot;fib&quot;)
// 如果找不到函数，`funcobj` 将为 `nil`。

store.Release()
</code></pre>
<p>你可以通过 <code>(*Store).FindFunctionRegistered</code> API 获取已注册模块的导出函数实例，并带有模块名称。</p>
</li>
<li>
<p>列出已注册的模块</p>
<p>使用模块名称，你可以列出已注册模块的导出实例及其名称。</p>
<pre><code class="language-go">store := wasmedge.NewStore()
// ...
// 通过 `*wasmedge.Executor` 对象实例化一个 WASM 模块。
// ...

// 尝试列出已注册的 WASM 模块。
modnames := store.ListModule()
for _, name := range modnames {
    fmt.Println(&quot;Registered module names:&quot;, name)
}

store.Release()
</code></pre>
</li>
</ol>
<h3 id="实例"><a class="header" href="#实例">实例</a></h3>
<p>实例是 WASM 的 Runtime 结构。你可以从 <code>Store</code> 对象中检索实例。当通过 <code>Executor</code> 注册或实例化 WASM 模块或 <code>ImportObject</code> 时，<code>Store</code> 对象将分配实例。单个实例可以通过它的创建函数来分配。你可以将实例构造成一个 <code>ImportObject</code> 进行注册。详情请参阅<a href="embed/go/ref.html#Host-%E5%87%BD%E6%95%B0">host 函数</a>。由它们的创建函数创建的实例应该被销毁，除非它们被添加到一个 <code>ImportObject</code> 对象中。</p>
<ol>
<li>
<p>函数实例</p>
<p><a href="https://webassembly.github.io/spec/core/exec/runtime.html#syntax-hostfunc">host 函数</a> 是 WebAssembly 之外的函数，并作为导入传递给 WASM 模块。在 WasmEdge 中，你可以为 Host 函数创建 <code>Function</code> 对象，并将它们添加到 <code>ImportObject</code> 对象中，以便注册到 <code>VM</code> 或 <code>Store</code> 中。对于 Host 函数和从 <code>Store</code> 获取的函数，你可以从 <code>Function</code> 对象中检索 <code>FunctionType</code>。<code>Host Function</code> 指南的详细内容请参考 <a href="embed/go/ref.html#Host-Functions">下一章</a>。</p>
<pre><code class="language-go">funcinst := ...
// `funcobj` 是从 store 对象中检索到的 `*wasmedge.Function`。
functype := funcobj.GetFunctionType()
// 从 store 对象中检索到的 `funcobj` 应该 __NOT__ 被释放。
// 从 `funcobj` 检索到的 `functype` 应该 __NOT__ 被释放。
</code></pre>
<ol>
<li>
<p>表实例</p>
<p>在 WasmEdge 中，你可以创建 <code>Table</code> 对象并将它们添加到 <code>ImportObject</code> 对象中，以便注册到 <code>VM</code> 或 <code>Store</code> 中。
<code>Table</code> 对象提供 API 来控制表实例中的数据。</p>
<pre><code class="language-go">lim := wasmedge.NewLimitWithMax(10, 20)
// 创建具有限制和 `FuncRef` 元素类型的表类型。
tabtype := wasmedge.NewTableType(wasmedge.RefType_FuncRef, lim)
// 创建具有表类型的表实例。
tabinst := wasmedge.NewTable(tabtype)
// 删除表类型。
tabtype.Release()

gottabtype := tabinst.GetTableType()
// 从表实例中得到的 `gottabtype` 归 `tabinst` 所有
// 并且应该 __NOT__ 被释放。
reftype := gottabtype.GetRefType()
// `reftype` 将是 `wasmedge.RefType_FuncRef`。

var gotdata 接口{}
data := wasmedge.NewFuncRef(5)
err := tabinst.SetData(data, 3)
// 将函数索引 5 设置为 table[3]。

// 下面的行会得到一个“out of bounds table access”错误，因为位置 (13) 超出了表大小 (10)：
// err = tabinst.SetData(data, 13)

gotdata, err = tabinst.GetData(3)
// 获取 table[3] 的 FuncRef 值。

// 下面的行会得到一个“out of bounds table access”错误，因为位置 (13) 超出了表大小 (10)：
// gotdata, err = tabinst.GetData(13)

tabsize := tabinst.GetSize()
// `tabsize` 将是 10。
err = tabinst.Grow(6)
// 将表大小增加到 6，表大小将是 16。

// 下面的行会得到一个“out of bounds table access”错误
// 因为大小 (16 + 6) 将达到表限制 (20):
// err = tabinst.Grow(6)

tabinst.Release()
</code></pre>
</li>
</ol>
</li>
<li>
<p>内存实例</p>
<p>在 WasmEdge 中，你可以创建 <code>Memory</code> 对象并将它们添加到 <code>ImportObject</code> 对象中，以便注册到 <code>VM</code> 或 <code>Store</code> 中。<code>Memory</code> 对象提供 API 来控制内存实例中的数据。</p>
<pre><code class="language-go">lim := wasmedge.NewLimitWithMax(1, 5)
// 创建有限制的内存类型。内存页大小为 64KiB。
memtype := wasmedge.NewMemoryType(lim)
// 创建内存类型的内存实例。
meminst := wasmedge.NewMemory(memtype)
// 删除内存类型。
memtype.Release()

data := []byte(&quot;A quick brown fox jumps over the lazy dog&quot;)
err := meminst.SetData(data, 0x1000, 10)
// 将数据[0:9]设置为内存[4096:4105]。

// 下面的行会得到一个“内存访问越界”的错误
// 因为 [65535:65544] 超出 1 个页面大小 (65536)：
// err = meminst.SetData(data, 0xFFFF, 10)

var gotdata []byte
gotdata, err = meminst.GetData(0x1000, 10)
// 获取内存[4096:4105]。`gotdata` 将是 `[]byte(&quot;A quick br&quot;)。
// 下面的行会得到一个“内存访问越界”的错误，因为 [65535:65544] 超出 1 个页面大小 (65536)：gotdata, err = meminst.Getdata(0xFFFF, 10)

pagesize := meminst.GetPageSize()
// `pagesize` 将为 1。
err = meminst.GrowPage(2)
// 增加 2 的页面大小，内存实例的页面大小将是 3。

// 下面的行会得到一个“内存访问越界”的错误，因为大小 (3 + 3) 将达到内存限制 (5): err = meminst.GetPageSize(3)

meminst.Release()
</code></pre>
</li>
<li>
<p>全局实例</p>
<p>在 WasmEdge 中，你可以创建 <code>Global</code> 对象并将它们添加到 <code>ImportObject</code> 对象中，以便注册到 <code>VM</code> 或 <code>Store</code> 中。
<code>Global</code> 对象提供 API 来控制全局实例中的值。</p>
<pre><code class="language-go">// 创建具有值类型和突变的全局类型。
globtype := wasmedge.NewGlobalType(wasmedge.ValType_I64, wasmedge.ValMut_Var)
// 创建具有值和全局类型的全局实例。
globinst := wasmedge.NewGlobal(globtype, uint64(1000))
// 删除全局类型。
globtype.Release()

gotglobtype := globinst.GetGlobalType()
// 从全局实例获取的 `gotglobtype` 归 `globinst` 所有
// 并且应该 __NOT__ 被释放。
valtype := gotglobtype.GetValType()
// `valtype` 将是 `wasmedge.ValType_I64`。
valmut := gotglobtype.GetMutability()
// `valmut` 将是 `wasmedge.ValMut_Var`。

globinst.SetValue(uint64(888))
// 将值 u64(888) 设置为全局。
// 如果值类型不匹配或
// 全局可变性是 `wasmedge.ValMut_Const`。
gotval := globinst.GetValue()
// `gotbal` 将是 `interface{}` 类型为 `uint64` 和
// 值为 888。

globinst.Release()
</code></pre>
</li>
</ol>
<h3 id="host-函数"><a class="header" href="#host-函数">Host 函数</a></h3>
<p><a href="https://webassembly.github.io/spec/core/exec/runtime.html#syntax-hostfunc">Host 函数</a> 是 WebAssembly 之外的函数，并作为导入传递给 WASM 模块。
在 WasmEdge-go 中，你可以创建 <code>Function</code>、<code>Memory</code>、<code>Table</code> 和 <code>Global</code> 对象并将它们添加到 <code>ImportObject</code> 对象中，以便注册到 <code>VM</code> 或 <code>Store</code> 中。</p>
<ol>
<li>
<p>Host 功能分配</p>
<p>你可以定义具有以下函数签名的 Go 函数作为 Host 函数体：</p>
<pre><code class="language-go">type hostFunctionSignature func(
    data interface{}, mem *Memory, params []interface{}) ([]interface{}, Result)
</code></pre>
<p>添加 2 个 <code>i32</code> 值的 <code>add</code> Host 函数示例：</p>
<pre><code class="language-c">func host_add(data interface{}, mem *wasmedge.Memory, params []interface{}) ([]interface{}, wasmedge.Result) {
    // 添加：i32, i32 -&gt; i32
    res := params[0].(int32) + params[1].(int32)

    // 设置返回
    returns := make([]interface{}, 1)
    returns[0] = res

    // 返回
    return returns, wasmedge.Result_Success
}
</code></pre>
<p>然后你可以创建带有 Host 函数体和函数类型的 <code>Function</code> 对象：</p>
<pre><code class="language-go">// 创建一个函数类型：{i32, i32} -&gt; {i32}。
functype := wasmedge.NewFunctionType(
    []wasmedge.ValType{wasmedge.ValType_I32, wasmedge.ValType_I32},
    []wasmedge.ValType{wasmedge.ValType_I32},
)

// 使用函数类型和 Host 函数体创建函数上下文。
// 第三个参数是指向附加数据的指针。
// 你要保证数据的生命周期，可以
// 如果不需要外部数据，则为 `nil`。
// 如果你不需要成本计量，最后一个参数可以为0。
func_add := wasmedge.NewFunction(functype, host_add, nil, 0)

// 如果函数对象未添加到导入对象对象中，则应将其释放。
func_add.Release()
functype.Release()
</code></pre>
</li>
<li>
<p>导入对象</p>
<p><code>ImportObject</code> 对象包含一个导出模块名称和实例。你可以添加 <code>Function</code>、<code>Memory</code>、<code>Table</code> 和 <code>Global</code> 实例及其导出名称。</p>
<pre><code class="language-go">// Host 函数体定义。
func host_add(data interface{}, mem *wasmedge.Memory, params []interface{}) ([]interface{}, wasmedge.Result) {
    // 添加：i32, i32 -&gt; i32
    res := params[0].(int32) + params[1].(int32)

    // 设置返回
    returns := make([]interface{}, 1)
    returns[0] = res

    // 返回
    return returns, wasmedge.Result_Success
}

// 创建模块名称为 `module` 的导入对象。
impobj := wasmedge.NewImportObject(&quot;module&quot;)

// 创建一个函数实例并将其添加到导出名称为 `add` 的导入对象中。
functype := wasmedge.NewFunctionType(
    []wasmedge.ValType{wasmedge.ValType_I32, wasmedge.ValType_I32},
    []wasmedge.ValType{wasmedge.ValType_I32},
)
hostfunc := wasmedge.NewFunction(functype, host_add, nil, 0)
functype.Release()
impobj.AddFunction(&quot;add&quot;, hostfunc)

// 创建一个表实例并将其添加到导出名称为 `table` 的导入对象中。
tabtype := wasmedge.NewTableType(wasmedge.RefType_FuncRef ,wasmedge.NewLimitWithMax(10, 20))
hosttab := wasmedge.NewTable(tabtype)
tabtype.Release()
impobj.AddTable(&quot;table&quot;, hosttab)

// 创建一个内存实例并将其添加到导出名称为 `memory` 的导入对象中。
memtype := wasmedge.NewMemoryType(wasmedge.NewLimitWithMax(1, 2))
hostmem := wasmedge.NewMemory(memtype)
memtype.Release()
impobj.AddMemory(&quot;memory&quot;, hostmem)

// 创建一个全局实例并将其添加到导出名称为 `global` 的导入对象中。
globtype := wasmedge.NewGlobalType(wasmedge.ValType_I32, wasmedge.ValMut_Var)
hostglob := wasmedge.NewGlobal(globtype, uint32(666))
globtype.Release()
impobj.AddGlobal(&quot;global&quot;, hostglob)

// 导入对象应该被释放。
// 你应该 __NOT__ 释放添加到导入对象对象中的实例。
impobj.Release()
</code></pre>
</li>
<li>
<p>指定导入对象</p>
<p><code>wasmedge.NewWasiImportObject()</code> API 可以创建和初始化 <code>WASI</code> 导入对象。
<code>wasmedge.NewWasmEdgeProcessImportObject()</code> API 可以创建和初始化 <code>wasmedge_process</code> 导入对象。
你可以创建这些导入对象对象并将它们注册到 <code>Store</code> 或 <code>VM</code> 对象中，而不是调整 <code>Configure</code> 对象中的设置。</p>
<pre><code class="language-go">wasiobj := wasmedge.NewWasiImportObject(
    os.Args[1:], // 参数
    os.Environ(), // 环境
    []string{&quot;.:.&quot;}, // 映射预打开
)
procobj := wasmedge.NewWasmEdgeProcessImportObject(
    []string{&quot;ls&quot;, &quot;echo&quot;}, // 允许的命令
    false, // 不允许所有命令
)

// 将 WASI 和 WasmEdge_Process 注册到 VM 对象中。
vm := wasmedge.NewVM()
vm.RegisterImport(wasiobj)
vm.RegisterImport(procobj)

// ... 执行一些 WASM 函数。

// 获取 WASI 退出代码。
exitcode := wasiobj.WasiGetExitCode()
// 如果 WASI 函数“_start”执行没有错误，则 `exitcode` 将为 0。
// 否则，它将返回相关的退出代码。

vm.Release()
// 应该删除导入对象。
wasiobj.Release()
procobj.Release()
</code></pre>
</li>
<li>
<p>例子</p>
<p>首先新建一个 Go 项目：</p>
<pre><code class="language-bash">mkdir wasmedge_test &amp;&amp; cd wasmedge_test
go mod init wasmedge_test
</code></pre>
<p>假设 WAT 中有一个简单的 WASM，如下所示：</p>
<pre><code class="language-wasm">(module
  (type $t0 (func (param i32 i32) (result i32)))
  (import &quot;extern&quot; &quot;func-add&quot; (func $f-add (type $t0)))
  (func (export &quot;addTwo&quot;) (param i32 i32) (result i32)
    local.get 0
    local.get 1
    call $f-add)
)
</code></pre>
<p>创建并编辑 Go 文件 <code>main.go</code>，如下所示：</p>
<pre><code class="language-go">package main

import (
    &quot;fmt&quot;

    &quot;github.com/second-state/WasmEdge-go/wasmedge&quot;
)

// Host 函数体定义。
func host_add(data interface{}, mem *wasmedge.Memory, params []interface{}) ([]interface{}, wasmedge.Result) {
    // 添加：i32, i32 -&gt; i32
    res := params[0].(int32) + params[1].(int32)

    // 设置返回
  returns := make([]interface{}, 1)
    returns[0] = res

    // 返回
    return returns, wasmedge.Result_Success
}

func main() {
    // 创建虚拟机对象。
    vm := wasmedge.NewVM()

    // WASM 模块缓冲区。
    wasmbuf := []字节{
        /* WASM 头文件 */
        0x00, 0x61, 0x73, 0x6D, 0x01, 0x00, 0x00, 0x00,
        /* 类型部分 */
        0x01, 0x07, 0x01,
        /* 函数类型 {i32, i32} -&gt; {i32} */
        0x60, 0x02, 0x7F, 0x7F, 0x01, 0x7F,
        /* 导入部分 */
        0x02, 0x13, 0x01, 
        /* 模块名称：“extern” */
        0x06, 0x65, 0x78, 0x74, 0x65, 0x72, 0x6E, 
        /* 外部名称：“func-add” */
        0x08, 0x66, 0x75, 0x6E, 0x63, 0x2D, 0x61, 0x64, 0x64,
        /* 导入描述：函数 0 */
        0x00, 0x00,
        /* 函数部分 */
        0x03, 0x02, 0x01, 0x00,
        /* 导出部分 */
        0x07, 0x0A, 0x01,
        /* 导出名称：`addTwo` */
        0x06, 0x61, 0x64, 0x64, 0x54, 0x77, 0x6F, 
        /* 导出描述：函数 0 */
        0x00, 0x01,
        /* 代码部分 */
        0x0A, 0x0A, 0x01, 
        /* 代码主体 */
        0x08, 0x00, 0x20, 0x00, 0x20, 0x01, 0x10, 0x00, 0x0B,
    }

    // 创建模块名称为 `extern` 的导入对象。
    impobj := wasmedge.NewImportObject(&quot;extern&quot;)

    // 创建一个函数实例并将其添加到导出名称为 `func-add` 的导入对象中。
    functype := wasmedge.NewFunctionType(
        []wasmedge.ValType{wasmedge.ValType_I32, wasmedge.ValType_I32},
        []wasmedge.ValType{wasmedge.ValType_I32},
    )
    hostfunc := wasmedge.NewFunction(functype, host_add, nil, 0)
    functype.Release()
    impobj.AddFunction(&quot;func-add&quot;, hostfunc)

    // 将导入对象注册到 VM 中。
    vm.RegisterImport(impobj)

    res, err := vm.RunWasmBuffer(wasmbuf, &quot;addTwo&quot;, uint32(1234), uint32(5678))
    if err == nil {
        fmt.Println(&quot;Get the result:&quot;, res[0].(int32))
    } else {
        fmt.Println(&quot;Error message:&quot;, err.Error())
    }

    impobj.Release()
    vm.Release()
}
</code></pre>
<p>然后，你可以使用 WasmEdge Golang SDK 构建和运行 Golang 应用程序：</p>
<pre><code class="language-bash">$ go get github.com/second-state/WasmEdge-go/wasmedge@v0.9.1
$ go build
$ ./wasmedge_test
得到结果：6912
</code></pre>
</li>
<li>
<p>Host 数据示例</p>
<p>你可以给函数对象设置一个外部数据对象，并在函数体中访问该对象。假设编辑上面的 Go 文件 <code>main.go</code>：</p>
<pre><code class="language-go">package main

import (
    &quot;fmt&quot;

    &quot;github.com/second-state/WasmEdge-go/wasmedge&quot;
)

// Host 函数体定义。
func host_add(data interface{}, mem *wasmedge.Memory, params []interface{}) ([]interface{}, wasmedge.Result) {
    // 添加：i32, i32 -&gt; i32
    res := params[0].(int32) + params[1].(int32)

    // 设置返回
    returns := make([]interface{}, 1)
    returns[0] = res

    // 同时将结果设置为数据。
    *data.(*int32) = res

    // 返回
    return returns, wasmedge.Result_Success
}

func main() {
    // 创建虚拟机对象。
    vm := wasmedge.NewVM()

    // WASM 模块缓冲区。
    wasmbuf := []字节{
        /* WASM 头文件 */
        0x00, 0x61, 0x73, 0x6D, 0x01, 0x00, 0x00, 0x00,
        /* 类型部分 */
        0x01, 0x07, 0x01,
        /* 函数类型 {i32, i32} -&gt; {i32} */
        0x60, 0x02, 0x7F, 0x7F, 0x01, 0x7F, 
        /* 导入部分 */
        0x02, 0x13, 0x01, 
        /* 模块名称：“extern” */
        0x06, 0x65, 0x78, 0x74, 0x65, 0x72, 0x6E, 
        /* 外部名称：“func-add” */
        0x08, 0x66, 0x75, 0x6E, 0x63, 0x2D, 0x61, 0x64, 0x64,
        /* 导入描述：函数 0 */
        0x00, 0x00,
        /* 函数部分 */
        0x03, 0x02, 0x01, 0x00,
        /* 导出部分 */
        0x07, 0x0A, 0x01,
        /* 导出名称：“addTwo” */
        0x06, 0x61, 0x64, 0x64, 0x54, 0x77, 0x6F, 
        /* 导出描述：函数 0 */
        0x00, 0x01,
        /* 代码部分 */
        0x0A, 0x0A, 0x01, 
        /* 代码主体 */
        0x08, 0x00, 0x20, 0x00, 0x20, 0x01, 0x10, 0x00, 0x0B,
    }

    // 要设置到 Host 函数中的附加数据。
    var data int32 = 0

    // 创建模块名称为 `extern` 的导入对象。
    impobj := wasmedge.NewImportObject(&quot;extern&quot;)

    // 创建一个函数实例并将其添加到导出名称为 `func-add` 的导入对象中。
    functype := wasmedge.NewFunctionType(
        []wasmedge.ValType{wasmedge.ValType_I32, wasmedge.ValType_I32},
        []wasmedge.ValType{wasmedge.ValType_I32},
    )
    hostfunc := wasmedge.NewFunction(functype, host_add, &amp;data, 0)
    functype.Release()
    impobj.AddFunction(&quot;func-add&quot;, hostfunc)

    // 将导入对象注册到 VM 中。
    res, err := vm.RunWasmBuffer(wasmbuf, &quot;addTwo&quot;, uint32(1234), uint32(5678))
    if err == nil {
        fmt.Println(&quot;Get the result:&quot;, res[0].(int32))
    } else {
        fmt.Println(&quot;Error message:&quot;, err.Error())
    }
    fmt.Println(&quot;Data value:&quot;, data)

    impobj.Release()
    vm.Release()
}
</code></pre>
<p>然后，你可以使用 WasmEdge Golang SDK 构建和运行 Golang 应用程序：</p>
<pre><code class="language-bash">$ go get github.com/second-state/WasmEdge-go/wasmedge@v0.9.1
$ go build
$ ./wasmedge_test
Get the result: 6912
Data value: 6912
</code></pre>
</li>
</ol>
<h2 id="wasmedge-aot-编译器"><a class="header" href="#wasmedge-aot-编译器">WasmEdge AOT 编译器</a></h2>
<p>在本部分中，我们将介绍 WasmEdge AOT 编译器和 Go 中的选项。WasmEdge 以解释器模式运行 WASM 文件，并且 WasmEdge 还支持在不修改任何代码的情况下运行 AOT (ahead-of-time) 模式。WasmEdge AOT（提前）编译器编译 WASM 文件以在 AOT 模式下运行，这比解释器模式快得多。你可以将 WASM 文件编译成共享库格式的已编译 WASM 文件，用于 AOT 模式执行的通用 WASM 格式。</p>
<h3 id="编译示例"><a class="header" href="#编译示例">编译示例</a></h3>
<p><a href="https://github.com/second-state/WasmEdge-go-examples/tree/master/go_WasmAOT">go_WasmAOT 示例</a> 提供了一个编译 WASM 文件的工具。</p>
<h3 id="编译器选项"><a class="header" href="#编译器选项">编译器选项</a></h3>
<p>你可以为 AOT 编译器设置优化级别和输出格式等选项：</p>
<pre><code class="language-go">const (
    // 禁用尽可能多的优化。
    CompilerOptLevel_O0 = CompilerOptimizationLevel(C.WasmEdge_CompilerOptimizationLevel_O0)
    // 在不破坏可调试性的情况下快速优化。
    CompilerOptLevel_O1 = CompilerOptimizationLevel(C.WasmEdge_CompilerOptimizationLevel_O1)
    // 在不触发显着增量编译时间或代码大小增长的情况下尽可能地优化快速执行。
    CompilerOptLevel_O2 = CompilerOptimizationLevel(C.WasmEdge_CompilerOptimizationLevel_O2)
    // 尽可能优化快速执行。
    CompilerOptLevel_O3 = CompilerOptimizationLevel(C.WasmEdge_CompilerOptimizationLevel_O3)
    // 代码越小越好，而不会触发显着的编译时间增量或执行时间减慢。
    CompilerOptLevel_Os = CompilerOptimizationLevel(C.WasmEdge_CompilerOptimizationLevel_Os)
    // 代码越小越好。
    CompilerOptLevel_Oz = CompilerOptimizationLevel(C.WasmEdge_CompilerOptimizationLevel_Oz)
)

const (
    // 原生动态库格式。
    CompilerOutputFormat_Native = CompilerOutputFormat(C.WasmEdge_CompilerOutputFormat_Native)
    // WebAssembly 与自定义部分中的 AOT 编译代码。
    CompilerOutputFormat_Wasm = CompilerOutputFormat(C.WasmEdge_CompilerOutputFormat_Wasm)
)
</code></pre>
<p>详情请参考 <a href="embed/go/ref.html#%E9%85%8D%E7%BD%AE">AOT 编译器选项配置</a>。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="nodejs-sdk"><a class="header" href="#nodejs-sdk">Node.js SDK</a></h1>
<p>在这篇教程中，我会向你展示如何通过 WasmEdge Node.js SDK 将用 Rust 写的 WebAssembly 函数合并进 Node.js 的服务端应用程序
中。这个方法可以将 Rust 的<strong>性能</strong>，WebAssembly 的<strong>安全性</strong>和<strong>可移植性</strong>，和 JavaScript 的<strong>易用性</strong>结合。一个典型的应用程序就像这样。</p>
<ul>
<li>host 应用程序是一个用 JavaScript 写的 Node.js web 应用程序，它可以调用 WebAssembly 函数。</li>
<li>WebAssembly 字节码程序是用 Rust 写的，运行在 WasmEdge Runtime，可以被 Node.js web 应用程序调用。</li>
</ul>
<blockquote>
<p><a href="https://github.com/second-state/wasmedge-nodejs-starter/fork">Fork 这个 Github 仓库</a>来开始写代码！</p>
</blockquote>
<h2 id="先决条件"><a class="header" href="#先决条件">先决条件</a></h2>
<p>为了搭建一个包含 Rust 和 WebAssembly 的高性能 Node.js 环境，你需要如下准备：</p>
<ul>
<li>一个现代的 Linux 发行版, 比如 Ubuntu Server 20.04 LTS</li>
<li><a href="https://www.rust-lang.org/tools/install">Rust 语言</a></li>
<li><a href="https://nodejs.org/en/download/package-manager/">Node.js</a></li>
<li>Node.js 的 <a href="embed/../start/install.html#install-wasmedge-for-node.js">WasmEdge Runtime</a></li>
<li><a href="embed//dev/rust/bindgen.html">rustwasmc 编译器工具链</a></li>
</ul>
<h3 id="docker"><a class="header" href="#docker">Docker</a></h3>
<p>最简单的启动方式就是使用 Docker 来搭建开发环境。只需要<a href="https://github.com/second-state/wasmedge-nodejs-starter/">克隆这个模板</a>到你的电脑，然后运行如下 Docker 命令：</p>
<pre><code class="language-bash"># 克隆代码到本地
$ git clone https://github.com/second-state/wasmedge-nodejs-starter
$ cd wasmedge-nodejs-starter

# 启动 Docker 容器
$ docker pull wasmedge/appdev_x86_64:0.8.2
$ docker run -p 3000:3000 --rm -it -v $(pwd):/app wasmedge/appdev_x86_64:0.8.2
(docker) $ cd /app
</code></pre>
<p>好了，你现在可以编译和运行代码了。</p>
<h3 id="没有-docker-的手动启动"><a class="header" href="#没有-docker-的手动启动">没有 Docker 的手动启动</a></h3>
<p>命令如下。</p>
<pre><code class="language-bash"># 安装 Rust
$ curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh
$ source $HOME/.cargo/env
$ rustup override set 1.50.0

# 安装 Node.js 和 npm
$ curl -sL https://deb.nodesource.com/setup_14.x |  bash
$ sudo apt-get install -y nodejs npm

# 安装 rustwasmc 工具链
$ npm install -g rustwasmc # 如果权限有问题，加上 --unsafe-perm

# WasmEdge 需要的系统依赖
$ sudo apt-get update
$ sudo apt-get -y upgrade
$ sudo apt install -y build-essential curl wget git vim libboost-all-dev llvm-dev liblld-10-dev

# 安装 WasmEdge 需要的 nodejs addon 
$ npm install wasmedge-core
$ npm install wasmedge-extensions
</code></pre>
<blockquote>
<p>WasmEdge Runtime 需要最新版本的 <code>libstdc++</code>。 Ubuntu 20.04 LTS 已经有最新的库了。 如果你使用的是比较老的 Linux 发行版中，有一些选项需要升级，<a href="https://www.secondstate.io/articles/ubuntu-req-ssvm-20200715/">更详细的信息在这儿</a>。</p>
</blockquote>
<p>然后，克隆示例源代码仓库。</p>
<pre><code class="language-bash">git clone https://github.com/second-state/wasmedge-nodejs-starter
cd wasmedge-nodejs-starter
</code></pre>
<h2 id="hello-world-3"><a class="header" href="#hello-world-3">Hello World</a></h2>
<p>第一个示例是一个 hello world，向你展示应用程序的各个部分如何组合在一起。</p>
<h3 id="rust-写的-webassembly-程序"><a class="header" href="#rust-写的-webassembly-程序">Rust 写的 WebAssembly 程序</a></h3>
<p>在这个例子中，Rust 程序将输入的字符串添加到 “hello” 后面。下面是 Rust 程序内容，位于 src/lib.rs。你可以在这个库文件中定义多个外部方法，所有的这些方法都可以在 host JavaScript 应用中通过 WebAssembly 调用。记得需要给每个函数添加 <code>#[wasm_bindgen]</code> 注解，这样 <a href="https://github.com/second-state/rustwasmc">rustwasmc</a> 就知道在构建时为这些函数生成正确的 JavaScript 到 Rust 接口。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use wasm_bindgen::prelude::*;

#[wasm_bindgen]
pub fn say(s: String) -&gt; String {
  let r = String::from(&quot;hello &quot;);
  return r + &amp;s;
}
<span class="boring">}
</span></code></pre></pre>
<p>然后你可以将 Rust 源代码编译成 WebAssembly 字节码，并且生成相应的 JavaScript 模块供 Node.js host 环境调用。</p>
<pre><code class="language-bash">rustwasmc build
</code></pre>
<p>生成的文件在 <code>pkg/</code> 目录下，<code>.wasm</code> 文件是 WebAssembly 字节码程序，<code>.js</code> 文件是 JavaScript 模块。</p>
<h3 id="nodejs-host-应用程序"><a class="header" href="#nodejs-host-应用程序">Node.js host 应用程序</a></h3>
<p>然后进入 <code>node</code> 文件夹下，检查 JavaScript 程序 <code>app.js</code>。有了生成的 <code>wasmedge_nodejs_starter_lib.js</code> 模块，就很容易写出调用 WebAssembly 函数的 JavaScript 了。下面是 node 应用程序 <code>app.js</code>。简单的从生成的模块中引入 <code>say()</code> 函数。 node 应用程序从 HTTP GET 请求中拿到 <code>name</code> 参数后返回 “hello <code>name</code>”。</p>
<pre><code class="language-javascript">const { say } = require('../pkg/wasmedge_nodejs_starter_lib.js');

const http = require('http');
const url = require('url');
const hostname = '127.0.0.1';
const port = 3000;

const server = http.createServer((req, res) =&gt; {
  const queryObject = url.parse(req.url,true).query;
  res.statusCode = 200;
  res.setHeader('Content-Type', 'text/plain');
  res.end(say(queryObject['name']));
});

server.listen(port, hostname, () =&gt; {
  console.log(`Server running at http://${hostname}:${port}/`);
});
</code></pre>
<p>像下面一样启动 Node.js 应用程序。</p>
<pre><code class="language-bash">$ node node/app.js
Server running at http://127.0.0.1:3000/
</code></pre>
<p>然后，你可以在另外一个终端窗口中测试。</p>
<pre><code class="language-bash">$ curl http://127.0.0.1:3000/?name=Wasm
hello Wasm
</code></pre>
<h2 id="完整的-web-应用程序"><a class="header" href="#完整的-web-应用程序">完整的 web 应用程序</a></h2>
<p>下面的例子展示了一个计算二次方程根的 web 应用程序，请在这里查看<a href="https://github.com/second-state/wasm-learning/tree/master/nodejs/quadratic">完整源代码</a>.</p>
<p>用户在 web 表单中输入 <code>a</code>, <code>b</code>, <code>c</code> 三个值，web 应用程序调用 web 服务 <code>/solve</code>，计算出二次方程的根。</p>
<pre><code class="language-src">a*X^2 + b*X + c = 0
</code></pre>
<p><code>X</code> 的根展示在输入表单下面。</p>
<p><img src="https://www.secondstate.io/articles/getting-started-with-rust-function-01.png" alt="getting-started-with-rust-function" /></p>
<p><a href="https://github.com/second-state/wasm-learning/blob/master/nodejs/quadratic/node/public/index.html">HTML 文件</a> 包含提交 web 表单到 <code>/solve</code> 的客户端 JavaScript，并且将结果放到页面的 <code>#roots</code> HTML 元素里。</p>
<pre><code class="language-javascript">$(function() {
    var options = {
      target: '#roots',
      url: &quot;/solve&quot;,
      type: &quot;post&quot;
    };
    $('#solve').ajaxForm(options);
});
</code></pre>
<p><code>/solve</code> URL 端点后的 <a href="https://github.com/second-state/wasm-learning/blob/master/nodejs/quadratic/node/server.js">Node.js 应用程序</a>如下所示。他从输入表单中读取数据，将他们作为数组传递给 <code>solve</code> 函数，将返回结果放到 HTTP 返回内容中。</p>
<pre><code class="language-javascript">app.post('/solve', function (req, res) {
  var a = parseFloat(req.body.a);
  var b = parseFloat(req.body.b);
  var c = parseFloat(req.body.c);
  res.send(solve([a, b, c]))
})
</code></pre>
<p><a href="https://github.com/second-state/wasm-learning/blob/master/nodejs/quadratic/src/lib.rs">用 Rust 写的 <code>solve</code> 函数</a>，运行在 WasmEdge Runtime。如果 JavaScript 端的调用参数是数组，Rust 函数接收到一个封装数组的 JSON 对象。在 Rust 代码中，我们首先解码 JSON，执行计算，然后返回一个 JSON 字符串的结果。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[wasm_bindgen]
pub fn solve(params: &amp;str) -&gt; String {
  let ps: (f32, f32, f32) = serde_json::from_str(&amp;params).unwrap();
  let discriminant: f32 = (ps.1 * ps.1) - (4. * ps.0 * ps.2);
  let mut solution: (f32, f32) = (0., 0.);
  if discriminant &gt;= 0. {
    solution.0 = (((-1.) * ps.1) + discriminant.sqrt()) / (2. * ps.0);
    solution.1 = (((-1.) * ps.1) - discriminant.sqrt()) / (2. * ps.0);
    return serde_json::to_string(&amp;solution).unwrap();
  } else {
    return String::from(&quot;not real numbers&quot;);
  }
}
<span class="boring">}
</span></code></pre></pre>
<p>让我们试试。</p>
<pre><code class="language-bash">rustwasmc build
npm install express # 这个应用程序需要 Node.js 的 express 框架
node node/server.js
</code></pre>
<p>在 web 浏览器中，输入 <code>http://ip-addr:8080/</code> 来获取应用程序。注意：如果你使用的是 Docker，确保 Docker 容器中的 8080 端口映射到宿主的 8080 端口。</p>
<p>这就是二次方程的例子。</p>
<h2 id="更多例子"><a class="header" href="#更多例子">更多例子</a></h2>
<p>在 Rust 和 JavaScript 之间除了可以传递字符串值外， <code>rustwasmc</code> 工具支持下面的数据类型。</p>
<ul>
<li>Rust 调用参数可以是 <code>i32</code>、<code>String</code>、<code>&amp;str</code>、<code>Vec&lt;u8&gt;</code> 和 <code>&amp;[u8]</code> 的组合。</li>
<li>返回值可能是 <code>i32</code> 或者 <code>String</code> 或者 <code>Vec&lt;u8&gt;</code> 或者 void。</li>
<li>对于复杂的数据结构，比如结构体，你可以使用 JSON 字符串来传递数据。</li>
</ul>
<blockquote>
<p>支持了 JSON，你可以用任意数量的输入参数调用 Rust 函数，并返回任意数量、任意类型的结果。</p>
</blockquote>
<p><a href="https://github.com/second-state/wasm-learning/tree/master/nodejs/functions">函数示例</a>中的 Rust 程序 <code>src/lib.rs</code> 演示了如何传递多个不同类型的调用参数和返回结果。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[wasm_bindgen]
pub fn obfusticate(s: String) -&gt; String {
  (&amp;s).chars().map(|c| {
    match c {
      'A' ..= 'M' | 'a' ..= 'm' =&gt; ((c as u8) + 13) as char,
      'N' ..= 'Z' | 'n' ..= 'z' =&gt; ((c as u8) - 13) as char,
      _ =&gt; c
    }
  }).collect()
}

#[wasm_bindgen]
pub fn lowest_common_denominator(a: i32, b: i32) -&gt; i32 {
  let r = lcm(a, b);
  return r;
}

#[wasm_bindgen]
pub fn sha3_digest(v: Vec&lt;u8&gt;) -&gt; Vec&lt;u8&gt; {
  return Sha3_256::digest(&amp;v).as_slice().to_vec();
}

#[wasm_bindgen]
pub fn keccak_digest(s: &amp;[u8]) -&gt; Vec&lt;u8&gt; {
  return Keccak256::digest(s).as_slice().to_vec();
}
<span class="boring">}
</span></code></pre></pre>
<p>最有意思的可能是 <code>create_line()</code> 函数。它需要两个 JSON 字符串，每一个都代表一个 <code>Point</code> 结构，返回一个 JSON 字符串代表 <code>Line</code> 结构。注意，<code>Point</code> 和 <code>Line</code> 结构都使用了 <code>Serialize</code> 和 <code>Deserialize</code> 注解，这样 Rust 编译器就会自动生成必要的代码来支持和 JSON 字符串之间的转换。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use wasm_bindgen::prelude::*;
use serde::{Serialize, Deserialize};

#[derive(Serialize, Deserialize, Debug)]
struct Point {
  x: f32, 
  y: f32
}

#[derive(Serialize, Deserialize, Debug)]
struct Line {
  points: Vec&lt;Point&gt;,
  valid: bool,
  length: f32,
  desc: String
}

#[wasm_bindgen]
pub fn create_line (p1: &amp;str, p2: &amp;str, desc: &amp;str) -&gt; String {
  let point1: Point = serde_json::from_str(p1).unwrap();
  let point2: Point = serde_json::from_str(p2).unwrap();
  let length = ((point1.x - point2.x) * (point1.x - point2.x) + (point1.y - point2.y) * (point1.y - point2.y)).sqrt();

  let valid = if length == 0.0 { false } else { true };
  let line = Line { points: vec![point1, point2], valid: valid, length: length, desc: desc.to_string() };
  return serde_json::to_string(&amp;line).unwrap();
}

#[wasm_bindgen]
pub fn say(s: &amp;str) -&gt; String {
  let r = String::from(&quot;hello &quot;);
  return r + s;
}
<span class="boring">}
</span></code></pre></pre>
<p>然后，让我们来检查下 JavaScript 程序 <a href="https://github.com/second-state/wasm-learning/blob/master/nodejs/functions/node/app.js"><code>app.js</code></a>，它展示了如何调用 Rust 函数。你可以看到，<code>String</code> 和 <code>&amp;str</code> 在 JavaScript 是简单的字符串，<code>i32</code> 是数字，<code>Vec&lt;u8&gt;</code> 或者 <code>&amp;[8]</code> 是 JavaScript <code>Uint8Array</code>。JavaScript 对象在传入或者从 Rust 函数结果返回需要通过 <code>JSON.stringify()</code> 或者 <code>JSON.parse()</code> 转换。</p>
<pre><code class="language-javascript">const { say, obfusticate, lowest_common_denominator, sha3_digest, keccak_digest, create_line } = require('./functions_lib.js');

var util = require('util');
const encoder = new util.TextEncoder();
console.hex = (d) =&gt; console.log((Object(d).buffer instanceof ArrayBuffer ? new Uint8Array(d.buffer) : typeof d === 'string' ? (new util.TextEncoder('utf-8')).encode(d) : new Uint8ClampedArray(d)).reduce((p, c, i, a) =&gt; p + (i % 16 === 0 ? i.toString(16).padStart(6, 0) + '  ' : ' ') + c.toString(16).padStart(2, 0) + (i === a.length - 1 || i % 16 === 15 ?  ' '.repeat((15 - i % 16) * 3) + Array.from(a).splice(i - i % 16, 16).reduce((r, v) =&gt; r + (v &gt; 31 &amp;&amp; v &lt; 127 || v &gt; 159 ? String.fromCharCode(v) : '.'), '  ') + '\n' : ''), ''));

console.log( say(&quot;WasmEdge&quot;) );
console.log( obfusticate(&quot;A quick brown fox jumps over the lazy dog&quot;) );
console.log( lowest_common_denominator(123, 2) );
console.hex( sha3_digest(encoder.encode(&quot;This is an important message&quot;)) );
console.hex( keccak_digest(encoder.encode(&quot;This is an important message&quot;)) );

var p1 = {x:1.5, y:3.8};
var p2 = {x:2.5, y:5.8};
var line = JSON.parse(create_line(JSON.stringify(p1), JSON.stringify(p2), &quot;A thin red line&quot;));
console.log( line );
</code></pre>
<p>在运行 <code>rustwasmc</code> 来构建 Rust 库后，在 Node.js 环境中运行 <code>app.js</code> 会产生如下结果。</p>
<pre><code class="language-bash">$ rustwasmc build
... Building the wasm file and JS shim file in pkg/ ...

$ node node/app.js
hello WasmEdge
N dhvpx oebja sbk whzcf bire gur ynml qbt
246
000000  57 1b e7 d1 bd 69 fb 31 9f 0a d3 fa 0f 9f 9a b5  W.çÑ½iû1..Óú...µ
000010  2b da 1a 8d 38 c7 19 2d 3c 0a 14 a3 36 d3 c3 cb  +Ú..8Ç.-&lt;..£6ÓÃË

000000  7e c2 f1 c8 97 74 e3 21 d8 63 9f 16 6b 03 b1 a9  ~ÂñÈ.tã!Øc..k.±©
000010  d8 bf 72 9c ae c1 20 9f f6 e4 f5 85 34 4b 37 1b  Ø¿r.®Á .öäõ.4K7.

{ points: [ { x: 1.5, y: 3.8 }, { x: 2.5, y: 5.8 } ],
  valid: true,
  length: 2.2360682,
  desc: 'A thin red line' }  
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rust-sdk"><a class="header" href="#rust-sdk">Rust SDK</a></h1>
<p>你可以通过 WasmEdge Rust SDK 将 WasmEdge 嵌入到 Rust 应用程序中。</p>
<p>WasmEdge Rust SDK 涉及两个 Rust crate <a href="https://crates.io/crates/wasmedge-sys">wasmedge-sys</a> 和 <a href="https://crates.io/crates/wasmedge-sdk">wasmedge-rs</a>，它们根据不同的原则和不同的目的设计。 wasmedge-sys crate 定义了一组底层 Rust API，其仅仅是对 WasmEdge C API 进行封装，以提供相应的安全接口，而 wasmedge-rs crate 提供更优雅和符合人体工程学的 API，更适合应用程序开发。</p>
<ul>
<li>
<p><a href="https://crates.io/crates/wasmedge-sys">wasmedge-sys</a> crate 定义了一组底层 Rust API，其仅仅是对 WasmEdge C API 进行封装，以提供相应的安全接口。 <a href="https://crates.io/crates/wasmedge-sys">wasmedge-sys</a> 更适合作为基础库，为面向应用的更高层 Rust 库提供服务。</p>
</li>
<li>
<p><a href="https://crates.io/crates/wasmedge-sdk">wasmedge-rs</a> crate 基于 wasmedge-sys crate，并提供更优雅和惯用的 Rust API，更适合面向业务的设计和开发，wasmedge-rs crate 目前仍处于积极地开发过程中。</p>
</li>
</ul>
<h2 id="构建-wasmedge-sys"><a class="header" href="#构建-wasmedge-sys">构建 <code>wasmedge-sys</code></a></h2>
<ol>
<li><code>wasmedge-sys</code> 依赖于 <code>WasmEdge</code> 的核心库及必要的头文件。</li>
<li>为了通过 cargo build 命令构建 wasmedge-sys 。</li>
</ol>
<ul>
<li>
<p>通过指定 <code>WASMEDGE_INCLUDE_DIR</code> 和 <code>WASMEDGE_LIB_DIR</code></p>
<ul>
<li>假设在 <a href="https://github.com/WasmEdge/WasmEdge/releases">WasmEdge Releases</a> 下载 <code>Wasmedge-0.9.1</code> 二进制包并放在 <code>~/workspace/me/</code>目录中，发布包的目录结构如下所示：</li>
</ul>
<pre><code class="language-bash">root@0a877562f39e:~/workspace/me/WasmEdge-0.9.1-Linux# pwd
/root/workspace/me/WasmEdge-0.9.1-Linux

root@0a877562f39e:~/workspace/me/WasmEdge-0.9.1-Linux# tree .
.
|-- bin
|   |-- wasmedge
|   `-- wasmedgec
|-- include
|   `-- wasmedge
|       |-- enum_configure.h
|       |-- enum_errcode.h
|       |-- enum_types.h
|       |-- int128.h
|       |-- version.h
|       `-- wasmedge.h
`-- lib64
    `-- libwasmedge.so

4 directories, 9 files
</code></pre>
<ul>
<li>
<p>设置 <code>WASMEDGE_INCLUDE_DIR</code> 和 <code>WASMEDGE_LIB_DIR</code> 环境变量以指定 <code>include</code> 和 <code>lib</code>（或 <code>lib64</code>）目录，进入 <code>wasmedge-sys</code> 目录和 <code>cargo build</code> crate。</p>
<pre><code class="language-bash">root@0a877562f39e:~/workspace/me/WasmEdge/bindings/rust/wasmedge-sys# export WASMEDGE_INCLUDE_DIR=/root/workspace/me/WasmEdge-0.9.1-Linux/include/wasmedge

root@0a877562f39e:~/workspace/me/WasmEdge/bindings/rust/wasmedge-sys# export WASMEDGE_LIB_DIR=/root/workspace/me/WasmEdge-0.9.1-Linux/lib64
</code></pre>
</li>
</ul>
</li>
<li>
<p>通过指定 <code>WASMEDGE_BUILD_DIR</code></p>
<ul>
<li>
<p>假设在 <code>~/workspace/me/WasmEdge</code> 中 <code>git clone</code> WasmEdge repo，并按照 <a href="https://wasmedge.org/book/en/extend/build.html">instructions</a> 构建 WasmEdge native library 生成 <code>include</code> 和 <code>lib</code> 目录应该在 <code>~/workspace/me/WasmEdge/build</code> 中。</p>
</li>
<li>
<p>设置 <code>WASMEDGE_BUILD_DIR</code> 环境变量并指定 <code>build</code> 目录，进入 <code>wasmedge-sys</code> 目录和 <code>cargo build</code> crate。</p>
<pre><code class="language-bash">root@0a877562f39e:~/workspace/me/WasmEdge# export WASMEDGE_BUILD_DIR=/root/workspace/me/WasmEdge/build
</code></pre>
</li>
</ul>
</li>
<li>
<p>通过 <code>standalone</code> 模式</p>
<p>上述提到的两种方法之外，<code>standalone</code> 模式可以在构建 crate 之前直接构建 <code>WasmEdge</code> 原生库。</p>
<ul>
<li>
<p>假设 <code>~/workspace/me/WasmEdge</code> 中有 <code>git clone</code> WasmEdge repo，在 <code>wasmedge-sys</code> 目录中按照以下说明进行操作：</p>
<pre><code class="language-bash">// set WASMEDGE_DIR
root@0a877562f39e:~/workspace/me/WasmEdge/bindings/rust/wasmedge-sys# export WASMEDGE_DIR=/root/workspace/me/WasmEdge

// cargo build with standalone feature
root@0a877562f39e:~/workspace/me/WasmEdge/bindings/rust/wasmedge-sys# cargo build --features standalone
</code></pre>
</li>
</ul>
</li>
<li>
<p>通过 WasmEdge docker image</p>
</li>
</ul>
<p>如果选择通过 WasmEdge docker 镜像来构建容器进行开发，则预构建 WasmEdge 二进制包默认位于 <code>$HOME/.wasmedge</code> 目录中， wasmedge-sys 的构建脚本 （ build.rs ）可以自动检测并构建 crate。</p>
<h2 id="案例"><a class="header" href="#案例">案例</a></h2>
<ul>
<li><a href="embed/rust/wasmedge-sys-api.html">使用 WasmEdge 底层 API 运行 WebAssembly 函数</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="使用-wasmedge-底层-rust-api-运行-webassembly-函数"><a class="header" href="#使用-wasmedge-底层-rust-api-运行-webassembly-函数">使用 WasmEdge 底层 Rust API 运行 WebAssembly 函数</a></h1>
<p>本节演示如何使用 <code>wasmedge sys</code> crate 的 Rust API 来运行 host 函数。</p>
<p>你可能知道，一些主流编程语言，如 C/C++、Rust、Go 和 Python，都支持将程序编译成 WebAssembly 二进制文件。在本演示中，我们将介绍如何使用 WasmEdge Rust API 调用 WebAssembly 函数，该函数可以用上述任何编程语言编写。</p>
<p>我们使用 <code>fibonacci.wasm</code> 和 WebAssembly 文件的内容如下所示。语句 <code>(export“fib”（func$fib))</code> 声明了一个名为 <code>fib</code> 的导出函数。此函数使用给定的 <code>i32</code> 数作为输入计算斐波那契数。我们稍后将使用函数名来实现计算斐波那契数的目标。</p>
<pre><code class="language-wasm">(module
  (export &quot;fib&quot; (func $fib))
  (func $fib (param $n i32) (result i32)
    (if
      (i32.lt_s
        (get_local $n)
        (i32.const 2)
      )
      (return
        (i32.const 1)
      )
    )
    (return
      (i32.add
        (call $fib
          (i32.sub
            (get_local $n)
            (i32.const 2)
          )
        )
        (call $fib
          (i32.sub
            (get_local $n)
            (i32.const 1)
          )
        )
      )
    )
  )
)
</code></pre>
<h2 id="步骤-1-创建-wasmedge-ast-模块"><a class="header" href="#步骤-1-创建-wasmedge-ast-模块">步骤 1: 创建 WasmEdge AST 模块</a></h2>
<p>在这一步中，我们将从 WebAssembly 文件创建一个 WasmEdge <code>AST Module</code> 实例。</p>
<ul>
<li>
<p>首先，创建一个 <code>loader</code> 实例;</p>
</li>
<li>
<p>然后，通过 <code>loader</code> 程序实例的 <code>from_file</code> 方法加载指定的 WebAssebly 文件（“fibonacci.wasm”）。如果该过程成功，则返回一个 WasmEdge <code>AST module</code> 实例。</p>
</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use wasmedge_sys::Loader
use std::path::PathBuf;

// 创建 Loader 程序实例
let loader = Loader::create(None).expect(&quot;fail to create a Loader context&quot;);

// 从指定的 wasm 文件加载 wasm 模块，并返回 WasmEdge AST 模块实例
let path = PathBuf::from(&quot;fibonacci.wasm&quot;);
let mut module = loader.from_file(path).expect(&quot;fail to load the WebAssembly file&quot;);
<span class="boring">}
</span></code></pre></pre>
<h2 id="步骤-2-创建一个-vm-实例"><a class="header" href="#步骤-2-创建一个-vm-实例">步骤 2: 创建一个 <code>Vm</code> 实例</a></h2>
<p>在 WasmEdge 中， <code>Vm</code> 定义了一个运行环境，在其中存储和维护各种实例。在下面的演示代码中，我们可以创建一个 WasmEdge <code>store</code> 实例，然后将其用作创建 <code>Vm</code> 实例的输入之一。如果没有明确指定 <code>store</code> 实例，那么 <code>Vm</code> 将自己创建一个 <code>store</code> 。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use wasmedge_sys::{Config, Store, Vm};

// 创建一个 config 实例
let config = Config::create().expect(&quot;fail to create a Config context&quot;);

// 创建 store 实例
let store = Store::create().expect(&quot;fail to create a Store context&quot;);

// 使用指定的配置和存储创建 Vm 实例
let mut vm = Vm::create(Some(config), Some(store)).expect(&quot;fail to create a Vm context&quot;);
<span class="boring">}
</span></code></pre></pre>
<h2 id="步骤-3-调用-fib-函数"><a class="header" href="#步骤-3-调用-fib-函数">步骤 3: 调用 fib 函数</a></h2>
<p>在步骤 1中，我们得到了一个模块，该模块承载 WebAssembly 中定义的目标 <code>fib</code> 函数。现在，我们可以通过传递导出的函数名 <code>fib</code> ，通过 <code>Vm</code> 实例的 <code>run_wasm_from_module</code> 方法调用该函数。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use wasmedge_sys::Value;

// 运行一个函数
let returns = vm.run_wasm_from_module(module, &quot;fib&quot;, [Value::from_i32(5)]).expect(&quot;fail to run the target function in the module&quot;);

println!(&quot;The result of fib(5) is {}&quot;, returns[0].to_i32());
<span class="boring">}
</span></code></pre></pre>
<p>这是在屏幕上打印的最终结果：</p>
<pre><code class="language-bash">The result of fib(5) is 8
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="并行计算斐波那契数"><a class="header" href="#并行计算斐波那契数">并行计算斐波那契数</a></h1>
<h2 id="前置条件-2"><a class="header" href="#前置条件-2">前置条件</a></h2>
<p>这个示例使用了如下的包：</p>
<ul>
<li>wasmedge-sys v0.7.0</li>
<li>wasmedge-types v0.1.1</li>
</ul>
<h2 id="概述"><a class="header" href="#概述">概述</a></h2>
<p>在这个例子中，我们将演示如何使用 <code>wasmedge-sys</code> 中定义的对象和 API 来并行地计算斐波那契数。</p>
<h2 id="示例"><a class="header" href="#示例">示例</a></h2>
<p>在下面的代码中，我们创建了两个子线程，<code>thread_a</code> 和 <code>thread_b</code>，它们分别负责通过调用宿主函数 <code>fib</code> 来计算 <code>Fib(4)</code> 和 <code>Fib(5)</code>。之后，主线程通过将 <code>thread_a</code> 和 <code>thread_b</code> 返回的数字相加来计算 <code>Fib(6)</code>。</p>
<h3 id="第一步创建一个-vm-上下文并注册-webassembly-模块"><a class="header" href="#第一步创建一个-vm-上下文并注册-webassembly-模块">第一步：创建一个 Vm 上下文并注册 WebAssembly 模块。</a></h3>
<pre><code>```rust
// create a Config context
let mut config = Config::create()?;
config.bulk_memory_operations(true);

// create a Store context
let mut store = Store::create()?;

// create a Vm context with the given Config and Store
let mut vm = Vm::create(Some(config), Some(&amp;mut store))?;

// register a wasm module from a wasm file
let file = std::path::PathBuf::from(env!(&quot;WASMEDGE_DIR&quot;))
    .join(&quot;bindings/rust/wasmedge-sys/tests/data/fibonacci.wasm&quot;);
vm.register_wasm_from_file(&quot;extern&quot;, file)?;
```
</code></pre>
<h3 id="第二步创建两个子线程分别计算-fib4-和-fib5"><a class="header" href="#第二步创建两个子线程分别计算-fib4-和-fib5">第二步：创建两个子线程，分别计算 <code>Fib(4)</code> 和 <code>Fib(5)</code>。</a></h3>
<pre><code>```rust
let vm = Arc::new(Mutex::new(vm));

// compute fib(4) by a child thread
let vm_cloned = Arc::clone(&amp;vm);
let handle_a = thread::spawn(move || {
  let vm_child_thread = vm_cloned.lock().expect(&quot;fail to lock vm&quot;);
  let returns = vm_child_thread
    .run_registered_function(&quot;extern&quot;, &quot;fib&quot;, [Value::from_i32(4)])
    .expect(&quot;fail to compute fib(4)&quot;);

  let fib4 = returns[0].to_i32();
  println!(&quot;fib(4) by child thread: {}&quot;, fib4);

  fib4
});

// compute fib(5) by a child thread
let vm_cloned = Arc::clone(&amp;vm);
let handle_b = thread::spawn(move || {
  let vm_child_thread = vm_cloned.lock().expect(&quot;fail to lock vm&quot;);
  let returns = vm_child_thread
    .run_registered_function(&quot;extern&quot;, &quot;fib&quot;, [Value::from_i32(5)])
    .expect(&quot;fail to compute fib(5)&quot;);

  let fib5 = returns[0].to_i32();
  println!(&quot;fib(5) by child thread: {}&quot;, fib5);

  fib5
});

```
</code></pre>
<h3 id="第三步从两个子线程中获取返回值计算-fib6"><a class="header" href="#第三步从两个子线程中获取返回值计算-fib6">第三步：从两个子线程中获取返回值，计算 <code>Fib(6)</code>。</a></h3>
<pre><code>```Rust
let fib4 = handle_a.join().unwrap();
let fib5 = handle_b.join().unwrap();

// compute fib(6)
println!(&quot;fib(6) = fib(5) + fib(1) = {}&quot;, fib5 + fib4);
```
</code></pre>
<p>上述代码的最终结果将会像下面这样被打印在屏幕上。</p>
<pre><code class="language-bash">fib(4) by child thread: 5
fib(5) by child thread: 8
fib(6) = fib(5) + fib(1) = 13
</code></pre>
<p>这个演示的完整源代码可以在 <a href="https://github.com/WasmEdge/WasmEdge/blob/master/bindings/rust/wasmedge-sys/examples/threads.rs">WasmEdge Github</a> 找到。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="python-sdk"><a class="header" href="#python-sdk">Python SDK</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="用-kubernetes-管理-wasmedge-应用"><a class="header" href="#用-kubernetes-管理-wasmedge-应用">用 Kubernetes 管理 WasmEdge 应用</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="快速开始-3"><a class="header" href="#快速开始-3">快速开始</a></h1>
<p>我们为你创建了基于 Ubuntu 的脚本，以便你在标准 Kubernetes 设置中快速开始使用以下运行时组合。</p>
<div class="table-wrapper"><table><thead><tr><th>CRI（高级）runtime</th><th>OCI（低级）runtime</th><th></th></tr></thead><tbody>
<tr><td>CRI-O</td><td>crun + WasmEdge</td><td><a href="https://github.com/second-state/wasmedge-containers-examples/blob/main/.github/workflows/kubernetes-crio.yml">脚本</a></td></tr>
<tr><td>containerd</td><td>crun + WasmEdge</td><td><a href="https://github.com/second-state/wasmedge-containers-examples/blob/main/.github/workflows/kubernetes-containerd.yml">脚本</a></td></tr>
</tbody></table>
</div>
<h2 id="cri-o-和-crun"><a class="header" href="#cri-o-和-crun">CRI-O 和 crun</a></h2>
<p>在 Ubuntu 20.04 上你可以使用 CRI-O <a href="https://github.com/second-state/wasmedge-containers-examples/blob/main/crio/install.sh">install.sh</a> 脚本来安装 CRI-O 和 <code>crun</code> 。</p>
<pre><code class="language-bash">wget -qO- https://raw.githubusercontent.com/second-state/wasmedge-containers-examples/main/crio/install.sh | bash
</code></pre>
<p>接下来，使用 <a href="https://github.com/second-state/wasmedge-containers-examples/blob/main/kubernetes_crio/install.sh">以下脚本</a> 安装 Kubernetes。</p>
<pre><code class="language-bash">wget -qO- https://raw.githubusercontent.com/second-state/wasmedge-containers-examples/main/kubernetes_crio/install.sh | bash
</code></pre>
<p><a href="https://github.com/second-state/wasmedge-containers-examples/blob/main/kubernetes_crio/simple_wasi_application.sh">simple_wasi_application.sh</a> 脚本展示了如何从 Docker Hub 拉取 <a href="kubernetes/demo/wasi.html">WebAssembly 应用程序</a> ，然后在 Kubernetes 中将其作为容器化应用程序运行。</p>
<pre><code class="language-bash">wget -qO- https://raw.githubusercontent.com/second-state/wasmedge-containers-examples/main/kubernetes_crio/simple_wasi_application.sh | bash
</code></pre>
<p>你应该会在控制台日志中看到 WebAssembly 程序打印的结果。<a href="https://github.com/second-state/wasmedge-containers-examples/runs/4186005677?check_suite_focus=true#step:6:3007">这里是一个例子</a>。</p>
<h2 id="containerd-和-crun"><a class="header" href="#containerd-和-crun">containerd 和 crun</a></h2>
<p>在 Ubuntu 20.04 上你可以使用 containerd <a href="https://github.com/second-state/wasmedge-containers-examples/blob/main/containerd/install.sh">install.sh</a> 脚本来安装 <code>containerd</code> 和 <code>crun</code>。</p>
<pre><code class="language-bash">wget -qO- https://raw.githubusercontent.com/second-state/wasmedge-containers-examples/main/containerd/install.sh | bash
</code></pre>
<p>接下来，使用 <a href="https://github.com/second-state/wasmedge-containers-examples/blob/main/kubernetes_containerd/install.sh">以下脚本</a> 安装 Kubernetes。</p>
<pre><code class="language-bash">wget -qO- https://raw.githubusercontent.com/second-state/wasmedge-containers-examples/main/kubernetes_containerd/install.sh | bash
</code></pre>
<p><a href="https://github.com/second-state/wasmedge-containers-examples/blob/main/kubernetes_containerd/simple_wasi_application.sh">simple_wasi_application.sh</a> 脚本展示了如何从 Docker Hub拉取 <a href="kubernetes/demo/wasi.html">WebAssembly 应用程序</a>，然后在 Kubernetes 中将其作为容器化应用程序运行。</p>
<pre><code class="language-bash">wget -qO- https://raw.githubusercontent.com/second-state/wasmedge-containers-examples/main/kubernetes_containerd/simple_wasi_application.sh | bash
</code></pre>
<p>你应该会在控制台日志中看到 WebAssembly 程序打印的结果。<a href="https://github.com/second-state/wasmedge-containers-examples/runs/4577789181?check_suite_focus=true#step:6:3010">这里是一个例子</a>。</p>
<p>继续阅读本章的其余部分，了解这些运行时的具体配置方式。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="demo-应用"><a class="header" href="#demo-应用">Demo 应用</a></h1>
<p>在本章中，我们将介绍两个 demo 应用。 我们将从 Rust 源码进行构建，并围绕它们构建 OCI 镜像，然后将这些镜像发布到 Docker Hub。</p>
<p>如果你还没有这样做，请先</p>
<ul>
<li><a href="https://www.rust-lang.org/tools/install">安装 Rust</a></li>
<li><a href="https://hub.docker.com/">注册 Docker Hub</a></li>
</ul>
<p>接下来，探索示例</p>
<ul>
<li><a href="kubernetes/demo/wasi.html">一个简单的 WASI 示例</a></li>
<li><a href="kubernetes/demo/server.html">一个 HTTP 服务器示例</a></li>
</ul>
<p>由于我们已经在 Docker Hub 上构建并发布了这些 demo 应用，你也可以直接进入容器运行时部分来使用这些镜像。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="一个简单的-wasi-例子"><a class="header" href="#一个简单的-wasi-例子">一个简单的 WASI 例子</a></h1>
<p>在这篇文章中，我会向你展示如何去构建一个 WebAssemblely 应用的容器镜像。然后可以通过 Kubernetes 生态系统工具（例如 CRI-O、Docker、crun 和 Kubernetes）来启动和管理它。</p>
<h2 id="先决条件-1"><a class="header" href="#先决条件-1">先决条件</a></h2>
<blockquote>
<p>如果你只是想要一个 wasm 字节码文件作为容器镜像进行测试，你可以跳过构建步骤，只需<a href="https://github.com/second-state/wasm-learning/blob/master/cli/wasi/wasi_example_main.wasm">在此处下载 wasm 文件</a>。</p>
</blockquote>
<p>首先，请按照这些简单的说明来<a href="https://www.rust-lang.org/tools/install">安装 Rust</a>。</p>
<h2 id="下载样例代码"><a class="header" href="#下载样例代码">下载样例代码</a></h2>
<pre><code class="language-bash">git clone https://github.com/second-state/wasm-learning
cd wasm-learning/cli/wasi
</code></pre>
<h2 id="构建-wasm-字节码"><a class="header" href="#构建-wasm-字节码">构建 WASM 字节码</a></h2>
<pre><code class="language-bash">rustup target add wasm32-wasi
cargo build --target wasm32-wasi --release
</code></pre>
<p>wasm 字节码应用程序位于 <code>target/wasm32-wasi/release/wasi_example_main.wasm</code> 文件中。你现在可以将其发布并用作容器镜像。</p>
<h2 id="申请-wasm-字节码的执行权限"><a class="header" href="#申请-wasm-字节码的执行权限">申请 Wasm 字节码的执行权限</a></h2>
<pre><code class="language-bash">chmod +x target/wasm32-wasi/release/wasi_example_main.wasm
</code></pre>
<h2 id="创建-dockerfile"><a class="header" href="#创建-dockerfile">创建 Dockerfile</a></h2>
<p>在 <code>target/wasm32-wasi/release</code> 文件夹中创建一个命名为 <code>Dockerfile</code> 的文件，其内容如下：</p>
<pre><code class="language-dockerfile">FROM scratch
ADD wasi_example_main.wasm /
CMD [&quot;/wasi_example_main.wasm&quot;]
</code></pre>
<h2 id="创建一个带注释的容器镜像"><a class="header" href="#创建一个带注释的容器镜像">创建一个带注释的容器镜像</a></h2>
<blockquote>
<p>请注意，添加自定义注释仍然是 buildah 中的新功能。</p>
</blockquote>
<p><code>crun</code> 容器运行时可以启动上述基于 WebAssembly 的容器镜像。但它需要容器镜像上的 <code>module.wasm.image/variant=compat-smart</code> 注释来表明它是一个没有客人操作系统（安装在虚拟机上的系统）的 WebAssembly 应用程序。你可以在<a href="https://github.com/containers/crun/blob/main/docs/wasm-wasi-example.md">官方 crun repo</a> 中找到详细信息。</p>
<p>要在容器镜像中添加 <code>module.wasm.image/variant=compat-smart</code> 注释，你需要最新的 <a href="https://buildah.io/">buildah</a>。 目前，Docker 不支持此功能。请按照 <a href="https://github.com/containers/buildah/blob/main/install.md">buildah 的安装说明</a> 构建最新的 buildah 二进制文件。</p>
<h3 id="在-ubuntu-上编译并安装最新的-buildah"><a class="header" href="#在-ubuntu-上编译并安装最新的-buildah">在 Ubuntu 上编译并安装最新的 buildah</a></h3>
<p>在 Ubuntu zesty 和 xenial 上，使用这些命令为 buildah 做准备。</p>
<pre><code class="language-bash">sudo apt-get -y install software-properties-common

export OS=&quot;xUbuntu_20.04&quot;
sudo bash -c &quot;echo \&quot;deb https://download.opensuse.org/repositories/devel:/kubic:/libcontainers:/stable/$OS/ /\&quot; &gt; /etc/apt/sources.list.d/devel:kubic:libcontainers:stable.list&quot;
sudo bash -c &quot;curl -L https://download.opensuse.org/repositories/devel:/kubic:/libcontainers:/stable/$OS/Release.key | apt-key add -&quot;

sudo add-apt-repository -y ppa:alexlarsson/flatpak
sudo apt-get -y -qq update
sudo apt-get -y install bats git libapparmor-dev libdevmapper-dev libglib2.0-dev libgpgme-dev libseccomp-dev libselinux1-dev skopeo-containers go-md2man containers-common
sudo apt-get -y install golang-1.16 make
</code></pre>
<p>然后，按照下列步骤在 Ubuntu 上编译和安装 buildah。</p>
<pre><code class="language-bash">mkdir -p ~/buildah
cd ~/buildah
export GOPATH=`pwd`
git clone https://github.com/containers/buildah ./src/github.com/containers/buildah
cd ./src/github.com/containers/buildah
PATH=/usr/lib/go-1.16/bin:$PATH make
cp bin/buildah /usr/bin/buildah
buildah --help
</code></pre>
<h3 id="创建和发布具备-buildah-的容器镜像"><a class="header" href="#创建和发布具备-buildah-的容器镜像">创建和发布具备 buildah 的容器镜像</a></h3>
<p>在 <code>target/wasm32-wasi/release/</code> 文件夹下，执行下列指令。</p>
<pre><code class="language-bash">$ sudo buildah build --annotation &quot;module.wasm.image/variant=compat-smart&quot; -t wasm-wasi-example .
# make sure docker is install and running
# systemctl status docker
# to make sure regular user can use docker
# sudo usermod -aG docker $USER
# newgrp docker

# You may need to use docker login to create the `~/.docker/config.json` for auth.
$ sudo buildah push --authfile ~/.docker/config.json wasm-wasi-example docker://docker.io/hydai/wasm-wasi-example:with-wasm-annotation
</code></pre>
<p>好了！ 现在你可以尝试在 <a href="kubernetes/demo/../cri/crio.html#run-a-http-server-app">CRI-O</a> 或 <a href="kubernetes/demo/../kubernetes/kubernetes.html#run-a-http-server-app">Kubernetes</a> 上运行它了！</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="http-服务端实例"><a class="header" href="#http-服务端实例">HTTP 服务端实例</a></h1>
<p>让我们构建一个基于 WebAssembly 的 HTTP 服务容器镜像。</p>
<p>这个 HTTP 服务应用程序是基于 Rust 开发，并采用了 <a href="https://github.com/second-state/wasmedge_wasi_socket">WasmEdge 网络 socket API</a>。</p>
<p>Kubernetes 可以使用 CRI-O、Docker 和 Containerd 来管理 wasm 应用程序生命周期。</p>
<h2 id="先决条件-2"><a class="header" href="#先决条件-2">先决条件</a></h2>
<p>这是一个 Rust 示例，它需要你先安装 <a href="https://www.rust-lang.org/tools/install">Rust</a> 和 <a href="kubernetes/demo/../../start/install.html">WasmEdge</a> 以便可以编译运行 http 服务。</p>
<h2 id="下载样例代码-1"><a class="header" href="#下载样例代码-1">下载样例代码</a></h2>
<pre><code class="language-bash">mkdir http_server
cd http_server
wget -q https://raw.githubusercontent.com/second-state/wasmedge_wasi_socket/main/examples/http_server/Cargo.toml
mkdir src
cd src
wget -q https://raw.githubusercontent.com/second-state/wasmedge_wasi_socket/main/examples/http_server/src/main.rs
cd ../
</code></pre>
<h2 id="构建-wasm-字节码-1"><a class="header" href="#构建-wasm-字节码-1">构建 WASM 字节码</a></h2>
<pre><code class="language-bash">rustup target add wasm32-wasi
cargo build --target wasm32-wasi --release
</code></pre>
<p>wasm 字节码应用程序现在应该位于 <code>./target/wasm32-wasi/release/http_server.wasm</code> 目录下。
你现在可以使用 wasmedge 测试运行它，然后将其发布为容器镜像。</p>
<h2 id="在-wasm-字节码上申请执行权限"><a class="header" href="#在-wasm-字节码上申请执行权限">在 Wasm 字节码上申请执行权限</a></h2>
<pre><code class="language-bash">chmod +x ./target/wasm32-wasi/release/http_server.wasm
</code></pre>
<h2 id="使用-wasmedge-运行-http_server-应用程序字节码"><a class="header" href="#使用-wasmedge-运行-http_server-应用程序字节码">使用 wasmedge 运行 http_server 应用程序字节码</a></h2>
<p>当你在使用 wasmedge 来执行字节码并看到如下结果时，你已完成了将字节码打包到容器中的准备工作。</p>
<pre><code class="language-bash">$ wasmedge ./target/wasm32-wasi/release/http_server.wasm
new connection at 1234
</code></pre>
<p>你可以在另一个的终端窗口中测试这个服务端。</p>
<pre><code class="language-bash">$ curl -X POST http://127.0.0.1:1234 -d 'name=WasmEdge'
echo: name=WasmEdge
</code></pre>
<h2 id="创建-dockerfile-1"><a class="header" href="#创建-dockerfile-1">创建 Dockerfile</a></h2>
<p>在 <code>target/wasm32-wasi/release</code> 文件夹中创建一个命名为 <code>Dockerfile</code> 的文件，其内容如下：</p>
<pre><code class="language-dockerfile">FROM scratch
ADD http_server.wasm /
CMD [&quot;/http_server.wasm&quot;]
</code></pre>
<h2 id="创建一个带注释的容器镜像-1"><a class="header" href="#创建一个带注释的容器镜像-1">创建一个带注释的容器镜像</a></h2>
<blockquote>
<p>请注意，添加自定义注释仍然是 buildah 中的新功能。</p>
</blockquote>
<p><code>crun</code> 容器运行时可以启动上述基于 WebAssembly 的容器镜像。但它需要容器镜像上的 <code>module.wasm.image/variant=compat-smart</code> 注释来表明它是一个没有客人操作系统（安装在虚拟机上的系统）的 WebAssembly 应用程序。你可以在<a href="https://github.com/containers/crun/blob/main/docs/wasm-wasi-example.md">官方 crun repo</a> 中找到详细信息。</p>
<p>要在容器镜像中添加 <code>module.wasm.image/variant=compat-smart</code> 注释，你需要最新的 <a href="https://buildah.io/">buildah</a>。 目前，Docker 不支持此功能。请按照 <a href="https://github.com/containers/buildah/blob/main/install.md">buildah 的安装说明</a> 构建最新的 buildah 二进制文件。</p>
<h3 id="在-ubuntu-上编译并安装最新的-buildah-1"><a class="header" href="#在-ubuntu-上编译并安装最新的-buildah-1">在 Ubuntu 上编译并安装最新的 buildah</a></h3>
<p>在 Ubuntu zesty 和 xenial 上，使用这些命令为 buildah 做准备。</p>
<pre><code class="language-bash">sudo apt-get -y install software-properties-common

export OS=&quot;xUbuntu_20.04&quot;
sudo bash -c &quot;echo \&quot;deb https://download.opensuse.org/repositories/devel:/kubic:/libcontainers:/stable/$OS/ /\&quot; &gt; /etc/apt/sources.list.d/devel:kubic:libcontainers:stable.list&quot;
sudo bash -c &quot;curl -L https://download.opensuse.org/repositories/devel:/kubic:/libcontainers:/stable/$OS/Release.key | apt-key add -&quot;

sudo add-apt-repository -y ppa:alexlarsson/flatpak
sudo apt-get -y -qq update

sudo apt-get -y install bats git libapparmor-dev libdevmapper-dev libglib2.0-dev libgpgme-dev libseccomp-dev libselinux1-dev skopeo-containers go-md2man containers-common
sudo apt-get -y install golang-1.16 make
</code></pre>
<p>然后，按照下列步骤在 Ubuntu 上编译和安装 buildah。</p>
<pre><code class="language-bash">mkdir -p ~/buildah
cd ~/buildah
export GOPATH=`pwd`
git clone https://github.com/containers/buildah ./src/github.com/containers/buildah
cd ./src/github.com/containers/buildah
PATH=/usr/lib/go-1.16/bin:$PATH make
cp bin/buildah /usr/bin/buildah
buildah --help
</code></pre>
<h3 id="创建和发布具备-buildah-的容器镜像-1"><a class="header" href="#创建和发布具备-buildah-的容器镜像-1">创建和发布具备 buildah 的容器镜像</a></h3>
<p>在 <code>target/wasm32-wasi/release/</code> 文件夹下，执行下列指令。</p>
<pre><code class="language-bash">$ sudo buildah build --annotation &quot;module.wasm.image/variant=compat-smart&quot; -t http_server .

#
# make sure docker is install and running
# systemctl status docker
# to make sure regular user can use docker
# sudo usermod -aG docker $USER#
# newgrp docker

# You may need to use docker login to create the `~/.docker/config.json` for auth.
#
# docker login

$ sudo buildah push --authfile ~/.docker/config.json http_server docker://docker.io/avengermojo/http_server:with-wasm-annotation
</code></pre>
<p>好了！ 现在你可以尝试在 <a href="kubernetes/demo/../cri/crio.html#run-a-http-server-app">CRI-O</a> 或 <a href="kubernetes/demo/../kubernetes/kubernetes.html#run-a-http-server-app">Kubernetes</a> 上运行它了！</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="容器运行时"><a class="header" href="#容器运行时">容器运行时</a></h1>
<p>容器镜像可以由任何与开放容器标准（OCI）兼容的容器运行时（runtime）启动，例如：</p>
<ul>
<li><a href="kubernetes/container/crun.html">crun</a>：高性能的轻量级容器运行时，用 C 语言编写</li>
<li><a href="kubernetes/container/runc.html">runc</a>：应用广泛的容器运行时，用 Go 语言编写</li>
<li><a href="kubernetes/container/youki.html">youki</a>：兼容 OCI 的容器运行时实现，用 Rust 编写</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="crun"><a class="header" href="#crun">crun</a></h1>
<p><a href="https://github.com/containers/crun">crun 项目</a>已经内置了对 WasmEdge 的支持。
目前，最简单的方法是自己从源代码构建它。首先，让我们确保 crun 在你的 Ubuntu 20.04 上安装了依赖包。
对于其他 Linux 发行版，请<a href="https://github.com/containers/crun#readme">参见此处</a>。</p>
<pre><code class="language-bash">$ sudo apt update
$ sudo apt install -y make git gcc build-essential pkgconf libtool \
      libsystemd-dev libprotobuf-c-dev libcap-dev libseccomp-dev libyajl-dev \
      go-md2man libtool autoconf python3 automake
</code></pre>
<p>接下来，配置、构建及安装一个支持 WasmEdge 的 crun 二进制文件。</p>
<pre><code class="language-bash">git clone https://github.com/containers/crun
cd crun
./autogen.sh
./configure --with-wasmedge
make
sudo make install
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="runc"><a class="header" href="#runc">runc</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="youki"><a class="header" href="#youki">youki</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cri-runtimes"><a class="header" href="#cri-runtimes">CRI runtimes</a></h1>
<p>高级容器运行时，例如 <a href="https://cri-o.io/">CRI-O</a> 和 <a href="https://containerd.io/">containerd</a>，从注册表拉取容器镜像(例如，Docker Hub)，在磁盘上管理这些镜像，并启动一个低级容器运行时来运行容器进程。
在本章节中，你可以看到一些针对 CRI-O 和 containerd 的具体教程。</p>
<ul>
<li><a href="kubernetes/cri/crio.html">CRI-O</a></li>
<li><a href="kubernetes/cri/containerd.html">containerd</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cri-o"><a class="header" href="#cri-o">CRI-O</a></h1>
<h2 id="快速开始-4"><a class="header" href="#快速开始-4">快速开始</a></h2>
<p><a href="https://github.com/second-state/wasmedge-containers-examples/">GitHub repo</a> 包含 CRI-O 相关示例的脚本和 Github Actions，以下是相关链接。</p>
<ul>
<li>WebAssembly 简单示例  <a href="https://github.com/second-state/wasmedge-containers-examples/blob/main/crio/README.md">Quick start</a> | <a href="https://github.com/second-state/wasmedge-containers-examples/blob/main/.github/workflows/crio.yml">Github Actions</a> | <a href="https://github.com/second-state/wasmedge-containers-examples/runs/4317457300?check_suite_focus=true#step:4:37">Successful run</a></li>
<li>HTTP 服务端示例 <a href="https://github.com/second-state/wasmedge-containers-examples/blob/main/crio/http_server/README.md">Quick start</a> | <a href="https://github.com/second-state/wasmedge-containers-examples/blob/main/.github/workflows/crio-server.yml">Github Actions</a> | <a href="https://github.com/second-state/wasmedge-containers-examples/runs/4317457313?check_suite_focus=true#step:4:54">Successful run</a></li>
</ul>
<p>在接下来的部分中，我们会展示如何使用这些脚本。</p>
<ul>
<li><a href="kubernetes/cri/crio.html#%E5%AE%89%E8%A3%85-cri-o">安装 CRI-O</a></li>
<li><a href="kubernetes/cri/crio.html#%E9%85%8D%E7%BD%AE-CRI-O-%E4%BB%A5%E4%BD%BF%E7%94%A8-crun">配置 CRI-O 和 crun</a></li>
<li><a href="kubernetes/cri/crio.html#%E8%BF%90%E8%A1%8C%E7%AE%80%E5%8D%95-WebAssembly-%E5%BA%94%E7%94%A8">示例一 :  WebAssembly 简单示例</a></li>
<li><a href="kubernetes/cri/crio.html#%E8%BF%90%E8%A1%8C-HTTP-%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%BA%94%E7%94%A8">示例二 : WebAssembly 中的 HTTP 服务端示例</a></li>
</ul>
<h2 id="安装-cri-o"><a class="header" href="#安装-cri-o">安装 CRI-O</a></h2>
<p>使用以下命令在你的系统上安装 CRI-O。</p>
<pre><code class="language-bash">export OS=&quot;xUbuntu_20.04&quot;
export VERSION=&quot;1.21&quot;
apt update
apt install -y libseccomp2 || sudo apt update -y libseccomp2
echo &quot;deb https://download.opensuse.org/repositories/devel:/kubic:/libcontainers:/stable/$OS/ /&quot; &gt; /etc/apt/sources.list.d/devel:kubic:libcontainers:stable.list
echo &quot;deb https://download.opensuse.org/repositories/devel:/kubic:/libcontainers:/stable:/cri-o:/$VERSION/$OS/ /&quot; &gt; /etc/apt/sources.list.d/devel:kubic:libcontainers:stable:cri-o:$VERSION.list

curl -L https://download.opensuse.org/repositories/devel:kubic:libcontainers:stable:cri-o:$VERSION/$OS/Release.key | apt-key add -
curl -L https://download.opensuse.org/repositories/devel:/kubic:/libcontainers:/stable/$OS/Release.key | apt-key add -

apt-get update
apt-get install criu libyajl2
apt-get install cri-o cri-o-runc cri-tools containernetworking-plugins
systemctl start crio
</code></pre>
<h2 id="配置-cri-o-以使用-crun"><a class="header" href="#配置-cri-o-以使用-crun">配置 CRI-O 以使用 crun</a></h2>
<p>CRI-O 默认使用 <code>runc</code> 运行时，我们需要修改配置以使用 <code>crun</code> 代替。
这需要添加到两个配置文件来完成。</p>
<blockquote>
<p>在运行下一步之前，请确保你已经构建并安装好了<a href="kubernetes/cri/../container/crun.html">支持 <code>WasmEdge</code> 的 <code>crun</code> 二进制文件</a>。</p>
</blockquote>
<p>首先，创建一个 <code>/etc/crio/crio.conf</code> 文件并添加以下内容，它会使 CRI-O 默认使用 <code>crun</code> 作为运行时。</p>
<pre><code class="language-conf">[crio.runtime]
default_runtime = &quot;crun&quot;
</code></pre>
<p><code>crun</code> 运行时在 <code>/etc/crio/crio.conf.d/01-crio-runc.conf</code> 文件中定义，按下面的内容修改此文件。</p>
<pre><code class="language-conf">[crio.runtime.runtimes.runc]
runtime_path = &quot;/usr/lib/cri-o-runc/sbin/runc&quot;
runtime_type = &quot;oci&quot;
runtime_root = &quot;/run/runc&quot;
# The above is the original content

# Add our crunw runtime here
[crio.runtime.runtimes.crun]
runtime_path = &quot;/usr/bin/crun&quot;
runtime_type = &quot;oci&quot;
runtime_root = &quot;/run/crun&quot;
</code></pre>
<p>接下来，重新启动 CRI-O 以应用配置更改。</p>
<pre><code class="language-bash">systemctl restart crio
</code></pre>
<h2 id="运行简单-webassembly-应用"><a class="header" href="#运行简单-webassembly-应用">运行简单 WebAssembly 应用</a></h2>
<p>现在，我们可以使用 CRI-O 运行一个简单的 WebAssembly 程序。
<a href="kubernetes/cri/../demo/wasi.html">另一篇文章</a> 解释了如何编译、打包和将 WebAssembly 程序作为容器镜像发布至 Docker hub。
在本节中，我们需要先使用 CRI-O 工具将这个基于 WebAssembly 的容器镜像从 Docker hub 中拉取下来。</p>
<pre><code class="language-bash">sudo crictl pull docker.io/hydai/wasm-wasi-example:with-wasm-annotation
</code></pre>
<p>接下来，我们需要创建两个简单的配置文件，指定 CRI-O 应该如何在 sandbox 中运行这个 WebAssembly 镜像。 我们已经有 <a href="https://github.com/second-state/wasmedge-containers-examples/blob/main/crio/container_wasi.json">container_wasi.json</a> 和 <a href="https://github.com/second-state/wasmedge-containers-examples/blob/main/crio/sandbox_config.json">sandbox_config.json</a> 这两个文件。你可以使用下面的命令将它们下载到本地目录。</p>
<pre><code class="language-bash">wget https://raw.githubusercontent.com/second-state/wasmedge-containers-examples/main/crio/sandbox_config.json
wget https://raw.githubusercontent.com/second-state/wasmedge-containers-examples/main/crio/container_wasi.json
</code></pre>
<p>现在你可以用 CRI-O 创建 pod 和容器。只需用本文的配置选项即可。</p>
<pre><code class="language-bash"># 创建 POD。输出会与示例不同。
$ sudo crictl runp sandbox_config.json
7992e75df00cc1cf4bff8bff660718139e3ad973c7180baceb9c84d074b516a4
# 设置一个辅助变量供之后使用。
$ POD_ID=7992e75df00cc1cf4bff8bff660718139e3ad973c7180baceb9c84d074b516a4

# 创建容器实例。输出会与示例不同。
$ sudo crictl create $POD_ID container_wasi.json sandbox_config.json
# 设置一个辅助变量供之后使用。
CONTAINER_ID=1d056e4a8a168f0c76af122d42c98510670255b16242e81f8e8bce8bd3a4476f
</code></pre>
<p>启动容器会执行 WebAssembly 程序， 你可以在控制台中看到输出。</p>
<pre><code class="language-bash"># 列出容器，容器状态应为 `Created`。
$ sudo crictl ps -a
CONTAINER           IMAGE                                          CREATED              STATE               NAME                     ATTEMPT             POD ID
1d056e4a8a168       hydai/wasm-wasi-example:with-wasm-annotation   About a minute ago   Created             podsandbox1-wasm-wasi   0                   7992e75df00cc

# 启动容器。
$ sudo crictl start $CONTAINER_ID

# 再次检查容器状态。
# 如果容器没有结束作业，你会看到它处于 Running 状态。
# 因为这个示例很小。此时你可能会看到已退出。
$ sudo crictl ps -a
CONTAINER           IMAGE                                          CREATED              STATE               NAME                     ATTEMPT             POD ID
1d056e4a8a168       hydai/wasm-wasi-example:with-wasm-annotation   About a minute ago   Running             podsandbox1-wasm-wasi   0                   7992e75df00cc

# 当容器完成作业时，你可以看到他的状态变为已退出。
$ sudo crictl ps -a
CONTAINER           IMAGE                                          CREATED              STATE               NAME                     ATTEMPT             POD ID
1d056e4a8a168       hydai/wasm-wasi-example:with-wasm-annotation   About a minute ago   Exited              podsandbox1-wasm-wasi   0                   7992e75df00cc

# 检查容器的日志，它应该显示 WebAssembly 程序的输出。
$ sudo crictl logs $CONTAINER_ID

Test 1: Print Random Number
Random number: 960251471

Test 2: Print Random Bytes
Random bytes: [50, 222, 62, 128, 120, 26, 64, 42, 210, 137, 176, 90, 60, 24, 183, 56, 150, 35, 209, 211, 141, 146, 2, 61, 215, 167, 194, 1, 15, 44, 156, 27, 179, 23, 241, 138, 71, 32, 173, 159, 180, 21, 198, 197, 247, 80, 35, 75, 245, 31, 6, 246, 23, 54, 9, 192, 3, 103, 72, 186, 39, 182, 248, 80, 146, 70, 244, 28, 166, 197, 17, 42, 109, 245, 83, 35, 106, 130, 233, 143, 90, 78, 155, 29, 230, 34, 58, 49, 234, 230, 145, 119, 83, 44, 111, 57, 164, 82, 120, 183, 194, 201, 133, 106, 3, 73, 164, 155, 224, 218, 73, 31, 54, 28, 124, 2, 38, 253, 114, 222, 217, 202, 59, 138, 155, 71, 178, 113]

Test 3: Call an echo function
Printed from wasi: This is from a main function
This is from a main function

Test 4: Print Environment Variables
The env vars are as follows.
PATH: /usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
TERM: xterm
HOSTNAME: crictl_host
PATH: /usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
The args are as follows.
/var/lib/containers/storage/overlay/006e7cf16e82dc7052994232c436991f429109edea14a8437e74f601b5ee1e83/merged/wasi_example_main.wasm
50000000

Test 5: Create a file `/tmp.txt` with content `This is in a file`

Test 6: Read the content from the previous file
File content is This is in a file

Test 7: Delete the previous file
</code></pre>
<p>接下来，你可尝试在 <a href="kubernetes/cri/../../kubernetes/kubernetes.html">Kubernetes</a> 中运行这个应用!</p>
<h2 id="运行-http-服务端应用"><a class="header" href="#运行-http-服务端应用"><strong>运行 HTTP 服务端应用</strong></a></h2>
<p>最后，我们可以在 CRI-O 中运行一个简单的基于 WebAssembly 的 HTTP 微服务。
<a href="kubernetes/cri/../demo/server.html">另一篇文章</a> 解释了如何编译、打包和将 WebAssembly 程序作为容器镜像发布至 Docker hub 。
在本节中，我们需要先使用 CRI-O 工具将这个基于 WebAssembly 的容器镜像从 Docker hub 中拉取下来。</p>
<pre><code class="language-bash">sudo crictl pull docker.io/avengermojo/http_server:with-wasm-annotation
</code></pre>
<p>接下来，我们需要创建两个简单的配置文件，指定 CRI-O 应该如何在 sandbox 中运行这个 WebAssembly 镜像。 我们已经有 <a href="https://raw.githubusercontent.com/second-state/wasmedge-containers-examples/main/crio/http_server/container_http_server.json">container_http_server.json</a> 和 <a href="https://github.com/second-state/wasmedge-containers-examples/blob/main/crio/sandbox_config.json">sandbox_config.json</a> 这两个文件。你可以使用下面的命令将它们下载到本地目录。</p>
<blockquote>
<p>HTTP 服务端示例和 WASI 简单示例使用的 <code>sandbox_config.json</code> 文件是相同的。 但另一个 <code>container_*.json</code> 文件是特定的，因为它包含应用程序的 Docker Hub 链接。</p>
</blockquote>
<pre><code class="language-bash">wget https://raw.githubusercontent.com/second-state/wasmedge-containers-examples/main/crio/sandbox_config.json
wget https://raw.githubusercontent.com/second-state/wasmedge-containers-examples/main/crio/http_server/container_http_server.json
</code></pre>
<p>现在你可以用 CRI-O 创建 pod 和容器。只需用本文的配置选项即可。</p>
<pre><code class="language-bash"># 创建 POD。输出会与示例不同。
$ sudo crictl runp sandbox_config.json
7992e75df00cc1cf4bff8bff660718139e3ad973c7180baceb9c84d074b516a4
# 设置一个辅助变量供之后使用。
$ POD_ID=7992e75df00cc1cf4bff8bff660718139e3ad973c7180baceb9c84d074b516a4

# 创建容器实例。输出会与示例不同。
$ sudo crictl create $POD_ID container_wasi.json sandbox_config.json
# 设置一个辅助变量供之后使用。
CONTAINER_ID=1d056e4a8a168f0c76af122d42c98510670255b16242e81f8e8bce8bd3a4476f
</code></pre>
<p>启动容器会执行 WebAssembly 程序， 你可以在控制台中看到输出。</p>
<pre><code class="language-bash"># 启动容器
$ sudo crictl start $CONTAINER_ID

# 检查容器状态。它应该正在运行。
# 如果没有，请等待几秒钟，然后再次检查。
$ sudo crictl ps -a
CONTAINER           IMAGE                                          CREATED                  STATE               NAME                ATTEMPT             POD ID
4eeddf8613691       avengermojo/http_server:with-wasm-annotation   Less than a second ago   Running             http_server         0                   1d84f30e7012e

# 检查容器的日志以查看 HTTP 服务器正在监听端口为 1234 。
$ sudo crictl logs $CONTAINER_ID
new connection at 1234

# 获取分配给容器的 IP 地址。
$ sudo crictl inspect $CONTAINER_ID | grep IP.0 | cut -d: -f 2 | cut -d'&quot;' -f 2
10.85.0.2

# 在该 IP 地址测试 HTTP 服务状态。
$ curl -d &quot;name=WasmEdge&quot; -X POST http://10.85.0.2:1234
echo: name=WasmEdge
</code></pre>
<p>接下来，你可尝试在 <a href="kubernetes/cri/../../kubernetes/kubernetes.html">Kubernetes</a> 中运行这个应用!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="containerd"><a class="header" href="#containerd">containerd</a></h1>
<h2 id="快速开始-5"><a class="header" href="#快速开始-5">快速开始</a></h2>
<p><a href="https://github.com/second-state/wasmedge-containers-examples/">GitHub repo</a>包含 containerd 相关示例的脚本和 Github Actions，以下是相关链接。</p>
<ul>
<li>WebAssembly 简单示例 <a href="https://github.com/second-state/wasmedge-containers-examples/blob/main/containerd/README.md">Quick start</a> | <a href="https://github.com/second-state/wasmedge-containers-examples/blob/main/.github/workflows/containerd.yml">Github Actions</a> | <a href="https://github.com/second-state/wasmedge-containers-examples/runs/4328930139?check_suite_focus=true#step:4:25">Successful run</a></li>
<li>HTTP 服务端示例 <a href="https://github.com/second-state/wasmedge-containers-examples/blob/main/containerd/http_server/README.md">Quick start</a> | <a href="https://github.com/second-state/wasmedge-containers-examples/blob/main/.github/workflows/containerd-server.yml">Github Actions</a> | <a href="https://github.com/second-state/wasmedge-containers-examples/runs/4328930141?check_suite_focus=true#step:4:44">Successful run</a></li>
</ul>
<p>在接下来的部分中，我们会展示如何使用这些脚本。</p>
<ul>
<li><a href="kubernetes/cri/containerd.html#%E5%AE%89%E8%A3%85-containerd">安装 containerd</a></li>
<li><a href="kubernetes/cri/containerd.html#%E8%BF%90%E8%A1%8C%E7%AE%80%E5%8D%95-WebAssembly-%E5%BA%94%E7%94%A8">示例一： WebAssembly 简单示例</a></li>
<li><a href="kubernetes/cri/containerd.html#%E8%BF%90%E8%A1%8C-HTTP-%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%BA%94%E7%94%A8">示例二： WebAssembly 中的 HTTP 服务端示例</a></li>
</ul>
<h2 id="安装-containerd"><a class="header" href="#安装-containerd">安装 containerd</a></h2>
<p>使用以下命令在您的系统上安装 containerd。</p>
<pre><code class="language-bash">export VERSION=&quot;1.5.7&quot;
echo -e &quot;Version: $VERSION&quot;
echo -e &quot;Installing libseccomp2 ...&quot;
sudo apt install -y libseccomp2
echo -e &quot;Installing wget&quot;
sudo apt install -y wget

wget https://github.com/containerd/containerd/releases/download/v${VERSION}/cri-containerd-cni-${VERSION}-linux-amd64.tar.gz
wget https://github.com/containerd/containerd/releases/download/v${VERSION}/cri-containerd-cni-${VERSION}-linux-amd64.tar.gz.sha256sum
sha256sum --check cri-containerd-cni-${VERSION}-linux-amd64.tar.gz.sha256sum

sudo tar --no-overwrite-dir -C / -xzf cri-containerd-cni-${VERSION}-linux-amd64.tar.gz
sudo systemctl daemon-reload
</code></pre>
<p>将 containerd 配置为使用 <code>crun</code> 作为底层 OCI runtime。
此处需要修改 <code>/etc/containerd/config.toml</code> 文件。</p>
<pre><code class="language-bash">sudo mkdir -p /etc/containerd/
sudo bash -c &quot;containerd config default &gt; /etc/containerd/config.toml&quot;
wget https://raw.githubusercontent.com/second-state/wasmedge-containers-examples/main/containerd/containerd_config.diff
sudo patch -d/ -p0 &lt; containerd_config.diff
</code></pre>
<p>启动 containerd 服务。</p>
<pre><code class="language-bash">sudo systemctl start containerd
</code></pre>
<p>在运行下一步之前，请确保你已经构建并安装好了<a href="kubernetes/cri/../container/crun.html">支持 <code>WasmEdge</code>的 <code>crun</code>二进制文件</a>。</p>
<h2 id="运行简单-webassembly-应用-1"><a class="header" href="#运行简单-webassembly-应用-1">运行简单 WebAssembly 应用</a></h2>
<p>现在，我们可以使用 containerd 运行一个简单的 WebAssembly 程序。
<a href="kubernetes/cri/../demo/wasi.html">另一篇文章</a> 解释了如何编译、打包和将 WebAssembly 程序作为容器镜像发布至 Docker hub 。
在本节中，我们需要先使用 containerd 工具将这个基于 WebAssembly 的容器镜像从 Docker hub 中拉取下来。</p>
<pre><code class="language-bash">sudo ctr i pull docker.io/hydai/wasm-wasi-example:with-wasm-annotation
</code></pre>
<p>现在，您可以使用 ctr（containerd cli 工具）运行此示例。</p>
<pre><code class="language-bash">sudo ctr run --rm --runc-binary crun --runtime io.containerd.runc.v2 --label module.wasm.image/variant=compat-smart docker.io/hydai/wasm-wasi-example:with-wasm-annotation wasm-example /wasi_example_main.wasm 50000000
</code></pre>
<p>启动容器会执行 WebAssembly 程序， 您可以在控制台中看到输出。</p>
<pre><code class="language-bash">Creating POD ...
Random number: -1678124602
Random bytes: [12, 222, 246, 184, 139, 182, 97, 3, 74, 155, 107, 243, 20, 164, 175, 250, 60, 9, 98, 25, 244, 92, 224, 233, 221, 196, 112, 97, 151, 155, 19, 204, 54, 136, 171, 93, 204, 129, 177, 163, 187, 52, 33, 32, 63, 104, 128, 20, 204, 60, 40, 183, 236, 220, 130, 41, 74, 181, 103, 178, 43, 231, 92, 211, 219, 47, 223, 137, 70, 70, 132, 96, 208, 126, 142, 0, 133, 166, 112, 63, 126, 164, 122, 49, 94, 80, 26, 110, 124, 114, 108, 90, 62, 250, 195, 19, 189, 203, 175, 189, 236, 112, 203, 230, 104, 130, 150, 39, 113, 240, 17, 252, 115, 42, 12, 185, 62, 145, 161, 3, 37, 161, 195, 138, 232, 39, 235, 222]
Printed from wasi: This is from a main function
This is from a main function
The env vars are as follows.
The args are as follows.
/wasi_example_main.wasm
50000000
File content is This is in a file
</code></pre>
<p>接下来，你可尝试在 <a href="kubernetes/cri/../../kubernetes/kubernetes.html">Kubernetes</a>中运行这个应用!</p>
<h2 id="运行-http-服务端应用-1"><a class="header" href="#运行-http-服务端应用-1">运行 HTTP 服务端应用</a></h2>
<p>最后，我们可以在 containerd 中运行一个简单的基于 WebAssembly 的 HTTP 微服务。
<a href="kubernetes/cri/../demo/server.html">另一篇文章</a> 解释了如何编译、打包和将 WebAssembly 程序作为容器镜像发布至 Docker hub 。
在本节中，我们需要先使用 containerd 工具将这个基于 WebAssembly 的容器镜像从 Docker hub 中拉取下来。</p>
<pre><code class="language-bash">sudo ctr i pull docker.io/avengermojo/http_server:with-wasm-annotation
</code></pre>
<p>现在，您可以使用 ctr（containerd cli 工具）运行该示例。（请注意，我们需要加上 <code>--net-host</code> 参数来运行容器，以便可以从外部访问 WasmEdge 容器内的 HTTP server。）</p>
<pre><code class="language-bash">sudo ctr run --rm --net-host --runc-binary crun --runtime io.containerd.runc.v2 --label module.wasm.image/variant=compat-smart docker.io/avengermojo/http_server:with-wasm-annotation http-server-example /http_server.wasm
</code></pre>
<p>启动容器会执行 WebAssembly 程序， 您可以在控制台中看到输出。</p>
<pre><code class="language-bash">new connection at 1234

# Test the HTTP service at that IP address
curl -d &quot;name=WasmEdge&quot; -X POST http://127.0.0.1:1234
echo: name=WasmEdge
</code></pre>
<p>接下来，你可尝试在 <a href="kubernetes/cri/../../kubernetes/kubernetes.html">Kubernetes</a> 中运行这个应用!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="kubernetes"><a class="header" href="#kubernetes">Kubernetes</a></h1>
<p>大多数高级容器运行时都实现了 Kubernetes 的 CRI（Container Runtime Interface）规范，以便能够被 Kubernetes 工具管理。这个意味着可以利用 Kubernetes 工具来管理 pod 和命名空间中 WebAssembly 应用程序镜像。</p>
<p>不同场景的 Kubernetes 设置具体说明如下所示：</p>
<ul>
<li><a href="kubernetes/kubernetes/kubernetes-crio.html">Kubernetes + CRI-O</a></li>
<li><a href="kubernetes/kubernetes/kubernetes-containerd.html">Kubernetes + containerd</a></li>
<li><a href="kubernetes/kubernetes/kubeedge.html">KubeEdge</a></li>
<li><a href="kubernetes/kubernetes/superedge.html">SuperEdge</a></li>
<li><a href="kubernetes/kubernetes/openyurt.html">OpenYurt</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="kubernetes--cri-o"><a class="header" href="#kubernetes--cri-o">Kubernetes + CRI-O</a></h1>
<h2 id="快速开始-6"><a class="header" href="#快速开始-6">快速开始</a></h2>
<p><a href="https://github.com/second-state/wasmedge-containers-examples/">这个 GitHub 仓库</a> 中包含了使用 Kubernetes + CRI-O 运行示例程序所需的脚本和 Github Actions 配置文件。</p>
<ul>
<li>
<p>简单示例程序 <a href="https://github.com/second-state/wasmedge-containers-examples/blob/main/kubernetes_crio/README.md">快速开始</a> | <a href="https://github.com/second-state/wasmedge-containers-examples/blob/main/.github/workflows/kubernetes-crio.yml">查看 Github Actions 配置文件</a> | <a href="https://github.com/second-state/wasmedge-containers-examples/runs/4328930134?check_suite_focus=true#step:6:3007">查看运行结果</a></p>
</li>
<li>
<p>基于 WebAssembly 的 HTTP 服务 <a href="https://github.com/second-state/wasmedge-containers-examples/blob/main/kubernetes_crio/http_server/README.md">快速开始</a> | <a href="https://github.com/second-state/wasmedge-containers-examples/blob/main/.github/workflows/kubernetes-crio-server.yml">查看 Github Actions 配置文件</a> | <a href="https://github.com/second-state/wasmedge-containers-examples/runs/4577789182?check_suite_focus=true#step:6:3030">查看运行结果</a></p>
</li>
</ul>
<p>本节接下来的部分将详细地解释其中的细节。你需要先 <a href="kubernetes/kubernetes/../cri/crio.html">安装并配置好 CRI-O</a> 才能使用 WasmEdge 容器镜像。</p>
<h2 id="安装和启动-kubernetes"><a class="header" href="#安装和启动-kubernetes">安装和启动 Kubernetes</a></h2>
<p>在终端窗口运行下面的脚本，就可以在本地开发环境中安装和启动一个 Kubernetes。</p>
<pre><code class="language-bash"># 安装 go
$ wget https://golang.org/dl/go1.17.1.linux-amd64.tar.gz
$ sudo rm -rf /usr/local/go
sudo tar -C /usr/local -xzf go1.17.1.linux-amd64.tar.gz
source /home/${USER}/.profile

# 克隆 k8s
git clone https://github.com/kubernetes/kubernetes.git
cd kubernetes
git checkout v1.22.2

# 用 k8s 中的安装脚本安装 etcd
sudo CGROUP_DRIVER=systemd CONTAINER_RUNTIME=remote CONTAINER_RUNTIME_ENDPOINT='unix:///var/run/crio/crio.sock' ./hack/install-etcd.sh
export PATH=&quot;/home/${USER}/kubernetes/third_party/etcd:${PATH}&quot;
sudo cp third_party/etcd/etcd* /usr/local/bin/

# 以上命令运行完毕以后，系统中就可以找到以下文件：/usr/local/bin/etcd  /usr/local/bin/etcdctl  /usr/local/bin/etcdutl 

# 用 CRI-O 构建运行 k8s
sudo apt-get install -y build-essential
sudo CGROUP_DRIVER=systemd CONTAINER_RUNTIME=remote CONTAINER_RUNTIME_ENDPOINT='unix:///var/run/crio/crio.sock' ./hack/local-up-cluster.sh

... ...
Local Kubernetes cluster is running. Press Ctrl-C to shut it down.
</code></pre>
<p>此时<strong>不要</strong>关闭终端，因为 Kubernetes 正在运行中！</p>
<h2 id="在-kubernetes-中运行-webassembly-容器镜像"><a class="header" href="#在-kubernetes-中运行-webassembly-容器镜像">在 Kubernetes 中运行 WebAssembly 容器镜像</a></h2>
<p>本节的内容介绍了如何在 Kubernetes 中，以 pod 中的容器的形式来运行 WebAssembly 程序。我们需要打开另一个终端。</p>
<pre><code class="language-bash">export KUBERNETES_PROVIDER=local

sudo cluster/kubectl.sh config set-cluster local --server=https://localhost:6443 --certificate-authority=/var/run/kubernetes/server-ca.crt
sudo cluster/kubectl.sh config set-credentials myself --client-key=/var/run/kubernetes/client-admin.key --client-certificate=/var/run/kubernetes/client-admin.crt
sudo cluster/kubectl.sh config set-context local --cluster=local --user=myself
sudo cluster/kubectl.sh config use-context local
sudo cluster/kubectl.sh
</code></pre>
<p>检查一下集群状态，看看集群有没有正常运行。</p>
<pre><code class="language-bash">$ sudo cluster/kubectl.sh cluster-info

# 运行命令后预计会有以下输出
Cluster &quot;local&quot; set.
User &quot;myself&quot; set.
Context &quot;local&quot; created.
Switched to context &quot;local&quot;.
Kubernetes control plane is running at https://localhost:6443
CoreDNS is running at https://localhost:6443/api/v1/namespaces/kube-system/services/kube-dns:dns/proxy

To further debug and diagnose cluster problems, use 'kubectl cluster-info dump'.
</code></pre>
<h3 id="简单的-webassembly-应用"><a class="header" href="#简单的-webassembly-应用">简单的 WebAssembly 应用</a></h3>
<p><a href="kubernetes/kubernetes/../demo/wasi.html">这篇文章</a> 描述了如何编译、打包一个简单的 WebAssembly WASI 程序，以及将它以容器镜像的形式发布到 Docker hub 的完整过程。</p>
<pre><code class="language-bash">sudo cluster/kubectl.sh run -it --rm --restart=Never wasi-demo --image=hydai/wasm-wasi-example:with-wasm-annotation --annotations=&quot;module.wasm.image/variant=compat-smart&quot; /wasi_example_main.wasm 50000000
</code></pre>
<p>容器化后的应用程序的输出会被打印到控制台上。</p>
<pre><code class="language-bash">Random number: 401583443
Random bytes: [192, 226, 162, 92, 129, 17, 186, 164, 239, 84, 98, 255, 209, 79, 51, 227, 103, 83, 253, 31, 78, 239, 33, 218, 68, 208, 91, 56, 37, 200, 32, 12, 106, 101, 241, 78, 161, 16, 240, 158, 42, 24, 29, 121, 78, 19, 157, 185, 32, 162, 95, 214, 175, 46, 170, 100, 212, 33, 27, 190, 139, 121, 121, 222, 230, 125, 251, 21, 210, 246, 215, 127, 176, 224, 38, 184, 201, 74, 76, 133, 233, 129, 48, 239, 106, 164, 190, 29, 118, 71, 79, 203, 92, 71, 68, 96, 33, 240, 228, 62, 45, 196, 149, 21, 23, 143, 169, 163, 136, 206, 214, 244, 26, 194, 25, 101, 8, 236, 247, 5, 164, 117, 40, 220, 52, 217, 92, 179]
Printed from wasi: This is from a main function
This is from a main function
The env vars are as follows.
The args are as follows.
/wasi_example_main.wasm
50000000
File content is This is in a file
pod &quot;wasi-demo-2&quot; deleted
</code></pre>
<h3 id="基于-webassembly-的-http-服务"><a class="header" href="#基于-webassembly-的-http-服务">基于 WebAssembly 的 HTTP 服务</a></h3>
<p><a href="kubernetes/kubernetes/../demo/server.html">这篇文章</a> 描述了如何编译、打包一个基于 WebAssembly 的 HTTP 服务应用程序，以及将它以容器镜像的形式发布到 Docker hub 的完整过程。由于运行 HTTP 服务的容器需要 Kubernetes 提供网络支持，我们需要用 <a href="https://github.com/second-state/wasmedge-containers-examples/blob/main/kubernetes_crio/http_server/k8s-http_server.yaml">k8s-http_server.yaml</a> 文件设定具体的配置。</p>
<pre><code class="language-yaml">apiVersion: v1
kind: Pod
metadata:
  name: http-server
  namespace: default
  annotations:
    module.wasm.image/variant: compat-smart
spec:
  hostNetwork: true
  containers:
  - name: http-server
    image: avengermojo/http_server:with-wasm-annotation
    command: [ &quot;/http_server.wasm&quot; ]
    ports:
    - containerPort: 1234
      protocol: TCP
    livenessProbe:
      tcpSocket:
        port: 1234
      initialDelaySeconds: 3
      periodSeconds: 30
</code></pre>
<p>输入下面的命令，可以使用上面的 <code>k8s-http_server.yaml</code> 文件，从 Docker Hub 拉取并运行基于 WebAssembly 的镜像。</p>
<pre><code class="language-bash">sudo ./kubernetes/cluster/kubectl.sh apply -f k8s-http_server.yaml
</code></pre>
<p>然后运行以下命令，查看运行中的容器应用程序和他们的 IP 地址。我们在 yaml 配置中用的是 <code>hostNetwork</code> 网络，所以 HTTP 服务器镜像会在 IP 为 <code>127.0.0.1</code> 的本地网络中运行。</p>
<pre><code class="language-bash">$ sudo cluster/kubectl.sh get pod --all-namespaces -o wide

NAMESPACE     NAME                       READY   STATUS             RESTARTS      AGE   IP          NODE        NOMINATED NODE   READINESS GATES
default       http-server                1/1     Running            1 (26s ago)     60s     127.0.0.1   127.0.0.1   &lt;none&gt;           &lt;none&gt;
</code></pre>
<p>现在，我们可以用 <code>curl</code> 命令来访问 HTTP 服务了。</p>
<pre><code class="language-bash">$ curl -d &quot;name=WasmEdge&quot; -X POST http://127.0.0.1:1234
echo: name=WasmEdge
</code></pre>
<p>搞定！</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="kubernetes--containerd"><a class="header" href="#kubernetes--containerd">Kubernetes + containerd</a></h1>
<h2 id="快速开始-7"><a class="header" href="#快速开始-7">快速开始</a></h2>
<p><a href="https://github.com/second-state/wasmedge-containers-examples/">GitHub 仓库</a> 包含在 Kubernetes + containerd 上运行我们的示例应用程序的脚本和 Github Actions。</p>
<ul>
<li>简单的 WebAssembly 示例 <a href="https://github.com/second-state/wasmedge-containers-examples/blob/main/kubernetes_containerd/README.md">快速开始</a> | <a href="https://github.com/second-state/wasmedge-containers-examples/blob/main/.github/workflows/kubernetes-containerd.yml">Github Actions</a> | <a href="https://github.com/second-state/wasmedge-containers-examples/runs/4577789181?check_suite_focus=true#step:6:3010">成功运行</a></li>
<li>基于 WebAssembly 的 HTTP 服务 <a href="https://github.com/second-state/wasmedge-containers-examples/blob/main/kubernetes_containerd/http_server/README.md">快速开始</a> | <a href="https://github.com/second-state/wasmedge-containers-examples/blob/main/.github/workflows/kubernetes-containerd-server.yml">Github Actions</a> | <a href="https://github.com/second-state/wasmedge-containers-examples/runs/4577789184?check_suite_focus=true#step:6:3016">成功运行</a></li>
</ul>
<p>在本节的其余部分，我们将详细解释这些步骤。我们将假设你已经 <a href="kubernetes/kubernetes/../cri/containerd.html">安装并配置了 containerd</a>，以便与 WasmEdge 容器镜像一起工作。</p>
<h2 id="安装和启动-kubernetes-1"><a class="header" href="#安装和启动-kubernetes-1">安装和启动 Kubernetes</a></h2>
<p>从终端窗口运行以下命令，为本地开发设置了 Kubernetes。</p>
<pre><code class="language-bash"># 安装 go
$ wget https://golang.org/dl/go1.17.1.linux-amd64.tar.gz
$ sudo rm -rf /usr/local/go
$ sudo tar -C /usr/local -xzf go1.17.1.linux-amd64.tar.gz
$ source /home/${USER}/.profile

# 克隆 k8s 源码
$ git clone https://github.com/kubernetes/kubernetes.git
$ cd kubernetes
$ git checkout v1.22.2

# 在 k8s 中用 hack 脚本安装 etcd
$ sudo CGROUP_DRIVER=systemd CONTAINER_RUNTIME=remote CONTAINER_RUNTIME_ENDPOINT='unix:///var/run/crio/crio.sock' ./hack/install-etcd.sh
$ export PATH=&quot;/home/${USER}/kubernetes/third_party/etcd:${PATH}&quot;
$ sudo cp third_party/etcd/etcd* /usr/local/bin/

# 运行上述命令后，你可以找到以下文件：/usr/local/bin/etcd  /usr/local/bin/etcdctl  /usr/local/bin/etcdutl

# 用 containerd 构建和运行 k8s
$ sudo apt-get install -y build-essential
$ sudo CGROUP_DRIVER=systemd CONTAINER_RUNTIME=remote CONTAINER_RUNTIME_ENDPOINT='unix:///var/run/crio/crio.sock' ./hack/local-up-cluster.sh

... ...
Local Kubernetes cluster is running. Press Ctrl-C to shut it down.
</code></pre>
<p><strong>不要关闭</strong>你的终端窗口。Kubernetes 正在运行!</p>
<h2 id="在-kubernetes-中运行-webassembly-容器镜像-1"><a class="header" href="#在-kubernetes-中运行-webassembly-容器镜像-1">在 Kubernetes 中运行 WebAssembly 容器镜像</a></h2>
<p>最后，我们可以在 Kubernetes 中将 WebAssembly 程序作为容器运行在 pod 中。
在本节中，我们将从<strong>另一个终端窗口</strong>开始，使用集群。</p>
<pre><code class="language-bash">export KUBERNETES_PROVIDER=local

sudo cluster/kubectl.sh config set-cluster local --server=https://localhost:6443 --certificate-authority=/var/run/kubernetes/server-ca.crt
sudo cluster/kubectl.sh config set-credentials myself --client-key=/var/run/kubernetes/client-admin.key --client-certificate=/var/run/kubernetes/client-admin.crt
sudo cluster/kubectl.sh config set-context local --cluster=local --user=myself
sudo cluster/kubectl.sh config use-context local
sudo cluster/kubectl.sh
</code></pre>
<p>让我们检查一下状态，确保集群正在运行。</p>
<pre><code class="language-bash">$ sudo cluster/kubectl.sh cluster-info

# 期望输出
Cluster &quot;local&quot; set.
User &quot;myself&quot; set.
Context &quot;local&quot; created.
Switched to context &quot;local&quot;.
Kubernetes control plane is running at https://localhost:6443
CoreDNS is running at https://localhost:6443/api/v1/namespaces/kube-system/services/kube-dns:dns/proxy

To further debug and diagnose cluster problems, use 'kubectl cluster-info dump'.
</code></pre>
<h3 id="一个简单的-webassembly-应用程序"><a class="header" href="#一个简单的-webassembly-应用程序">一个简单的 WebAssembly 应用程序</a></h3>
<p><a href="kubernetes/kubernetes/../demo/wasi.html">另一篇文章</a>解释了如何编译、打包和发布一个简单的 WebAssembly WASI 程序作为容器镜像到 Docker hub。
在 Kubernetes 集群中运行 Docker Hub 中基于 WebAssembly 的镜像，方法如下。</p>
<pre><code class="language-bash">sudo cluster/kubectl.sh run -it --rm --restart=Never wasi-demo --image=hydai/wasm-wasi-example:with-wasm-annotation --annotations=&quot;module.wasm.image/variant=compat-smart&quot; --overrides='{&quot;kind&quot;:&quot;Pod&quot;, &quot;apiVersion&quot;:&quot;v1&quot;, &quot;spec&quot;: {&quot;hostNetwork&quot;: true}}' /wasi_example_main.wasm 50000000
</code></pre>
<p>容器化应用程序的输出被打印到控制台。</p>
<pre><code class="language-bash">Random number: 401583443
Random bytes: [192, 226, 162, 92, 129, 17, 186, 164, 239, 84, 98, 255, 209, 79, 51, 227, 103, 83, 253, 31, 78, 239, 33, 218, 68, 208, 91, 56, 37, 200, 32, 12, 106, 101, 241, 78, 161, 16, 240, 158, 42, 24, 29, 121, 78, 19, 157, 185, 32, 162, 95, 214, 175, 46, 170, 100, 212, 33, 27, 190, 139, 121, 121, 222, 230, 125, 251, 21, 210, 246, 215, 127, 176, 224, 38, 184, 201, 74, 76, 133, 233, 129, 48, 239, 106, 164, 190, 29, 118, 71, 79, 203, 92, 71, 68, 96, 33, 240, 228, 62, 45, 196, 149, 21, 23, 143, 169, 163, 136, 206, 214, 244, 26, 194, 25, 101, 8, 236, 247, 5, 164, 117, 40, 220, 52, 217, 92, 179]
Printed from wasi: This is from a main function
This is from a main function
The env vars are as follows.
The args are as follows.
/wasi_example_main.wasm
50000000
File content is This is in a file
pod &quot;wasi-demo-2&quot; deleted
</code></pre>
<h3 id="一个基于-webassembly-的-http-服务"><a class="header" href="#一个基于-webassembly-的-http-服务">一个基于 WebAssembly 的 HTTP 服务</a></h3>
<p><a href="kubernetes/kubernetes/../demo/server.html">另一篇文章</a>解释了如何编译、打包和发布一个简单的 WebAssembly HTTP 服务应用程序作为容器镜像到 Docker hub。
在 Kubernetes 集群中运行 Docker Hub 中基于 WebAssembly 的镜像，方法如下。</p>
<pre><code class="language-bash">sudo cluster/kubectl.sh run --restart=Never http-server --image=avengermojo/http_server:with-wasm-annotation --annotations=&quot;module.wasm.image/variant=compat-smart&quot; --overrides='{&quot;kind&quot;:&quot;Pod&quot;, &quot;apiVersion&quot;:&quot;v1&quot;, &quot;spec&quot;: {&quot;hostNetwork&quot;: true}}'
</code></pre>
<p>由于我们在 <code>kubectl run</code> 命令中使用了 <code>hostNetwork</code> ，HTTP 服务器镜像运行在本地网络上，IP 地址是 <code>127.0.0.1</code> 。
现在，你可以使用 <code>curl</code> 命令来访问 HTTP 服务。</p>
<pre><code class="language-bash">$ curl -d &quot;name=WasmEdge&quot; -X POST http://127.0.0.1:1234
echo: name=WasmEdge
</code></pre>
<p>就是这样!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="kind"><a class="header" href="#kind">KinD</a></h1>
<p>KinD 是在 Docker 内部运行的 Kubernetes 发行版，非常适合本地开发或集成测试。</p>
<h2 id="快速开始-8"><a class="header" href="#快速开始-8">快速开始</a></h2>
<p>作为先决条件，我们第一步需要安装 KinD。为此，请参阅<a href="https://kind.sigs.k8s.io/docs/user/quick-start/#installing-from-release-binaries">快速入门指南</a>和<a href="https://kind.sigs.k8s.io/docs/user/quick-start/#installing-from-release-binaries">稳定版发布页面</a>来安装最新版本的 KinD CLI。</p>
<p>如果已经安装了 KinD，我们可以直接从<a href="https://github.com/Liquid-Reply/kind-crun-wasm">这里</a>中的示例开始：</p>
<pre><code class="language-bash"># Create a &quot;WASM in KinD&quot; Cluster
kind create cluster --image ghcr.io/liquid-reply/kind-crun-wasm:v1.23.0
# Run the example
kubectl run -it --rm --restart=Never wasi-demo --image=hydai/wasm-wasi-example:with-wasm-annotation --annotations=&quot;module.wasm.image/variant=compat-smart&quot; /wasi_example_main.wasm 50000000
</code></pre>
<p>在这个章节的剩余部分，我们会介绍如何去创建一个带有 wasmedge 的支持 KinD 的节点镜像。</p>
<h2 id="编译-crun"><a class="header" href="#编译-crun">编译 crun</a></h2>
<p>KinD 使用 kindest/node 这个镜像作为控制平面和工作节点。该镜像包括作为 CRI 的 containerd 和作为 OCI 运行时的 runc。为了启用 WasmEdge 支持，我们将 runc 替换为 crun。</p>
<pre><code class="language-Dockerfile">FROM ubuntu:21.10 AS builder
WORKDIR /data
RUN DEBIAN_FRONTEND=noninteractive apt update \
    &amp;&amp; DEBIAN_FRONTEND=noninteractive apt install -y curl make git gcc build-essential pkgconf libtool libsystemd-dev libprotobuf-c-dev libcap-dev libseccomp-dev libyajl-dev go-md2man libtool autoconf python3 automake \
    &amp;&amp; curl https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/utils/install.sh | bash -s -- -p /usr/local \
    &amp;&amp; git clone --single-branch --branch feat/handler_per_container https://github.com/liquid-reply/crun \
    &amp;&amp; cd crun \
    &amp;&amp; ./autogen.sh \
    &amp;&amp; ./configure --with-wasmedge --enable-embedded-yajl\
    &amp;&amp; make 

...
</code></pre>
<p>现在我们在 <code>/data/crun/crun</code> 目录下有了一个新的可以支持 wasmedge 的 <code>crun</code> 二进制文件，我们可以在下一步中从这个容器中复制它。</p>
<h2 id="替代-crun-和配置-containerd"><a class="header" href="#替代-crun-和配置-containerd">替代 crun 和配置 containerd</a></h2>
<p>runc 和 crun 都实现了 OCI 运行时规范，并且它们具有相同的 CLI 参数。因此我们可以用之前创建的 crun-wasmedge 二进制文件替换 runc 二进制文件。</p>
<p>由于 crun 使用了一些共享库，我们需要安装 libyajl、wasmedge 和 criu 来使 crun 工作。</p>
<p>现在我们已经有了一个使用 crun 而不是 runc 的 KinD。现在我们只需要将两个配置更改即可。第一个是在 <code>/etc/containerd/config.toml</code> 中，我们添加了可以传递给运行时的 <code>pod_annotations</code>：</p>
<pre><code class="language-toml">[plugins.&quot;io.containerd.grpc.v1.cri&quot;.containerd.runtimes.runc]
  pod_annotations = [&quot;*.wasm.*&quot;, &quot;wasm.*&quot;, &quot;module.wasm.image/*&quot;, &quot;*.module.wasm.image&quot;, &quot;module.wasm.image/variant.*&quot;]
</code></pre>
<p>第二个是在 <code>/etc/containerd/cri-base.json</code> 中，我们删除了一个导致一些问题的 hook。</p>
<p>生成的 dockerfile 如下所示：</p>
<pre><code class="language-Dockerfile">...

FROM kindest/node:v1.23.0

COPY config.toml /etc/containerd/config.toml
COPY --from=builder /data/crun/crun /usr/local/sbin/runc
COPY --from=builder /usr/local/lib/libwasmedge.so /usr/local/lib/libwasmedge.so

RUN echo &quot;Installing Packages ...&quot; \
    &amp;&amp; bash -c 'cat &lt;&lt;&lt; $(jq &quot;del(.hooks.createContainer)&quot; /etc/containerd/cri-base.json) &gt; /etc/containerd/cri-base.json' \
    &amp;&amp; ldconfig
</code></pre>
<h2 id="编译和测试"><a class="header" href="#编译和测试">编译和测试</a></h2>
<p>最终我们构建了一个新的 <code>node-wasmedge</code> 镜像。为了测试它，我们从该图像创建一个 kind 集群并运行简单的应用程序示例。</p>
<pre><code class="language-bash">$ docker build -t node-wasmedge .
$ kind create cluster --image node-wasmedge
# Now you can run the example to validate your cluster
$ kubectl run -it --rm --restart=Never wasi-demo --image=hydai/wasm-wasi-example:with-wasm-annotation --annotations=&quot;module.wasm.image/variant=compat-smart&quot; /wasi_example_main.wasm 50000000
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="为-kubeedge-创建一个-crun-示例"><a class="header" href="#为-kubeedge-创建一个-crun-示例">为 KubeEdge 创建一个 <code>crun</code> 示例</a></h1>
<h2 id="1-云端设置kubeedge-主节点"><a class="header" href="#1-云端设置kubeedge-主节点">1. 云端设置（KubeEdge 主节点）</a></h2>
<h3 id="安装-go"><a class="header" href="#安装-go">安装 Go</a></h3>
<pre><code class="language-bash">$ wget https://golang.org/dl/go1.17.3.linux-amd64.tar.gz
$ tar xzvf go1.17.3.linux-amd64.tar.gz

$ export PATH=/home/${user}/go/bin:$PATH
$ go version
go version go1.17.3 linux/amd64
</code></pre>
<h3 id="安装-cri-o-1"><a class="header" href="#安装-cri-o-1">安装 CRI-O</a></h3>
<p>请参阅 <a href="https://github.com/cri-o/cri-o/blob/main/install.md#install-packaged-versions-of-cri-o">CRI-O Installation Instructions</a>.</p>
<pre><code class="language-bash"># 创建 .conf 文件以在启动时加载模块
$ cat &lt;&lt;EOF | sudo tee /etc/modules-load.d/crio.conf
overlay
br_netfilter
EOF

$ sudo modprobe overlay
$ sudo modprobe br_netfilter

# 设置所需的 sysctl 参数，这些参数在重启后仍然存在。
$ cat &lt;&lt;EOF | sudo tee /etc/sysctl.d/99-kubernetes-cri.conf
net.bridge.bridge-nf-call-iptables  = 1
net.ipv4.ip_forward                 = 1
net.bridge.bridge-nf-call-ip6tables = 1
EOF

$ sudo sysctl --system
$ export OS=&quot;xUbuntu_20.04&quot;
$ export VERSION=&quot;1.21&quot;
$ cat &lt;&lt;EOF | sudo tee /etc/apt/sources.list.d/devel:kubic:libcontainers:stable.list
deb https://download.opensuse.org/repositories/devel:/kubic:/libcontainers:/stable/$OS/ /
EOF
$ cat &lt;&lt;EOF | sudo tee /etc/apt/sources.list.d/devel:kubic:libcontainers:stable:cri-o:$VERSION.list
deb http://download.opensuse.org/repositories/devel:/kubic:/libcontainers:/stable:/cri-o:/$VERSION/$OS/ /
EOF

$ curl -L https://download.opensuse.org/repositories/devel:/kubic:/libcontainers:/stable/$OS/Release.key | sudo apt-key --keyring /etc/apt/trusted.gpg.d/libcontainers.gpg add -
$ curl -L https://download.opensuse.org/repositories/devel:kubic:libcontainers:stable:cri-o:$VERSION/$OS/Release.key | sudo apt-key --keyring /etc/apt/trusted.gpg.d/libcontainers-cri-o.gpg add -

$ sudo apt-get update
$ sudo apt-get install cri-o cri-o-runc

$ sudo systemctl daemon-reload
$ sudo systemctl enable crio --now
$ sudo systemctl status cri-o
</code></pre>
<p>输出：</p>
<pre><code class="language-bash">$ sudo systemctl status cri-o
● crio.service - Container Runtime Interface for OCI (CRI-O)
     Loaded: loaded (/lib/systemd/system/crio.service; enabled; vendor preset: enabled)
     Active: active (running) since Mon 2021-12-06 13:46:29 UTC; 16h ago
       Docs: https://github.com/cri-o/cri-o
   Main PID: 6868 (crio)
      Tasks: 14
     Memory: 133.2M
     CGroup: /system.slice/crio.service
             └─6868 /usr/bin/crio

Dec 07 06:04:13 master crio[6868]: time=&quot;2021-12-07 06:04:13.694226800Z&quot; level=info msg=&quot;Checking image status: k8s.gcr.io/pause:3.4.1&quot; id=1dbb722e-f031-410c-9f45-5d4b5760163e name=/runtime.v1alpha2.ImageServic&gt;
Dec 07 06:04:13 master crio[6868]: time=&quot;2021-12-07 06:04:13.695739507Z&quot; level=info msg=&quot;Image status: &amp;{0xc00047fdc0 map[]}&quot; id=1dbb722e-f031-410c-9f45-5d4b5760163e name=/runtime.v1alpha2.ImageService/ImageSta&gt;
Dec 07 06:09:13 master crio[6868]: time=&quot;2021-12-07 06:09:13.698823984Z&quot; level=info msg=&quot;Checking image status: k8s.gcr.io/pause:3.4.1&quot; id=661b754b-48a4-401b-a03f-7f7a553c7eb6 name=/runtime.v1alpha2.ImageServic&gt;
Dec 07 06:09:13 master crio[6868]: time=&quot;2021-12-07 06:09:13.703259157Z&quot; level=info msg=&quot;Image status: &amp;{0xc0004d98f0 map[]}&quot; id=661b754b-48a4-401b-a03f-7f7a553c7eb6 name=/runtime.v1alpha2.ImageService/ImageSta&gt;
Dec 07 06:14:13 master crio[6868]: time=&quot;2021-12-07 06:14:13.707778419Z&quot; level=info msg=&quot;Checking image status: k8s.gcr.io/pause:3.4.1&quot; id=8c7e4d36-871a-452e-ab55-707053604077 name=/runtime.v1alpha2.ImageServic&gt;
Dec 07 06:14:13 master crio[6868]: time=&quot;2021-12-07 06:14:13.709379469Z&quot; level=info msg=&quot;Image status: &amp;{0xc000035030 map[]}&quot; id=8c7e4d36-871a-452e-ab55-707053604077 name=/runtime.v1alpha2.ImageService/ImageSta&gt;
Dec 07 06:19:13 master crio[6868]: time=&quot;2021-12-07 06:19:13.713158978Z&quot; level=info msg=&quot;Checking image status: k8s.gcr.io/pause:3.4.1&quot; id=827b6315-f145-4f76-b8da-31653d5892a2 name=/runtime.v1alpha2.ImageServic&gt;
Dec 07 06:19:13 master crio[6868]: time=&quot;2021-12-07 06:19:13.714030148Z&quot; level=info msg=&quot;Image status: &amp;{0xc000162bd0 map[]}&quot; id=827b6315-f145-4f76-b8da-31653d5892a2 name=/runtime.v1alpha2.ImageService/ImageSta&gt;
Dec 07 06:24:13 master crio[6868]: time=&quot;2021-12-07 06:24:13.716746612Z&quot; level=info msg=&quot;Checking image status: k8s.gcr.io/pause:3.4.1&quot; id=1d53a917-4d98-4723-9ea8-a2951a472cff name=/runtime.v1alpha2.ImageServic&gt;
Dec 07 06:24:13 master crio[6868]: time=&quot;2021-12-07 06:24:13.717381882Z&quot; level=info msg=&quot;Image status: &amp;{0xc00042ce00 map[]}&quot; id=1d53a917-4d98-4723-9ea8-a2951a472cff name=/runtime.v1alpha2.ImageService/ImageSta&gt;
</code></pre>
<h3 id="使用-k8s-kubeadm-安装和创建集群"><a class="header" href="#使用-k8s-kubeadm-安装和创建集群">使用 K8s Kubeadm 安装和创建集群</a></h3>
<p>请参阅 <a href="https://kubernetes.io/zh/docs/setup/production-environment/tools/kubeadm/create-cluster-kubeadm/">使用 kubeadm 创建集群</a>.</p>
<h4 id="安装-k8s"><a class="header" href="#安装-k8s">安装 K8s</a></h4>
<pre><code class="language-bash">sudo apt-get update
sudo apt-get install -y apt-transport-https curl
echo &quot;deb [signed-by=/usr/share/keyrings/kubernetes-archive-keyring.gpg] https://apt.kubernetes.io/ kubernetes-xenial main&quot; | sudo tee /etc/apt/sources.list.d/kubernetes.list

sudo apt update
K_VER=&quot;1.21.0-00&quot;
sudo apt install -y kubelet=${K_VER} kubectl=${K_VER} kubeadm=${K_VER}
sudo apt-mark hold kubelet kubeadm kubectl
</code></pre>
<h4 id="使用-kubeadm-创建集群"><a class="header" href="#使用-kubeadm-创建集群">使用 kubeadm 创建集群</a></h4>
<pre><code class="language-bash"># kubernetes 调度程序需要进行此设置。
$ sudo swapoff -a
$ sudo vim /etc/fstab
mark contain swapfile of row

$ cat /etc/cni/net.d/100-crio-bridge.conf
{
    &quot;cniVersion&quot;: &quot;0.3.1&quot;,
    &quot;name&quot;: &quot;crio&quot;,
    &quot;type&quot;: &quot;bridge&quot;,
    &quot;bridge&quot;: &quot;cni0&quot;,
    &quot;isGateway&quot;: true,
    &quot;ipMasq&quot;: true,
    &quot;hairpinMode&quot;: true,
    &quot;ipam&quot;: {
        &quot;type&quot;: &quot;host-local&quot;,
        &quot;routes&quot;: [
            { &quot;dst&quot;: &quot;0.0.0.0/0&quot; },
            { &quot;dst&quot;: &quot;1100:200::1/24&quot; }
        ],
        &quot;ranges&quot;: [
            [{ &quot;subnet&quot;: &quot;10.85.0.0/16&quot; }],
            [{ &quot;subnet&quot;: &quot;1100:200::/24&quot; }]
        ]
    }
}
$ export CIDR=10.85.0.0/16
$ sudo kubeadm init --apiserver-advertise-address=192.168.122.160 --pod-network-cidr=$CIDR --cri-socket=/var/run/crio/crio.sock

$ mkdir -p $HOME/.kube
$ sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config
$ sudo chown $(id -u):$(id -g) $HOME/.kube/config
</code></pre>
<p>输出：</p>
<pre><code class="language-bash">Your Kubernetes control-plane has initialized successfully!

To start using your cluster, you need to run the following as a regular user:

  mkdir -p $HOME/.kube
  sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config
  sudo chown $(id -u):$(id -g) $HOME/.kube/config

You should now deploy a Pod network to the cluster.
Run &quot;kubectl apply -f [podnetwork].yaml&quot; with one of the options listed at:
  /docs/concepts/cluster-administration/addons/

You can now join any number of machines by running the following on each node
as root:

  kubeadm join &lt;control-plane-host&gt;:&lt;control-plane-port&gt; --token &lt;token&gt; --discovery-token-ca-cert-hash sha256:&lt;hash&gt;
</code></pre>
<p>要让 kubectl 为你的非 root 用户工作，请运行这些命令，这些命令也是 kubeadm init 输出的一部分：</p>
<pre><code class="language-bash">mkdir -p $HOME/.kube
sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config
sudo chown $(id -u):$(id -g) $HOME/.kube/config
</code></pre>
<h3 id="设置-kubeedge-主节点"><a class="header" href="#设置-kubeedge-主节点">设置 KubeEdge 主节点</a></h3>
<p>请参阅 <a href="https://kubeedge.io/zh/docs/setup/keadm/">使用 Keadm 进行部署</a>。</p>
<p>重要提醒:</p>
<ol>
<li>kubeconfig 或 master 中的至少一项必须配置正确，才能用于验证 k8s 集群的版本等信息。</li>
<li>请确保边缘节点可以使用云节点的本地 IP 连接云节点，或者你需要使用 <code>--advertise-address</code> 标志指定云节点的公共 IP。</li>
<li><code>--advertise-address</code>（仅 1.3 版本起有效）为云端公开的地址（将添加到 CloudCore 证书的 SAN 中），默认值为本地IP。</li>
</ol>
<pre><code class="language-bash">wget https://github.com/kubeedge/kubeedge/releases/download/v1.8.0/keadm-v1.8.0-linux-amd64.tar.gz
tar xzvf keadm-v1.8.0-linux-amd64.tar.gz
cd keadm-v1.8.0-linux-amd64/keadm/
sudo ./keadm init --advertise-address=192.168.122.160 --kube-config=/home/${user}/.kube/config
</code></pre>
<p>输出：</p>
<pre><code class="language-bash">Kubernetes version verification passed, KubeEdge installation will start...
...
KubeEdge cloudcore is running, For logs visit:  /var/log/kubeedge/cloudcore.log
</code></pre>
<h2 id="2-设置边缘端kubeedge-工作节点"><a class="header" href="#2-设置边缘端kubeedge-工作节点">2. 设置边缘端（KubeEdge 工作节点）</a></h2>
<p>你可以使用 CRI-O install.sh 脚本 <code>crun</code> 在 Ubuntu 20.04 上安装 CRI-O。</p>
<pre><code class="language-bash">wget -qO- https://raw.githubusercontent.com/second-state/wasmedge-containers-examples/main/crio/install.sh | bash
</code></pre>
<h3 id="在工作节点安装-go"><a class="header" href="#在工作节点安装-go">在工作节点安装 Go</a></h3>
<pre><code class="language-bash">$ wget https://golang.org/dl/go1.17.3.linux-amd64.tar.gz
$ tar xzvf go1.17.3.linux-amd64.tar.gz

$ export PATH=/home/${user}/go/bin:$PATH
$ go version
go version go1.17.3 linux/amd64
</code></pre>
<h3 id="从云端获取令牌"><a class="header" href="#从云端获取令牌">从云端获取令牌</a></h3>
<p>在云端运行 <code>keadm gettoken</code> 会返回 token ，在加入边缘节点时使用。</p>
<pre><code class="language-bash">$ sudo ./keadm gettoken --kube-config=/home/${user}/.kube/config
27a37ef16159f7d3be8fae95d588b79b3adaaf92727b72659eb89758c66ffda2.eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJleHAiOjE1OTAyMTYwNzd9.JBj8LLYWXwbbvHKffJBpPd5CyxqapRQYDIXtFZErgYE
</code></pre>
<h3 id="下载-kubeedge-并加入边缘节点"><a class="header" href="#下载-kubeedge-并加入边缘节点">下载 Kubeedge 并加入边缘节点</a></h3>
<p>请参阅 <a href="https://kubeedge.io/zh/docs/advanced/cri/#cri-o">使用 CRI 设置不同的容器运行时</a> 和 <a href="https://kubeedge.io/zh/docs/setup/keadm/">使用 Keadm 部署</a>.</p>
<pre><code class="language-bash">$ wget https://github.com/kubeedge/kubeedge/releases/download/v1.8.0/keadm-v1.8.0-linux-amd64.tar.gz
$ tar xzvf keadm-v1.8.0-linux-amd64.tar.gz
$ cd keadm-v1.8.0-linux-amd64/keadm/

$ sudo ./keadm join \
--cloudcore-ipport=192.168.122.160:10000 \
--edgenode-name=edge \
--token=b4550d45b773c0480446277eed1358dcd8a02a0c214646a8082d775f9c447d81.eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJleHAiOjE2Mzg4ODUzNzd9.A9WOYJFrgL2swVGnydpb4gMojyvyoNPCXaA4rXGowqU \
--remote-runtime-endpoint=unix:///var/run/crio/crio.sock \
--runtimetype=remote \
--cgroupdriver=systemd
</code></pre>
<p>输出：</p>
<pre><code class="language-bash">Host has mosquit+ already installed and running. Hence skipping the installation steps !!!
...
KubeEdge edgecore is running, For logs visit:  /var/log/kubeedge/edgecore.log
</code></pre>
<h3 id="从云端获取边缘节点状态"><a class="header" href="#从云端获取边缘节点状态">从云端获取边缘节点状态</a></h3>
<p>输出：</p>
<pre><code class="language-bash">kubectl get node
NAME       STATUS    ROLES                  AGE   VERSION
edge       Ready     agent,edge             10s   v1.19.3-kubeedge-v1.8.2
master     Ready     control-plane,master   68m   v1.21.0
</code></pre>
<h2 id="3-启用-kubectl-日志功能"><a class="header" href="#3-启用-kubectl-日志功能">3. 启用 kubectl 日志功能</a></h2>
<p>在部署 metrics-server 之前，必须激活 kubectl 日志功能，请<a href="https://kubeedge.io/zh/docs/setup/keadm/#enable-kubectl-logs-feature">参阅这里</a>.</p>
<h2 id="4-运行一个简单的-webassembly-应用"><a class="header" href="#4-运行一个简单的-webassembly-应用">4. 运行一个简单的 WebAssembly 应用</a></h2>
<p>我们可以从 Kubernetes 集群中的 Docker Hub 运行基于 WebAssembly 的镜像。</p>
<h3 id="云端"><a class="header" href="#云端">云端</a></h3>
<pre><code class="language-bash">$ kubectl run -it --restart=Never wasi-demo --image=hydai/wasm-wasi-example:with-wasm-annotation --annotations=&quot;module.wasm.image/variant=compat-smart&quot; /wasi_example_main.wasm 50000000

Random number: -1694733782
Random bytes: [6, 226, 176, 126, 136, 114, 90, 2, 216, 17, 241, 217, 143, 189, 123, 197, 17, 60, 49, 37, 71, 69, 67, 108, 66, 39, 105, 9, 6, 72, 232, 238, 102, 5, 148, 243, 249, 183, 52, 228, 54, 176, 63, 249, 216, 217, 46, 74, 88, 204, 130, 191, 182, 19, 118, 193, 77, 35, 189, 6, 139, 68, 163, 214, 231, 100, 138, 246, 185, 47, 37, 49, 3, 7, 176, 97, 68, 124, 20, 235, 145, 166, 142, 159, 114, 163, 186, 46, 161, 144, 191, 211, 69, 19, 179, 241, 8, 207, 8, 112, 80, 170, 33, 51, 251, 33, 105, 0, 178, 175, 129, 225, 112, 126, 102, 219, 106, 77, 242, 104, 198, 238, 193, 247, 23, 47, 22, 29]
Printed from wasi: This is from a main function
This is from a main function
The env vars are as follows.
The args are as follows.
/wasi_example_main.wasm
50000000
File content is This is in a file
</code></pre>
<p>WebAssembly 应用的 pod 成功部署到边缘节点。</p>
<pre><code class="language-bash">$ kubectl describe pod wasi-demo

Name:         wasi-demo
Namespace:    default
Priority:     0
Node:         edge/192.168.122.229
Start Time:   Mon, 06 Dec 2021 15:45:34 +0000
Labels:       run=wasi-demo
Annotations:  module.wasm.image/variant: compat-smart
Status:       Succeeded
IP:           
IPs:          &lt;none&gt;
Containers:
  wasi-demo:
    Container ID:  cri-o://1ae4d0d7f671050331a17e9b61b5436bf97ad35ad0358bef043ab820aed81069
    Image:         hydai/wasm-wasi-example:with-wasm-annotation
    Image ID:      docker.io/hydai/wasm-wasi-example@sha256:525aab8d6ae8a317fd3e83cdac14b7883b92321c7bec72a545edf276bb2100d6
    Port:          &lt;none&gt;
    Host Port:     &lt;none&gt;
    Args:
      /wasi_example_main.wasm
      50000000
    State:          Terminated
      Reason:       Completed
      Exit Code:    0
      Started:      Mon, 06 Dec 2021 15:45:33 +0000
      Finished:     Mon, 06 Dec 2021 15:45:33 +0000
    Ready:          False
    Restart Count:  0
    Environment:    &lt;none&gt;
    Mounts:
      /var/run/secrets/kubernetes.io/serviceaccount from kube-api-access-bhszr (ro)
Conditions:
  Type           Status
  Initialized    True 
  Ready          False 
  PodScheduled   True 
Volumes:
  kube-api-access-bhszr:
    Type:                    Projected (a volume that contains injected data from multiple sources)
    TokenExpirationSeconds:  3607
    ConfigMapName:           kube-root-ca.crt
    ConfigMapOptional:       &lt;nil&gt;
    DownwardAPI:             true
QoS Class:                   BestEffort
Node-Selectors:              &lt;none&gt;
Tolerations:                 node.kubernetes.io/not-ready:NoExecute op=Exists for 300s
                             node.kubernetes.io/unreachable:NoExecute op=Exists for 300s
Events:
  Type    Reason     Age   From               Message
  ----    ------     ----  ----               -------
</code></pre>
<h3 id="边缘端"><a class="header" href="#边缘端">边缘端</a></h3>
<pre><code class="language-bash">$ sudo crictl ps -a
CONTAINER           IMAGE                                                                                           CREATED             STATE               NAME                ATTEMPT             POD ID
1ae4d0d7f6710       0423b8eb71e312b8aaa09a0f0b6976381ff567d5b1e5729bf9b9aa87bff1c9f3                                16 minutes ago      Exited              wasi-demo           0                   2bc2ac0c32eda
1e6c7cb6bc731       k8s.gcr.io/kube-proxy@sha256:2a25285ff19f9b4025c8e54dac42bb3cd9aceadc361f2570489b8d723cb77135   18 minutes ago      Running             kube-proxy          0                   8b7e7388ad866
</code></pre>
<p>就是这样。</p>
<h2 id="5-运行示例的录屏"><a class="header" href="#5-运行示例的录屏">5. 运行示例的录屏</a></h2>
<p><a href="https://asciinema.org/a/wkLOu6xnAOSAQdmYayumwrAvh"><img src="https://asciinema.org/a/wkLOu6xnAOSAQdmYayumwrAvh.svg" alt="asciicast" /></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="superedge"><a class="header" href="#superedge">SuperEdge</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="openyurt--containerd--crun"><a class="header" href="#openyurt--containerd--crun">OpenYurt + containerd + crun</a></h1>
<p>在这篇文章中，我们将介绍如何在 <a href="https://github.com/openyurtio/openyurt">OpenYurt</a>  边缘计算框架下，使用 containerd 去运行一个简单的 WasmEdge 的 demo</p>
<h2 id="搭建一个-openyurt-集群"><a class="header" href="#搭建一个-openyurt-集群">搭建一个 OpenYurt 集群</a></h2>
<p>这里，我们介绍两种不同的方式来搭建一个 OpenYurt 集群。
第一个是从零开始搭建，先搭建出一个 kubernetes 集群，然后使用 <code>yurtctl convert</code> 将
这个 kubernetes 集群转化为 OpenYurt 集群；
第二个是使用 <a href="https://openyurt.io/docs/installation/openyurt-experience-center/overview">OpenYurt 体验中心</a>   提供的能力，即只要在 OpenYurt 体验中心注册一个账户，即可拥有一个 OpenYurt 集群，如果需要接入新的节点到 OpenYurt 集群中，只需要使用
<code>yurtctl join</code> 命令加入节点。</p>
<h3 id="前置准备"><a class="header" href="#前置准备">前置准备</a></h3>
<div class="table-wrapper"><table><thead><tr><th></th><th>OS/kernel</th><th>私网IP/ 公网IP</th></tr></thead><tbody>
<tr><td>Master</td><td>Ubuntu  20.04.3 LTS/5.4.0-91-generic</td><td>192.168.3.169/120.55.126.18</td></tr>
<tr><td>Node</td><td>Ubuntu  20.04.3 LTS/5.4.0-91-generic</td><td>192.168.3.170/121.43.113.152</td></tr>
</tbody></table>
</div>
<p>由于操作系统的不同，下面的步骤可能有一些微小的变动，主要是关于 <a href="https://github.com/openyurtio/openyurt">OpenYurt</a>  和 <a href="https://github.com/containers/crun">crun</a>  的安装。</p>
<p>因为我们使用 <code>yurtctl convert</code> 命令将 K8s 集群转化成 OpenYurt 集群，因此我们应该首先搭建一个 kubernetes 集群。当然， OpenYurt 也提供了一个简单的方法， <code>yurtctl init/join</code> 可以允许我们不搭建 kubernetes 集群，直接创建一个 OpenYurt 集群出来。
更多关于 <code>yurtctl convert/revert</code> 的介绍可以参考文章<a href="https://openyurt.io/docs/installation/yurtctl-convert-revert">Conversion between OpenYurt and Kubernetes:<code>yurtctl convert/revert</code></a> ，
而关于 <code>yurtctl init/join</code> 的介绍可以参考文章 <a href="https://openyurt.io/docs/installation/yurtctl-init-join">how use <code>Yurtctl init/join</code></a></p>
<ul>
<li>关闭节点 swap 分区</li>
</ul>
<pre><code class="language-bash">sudo swapoff -a
//verify    
free -m
</code></pre>
<ul>
<li>配置节点 IP 与 DNS 映射</li>
</ul>
<pre><code class="language-bash">192.168.3.169  oy-master 
120.55.126.18  oy-master
92.168.3.170   oy-node
121.43.113.152 oy-node
</code></pre>
<ul>
<li>加载内核模块 br_netfilter</li>
</ul>
<pre><code class="language-bash">sudo modprobe br_netfilter     
lsmod | grep br_netfilter    //确认加载
</code></pre>
<ul>
<li>调整内核参数，创建 k8s.conf</li>
</ul>
<pre><code class="language-bash">cat &lt;&lt;EOF | sudo tee /etc/sysctl.d/k8s.conf
net.bridge.bridge-nf-call-ip6tables = 1
net.bridge.bridge-nf-call-iptables = 1
EOF
sudo sysctl --system
</code></pre>
<ul>
<li>设置 rp-filter 值，将文件 /etc/sysctl.d/10-network-security.conf 中两个参数的值由2改为1，且将 /proc/sys/net/ipv4/ip_forward 设置为1</li>
</ul>
<pre><code class="language-bash">sudo vi /etc/sysctl.d/10-network-security.conf
echo 1 &gt; /proc/sys/net/ipv4/ip_forward
sudo sysctl --system
</code></pre>
<h4 id="安装-containerd-1"><a class="header" href="#安装-containerd-1">安装 containerd</a></h4>
<ul>
<li>安装 containerd</li>
</ul>
<pre><code class="language-bash">export VERSION=&quot;1.5.7&quot;
echo -e &quot;Version: $VERSION&quot;
echo -e &quot;Installing libseccomp2 ...&quot;
sudo apt install -y libseccomp2
echo -e &quot;Installing wget&quot;
sudo apt install -y wget

wget https://github.com/containerd/containerd/releases/download/v${VERSION}/cri-containerd-cni-${VERSION}-linux-amd64.tar.gz
wget https://github.com/containerd/containerd/releases/download/v${VERSION}/cri-containerd-cni-${VERSION}-linux-amd64.tar.gz.sha256sum
sha256sum --check cri-containerd-cni-${VERSION}-linux-amd64.tar.gz.sha256sum

sudo tar --no-overwrite-dir -C / -xzf cri-containerd-cni-${VERSION}-linux-amd64.tar.gz
sudo systemctl daemon-reload
</code></pre>
<ul>
<li>配置 containerd 文件 /etc/containerd/config.toml，修改 plugin 中参数，将其中的 runc 改为 crun，添加 pod_annotation</li>
</ul>
<pre><code class="language-bash">udo mkdir -p /etc/containerd/
sudo bash -c &quot;containerd config default &gt; /etc/containerd/config.toml&quot;
wget https://raw.githubusercontent.com/second-state/wasmedge-containers-examples/main/containerd/containerd_config.diff
sudo patch -d/ -p0 &lt; containerd_config.diff
</code></pre>
<ul>
<li>重启 containerd 服务：</li>
</ul>
<pre><code class="language-bash">systemctl start containerd
</code></pre>
<h4 id="安装-wasmedge"><a class="header" href="#安装-wasmedge">安装 WasmEdge</a></h4>
<p>使用 WasmEdge 提供的<a href="https://wasmedge.org/book/en/start/install.html">安装脚本</a> 在你的边缘节点上安装 WasmEdge</p>
<pre><code class="language-bash">curl -sSf https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/utils/install.sh | bash
</code></pre>
<h4 id="编译安装-crun"><a class="header" href="#编译安装-crun">编译、安装 crun</a></h4>
<p>我们需要一个在边缘节点支持 WasmEdge 的 crun 二进制文件。最直接的方法就是自己从源码编译。首先，需要确保在 ubuntu 系统上安装 crun 依赖。对于其他的 Linux 发行版，请参考<a href="https://github.com/containers/crun#readme">文章</a></p>
<ul>
<li>编译需要的依赖</li>
</ul>
<pre><code class="language-bash">sudo apt update
sudo apt install -y make git gcc build-essential pkgconf libtool \
  libsystemd-dev libprotobuf-c-dev libcap-dev libseccomp-dev libyajl-dev \
  go-md2man libtool autoconf python3 automake
</code></pre>
<ul>
<li>配置、编译、安装支持 WasmEdge 的 crun</li>
</ul>
<pre><code class="language-bash">it clone https://github.com/containers/crun
cd crun
./autogen.sh
./configure --with-wasmedge
make
sudo make install
</code></pre>
<h3 id="从零搭建一个-openyurt-集群"><a class="header" href="#从零搭建一个-openyurt-集群">从零搭建一个 OpenYurt 集群</a></h3>
<p>在这个 demo 中，我们使用两台虚拟机来搭建 OpenYurt 集群，一台模拟云端节点 Master，一台模拟边缘节点 Node，由这样两个节点构成最简单的 OpenYurt 集群系统。</p>
<h4 id="搭建一个-kubernetes-集群"><a class="header" href="#搭建一个-kubernetes-集群">搭建一个 kubernetes 集群</a></h4>
<pre><code class="language-bash">$ sudo apt-get update &amp;&amp; sudo apt-get install -y ca-certificates curl software-properties-common apt-transport-https
// add K8s source
$ curl -s https://mirrors.aliyun.com/kubernetes/apt/doc/apt-key.gpg | sudo apt-key add -
$ sudo tee /etc/apt/sources.list.d/kubernetes.list &lt;&lt;EOF
$ deb https://mirrors.aliyun.com/kubernetes/apt/ kubernetes-xenial main
// install K8s components 1.18.9
$ sudo apt-get update &amp;&amp; sudo apt-get install -y kubelet=1.18.9-00 kubeadm=1.18.9-00 kubectl=1.18.9-00 
// Initialize the master node
$ sudo kubeadm init --pod-network-cidr 172.16.0.0/16 \
--apiserver-advertise-address=192.168.3.167 \
--image-repository registry.cn-hangzhou.aliyuncs.com/google_containers
// join the work node
$ kubeadm join 192.168.3.167:6443 --token 3zefbt.99e6denc1cxpk9fg \
   --discovery-token-ca-cert-hash sha256:8077d4e7dd6eee64a999d56866ae4336073ed5ffc3f23281d757276b08b9b195
</code></pre>
<h4 id="安装-yurtctl"><a class="header" href="#安装-yurtctl">安装 yurtctl</a></h4>
<p>使用下面命令来安装 yurtctl，借助 yurtctl 命令行工具，我们可以安装/卸载 OpenYurt 集群，也可以用于在 kubernetes 集群和 OpenYurt 集群转化。</p>
<pre><code class="language-bash">git clone https://github.com/openyurtio/openyurt.git
cd openyurt
make build WHAT=cmd/yurtctl
</code></pre>
<h4 id="安装-openyurt-组件"><a class="header" href="#安装-openyurt-组件">安装 OpenYurt 组件</a></h4>
<p>OpenYurt 包括多个组件。YurtHub 是节点和 kube-apiserver 之间的流量代理，边缘节点上部署的 YurtHub 能够缓存来自云端的数据信息。
Yurt controller 是对上游节点控制器的补充，以支持边缘计算需求。TunnelServer 通过反向代理与运行在每个
边缘节点上的 TunnelAgent 守护进程连接，以在云端节点控制平面和连接到内网的边缘节点之间建立安全的网络访问。
更详细的信息可以参考 <a href="https://github.com/openyurtio/openyurt">OpenYurt Docs</a></p>
<pre><code class="language-bash">yurtctl convert --deploy-yurttunnel --cloud-nodes oy-master --provider kubeadm\
--yurt-controller-manager-image=&quot;openyurt/yurt-controller-manager:v0.5.0&quot;\
--yurt-tunnel-agent-image=&quot;openyurt/yurt-tunnel-agent:v0.5.0&quot;\
--yurt-tunnel-server-image=&quot;openyurt/yurt-tunnel-server:v0.5.0&quot;\
--node-servant-image=&quot;openyurt/node-servant:latest&quot;\
--yurthub-image=&quot;openyurt/yurthub:v0.5.0&quot;
</code></pre>
<p>实际上，我们更推荐安装 OpenYurt0.6.0 版本，而且已经验证通过。关于如何安装该版本，可以参考<a href="https://github.com/openyurtio/openyurt/releases/tag/v0.6.0">文章</a></p>
<h3 id="利用-openyurt-体验中心快速搭建一个-openyurt-集群"><a class="header" href="#利用-openyurt-体验中心快速搭建一个-openyurt-集群">利用 OpenYurt 体验中心快速搭建一个 OpenYurt 集群</a></h3>
<p>下面，我们将介绍一种快速搭建 OpenYurt 集群的方法，你只需要在 OpenYurt 体验中心注册一个账户，就可以拥有一个 OpenYurt 集群。如果你想接入一个边缘节点到你创建的 OpenYurt 集群中，
根据提示使用 <code>yurtctl join</code> 命令即可。更多关于 OpenYurt 体验中心的介绍，可以参考<a href="https://github.com/openyurtio/openyurt/releases/tag/v0.6.0">文章</a></p>
<h2 id="运行一个简单的-webassembly-应用"><a class="header" href="#运行一个简单的-webassembly-应用">运行一个简单的 WebAssembly 应用</a></h2>
<p>这一部分我们将在 OpenYurt 集群 pod 中的一个容器里运行 WebAssembly 应用。首先我们需要从 Docker Hub 拉取基于 WebAssembly 容器镜像，如果你对如何编译、打包以及发布一个基于
WebAssembly 的容器镜像感兴趣，可以阅读 <a href="https://wasmedge.org/book/en/kubernetes/demo/wasi.html">WasmEdge Book</a></p>
<p>在验证 OpenYurt 上运行 WasmEdge 应用的时候，我们参考了之前关于 <a href="https://wasmedge.org/book/en/kubernetes/kubernetes.html">kubernetes 的验证</a> ，</p>
<p>需要注意的是由于命令 <code>kubectl run</code> 在1.18.9版本上缺少 annotations 参数，我们需要修改命令行的内容。
如果你使用的是 OpenYurt 体验中心，默认情况下搭建的 OpenYurt 的版本是0.6.0，对应的 Kubernetes 版本是1.20.11。</p>
<pre><code class="language-bash">// kubectl 1.18.9
$ sudo kubectl run -it --rm --restart=Never wasi-demo --image=hydai/wasm-wasi-example:with-wasm-annotation  --overrides='{&quot;kind&quot;:&quot;Pod&quot;,&quot;metadata&quot;:{&quot;annotations&quot;:{&quot;module.wasm.image/variant&quot;:&quot;compat-smart&quot;}} , &quot;apiVersion&quot;:&quot;v1&quot;, &quot;spec&quot;: {&quot;hostNetwork&quot;: true}}' /wasi_example_main.wasm 50000000
// kubectl 1.20.11
$ sudo kubectl run -it --rm --restart=Never wasi-demo --image=hydai/wasm-wasi-example:with-wasm-annotation --annotations=&quot;module.wasm.image/variant=compat-smart&quot; --overrides='{&quot;kind&quot;:&quot;Pod&quot;, &quot;apiVersion&quot;:&quot;v1&quot;, &quot;spec&quot;: {&quot;hostNetwork&quot;: true}}' /wasi_example_main.wasm 50000000
</code></pre>
<p>容器化应用的结果将会在控制台上输出，对应不同 Kubernetes 版本，得到的结果都是相同的。</p>
<pre><code class="language-bash">Random number: 1123434661
Random bytes: [25, 169, 202, 211, 22, 29, 128, 133, 168, 185, 114, 161, 48, 154, 56, 54, 99, 5, 229, 161, 225, 47, 85, 133, 90, 61, 156, 86, 3, 14, 10, 69, 185, 225, 226, 181, 141, 67, 44, 121, 157, 98, 247, 148, 201, 248, 236, 190, 217, 245, 131, 68, 124, 28, 193, 143, 215, 32, 184, 50, 71, 92, 148, 35, 180, 112, 125, 12, 152, 111, 32, 30, 86, 15, 107, 225, 39, 30, 178, 215, 182, 113, 216, 137, 98, 189, 72, 68, 107, 246, 108, 210, 148, 191, 28, 40, 233, 200, 222, 132, 247, 207, 239, 32, 79, 238, 18, 62, 67, 114, 186, 6, 212, 215, 31, 13, 53, 138, 97, 169, 28, 183, 235, 221, 218, 81, 84, 235]
Printed from wasi: This is from a main function
This is from a main function
The env vars are as follows.
The args are as follows.
/wasi_example_main.wasm
50000000
File content is This is in a file
pod &quot;wasi-demo&quot; deleted
</code></pre>
<p>我们可以使用如下命令检查 pod 的状态</p>
<pre><code class="language-bash">crictl ps -a
</code></pre>
<p>输出结果如下：</p>
<pre><code class="language-bash">CONTAINER           IMAGE               CREATED             STATE               NAME                 ATTEMPT             POD ID
0c176ed65599a       0423b8eb71e31       8 seconds ago       Exited              wasi-demo  
</code></pre>
<p>至此，在 OpenYurt 上运行一个基于 WasmEdge 应用的简单 demo 已经完成了。如果你在实验的过程中遇到问题或者有一些建议，非常欢迎来到我们项目的 github 上提交 issue，让我们知道你的想法。</p>
<ul>
<li>WasmEdge GitHub repo: <a href="https://github.com/WasmEdge/WasmEdge">https://github.com/WasmEdge/WasmEdge</a></li>
<li>OpenYurt GitHub repo: <a href="https://github.com/openyurtio/openyurt">https://github.com/openyurtio/openyurt</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="knative"><a class="header" href="#knative">Knative</a></h1>
<p>Knative 是一个构建在Kubernetes上的开源serverless架构方案。</p>
<h2 id="快速开始-9"><a class="header" href="#快速开始-9">快速开始</a></h2>
<p>您可以参考文档 <a href="kubernetes/kubernetes/./kubernetes-containerd.html">Kubernetes + containerd</a> 来创建一个Kubernetes集群。但是这个文档中默认容器运行时从runc替换成了crun。它可能不适用于已经创建好的k8s集群。</p>
<p>这篇文档中我们将crun设置位可选的runtimeClass,这样可以无入侵的将Wasm runtime加入到k8s集群。并且我们会部署Knative serving服务，并展示如何创建一个WASM serverless service.</p>
<h2 id="编译crun"><a class="header" href="#编译crun">编译crun</a></h2>
<p>下面代码参考文档 <a href="kubernetes/kubernetes/../container/crun.html">crun</a></p>
<pre><code class="language-bash"># 安装依赖
$ sudo apt update
$ sudo apt install -y make git gcc build-essential pkgconf libtool \
    libsystemd-dev libprotobuf-c-dev libcap-dev libseccomp-dev libyajl-dev \
    go-md2man libtool autoconf python3 automake

# 编译crun
$ git clone https://github.com/containers/crun
$ cd crun
$ ./autogen.sh
$ ./configure --with-wasmedge
$ make
$ sudo make install
</code></pre>
<h2 id="安装和配置containerd"><a class="header" href="#安装和配置containerd">安装和配置containerd</a></h2>
<p>为了使这个教程简单，我们直接使用apt安装containerd，文档在<a href="https://docs.docker.com/engine/install/ubuntu/">document for ubuntu</a>。
安装好containerd后，编辑配置文件/etc/containerd/config.toml</p>
<pre><code class="language-bash">$ cat /etc/containerd/config.toml

# 注释掉下面这一行让cri可以工作
# disabled_plugins = [&quot;cri&quot;]

# 在下面位置添加crun的配置，确保里面的BinaryName等于crun二进制文件的路径
[plugins]
  [plugins.cri]
    [plugins.cri.containerd]
      [plugins.cri.containerd.runtimes]
...
        [plugins.cri.containerd.runtimes.crun]
           runtime_type = &quot;io.containerd.runc.v2&quot;
           pod_annotations = [&quot;*.wasm.*&quot;, &quot;wasm.*&quot;, &quot;module.wasm.image/*&quot;, &quot;*.module.wasm.image&quot;, &quot;module.wasm.image/variant.*&quot;]
           privileged_without_host_devices = false
           [plugins.cri.containerd.runtimes.crun.options]
             BinaryName = &quot;/usr/local/bin/crun&quot;
...

# 重启containerd服务
$ sudo systemctl restart containerd

# 检查crun是否能正常运行WASM文件
$ ctr image pull docker.io/wasmedge/example-wasi:latest
$ ctr run --rm --runc-binary crun --runtime io.containerd.runc.v2 --label module.wasm.image/variant=compat-smart docker.io/wasmedge/example-wasi:latest wasm-example /wasi_example_main.wasm 50000000
Creating POD ...
Random number: -1678124602
Random bytes: [12, 222, 246, 184, 139, 182, 97, 3, 74, 155, 107, 243, 20, 164, 175, 250, 60, 9, 98, 25, 244, 92, 224, 233, 221, 196, 112, 97, 151, 155, 19, 204, 54, 136, 171, 93, 204, 129, 177, 163, 187, 52, 33, 32, 63, 104, 128, 20, 204, 60, 40, 183, 236, 220, 130, 41, 74, 181, 103, 178, 43, 231, 92, 211, 219, 47, 223, 137, 70, 70, 132, 96, 208, 126, 142, 0, 133, 166, 112, 63, 126, 164, 122, 49, 94, 80, 26, 110, 124, 114, 108, 90, 62, 250, 195, 19, 189, 203, 175, 189, 236, 112, 203, 230, 104, 130, 150, 39, 113, 240, 17, 252, 115, 42, 12, 185, 62, 145, 161, 3, 37, 161, 195, 138, 232, 39, 235, 222]
Printed from wasi: This is from a main function
This is from a main function
The env vars are as follows.
The args are as follows.
/wasi_example_main.wasm
50000000
File content is This is in a file
</code></pre>
<h2 id="用kubeadm创建kubernetes集群"><a class="header" href="#用kubeadm创建kubernetes集群">用kubeadm创建kubernetes集群</a></h2>
<p>参考下面文档 <a href="https://kubernetes.io/docs/setup/production-environment/tools/kubeadm/install-kubeadm/">安装kubeadm</a>, <a href="https://kubernetes.io/docs/setup/production-environment/tools/kubeadm/create-cluster-kubeadm/">使用kubeadm创建一个集群</a> and <a href="https://github.com/flannel-io/flannel#deploying-flannel-manually">安装flannel CNI</a>, to create a kubernetes cluster.</p>
<pre><code class="language-bash"># 安装kubeadm
$ sudo apt-get update
$ sudo apt-get install -y apt-transport-https ca-certificates curl
$ sudo curl -fsSLo /usr/share/keyrings/kubernetes-archive-keyring.gpg https://packages.cloud.google.com/apt/doc/apt-key.gpg
$ echo &quot;deb [signed-by=/usr/share/keyrings/kubernetes-archive-keyring.gpg] https://apt.kubernetes.io/ kubernetes-xenial main&quot; | sudo tee /etc/apt/sources.list.d/kubernetes.list
$ sudo apt-get update
$ sudo apt-get install -y kubelet kubeadm kubectl
$ sudo apt-mark hold kubelet kubeadm kubectl

# 创建k8s集群
$ swapoff -a
$ kubeadm init --pod-network-cidr=10.244.0.0/16 --cri-socket unix:///var/run/containerd/containerd.sock

# 安装CNI
$ kubectl apply -f https://raw.githubusercontent.com/flannel-io/flannel/master/Documentation/kube-flannel.yml

# untaint master node
$ kubectl taint nodes --all node-role.kubernetes.io/control-plane-
$ export KUBECONFIG=/etc/kubernetes/admin.conf

# 添加 crun runtimeClass
$ cat &gt; runtime.yaml &lt;&lt;EOF
apiVersion: node.k8s.io/v1
kind: RuntimeClass
metadata:
  name: crun
handler: crun
EOF
$ kubectl apply runtime.yaml

# 验证crun runtimeClass是否可以正常工作
$ kubectl run -it --rm --restart=Never wasi-demo --image=wasmedge/example-wasi:latest --annotations=&quot;module.wasm.image/variant=compat-smart&quot; --overrides='{&quot;kind&quot;:&quot;Pod&quot;, &quot;apiVersion&quot;:&quot;v1&quot;, &quot;spec&quot;: {&quot;hostNetwork&quot;: true, &quot;runtimeClassName&quot;: &quot;crun&quot;}}' /wasi_example_main.wasm 50000000
Random number: 1534679888
Random bytes: [88, 170, 82, 181, 231, 47, 31, 34, 195, 243, 134, 247, 211, 145, 28, 30, 162, 127, 234, 208, 213, 192, 205, 141, 83, 161, 121, 206, 214, 163, 196, 141, 158, 96, 137, 151, 49, 172, 88, 234, 195, 137, 44, 152, 7, 130, 41, 33, 85, 144, 197, 25, 104, 236, 201, 91, 210, 17, 59, 248, 80, 164, 19, 10, 46, 116, 182, 111, 112, 239, 140, 16, 6, 249, 89, 176, 55, 6, 41, 62, 236, 132, 72, 70, 170, 7, 248, 176, 209, 218, 214, 160, 110, 93, 232, 175, 124, 199, 33, 144, 2, 147, 219, 236, 255, 95, 47, 15, 95, 192, 239, 63, 157, 103, 250, 200, 85, 237, 44, 119, 98, 211, 163, 26, 157, 248, 24, 0]
Printed from wasi: This is from a main function
This is from a main function
The env vars are as follows.
The args are as follows.
/wasi_example_main.wasm
50000000
File content is This is in a file
pod &quot;wasi-demo&quot; deleted
</code></pre>
<h2 id="设置knative-serving"><a class="header" href="#设置knative-serving">设置Knative Serving</a></h2>
<p>参考下面文档<a href="https://knative.dev/docs/install/yaml-install/serving/install-serving-with-yaml/">Installing Knative Serving using YAML files</a>。</p>
<pre><code class="language-bash"># 安装Knative Serving相关组件
$ kubectl apply -f https://github.com/knative/serving/releases/download/knative-v1.7.2/serving-crds.yaml
$ kubectl apply -f https://github.com/knative/serving/releases/download/knative-v1.7.2/serving-core.yaml

# 安装网络层
$ kubectl apply -f https://github.com/knative/net-kourier/releases/download/knative-v1.7.0/kourier.yaml
$ kubectl patch configmap/config-network \
  --namespace knative-serving \
  --type merge \
  --patch '{&quot;data&quot;:{&quot;ingress-class&quot;:&quot;kourier.ingress.networking.knative.dev&quot;}}'
$ kubectl --namespace kourier-system get service kourier

# 验证安装结果
$ kubectl get pods -n knative-serving

# 在knative中打开runtimeClass feature gate
$ kubectl patch configmap/config-features -n knative-serving --type merge --patch '{&quot;data&quot;:{&quot;kubernetes.podspec-runtimeclassname&quot;:&quot;enabled&quot;}}'
</code></pre>
<h2 id="创建一个wasm-serverless-service"><a class="header" href="#创建一个wasm-serverless-service">创建一个WASM serverless service</a></h2>
<p>现在我们尝试创建一个WASM serverless service.</p>
<pre><code class="language-bash"># WASM serverless service的配置文件
# 注意配置annotations, 指定runtimeClassName和端口
$ cat &gt; http-wasm-serverless.yaml &lt;&lt;EOF
apiVersion: serving.knative.dev/v1
kind: Service
metadata:
  name: http-wasm
  namespace: default
spec:
  template:
    metadata:
      annotations:
        module.wasm.image/variant: compat-smart
    spec:
      runtimeClassName: crun
      timeoutSeconds: 1
      containers:
      - name: http-server
        image: docker.io/wasmedge/example-wasi-http:latest
        ports:
        - containerPort: 1234
          protocol: TCP
        livenessProbe:
          tcpSocket:
            port: 1234
EOF

$ kubectl apply http-wasm-serverless.yaml

# 稍等一会，检查服务是否可用
$ kubectl get ksvc http-wasm
NAME          URL                                              LATESTCREATED       LATESTREADY         READY   REASON
http-wasm     http://http-wasm.default.knative.example.com     http-wasm-00001     http-wasm-00001     True

# 尝试请求服务
# 因为我们没有配置DNS，所以要通过Kourier, 也就是Knative Serving ingress port访问服务。
# 首先获得Kourier端口号，下面例子里端口号是31997.
$ kubectl --namespace kourier-system get service kourier
NAME      TYPE           CLUSTER-IP      EXTERNAL-IP       PORT(S)                      AGE
kourier   LoadBalancer   10.105.58.134                     80:31997/TCP,443:31019/TCP   53d
$ curl -H &quot;Host: http-wasm.default.knative.example.com&quot; -d &quot;name=WasmEdge&quot; -X POST http://localhost:31997

# 检查响应请求而新启动的pods
$ kubectl get pods
NAME                                           READY   STATUS    RESTARTS   AGE
http-wasm-00001-deployment-748bdc7cf-96l4r     2/2     Running   0          19s
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="应用框架与平台"><a class="header" href="#应用框架与平台">应用框架与平台</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="service-mesh-与分布式框架"><a class="header" href="#service-mesh-与分布式框架">Service mesh 与分布式框架</a></h1>
<p>WasmEdge 可以作为 sidecar 微服务的轻量级运行时，也可以作为 Docker 替代方案的 API 代理。</p>
<h2 id="sidecar-微服务"><a class="header" href="#sidecar-微服务">Sidecar 微服务</a></h2>
<p>对于支持多个应用程序运行时的 sidecar 框架，我们可以通过其 C、Go、Rust 或 Node.js SDK 将 WasmEdge 应用程序简单地嵌入到 sidecar 中。 另外，WasmEdge 应用程序可以直接由容器工具管理并充当 sidecar 微服务。</p>
<ul>
<li><a href="frameworks/mesh/dapr.html">Dapr</a> 展示了如何将 WasmEdge 微服务作为 Dapr sidecar 运行。</li>
<li><a href="frameworks/mesh/evenmesh.html">Apache EventMesh</a> 展示了如何将 WasmEdge 微服务作为 Apache EventMesh sidecar 运行</li>
</ul>
<h2 id="api-porxy-的扩展"><a class="header" href="#api-porxy-的扩展">API porxy 的扩展</a></h2>
<p>API proxy 是服务网格中的另一个关键组件。 它以保持系统可扩展性的方式管理 API 请求并将其定向到 sidecar。 开发人员需要编写这些代理脚本，以根据不断变化的基础设施和运营要求来路由流量。 看到用户希望使用 WebAssembly 而不是 LUA 脚本语言的广泛需求，社区一起创建了 proxy-wasm 规范。 它定义了 WebAssembly 运行时必须支持的插入 proxy 的主机接口。 WasmEdge 现在已经支持 proxy-wasm。</p>
<ul>
<li><a href="frameworks/mesh/mosn.html">MOSN</a> 展示了如何使用 WasmEdge 作为 MOSN 的扩展。</li>
</ul>
<p>如果你对 WasmEdge 和微服务有一些好的想法，请随时在 <a href="https://github.com/WasmEdge/WasmEdge">WasmEdge</a> GitHub 存储库上创建问题或 PR！</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="dapr"><a class="header" href="#dapr">Dapr</a></h1>
<p>在这篇文章中，我将演示如何使用 WasmEdge 作为 Dapr sidecar 应用程序的 runtime。我们将使用一个用 Rust 或 Go 编写的简单的 NaCl 用于监听微服务的 API 请求。它会将请求的数据传递给 WebAssembly runtime 进行处理。而微服务的业务逻辑由应用开发者创建和部署的 WebAssembly 函数实现，你也可以观看相关的 <a href="https://www.youtube.com/watch?v=t_sQP6Qpf7U">演示视频</a> 。</p>
<blockquote>
<p>更多有关于在 Dapr 上运行 WasmEdge 的内容，请参阅文章 <a href="https://www.secondstate.io/articles/dapr-wasmedge-webassembly/">A Lightweight, Safe, Portable, and High-performance Runtime for Dapr</a></p>
</blockquote>
<h2 id="快速开始-10"><a class="header" href="#快速开始-10">快速开始</a></h2>
<p>首先，你需要安装 <a href="https://golang.org/doc/install">Go</a>、<a href="https://www.rust-lang.org/tools/install">Rust</a>、 <a href="https://docs.dapr.io/getting-started/install-dapr-cli">Dapr</a>、 <a href="frameworks/mesh/../../start/install.html">WasmEdge</a>、 和 <a href="frameworks/mesh/../../dev/rust/bindgen.html">rustwasmc</a> 编译器工具。</p>
<p>接着，从 Github fork 或 clone 应用程序的 demo。你也可以将这个 repo 作为你自己的应用程序模板。</p>
<pre><code class="language-bash">git clone https://github.com/second-state/dapr-wasm
</code></pre>
<p>这个 demo 包含 3 个 Dapr sidecar 应用程序，如下：</p>
<ul>
<li><a href="https://github.com/second-state/dapr-wasm/tree/main/web-port">web-port</a> 项目提供公开的静态 HTML 页面的 Web 服务。web-port 是 demo 的 UI 应用程序。</li>
<li><a href="https://github.com/second-state/dapr-wasm/tree/main/image-api-rs">image-api-rs</a> 项目提供了一个运行 <a href="https://github.com/second-state/dapr-wasm/tree/main/functions/grayscale&amp;sa=D&amp;source=editors&amp;ust=1634144162467000&amp;usg=AOvVaw1uNZEDmOfXXXzLHHZWVFyD">grayscale</a> 函数的 WasmEdge 微服务。微服务调用 <a href="https://github.com/second-state/dapr-wasm/tree/main/functions/grayscale&amp;sa=D&amp;source=editors&amp;ust=1634144162467000&amp;usg=AOvVaw1uNZEDmOfXXXzLHHZWVFyD">grayscale</a> 将输入图像转换为 grayscale 图像。image-api-rs 演示了 Rust SDK 在 Dapr 和 WasmEdge 上的使用。</li>
<li><a href="https://github.com/second-state/dapr-wasm/tree/main/image-api-go&amp;sa=D&amp;source=editors&amp;ust=1634144162467000&amp;usg=AOvVaw3pG0m0DQap9XTUAfBMyi1s">image-api-go</a> 项目提供了一个运行 <a href="https://github.com/second-state/dapr-wasm/tree/main/functions/classify&amp;sa=D&amp;source=editors&amp;ust=1634144162468000&amp;usg=AOvVaw0zYdNzIz6MiDkZCAvm_D9q">classify</a> 函数的 WasmEdge 微服务，对输入图像中的对象进行识别和分类。image-api-go 演示了 Go SDK 在 Dapr 和 WasmEdge 上的使用。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/docs/book/en/src/frameworks/mesh/dapr-wasmedge.png" alt="dapr-wasmedge" /></p>
<p>如上，Dapr sidecar 微服务在这个 demo 应用程序架构中的位置。</p>
<p>你可以按照 <a href="https://github.com/second-state/dapr-wasm/blob/main/README.md">README</a> 的说明启动 sidecar 服务。以下是构建 WebAssembly 函数和启动上述 3 个 sidecar 服务的命令。</p>
<pre><code class="language-bash"># 构建分类和 grayscale WebAssembly 函数，并将它们部署到 Sidecar 项目
cd functions/grayscale
./build.sh
cd ../../
cd functions/classify
./build.sh
cd ../../

# 构建并启动 Web 服务用于应用程序的 UI 
cd web-port
go build
./run_web.sh
cd ../

# 构建并启动用于图像处理（grayscale）的微服务
cd image-api-rs
cargo build
./run_api_rs.sh
cd ../

# 构建并启动基于 tensorflow 的图像分类的微服务
cd image-api-go
go build --tags &quot;tensorflow image&quot;
./run_api_go.sh
cd ../
</code></pre>
<p>最后，你应该能够通过浏览器看见 Web UI 如下:</p>
<p><img src="https://github.com/WasmEdge/WasmEdge/blob/master/docs/book/en/src/frameworks/mesh/dapr-wasmedge-in-action.png" alt="dapr-wasmedge" /></p>
<p>如上，demo 应用程序正常运行的浏览器截图。</p>
<h2 id="两个-webassembly-函数"><a class="header" href="#两个-webassembly-函数">两个 WebAssembly 函数</a></h2>
<p>我们有两个用 Rust 编写并被编译的 WebAssembly 函数。它们将部署在 sidecar 微服务中，分别执行图像处理和图像分类的任务。</p>
<p>虽然，我们的示例 WebAssembly 函数是用 Rust 编写的，但你也可以用 C/C++、Swift、Kotlin 和 AssemblyScript 编写并编译成 WebAssembly 函数。此外 WasmEdge 还支持运行 JavaScript 和 DSL 编写的函数。</p>
<p><a href="https://github.com/second-state/dapr-wasm/tree/main/functions/grayscale">grayscale</a> 函数是一个 Rust 编写的程序，它通过 <code>STDIN</code> 读取图像数据，并将 grayscale 图像写入 <code>STDOUT</code>。</p>
<pre><pre class="playground"><code class="language-rust">use image::{ImageFormat, ImageOutputFormat};
use std::io::{self, Read, Write};
fn main() {
  let mut buf = Vec::new();
  io::stdin().read_to_end(&amp;mut buf).unwrap();
  let image_format_detected: ImageFormat = image::guess_format(&amp;buf).unwrap();
  let img = image::load_from_memory(&amp;buf).unwrap();
  let filtered = img.grayscale();
  let mut buf = vec![];
  match image_format_detected {
    ImageFormat::Gif =&gt; {
      filtered.write_to(&amp;mut buf, ImageOutputFormat::Gif).unwrap();
    }
    _ =&gt; {
      filtered.write_to(&amp;mut buf, ImageOutputFormat::Png).unwrap();
    }
  };
  io::stdout().write_all(&amp;buf).unwrap();
  io::stdout().flush().unwrap();
}
</code></pre></pre>
<p>然后，我们使用 <a href="https://www.secondstate.io/articles/rustwasmc/">rustwasmc</a> 进行构建，将构建好的 wasm 文件复制到 <a href="https://github.com/second-state/dapr-wasm/tree/main/image-api-rs">image-api-rs</a> sidecar 中。</p>
<pre><code class="language-bash">cd functions/grayscale
rustup override set 1.50.0
rustwasmc  build --enable-ext
cp ./pkg/grayscale.wasm ../../image-api-rs/lib
</code></pre>
<p><a href="https://github.com/second-state/dapr-wasm/tree/main/functions/classify">classify</a> 函数是一个 Rust 函数，它将图像数据的字节数组作为输入（参数），调用 WasmEdge TensorFlow API 处理，并返回一个字符串用于分类。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use wasmedge_tensorflow_interface;
pub fn infer_internal(image_data: &amp;[u8]) -&gt; String {
  let model_data: &amp;[u8] = include_bytes!(&quot;models/mobilenet_v1_1.0_224/mobilenet_v1_1.0_224_quant.tflite&quot;);
  let labels = include_str!(&quot;models/mobilenet_v1_1.0_224/labels_mobilenet_quant_v1_224.txt&quot;);
  let flat_img = wasmedge_tensorflow_interface::load_jpg_image_to_rgb8(image_data, 224, 224);
  let mut session = wasmedge_tensorflow_interface::Session::new(
    &amp;model_data,
    wasmedge_tensorflow_interface::ModelType::TensorFlowLite,
  );
  session.add_input(&quot;input&quot;, &amp;flat_img, &amp;[1, 224, 224, 3])
         .run();
  let res_vec: Vec&lt;u8&gt; = session.get_output(&quot;MobilenetV1/Predictions/Reshape_1&quot;);
  // ... Map the probabilities in res_vec to text labels in the labels file ...
  if max_value &gt; 50 {
    format!(
      &quot;It {} a &lt;a href='https://www.google.com/search?q={}'&gt;{}&lt;/a&gt; in the picture&quot;,
      confidence.to_string(),
      class_name,
      class_name
    )
  } else {
    format!(&quot;It does not appears to be any food item in the picture.&quot;)
  }
}
<span class="boring">}
</span></code></pre></pre>
<p>然后，我们使用 <a href="https://www.secondstate.io/articles/rustwasmc/">rustwasmc</a> 构建，将构建好的 wasm 文件复制到 <a href="https://github.com/second-state/dapr-wasm/tree/main/image-api-go">image-api-go</a> sidecar。</p>
<pre><code class="language-bash">cd functions/classify
rustup override set 1.50.0
rustwasmc  build --enable-ext
cp ./pkg/classify_bg.wasm ../../image-api-go/lib/classify_bg.wasm
</code></pre>
<p>在接下来的三个小节中，我们将探究这三个 sidecar 服务。</p>
<h2 id="图像处理-sidecar"><a class="header" href="#图像处理-sidecar">图像处理 sidecar</a></h2>
<p><a href="https://github.com/second-state/dapr-wasm/tree/main/image-api-rs">image-api-rs</a> sidecar 应用程序是用 Rust 编写的。在上一步中，已经通过安装 <code>lib/grayscale.wasm</code> 拥有了 WebAssembly 函数。请参考 <a href="https://github.com/second-state/dapr-wasm/blob/main/functions/bin/install.sh">functions/bin/install.sh</a> 脚本来安装 WasmEdge Runtime 的二进制文件 <code>lib/wasmedge-tensorflow-lite</code> 及其依赖项。</p>
<p>Sidecar 微服务运行了一个基于 Tokio 的事件循环，用于侦听 <code>/api/image</code> 路径上接收到的 HTTP 请求。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[tokio::main]
pub async fn run_server(port: u16) {
  pretty_env_logger::init();
  let home = warp::get().map(warp::reply);
  let image = warp::post().and(warp::path(&quot;api&quot;))
                          .and(warp::path(&quot;image&quot;))
                          .and(warp::body::bytes())
                          .map(|bytes: bytes::Bytes| {
    let v: Vec&lt;u8&gt; = bytes.iter().map(|&amp;x| x).collect();
    let res = image_process(&amp;v);
    Ok(Box::new(res))
  });
  let routes = home.or(image);
  let routes = routes.with(warp::cors().allow_any_origin());
  let log = warp::log(&quot;dapr_wasm&quot;);
  let routes = routes.with(log);
  warp::serve(routes).run((Ipv4Addr::UNSPECIFIED, port)).await
}
<span class="boring">}
</span></code></pre></pre>
<p>一旦它接收到通过 HTTP POST 请求发送的图像文件，就会调用 WasmEdge 中的 WebAssembly 函数来执行图像处理任务。它创建一个 WasmEdge 实例来与 WebAssembly 程序交互。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn image_process(buf: &amp;Vec&lt;u8&gt;) -&gt; Vec&lt;u8&gt; {
  let mut child = Command::new(&quot;./lib/wasmedge-tensorflow-lite&quot;)
    .arg(&quot;./lib/grayscale.wasm&quot;)
    .stdin(Stdio::piped())
    .stdout(Stdio::piped())
    .spawn()
    .expect(&quot;failed to execute child&quot;);
  {
    // limited borrow of stdin
    let stdin = child.stdin.as_mut().expect(&quot;failed to get stdin&quot;);
    stdin.write_all(buf).expect(&quot;failed to write to stdin&quot;);
  }
  let output = child.wait_with_output().expect(&quot;failed to wait on child&quot;);
  output.stdout
}
<span class="boring">}
</span></code></pre></pre>
<p>执行以下 Dapr CLI 命令将在 Dapr runtime 环境中启动 image-api-rs 微服务。</p>
<pre><code class="language-bash">cd image-api-rs
sudo dapr run --app-id image-api-rs \
    --app-protocol http \
    --app-port 9004 \
    --dapr-http-port 3502 \
    --components-path ../config \
    --log-level debug \
    ./target/debug/image-api-rs
cd ../
</code></pre>
<h2 id="tensorflow-sidecar"><a class="header" href="#tensorflow-sidecar">Tensorflow sidecar</a></h2>
<p><a href="https://github.com/second-state/dapr-wasm/tree/main/image-api-go">image-api-go</a> sidecar 应用程序是用 Go 编写的。通过之前安装 <code>lib/classify\_bg.wasm</code> 的步骤已有 WebAssembly 函数。请参考 <a href="https://github.com/second-state/dapr-wasm/blob/main/functions/bin/install.sh">functions/bin/install.sh</a> 脚本来安装 WasmEdge Runtime 的 Go SDK。</p>
<p>Sidecar 微服务运行一个事件循环，在 <code>/api/image</code> 路径上监听传入的 HTTP 请求。</p>
<pre><code class="language-go">func main() {
  s := daprd.NewService(&quot;:9003&quot;)
  if err := s.AddServiceInvocationHandler(&quot;/api/image&quot;, imageHandlerWASI); err != nil {
    log.Fatalf(&quot;error adding invocation handler: %v&quot;, err)
  }
  if err := s.Start(); err != nil &amp;&amp; err != http.ErrServerClosed {
    log.Fatalf(&quot;error listenning: %v&quot;, err)
  }
}
</code></pre>
<p>一旦程序接收到通过 HTTP POST 请求发送的图像文件，就会调用 WasmEdge 中的 WebAssembly 函数执行基于 Tensorflow 的图像分类任务。它使用 WasmEdge 的 Go API 与 WebAssembly 程序进行交互。</p>
<pre><code class="language-go">func imageHandlerWASI(_ context.Context, in *common.InvocationEvent) (out *common.Content, err error) {
  image := in.Data
  var conf = wasmedge.NewConfigure(wasmedge.REFERENCE_TYPES)
  conf.AddConfig(wasmedge.WASI)
  var vm = wasmedge.NewVMWithConfig(conf)
  var wasi = vm.GetImportObject(wasmedge.WASI)
  wasi.InitWasi(
    os.Args[1:],     // The args
    os.Environ(),    // The envs
    []string{&quot;.:.&quot;}, // The mapping directories
    []string{},      // The preopens will be empty
  )
  // Register WasmEdge-tensorflow and WasmEdge-image
  var tfobj = wasmedge.NewTensorflowImportObject()
  var tfliteobj = wasmedge.NewTensorflowLiteImportObject()
  vm.RegisterImport(tfobj)
  vm.RegisterImport(tfliteobj)
  var imgobj = wasmedge.NewImageImportObject()
  vm.RegisterImport(imgobj)
  vm.LoadWasmFile(&quot;./lib/classify_bg.wasm&quot;)
  vm.Validate()
  vm.Instantiate()
  res, err := vm.ExecuteBindgen(&quot;infer&quot;, wasmedge.Bindgen_return_array, image)
  ans := string(res.([]byte))
  
  vm.Delete()
  conf.Delete()
  out = &amp;common.Content{
    Data:    []byte(ans),
    ContentType: in.ContentType,
    DataTypeURL: in.DataTypeURL,
  }
  return out, nil
}
</code></pre>
<p>执行以下 Dapr CLI 命令会在 Dapr runtime 环境中启动 image-api-go 微服务。</p>
<pre><code class="language-bash">cd image-api-go
sudo dapr run --app-id image-api-go \
    --app-protocol http \
    --app-port 9003 \
    --dapr-http-port 3501 \
    --log-level debug \
    --components-path ../config \
    ./image-api-go
cd ../
</code></pre>
<h2 id="web-ui-sidecar"><a class="header" href="#web-ui-sidecar">Web UI sidecar</a></h2>
<p>Web UI 服务 <a href="https://github.com/second-state/dapr-wasm/tree/main/web-port">web-port</a> 是一个用 Go 编写的简单 Web 服务器。它提供静态文件夹中的静态 HTML 和 JavaScript 文件，并将通过 <code>/api/hello</code> 上传的图像发送到 <a href="https://github.com/second-state/dapr-wasm/tree/main/image-api-rs">grayscale</a> 或 <a href="https://github.com/second-state/dapr-wasm/tree/main/image-api-go">classify</a> sidecar 的 <code>/api/image</code> 端点。</p>
<pre><code class="language-go">func main() {
  http.HandleFunc(&quot;/static/&quot;, staticHandler)
  http.HandleFunc(&quot;/api/hello&quot;, imageHandler)
  println(&quot;listen to 8080 ...&quot;)
  log.Fatal(http.ListenAndServe(&quot;:8080&quot;, nil))
}

func staticHandler(w http.ResponseWriter, r *http.Request) {
  // ... 读取并返回 HTML CSS 和 JS 文件的内容 ...
}

func imageHandler(w http.ResponseWriter, r *http.Request) {
  // ... ...
  api := r.Header.Get(&quot;api&quot;)
  if api == &quot;go&quot; {
    daprClientSend(body, w)
  } else {
    httpClientSend(body, w)
  }
}

// 通过 Dapr API 发送到 image-api-go sidecar（分类）
func daprClientSend(image []byte, w http.ResponseWriter) {
  // ... ...
  resp, err := client.InvokeMethodWithContent(ctx, &quot;image-api-go&quot;, &quot;/api/image&quot;, &quot;post&quot;, content)
  // ... ...
}

// 通过 HTTP API 发送到  image-api-rs sidecar（grayscale）
func httpClientSend(image []byte, w http.ResponseWriter) {
  // ... ...
  req, err := http.NewRequest(&quot;POST&quot;, &quot;http://localhost:3502/v1.0/invoke/image-api-rs/method/api/image&quot;, bytes.NewBuffer(image))
  // ... ...
}
</code></pre>
<p><a href="https://github.com/second-state/dapr-wasm/blob/main/web-port/static/page.js">page.js</a> 中的 JavaScript 代码只实现了将图像上传到 <a href="https://github.com/second-state/dapr-wasm/tree/main/web-port">web-port</a> sidecar 的 <code>/api/hello</code> 端点，<a href="https://github.com/second-state/dapr-wasm/tree/main/web-port">web-port</a> 将根据请求头请求 classify（分类）或 grayscale 微服务的 api。</p>
<pre><code class="language-javascript">function runWasm(e) {
  const reader = new FileReader();
  reader.onload = function (e) {
    setLoading(true);
    var req = new XMLHttpRequest();
    req.open(&quot;POST&quot;, '/api/hello', true);
    req.setRequestHeader('api', getApi());
    req.onload = function () {
      // ...  display results ...
    };
    const blob = new Blob([e.target.result], {
      type: 'application/octet-stream'
    });
    req.send(blob);
  };
  console.log(image.file)
  reader.readAsArrayBuffer(image.file);
}
</code></pre>
<p>执行以下 Dapr CLI 命令启动静态 UI 文件的 Web 服务。</p>
<pre><code class="language-bash">cd web-port
sudo dapr run --app-id go-web-port \
    --app-protocol http \
    --app-port 8080 \
    --dapr-http-port 3500 \
    --components-path ../config \
    --log-level debug \
    ./web-port
cd ../
</code></pre>
<p>至此，你现在有一个用两种语言编写的并由三部分组成的分布式应用程序了！</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mosn"><a class="header" href="#mosn">MOSN</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="apache-eventmesh"><a class="header" href="#apache-eventmesh">Apache EventMesh</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="应用框架"><a class="header" href="#应用框架">应用框架</a></h1>
<p>WasmEdge 为应用程序提供安全高效的扩展机制。当然，应用程序开发人员随时可以使用 <a href="https://github.com/WasmEdge/WasmEdge/blob/master/docs/book/en/src/embed.md">WasmEdge SDK</a> 来嵌入 WebAssembly 函数。但有些应用程序和框架选择在 WasmEdge SDK 之上构建扩展/嵌入 API，后者支持与应用程序的本地应用场景和编程模型进行更符合人体工程学的集成。</p>
<ul>
<li><a href="https://github.com/WasmEdge/WasmEdge/blob/master/docs/book/en/src/frameworks/app/yomo.md">YoMo</a> 是一个数据流处理框架。WasmEdge 函数可以插入到框架中来处理流中的数据。</li>
<li><a href="https://github.com/WasmEdge/WasmEdge/blob/master/docs/book/en/src/frameworks/app/reactr.md">Reactr</a> 是一个 Go 语言框架，用于管理和扩展 WebAssembly 函数，以便轻松嵌入到其他 Go 应用程序中。</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="yomo"><a class="header" href="#yomo">YoMo</a></h1>
<p><a href="https://yomo.run/">YoMo</a> 是一个让开发者能够构建分布式云系统（地理分布式云系统）的编程框架。YoMo 的通信层是建立在 QUIC 协议之上，QUIC 协议带来了高速的数据传输。另外，YoMo 内置了流式 Serverless 的 “流式函数”，这可以显著提升分布式云系统的开发体验。YoMo 构建的分布式云系统提供了近场算力与终端之间的超高速通信机制， 使得它在元宇宙、VR/AR、IoT 等领域有着广泛的应用。</p>
<blockquote>
<p>YoMo 是使用 Go 语言编写的。对于流式 Serverless，Go 语言的插件和共享库可以动态加载用户的代码，这也对开发者带来了一些限制。加上 Serverless 架构对隔离性的刚性需求，这使得 WebAssembly 成为运行用户定义函数的最佳选择。</p>
</blockquote>
<p>举个例子， 在 AR/VR 设备或智能工厂的 AI 推理过程中，摄像头通过  YoMo 向近场 MEC（对接入边缘计算）设备中的计算节点发送实时非结构化数据。当 AI 推理完成之后，YoMo 将 AI 计算结果实时发送到终端设备。因此，托管的 AI 推理功能实现了自动化。</p>
<p>然而，YoMo 面临的挑战是在边缘计算节点中整合和管理多个外部开发者开发的 handler 函数。这需要在不影响性能的情况下对这些函数进行 runtime 隔离。传统的软件容器解决方案，比如 Docker，难以胜任。因为传统的软件容器太重太慢，无法处理实时任务。</p>
<p>WebAssembly 提供了一个轻量级和高性能的软件容器。 它非常适合作为 YoMo 数据处理 handler 函数的 runtime。</p>
<p>在本文中，我们将向你展示如何创建一个基于 Tensorflow 图像分类的 Rust 函数，将其编译为 WebAssembly，然后使用 YoMo 作为流数据 handler 运行它。我们使用 <a href="https://wasmedge.org/">WasmEdge</a> 作为我们 WebAssembly runtime，因为与其他 WebAssembly runtime 相比，WasmEdge 提供了最高的性能与灵活性。是唯一能稳定支持 Tensorflow 的 WebAssembly 虚拟机。<a href="https://github.com/WasmEdge/WasmEdge/blob/master/docs/book/en/src/embed/go.md">YoMo 通过 WasmEdge 的 Go SDK</a> 来管理 WasmEdge 虚拟机实例和 contained 容器化 WebAssembly 字节码应用。</p>
<blockquote>
<p>源码: <a href="https://github.com/yomorun/yomo-wasmedge-tensorflow">https://github.com/yomorun/yomo-wasmedge-tensorflow</a></p>
</blockquote>
<p>详情可查看 <a href="https://www.youtube.com/watch?v=E0ltsn6cLIU">YoMo 中的 WasmEdge 图像分类函数实战</a></p>
<h2 id="安装前提"><a class="header" href="#安装前提">安装前提</a></h2>
<p>显然，你需要 <a href="https://golang.org/doc/install">安装 Go 语言</a>，但我觉得你肯定安装好了。</p>
<blockquote>
<p>为了我们的示例代码能正常工作， Go 语言版本应不低于 1.15 。</p>
</blockquote>
<p>你还要安装 YoMo CLI  应用程序，其负责数据流和 handler 函数调用的编排和协调。</p>
<pre><code class="language-bash">$ go install github.com/yomorun/cli/yomo@latest
$ yomo version
YoMo CLI version: v0.1.3
</code></pre>
<p>接下来，请安装 WasmEdge 和其 Tensorflow 共享库。<a href="https://wasmedge.org/">WasmEdge</a> 是由云原生基金会（CNCF）托管的行业领先的 WebAssembly runtime。我们将使用它来嵌入和运行来自 YoMo 的 WebAssembly 程序。</p>
<pre><code class="language-bash">curl -sSf https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/utils/install.sh | bash
</code></pre>
<p>最后，因为我们的 demo WebAssembly 函数是 Rust 编写的，因此你还需要一个  <a href="https://www.rust-lang.org/tools/install">Rust 编译器</a>。</p>
<p>至于 demo 的其余部分，fork 并克隆 <a href="https://github.com/yomorun/yomo-wasmedge-tensorflow">源码库</a> 就行。</p>
<pre><code class="language-bash">git clone https://github.com/yomorun/yomo-wasmedge-tensorflow.git
</code></pre>
<h2 id="图像分类函数"><a class="header" href="#图像分类函数">图像分类函数</a></h2>
<p>处理 YoMo 图像流的 <a href="https://github.com/yomorun/yomo-wasmedge-tensorflow/tree/main/flow/rust_mobilenet_food">图像分类函数</a> 是 Rust 写的。它利用 WasmEdge Tensorflow API 来处理输入图像。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[wasmedge_bindgen]
pub fn infer(image_data: Vec&lt;u8&gt;) -&gt; Result&lt;Vec&lt;u8&gt;, String&gt; {
  let start = Instant::now();

  // 导入 TFLite 模型和其元数据（每个被识别对象编号的文本标签）
  let model_data: &amp;[u8] = include_bytes!(&quot;lite-model_aiy_vision_classifier_food_V1_1.tflite&quot;);
  let labels = include_str!(&quot;aiy_food_V1_labelmap.txt&quot;);

  // 将图像进行预处理成该模型可以使用的规范模式
  let flat_img = wasmedge_tensorflow_interface::load_jpg_image_to_rgb8(&amp;image_data[..], 192, 192);
  println!(&quot;RUST: Loaded image in ... {:?}&quot;, start.elapsed());

  // 使用 WasmEdge TensorFlow API 运行 TFLite 模型
  let mut session = wasmedge_tensorflow_interface::Session::new(&amp;model_data, wasmedge_tensorflow_interface::ModelType::TensorFlowLite);
  session.add_input(&quot;input&quot;, &amp;flat_img, &amp;[1, 192, 192, 3])
         .run();
  let res_vec: Vec&lt;u8&gt; = session.get_output(&quot;MobilenetV1/Predictions/Softmax&quot;);

  // 在 res_vec 中找到概率最大的对象索引
  // 将概率转换为置信水平
  // 将模型元数据 food_name 中的对象索引转换为标签
  let mut i = 0;
  let mut max_index: i32 = -1;
  let mut max_value: u8 = 0;
  while i &lt; res_vec.len() {
    let cur = res_vec[i];
    if cur &gt; max_value {
      max_value = cur;
      max_index = i as i32;
    }
    i += 1;
  }
  println!(&quot;RUST: index {}, prob {}&quot;, max_index, max_value);

  let confidence: String;
  if max_value &gt; 200 {
    confidence = &quot;is very likely&quot;.to_string();
  } else if max_value &gt; 125 {
    confidence = &quot;is likely&quot;.to_string();
  } else {
    confidence = &quot;could be&quot;.to_string();
  }

  let ret_str: String;
  if max_value &gt; 50 {
    let mut label_lines = labels.lines();
    for _i in 0..max_index {
      label_lines.next();
    }
    let food_name = label_lines.next().unwrap().to_string();
    ret_str = format!(
      &quot;It {} a &lt;a href='https://www.google.com/search?q={}'&gt;{}&lt;/a&gt; in the picture&quot;,
      confidence, food_name, food_name
    );
  } else {
    ret_str = &quot;It does not appears to be a food item in the picture.&quot;.to_string();
  }

  println!(
    &quot;RUST: Finished post-processing in ... {:?}&quot;,
    start.elapsed()
  );
  return Ok(ret_str.as_bytes().to_vec());
}
<span class="boring">}
</span></code></pre></pre>
<p>你应该把 <code>wasm32-wasi</code> 目标添加到 rust，用以将此函数编译为 WebAssembly 字节码。</p>
<pre><code class="language-bash">rustup target add wasm32-wasi

cd flow/rust_mobilenet_food
cargo build --target wasm32-wasi --release
# 编译生成的 WASM 字节码文件就是 target/wasm32-wasi/release/rust_mobilenet_food_lib.wasm

# 把 wasm 字节码文件拷贝到 flow/ 目录
cp target/wasm32-wasi/release/rust_mobilenet_food_lib.wasm ../
</code></pre>
<p>为了释放 WasmEdge 的最佳性能，你应该使用 <code>wasmedgec</code> 将 <code>.wasm</code> 文件编译为原生二进制文件来启用 AOT 模式。</p>
<pre><code class="language-bash">wasmedgec rust_mobilenet_food_lib.wasm rust_mobilenet_food_lib.wasm
</code></pre>
<h2 id="与-yomo-集成"><a class="header" href="#与-yomo-集成">与 YoMo 集成</a></h2>
<p>在 YoMo 方面，我们使用 WasmEdge Go 语言 API 来启动和运行 WasmEdge 虚拟机来实现图像分类功能。下面是源码项目中的 <a href="https://github.com/yomorun/yomo-wasmedge-tensorflow/blob/main/flow/app.go">app.go</a> 文件。</p>
<pre><code class="language-go">package main

import (
  &quot;crypto/sha1&quot;
  &quot;fmt&quot;
  &quot;log&quot;
  &quot;os&quot;
  &quot;sync/atomic&quot;

  &quot;github.com/second-state/WasmEdge-go/wasmedge&quot;
  bindgen &quot;github.com/second-state/wasmedge-bindgen/host/go&quot;
  &quot;github.com/yomorun/yomo&quot;
)

var (
  counter uint64
)

const ImageDataKey = 0x10

func main() {
  // 连接 Zipper 服务
  sfn := yomo.NewStreamFunction(&quot;image-recognition&quot;, yomo.WithZipperAddr(&quot;localhost:9900&quot;))
  defer sfn.Close()

  // 设置监控数据
  sfn.SetObserveDataID(ImageDataKey)

  // 设置 handler
  sfn.SetHandler(Handler)

  // 启动
  err := sfn.Connect()
  if err != nil {
    log.Print(&quot;❌ Connect to zipper failure: &quot;, err)
    os.Exit(1)
  }

  select {}
}

// Handler 处理流式数据
func Handler(img []byte) (byte, []byte) {
  // 初始化 WasmEdge 虚拟机
  vmConf, vm := initVM()
  bg := bindgen.Instantiate(vm)
  defer bg.Release()
  defer vm.Release()
  defer vmConf.Release()

  // 识别图像
  res, err := bg.Execute(&quot;infer&quot;, img)
  if err == nil {
    fmt.Println(&quot;GO: Run bindgen -- infer:&quot;, string(res))
  } else {
    fmt.Println(&quot;GO: Run bindgen -- infer FAILED&quot;)
  }

  // 打印 log 
  hash := genSha1(img)
  log.Printf(&quot;✅ received image-%d hash %v, img_size=%d \n&quot;, atomic.AddUint64(&amp;counter, 1), hash, len(img))

  return 0x11, nil
}

// genSha1 生成图像的哈希值
func genSha1(buf []byte) string {
  h := sha1.New()
  h.Write(buf)
  return fmt.Sprintf(&quot;%x&quot;, h.Sum(nil))
}

// initVM 初始化 WasmEdge 虚拟机
func initVM() (*wasmedge.Configure, *wasmedge.VM) {
  wasmedge.SetLogErrorLevel()
  // 设置 Tensorflow 不要打印调试信息
  os.Setenv(&quot;TF_CPP_MIN_LOG_LEVEL&quot;, &quot;3&quot;)
  os.Setenv(&quot;TF_CPP_MIN_VLOG_LEVEL&quot;, &quot;3&quot;)

  // 创建配置信息
  vmConf := wasmedge.NewConfigure(wasmedge.WASI)

  // 根据配置信息创建虚拟机
  vm := wasmedge.NewVMWithConfig(vmConf)

  // 初始化 WASI
  var wasi = vm.GetImportObject(wasmedge.WASI)
  wasi.InitWasi(
    os.Args[1:],     // The args
    os.Environ(),    // The envs
    []string{&quot;.:.&quot;}, // The mapping directories
  )

  // 注册 WasmEdge-tensorflow 和 WasmEdge-image
  var tfobj = wasmedge.NewTensorflowImportObject()
  var tfliteobj = wasmedge.NewTensorflowLiteImportObject()
  vm.RegisterImport(tfobj)
  vm.RegisterImport(tfliteobj)
  var imgobj = wasmedge.NewImageImportObject()
  vm.RegisterImport(imgobj)

  // 实例化 wasm
  vm.LoadWasmFile(&quot;rust_mobilenet_food_lib.so&quot;)
  vm.Validate()

  return vmConf, vm
}
</code></pre>
<h2 id="实战"><a class="header" href="#实战">实战</a></h2>
<p>最后，我们启动 YoMo 并可以看到整个数据处理流水线的运行情况。从项目文件夹中启动 YoMo CLI 应用程序。<a href="https://github.com/yomorun/yomo-wasmedge-tensorflow/blob/main/zipper/workflow.yaml">yaml 文件</a> 定义了 YoMo 应该监听的端口和用来触发传入数据的工作流 handler。注意该 flow 名称 <code>image-recognition</code> 与上面提到的数据 handler 程序 <a href="https://github.com/yomorun/yomo-wasmedge-tensorflow/blob/main/flow/app.go">app.go</a> 中一致。</p>
<pre><code class="language-bash">yomo serve -c ./zipper/workflow.yaml
</code></pre>
<p>通过运行上面提到的 <a href="https://github.com/yomorun/yomo-wasmedge-tensorflow/blob/main/flow/app.go">app.go</a> 程序来启动 handler 函数。</p>
<pre><code class="language-bash">cd flow
go run --tags &quot;tensorflow image&quot; app.go
</code></pre>
<p>通过向 YoMo 发送视频来<a href="https://github.com/yomorun/yomo-wasmedge-tensorflow/blob/main/source/main.go">启动模拟数据源</a>。视频都是一系列图像帧。<a href="https://github.com/yomorun/yomo-wasmedge-tensorflow/blob/main/flow/app.go">app.go</a> 中的 WasmEdge 函数将针对视频中的图像逐帧调用。</p>
<pre><code class="language-bash"># 下载视频文件
wget -P source 'https://github.com/yomorun/yomo-wasmedge-tensorflow/releases/download/v0.1.0/hot-dog.mp4'

# 将视频流传给 YoMo
go run ./source/main.go ./source/hot-dog.mp4
</code></pre>
<p>你可以在操作台中看到来自 WasmEdge handler 函数的输出。它打印了视频中每个图像帧检测到的物体名称。</p>
<h2 id="更多内容"><a class="header" href="#更多内容">更多内容</a></h2>
<p>在本文中，我们了解了如何使用  WasmEdge Tensorflow API 和 YoMo 框架的 Go 语言 SDK 来近乎实时地处理图像流。</p>
<p>与 YoMo 合作，我们可以快速地在智能工厂的生产中部署 WasmEdge，以完成各种装配线任务。 WasmEdge 就是边缘计算软件 runtime 的事实标准！</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="reactr"><a class="header" href="#reactr">Reactr</a></h1>
<p><a href="https://github.com/suborbital/reactr">Reactr</a> 是一个用 Go 语言编写的高性能函数调用库。Reactr 的设计十分灵活，你可将其嵌入 Go 程序中运行，它也为 WebAssembly 提供了一流的支持。
得益于 Go 语言出色的并发性能，Reactr 可以同时管理和执行上百个 WebAssembly 运行时实例，这使得 Reactr 成为了服务端程序框架的一个优秀选择。</p>
<p>Reactr 让你可以在 Go 程序中调用 WebAssembly 函数，<a href="frameworks/app/../../embed/go.html">WasmEdge Go SDK</a> 也是如此。
Reactr 的特别之处在于，它在 Go 语言中提供了一套丰富的主机函数，其中包括了对访问网络、数据库等功能的支持。此外，Reactr 提供了 Rust (以及 Swift / AssemblyScript) 的 API，你可以用它在 WebAssembly 函数中调用上述的主机函数。</p>
<p>本文将向你展示如何将 WasmEdge 与 Reactr 结合起来使用，以充分利用二者的优势。
WasmEdge 是<a href="frameworks/app/../../intro/features.html">性能最佳且最具拓展性的 WebAssembly 运行时</a>，
并在 <a href="https://github.com/suborbital/reactr/runs/4476074960?check_suite_focus=true">Reactr 的官方测试用例</a>中是性能最好的。
我们将演示如何在 WasmEdge 和 Reactr 中运行编译为 WebAssembly 的 Rust 函数以及 JavaScript 程序。</p>
<blockquote>
<p>WasmEdge 为 JavaScript 提供了<a href="frameworks/app/../../dev/js.html">增强支持</a>，包括<a href="frameworks/app/../../dev/js/rust.html">将 Rust 与 JavaScript 混合</a>以提高性能。</p>
</blockquote>
<ul>
<li><a href="frameworks/app/reactr.html#hello-world">Hello world</a></li>
<li><a href="frameworks/app/reactr.html#%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9F%A5%E8%AF%A2">数据库查询</a></li>
<li><a href="frameworks/app/reactr.html#%E5%9C%A8-Go-%E4%B8%AD%E5%B5%8C%E5%85%A5-JavaScript">在 Go 中嵌入 JavaScript</a></li>
</ul>
<h2 id="环境准备"><a class="header" href="#环境准备">环境准备</a></h2>
<p>你的系统中需要装有 <a href="https://www.rust-lang.org/zh-CN/tools/install">Rust</a>、<a href="https://go.dev/doc/install">Go</a> 以及 <a href="frameworks/app/../../start/install.html">WasmEdge</a>。
WasmEdge 需要用到 GCC 编译器（<code>build-essential</code> 中包含 GCC 编译器）。</p>
<pre><code class="language-bash">sudo apt-get update
sudo apt-get -y upgrade
sudo apt install build-essential

curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh
source $HOME/.cargo/env
rustup target add wasm32-wasi

curl -OL https://golang.org/dl/go1.17.5.linux-amd64.tar.gz
sudo tar -C /usr/local -xvf go1.17.5.linux-amd64.tar.gz
export PATH=$PATH:/usr/local/go/bin

wget -qO- https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/utils/install.sh | bash
source $HOME/.wasmedge/env
</code></pre>
<h2 id="hello-world-4"><a class="header" href="#hello-world-4">Hello world</a></h2>
<p>你可以在<a href="https://github.com/second-state/wasm-learning/tree/master/reactr/hello">这里</a>找到一个简单的关于 Reactr 的 <code>hello world</code> 示例。</p>
<h3 id="hello-world-编译为-webassembly-的-rust-函数"><a class="header" href="#hello-world-编译为-webassembly-的-rust-函数">Hello world: 编译为 WebAssembly 的 Rust 函数</a></h3>
<p>我们首先编写一个<a href="https://github.com/second-state/wasm-learning/blob/master/reactr/hello/hello-echo/src/lib.rs">简单的 Rust 函数</a>，它所做的事只是回应一个 &quot;hello&quot;。
我们将通过 Reactr 把下面的 Rust 函数 <code>HelloEcho::run()</code> 暴露给 Go 主机应用。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use suborbital::runnable::*;

struct HelloEcho{}

impl Runnable for HelloEcho {
  fn run(&amp;self, input: Vec&lt;u8&gt;) -&gt; Result&lt;Vec&lt;u8&gt;, RunErr&gt; {
    let in_string = String::from_utf8(input).unwrap();
    Ok(format!(&quot;hello {}&quot;, in_string).as_bytes().to_vec())
  }
}
<span class="boring">}
</span></code></pre></pre>
<p>接下来，把这个 Rust 函数构建为 WebAssembly 字节码文件。</p>
<pre><code class="language-bash">cd hello-echo
cargo build --target wasm32-wasi --release
cp target/wasm32-wasi/release/hello_echo.wasm ..
cd ..
</code></pre>
<h3 id="hello-world-go-主机程序"><a class="header" href="#hello-world-go-主机程序">Hello world: Go 主机程序</a></h3>
<p>接下来，让我们看看执行这个 WebAssembly 函数的 <a href="https://github.com/second-state/wasm-learning/blob/master/reactr/hello/main.go">Go 主机程序</a>。
<code>Runnable</code> 结构体中的 <code>runBundle()</code> 函数所做的事是调用 <code>run()</code> 函数。</p>
<pre><code class="language-go">func runBundle() {
  r := rt.New()
  doWasm := r.Register(&quot;hello-echo&quot;, rwasm.NewRunner(&quot;./hello_echo.wasm&quot;))

  res, err := doWasm([]byte(&quot;wasmWorker!&quot;)).Then()
  if err != nil {
    fmt.Println(err)
    return
  }

  fmt.Println(string(res.([]byte)))
}
</code></pre>
<p><code>runGroup()</code> 函数会在组内异步地执行由 Rust 编译的 WebAssembly <code>run()</code> 函数，并在返回结果的时候接收它们。</p>
<pre><code class="language-go">func runGroup() {
  r := rt.New()

  doWasm := r.Register(&quot;hello-echo&quot;, rwasm.NewRunner(&quot;./hello_echo.wasm&quot;))

  grp := rt.NewGroup()
  for i := 0; i &lt; 100000; i++ {
    grp.Add(doWasm([]byte(fmt.Sprintf(&quot;world %d&quot;, i))))
  }

  if err := grp.Wait(); err != nil {
    fmt.Println(err)
  }
}
</code></pre>
<p>现在，我们可以将 Go 主机程序运行起来，并观察控制台中所打印的结果。</p>
<blockquote>
<p>只有在设置了 <code>-tags wasmedge</code> 这一标签后，你才能获得 WasmEdge 提供的性能优势以及拓展 WebAssembly API。</p>
</blockquote>
<pre><code class="language-bash">go mod tidy
go run -tags wasmedge main.go
</code></pre>
<h2 id="数据库查询"><a class="header" href="#数据库查询">数据库查询</a></h2>
<p>这个<a href="https://github.com/second-state/wasm-learning/tree/master/reactr/db">示例</a>演示了如何在 WebAssembly 函数中使用 Reactr 主机函数及 API 查询 PostgreSQL 数据库。</p>
<h3 id="数据库查询下载并安装-postgresql"><a class="header" href="#数据库查询下载并安装-postgresql">数据库查询：下载并安装 PostgreSQL</a></h3>
<p>我们可以在 Docker 中启动一个 PostgreSQL 实例。</p>
<pre><code class="language-bash">docker pull postgres
docker run --name reactr-postgres -p 5432:5432 -e POSTGRES_PASSWORD=12345 -d postgres
</code></pre>
<p>接下来，创建一个数据库并向其中填入一些样本数据。</p>
<pre><code class="language-bash">$ docker run -it --rm --network host postgres psql -h 127.0.0.1 -U postgres
postgres=# CREATE DATABASE reactr;
postgres=# \c reactr;

# Create a table:
postgres=# CREATE TABLE users (
    uuid        varchar(100) CONSTRAINT firstkey PRIMARY KEY,
    email       varchar(50) NOT NULL,
    created_at  date,
    state       char(1),
    identifier  integer
);
</code></pre>
<p>保持容器的运行状态，并打开一个新的终端窗口来与 PostgreSQL 服务器进行交互。</p>
<h3 id="数据库查询编译为-webassembly-的-rust-函数"><a class="header" href="#数据库查询编译为-webassembly-的-rust-函数">数据库查询：编译为 WebAssembly 的 Rust 函数</a></h3>
<p>让我们编写一个访问 PostgreSQL 数据库的 <a href="https://github.com/second-state/wasm-learning/blob/master/reactr/db/rs-db/src/lib.rs">Rust 函数</a>。
如下所示的 Rust 函数 <code>RsDbtest::run()</code> 将会通过 Reactr 暴露给 Go 主机程序。它使用 <code>PGInsertUser</code>、<code>PGSelectUserWithUUID</code> 等命名查询来操作数据库，稍后我们会看到定义在 Go 主机程序中的查询。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use suborbital::runnable::*;
use suborbital::db;
use suborbital::util;
use suborbital::db::query;
use suborbital::log;
use uuid::Uuid;

struct RsDbtest{}

impl Runnable for RsDbtest {
  fn run(&amp;self, _: Vec&lt;u8&gt;) -&gt; Result&lt;Vec&lt;u8&gt;, RunErr&gt; {
    let uuid = Uuid::new_v4().to_string();

    let mut args: Vec&lt;query::QueryArg&gt; = Vec::new();
    args.push(query::QueryArg::new(&quot;uuid&quot;, uuid.as_str()));
    args.push(query::QueryArg::new(&quot;email&quot;, &quot;connor@suborbital.dev&quot;));

    match db::insert(&quot;PGInsertUser&quot;, args) {
      Ok(_) =&gt; log::info(&quot;insert successful&quot;),
      Err(e) =&gt; {
        return Err(RunErr::new(500, e.message.as_str()))
      }
    };

    let mut args2: Vec&lt;query::QueryArg&gt; = Vec::new();
    args2.push(query::QueryArg::new(&quot;uuid&quot;, uuid.as_str()));

    match db::update(&quot;PGUpdateUserWithUUID&quot;, args2.clone()) {
      Ok(rows) =&gt; log::info(format!(&quot;update: {}&quot;, util::to_string(rows).as_str()).as_str()),
      Err(e) =&gt; {
        return Err(RunErr::new(500, e.message.as_str()))
      }
    }

    match db::select(&quot;PGSelectUserWithUUID&quot;, args2.clone()) {
      Ok(result) =&gt; log::info(format!(&quot;select: {}&quot;, util::to_string(result).as_str()).as_str()),
      Err(e) =&gt; {
        return Err(RunErr::new(500, e.message.as_str()))
      }
    }

    match db::delete(&quot;PGDeleteUserWithUUID&quot;, args2.clone()) {
      Ok(rows) =&gt; log::info(format!(&quot;delete: {}&quot;, util::to_string(rows).as_str()).as_str()),
      Err(e) =&gt; {
        return Err(RunErr::new(500, e.message.as_str()))
      }
    }

    ... ...
  }
}
<span class="boring">}
</span></code></pre></pre>
<p>让我们把这个 Rust 函数构建为 WebAssembly 字节码文件。</p>
<pre><code class="language-bash">cd rs-db
cargo build --target wasm32-wasi --release
cp target/wasm32-wasi/release/rs_db.wasm ..
cd ..
</code></pre>
<h3 id="数据库查询go-主机程序"><a class="header" href="#数据库查询go-主机程序">数据库查询：Go 主机程序</a></h3>
<p>在这个 <a href="https://github.com/second-state/wasm-learning/blob/master/reactr/db/main.go">Go 主机程序</a>中，我们首先定义了几个 SQL 查询，并为其命名。
我们将把这些查询作为配置传入 Reactr 运行时。</p>
<pre><code class="language-go">func main() {
  dbConnString, exists := os.LookupEnv(&quot;REACTR_DB_CONN_STRING&quot;)
  if !exists {
    fmt.Println(&quot;skipping as conn string env var not set&quot;)
    return
  }

  q1 := rcap.Query{
    Type:     rcap.QueryTypeInsert,
    Name:     &quot;PGInsertUser&quot;,
    VarCount: 2,
    Query: `
    INSERT INTO users (uuid, email, created_at, state, identifier)
    VALUES ($1, $2, NOW(), 'A', 12345)`,
  }

  q2 := rcap.Query{
    Type:     rcap.QueryTypeSelect,
    Name:     &quot;PGSelectUserWithUUID&quot;,
    VarCount: 1,
    Query: `
    SELECT * FROM users
    WHERE uuid = $1`,
  }

  q3 := rcap.Query{
    Type:     rcap.QueryTypeUpdate,
    Name:     &quot;PGUpdateUserWithUUID&quot;,
    VarCount: 1,
    Query: `
    UPDATE users SET state='B' WHERE uuid = $1`,
  }

  q4 := rcap.Query{
    Type:     rcap.QueryTypeDelete,
    Name:     &quot;PGDeleteUserWithUUID&quot;,
    VarCount: 1,
    Query: `
    DELETE FROM users WHERE uuid = $1`,
  }

  config := rcap.DefaultConfigWithDB(vlog.Default(), rcap.DBTypePostgres, dbConnString, []rcap.Query{q1, q2, q3, q4})

  r, err := rt.NewWithConfig(config)
  if err != nil {
    fmt.Println(err)
    return
  }

  ... ...
}
</code></pre>
<p>接下来便可以在 Reactr 中运行这个 WebAssembly 函数了。</p>
<pre><code class="language-go">func main() {
  ... ...

  doWasm := r.Register(&quot;rs-db&quot;, rwasm.NewRunner(&quot;./rs_db.wasm&quot;))

  res, err := doWasm(nil).Then()
  if err != nil {
    fmt.Println(err)
    return
  }

  fmt.Println(string(res.([]byte)))
}
</code></pre>
<p>最后，让我们运行 Go 主机程序并观察控制台中打印出的结果。</p>
<blockquote>
<p>只有在设置了 <code>-tags wasmedge</code> 这一标签后，你才能获得 WasmEdge 提供的性能优势以及拓展 WebAssembly API。</p>
</blockquote>
<pre><code class="language-bash">export REACTR_DB_CONN_STRING='postgresql://postgres:12345@127.0.0.1:5432/reactr'
go mod tidy
go run -tags wasmedge main.go
</code></pre>
<h2 id="在-go-中嵌入-javascript"><a class="header" href="#在-go-中嵌入-javascript">在 Go 中嵌入 JavaScript</a></h2>
<p>我们前面提过，WasmEdge 运行时的一大特点就是它<a href="frameworks/app/../../dev/js.html">对 JavaScript 的高级支持</a>，这使得我们能在轻量、高性能、安全、支持多语言的<a href="frameworks/app/../../kubernetes.html">Kubernetes 管理的 WasmEdge 容器</a>中运行 JavaScript 程序。
你可以在<a href="https://github.com/second-state/wasm-learning/tree/master/reactr/quickjs">这里</a>找到一个在 Reactr 中嵌入的 JavaScript 函数示例。</p>
<h3 id="javascript-示例-1"><a class="header" href="#javascript-示例-1">JavaScript 示例</a></h3>
<p>这个<a href="https://github.com/second-state/wasm-learning/tree/master/reactr/quickjs/hello.js">示例函数</a>十分简单，仅仅是返回一个字符串值。</p>
<pre><code class="language-javascript">let h = 'hello';
let w = 'wasmedge';
`${h} ${w}`;
</code></pre>
<h3 id="javascript-示例go-主机程序"><a class="header" href="#javascript-示例go-主机程序">JavaScript 示例：Go 主机程序</a></h3>
<p>这个 <a href="https://github.com/second-state/wasm-learning/tree/master/reactr/quickjs/main.go">Go 主机程序</a> 使用了 Reactr API 来运行 WasmEdge 的标准 JavaScript 解释器（<a href="https://github.com/second-state/wasm-learning/blob/master/reactr/quickjs/rs_embed_js.wasm">rs_embed_js.wasm</a>）。你也可以通过修改这个 <a href="https://github.com/second-state/wasm-learning/tree/master/reactr/quickjs/rs-embed-js">Rust 项目</a> 来使用其他版本的 JavaScript 解释器。</p>
<blockquote>
<p>你可以点击这两个超链接来了解如何<a href="https://github.com/second-state/wasmedge-quickjs/tree/main/examples/embed_js">将 JavaScript 代码嵌入 Rust</a> 以及<a href="frameworks/app/../../dev/js/rust.html">使用 Rust 实现 JavaScript API</a>。</p>
</blockquote>
<p>Go 主机程序只需要启动 <code>rs_embed_js.wasm</code> 的任务并将 JavaScript 内容传入它。接下来可以用 Go 程序来捕获并打印出返回值。</p>
<pre><code class="language-go">func main() {
  r := rt.New()
  doWasm := r.Register(&quot;hello-quickjs&quot;, rwasm.NewRunner(&quot;./rs_embed_js.wasm&quot;))

  code, err := ioutil.ReadFile(os.Args[1])
  if err != nil {
    fmt.Print(err)
  }
  res, err := doWasm(code).Then()
  if err != nil {
    fmt.Println(err)
    return
  }

  fmt.Println(string(res.([]byte)))
}
</code></pre>
<p>使用下面的命令运行 Go 主机程序。</p>
<pre><code class="language-bash">$ cd quickjs
$ go mod tidy
$ go run -tags wasmedge main.go hello.js
String(JsString(hello wasmedge))
</code></pre>
<p>打印出来的结果中包含了 Rust 和 Go API 中的字符串类型信息。你可以对 Rust / Go 程序进行修改来将其移除。</p>
<h3 id="javascript-示例功能实例"><a class="header" href="#javascript-示例功能实例">JavaScript 示例：功能实例</a></h3>
<p>WasmEdge 支持许多 JavaScript 高级特性。在了解了上面的三个简单例子后，你可以尝试使用我们的 <a href="https://github.com/second-state/wasmedge-quickjs/tree/main/example_js/react_ssr">React SSR 示例</a>来通过一个 Reactr 函数生成 HTML UI。
你可以只从 React SSR 示例中构建 <code>dist/main.js</code>，并将其复制到这个示例的文件夹中，然后你就能让它工作起来了！</p>
<pre><code class="language-bash">$ cd quickjs
# 从 react ssr 示例中拷贝出 dist/main.js
$ go mod tidy
$ go run -tags wasmedge main.go main.js
&lt;div data-reactroot=&quot;&quot;&gt;&lt;div&gt;This is home&lt;/div&gt;&lt;div&gt;&lt;div&gt;This is page&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;
UnDefined
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="serverless-平台"><a class="header" href="#serverless-平台">Serverless 平台</a></h1>
<p>在云原生基础设施中，我们希望将 WebAssembly 作为轻量级运行时的替代方案，与 Docker 和 microVMs 一同使用。WebAssembly 提供了比类似 Docker 的容器或 microVMs 更高的性能和更少的资源消耗。然而，公有云只支持在 microVM 中运行 WebAssembly。尽管如此，在 microVM 中运行 WebAssembly 函数仍然比与运行容器化的 NaCI 程序有诸多优势。</p>
<p>与直接在 Docker 容器中运行 NaCI 程序相比，在类似 Docker 的容器中运行 WebAssembly 函数具有如下优势：</p>
<p><strong>首先</strong>，WebAssembly 为单个函数提供细粒度的运行时隔离。一个微服务可以在一个类似 Docker 的容器中运行多个函数和支持服务。WebAssembly 可以使微服务更安全、更稳定。</p>
<p><strong>第二点</strong>，WebAssembly 字节码是可移植的。开发人员只需构建一次，无需担心底层 Vercel serverless 容器（操作系统和硬件）的修改或更新。它还允许开发人员在其他云环境中复用相同的 WebAssembly 函数功能。</p>
<p><strong>第三点</strong>，WebAssembly 应用程序易于部署和管理。与 NaCI 动态库和可执行文件相比，它们的平台依赖性和复杂性要少得多。</p>
<p><strong>最后</strong>，<a href="https://www.secondstate.io/articles/wasi-tensorflow/">WasmEdge Tensorflow API</a> 提供了用 Rust 语言编写的示例，以最符合人类的思维方式来执行 Tensorflow 模型。WasmEdge 安装了使用 Tensorflow 所需的依赖库，并为开发人员提供了统一的 API。</p>
<p>在本节中，我们将向你展示如何在公有云中运行 WebAssembly serverless 函数。每个平台都有其对应的代码模板，其中包含两个 Rust 语言示例，一个是正常的图像处理，另一个是使用 WasmEdge TensorFlow SDK 的 TensorFlow 推理。</p>
<ul>
<li><a href="frameworks/serverless/vercel.html">Vercel</a> 如何利用 WasmEdge 加载在 Vercel 上部署的 Jamstack 应用程序</li>
<li><a href="frameworks/serverless/netlify.html">Netlify</a> 如何利用 WasmEdge 加载在 Netlify 上部署的 Jamstack 应用程序</li>
<li><a href="frameworks/serverless/aws.html">AWS Lambda</a> 如何利用 WasmEdge 加载在 AWS Lambda 上部署的 serverless 函数</li>
<li><a href="frameworks/serverless/tencent.html">Tencent</a> 如何利用 WasmEdge 加载在腾讯云上部署的 serverless 函数</li>
</ul>
<blockquote>
<p>如果你想在公有云平台上添加更多 WasmEdge 示例，比如谷歌云，请随时为 WasmEdge 创建一个 PR，并让社区知道你做了什么。</p>
</blockquote>
<p><img src="frameworks/serverless-wasmedge.png" alt="serverless-wasmedge.png" /></p>
<p>在公有云上的 Docker 容器中运行 WasmEdge，是 web 应用程序提高性能的一种简单方法。展望未来，更好的方法是使用 <a href="https://www.computer.org/csdl/magazine/so/5555/01/09214403/1nHNGfu2Ypi">WasmEdge 作为容器</a>。不需要 Docker 和 Node.js 来引入 WasmEdge。这样，我们可以更加高效的执行 serverless 函数。</p>
<ul>
<li><a href="frameworks/serverless/secondstate.html">Second State Functions</a> 将讨论如何使用 WasmEdge 作为容器，因为 Second State Functions 是一个纯 WebAssembly/WasmEdge 的 serverless 平台。</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="vercel"><a class="header" href="#vercel">Vercel</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="netlify"><a class="header" href="#netlify">Netlify</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="aws"><a class="header" href="#aws">AWS</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tencent"><a class="header" href="#tencent">Tencent</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="second-state-函数"><a class="header" href="#second-state-函数">Second State 函数</a></h1>
<p>Second State 函数由 WasmEdge 驱动，并且支持 Rust 语言作为其一等公民。</p>
<p>它可以</p>
<ul>
<li><a href="https://www.secondstate.io/articles/getting-started-with-function-as-a-service-in-rust/">处理基于文本的输入和输出</a></li>
<li><a href="https://www.secondstate.io/articles/use-binary-data-as-function-input-and-output/">使用二进制数据作为函数输入和输出</a></li>
<li><a href="https://www.secondstate.io/articles/use-binary-data-as-function-input-and-output/">在函数参数和返回值中混合字节和字符串类型</a></li>
<li><a href="https://www.secondstate.io/articles/internet-of-functions-webhooks/">使用 webhooks 作为函数输入和输出</a></li>
<li><a href="https://www.secondstate.io/articles/internet-of-functions-http-proxy/">通过 <code>http_proxy</code> API 来访问互联网资源</a></li>
<li><a href="https://www.secondstate.io/articles/wasi-tensorflow/">通过 WasmEdge TensorFlow API 以原生速度运行 TensorFlow 模型</a></li>
</ul>
<p>查看 <a href="https://www.secondstate.io/faas/">Second State Functions</a> 官网内容来获得更多教程。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="操作系统"><a class="header" href="#操作系统">操作系统</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="linux"><a class="header" href="#linux">Linux</a></h1>
<p>WasmEdge 支持广泛的2007年之后的 Linux 发行版。官方发布包包含静态链接的二进制文件和库，适用于旧的 Linux 系统。
下表展示了 WasmEdge 官方发布包中的构建目标。</p>
<div class="table-wrapper"><table><thead><tr><th>镜像 tag</th><th>指令集架构</th><th>基础操作系统</th><th>LLVM 版本</th><th>环境变量</th><th>兼容性</th><th>说明</th></tr></thead><tbody>
<tr><td><code>latest</code></td><td>x86_64</td><td>Ubuntu 20.04 LTS</td><td>12.0.0</td><td>CC=clang, CXX=clang++</td><td>Ubuntu 20.04+</td><td>始终使用最新的 Ubuntu 版本提供给 CI</td></tr>
<tr><td><code>ubuntu-build-gcc</code></td><td>x86_64</td><td>Ubuntu 20.04 LTS</td><td>12.0.0</td><td>CC=gcc, CXX=g++</td><td>Ubuntu 20.04+</td><td>始终使用最新的 Ubuntu 版本提供给 CI</td></tr>
<tr><td><code>ubuntu-build-clang</code></td><td>x86_64</td><td>Ubuntu 20.04 LTS</td><td>12.0.0</td><td>CC=clang, CXX=clang++</td><td>Ubuntu 20.04+</td><td>始终使用最新的 Ubuntu 版本提供给 CI</td></tr>
<tr><td><code>ubuntu2004_x86_64</code></td><td>x86_64</td><td>Ubuntu 20.04 LTS</td><td>10.0.0</td><td>CC=gcc, CXX=g++</td><td>Ubuntu 20.04+</td><td>提供给熟悉 Ubuntu 20.04 LTS 版本的开发者</td></tr>
<tr><td><code>ubuntu2104_armv7l</code></td><td>armhf</td><td>Ubuntu 21.04</td><td>12.0.0</td><td>CC=gcc, CXX=g++</td><td>Ubuntu 21.04+</td><td>提供给 armhf 发布的版本</td></tr>
<tr><td><code>manylinux2014_x86_64</code></td><td>x86_64</td><td>CentOS 7, 7.9.2009</td><td>12.0.0</td><td>CC=gcc, CXX=g++</td><td>Ubuntu 16.04+, CentOS 7+</td><td>提供给熟悉 X86_64 架构的 CentOS 的开发者</td></tr>
<tr><td><code>manylinux2014_aarch64</code></td><td>aarch64</td><td>CentOS 7, 7.9.2009</td><td>12.0.0</td><td>CC=gcc, CXX=g++</td><td>Ubuntu 16.04+, CentOS 7+</td><td>提供给熟悉 Aarch64 架构的 CentOS 的开发者</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="windows"><a class="header" href="#windows">Windows</a></h1>
<p>WasmEdge 提供了一个标准的 Windows PowerShell 二进制构建程序作为其官方发布包的一部分。你可以通过我们的标准安装脚本来安装它。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mac"><a class="header" href="#mac">Mac</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="android"><a class="header" href="#android">Android</a></h1>
<p>在 WasmEdge 发布版本中具有用于 Android 操作系统的预构建二进制文件。但是，WasmEdge installer 不支持 Android。 用户必须将发布文件下载到计算机，然后使用 <code>adb</code> 工具将文件传输到 Android 设备或模拟器。我们将向您展示如何做到这一点。</p>
<blockquote>
<p>如果您更喜欢自己构建适用于 Android 的 WasmEdge Runtime 二进制文件，可以参考 <a href="os/../extend/build_for_android.html">build WasmEdge for Android</a> 文档。</p>
</blockquote>
<ul>
<li><a href="os/android/cli.html">适用于 Android 的 WasmEdge CLI 工具</a></li>
<li><a href="os/android/ndk.html">从 NDK 原生应用调用 WasmEdge 函数</a></li>
<li><a href="os/android/studio.html">从 Android APK 应用调用 WasmEdge 函数</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="wasmedge-on-sel4"><a class="header" href="#wasmedge-on-sel4">WasmEdge on seL4</a></h1>
<p><a href="https://youtu.be/2Qu-Trtkspk">视频演示</a> | <a href="https://github.com/second-state/wasmedge-seL4/runs/3982081148?check_suite_focus=true">Build logs</a> | <a href="https://github.com/second-state/wasmedge-seL4/actions/runs/1374510169">Build artifact</a></p>
<p>在本文中，我们演示了如何在 seL4 RTOS 上运行 WasmEdge，分为两部分：</p>
<ol>
<li>seL4 上的 Guest Linux OS：这是 WasmEdge runtime 的控制器，它将把 wasm 程序发送到作为 seL4 上的代理的 WasmEdge runner 来执行。</li>
<li>seL4 上的 WasmEdge runner：这是 wasm 程序运行时，它将从 Guest Linux OS 执行给定的 wasm 程序。</li>
</ol>
<p>下图说明了系统的架构。</p>
<p><img src="os/wasmedge-sel4.png" alt="wasmedge-sel4" /></p>
<p>该演示基于 Linux 上的 seL4 模拟器。</p>
<h2 id="快速开始-11"><a class="header" href="#快速开始-11">快速开始</a></h2>
<h3 id="系统要求"><a class="header" href="#系统要求">系统要求</a></h3>
<p>硬件:</p>
<ul>
<li>至少 4GB 的 内存</li>
<li>至少 20GB 的磁盘存储空间（以下安装完成后 wasmedge_sel4 目录将包含超过 11GB 的数据）</li>
</ul>
<p>软件: 安装了开发工具包（例如：Python）的 Ubuntu 20.04。 我们推荐 <a href="https://github.com/actions/virtual-environments/blob/main/images/linux/Ubuntu2004-README.md">GitHub Actions Ubuntu 20.04 VM</a> (查看 <a href="https://github.com/actions/virtual-environments/blob/main/images/linux/Ubuntu2004-README.md#installed-apt-packages">已安装的 apt 包</a> 列表). 或者，你可以使用我们的 Docker 镜像 (查看 <a href="https://github.com/second-state/wasmedge-seL4/blob/main/docs/Dockerfile.sel4_build">Dockerfile</a>).</p>
<pre><code class="language-bash">$ docker pull wasmedge/sel4_build
$ docker run --rm -v $(pwd):/app -it wasmedge/sel4_build
(docker) root#
</code></pre>
<blockquote>
<p>如果你不想自己搭建 seL4 系统模拟器，你可以从我们的 GitHub Actions 下载 <a href="https://github.com/second-state/wasmedge-seL4/actions/runs/1374510169">build artifact</a>, 并直接跳到 <a href="os/sel4.html#boot-wasmedge-sel4">启动-wasmedge-seL4</a>。</p>
</blockquote>
<h3 id="自动安装一体化脚本"><a class="header" href="#自动安装一体化脚本">自动安装：一体化脚本</a></h3>
<p>使用我们的一体化构建脚本：</p>
<pre><code class="language-bash">wget -qO- https://raw.githubusercontent.com/second-state/wasmedge-seL4/main/build.sh | bash
</code></pre>
<p>这将在 seL4 上克隆并构建 wasmedge 到镜像。</p>
<p>完成构建脚本后，你会生成一个文件夹 <code>sel4_wasmedge</code>.</p>
<p>如果此自动安装成功完成，请跳过手动安装信息并继续 <a href="https://github.com/second-state/wasmedge-seL4#boot-wasmedge-sel4">启动-wasmedge-sel4</a></p>
<h3 id="手动安装管理内存使用"><a class="header" href="#手动安装管理内存使用">手动安装：管理内存使用</a></h3>
<p>上述一体化脚本在大多数情况下都可以使用。 但是，如果你的系统资源紧张并且遇到错误，例如 <code>ninja: build stopped: subcommand failed</code>，请注意，你可以通过将 <code>-j</code> 参数显式传递给 <code>ninja</code> 命令（在 <code>build.sh</code> 文件的最后一行）来降低安装的并行度。 你会看到，Ninja 默认运行最多的并行进程，因此以下过程是一种显式设置/减少并行化的方法。</p>
<p>手动拉取 <code>wasmedge-sel4</code> 仓库。</p>
<pre><code class="language-bash">cd ~
git clone https://github.com/second-state/wasmedge-seL4.git
cd wasmedge-seL4
</code></pre>
<p>手动编辑 <code>build.sh</code> 文件。</p>
<pre><code class="language-bash">vi build.sh
</code></pre>
<p>将以下 <code>-j</code> 参数添加到文件的最后一行，即：</p>
<pre><code class="language-bash">ninja -j 2
</code></pre>
<p>使 <code>build.sh</code> 文件可执行。</p>
<pre><code class="language-bash">sudo chmod a+x build.sh
</code></pre>
<p>运行编辑后的 <code>build.sh</code> 文件。</p>
<pre><code class="language-bash">./build.sh
</code></pre>
<p>完成此手动安装后，请按照以下步骤操作； 启动-wasmedge-sel4；</p>
<h3 id="启动-wasmedge-sel4"><a class="header" href="#启动-wasmedge-sel4">启动-wasmedge-seL4</a></h3>
<pre><code class="language-bash">cd sel4_wasmedge/build
./simulate
</code></pre>
<p>预计输出：</p>
<pre><code class="language-bash">$ ./simulate: qemu-system-aarch64 -machine virt,virtualization=on,highmem=off,secure=off -cpu cortex-a53 -nographic  -m size=2048  -kernel images/capdl-loader-image-arm-qemu-arm-virt
ELF-loader started on CPU: ARM Ltd. Cortex-A53 r0p4
  paddr=[6abd8000..750cf0af]
No DTB passed in from boot loader.
Looking for DTB in CPIO archive...found at 6ad18f58.
Loaded DTB from 6ad18f58.
   paddr=[60243000..60244fff]
ELF-loading image 'kernel' to 60000000
  paddr=[60000000..60242fff]
  vaddr=[ff8060000000..ff8060242fff]
  virt_entry=ff8060000000
ELF-loading image 'capdl-loader' to 60245000
  paddr=[60245000..6a7ddfff]
  vaddr=[400000..a998fff]
  virt_entry=408f38
Enabling hypervisor MMU and paging
Jumping to kernel-image entry point...

Bootstrapping kernel
Warning: Could not infer GIC interrupt target ID, assuming 0.
Booting all finished, dropped to user space
&lt;&lt;seL4(CPU 0) [decodeUntypedInvocation/205 T0xff80bf85d400 &quot;rootserver&quot; @4006f8]: Untyped Retype: Insufficient memory (1 * 2097152 bytes needed, 0 bytes available).&gt;&gt;
Loading Linux: 'linux' dtb: 'linux-dtb'

...(omitted)...

Starting syslogd: OK
Starting klogd: OK
Running sysctl: OK
Initializing random number generator... [    3.512482] random: dd: uninitialized urandom read (512 bytes read)
done.
Starting network: OK
[    4.086059] connection: loading out-of-tree module taints kernel.
[    4.114686] Event Bar (dev-0) initalised
[    4.123771] 2 Dataports (dev-0) initalised
[    4.130626] Event Bar (dev-1) initalised
[    4.136096] 2 Dataports (dev-1) initalised

Welcome to Buildroot
buildroot login:
</code></pre>
<h3 id="在-guest-linux-上登录"><a class="header" href="#在-guest-linux-上登录">在 guest linux 上登录</a></h3>
<p>输入 <code>root</code> 登录</p>
<pre><code class="language-bash">buildroot login: root
</code></pre>
<p>预计输出：</p>
<pre><code class="language-bash">buildroot login: root
#
</code></pre>
<h3 id="执行-wasm-示例"><a class="header" href="#执行-wasm-示例">执行 wasm 示例</a></h3>
<h4 id="示例-a-nbody-cwasm"><a class="header" href="#示例-a-nbody-cwasm">示例 A: nbody-c.wasm</a></h4>
<p>运行 nbody 模拟。</p>
<pre><code class="language-bash">wasmedge_emit /usr/bin/nbody-c.wasm 10
</code></pre>
<p>预计输出：</p>
<pre><code class="language-bash">[1900-01-00 00:00:00.000] [info] executing wasm file
-0.169075164
-0.169073022
[1900-01-00 00:00:00.000] [info] execution success, exit code:0
</code></pre>
<h4 id="示例-b-hellowasm"><a class="header" href="#示例-b-hellowasm">示例 B: hello.wasm</a></h4>
<p>运行一个简单的应用程序来打印 <code>hello, sel4</code> 和一个简单的计算。</p>
<pre><code class="language-bash">wasmedge_emit /usr/bin/hello.wasm
</code></pre>
<p>预计输出：</p>
<pre><code class="language-bash">[1900-01-00 00:00:00.000] [info] executing wasm file
hello, sel4
1+2-3*4 = -9
[1900-01-00 00:00:00.000] [info] execution success, exit code:0
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="open-harmony"><a class="header" href="#open-harmony">Open Harmony</a></h1>
<h2 id="从源码在-openharmony-standard-上构建和测试-wasmedge"><a class="header" href="#从源码在-openharmony-standard-上构建和测试-wasmedge">从源码在 OpenHarmony Standard 上构建和测试 WasmEdge</a></h2>
<p>请参考这个教程来从源码在 OpenHarmony 标准系统中构建和测试 WasmEdge</p>
<h2 id="环境准备-1"><a class="header" href="#环境准备-1">环境准备</a></h2>
<h3 id="openharmony-标准系统"><a class="header" href="#openharmony-标准系统">OpenHarmony 标准系统</a></h3>
<p>OpenHarmony 标准系统为开发者提供的 Docker 环境将对应的编译工具链进行了封装，本文档主要介绍在 Docker 环境下构建 WasmEdge 的步骤.</p>
<p>OpenHarmony 源码的获取与编译可以参考文档 <a href="https://www.openharmony.cn/pages/00010102/">搭建Ubuntu环境-Docker方式</a></p>
<p>请注意，在构建 WasmEdge 前需要将 Openharmony 进行一次全量编译以便后续WasmEdge的交叉编译过程.</p>
<pre><code class="language-bash"># 获取到 docker 镜像后
$ docker run -it -v $(pwd):/home/openharmony openharmony-docker-standard:0.0.5
(root@xxxxxx:/home/openharmony/)$ ./build.sh --product-name Hi3516DV300
</code></pre>
<h2 id="获取源码"><a class="header" href="#获取源码">获取源码</a></h2>
<p>OpenHarmony 将三方库项目放在了 third_party 文件夹下，因此本文档在 third_party 文件夹下获取 WasmEdge 源码，用户可以根据需要更改路径并修改相关配置文件中的路径。</p>
<pre><code class="language-bash">$ docker run -it -v $(pwd):/home/openharmony openharmony-docker-standard:0.0.5
(root@xxxxxx:/home/openharmony)$ cd third_party
(root@xxxxxx:/home/openharmony/third_party)$ git clone https://github.com/WasmEdge/WasmEdge.git
(root@xxxxxx:/home/openharmony/third_party)$ cd WasmEdge
(root@xxxxxx:/home/openharmony/third_party/WasmEdge)$ 
</code></pre>
<h2 id="修改-openharmony-标准系统配置文件"><a class="header" href="#修改-openharmony-标准系统配置文件">修改 OpenHarmony 标准系统配置文件</a></h2>
<h3 id="添加-wasmedge-子系统配置"><a class="header" href="#添加-wasmedge-子系统配置">添加 WasmEdge 子系统配置</a></h3>
<p>修改 OpenHarmony 的 build 目录下的 <code>subsystem_config.json</code> 文件，添加 <code>wasmedge</code> 子系统。</p>
<pre><code class="language-json">{
  ...
  
  &quot;wasmedge&quot;: {
    &quot;path&quot;: &quot;third_party/WasmEdge&quot;,
    &quot;name&quot;: &quot;wasmedge&quot;
  },
  
  ...
}
</code></pre>
<h3 id="将组件添加到产品配置中"><a class="header" href="#将组件添加到产品配置中">将组件添加到产品配置中</a></h3>
<p>修改 OpenHarmony 产品配置文件，标准系统对应的配置文件：<code>productdefine/common/products/Hi3516DV300.json</code>。
在该配置文件中添加 <code>&quot;wasmedge:wasmedge&quot;:{}</code>，表示该产品中会编译并打包 wasmedge 子系统下的 <code>wasmedge</code> 模块到版本中。</p>
<pre><code class="language-json">{
  ...
  &quot;parts&quot;:{
    ...
    &quot;wasmedge:wasmedge&quot;:{}
  }
}
</code></pre>
<h2 id="构建-wasmedge"><a class="header" href="#构建-wasmedge">构建 WasmEdge</a></h2>
<h3 id="说明"><a class="header" href="#说明">说明</a></h3>
<p>在 OpenHarmony 中构建的 WasmEdge 目前仅支持 <code>wasmedge</code>，即 wasm 的通用运行时。</p>
<ul>
<li><code>wasmedge</code> 可以在解释器模式下执行一个 <code>WASM</code> 文件， 也可以在预编译模式下执行通用 Wasm 二进制格式文件， 目前还不支持在 OpenHarmony 中使用预编译模式 。</li>
</ul>
<h3 id="执行构建脚本"><a class="header" href="#执行构建脚本">执行构建脚本</a></h3>
<p>通过执行 WasmEdge 源码下的 <code>utils/build_for_ohos.sh</code> 命令行脚本，将自动执行以下工作：</p>
<ol>
<li>将 .gn 等 OpenHarmony 需要的构建配置文件移动到 WasmEdge 项目根目录。</li>
<li>使用 OpenHarmony 的编译工具链进行交叉编译构建 WasmEdge。</li>
<li>运行 OpenHarmony 的构建脚本 <code>build.sh</code> 进行全量编译，该步骤将 <code>wasmedge</code> 添加进 OpenHarmony OS。</li>
</ol>
<pre><code class="language-bash">$ docker run -it -v $(pwd):/home/openharmony openharmony-docker-standard:0.0.5
(root@xxxxxx:/home/openharmony)$ cd third_party/WasmEdge/utils/ohos
(root@xxxxxx:/home/openharmony/third_party/WasmEdge/utils/ohos)$ ./build_for_ohos.sh /home/openharmony
</code></pre>
<p>当显示以下信息时，表明编译完成.</p>
<pre><code class="language-bash">...

post_process
=====build Hi3516DV300 successful.
2021-12-15 03:18:50
++++++++++++++++++++++++++++++++++++++++

</code></pre>
<p>检查 <code>wasmedge</code> 是否编译打包进 OpenHarmony OS。</p>
<pre><code class="language-bash">(root@xxxxxx:/home/openharmony/third_party/WasmEdge/utils/ohos)$ cd /home/openharmony/out/ohos-arm-release/packages/phone/system/bin
(root@xxxxxx:/home/openharmony/out/ohos-arm-release/packages/phone/system/bin)$ ls 
</code></pre>
<p>当输出的文件名中存在 <code>wasmedge</code> ，表明成功加入 OpenHarmony OS。</p>
<h2 id="测试"><a class="header" href="#测试">测试</a></h2>
<h3 id="烧录镜像"><a class="header" href="#烧录镜像">烧录镜像</a></h3>
<p>将重新编译后的 OpenHarmony 标准系统镜像烧录进开发板，具体见 OpenHarmony 文档<a href="https://device.harmonyos.com/cn/docs/documentation/guide/hi3516_upload-0000001052148681">Hi3516DV300开发板烧录</a></p>
<h3 id="运行应用"><a class="header" href="#运行应用">运行应用</a></h3>
<p>在 OpenHarmony 标准系统中，WasmEdge 提供了测试样例，并写入了 system 镜像中，供用户进行测试。
通过串口工具连接上开发板并启动OpenHarmony标准系统后，用户可以进行以下测试。</p>
<pre><code class="language-bash">$ cd /system/usr/wasmedge_example
$ wasmedge hello.wasm 1 2 3
hello
1
2
3

$ wasmedge --reactor add.wasm add 2 2
4

$ wasmedge --reactor fibonacci.wasm fib 8
34

$ wasmedge --reactor factorial.wasm fac 12
479001600

$ cd js
$ wasmedge --dir .:. qjs.wasm hello.js 1 2 3
Hello 1 2 3
</code></pre>
<h2 id="开发"><a class="header" href="#开发">开发</a></h2>
<p>接下来，你可以使用 WasmEdge Runtime 在 OpenHarmony 标准系统中进行 WebAssembly 的相关开发工作。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="raspberry-pi-34"><a class="header" href="#raspberry-pi-34">Raspberry Pi 3/4</a></h1>
<p>Raspberry Pi 从 3 Model B 开始就使用 64-bit 处理器。WasmEdge 能够在 arm 64-bit 上运行，所以 WasmEdge 同样能够在 Raspberry Pi 上运行。你可以选择任何 64-bit Linux 发行版本，例如 Raspbian， Ubuntu 或者支持 ARM 的 Manjaro。当前文档已经在支持 ARM 的 Manjaro 发行版本和 Raspberry Pi 3 Model B 硬件上测试可行。</p>
<p>在 Raspberry Pi 上的安装步骤等同于<a href="https://wasmedge.org/book/en/start/install.html">安装文档</a>，执行过程也一样。以下有一个视频，通过安装 WasmEdge 和运行一个简单的 WebAssembly 模块实现两数相加的功能。</p>
<p><a href="https://asciinema.org/a/458453"><img src="https://asciinema.org/a/458453.svg" alt="asciicast" /></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="为-wasmedge-贡献代码"><a class="header" href="#为-wasmedge-贡献代码">为 WasmEdge 贡献代码</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="从源码构建和测试-wasmedge"><a class="header" href="#从源码构建和测试-wasmedge">从源码构建和测试 WasmEdge</a></h1>
<p>请参考这个教程来从源码构建和测试 WasmEdge</p>
<h2 id="获取源码-1"><a class="header" href="#获取源码-1">获取源码</a></h2>
<pre><code class="language-bash">git clone https://github.com/WasmEdge/WasmEdge.git
cd WasmEdge
</code></pre>
<h2 id="检查依赖"><a class="header" href="#检查依赖">检查依赖</a></h2>
<p>WasmEdge 会基于最新版本的 LLVM 来创建我们的每日构建。
如果你想从源码构建的话，需要自己手动来安装下面的这些依赖。你也可以直接使用我们提供的 Docker 镜像来构建， 它支持多个发行版本的 Linux 。</p>
<ul>
<li>LLVM 12.0.0 (&gt;= 10.0.0)</li>
<li>GCC 11.1.0 (&gt;= 9.4.0)</li>
</ul>
<h2 id="环境准备-2"><a class="header" href="#环境准备-2">环境准备</a></h2>
<h3 id="docker-镜像"><a class="header" href="#docker-镜像">Docker 镜像</a></h3>
<p>Dockerhub 上的仓库 <code>wasmedge/wasmedge</code></p>
<p>你可以使用下面的命令来获取我们最新的镜像：</p>
<pre><code class="language-bash">docker pull wasmedge/wasmedge # 等同于 wasmedge/wasmedge:latest
</code></pre>
<h4 id="可用的标签"><a class="header" href="#可用的标签">可用的标签</a></h4>
<div class="table-wrapper"><table><thead><tr><th>标签名</th><th>体系结构</th><th>基于的操作系统</th><th>LLVM 版本</th><th>环境配置</th><th>兼容性</th><th>备注</th></tr></thead><tbody>
<tr><td><code>latest</code></td><td>x86_64</td><td>Ubuntu 20.04 LTS</td><td>12.0.0</td><td>CC=clang, CXX=clang++</td><td>Ubuntu 20.04+</td><td>这个是用于持续集成的，会一直使用最新的 Ubuntu 版本</td></tr>
<tr><td><code>ubuntu-build-gcc</code></td><td>x86_64</td><td>Ubuntu 20.04 LTS</td><td>12.0.0</td><td>CC=gcc, CXX=g++</td><td>Ubuntu 20.04+</td><td>这个是用于持续集成的，会一直使用最新的 Ubuntu 版本</td></tr>
<tr><td><code>ubuntu-build-clang</code></td><td>x86_64</td><td>Ubuntu 20.04 LTS</td><td>12.0.0</td><td>CC=clang, CXX=clang++</td><td>Ubuntu 20.04+</td><td>这个是用于持续集成的，会一直使用最新的 Ubuntu 版本</td></tr>
<tr><td><code>ubuntu2004_x86_64</code></td><td>x86_64</td><td>Ubuntu 20.04 LTS</td><td>10.0.0</td><td>CC=gcc, CXX=g++</td><td>Ubuntu 20.04+</td><td>这个提供给熟悉 Ubuntu 20.04 LTS 版本的开发者使用</td></tr>
<tr><td><code>manylinux2014_x86_64</code></td><td>x86_64</td><td>CentOS 7, 7.9.2009</td><td>12.0.0</td><td>CC=gcc, CXX=g++</td><td>Ubuntu 16.04+, CentOS 7+</td><td>这个提供给熟悉 CentOS x86_64 架构的开发者使用</td></tr>
<tr><td><code>manylinux2014_aarch64</code></td><td>aarch64</td><td>CentOS 7, 7.9.2009</td><td>12.0.0</td><td>CC=gcc, CXX=g++</td><td>Ubuntu 16.04+, CentOS 7+</td><td>这个提供给熟悉 CentOS aarch64 架构的开发者使用</td></tr>
</tbody></table>
</div>
<h3 id="在-ubuntu-2004-上手动安装依赖"><a class="header" href="#在-ubuntu-2004-上手动安装依赖">在 Ubuntu 20.04 上手动安装依赖</a></h3>
<pre><code class="language-bash"># 工具和库
sudo apt install -y \
    software-properties-common \
    cmake \
    libboost-all-dev

# 你需要 llvm 来支持 wasmedgec 工具
sudo apt install -y \
    llvm-12-dev \
    liblld-12-dev

# WasmEdge 支持 clang++ 和 g++ 编译器
# 你可以选择其中任一个用来编译这个项目
# 如果你倾向于 GCC
sudo apt install -y gcc g++
# 或者你选择 clang
sudo apt install -y clang
</code></pre>
<h3 id="对过时操作系统的支持"><a class="header" href="#对过时操作系统的支持">对过时操作系统的支持</a></h3>
<p>我们的开发环境依赖于 <code>libLLVM-12</code> 和 <code>&gt;=GLIBCXX_3.4.33</code>。</p>
<p>如果用户的系统是比 Ubuntu 20.04 还早的版本，请使用我们定制的 docker 镜像来构建 WasmEdge 。
如果你需要的是在过时版本的操作系统上使用的二进制包，我们也提供了几个基于 manylinux* 发行版本的安装包。</p>
<div class="table-wrapper"><table><thead><tr><th>可移植的 Linux 发行版标签</th><th>基础镜像</th><th>提供的依赖</th><th>Docker 镜像</th></tr></thead><tbody>
<tr><td><code>manylinux2014</code></td><td>CentOS 7.9</td><td>GLIBC &lt;= 2.17</br>CXXABI &lt;= 1.3.7</br>GLIBCXX &lt;= 3.4.19</br>GCC &lt;= 4.8.0</td><td>wasmedge/wasmedge:manylinux2014_x86_64</td></tr>
<tr><td><code>manylinux2014</code></td><td>CentOS 7.9</td><td>GLIBC &lt;= 2.17</br>CXXABI &lt;= 1.3.7</br>GLIBCXX &lt;= 3.4.19</br>GCC &lt;= 4.8.0</td><td>wasmedge/wasmedge:manylinux2014_aarch64</td></tr>
</tbody></table>
</div>
<h2 id="构建-wasmedge-1"><a class="header" href="#构建-wasmedge-1">构建 WasmEdge</a></h2>
<p>WasmEdge 提供了丰富的工具来支撑更好的性能以及更多样的运行时环境，
编译完成后，你可以找到以下几个 WasmEdge 相关的工具：</p>
<ol>
<li><code>wasmedge</code> 是 wasm 的通用运行时。
<ul>
<li><code>wasmedge</code> 可以在解释器模式下执行一个 <code>WASM</code> 文件， 也可以在预编译模式下执行一个 WASM <code>so</code> 文件。</li>
<li>你可以通过将 CMAKE 配置项 <code>WASMEDGE_BUILD_TOOLS</code> 设置成 <code>OFF</code>来禁止所有工具的构建。</li>
</ul>
</li>
<li><code>wasmedgec</code> 是一个 <code>WASM</code> 预编译器。
<ul>
<li><code>wasmedgec</code> 将一个通用的 <code>WASM</code> 文件编译成 <code>so</code> 文件。</li>
<li>你可以通过将 CMAKE 配置项 <code>WASMEDGE_BUILD_AOT_RUNTIME</code> 设置成 <code>OFF</code>来禁止构建预编译器。</li>
</ul>
</li>
<li><code>libwasmedge.so</code> 是 WasmEdge C API 的共享库。
<ul>
<li><code>libwasmedge.so</code> 提供了访问预编译器和 WASM 运行时的 C 语言 API。</li>
<li>如果 <code>WASMEDGE_BUILD_AOT_RUNTIME</code> 配置项被设置成 <code>OFF</code>， 那么与预编译器相关的 API 都将会返回错误。</li>
</ul>
</li>
<li><code>ssvm-qitc</code> 是用来支持 AI 应用的，它支持基于 ONNX 格式的 AI 模型的 ONNC 运行时。
<ul>
<li>如果你想尝试使用 <code>ssvm-qitc</code>，请参考 <a href="https://github.com/ONNC/onnc-wasm">ONNC-Wasm</a> 项目来设置运行环境，并且运行几个示例。</li>
<li>这里是我们的 <a href="https://www.youtube.com/watch?v=cbiPuHMS-iQ">ONNC-Wasm 项目教程 （ YouTube 视频）</a> 。</li>
</ul>
</li>
</ol>
<pre><code class="language-bash"># 获取到 wasm docker 镜像后
docker run -it --rm \
    -v &lt;path/to/your/wasmedge/source/folder&gt;:/root/wasmedge \
    wasmedge/wasmedge:latest
# In docker
cd /root/wasmedge
mkdir -p build &amp;&amp; cd build
cmake -DCMAKE_BUILD_TYPE=Release -DWASMEDGE_BUILD_TESTS=ON .. &amp;&amp; make -j
</code></pre>
<h3 id="如果你不需要预编译运行时编译器"><a class="header" href="#如果你不需要预编译运行时编译器">如果你不需要预编译运行时/编译器</a></h3>
<p>如果用户不需要预编译运行时和编译器特性的话，可以将 CMAKE 配置项 <code>WASMEDGE_BUILD_AOT_RUNTIME</code> 设置成 <code>OFF</code>。</p>
<pre><code class="language-bash">cmake -DCMAKE_BUILD_TYPE=Release -DWASMEDGE_BUILD_AOT_RUNTIME=OFF ..
</code></pre>
<h2 id="执行内置的测试"><a class="header" href="#执行内置的测试">执行内置的测试</a></h2>
<p>下面所提到的测试只有在构建配置 <code>WASMEDGE_BUILD_TESTS</code> 设置为 <code>ON</code> 的时候才有效。</p>
<p>用户可以通过这些测试来验证 WasmEdge 二进制包的正确性。</p>
<pre><code class="language-bash">cd &lt;path/to/wasmedge/build_folder&gt;
LD_LIBRARY_PATH=$(pwd)/lib/api ctest
</code></pre>
<h2 id="运行应用-1"><a class="header" href="#运行应用-1">运行应用</a></h2>
<p>接下来，参考 <a href="extend/../index.html">这个文档</a> 在 <code>wasmedge</code> 上运行 WebAssembly 字节码程序。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="用-mac-编译"><a class="header" href="#用-mac-编译">用 Mac 编译</a></h1>
<p>目前，WasmEdge 项目同时支持 Intel 和 M1 型号的 MacOS。然而，我们只在 Big Sur 和 Catalina 上进行测试和开发。</p>
<ul>
<li>型号
<ul>
<li>Intel</li>
<li>M1</li>
</ul>
</li>
<li>操作系统
<ul>
<li>Big Sur</li>
<li>Catalina</li>
</ul>
</li>
</ul>
<p>如果您想在 MacOS 上开发 WasmEdge，请按照这个教程从源码进行构建和测试。</p>
<h2 id="获取源码-2"><a class="header" href="#获取源码-2">获取源码</a></h2>
<pre><code class="language-bash">git clone https://github.com/WasmEdge/WasmEdge.git
cd WasmEdge
</code></pre>
<h2 id="依赖组件"><a class="header" href="#依赖组件">依赖组件</a></h2>
<p>WasmEdge 会基于最新版本的 LLVM 来创建我们的每日构建。如果你想从源码构建的话，需要自己手动来安装下面的这些依赖。</p>
<ul>
<li>LLVM 12.0.0 (&gt;= 10.0.0)，使用 brew 安装，请勿使用系统自带的 LLVM。</li>
<li>因为最新版本 brew 中的 LLVM 默认版本是 13。请使用 <code>llvm@12</code> 来调整 LLVM 的版本。</li>
</ul>
<h3 id="环境准备-3"><a class="header" href="#环境准备-3">环境准备</a></h3>
<pre><code class="language-bash"># 工具和库
$ brew install boost cmake ninja llvm@12
# 使用 brew 版本的 llvm，而不是系统自带的 LLVM。
$ export PATH=&quot;/usr/local/opt/llvm@12/bin:$PATH&quot;
$ export LDFLAGS=&quot;-L/usr/local/opt/llvm@12/lib -Wl，-rpath，/usr/local/opt/llvm@12/lib&quot;
$ export CPPFLAGS=&quot;-I/usr/local/opt/llvm@12/include&quot;
</code></pre>
<h3 id="如果你不需要预编译的运行时编译器"><a class="header" href="#如果你不需要预编译的运行时编译器">如果你不需要预编译的运行时/编译器</a></h3>
<p>如果你不需要预编译运行时和编译器特性的话，你可以将 CMake 配置项 <code>WASMEDGE_BUILD_AOT_RUNTIME</code> 设置成 <code>OFF</code>。</p>
<pre><code class="language-bash">cmake -DCMAKE_BUILD_TYPE=Release -DWASMEDGE_BUILD_AOT_RUNTIME=OFF ..
</code></pre>
<h2 id="构建-wasmedge-2"><a class="header" href="#构建-wasmedge-2">构建 WasmEdge</a></h2>
<p>WasmEdge 提供了丰富的工具来支撑更好的性能以及更多样的运行时环境，编译完成后，你可以找到以下几个 WasmEdge 相关的工具：</p>
<ol>
<li><code>wasmedge</code> 是 wasm 的通用运行时。
<ul>
<li><code>wasmedge</code> 可以在解释器模式下执行一个 <code>WASM</code> 文件，也可以在预编译模式下执行一个 WASM <code>dyld</code> 文件。</li>
<li>你可以通过将 CMake 配置项 <code>WASMEDGE_BUILD_TOOLS</code> 设置成 <code>OFF</code> 来禁止构建所有工具。</li>
</ul>
</li>
<li><code>wasmedgec</code> 是一个 <code>WASM</code> 预编译器。
<ul>
<li><code>wasmedgec</code> 将一个通用的 <code>WASM</code> 文件编译成 <code>dyld</code> 文件。</li>
<li>你可以通过将 CMake 配置项 <code>WASMEDGE_BUILD_AOT_RUNTIME</code> 设置成 <code>OFF</code> 来禁止构建预编译器。</li>
</ul>
</li>
<li><code>libwasmedge.dyld</code> 是 WasmEdge C API 的共享库。
<ul>
<li><code>libwasmedge.dyld</code> 提供了访问预编译器和 WASM 运行时的 C 语言 API。</li>
<li>如果 <code>WASMEDGE_BUILD_AOT_RUNTIME</code> 配置项被设置成 <code>OFF</code> ，那么与预编译器相关的 API 都将会返回错误。</li>
<li>你可以通过将 CMake 配置项 <code>WASMEDGE_BUILD_SHARED_LIB</code> 设置成 <code>OFF</code> 来禁止构建共享库。</li>
</ul>
</li>
</ol>
<pre><code class="language-bash">cmake -Bbuild -GNinja -DWASMEDGE_BUILD_PACKAGE=&quot;TGZ&quot; -DWASMEDGE_BUILD_TESTS=ON .
cmake --build build
</code></pre>
<h2 id="运行内置测试"><a class="header" href="#运行内置测试">运行内置测试</a></h2>
<p>以下内置测试只有在构建标志 <code>WASMEDGE_BUILD_TESTS</code> 设置为 <code>ON</code> 时才可用。</p>
<p>用户可以通过这些测试来验证 WasmEdge 二进制包的正确性。</p>
<pre><code class="language-bash">export DYLD_LIBRARY_PATH=&quot;$(pwd)/build/lib/api:$DYLD_LIBRARY_PATH&quot;
cmake --build build --target test
</code></pre>
<h2 id="运行应用程序"><a class="header" href="#运行应用程序">运行应用程序</a></h2>
<p>接下来，参考<a href="extend/../index.html">这个文档</a>在 <code>wasmedge</code> 上运行 WebAssembly 字节码程序。</p>
<h2 id="已知问题"><a class="header" href="#已知问题">已知问题</a></h2>
<p>以下测试无法在 MacOS 上通过，我们正在调查这些问题：</p>
<ul>
<li>wasmedgeAPIVMCoreTests</li>
<li>wasmedgeAPIStepsCoreTests</li>
<li>wasmedgeAPIAOTCoreTests</li>
<li>wasmedgeProcessTests</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="在-windows-10由源码构建"><a class="header" href="#在-windows-10由源码构建">在 Windows 10由源码构建</a></h1>
<p>WasmEdge 支持 Windows 10 。我们也同时提供了二进制安装包和库文件。</p>
<p>可以在<a href="https://github.com/WasmEdge/WasmEdge/blob/master/.github/workflows/build.yml#L266-L322">这里</a>查看详情。</p>
<p>如果想要在 Windows 10 上开发 WasmEdge，请继续阅读本文以进行从源码构建和测试。</p>
<p>下文中将以 <code>AOT</code> 代替 <code>ahead-of-time</code> ，<code>ahead-of-time</code> 的含义是将 WASM 文件提前编译为机器码。</p>
<h2 id="下载源代码"><a class="header" href="#下载源代码">下载源代码</a></h2>
<pre><code class="language-bash">git clone https://github.com/WasmEdge/WasmEdge.git
cd WasmEdge
</code></pre>
<h2 id="依赖说明"><a class="header" href="#依赖说明">依赖说明</a></h2>
<p>WasmEdge 尝试用最新的 LLVM 发行版本来创建我们的 nightly 版本。</p>
<p>需要以下自行安装以下依赖才能编译源码：</p>
<ul>
<li>Chocolatey，用来安装 cmake、ninja 和 vswhere</li>
<li>Windows SDK 19041</li>
<li>LLVM 13.0.0，预编译版本在下节中提供</li>
</ul>
<h3 id="下载依赖"><a class="header" href="#下载依赖">下载依赖</a></h3>
<pre><code class="language-powershell"># 下载工具
choco install cmake ninja vswhere

$vsPath = (vswhere -latest -property installationPath)
Import-Module (Join-Path $vsPath &quot;Common7\Tools\Microsoft.VisualStudio.DevShell.dll&quot;)
Enter-VsDevShell -VsInstallPath $vsPath -SkipAutomaticLocation -DevCmdArguments &quot;-arch=x64 -host_arch=x64 -winsdk=10.0.19041.0&quot;

# 下载我们提供的预编译好的 LLVM 13
$llvm = &quot;LLVM-13.0.0-win64.zip&quot;
curl -sLO https://github.com/WasmEdge/llvm-windows/releases/download/llvmorg-13.0.0/LLVM-13.0.0-win64.zip -o $llvm
Expand-Archive -Path $llvm

# 设置 LLVM 环境变量
$llvm_dir = &quot;$pwd\\LLVM-13.0.0-win64\\LLVM-13.0.0-win64\\lib\\cmake\\llvm&quot;
$Env:CC = &quot;clang-cl&quot;
$Env:CXX = &quot;clang-cl&quot;
</code></pre>
<h3 id="如果不需要构建aot运行时或者编译器"><a class="header" href="#如果不需要构建aot运行时或者编译器">如果不需要构建AOT运行时或者编译器</a></h3>
<p>如果不需要 AOT 运行时或者编译器，可以将 CMake 选项 <code>WASMEDGE_BUILD_AOT_RUNTIME</code>  设置为 <code>OFF</code>。</p>
<pre><code class="language-bash">cmake -DCMAKE_BUILD_TYPE=Release -DWASMEDGE_BUILD_AOT_RUNTIME=OFF ..
</code></pre>
<h2 id="构建-wasmedge-3"><a class="header" href="#构建-wasmedge-3">构建 WasmEdge</a></h2>
<p>为应对不同的性能需求，WasmEdge 提供了多种运行时环境和工具。</p>
<p>构建成功后，你可以找到这些 wasmedge 相关工具：</p>
<ol>
<li><code>wasmedge</code>  是一个通用的 wasm 运行时。
<ul>
<li><code>wasmedge</code>  可以解释执行 <code>WASM</code>  文件或者以 AOT 模式执行一个编译过的 WASM <code>dyld</code> 文件。</li>
<li>在构建 WasmEdge 时，可以设置 CMake 选项 <code>WASMEDGE_BUILD_TOOLS</code> 为<code>OFF</code> 来不构建所有工具。</li>
</ul>
</li>
<li><code>wasmedgec</code> 是一个 AOT <code>WASM</code> 编译器。
<ul>
<li><code>wasmedgec</code> 将一个 <code>WASM</code> 格式的文件编译为<code>dll</code> 格式文件。</li>
<li>如果你不需要构建 AOT 编译器，可以将 CMake 选项 <code>WASMEDGE_BUILD_AOT_RUNTIME</code>  设置为  <code>OFF</code> 。</li>
</ul>
</li>
<li><code>wasmedge.dll</code> 是 WasmEdge 的 C API 共享库.
<ul>
<li><code>wasmedge.dll</code> 为 AOT 编译器和 WASM 运行时提供 C API。</li>
<li>CMake 选项 <code>WASMEDGE_BUILD_AOT_RUNTIME</code> 设置为 <code>OFF</code> 后，调用与 AOT 编译器相关的 API 只会返回失败值。</li>
<li>如果你不需要构建共享库，可以将 CMake 选项 <code>WASMEDGE_BUILD_SHARED_LIB</code>  设置为 <code>OFF</code> 。</li>
</ul>
</li>
</ol>
<pre><code class="language-bash">$vsPath = (vswhere -latest -property installationPath)
Import-Module (Join-Path $vsPath &quot;Common7\Tools\Microsoft.VisualStudio.DevShell.dll&quot;)
Enter-VsDevShell -VsInstallPath $vsPath -SkipAutomaticLocation -DevCmdArguments &quot;-arch=x64 -host_arch=x64 -winsdk=10.0.19041.0&quot;

cmake -Bbuild -GNinja -DCMAKE_SYSTEM_VERSION=10.0.19041.0 -DCMAKE_MSVC_RUNTIME_LIBRARY=MultiThreadedDLL &quot;-DLLVM_DIR=$llvm_dir&quot; -DWASMEDGE_BUILD_TESTS=ON -DWASMEDGE_BUILD_PACKAGE=&quot;ZIP&quot; .
cmake --build build
</code></pre>
<h2 id="运行内置测试-1"><a class="header" href="#运行内置测试-1">运行内置测试</a></h2>
<p>以下内置测试仅在 CMake 编译选项 <code>WASMEDGE_BUILD_TESTS</code>  为 <code>ON</code> 时可用。</p>
<p>用户可以用这些测试来验证自己构建的 WasmEdge 二进制文件的正确性。</p>
<pre><code class="language-bash">$vsPath = (vswhere -latest -property installationPath)
Import-Module (Join-Path $vsPath &quot;Common7\Tools\Microsoft.VisualStudio.DevShell.dll&quot;)
Enter-VsDevShell -VsInstallPath $vsPath -SkipAutomaticLocation -DevCmdArguments &quot;-arch=x64 -host_arch=x64 -winsdk=10.0.19041.0&quot;

$Env:PATH += &quot;;$pwd\\build\\lib\\api&quot;
cd build
ctest --output-on-failure
cd -
</code></pre>
<h2 id="运行应用-2"><a class="header" href="#运行应用-2">运行应用</a></h2>
<p>下一步，请按照<a href="extend/run.html">该指导</a> 使用 <code>wasmedge</code> 运行 WebAssembly 字节码程序。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="为-android-编译"><a class="header" href="#为-android-编译">为 Android 编译</a></h1>
<h2 id="使用-android-ndk-构建和测试-wasmedge-命令行工具"><a class="header" href="#使用-android-ndk-构建和测试-wasmedge-命令行工具">使用 Android NDK 构建和测试 WasmEdge 命令行工具</a></h2>
<p>此教程指导使用 Android NDK 构建 Interpreter 模式的 WasmEdge ，并在 Android 设备中测试 wasmedge 命令行工具。</p>
<h3 id="环境准备-4"><a class="header" href="#环境准备-4">环境准备</a></h3>
<ul>
<li><a href="https://developer.android.com/ndk/downloads">Android NDK 23b</a>
<ul>
<li>下载到的 NDK 工具链需要解压到磁盘上</li>
</ul>
</li>
<li><a href="https://cmake.org/download/">CMake 3.21</a> 及以上版本
<ul>
<li>如果本机已安装 cmake，请检查版本是否符合要求</li>
</ul>
</li>
<li><a href="https://developer.android.com/studio/releases/platform-tools">ADB</a>
<ul>
<li>将下载到的 platform-tools 解压到磁盘上，adb 命令在 bin 目录中</li>
<li>如果您使用的是 debian/ubuntu 系统，可以通过 apt 安装 adb</li>
</ul>
</li>
<li>一台已经 <a href="https://developer.android.com/studio/debug/dev-options">启用开发者选项和 USB 调试</a> 的 Android 设备, 最低系统版本为 Android 6.0</li>
</ul>
<h3 id="构建-wasmedge-4"><a class="header" href="#构建-wasmedge-4">构建 WasmEdge</a></h3>
<ol>
<li>添加 NDK 目录路径到环境变量 <code>ANDROID_NDK_HOME=path/to/you/ndk/dir</code></li>
<li>执行 WasmEdge 源码路径下的 <code>utils/android/standalone/build_for_android.sh</code> 命令行脚本，将自动执行构建，构建结果在 WasmEdge 目录中的 build 目录</li>
</ol>
<h3 id="测试-1"><a class="header" href="#测试-1">测试</a></h3>
<h4 id="推送到-android-设备"><a class="header" href="#推送到-android-设备">推送到 Android 设备</a></h4>
<ol>
<li>
<p>将 Android 设备通过 USB 或 WLAN 连接到 PC 。您可以通过 <code>adb devices</code> 命令检查已连接的设备，可以获得类似如下显示：</p>
<pre><code class="language-bash">$ adb devices
List of devices attached
0a388e93      device
</code></pre>
</li>
<li>
<p>使用 <code>adb push</code>命令推送 build/tools/wasmedge 到 Android 设备的 /data/local/tmp 目录</p>
<pre><code class="language-bash">cd build
adb push ./tools/wasmedge /data/local/tmp  
</code></pre>
</li>
</ol>
<h4 id="在-android-设备中执行-wasmedge"><a class="header" href="#在-android-设备中执行-wasmedge">在 Android 设备中执行 WasmEdge</a></h4>
<ol>
<li>使用 <code>adb shell</code> 命令进入 Android 设备</li>
<li>测试运行 wasmedge 程序</li>
</ol>
<pre><code class="language-bash">$ cd /data/local/tmp/wasmedge/examples
$ ../wasmedge hello.wasm 1 2 3                                                           
hello
1
2
3

$ ../wasmedge --reactor add.wasm add 2 2
4

$ ../wasmedge --reactor fibonacci.wasm fib 8
34

$ ../wasmedge --reactor factorial.wasm fac 12
479001600

$ cd js
$ ./../wasmedge --dir .:. qjs.wasm hello.js 1 2 3
Hello 1 2 3
</code></pre>
<h3 id="注意-1"><a class="header" href="#注意-1">注意</a></h3>
<ul>
<li>Android 10 及以上系统版本，SELinux 限制普通 Android 应用程序使用 exec() 执行 home 目录中的可执行文件。<a href="https://android.googlesource.com/platform/system/sepolicy/+/08450264ae3f917f6b8e4091d6fedf84ef8d796f/private/untrusted_app_all.te#27">参考</a></li>
<li>Android SELinux 限制普通 Android 应用程序访问 /data/local/tmp 目录</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="wasmedge-插件-api"><a class="header" href="#wasmedge-插件-api">WasmEdge 插件 API</a></h1>
<p>WasmEdge 提供了一套基于 C++ 的 API 用来注册自定义扩展和 host 函数。虽然 WasmEdge 的各种语言 SDK 允许将主机应用注册为主机功能函数，但插件 API 方式允许这种扩展被纳入 WasmEdge 自己的构建和发布过程。</p>
<p>事实上，WasmEdge 对 Tensorflow 、图像处理、键值存储等的扩展都是通过插件 API 实现的。插件 API 是你可以为 WasmEdge Runtime 本身贡献新功能的方式。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="host-函数-1"><a class="header" href="#host-函数-1">Host 函数</a></h1>
<p><a href="https://webassembly.github.io/spec/core/exec/runtime.html#syntax-hostfunc">Host 函数</a> 是在 WebAssembly 之外的函数，它们以导入的方式传递到 WASM 模块中。以下步骤是将 <code>host module</code> 注册到 WasmEdge runtime 的示例。</p>
<p>此示例适用于使用 C++ 编写的 WasmEdge 项目的源代码编译。如果开发者想使用C/C++ 和 WasmEdge C API 来实现 host 函数，而不用 WasmEdge 项目进行编译，请参阅 <a href="extend/plugin/../../embed/c/ref.html#host-functions">C API 文档</a>。</p>
<h2 id="host-实例定义"><a class="header" href="#host-实例定义">Host 实例定义</a></h2>
<p>WasmEdge 支持以导入的形式注册 <code>host function</code> 、<code>memory</code> 、<code>table</code> 和 <code>global</code> 等实例。
详情请参阅 <code>include/host/wasi/</code> 和 <code>test/core/spectest.h</code> 中的示例。</p>
<h3 id="函数-1"><a class="header" href="#函数-1">函数</a></h3>
<p>可以按照如下方式声明一个简单的 host 函数类：</p>
<pre><code class="language-cpp">#include &quot;common/errcode.h&quot;
#include &quot;runtime/hostfunc.h&quot;
#include &quot;runtime/instance/memory.h&quot;

namespace WasmEdge {
namespace Host {

class TestHost : public Runtime::HostFunction&lt;TestHost&gt; {
public:
  Expect&lt;uint32_t&gt; body(Runtime::Instance::MemoryInstance *MemInst, uint32_t Param1, float Param2);
};

} // namespace Host
} // namespace WasmEdge
</code></pre>
<p>在上述示例中，返回类型 <code>Expect&lt;T&gt;</code> 表示该 host 函数的预期返回类型 <code>T</code>。 <code>Param1</code> 和 <code>Param2</code> 的类型表示此 host 函数的参数类型。 host 函数仅支持 WASM 的内置类型（如 <code>uint32_t</code>、 <code>uint64_t</code>、 <code>float</code> 以及 <code>double</code>）。在实例化时会生成 <code>vec(valtype) -&gt; resulttype</code> 的函数签名，它能被 WASM 模块导入。</p>
<p>注意：目前 host 函数仅支持单个返回值。</p>
<p>另一种情况是传递需要由 <code>host function</code> 体访问的环境或信息。 以下示例展示了如何实现 host 函数集群：</p>
<pre><code class="language-cpp">#include &quot;common/errcode.h&quot;
#include &quot;runtime/hostfunc.h&quot;
#include &quot;runtime/instance/memory.h&quot;
#include &lt;vector&gt;

namespace WasmEdge {
namespace Host {

template &lt;typename T&gt; class TestCluster : public Runtime::HostFunction&lt;T&gt; {
public:
  TestCluster(std::vector&lt;uint8_t&gt; &amp;Vec) : Data(Vec) {}

protected:
  std::vector&lt;uint8_t&gt; &amp;Data;
};

class TestHost1 : public TestCluster&lt;TestHost1&gt; {
public:
  TestHost1(std::vector&lt;uint8_t&gt; &amp;Vec) : TestCluster(Vec) {}
  Expect&lt;uint32_t&gt; body(Runtime::Instance::MemoryInstance *MemInst, uint32_t Param1, float Param2) {
    /// Operations to `Data` ...
    return {};
  }
};

class TestHost2 : public TestCluster&lt;TestHost2&gt; {
public:
  TestHost2(std::vector&lt;uint8_t&gt; &amp;Vec) : TestCluster(Vec) {}
  Expect&lt;uint64_t&gt; body(Runtime::Instance::MemoryInstance *MemInst, uint64_t Param1, double Param2) {
    /// Operations to `Data` ...
    return {};
  }
};

} // namespace Host
} // namespace WasmEdge
</code></pre>
<h3 id="表-内存-以及全局实例"><a class="header" href="#表-内存-以及全局实例">表、 内存、 以及全局实例</a></h3>
<p>要创建 <code>host table</code>、 <code>memory</code> 以及 <code>global</code> 实例，唯一的办法就是使用 <code>host module</code> 中它们各自的构造器来创建。以下关于 <code>host module</code> 的章节将提供更详细的示例。</p>
<h2 id="host-modules-host-模块"><a class="header" href="#host-modules-host-模块">Host Modules/ host 模块</a></h2>
<p><code>Host module</code> 是一个可以注册到 WasmEdge runtime 的对象。<code>Host module</code> 包含了 <code>host functions</code>、 <code>tables</code>、 <code>memories</code>、 <code>globals</code> 以及其它用户自定义的数据。WasmEdge 提供 API 来注册 <code>host modules</code>。在注册后，<code>host modules</code> 中的这些 host 实例可以被 WASM 模块所导入。</p>
<h3 id="声明"><a class="header" href="#声明">声明</a></h3>
<p><code>Host module</code> 提供了导出的模块名称，并且可以包含自定义数据。 构建 <code>host modules</code> 时需要填写模块名称。</p>
<pre><code class="language-cpp">#include &quot;common/errcode.h&quot;
#include &quot;runtime/hostfunc.h&quot;
#include &quot;runtime/importobj.h&quot;

namespace WasmEdge {
namespace Host {

class TestModule : public Runtime::ImportObject {
public:
  TestModule() : ImportObject(&quot;test&quot;);
  virtual ~TestModule() = default;
};

} // namespace Host
} // namespace WasmEdge
</code></pre>
<h3 id="添加实例"><a class="header" href="#添加实例">添加实例</a></h3>
<p><code>Host module</code> 提供了以下四种方法 <code>addHostFunc()</code>、 <code>addHostTable()</code>、 <code>addHostMemory()</code> 和 <code>addHostGlobal()</code> 来插入具有唯一名称的实例。插入操作可以在构造器中完成。下面的示例代码中还展示了如何创建 <code>host memories</code>、 <code>tables</code> 和 <code>globals</code>。</p>
<pre><code class="language-cpp">#include &quot;common/errcode.h&quot;
#include &quot;runtime/hostfunc.h&quot;
#include &quot;runtime/importobj.h&quot;
#include &lt;memory&gt;
#include &lt;vector&gt;

namespace WasmEdge {
namespace Host {

template &lt;typename T&gt; class TestCluster : public Runtime::HostFunction&lt;T&gt; {
public:
  TestCluster(std::vector&lt;uint8_t&gt; &amp;Vec) : Data(Vec) {}

protected:
  std::vector&lt;uint8_t&gt; &amp;Data;
};

class TestHost1 : public TestCluster&lt;TestHost1&gt; {
public:
  TestHost1(std::vector&lt;uint8_t&gt; &amp;Vec) : TestCluster(Vec) {}
  Expect&lt;uint32_t&gt; body(Runtime::Instance::MemoryInstance *MemInst, uint32_t Param1, float Param2) {
    /// Operations to `Data` ...
    return {};
  }
};

class TestHost2 : public TestCluster&lt;TestHost2&gt; {
public:
  TestHost2(std::vector&lt;uint8_t&gt; &amp;Vec) : TestCluster(Vec) {}
  Expect&lt;uint64_t&gt; body(Runtime::Instance::MemoryInstance *MemInst, uint64_t Param1, double Param2) {
    /// Operations to `Data` ...
    return {};
  }
};

class TestModule : public Runtime::ImportObject {
public:
  TestModule(std::vector&lt;uint8_t&gt; &amp;Vec) : ImportObject(&quot;test&quot;), Data(Vec) {
    /// Add function instances with exporting name
    addHostFunc(&quot;test_func1&quot;, std::make_unique&lt;TestHost1&gt;(Data));
    addHostFunc(&quot;test_func2&quot;, std::make_unique&lt;TestHost2&gt;(Data));

    /// Add table instance with exporting name
    addHostTable(&quot;table&quot;, std::make_unique&lt;Runtime::Instance::TableInstance&gt;(
                              TableType(RefType::FuncRef, 10, 20)));

    /// Add memory instance with exporting name
    addHostMemory(&quot;memory&quot;, std::make_unique&lt;Runtime::Instance::MemoryInstance&gt;(
                                MemoryType(1, 2)));

    /// Add global instance with exporting name
    addHostGlobal(&quot;global_i32&quot;,
                  std::make_unique&lt;Runtime::Instance::GlobalInstance&gt;(
                      GlobalType(ValType::I32, ValMut::Const), uint32_t(666)));
    addHostGlobal(&quot;global_i64&quot;,
                  std::make_unique&lt;Runtime::Instance::GlobalInstance&gt;(
                      GlobalType(ValType::I64, ValMut::Const), uint64_t(666)));
    addHostGlobal(&quot;global_f32&quot;,
                  std::make_unique&lt;Runtime::Instance::GlobalInstance&gt;(
                      GlobalType(ValType::F32, ValMut::Const), float(666)));
    addHostGlobal(&quot;global_f64&quot;,
                  std::make_unique&lt;Runtime::Instance::GlobalInstance&gt;(
                      GlobalType(ValType::F64, ValMut::Const), double(666)));
  }
  virtual ~TestModule() = default;

private:
  std::vector&lt;uint8_t&gt; &amp;Data;
};

} // namespace Host
} // namespace WasmEdge
</code></pre>
<p><code>Host module</code> 提供了以下四种方法 <code>getFuncs()</code>、 <code>getTables()</code>、 <code>getMems()</code> 和 <code>getGlobals()</code> 用来通过唯一的导出名称搜索已注册的实例。更多细节和 APIs 请参阅 <code>include/runtime/importobj.h</code>。</p>
<h3 id="在-wasmedge-中注册-host-module"><a class="header" href="#在-wasmedge-中注册-host-module">在 WasmEdge 中注册 host module</a></h3>
<p>用户可以通过 <code>WasmEdge::VM::registerModule()</code> API 来注册 <code>host module</code>。</p>
<pre><code class="language-cpp">#include &quot;common/configure.h&quot;
#include &quot;vm/vm.h&quot;
#include &lt;vector&gt;

WasmEdge::Configure Conf;
WasmEdge::VM::VM VM(Conf);
std::vector&lt;uint8_t&gt; Data;
WasmEdge::Host::TestModule TestMod(Data);
VM.registerModule(TestMod);
</code></pre>
<h3 id="在-cmakefile-中链接库以及包含目录"><a class="header" href="#在-cmakefile-中链接库以及包含目录">在 CMakeFile 中链接库以及包含目录</a></h3>
<p>为了从 WasmEdge 的包含目录中查找头文件以及链接静态库，CMakeFile 需要如下设置</p>
<pre><code class="language-cmake">add_library(wasmedgeHostModuleTest  # Static library name of host modules
  test.cpp  # Path to host modules cpp files
)

target_include_directories(wasmedgeHostModuleTest
  PUBLIC
  ${Boost_INCLUDE_DIRS}
  ${PROJECT_SOURCE_DIR}/include
)
</code></pre>
<h2 id="host-函数体实现"><a class="header" href="#host-函数体实现">host 函数体实现</a></h2>
<p>以下是一些实现 host 函数体的小技巧。</p>
<h3 id="使用时检查-memory-实例"><a class="header" href="#使用时检查-memory-实例">使用时检查 Memory 实例</a></h3>
<p>Host 函数能够访问 WASM 内存，这些内存通常以 <code>MemoryInstance *</code> 参数的形式被传递。 当发生<a href="https://webassembly.github.io/spec/core/exec/instructions.html#function-calls">函数调用</a> 时，被调用函数所属的带有模块的帧将被压入<code>堆栈</code>。 在 host 函数的例子中，堆栈顶部栈帧中的内存实例将作为 host 函数体的参数被传递。然而，一个 WASM 模块中可以不包含内存实例。因此，用户在访问时应检查内存实例指针是否为空指针。</p>
<h3 id="预期返回"><a class="header" href="#预期返回">预期返回</a></h3>
<p>在我们的机制里， <code>include/common/errcode.h</code> 中声明的 <code>Expect&lt;T&gt;</code> 被用作函数体的结果类型。在 <code>Expect&lt;void&gt;</code> 的情况下，预期场景需要 <code>return {};</code> 。其它情况下， 预期场景需要 <code>return Value;</code> ，其中 <code>Value</code> 是 <code>T</code> 类型的一个变量。如果出现意外情况，用户可以调用 <code>return Unexpect(Code);</code> 来返回一个错误，其中 <code>Code</code> 是枚举 <code>ErrCode</code> 的一个元素。</p>
<h3 id="强制终止"><a class="header" href="#强制终止">强制终止</a></h3>
<p>WasmEdge 提供了一种在 host 函数中终止 WASM 执行的方法。开发者可以返回 <code>ErrCode::Terminated</code>  来触发当前执行的强制终止，并将 <code>ErrCode::Terminated</code>  传递给 host 函数的调用者。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="自定义外部引用"><a class="header" href="#自定义外部引用">自定义外部引用</a></h1>
<p><a href="https://webassembly.github.io/reference-types/core/syntax/types.html#syntax-reftype">外部引用</a>指示对 host 对象的不透明且不可伪造的引用。新的 <code>externref</code> 类型可以被传递到 Wasm 模块或从 Wasm 模块返回。Wasm 模块不能显示 <code>externref</code> 值的位模式，也不能通过整数值创建一个假的 host 引用。</p>
<h2 id="教程"><a class="header" href="#教程">教程</a></h2>
<p>下面的教程是对 WasmEdge 中的 <code>externref</code> 示例的总结。</p>
<h3 id="准备-wasm-文件"><a class="header" href="#准备-wasm-文件">准备 Wasm 文件</a></h3>
<p>Wasm 文件应该包含接受 <code>externref</code> 的 host 函数导入。以<a href="extend/plugin/../test/externref/externrefTestData/funcs.wasm">这个 WASM 测试用例</a>为例（<a href="extend/plugin/../test/externref/externrefTestData/funcs.wat">WAT</a>是相对应的文本格式）。</p>
<pre><code class="language-wasm">(module
  (type $t0 (func (param externref i32) (result i32)))
  (type $t1 (func (param externref i32 i32) (result i32)))
  (type $t2 (func (param externref externref i32 i32) (result i32)))
  (import &quot;extern_module&quot; &quot;functor_square&quot; (func $functor_square (type $t0)))
  (import &quot;extern_module&quot; &quot;class_add&quot; (func $class_add (type $t1)))
  (import &quot;extern_module&quot; &quot;func_mul&quot; (func $func_mul (type $t1)))
  (func $call_add (export &quot;call_add&quot;) (type $t1) (param $p0 externref) (param $p1 i32) (param $p2 i32) (result i32)
    (call $class_add
      (local.get $p0)
      (local.get $p1)
      (local.get $p2)))
  (func $call_mul (export &quot;call_mul&quot;) (type $t1) (param $p0 externref) (param $p1 i32) (param $p2 i32) (result i32)
    (call $func_mul
      (local.get $p0)
      (local.get $p1)
      (local.get $p2)))
  (func $call_square (export &quot;call_square&quot;) (type $t0) (param $p0 externref) (param $p1 i32) (result i32)
    (call $functor_square
      (local.get $p0)
      (local.get $p1)))
  (func $call_add_square (export &quot;call_add_square&quot;) (type $t2) (param $p0 externref) (param $p1 externref) (param $p2 i32) (param $p3 i32) (result i32)
    (call $functor_square
      (local.get $p1)
      (call $class_add
        (local.get $p0)
        (local.get $p2)
        (local.get $p3))))
  (memory $memory (export &quot;memory&quot;) 1))
</code></pre>
<p>你可以通过 <a href="https://webassembly.github.io/wabt/demo/wat2wasm/">wat2wasm</a> 在线实时工具将 <code>wat</code> 转换为 <code>wasm</code>。注意页面上的 <code>reference types</code> 复选框必须勾选。</p>
<h3 id="实现-host-模块以及在-wasmedge-中注册"><a class="header" href="#实现-host-模块以及在-wasmedge-中注册">实现 Host 模块以及在 WasmEdge 中注册</a></h3>
<p>在执行 Wasm 执行前，host 模块必须实现以及在 WasmEdge 中注册。假设下面的代码保存为 <code>main.c</code>：</p>
<pre><code class="language-cpp">#include &lt;wasmedge/wasmedge.h&gt;

#include &lt;stdio.h&gt;

uint32_t SquareFunc(uint32_t A) { return A * A; }
uint32_t AddFunc(uint32_t A, uint32_t B) { return A + B; }
uint32_t MulFunc(uint32_t A, uint32_t B) { return A * B; }

// Host 函数通过外部引用调用 `SquareFunc`
WasmEdge_Result ExternSquare(void *Data, WasmEdge_MemoryInstanceContext *MemCxt,
                             const WasmEdge_Value *In, WasmEdge_Value *Out) {
  // 函数类型: {externref, i32} -&gt; {i32}
  uint32_t (*Func)(uint32_t) = WasmEdge_ValueGetExternRef(In[0]);
  uint32_t C = Func(WasmEdge_ValueGetI32(In[1]));
  Out[0] = WasmEdge_ValueGenI32(C);
  return WasmEdge_Result_Success;
}

// Host 函数通过外部引用调用 `AddFunc`
WasmEdge_Result ExternAdd(void *Data, WasmEdge_MemoryInstanceContext *MemCxt,
                          const WasmEdge_Value *In, WasmEdge_Value *Out) {
  // 函数类型: {externref, i32, i32} -&gt; {i32}
  uint32_t (*Func)(uint32_t, uint32_t) = WasmEdge_ValueGetExternRef(In[0]);
  uint32_t C = Func(WasmEdge_ValueGetI32(In[1]), WasmEdge_ValueGetI32(In[2]));
  Out[0] = WasmEdge_ValueGenI32(C);
  return WasmEdge_Result_Success;
}

// host 函数通过外部引用调用 `ExternMul`
WasmEdge_Result ExternMul(void *Data, WasmEdge_MemoryInstanceContext *MemCxt,
                          const WasmEdge_Value *In, WasmEdge_Value *Out) {
  // 函数类型: {externref, i32, i32} -&gt; {i32}
  uint32_t (*Func)(uint32_t, uint32_t) = WasmEdge_ValueGetExternRef(In[0]);
  uint32_t C = Func(WasmEdge_ValueGetI32(In[1]), WasmEdge_ValueGetI32(In[2]));
  Out[0] = WasmEdge_ValueGenI32(C);
  return WasmEdge_Result_Success;
}

// 创建“extern_module”引入对象的辅助函数。
WasmEdge_ImportObjectContext *CreateExternModule() {
  WasmEdge_String HostName;
  WasmEdge_FunctionTypeContext *HostFType = NULL;
  WasmEdge_FunctionInstanceContext *HostFunc = NULL;
  enum WasmEdge_ValType P[3], R[1];

  HostName = WasmEdge_StringCreateByCString(&quot;extern_module&quot;);
  WasmEdge_ImportObjectContext *ImpObj = WasmEdge_ImportObjectCreate(HostName);
  WasmEdge_StringDelete(HostName);

  // 添加 host 函数 &quot;functor_square&quot;: {externref, i32} -&gt; {i32}
  P[0] = WasmEdge_ValType_ExternRef;
  P[1] = WasmEdge_ValType_I32;
  R[0] = WasmEdge_ValType_I32;
  HostFType = WasmEdge_FunctionTypeCreate(P, 2, R, 1);
  HostFunc = WasmEdge_FunctionInstanceCreate(HostFType, ExternSquare, NULL, 0);
  WasmEdge_FunctionTypeDelete(HostFType);
  HostName = WasmEdge_StringCreateByCString(&quot;functor_square&quot;);
  WasmEdge_ImportObjectAddFunction(ImpObj, HostName, HostFunc);
  WasmEdge_StringDelete(HostName);

  // 添加 host 函数 &quot;class_add&quot;: {externref, i32, i32} -&gt; {i32}
  P[2] = WasmEdge_ValType_I32;
  HostFType = WasmEdge_FunctionTypeCreate(P, 3, R, 1);
  HostFunc = WasmEdge_FunctionInstanceCreate(HostFType, ExternAdd, NULL, 0);
  WasmEdge_FunctionTypeDelete(HostFType);
  HostName = WasmEdge_StringCreateByCString(&quot;class_add&quot;);
  WasmEdge_ImportObjectAddFunction(ImpObj, HostName, HostFunc);
  WasmEdge_StringDelete(HostName);

  // 添加 host 函数 &quot;func_mul&quot;: {externref, i32, i32} -&gt; {i32}
  HostFType = WasmEdge_FunctionTypeCreate(P, 3, R, 1);
  HostFunc = WasmEdge_FunctionInstanceCreate(HostFType, ExternMul, NULL, 0);
  WasmEdge_FunctionTypeDelete(HostFType);
  HostName = WasmEdge_StringCreateByCString(&quot;func_mul&quot;);
  WasmEdge_ImportObjectAddFunction(ImpObj, HostName, HostFunc);
  WasmEdge_StringDelete(HostName);

  return ImpObj;
}

int main() {
  WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(NULL, NULL);
  WasmEdge_ImportObjectContext *ImpObj = CreateExternModule();
  WasmEdge_Value P[3], R[1];
  WasmEdge_String FuncName;
  WasmEdge_Result Res;

  Res = WasmEdge_VMRegisterModuleFromImport(VMCxt, ImpObj);
  if (!WasmEdge_ResultOK(Res)) {
    printf(&quot;Import object registration failed\n&quot;);
    return EXIT_FAILURE;
  }
  Res = WasmEdge_VMLoadWasmFromFile(VMCxt, &quot;funcs.wasm&quot;);
  if (!WasmEdge_ResultOK(Res)) {
    printf(&quot;WASM file loading failed\n&quot;);
    return EXIT_FAILURE;
  }
  Res = WasmEdge_VMValidate(VMCxt);
  if (!WasmEdge_ResultOK(Res)) {
    printf(&quot;WASM validation failed\n&quot;);
    return EXIT_FAILURE;
  }
  Res = WasmEdge_VMInstantiate(VMCxt);
  if (!WasmEdge_ResultOK(Res)) {
    printf(&quot;WASM instantiation failed\n&quot;);
    return EXIT_FAILURE;
  }

  // 测试用例 1：调用 add -- 1234 + 5678
  P[0] = WasmEdge_ValueGenExternRef(AddFunc);
  P[1] = WasmEdge_ValueGenI32(1234);
  P[2] = WasmEdge_ValueGenI32(5678);
  FuncName = WasmEdge_StringCreateByCString(&quot;call_add&quot;);
  Res = WasmEdge_VMExecute(VMCxt, FuncName, P, 3, R, 1);
  WasmEdge_StringDelete(FuncName);
  if (WasmEdge_ResultOK(Res)) {
    printf(&quot;Test 1 -- `call_add` -- 1234 + 5678 = %d\n&quot;,
           WasmEdge_ValueGetI32(R[0]));
  } else {
    printf(&quot;Test 1 -- `call_add` -- 1234 + 5678 -- failed\n&quot;);
    return EXIT_FAILURE;
  }

  // 测试用例 2：调用 mul -- 789 * 4321
  P[0] = WasmEdge_ValueGenExternRef(MulFunc);
  P[1] = WasmEdge_ValueGenI32(789);
  P[2] = WasmEdge_ValueGenI32(4321);
  FuncName = WasmEdge_StringCreateByCString(&quot;call_mul&quot;);
  Res = WasmEdge_VMExecute(VMCxt, FuncName, P, 3, R, 1);
  WasmEdge_StringDelete(FuncName);
  if (WasmEdge_ResultOK(Res)) {
    printf(&quot;Test 2 -- `call_mul` -- 789 * 4321 = %d\n&quot;,
           WasmEdge_ValueGetI32(R[0]));
  } else {
    printf(&quot;Test 2 -- `call_mul` -- 789 * 4321 -- failed\n&quot;);
    return EXIT_FAILURE;
  }

  // 测试用例 3：调用 square -- 8256^2
  P[0] = WasmEdge_ValueGenExternRef(SquareFunc);
  P[1] = WasmEdge_ValueGenI32(8256);
  FuncName = WasmEdge_StringCreateByCString(&quot;call_square&quot;);
  Res = WasmEdge_VMExecute(VMCxt, FuncName, P, 2, R, 1);
  if (WasmEdge_ResultOK(Res)) {
    printf(&quot;Test 3 -- `call_mul` -- 8256 ^ 2 = %d\n&quot;,
           WasmEdge_ValueGetI32(R[0]));
  } else {
    printf(&quot;Test 3 -- `call_mul` -- 8256 ^ 2 -- failed\n&quot;);
    return EXIT_FAILURE;
  }

  return EXIT_SUCCESS;
}
</code></pre>
<h3 id="设置环境并编译"><a class="header" href="#设置环境并编译">设置环境并编译</a></h3>
<ol>
<li>
<p>安装 WasmEdge 共享库。</p>
<p>详细信息请参阅<a href="extend/plugin/install.html">安装</a>。</p>
</li>
<li>
<p>如上所示准备 WASM 文件和 <code>main.c</code> 源文件。</p>
</li>
<li>
<p>编译</p>
<pre><code class="language-bash">gcc main.c -lwasmedge
# 或者你可以在 C++ 场景下使用 g++，或者使用 clang。
</code></pre>
</li>
<li>
<p>运行测试用例</p>
<pre><code class="language-bash">$ ./a.out
Test 1 -- `call_add` -- 1234 + 5678 = 6912
Test 2 -- `call_mul` -- 789 * 4321 = 3409269
Test 3 -- `call_mul` -- 8256 ^ 2 = 68161536
</code></pre>
</li>
</ol>
<h2 id="使用外部引用的--wasm"><a class="header" href="#使用外部引用的--wasm">使用外部引用的  Wasm</a></h2>
<p>以下文的 <code>wat</code> 为例：</p>
<pre><code class="language-wasm">(module
  (type $t0 (func (param externref i32) (result i32)))
  ;; Import a host function which type is {externref i32} -&gt; {i32}
  (import &quot;extern_module&quot; &quot;functor_square&quot; (func $functor_square (type $t0)))
  ;; Wasm function which type is {externref i32} -&gt; {i32} and exported as &quot;call_square&quot;
  (func $call_square (export &quot;call_square&quot;) (type $t0) (param $p0 externref) (param $p1 i32) (result i32)
    (call $functor_square (local.get $p0) (local.get $p1))
  )
  (memory $memory (export &quot;memory&quot;) 1))
</code></pre>
<p>Wasm 函数 &quot;<code>call_square</code>&quot; 包含一个 <code>externref</code> 参数，并用这个 <code>externref</code> 调用导入的 host 函数 <code>functor_square</code>。所以，当你调用 Wasm 函数 <code>call_square</code> 并传递对象的引用时，host 函数 <code>functor_square</code> 就能获得该对应引用。</p>
<h2 id="wasmedge-externref-示例"><a class="header" href="#wasmedge-externref-示例">WasmEdge ExternRef 示例</a></h2>
<p>下面的例子展示了如何在 Wasm 里通过 WasmEdge C API 使用 <code>externref</code>。</p>
<h3 id="wasm-代码"><a class="header" href="#wasm-代码">Wasm 代码</a></h3>
<p>Wasm 代码必须将 <code>externref</code> 传递给想要访问它的 host 函数。以下文的 <code>wat</code> 为例，这是 <a href="extend/plugin/../test/externref/externrefTestData/funcs.wat">WASM 测试用例</a>的其中一部分：</p>
<pre><code class="language-wasm">(module
  (type $t0 (func (param externref i32 i32) (result i32)))
  (import &quot;extern_module&quot; &quot;func_mul&quot; (func $func_mul (type $t0)))
  (func $call_mul (export &quot;call_mul&quot;) (type $t0) (param $p0 externref) (param $p1 i32) (param $p2 i32) (result i32)
    (call $func_mul (local.get $p0) (local.get $p1) (local.get $p2))
  )
  (memory $memory (export &quot;memory&quot;) 1))
</code></pre>
<p>host 函数 <code>extern_module::func_mul</code> 将 <code>externref</code> 作为一个函数指针用来将参数 1 和参数 2 相乘并返回其结果。输出的 Wasm 函数 <code>call_mul</code> 调用 <code>func_mul</code> 并传递 <code>externref</code> 和 2 个数字作为参数。</p>
<h3 id="host-函数-2"><a class="header" href="#host-函数-2">Host 函数</a></h3>
<p>要实例化上面的 Wasm 示例，host 函数必须注册到 WasmEdge 中。详见 <a href="extend/plugin/../../embed/c/ref.html#host-functions">Host 函数</a>。接受 <code>externref</code> 的 host 函数必须知道原始对象的类型。我们以函数指针为例。</p>
<pre><code class="language-c">/* 作为函数指针传递的函数。 */
uint32_t MulFunc(uint32_t A, uint32_t B) { return A * B; }

/* Host 函数通过外部引用作为函数指针来调用函数 */
WasmEdge_Result ExternMul(void *, WasmEdge_MemoryInstanceContext *,
                          const WasmEdge_Value *In, WasmEdge_Value *Out) {
  /* 函数类型: {externref, i32, i32} -&gt; {i32} */
  void *Ptr = WasmEdge_ValueGetExternRef(In[0]);
  uint32_t (*Obj)(uint32_t, uint32_t) = Ptr;
  /*
   * 对于 C++ 来说，`reinterpret_cast` 是必需的：
   * uint32_t (*Obj)(uint32_t, uint32_t) = 
   *   *reinterpret_cast&lt;uint32_t (*)(uint32_t, uint32_t)&gt;(Ptr);
   */
  uint32_t C = Obj(WasmEdge_ValueGetI32(In[1]), WasmEdge_ValueGetI32(In[2]));
  Out[0] = WasmEdge_ValueGenI32(C);
  return WasmEdge_Result_Success;
}
</code></pre>
<p>&quot;<code>MulFunc</code>&quot; 是一个函数，将作为 <code>externref</code> 传递给 Wasm。在 host 函数 &quot;<code>func_mul</code>&quot; 中，你可以使用 &quot;<code>WasmEdge_ValueGetExternRef</code>&quot; API 从包含 <code>externref</code> 的 <code>WasmEdge_Value</code> 中获取指针。</p>
<p>开发人员可以将带有名称的 host 函数添加到导入对象中。</p>
<pre><code class="language-c">/* 创建一个导入对象。 */
WasmEdge_String HostName = WasmEdge_StringCreateByCString(&quot;extern_module&quot;);
WasmEdge_ImportObjectContext *ImpObj = WasmEdge_ImportObjectCreate(HostName);
WasmEdge_StringDelete(HostName);

/* 创建一个函数实例并添加到一个导入对象中。 */
enum WasmEdge_ValType P[3], R[1];
P[0] = WasmEdge_ValType_ExternRef;
P[1] = WasmEdge_ValType_I32;
P[2] = WasmEdge_ValType_I32;
R[0] = WasmEdge_ValType_I32;
WasmEdge_FunctionTypeContext *HostFType = WasmEdge_FunctionTypeCreate(P, 3, R, 1);
WasmEdge_FunctionInstanceContext *HostFunc = WasmEdge_FunctionInstanceCreate(HostFType, ExternFuncMul, NULL, 0);
WasmEdge_FunctionTypeDelete(HostFType);
HostName = WasmEdge_StringCreateByCString(&quot;func_mul&quot;);
WasmEdge_ImportObjectAddFunction(ImpObj, HostName, HostFunc);
WasmEdge_StringDelete(HostName);

...
</code></pre>
<h3 id="执行"><a class="header" href="#执行">执行</a></h3>
<p>以<a href="extend/plugin/../test/externref/externrefTestData/funcs.wasm">这个 WASM 测试用例</a>为例（<a href="extend/plugin/../test/externref/externrefTestData/funcs.wat">WAT</a>是相对应的文本格式）。假设函数 <code>funcs.wasm</code> 被复制到了当前目录。下面的例子展示了如何在 Wasm 里用 WasmEdge C API 使用 <code>externref</code>。</p>
<pre><code class="language-c">/* 创建 VM 上下文。 */
WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(NULL, NULL);
/* 创建包含 host 函数的导入对象上下文。 */
WasmEdge_ImportObjectContext *ImpObj = /* Ignored ... */;
/* 假设 host 函数被添加到上面的导入对象中。 */
WasmEdge_Value P[3], R[1];
WasmEdge_String FuncName;
WasmEdge_Result Res;

/* 将导入对象注册到 VM。 */
Res = WasmEdge_VMRegisterModuleFromImport(VMCxt, ImpObj);
if (!WasmEdge_ResultOK(Res)) {
  printf(&quot;Import object registration failed\n&quot;);
  return EXIT_FAILURE;
}
/* 从文件中加载 WASM。 */
Res = WasmEdge_VMLoadWasmFromFile(VMCxt, &quot;funcs.wasm&quot;);
if (!WasmEdge_ResultOK(Res)) {
  printf(&quot;WASM file loading failed\n&quot;);
  return EXIT_FAILURE;
}
/* 验证 WASM。 */
Res = WasmEdge_VMValidate(VMCxt);
if (!WasmEdge_ResultOK(Res)) {
  printf(&quot;WASM validation failed\n&quot;);
  return EXIT_FAILURE;
}
/* 实例化 WASM 模块。 */
Res = WasmEdge_VMInstantiate(VMCxt);
if (!WasmEdge_ResultOK(Res)) {
  printf(&quot;WASM instantiation failed\n&quot;);
  return EXIT_FAILURE;
}

/* 运行 WASM 函数。 */
P[0] = WasmEdge_ValueGenExternRef(AddFunc);
P[1] = WasmEdge_ValueGenI32(1234);
P[2] = WasmEdge_ValueGenI32(5678);
/* 运行 `call_add` 函数。 */
FuncName = WasmEdge_StringCreateByCString(&quot;call_add&quot;);
Res = WasmEdge_VMExecute(VMCxt, FuncName, P, 3, R, 1);
WasmEdge_StringDelete(FuncName);
if (WasmEdge_ResultOK(Res)) {
  printf(&quot;Run -- `call_add` -- 1234 + 5678 = %d\n&quot;,
          WasmEdge_ValueGetI32(R[0]));
} else {
  printf(&quot;Run -- `call_add` -- 1234 + 5678 -- failed\n&quot;);
  return EXIT_FAILURE;
}
</code></pre>
<h2 id="传递对象"><a class="header" href="#传递对象">传递对象</a></h2>
<p>上面的例子是传递一个函数引用 <code>externref</code>。下面的例子是关于如何在 C++ 中将对象引用作为 <code>externref</code> 传递给 WASM 的。</p>
<h3 id="传递一个类"><a class="header" href="#传递一个类">传递一个类</a></h3>
<p>将一个类通过 <code>externref</code> 传递，对象实例是必须的。</p>
<pre><code class="language-cpp">class AddClass {
public:
  uint32_t add(uint32_t A, uint32_t B) const { return A + B; }
};

AddClass AC;
</code></pre>
<p>然后你可以通过使用 <code>WasmEdge_ValueGenExternRef()</code> API 将对象传入 WasmEdge。</p>
<pre><code class="language-cpp">WasmEdge_Value P[3], R[1];
P[0] = WasmEdge_ValueGenExternRef(&amp;AC);
P[1] = WasmEdge_ValueGenI32(1234);
P[2] = WasmEdge_ValueGenI32(5678);
WasmEdge_String FuncName = WasmEdge_StringCreateByCString(&quot;call_add&quot;);
WasmEdge_Result Res = WasmEdge_VMExecute(VMCxt, FuncName, P, 3, R, 1);
WasmEdge_StringDelete(FuncName);
if (WasmEdge_ResultOK(Res)) {
  std::cout &lt;&lt; &quot;Result : &quot; &lt;&lt; WasmEdge_ValueGetI32(R[0]) std::endl;
  // 将会打印 `6912`.
} else {
  return EXIT_FAILURE;
}
</code></pre>
<p>在通过引用访问对象的 host 函数中，你可以使用 <code>WasmEdge_ValueGetExternRef()</code> API 来检索对对象的引用。</p>
<pre><code class="language-cpp">// 修改上面的教程中的 `ExternAdd`。
WasmEdge_Result ExternAdd(void *, WasmEdge_MemoryInstanceContext *,
                          const WasmEdge_Value *In, WasmEdge_Value *Out) {
  // 函数类型：{externref, i32, i32} -&gt; {i32}
  void *Ptr = WasmEdge_ValueGetExternRef(In[0]);
  AddClass &amp;Obj = *reinterpret_cast&lt;AddClass *&gt;(Ptr);
  uint32_t C =
      Obj.add(WasmEdge_ValueGetI32(In[1]), WasmEdge_ValueGetI32(In[2]));
  Out[0] = WasmEdge_ValueGenI32(C);
  return WasmEdge_Result_Success;
}
</code></pre>
<h3 id="传递一个对象作为仿函数"><a class="header" href="#传递一个对象作为仿函数">传递一个对象作为仿函数</a></h3>
<p>与传递类实例一样，需要 functor 对象实例。</p>
<pre><code class="language-cpp">struct SquareStruct {
  uint32_t operator()(uint32_t Val) const { return Val * Val; }
};

SquareStruct SS;
</code></pre>
<p>然后你可以通过使用 <code>WasmEdge_ValueGenExternRef()</code> API 将对象传递到 WasmEdge。</p>
<pre><code class="language-cpp">WasmEdge_Value P[2], R[1];
P[0] = WasmEdge_ValueGenExternRef(&amp;SS);
P[1] = WasmEdge_ValueGenI32(1024);
WasmEdge_String FuncName = WasmEdge_StringCreateByCString(&quot;call_square&quot;);
WasmEdge_Result Res = WasmEdge_VMExecute(VMCxt, FuncName, P, 2, R, 1);
WasmEdge_StringDelete(FuncName);
if (WasmEdge_ResultOK(Res)) {
  std::cout &lt;&lt; &quot;Result : &quot; &lt;&lt; WasmEdge_ValueGetI32(R[0]) std::endl;
  // 将会打印 `1048576`.
} else {
  return EXIT_FAILURE;
}
</code></pre>
<p>在通过引用访问对象的 host 函数中，你可以使用 <code>WasmEdge_ValueGetExternRef</code> API 来检索对该对象的引用，而该引用是一个 functor。</p>
<pre><code class="language-cpp">// 修改上文教程中的 `ExternSquare`。
WasmEdge_Result ExternSquare(void *, WasmEdge_MemoryInstanceContext *,
                          const WasmEdge_Value *In, WasmEdge_Value *Out) {
  // 函数类型：{externref, i32, i32} -&gt; {i32}
  void *Ptr = WasmEdge_ValueGetExternRef(In[0]);
  SquareStruct &amp;Obj = *reinterpret_cast&lt;SquareStruct *&gt;(Ptr);
  uint32_t C = Obj(WasmEdge_ValueGetI32(In[1]));
  Out[0] = WasmEdge_ValueGenI32(C);
  return WasmEdge_Result_Success;
}
</code></pre>
<h3 id="传递-stl-对象"><a class="header" href="#传递-stl-对象">传递 STL 对象</a></h3>
<p><a href="extend/plugin/../test/externref/externrefTestData/stl.wasm">example Wasm binary</a> 提供了与 host 函数交互的函数可以访问 C++ STL 对象的示例（<a href="extend/plugin/../test/externref/externrefTestData/stl.wat">WAT</a> 是相对应的文本格式）。</p>
<p>假设 WASM 文件 <code>stl.wasm</code> 被复制到了当前目录。</p>
<p>以下文的 <code>std::ostream</code> 和 <code>std::string</code> 为例。假设有一个 host 函数可以通过 <code>externref</code> 访问 <code>std::ostream</code> 和 <code>std::string</code>。</p>
<pre><code class="language-cpp">// Host 函数，通过 std::ostream 输出 std::string
WasmEdge_Result ExternSTLOStreamStr(void *, WasmEdge_MemoryInstanceContext *,
                                    const WasmEdge_Value *In,
                                    WasmEdge_Value *) {
  // 函数类型：{externref, externref} -&gt; {}
  void *Ptr0 = WasmEdge_ValueGetExternRef(In[0]);
  void *Ptr1 = WasmEdge_ValueGetExternRef(In[1]);
  std::ostream &amp;RefOS = *reinterpret_cast&lt;std::ostream *&gt;(Ptr0);
  std::string &amp;RefStr = *reinterpret_cast&lt;std::string *&gt;(Ptr1);
  RefOS &lt;&lt; RefStr;
  return WasmEdge_Result_Success;
}
</code></pre>
<p>假设上面的 host 函数被添加到一个导入对象 <code>ImpObj</code> 中，并且 <code>ImpObj</code> 被注册到一个虚拟机上下文 <code>VMCxt</code> 中。然后你可以通过以下代码实例化 Wasm 模块：</p>
<pre><code class="language-cpp">WasmEdge_Result Res = WasmEdge_VMLoadWasmFromFile(VMCxt, &quot;stl.wasm&quot;);
if (!WasmEdge_ResultOK(Res)) {
  printf(&quot;WASM file loading failed\n&quot;);
  return EXIT_FAILURE;
}
Res = WasmEdge_VMValidate(VMCxt);
if (!WasmEdge_ResultOK(Res)) {
  printf(&quot;WASM validation failed\n&quot;);
  return EXIT_FAILURE;
}
Res = WasmEdge_VMInstantiate(VMCxt);
if (!WasmEdge_ResultOK(Res)) {
  printf(&quot;WASM instantiation failed\n&quot;);
  return EXIT_FAILURE;
}
</code></pre>
<p>最后，通过外部引用传递 <code>std::cout</code> 和 <code>std::string</code> 对象。</p>
<pre><code class="language-cpp">std::string PrintStr(&quot;Hello world!&quot;);
WasmEdge_Value P[2], R[1];
P[0] = WasmEdge_ValueGenExternRef(&amp;std::cout);
P[1] = WasmEdge_ValueGenExternRef(&amp;PrintStr);
WasmEdge_String FuncName = WasmEdge_StringCreateByCString(&quot;call_ostream_str&quot;);
WasmEdge_Result Res = WasmEdge_VMExecute(VMCxt, FuncName, P, 2, R, 1);
// 将会打印 &quot;Hello world!&quot; 到标准输出 stdout.
WasmEdge_StringDelete(FuncName);
if (!WasmEdge_ResultOK(Res)) {
  return EXIT_FAILURE;
}
</code></pre>
<p>对于其它 C++ STL 对象的情况，例如 <code>std::vector&lt;T&gt;</code>，<code>std::map&lt;T, U&gt;</code> 或 <code>std::set&lt;T&gt;</code>，如果 <code>reinterpret_cast</code> 中的类型是正确的，该对象就可以在 host 函数中被正确访问到。</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
    </body>
</html>
