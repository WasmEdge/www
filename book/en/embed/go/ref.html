<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>API references - WasmEdge Runtime</title>
        <!-- Custom HTML head -->
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-NGPCK7VF2L"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-NGPCK7VF2L');
</script>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../../favicon.svg">
        <link rel="shortcut icon" href="../../favicon.png">
        <link rel="stylesheet" href="../../css/variables.css">
        <link rel="stylesheet" href="../../css/general.css">
        <link rel="stylesheet" href="../../css/chrome.css">
        <link rel="stylesheet" href="../../css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="../../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../../fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../../highlight.css">
        <link rel="stylesheet" href="../../tomorrow-night.css">
        <link rel="stylesheet" href="../../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item "><a href="../../index.html"><strong aria-hidden="true">1.</strong> Getting started</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../start/install.html"><strong aria-hidden="true">1.1.</strong> Install and uninstall</a></li><li class="chapter-item "><a href="../../start/docker.html"><strong aria-hidden="true">1.2.</strong> Use Docker</a></li><li class="chapter-item "><a href="../../start/cli.html"><strong aria-hidden="true">1.3.</strong> WasmEdge command line</a></li><li class="chapter-item "><a href="../../start/universal.html"><strong aria-hidden="true">1.4.</strong> Universal Binary</a></li></ol></li><li class="chapter-item "><a href="../../intro.html"><strong aria-hidden="true">2.</strong> What is WasmEdge</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../intro/use.html"><strong aria-hidden="true">2.1.</strong> Use cases</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../intro/use/runtime.html"><strong aria-hidden="true">2.1.1.</strong> Cloud-native runtime</a></li><li class="chapter-item "><a href="../../intro/use/js.html"><strong aria-hidden="true">2.1.2.</strong> JavaScript or DSL runtime</a></li><li class="chapter-item "><a href="../../intro/use/serverless.html"><strong aria-hidden="true">2.1.3.</strong> Serverless function-as-a-service in public clouds</a></li><li class="chapter-item "><a href="../../intro/use/edge.html"><strong aria-hidden="true">2.1.4.</strong> Edge computing</a></li><li class="chapter-item "><a href="../../intro/use/saas.html"><strong aria-hidden="true">2.1.5.</strong> Reactive functions for SaaS</a></li></ol></li><li class="chapter-item "><a href="../../intro/features.html"><strong aria-hidden="true">2.2.</strong> Feature highlights</a></li><li class="chapter-item "><a href="../../intro/standard.html"><strong aria-hidden="true">2.3.</strong> Standard extensions</a></li><li class="chapter-item "><a href="../../intro/proprietary.html"><strong aria-hidden="true">2.4.</strong> Proprietary extensions</a></li><li class="chapter-item "><a href="../../intro/integrations.html"><strong aria-hidden="true">2.5.</strong> Integrations</a></li><li class="chapter-item "><a href="../../intro/faq.html"><strong aria-hidden="true">2.6.</strong> FAQ</a></li></ol></li><li class="chapter-item "><a href="../../dev.html"><strong aria-hidden="true">3.</strong> Develop a WasmEdge app</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../dev/rust.html"><strong aria-hidden="true">3.1.</strong> Rust</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../dev/rust/wasi.html"><strong aria-hidden="true">3.1.1.</strong> Access OS services</a></li><li class="chapter-item "><a href="../../dev/rust/tensorflow.html"><strong aria-hidden="true">3.1.2.</strong> Tensorflow</a></li><li class="chapter-item "><a href="../../dev/rust/networking.html"><strong aria-hidden="true">3.1.3.</strong> Networking sockets</a></li><li class="chapter-item "><a href="../../dev/rust/command.html"><strong aria-hidden="true">3.1.4.</strong> Command interface</a></li><li class="chapter-item "><a href="../../dev/rust/bindgen.html"><strong aria-hidden="true">3.1.5.</strong> rustwasmc</a></li></ol></li><li class="chapter-item "><a href="../../dev/js.html"><strong aria-hidden="true">3.2.</strong> JavaScript</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../dev/js/quickstart.html"><strong aria-hidden="true">3.2.1.</strong> Getting started</a></li><li class="chapter-item "><a href="../../dev/js/es6.html"><strong aria-hidden="true">3.2.2.</strong> ES6 module</a></li><li class="chapter-item "><a href="../../dev/js/cjs.html"><strong aria-hidden="true">3.2.3.</strong> CommonJS module</a></li><li class="chapter-item "><a href="../../dev/js/npm.html"><strong aria-hidden="true">3.2.4.</strong> NodeJS &amp; NPM module</a></li><li class="chapter-item "><a href="../../dev/js/ssr.html"><strong aria-hidden="true">3.2.5.</strong> Example: React SSR</a></li><li class="chapter-item "><a href="../../dev/js/tensorflow.html"><strong aria-hidden="true">3.2.6.</strong> Tensorflow</a></li><li class="chapter-item "><a href="../../dev/js/networking.html"><strong aria-hidden="true">3.2.7.</strong> Networking sockets</a></li><li class="chapter-item "><a href="../../dev/js/async.html"><strong aria-hidden="true">3.2.8.</strong> Async networking</a></li><li class="chapter-item "><a href="../../dev/js/rust.html"><strong aria-hidden="true">3.2.9.</strong> Use Rust to implement JS API</a></li></ol></li><li class="chapter-item "><a href="../../dev/go.html"><strong aria-hidden="true">3.3.</strong> Go</a></li><li class="chapter-item "><a href="../../dev/swift.html"><strong aria-hidden="true">3.4.</strong> Swift</a></li><li class="chapter-item "><a href="../../dev/as.html"><strong aria-hidden="true">3.5.</strong> AssemblyScript</a></li><li class="chapter-item "><a href="../../dev/kotlin.html"><strong aria-hidden="true">3.6.</strong> Kotlin</a></li><li class="chapter-item "><a href="../../dev/grain.html"><strong aria-hidden="true">3.7.</strong> Grain</a></li></ol></li><li class="chapter-item expanded "><a href="../../embed.html"><strong aria-hidden="true">4.</strong> Embed WasmEdge functions</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../embed/c.html"><strong aria-hidden="true">4.1.</strong> C SDK</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../embed/c/ref.html"><strong aria-hidden="true">4.1.1.</strong> API references</a></li></ol></li><li class="chapter-item expanded "><a href="../../embed/go.html"><strong aria-hidden="true">4.2.</strong> Go SDK</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../embed/go/app.html"><strong aria-hidden="true">4.2.1.</strong> Embed WASM apps</a></li><li class="chapter-item "><a href="../../embed/go/function.html"><strong aria-hidden="true">4.2.2.</strong> Embed WASM funcs</a></li><li class="chapter-item "><a href="../../embed/go/memory.html"><strong aria-hidden="true">4.2.3.</strong> Pass complex data</a></li><li class="chapter-item "><a href="../../embed/go/tensorflow.html"><strong aria-hidden="true">4.2.4.</strong> Tensorflow</a></li><li class="chapter-item "><a href="../../embed/go/bindgen.html"><strong aria-hidden="true">4.2.5.</strong> Embed bindgen funcs</a></li><li class="chapter-item expanded "><a href="../../embed/go/ref.html" class="active"><strong aria-hidden="true">4.2.6.</strong> API references</a></li></ol></li><li class="chapter-item "><a href="../../embed/node.html"><strong aria-hidden="true">4.3.</strong> Node.js SDK</a></li><li class="chapter-item "><a href="../../embed/rust.html"><strong aria-hidden="true">4.4.</strong> Rust SDK</a></li><li class="chapter-item "><a href="../../embed/python.html"><strong aria-hidden="true">4.5.</strong> Python SDK</a></li></ol></li><li class="chapter-item "><a href="../../kubernetes.html"><strong aria-hidden="true">5.</strong> WasmEdge in Kubernetes</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../kubernetes/quickstart.html"><strong aria-hidden="true">5.1.</strong> Quick start</a></li><li class="chapter-item "><a href="../../kubernetes/demo.html"><strong aria-hidden="true">5.2.</strong> Demo apps</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../kubernetes/demo/wasi.html"><strong aria-hidden="true">5.2.1.</strong> Simple example</a></li><li class="chapter-item "><a href="../../kubernetes/demo/server.html"><strong aria-hidden="true">5.2.2.</strong> HTTP service</a></li></ol></li><li class="chapter-item "><a href="../../kubernetes/container.html"><strong aria-hidden="true">5.3.</strong> Container runtimes</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../kubernetes/container/crun.html"><strong aria-hidden="true">5.3.1.</strong> crun</a></li><li class="chapter-item "><a href="../../kubernetes/container/runc.html"><strong aria-hidden="true">5.3.2.</strong> runc</a></li><li class="chapter-item "><a href="../../kubernetes/container/youki.html"><strong aria-hidden="true">5.3.3.</strong> youki</a></li></ol></li><li class="chapter-item "><a href="../../kubernetes/cri.html"><strong aria-hidden="true">5.4.</strong> CRI runtimes</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../kubernetes/cri/crio.html"><strong aria-hidden="true">5.4.1.</strong> CRI-O</a></li><li class="chapter-item "><a href="../../kubernetes/cri/containerd.html"><strong aria-hidden="true">5.4.2.</strong> containerd</a></li></ol></li><li class="chapter-item "><a href="../../kubernetes/kubernetes.html"><strong aria-hidden="true">5.5.</strong> Kubernetes</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../kubernetes/kubernetes/kubernetes-crio.html"><strong aria-hidden="true">5.5.1.</strong> Kubernetes + CRI-O</a></li><li class="chapter-item "><a href="../../kubernetes/kubernetes/kubernetes-containerd.html"><strong aria-hidden="true">5.5.2.</strong> Kubernetes + containerd</a></li><li class="chapter-item "><a href="../../kubernetes/kubernetes/kubeedge.html"><strong aria-hidden="true">5.5.3.</strong> KubeEdge</a></li><li class="chapter-item "><a href="../../kubernetes/kubernetes/superedge.html"><strong aria-hidden="true">5.5.4.</strong> SuperEdge</a></li><li class="chapter-item "><a href="../../kubernetes/kubernetes/openyurt.html"><strong aria-hidden="true">5.5.5.</strong> OpenYurt</a></li></ol></li></ol></li><li class="chapter-item "><a href="../../frameworks.html"><strong aria-hidden="true">6.</strong> App frameworks &amp; platforms</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../frameworks/mesh.html"><strong aria-hidden="true">6.1.</strong> Service mesh &amp; runtimes</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../frameworks/mesh/dapr.html"><strong aria-hidden="true">6.1.1.</strong> Dapr</a></li><li class="chapter-item "><a href="../../frameworks/mesh/mosn.html"><strong aria-hidden="true">6.1.2.</strong> MOSN</a></li><li class="chapter-item "><a href="../../frameworks/mesh/eventmesh.html"><strong aria-hidden="true">6.1.3.</strong> Apache EventMesh</a></li></ol></li><li class="chapter-item "><a href="../../frameworks/app.html"><strong aria-hidden="true">6.2.</strong> Application frameworks</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../frameworks/app/yomo.html"><strong aria-hidden="true">6.2.1.</strong> YoMo</a></li><li class="chapter-item "><a href="../../frameworks/app/reactr.html"><strong aria-hidden="true">6.2.2.</strong> Reactr</a></li></ol></li><li class="chapter-item "><a href="../../frameworks/serverless.html"><strong aria-hidden="true">6.3.</strong> Serverless platforms</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../frameworks/serverless/vercel.html"><strong aria-hidden="true">6.3.1.</strong> Vercel</a></li><li class="chapter-item "><a href="../../frameworks/serverless/netlify.html"><strong aria-hidden="true">6.3.2.</strong> Netlify</a></li><li class="chapter-item "><a href="../../frameworks/serverless/aws.html"><strong aria-hidden="true">6.3.3.</strong> AWS</a></li><li class="chapter-item "><a href="../../frameworks/serverless/tencent.html"><strong aria-hidden="true">6.3.4.</strong> Tencent</a></li><li class="chapter-item "><a href="../../frameworks/serverless/secondstate.html"><strong aria-hidden="true">6.3.5.</strong> Second State</a></li></ol></li></ol></li><li class="chapter-item "><a href="../../os.html"><strong aria-hidden="true">7.</strong> Operating systems</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../os/linux.html"><strong aria-hidden="true">7.1.</strong> Linux</a></li><li class="chapter-item "><a href="../../os/windows.html"><strong aria-hidden="true">7.2.</strong> Windows</a></li><li class="chapter-item "><a href="../../os/mac.html"><strong aria-hidden="true">7.3.</strong> Mac</a></li><li class="chapter-item "><a href="../../os/sel4.html"><strong aria-hidden="true">7.4.</strong> seL4</a></li><li class="chapter-item "><a href="../../os/openharmony.html"><strong aria-hidden="true">7.5.</strong> Open Harmony</a></li><li class="chapter-item "><a href="../../os/raspberrypi.html"><strong aria-hidden="true">7.6.</strong> Raspberry Pi</a></li></ol></li><li class="chapter-item "><a href="../../extend.html"><strong aria-hidden="true">8.</strong> Contribute to WasmEdge</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../extend/build.html"><strong aria-hidden="true">8.1.</strong> Build WasmEdge from source</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../extend/build_on_mac.html"><strong aria-hidden="true">8.1.1.</strong> Build for Mac</a></li><li class="chapter-item "><a href="../../extend/build_on_windows.html"><strong aria-hidden="true">8.1.2.</strong> Build for Windows</a></li></ol></li><li class="chapter-item "><a href="../../extend/plugin.html"><strong aria-hidden="true">8.2.</strong> WasmEdge plug-in API</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../extend/plugin/hostfunction.html"><strong aria-hidden="true">8.2.1.</strong> Host functions</a></li><li class="chapter-item "><a href="../../extend/plugin/externref.html"><strong aria-hidden="true">8.2.2.</strong> External references</a></li></ol></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">WasmEdge Runtime</h1>

                    <div class="right-buttons">
                        <a href="../../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/WasmEdge/WasmEdge" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        <a href="https://github.com/WasmEdge/WasmEdge/tree/master/docs/book/en/src/embed/go/ref.md" title="Suggest an edit" aria-label="Suggest an edit">
                            <i id="git-edit-button" class="fa fa-edit"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="wasmedge-go-api-references"><a class="header" href="#wasmedge-go-api-references">WasmEdge Go API references</a></h1>
<p>The followings are the guides to working with the WasmEdge-Go SDK.</p>
<h2 id="table-of-contents"><a class="header" href="#table-of-contents">Table of Contents</a></h2>
<ul>
<li><a href="#Getting-Started">Getting Started</a>
<ul>
<li><a href="#WasmEdge-Installation">WasmEdge Installation</a></li>
<li><a href="#Get-WasmEdge-go">Get WasmEdge-go</a></li>
<li><a href="#WasmEdge-go-Extensions">WasmEdge-go Extensions</a></li>
<li><a href="#Example-of-Embedding-A-Function-with-wasm-bindgen">Example of Embedding A Function with wasm-bindgen</a></li>
<li><a href="#Example-of-Embedding-A-Full-WASI-Program">Example of Embedding A Full WASI Program</a></li>
</ul>
</li>
<li><a href="#WasmEdge-go-Basics">WasmEdge-go Basics</a>
<ul>
<li><a href="#Version">Version</a></li>
<li><a href="#Logging-Settings">Logging Settings</a></li>
<li><a href="#Value-Types">Value Types</a></li>
<li><a href="#Results">Results</a></li>
<li><a href="#Contexts-And-Their-Life-Cycles">Contexts And Their Life Cycles</a></li>
<li><a href="#Wasm-data-structures">WASM data structures</a></li>
<li><a href="#Configurations">Configurations</a></li>
<li><a href="#Statistics">Statistics</a></li>
</ul>
</li>
<li><a href="#WasmEdge-VM">WasmEdge VM</a>
<ul>
<li><a href="#WASM-Execution-Example-With-VM-Object">WASM Execution Example With VM Object</a></li>
<li><a href="#VM-Creations">VM Creations</a></li>
<li><a href="#Preregistrations">Preregistrations</a></li>
<li><a href="#Host-Module-Registrations">Host Module Registrations</a></li>
<li><a href="#WASM-Registrations-And-Executions">WASM Registrations And Executions</a></li>
<li><a href="#Instance-Tracing">Instance Tracing</a></li>
</ul>
</li>
<li><a href="#WasmEdge-Runtime">WasmEdge Runtime</a>
<ul>
<li><a href="#WASM-Execution-Example-Step-By-Step">WASM Execution Example Step-By-Step</a></li>
<li><a href="#Loader">Loader</a></li>
<li><a href="#Validator">Validator</a></li>
<li><a href="#Executor">Executor</a></li>
<li><a href="#AST-Module">AST Module</a></li>
<li><a href="#Store">Store</a></li>
<li><a href="#Instances">Instances</a></li>
<li><a href="#Host-Functions">Host Functions</a></li>
</ul>
</li>
<li><a href="#WasmEdge-AOT-Compiler">WasmEdge AOT Compiler</a>
<ul>
<li><a href="#Compilation-Example">Compilation Example</a></li>
<li><a href="#Compiler-Options">Compiler Options</a></li>
</ul>
</li>
</ul>
<h2 id="getting-started"><a class="header" href="#getting-started">Getting Started</a></h2>
<p>The WasmEdge-go requires golang version &gt;= 1.15. Please check your golang version before installation. Developers can <a href="https://golang.org/dl/">download golang here</a>.</p>
<pre><code class="language-bash">$ go version
go version go1.16.5 linux/amd64
</code></pre>
<h3 id="wasmedge-installation"><a class="header" href="#wasmedge-installation">WasmEdge Installation</a></h3>
<p>Developers must <a href="start/install.html">install the WasmEdge shared library</a> with the same <code>WasmEdge-go</code> release or pre-release version.</p>
<pre><code class="language-bash">wget -qO- https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/utils/install.sh | bash -s -- -v 0.9.0
</code></pre>
<p>For the developers need the <code>TensorFlow</code> or <code>Image</code> extension for <code>WasmEdge-go</code>, please install the <code>WasmEdge</code> with extensions:</p>
<pre><code class="language-bash">wget -qO- https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/utils/install.sh | bash -s -- -e tf,image -v 0.9.0
</code></pre>
<p>Noticed that the <code>TensorFlow</code> and <code>Image</code> extensions are only for the <code>Linux</code> platforms.
After installation, developers can use the <code>source</code> command to update the include and linking searching path.</p>
<h3 id="get-wasmedge-go"><a class="header" href="#get-wasmedge-go">Get WasmEdge-go</a></h3>
<p>After the WasmEdge installation, developers can get the <code>WasmEdge-go</code> package and build it in your Go project directory.</p>
<pre><code class="language-bash">$ go get github.com/second-state/WasmEdge-go/wasmedge@v0.9.0
$ go build
</code></pre>
<h3 id="wasmedge-go-extensions"><a class="header" href="#wasmedge-go-extensions">WasmEdge-go Extensions</a></h3>
<p>By default, the <code>WasmEdge-go</code> only turns on the basic runtime.</p>
<p><code>WasmEdge-go</code> has the following extensions (on the Linux platforms only):</p>
<ul>
<li>
<p>Tensorflow</p>
<ul>
<li>
<p>This extension supports the host functions in <a href="https://github.com/second-state/WasmEdge-tensorflow">WasmEdge-tensorflow</a>.</p>
</li>
<li>
<p>The <code>TensorFlow</code> extension when installing <code>WasmEdge</code> is required. Please install <code>WasmEdge</code> with the <code>-e tensorflow</code> command.</p>
</li>
<li>
<p>For using this extension, the tag <code>tensorflow</code> when building is required:</p>
<pre><code class="language-bash">$ go build -tags tensorflow
</code></pre>
</li>
</ul>
</li>
<li>
<p>Image</p>
<ul>
<li>
<p>This extension supports the host functions in <a href="https://github.com/second-state/WasmEdge-image">WasmEdge-image</a>.</p>
</li>
<li>
<p>The <code>Image</code> extension when installing <code>WasmEdge</code> is required. Please install <code>WasmEdge</code> with the <code>-e image</code> command.</p>
</li>
<li>
<p>For using this extension, the tag <code>image</code> when building is required:</p>
<pre><code class="language-bash">$ go build -tags image
</code></pre>
</li>
</ul>
</li>
</ul>
<p>Users can also turn on the multiple extensions when building:</p>
<pre><code class="language-bash">$ go build -tags image,tensorflow
</code></pre>
<h3 id="example-of-embedding-a-function-with-wasm-bindgen"><a class="header" href="#example-of-embedding-a-function-with-wasm-bindgen">Example of Embedding A Function with wasm-bindgen</a></h3>
<p>In <a href="https://github.com/second-state/WasmEdge-go-examples/tree/master/go_BindgenFuncs">this example</a>, we will demonstrate how to call a few simple WebAssembly functions with wasm-bindgen from a Golang app. The <a href="https://github.com/second-state/WasmEdge-go-examples/blob/master/go_BindgenFuncs/rust_bindgen_funcs/src/lib.rs">functions</a> are written in Rust, and require complex call parameters and return values. The <code>#[wasm_bindgen]</code> macro is needed for the compiler tools to auto-generate the correct code to pass call parameters from Golang to WebAssembly.</p>
<p>Note: At this time, we require Rust compiler version 1.50 or less in order for WebAssembly functions to work with WasmEdge’s Golang API. We will <a href="https://github.com/WasmEdge/WasmEdge/issues/264">catch up to the latest Rust</a> compiler version once the Interface Types specification is finalized and supported.</p>
<p>Note: The WebAssembly only supports a few simple data types out of the box. It <a href="https://medium.com/wasm/strings-in-webassembly-wasm-57a05c1ea333">does not support</a> types such as string and array. In order to pass rich types in Golang to WebAssembly, the compiler needs to convert them to simple integers. For example, it converts a string into an integer memory address and an integer length. The <code>wasm-bindgen</code> tool, embedded in rustwasmc, does this conversion automatically.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use wasm_bindgen::prelude::*;
use num_integer::lcm;
use sha3::{Digest, Sha3_256, Keccak256};

#[wasm_bindgen]
pub fn say(s: &amp;str) -&gt; String {
  let r = String::from(&quot;hello &quot;);
  return r + s;
}

#[wasm_bindgen]
pub fn obfusticate(s: String) -&gt; String {
  (&amp;s).chars().map(|c| {
    match c {
      'A' ..= 'M' | 'a' ..= 'm' =&gt; ((c as u8) + 13) as char,
      'N' ..= 'Z' | 'n' ..= 'z' =&gt; ((c as u8) - 13) as char,
      _ =&gt; c
    }
  }).collect()
}

#[wasm_bindgen]
pub fn lowest_common_multiple(a: i32, b: i32) -&gt; i32 {
  let r = lcm(a, b);
  return r;
}

#[wasm_bindgen]
pub fn sha3_digest(v: Vec&lt;u8&gt;) -&gt; Vec&lt;u8&gt; {
  return Sha3_256::digest(&amp;v).as_slice().to_vec();
}

#[wasm_bindgen]
pub fn keccak_digest(s: &amp;[u8]) -&gt; Vec&lt;u8&gt; {
  return Keccak256::digest(s).as_slice().to_vec();
}
<span class="boring">}
</span></code></pre></pre>
<p>First, we use the <a href="dev/rust/bindgen.html"><code>rustwasmc</code> tool</a> to compile the Rust source code into WebAssembly bytecode functions using Rust 1.50 or less.</p>
<pre><code class="language-bash">$ rustup default 1.50.0
$ cd rust_bindgen_funcs
$ rustwasmc build
# The output WASM will be pkg/rust_bindgen_funcs_lib_bg.wasm
</code></pre>
<p>The <a href="https://github.com/second-state/WasmEdge-go-examples/blob/master/go_BindgenFuncs/bindgen_funcs.go">Golang source code</a> to run the WebAssembly function in WasmEdge is as follows. The <code>ExecuteBindgen()</code> function calls the WebAssembly function and passes the parameters with the <code>wasm-bindgen</code> supporting.</p>
<pre><code class="language-go">package main

import (
    &quot;fmt&quot;
    &quot;os&quot;

    &quot;github.com/second-state/WasmEdge-go/wasmedge&quot;
)

func main() {
    /// Expected Args[0]: program name (./bindgen_funcs)
    /// Expected Args[1]: wasm or wasm-so file (rust_bindgen_funcs_lib_bg.wasm)

    wasmedge.SetLogErrorLevel()

    var conf = wasmedge.NewConfigure(wasmedge.WASI)
    var vm = wasmedge.NewVMWithConfig(conf)
    var wasi = vm.GetImportObject(wasmedge.WASI)
    wasi.InitWasi(
        os.Args[1:],     /// The args
        os.Environ(),    /// The envs
        []string{&quot;.:.&quot;}, /// The mapping directories
    )

    /// Instantiate wasm
    vm.LoadWasmFile(os.Args[1])
    vm.Validate()
    vm.Instantiate()

    /// Run bindgen functions
    var res interface{}
    var err error
    
    res, err = vm.ExecuteBindgen(&quot;say&quot;, wasmedge.Bindgen_return_array, []byte(&quot;bindgen funcs test&quot;))
    if err == nil {
        fmt.Println(&quot;Run bindgen -- say:&quot;, string(res.([]byte)))
    } 
    res, err = vm.ExecuteBindgen(&quot;obfusticate&quot;, wasmedge.Bindgen_return_array, []byte(&quot;A quick brown fox jumps over the lazy dog&quot;))
    if err == nil {
        fmt.Println(&quot;Run bindgen -- obfusticate:&quot;, string(res.([]byte)))
    } 
    res, err = vm.ExecuteBindgen(&quot;lowest_common_multiple&quot;, wasmedge.Bindgen_return_i32, int32(123), int32(2))
    if err == nil {
        fmt.Println(&quot;Run bindgen -- lowest_common_multiple:&quot;, res.(int32))
    } 
    res, err = vm.ExecuteBindgen(&quot;sha3_digest&quot;, wasmedge.Bindgen_return_array, []byte(&quot;This is an important message&quot;))
    if err == nil {
        fmt.Println(&quot;Run bindgen -- sha3_digest:&quot;, res.([]byte))
    } 
    res, err = vm.ExecuteBindgen(&quot;keccak_digest&quot;, wasmedge.Bindgen_return_array, []byte(&quot;This is an important message&quot;))
    if err == nil {
        fmt.Println(&quot;Run bindgen -- keccak_digest:&quot;, res.([]byte))
    } 

    vm.Release()
    conf.Release()
}
</code></pre>
<p>Next, build the Golang application with the WasmEdge Golang SDK.</p>
<pre><code class="language-bash">$ go get github.com/second-state/WasmEdge-go/wasmedge@v0.9.0
$ go build
</code></pre>
<p>Run the Golang application and it will run the WebAssembly functions embedded in the WasmEdge runtime.</p>
<pre><code class="language-bash">$ ./bindgen_funcs rust_bindgen_funcs/pkg/rust_bindgen_funcs_lib_bg.wasm
Run bindgen -- say: hello bindgen funcs test
Run bindgen -- obfusticate: N dhvpx oebja sbk whzcf bire gur ynml qbt
Run bindgen -- lowest_common_multiple: 246
Run bindgen -- sha3_digest: [87 27 231 209 189 105 251 49 159 10 211 250 15 159 154 181 43 218 26 141 56 199 25 45 60 10 20 163 54 211 195 203]
Run bindgen -- keccak_digest: [126 194 241 200 151 116 227 33 216 99 159 22 107 3 177 169 216 191 114 156 174 193 32 159 246 228 245 133 52 75 55 27]
</code></pre>
<h3 id="example-of-embedding-a-full-wasi-program"><a class="header" href="#example-of-embedding-a-full-wasi-program">Example of Embedding A Full WASI Program</a></h3>
<p>Note: You can use the latest Rust compiler to create a standalone WasmEdge application with a <code>main.rs</code> functions and then embed it into a Golang application.</p>
<p>Besides functions, the WasmEdge Golang SDK can also <a href="https://github.com/second-state/WasmEdge-go-examples/tree/master/go_ReadFile">embed standalone WebAssembly applications</a> — i.e. a Rust application with a <code>main()</code> function compiled into WebAssembly.</p>
<p>Our <a href="https://github.com/second-state/WasmEdge-go-examples/tree/master/go_ReadFile/rust_readfile">demo Rust application</a> reads from a file. Note that there is no need for <code>#[wasm_bindgen]</code> here, as the WebAssembly program’s WASI supporting for the <code>argv</code> input and <code>exit code</code> output of the <code>main()</code> function.</p>
<pre><pre class="playground"><code class="language-rust">use std::env;
use std::fs::File;
use std::io::{self, BufRead};

fn main() {
    // Get the argv.
    let args: Vec&lt;String&gt; = env::args().collect();
    if args.len() &lt;= 1 {
        println!(&quot;Rust: ERROR - No input file name.&quot;);
        return;
    }

    // Open the file.
    println!(&quot;Rust: Opening input file \&quot;{}\&quot;...&quot;, args[1]);
    let file = match File::open(&amp;args[1]) {
        Err(why) =&gt; {
            println!(&quot;Rust: ERROR - Open file \&quot;{}\&quot; failed: {}&quot;, args[1], why);
            return;
        },
        Ok(file) =&gt; file,
    };

    // Read lines.
    let reader = io::BufReader::new(file);
    let mut texts:Vec&lt;String&gt; = Vec::new();
    for line in reader.lines() {
        if let Ok(text) = line {
            texts.push(text);
        }
    }
    println!(&quot;Rust: Read input file \&quot;{}\&quot; succeeded.&quot;, args[1]);

    // Get stdin to print lines.
    println!(&quot;Rust: Please input the line number to print the line of file.&quot;);
    let stdin = io::stdin();
    for line in stdin.lock().lines() {
        let input = line.unwrap();
        match input.parse::&lt;usize&gt;() {
            Ok(n) =&gt; if n &gt; 0 &amp;&amp; n &lt;= texts.len() {
                println!(&quot;{}&quot;, texts[n - 1]);
            } else {
                println!(&quot;Rust: ERROR - Line \&quot;{}\&quot; is out of range.&quot;, n);
            },
            Err(e) =&gt; println!(&quot;Rust: ERROR - Input \&quot;{}\&quot; is not an integer: {}&quot;, input, e),
        }
    }
    println!(&quot;Rust: Process end.&quot;);
}
</code></pre></pre>
<p>Use the <code>rustwasmc</code> tool to compile the application into WebAssembly.</p>
<pre><code class="language-bash">$ cd rust_readfile
$ rustwasmc build
# The output file will be at `pkg/rust_readfile.wasm`.
</code></pre>
<p>Or you can compile the application into WebAssembly directly by <code>cargo</code>:</p>
<pre><code class="language-bash">$ cd rust_readfile
# Need to add the `wasm32-wasi` target.
$ rustup target add wasm32-wasi
$ cargo build --release --target=wasm32-wasi
# The output wasm will be at `target/wasm32-wasi/release/rust_readfile.wasm`.
</code></pre>
<p>The Golang source code to run the WebAssembly function in WasmEdge is as follows.</p>
<pre><code class="language-go">package main

import (
    &quot;os&quot;

    &quot;github.com/second-state/WasmEdge-go/wasmedge&quot;
)

func main() {
    wasmedge.SetLogErrorLevel()

    var conf = wasmedge.NewConfigure(wasmedge.REFERENCE_TYPES)
    conf.AddConfig(wasmedge.WASI)
    var vm = wasmedge.NewVMWithConfig(conf)
    var wasi = vm.GetImportObject(wasmedge.WASI)
    wasi.InitWasi(
        os.Args[1:],     /// The args
        os.Environ(),    /// The envs
        []string{&quot;.:.&quot;}, /// The mapping directories
    )

    /// Instantiate and run WASM &quot;_start&quot; function, which refers to the main() function
    vm.RunWasmFile(os.Args[1], &quot;_start&quot;)

    vm.Release()
    conf.Release()
}
</code></pre>
<p>Next, build the Golang application with the WasmEdge Golang SDK.</p>
<pre><code class="language-bash">$ go get github.com/second-state/WasmEdge-go/wasmedge@v0.9.0
$ go build
</code></pre>
<p>Run the Golang application.</p>
<pre><code class="language-bash">$ ./read_file rust_readfile/pkg/rust_readfile.wasm file.txt
Rust: Opening input file &quot;file.txt&quot;...
Rust: Read input file &quot;file.txt&quot; succeeded.
Rust: Please input the line number to print the line of file.
# Input &quot;5&quot; and press Enter.
5
# The output will be the 5th line of `file.txt`:
abcDEF___!@#$%^
# To terminate the program, send the EOF (Ctrl + D).
^D
# The output will print the terminate message:
Rust: Process end.
</code></pre>
<p>For more examples, please refer to the <a href="https://github.com/second-state/WasmEdge-go-examples/">example repository</a>.</p>
<h2 id="wasmedge-go-basics"><a class="header" href="#wasmedge-go-basics">WasmEdge-go Basics</a></h2>
<p>In this partition, we will introduce the utilities and concepts of WasmEdge-go APIs and data structures.</p>
<h3 id="version"><a class="header" href="#version">Version</a></h3>
<p>The <code>Version</code> related APIs provide developers to check for the installed WasmEdge shared library version.</p>
<pre><code class="language-go">import &quot;github.com/second-state/WasmEdge-go/wasmedge&quot;

verstr := wasmedge.GetVersion() // Will be `string` of WasmEdge version.
vermajor := wasmedge.GetVersionMajor() // Will be `uint` of WasmEdge major version number.
verminor := wasmedge.GetVersionMinor() // Will be `uint` of WasmEdge minor version number.
verpatch := wasmedge.GetVersionPatch() // Will be `uint` of WasmEdge patch version number.
</code></pre>
<h3 id="logging-settings"><a class="header" href="#logging-settings">Logging Settings</a></h3>
<p>The <code>wasmedge.SetLogErrorLevel()</code> and <code>wasmedge.SetLogDebugLevel()</code> APIs can set the logging system to debug level or error level. By default, the error level is set, and the debug info is hidden.</p>
<h3 id="value-types"><a class="header" href="#value-types">Value Types</a></h3>
<p>In WasmEdge-go, the APIs will automatically do the conversion for the built-in types, and implement the data structure for the reference types.</p>
<ol>
<li>
<p>Number types: <code>i32</code>, <code>i64</code>, <code>f32</code>, and <code>f64</code></p>
<ul>
<li>Convert the <code>uint32</code> and <code>int32</code> to <code>i32</code> automatically when passing a value into WASM.</li>
<li>Convert the <code>uint64</code> and <code>int64</code> to <code>i64</code> automatically when passing a value into WASM.</li>
<li>Convert the <code>uint</code> and <code>int</code> to <code>i32</code> automatically when passing a value into WASM in 32-bit system.</li>
<li>Convert the <code>uint</code> and <code>int</code> to <code>i64</code> automatically when passing a value into WASM in 64-bit system.</li>
<li>Convert the <code>float32</code> to <code>f32</code> automatically when passing a value into WASM.</li>
<li>Convert the <code>float64</code> to <code>f64</code> automatically when passing a value into WASM.</li>
<li>Convert the <code>i32</code> from WASM to <code>int32</code> when getting a result.</li>
<li>Convert the <code>i64</code> from WASM to <code>int64</code> when getting a result.</li>
<li>Convert the <code>f32</code> from WASM to <code>float32</code> when getting a result.</li>
<li>Convert the <code>f64</code> from WASM to <code>float64</code> when getting a result.</li>
</ul>
</li>
<li>
<p>Number type: <code>v128</code> for the <code>SIMD</code> proposal</p>
<p>Developers should use the <code>wasmedge.NewV128()</code> to generate a <code>v128</code> value, and use the <code>wasmedge.GetV128()</code> to get the value.</p>
<pre><code class="language-go">val := wasmedge.NewV128(uint64(1234), uint64(5678))
high, low := val.GetVal()
// `high` will be uint64(1234), `low` will be uint64(5678)
</code></pre>
</li>
<li>
<p>Reference types: <code>FuncRef</code> and <code>ExternRef</code> for the <code>Reference-Types</code> proposal</p>
<pre><code class="language-go">funcref := wasmedge.NewFuncRef(10)
// Create a `FuncRef` with function index 10.

num := 1234
// `num` is a `int`.
externref := wasmedge.NewExternRef(&amp;num)
// Create an `ExternRef` which reference to the `num`.
num = 5678
// Modify the `num` to 5678.
numref := externref.GetRef().(*int)
// Get the original reference from the `ExternRef`.
fmt.Println(*numref)
// Will print `5678`.
numref.Release()
// Should call the `Release` method.
</code></pre>
</li>
</ol>
<h3 id="results"><a class="header" href="#results">Results</a></h3>
<p>The <code>Result</code> object specifies the execution status. Developers can use the <code>Error()</code> function to get the error message.</p>
<pre><code class="language-go">// Assume that `vm` is a `wasmedge.VM` object.
res, err = vm.Execute(...) // Ignore the detail of parameters.
// Assume that `res, err` are the return values for executing a function with `vm`.
if err != nil {
    fmt.Println(&quot;Error message:&quot;, err.Error())
}
</code></pre>
<h3 id="contexts-and-their-life-cycles"><a class="header" href="#contexts-and-their-life-cycles">Contexts And Their Life Cycles</a></h3>
<p>The objects, such as <code>VM</code>, <code>Store</code>, and <code>Function</code>, etc., are composed of <code>Context</code>s in the WasmEdge shared library.
All of the contexts can be created by calling the corresponding <code>New</code> APIs, developers should also call the corresponding <code>Release</code> functions of the contexts to release the resources.
Noticed that it's not necessary to call the <code>Release</code> functions for the contexts which are retrieved from other contexts but not created from the <code>New</code> APIs.</p>
<pre><code class="language-go">// Create a Configure.
conf := wasmedge.NewConfigure()
// Release the `conf` immediately.
conf.Release()
</code></pre>
<p>The details of other contexts will be introduced later.</p>
<h3 id="wasm-data-structures"><a class="header" href="#wasm-data-structures">WASM Data Structures</a></h3>
<p>The WASM data structures are used for creating instances or can be queried from instance contexts.
The details of instances creation will be introduced in the <a href="#Instances">Instances</a>.</p>
<ol>
<li>
<p>Limit</p>
<p>The <code>Limit</code> struct presents the minimum and maximum value data structure.</p>
<pre><code class="language-go">lim1 := wasmedge.NewLimit(12)
fmt.Println(lim1.HasMax())
// Will print `false`.
fmt.Println(lim1.GetMin())
// Will print `12`.

lim2 := wasmedge.NewLimitWithMax(15, 50)
fmt.Println(lim2.HasMax())
// Will print `true`.
fmt.Println(lim2.GetMin())
// Will print `15`.
fmt.Println(lim2.GetMax())
// Will print `50`.
</code></pre>
</li>
<li>
<p>Function type context</p>
<p>The <code>FunctionType</code> is an object holds the function type context and used for the <code>Function</code> creation, checking the value types of a <code>Function</code> instance, or getting the function type with function name from VM.
Developers can use the <code>FunctionType</code> APIs to get the parameter or return value types information.</p>
<pre><code class="language-go">functype := wasmedge.NewFunctionType(
    []wasmedge.ValType{
        wasmedge.ValType_ExternRef,
        wasmedge.ValType_I32,
        wasmedge.ValType_I64,
    }, []wasmedge.ValType{
        wasmedge.ValType_F32,
        wasmedge.ValType_F64,
    })

plen := functype.GetParametersLength()
// `plen` will be 3.
rlen := functype.GetReturnsLength()
// `rlen` will be 2.
plist := functype.GetParameters()
// `plist` will be `[]wasmedge.ValType{wasmedge.ValType_ExternRef, wasmedge.ValType_I32, wasmedge.ValType_I64}`.
rlist := functype.GetReturns()
// `rlist` will be `[]wasmedge.ValType{wasmedge.ValType_F32, wasmedge.ValType_F64}`.

functype.Release()
</code></pre>
</li>
<li>
<p>Table type context</p>
<p>The <code>TableType</code> is an object holds the table type context and used for <code>Table</code> instance creation or getting information from <code>Table</code> instances.</p>
<pre><code class="language-go">lim := wasmedge.NewLimit(12)
tabtype := wasmedge.NewTableType(wasmedge.RefType_ExternRef, lim)

rtype := tabtype.GetRefType()
// `rtype` will be `wasmedge.RefType_ExternRef`.
getlim := tabtype.GetLimit()
// `getlim` will be the same value as `lim`.

tabtype.Release()
</code></pre>
</li>
<li>
<p>Memory type context</p>
<p>The <code>MemoryType</code> is an object holds the memory type context and used for <code>Memory</code> instance creation or getting information from <code>Memory</code> instances.</p>
<pre><code class="language-go">lim := wasmedge.NewLimit(1)
memtype := wasmedge.NewMemoryType(lim)

getlim := memtype.GetLimit()
// `getlim` will be the same value as `lim`.

memtype.Release()
</code></pre>
</li>
<li>
<p>Global type context</p>
<p>The <code>GlobalType</code> is an object holds the global type context and used for <code>Global</code> instance creation or getting information from <code>Global</code> instances.</p>
<pre><code class="language-go">globtype := wasmedge.NewGlobalType(wasmedge.ValType_F64, wasmedge.ValMut_Var)

vtype := globtype.GetValType()
// `vtype` will be `wasmedge.ValType_F64`.
vmut := globtype.GetMutability()
// `vmut` will be `wasmedge.ValMut_Var`.

globtype.Release()
</code></pre>
</li>
<li>
<p>Import type context</p>
<p>The <code>ImportType</code> is an object holds the import type context and used for getting the imports information from a <a href="#AST-Module">AST Module</a>.
Developers can get the external type (<code>function</code>, <code>table</code>, <code>memory</code>, or <code>global</code>), import module name, and external name from an <code>ImportType</code> object.
The details about querying <code>ImportType</code> objects will be introduced in the <a href="#AST-Module">AST Module</a>.</p>
<pre><code class="language-go">var ast *wasmedge.AST = ...
// Assume that `ast` is returned by the `Loader` for the result of loading a WASM file.
imptypelist := ast.ListImports()
// Assume that `imptypelist` is an array listed from the `ast` for the imports.

for i, imptype := range imptypelist {
    exttype := imptype.GetExternalType()
    // The `exttype` must be one of `wasmedge.ExternType_Function`, `wasmedge.ExternType_Table`,
    // wasmedge.ExternType_Memory`, or `wasmedge.ExternType_Global`.

    modname := imptype.GetModuleName()
    extname := imptype.GetExternalName()
    // Get the module name and external name of the imports.

    extval := imptype.GetExternalValue()
    // The `extval` is the type of `interface{}` which indicates one of `*wasmedge.FunctionType`,
    // `*wasmedge.TableType`, `*wasmedge.MemoryType`, or `*wasmedge.GlobalType`.
}
</code></pre>
</li>
<li>
<p>Export type context</p>
<p>The <code>ExportType</code> is an object holds the export type context is used for getting the exports information from a <a href="#AST-Module">AST Module</a>.
Developers can get the external type (<code>function</code>, <code>table</code>, <code>memory</code>, or <code>global</code>) and external name from an <code>Export Type</code> context.
The details about querying <code>ExportType</code> objects will be introduced in the <a href="#AST-Module">AST Module</a>.</p>
<pre><code class="language-go">var ast *wasmedge.AST = ...
// Assume that `ast` is returned by the `Loader` for the result of loading a WASM file.
exptypelist := ast.ListExports()
// Assume that `exptypelist` is an array listed from the `ast` for the exports.

for i, exptype := range exptypelist {
    exttype := exptype.GetExternalType()
    // The `exttype` must be one of `wasmedge.ExternType_Function`, `wasmedge.ExternType_Table`,
    // wasmedge.ExternType_Memory`, or `wasmedge.ExternType_Global`.

    extname := exptype.GetExternalName()
    // Get the external name of the exports.

    extval := exptype.GetExternalValue()
    // The `extval` is the type of `interface{}` which indicates one of `*wasmedge.FunctionType`,
    // `*wasmedge.TableType`, `*wasmedge.MemoryType`, or `*wasmedge.GlobalType`.
}
</code></pre>
</li>
</ol>
<h3 id="configurations"><a class="header" href="#configurations">Configurations</a></h3>
<p>The configuration object, <code>wasmedge.Configure</code>, manages the configurations for <code>Loader</code>, <code>Validator</code>, <code>Executor</code>, <code>VM</code>, and <code>Compiler</code>.
Developers can adjust the settings about the proposals, VM host pre-registrations (such as <code>WASI</code>), and AOT compiler options, and then apply the <code>Configure</code> object to create other runtime objects.</p>
<ol>
<li>
<p>Proposals</p>
<p>WasmEdge supports turning on or off the WebAssembly proposals.
This configuration is effective in any contexts created with the <code>Configure</code> object.</p>
<pre><code class="language-go">const (
    IMPORT_EXPORT_MUT_GLOBALS         = Proposal(C.WasmEdge_Proposal_ImportExportMutGlobals)
    NON_TRAP_FLOAT_TO_INT_CONVERSIONS = Proposal(C.WasmEdge_Proposal_NonTrapFloatToIntConversions)
    SIGN_EXTENSION_OPERATORS          = Proposal(C.WasmEdge_Proposal_SignExtensionOperators)
    MULTI_VALUE                       = Proposal(C.WasmEdge_Proposal_MultiValue)
    BULK_MEMORY_OPERATIONS            = Proposal(C.WasmEdge_Proposal_BulkMemoryOperations)
    REFERENCE_TYPES                   = Proposal(C.WasmEdge_Proposal_ReferenceTypes)
    SIMD                              = Proposal(C.WasmEdge_Proposal_SIMD)
    TAIL_CALL                         = Proposal(C.WasmEdge_Proposal_TailCall)
    ANNOTATIONS                       = Proposal(C.WasmEdge_Proposal_Annotations)
    MEMORY64                          = Proposal(C.WasmEdge_Proposal_Memory64)
    THREADS                           = Proposal(C.WasmEdge_Proposal_Threads)
    EXCEPTION_HANDLING                = Proposal(C.WasmEdge_Proposal_ExceptionHandling)
    FUNCTION_REFERENCES               = Proposal(C.WasmEdge_Proposal_FunctionReferences)
)
</code></pre>
<p>Developers can add or remove the proposals into the <code>Configure</code> object.</p>
<pre><code class="language-go">// By default, the following proposals have turned on initially:
// * IMPORT_EXPORT_MUT_GLOBALS
// * NON_TRAP_FLOAT_TO_INT_CONVERSIONS
// * SIGN_EXTENSION_OPERATORS
// * MULTI_VALUE
// * BULK_MEMORY_OPERATIONS
// * REFERENCE_TYPES
// * SIMD
conf := wasmedge.NewConfigure()
// Developers can also pass the proposals as parameters:
// conf := wasmedge.NewConfigure(wasmedge.SIMD, wasmedge.BULK_MEMORY_OPERATIONS)
conf.AddConfig(wasmedge.SIMD)
conf.RemoveConfig(wasmedge.REFERENCE_TYPES)
is_bulkmem := conf.HasConfig(wasmedge.BULK_MEMORY_OPERATIONS)
// The `is_bulkmem` will be `true`.
conf.Release()
</code></pre>
</li>
<li>
<p>Host registrations</p>
<p>This configuration is used for the <code>VM</code> context to turn on the <code>WASI</code> or <code>wasmedge_process</code> supports and only effective in <code>VM</code> objects.</p>
<pre><code class="language-go">const (
    WASI             = HostRegistration(C.WasmEdge_HostRegistration_Wasi)
    WasmEdge_PROCESS = HostRegistration(C.WasmEdge_HostRegistration_WasmEdge_Process)
)
</code></pre>
<p>The details will be introduced in the <a href="###Preregistrations">preregistrations of VM context</a>.</p>
<pre><code class="language-go">conf := wasmedge.NewConfigure()
// Developers can also pass the proposals as parameters:
// conf := wasmedge.NewConfigure(wasmedge.WASI)
conf.AddConfig(wasmedge.WASI)
conf.Release()
</code></pre>
</li>
<li>
<p>Maximum memory pages</p>
<p>Developers can limit the page size of memory instances by this configuration.
When growing the page size of memory instances in WASM execution and exceeding the limited size, the page growing will fail.
This configuration is only effective in the <code>Executor</code> and <code>VM</code> objects.</p>
<pre><code class="language-go">conf := wasmedge.NewConfigure()

pagesize := conf.GetMaxMemoryPage()
// By default, the maximum memory page size in each memory instances is 65536.
conf.SetMaxMemoryPage(1234)
pagesize := conf.GetMaxMemoryPage()
// `pagesize` will be 1234.

conf.Release()
</code></pre>
</li>
<li>
<p>AOT compiler options</p>
<p>The AOT compiler options configure the behavior about optimization level, output format, dump IR, and generic binary.</p>
<pre><code class="language-go">const (
    // Disable as many optimizations as possible.
    CompilerOptLevel_O0 = CompilerOptimizationLevel(C.WasmEdge_CompilerOptimizationLevel_O0)
    // Optimize quickly without destroying debuggability.
    CompilerOptLevel_O1 = CompilerOptimizationLevel(C.WasmEdge_CompilerOptimizationLevel_O1)
    // Optimize for fast execution as much as possible without triggering significant incremental compile time or code size growth.
    CompilerOptLevel_O2 = CompilerOptimizationLevel(C.WasmEdge_CompilerOptimizationLevel_O2)
    // Optimize for fast execution as much as possible.
    CompilerOptLevel_O3 = CompilerOptimizationLevel(C.WasmEdge_CompilerOptimizationLevel_O3)
    // Optimize for small code size as much as possible without triggering significant incremental compile time or execution time slowdowns.
    CompilerOptLevel_Os = CompilerOptimizationLevel(C.WasmEdge_CompilerOptimizationLevel_Os)
    /// Optimize for small code size as much as possible.
    CompilerOptLevel_Oz = CompilerOptimizationLevel(C.WasmEdge_CompilerOptimizationLevel_Oz)
)

const (
    /// Native dynamic library format.
    CompilerOutputFormat_Native = CompilerOutputFormat(C.WasmEdge_CompilerOutputFormat_Native)
    /// WebAssembly with AOT compiled codes in custom section.
    CompilerOutputFormat_Wasm = CompilerOutputFormat(C.WasmEdge_CompilerOutputFormat_Wasm)
)
</code></pre>
<p>These configurations are only effective in <code>Compiler</code> contexts.</p>
<pre><code class="language-go">conf := wasmedge.NewConfigure()

// By default, the optimization level is O3.
conf.SetCompilerOptimizationLevel(wasmedge.CompilerOptLevel_O2)
// By default, the output format is universal WASM.
conf.SetCompilerOutputFormat(wasmedge.CompilerOutputFormat_Native)
// By default, the dump IR is `false`.
conf.SetCompilerDumpIR(true)
// By default, the generic binary is `false`.
conf.SetCompilerGenericBinary(true)

conf.Release()
</code></pre>
</li>
<li>
<p>Statistics options</p>
<p>The statistics options configure the behavior about instruction counting, cost measuring, and time measuring in both runtime and AOT compiler.
These configurations are effective in <code>Compiler</code>, <code>VM</code>, and <code>Executor</code> objects.</p>
<pre><code class="language-go">conf := wasmedge.NewConfigure()

// By default, the intruction counting is `false` when running a compiled-WASM or a pure-WASM.
conf.SetStatisticsInstructionCounting(true)
// By default, the cost measurement is `false` when running a compiled-WASM or a pure-WASM.
conf.SetStatisticsTimeMeasuring(true)
// By default, the time measurement is `false` when running a compiled-WASM or a pure-WASM.
conf.SetStatisticsCostMeasuring(true)

conf.Release()
</code></pre>
</li>
</ol>
<h2 id="wasmedge-vm"><a class="header" href="#wasmedge-vm">WasmEdge VM</a></h2>
<p>In this partition, we will introduce the functions of <code>wasmedge.VM</code> object and show examples of executing WASM functions.</p>
<h3 id="wasm-execution-example-with-vm-object"><a class="header" href="#wasm-execution-example-with-vm-object">WASM Execution Example With VM Object</a></h3>
<p>The following shows the example of running the WASM for getting the Fibonacci.
This example uses the <a href="../tools/wasmedge/examples/fibonacci.wasm">fibonacci.wasm</a>, and the corresponding WAT file is at <a href="../tools/wasmedge/examples/fibonacci.wat">fibonacci.wat</a>.</p>
<pre><code>(module
 (export &quot;fib&quot; (func $fib))
 (func $fib (param $n i32) (result i32)
  (if
   (i32.lt_s (get_local $n)(i32.const 2))
   (return (i32.const 1))
  )
  (return
   (i32.add
    (call $fib (i32.sub (get_local $n)(i32.const 2)))
    (call $fib (i32.sub (get_local $n)(i32.const 1)))
   )
  )
 )
)
</code></pre>
<ol>
<li>
<p>Run WASM functions rapidly</p>
<p>Create a new Go project first:</p>
<pre><code class="language-bash">$ mkdir wasmedge_test &amp;&amp; cd wasmedge_test
$ go mod init wasmedge_test
</code></pre>
<p>Assume that the WASM file <a href="../tools/wasmedge/examples/fibonacci.wasm"><code>fibonacci.wasm</code></a> is copied into the current <code>wasmedge_test</code> directory, and create and edit the Go file <code>main.go</code> as following:</p>
<pre><code class="language-go">package main

import (
    &quot;fmt&quot;

    &quot;github.com/second-state/WasmEdge-go/wasmedge&quot;
)

func main() {
    // Set the logging level.
    wasmedge.SetLogErrorLevel()

    // Create the configure context and add the WASI support.
    // This step is not necessary unless you need WASI support.
    conf := wasmedge.NewConfigure(wasmedge.WASI)
    // Create VM with the configure.
    vm := wasmedge.NewVMWithConfig(conf)

    res, err := vm.RunWasmFile(&quot;fibonacci.wasm&quot;, &quot;fib&quot;, uint32(21))
    if err == nil {
        fmt.Println(&quot;Get fibonacci[21]:&quot;, res[0].(int32))
    } else {
        fmt.Println(&quot;Run failed:&quot;, err.Error())
    }

    vm.Release()
    conf.Release()
}
</code></pre>
<p>Then you can build and run the Golang application with the WasmEdge Golang SDK: (the 21 Fibonacci number is 17711 in 0-based index)</p>
<pre><code class="language-bash">$ go get github.com/second-state/WasmEdge-go/wasmedge@v0.9.0
$ go build
$ ./wasmedge_test
Get fibonacci[21]: 17711
</code></pre>
</li>
<li>
<p>Instantiate and run WASM functions manually</p>
<p>Besides the above example, developers can run the WASM functions step-by-step with <code>VM</code> object APIs:</p>
<pre><code class="language-go">package main

import (
    &quot;fmt&quot;

    &quot;github.com/second-state/WasmEdge-go/wasmedge&quot;
)

func main() {
    // Set the logging level.
    wasmedge.SetLogErrorLevel()

    // Create VM.
    vm := wasmedge.NewVM()
    var err error
    var res []interface{}

    // Step 1: Load WASM file.
    err = vm.LoadWasmFile(&quot;fibonacci.wasm&quot;)
    if err != nil {
        fmt.Println(&quot;Load WASM from file FAILED:&quot;, err.Error())
        return
    }

    // Step 2: Validate the WASM module.
    err = vm.Validate()
    if err != nil {
        fmt.Println(&quot;Validation FAILED:&quot;, err.Error())
        return
    }

    // Step 3: Instantiate the WASM module.
    err = vm.Instantiate()
    // Developers can load, validate, and instantiate another WASM module
    // to replace the instantiated one. In this case, the old module will
    // be cleared, but the registered modules are still kept.
    if err != nil {
        fmt.Println(&quot;Instantiation FAILED:&quot;, err.Error())
        return
    }

    // Step 4: Execute WASM functions. Parameters: (funcname, args...)
    res, err = vm.Execute(&quot;fib&quot;, uint32(25))
    // Developers can execute functions repeatedly after instantiation.
    if err == nil {
        fmt.Println(&quot;Get fibonacci[25]:&quot;, res[0].(int32))
    } else {
        fmt.Println(&quot;Run failed:&quot;, err.Error())
    }

    vm.Release()
}
</code></pre>
<p>Then you can build and run: (the 25th Fibonacci number is 121393 in 0-based index)</p>
<pre><code class="language-bash">$ go build
$ ./wasmedge_test
Get fibonacci[25]: 121393
</code></pre>
<p>The following graph explains the status of the <code>VM</code> object.</p>
<pre><code>                       |========================|
              |-------&gt;|      VM: Initiated     |
              |        |========================|
              |                    |
              |                 LoadWasm
              |                    |
              |                    v
              |        |========================|
              |--------|       VM: Loaded       |&lt;-------|
              |        |========================|        |
              |              |            ^              |
              |         Validate          |              |
          Cleanup            |          LoadWasm         |
              |              v            |            LoadWasm
              |        |========================|        |
              |--------|      VM: Validated     |        |
              |        |========================|        |
              |              |            ^              |
              |      Instantiate          |              |
              |              |          RegisterModule   |
              |              v            |              |
              |        |========================|        |
              |--------|    VM: Instantiated    |--------|
                       |========================|
                             |            ^
                             |            |
                             --------------
                Instantiate, Execute, ExecuteRegistered,
                ExecuteBindgen, ExecuteBindgenRegistered
</code></pre>
<p>The status of the <code>VM</code> context would be <code>Inited</code> when created.
After loading WASM successfully, the status will be <code>Loaded</code>.
After validating WASM successfully, the status will be <code>Validated</code>.
After instantiating WASM successfully, the status will be <code>Instantiated</code>, and developers can invoke functions.
Developers can register WASM or import objects in any status, but they should instantiate WASM again.
Developers can also load WASM in any status, and they should validate and instantiate the WASM module before function invocation.
When in the <code>Instantiated</code> status, developers can instantiate the WASM module again to reset the old WASM runtime structures.</p>
</li>
<li>
<p>Wasm-bindgen Supporting</p>
<p>The <code>(*VM).ExecuteBindgen</code> and the <code>(*VM).ExecuteBindgenRegistered</code> are the special functions for supporting the <code>wasm-bindgen</code> functions execution.
In WasmEdge-go, we support the following return types of the <code>wasm-bindgen</code> functions:</p>
<pre><code class="language-go">type bindgen int

const (
    Bindgen_return_void  bindgen = iota
    Bindgen_return_i32   bindgen = iota
    Bindgen_return_i64   bindgen = iota
    Bindgen_return_array bindgen = iota
)
</code></pre>
<p>And only the <code>int32</code>, <code>uint32</code>, <code>int64</code>, <code>uint64</code>, and <code>[]byte</code> parameters are accepted.
Each <code>wasm-bindgen</code> function has at most only 1 return value.</p>
<pre><code class="language-go">// Take the wasm-bindgen case for example.
var res interface{}
var err error
res, err = vm.ExecuteBindgen(
    &quot;lowest_common_multiple&quot;,       // Function name
    wasmedge.Bindgen_return_i32,    // Return type: int32
    int32(123), int32(2)            // Parameters: int32, int32
)
if err == nil {
    fmt.Println(&quot;Run bindgen -- lowest_common_multiple:&quot;, res.(int32))
} 
res, err = vm.ExecuteBindgen(
    &quot;sha3_digest&quot;,                          // Function name
    wasmedge.Bindgen_return_array,          // Return type: []byte
    []byte(&quot;This is an important message&quot;)  // Parameter: []byte
)
if err == nil {
    fmt.Println(&quot;Run bindgen -- sha3_digest:&quot;, res.([]byte))
} 
</code></pre>
<p>For the full example, please refer to <a href="#Example-of-Embedding-A-Function-with-wasm-bindgen">the example above</a>.</p>
</li>
</ol>
<h3 id="vm-creations"><a class="header" href="#vm-creations">VM Creations</a></h3>
<p>The <code>VM</code> creation APIs accepts the <code>Configure</code> object and the <code>Store</code> object.
Noticed that if the <code>VM</code> created with the outside <code>Store</code> object, the <code>VM</code> will execute WASM on that <code>Store</code> object. If the <code>Store</code> object is set into multiple <code>VM</code> objects, it may causes data conflict when in execution.
The details of the <code>Store</code> object will be introduced in <a href="#Store">Store</a>.</p>
<pre><code class="language-go">conf := wasmedge.NewConfigure()
store := wasmedge.NewStore()

// Create a VM with default configure and store.
vm := wasmedge.NewVM()
vm.Release()

// Create a VM with the specified configure and default store.
vm = wasmedge.NewVMWithConfig(conf)
vm.Release()

// Create a VM with the default configure and specified store.
vm = wasmedge.NewVMWithStore(store)
vm.Release()

// Create a VM with the specified configure and store.
vm = wasmedge.NewVMWithConfigAndStore(conf, store)
vm.Release()

conf.Release()
store.Release()
</code></pre>
<h3 id="preregistrations"><a class="header" href="#preregistrations">Preregistrations</a></h3>
<p>WasmEdge provides the following built-in pre-registrations.</p>
<ol>
<li>
<p><a href="https://github.com/WebAssembly/WASI">WASI (WebAssembly System Interface)</a></p>
<p>Developers can turn on the WASI support for VM in the <code>Configure</code> object.</p>
<pre><code class="language-go">conf := wasmedge.NewConfigure(wasmedge.WASI)
// Or you can set the `wasmedge.WASI` into the configure object through `(*Configure).AddConfig`.
vm := wasmedge.NewVMWithConfig(conf)
vm.Release()

// The following API can retrieve the pre-registration import objects from the VM object.
// This API will return `nil` if the corresponding pre-registration is not set into the configuration.
wasiconf := conf.GetImportObject(wasmedge.WASI)
// Initialize the WASI.
wasiconf.InitWasi(/* ... ignored */)

conf.Release()
</code></pre>
<p>And also can create the WASI import object from API. The details will be introduced in the <a href="#Host-Functions">Host Functions</a> and the <a href="#Host-Module-Registrations">Host Module Registrations</a>.</p>
</li>
<li>
<p><a href="https://crates.io/crates/wasmedge_process_interface">WasmEdge_Process</a></p>
<p>This pre-registration is for the process interface for WasmEdge on <code>Rust</code> sources.
After turning on this pre-registration, the VM will support the <code>wasmedge_process</code> host functions.</p>
<pre><code class="language-go">conf := wasmedge.NewConfigure(wasmedge.WasmEdge_PROCESS)
vm := wasmedge.NewVMWithConfig(conf)
vm.Release()

// The following API can retrieve the pre-registration import objects from the VM object.
// This API will return `nil` if the corresponding pre-registration is not set into the configuration.
procconf := conf.GetImportObject(wasmedge.WasmEdge_PROCESS)
// Initialize the WasmEdge_Process.
procconf.InitWasmEdgeProcess(/* ... ignored */)

conf.Release()
</code></pre>
<p>And also can create the WasmEdge_Process import object from API. The details will be introduced in the <a href="#Host-Functions">Host Functions</a> and the <a href="#Host-Module-Registrations">Host Module Registrations</a>.</p>
</li>
</ol>
<h3 id="host-module-registrations"><a class="header" href="#host-module-registrations">Host Module Registrations</a></h3>
<p><a href="https://webassembly.github.io/spec/core/exec/runtime.html#syntax-hostfunc">Host functions</a> are functions outside WebAssembly and passed to WASM modules as imports.
In WasmEdge-go, the host functions are composed into host modules as <code>ImportObject</code> objects with module names.
Please refer to the <a href="#Host-Functions">Host Functions in WasmEdge Runtime</a> for the details.
In this chapter, we show the example for registering the host modules into a <code>VM</code> object.</p>
<pre><code class="language-go">vm := wasmedge.NewVM()
// You can also create and register the WASI host modules by this API.
wasiobj := wasmedge.NewWasiImportObject(/* ... ignored ... */)

res := vm.RegisterImport(wasiobj)
// The result status should be checked.

vm.Release()
// The created import objects should be released.
wasiobj.Release()
</code></pre>
<h3 id="wasm-registrations-and-executions"><a class="header" href="#wasm-registrations-and-executions">WASM Registrations And Executions</a></h3>
<p>In WebAssembly, the instances in WASM modules can be exported and can be imported by other WASM modules.
WasmEdge VM provides APIs for developers to register and export any WASM modules, and execute the functions or host functions in the registered WASM modules.</p>
<ol>
<li>
<p>Register the WASM modules with exported module names</p>
<p>Unless the import objects have already contained the module names, every WASM module should be named uniquely when registering. The following shows the example.</p>
<p>Create a new Go project first:</p>
<pre><code class="language-bash">$ mkdir wasmedge_test &amp;&amp; cd wasmedge_test
$ go mod init wasmedge_test
</code></pre>
<p>Assume that the WASM file <a href="../tools/wasmedge/examples/fibonacci.wasm"><code>fibonacci.wasm</code></a> is copied into the current directory.
Then create and edit the Go file <code>main.go</code> as following:</p>
<pre><code class="language-go">package main

import &quot;github.com/second-state/WasmEdge-go/wasmedge&quot;

func main() {
    // Create VM.
    vm := wasmedge.NewVM()

    var err error
    err = vm.RegisterWasmFile(&quot;module_name&quot;, &quot;fibonacci.wasm&quot;)
    // Developers can register the WASM module from `[]byte` with the
    // `(*VM).RegisterWasmBuffer` function, or from `AST` object with
    // the `(*VM).RegisterAST` function.
    // The result status should be checked. The error will occur if the
    // WASM module instantiation failed or the module name conflicts.

    vm.Release()
}
</code></pre>
</li>
<li>
<p>Execute the functions in registered WASM modules</p>
<p>Edit the Go file <code>main.go</code> as following:</p>
<pre><code class="language-go">package main

import (
    &quot;fmt&quot;

    &quot;github.com/second-state/WasmEdge-go/wasmedge&quot;
)

func main() {
    // Create VM.
    vm := wasmedge.NewVM()

    var res []interface{}
    var err error
    // Register the WASM module from file into VM with the module name &quot;mod&quot;.
    err = vm.RegisterWasmFile(&quot;mod&quot;, &quot;fibonacci.wasm&quot;)
    // Developers can register the WASM module from `[]byte` with the
    // `(*VM).RegisterWasmBuffer` function, or from `AST` object with
    // the `(*VM).RegisterAST` function.
    if err != nil {
        fmt.Println(&quot;WASM registration failed:&quot;, err.Error())
        return
    }
    // The function &quot;fib&quot; in the &quot;fibonacci.wasm&quot; was exported with the module
    // name &quot;mod&quot;. As the same as host functions, other modules can import the
    // function `&quot;mod&quot; &quot;fib&quot;`.

    // Execute WASM functions in registered modules.
    // Unlike the execution of functions, the registered functions can be
    // invoked without `(*VM).Instantiate` because the WASM module was
    // instantiated when registering.
    // Developers can also invoke the host functions directly with this API.
    res, err = vm.ExecuteRegistered(&quot;mod&quot;, &quot;fib&quot;, int32(25))
    if err == nil {
        fmt.Println(&quot;Get fibonacci[25]:&quot;, res[0].(int32))
    } else {
        fmt.Println(&quot;Run failed:&quot;, err.Error())
    }

    vm.Release()
}
</code></pre>
<p>Then you can build and run: (the 25th Fibonacci number is 121393 in 0-based index)</p>
<pre><code class="language-bash">$ go get github.com/second-state/WasmEdge-go/wasmedge@v0.9.0
$ go build
$ ./wasmedge_test
Get fibonacci[25]: 121393
</code></pre>
</li>
</ol>
<h3 id="instance-tracing"><a class="header" href="#instance-tracing">Instance Tracing</a></h3>
<p>Sometimes the developers may have requirements to get the instances of the WASM runtime.
The <code>VM</code> object supplies the APIs to retrieve the instances.</p>
<ol>
<li>
<p>Store</p>
<p>If the <code>VM</code> object is created without assigning a <code>Store</code> object, the <code>VM</code> context will allocate and own a <code>Store</code>.</p>
<pre><code class="language-go">vm := wasmedge.NewVM()
store := vm.GetStore()
// The object should __NOT__ be deleted by calling `(*Store).Release`.
vm.Release()
</code></pre>
<p>Developers can also create the <code>VM</code> object with a <code>Store</code> object.
In this case, developers should guarantee that the <code>Store</code> object cannot be released before the <code>VM</code> object.
Please refer to the <a href="#Store">Store Objects</a> for the details about the <code>Store</code> APIs.</p>
<pre><code class="language-go">store := wasmedge.NewStore()
vm := wasmedge.NewVMWithStore(store)

storemock := vm.GetStore()
// The internal store context of the `store` and the `storemock` are the same.

vm.Release()
store.Release()
</code></pre>
</li>
<li>
<p>List exported functions</p>
<p>After the WASM module instantiation, developers can use the <code>(*VM).Execute</code> function to invoke the exported WASM functions. For this purpose, developers may need information about the exported WASM function list.
Please refer to the <a href="#Instances">Instances in runtime</a> for the details about the function types.</p>
<p>Assume that a new Go project is created as following:</p>
<pre><code class="language-bash">$ mkdir wasmedge_test &amp;&amp; cd wasmedge_test
$ go mod init wasmedge_test
</code></pre>
<p>Then assume that the WASM file <a href="../tools/wasmedge/examples/fibonacci.wasm"><code>fibonacci.wasm</code></a> is copied into the current directory, and create and edit a Go file <code>main.go</code>:</p>
<pre><code class="language-go">package main

import (
    &quot;fmt&quot;

    &quot;github.com/second-state/WasmEdge-go/wasmedge&quot;
)

func main() {
    // Create VM.
    vm := wasmedge.NewVM()

    // Step 1: Load WASM file.
    err := vm.LoadWasmFile(&quot;fibonacci.wasm&quot;)
    if err != nil {
        fmt.Println(&quot;Load WASM from file FAILED:&quot;, err.Error())
        return
    }

    // Step 2: Validate the WASM module.
    err = vm.Validate()
    if err != nil {
        fmt.Println(&quot;Validation FAILED:&quot;, err.Error())
        return
    }

    // Step 3: Instantiate the WASM module.
    err = vm.Instantiate()
    if err != nil {
        fmt.Println(&quot;Instantiation FAILED:&quot;, err.Error())
        return
    }

    // List the exported functions for the names and function types.
    funcnames, functypes := vm.GetFunctionList()
    for _, fname := range funcnames {
        fmt.Println(&quot;Exported function name:&quot;, fname)
    }
    for _, ftype := range functypes {
        // `ftype` is the `FunctionType` object of the same index in the `funcnames` array.
        // Developers should __NOT__ call the `ftype.Release()`.
    }

    vm.Release()
}
</code></pre>
<p>Then you can build and run: (the only exported function in <code>fibonacci.wasm</code> is <code>fib</code>)</p>
<pre><code class="language-bash">$ go get github.com/second-state/WasmEdge-go/wasmedge@v0.9.0
$ go build
$ ./wasmedge_test
Exported function name: fib
</code></pre>
<p>If developers want to get the exported function names in the registered WASM modules, please retrieve the <code>Store</code> object from the <code>VM</code> object and refer to the APIs of <a href="#Store">Store Contexts</a> to list the registered functions by the module name.</p>
</li>
<li>
<p>Get function types</p>
<p>The <code>VM</code> object provides APIs to find the function type by function name.
Please refer to the <a href="#Instances">Instances in runtime</a> for the details about the function types.</p>
<pre><code class="language-go">// Assume that a WASM module is instantiated in `vm` which is a `wasmedge.VM` object.
functype := vm.GetFunctionType(&quot;fib&quot;)
// Developers can get the function types of functions in the registered modules via the 
// `(*VM).GetFunctionTypeRegistered` API with the functon name and the module name.
// If the function is not found, these APIs will return `nil`.
// Developers should __NOT__ call the `(*FunctionType).Release` function of the returned object.
</code></pre>
</li>
</ol>
<h2 id="wasmedge-runtime"><a class="header" href="#wasmedge-runtime">WasmEdge Runtime</a></h2>
<p>In this partition, we will introduce the objects of WasmEdge runtime manually.</p>
<h3 id="wasm-execution-example-step-by-step"><a class="header" href="#wasm-execution-example-step-by-step">WASM Execution Example Step-By-Step</a></h3>
<p>Besides the WASM execution through the <a href="#WasmEdge-VM"><code>VM</code> object</a> rapidly, developers can execute the WASM functions or instantiate WASM modules step-by-step with the <code>Loader</code>, <code>Validator</code>, <code>Executor</code>, and <code>Store</code> objects.</p>
<p>Assume that a new Go project is created as following:</p>
<pre><code class="language-bash">$ mkdir wasmedge_test &amp;&amp; cd wasmedge_test
$ go mod init wasmedge_test
</code></pre>
<p>Then assume that the WASM file <a href="../tools/wasmedge/examples/fibonacci.wasm"><code>fibonacci.wasm</code></a> is copied into the current directory, and create and edit a Go file <code>main.go</code>:</p>
<pre><code class="language-go">package main

import (
    &quot;fmt&quot;

    &quot;github.com/second-state/WasmEdge-go/wasmedge&quot;
)

func main() {
    // Set the logging level to debug to print the statistics info.
    wasmedge.SetLogDebugLevel()
    // Create the configure object. This is not necessary if developers use the default configuration.
    conf := wasmedge.NewConfigure()
    // Turn on the runtime instruction counting and time measuring.
    conf.SetStatisticsInstructionCounting(true)
    conf.SetStatisticsTimeMeasuring(true)
    // Create the statistics object. This is not necessary if the statistics in runtime is not needed.
    stat := wasmedge.NewStatistics()
    // Create the store object. The store object is the WASM runtime structure core.
    store := wasmedge.NewStore()

    var err error
    var res []interface{}
    var ast *wasmedge.AST

    // Create the loader object.
    // For loader creation with default configuration, you can use `wasmedge.NewLoader()` instead.
    loader := wasmedge.NewLoaderWithConfig(conf)
    // Create the validator object.
    // For validator creation with default configuration, you can use `wasmedge.NewValidator()` instead.
    validator := wasmedge.NewValidatorWithConfig(conf)
    // Create the executor object.
    // For executor creation with default configuration and without statistics, you can use `wasmedge.NewExecutor()` instead.
    executor := wasmedge.NewExecutorWithConfigAndStatistics(conf, stat)

    // Load the WASM file or the compiled-WASM file and convert into the AST module object.
    ast, err = loader.LoadFile(&quot;fibonacci.wasm&quot;)
    if err != nil {
        fmt.Println(&quot;Load WASM from file FAILED:&quot;, err.Error())
        return
    }
    // Validate the WASM module.
    err = validator.Validate(ast)
    if err != nil {
        fmt.Println(&quot;Validation FAILED:&quot;, err.Error())
        return
    }
    // Instantiate the WASM module into the Store object.
    err = executor.Instantiate(store, ast)
    if err != nil {
        fmt.Println(&quot;Instantiation FAILED:&quot;, err.Error())
        return
    }

    // Try to list the exported functions of the instantiated WASM module.
    funcnames := store.ListFunction()
    for _, fname := range funcnames {
        fmt.Println(&quot;Exported function name:&quot;, fname)
    }

    // Invoke the WASM function.
    res, err = executor.Invoke(store, &quot;fib&quot;, int32(30))
    if err == nil {
        fmt.Println(&quot;Get fibonacci[30]:&quot;, res[0].(int32))
    } else {
        fmt.Println(&quot;Run failed:&quot;, err.Error())
    }

    // Resources deallocations.
    conf.Release()
    stat.Release()
    ast.Release()
    loader.Release()
    validator.Release()
    executor.Release()
    store.Release()
}
</code></pre>
<p>Then you can build and run: (the 18th Fibonacci number is 1346269 in 30-based index)</p>
<pre><code class="language-bash">$ go get github.com/second-state/WasmEdge-go/wasmedge@v0.9.0
$ go build
$ ./wasmedge_test
Exported function name: fib
[2021-11-24 18:53:01.451] [debug]  Execution succeeded.
[2021-11-24 18:53:01.452] [debug]
 ====================  Statistics  ====================
 Total execution time: 556372295 ns
 Wasm instructions execution time: 556372295 ns
 Host functions execution time: 0 ns
 Executed wasm instructions count: 28271634
 Gas costs: 0
 Instructions per second: 50814237
Get fibonacci[30]: 1346269
</code></pre>
<h3 id="loader"><a class="header" href="#loader">Loader</a></h3>
<p>The <code>Loader</code> object loads the WASM binary from files or buffers.
Both the WASM and the compiled-WASM from the <a href="#WasmEdge-AOT-Compiler">WasmEdge AOT Compiler</a> are supported.</p>
<pre><code class="language-go">var buf []byte
// ... Read the WASM code to the `buf`.

// Developers can adjust settings in the configure object.
conf := wasmedge.NewConfigure()
// Create the loader object.
// For loader creation with default configuration, you can use `wasmedge.NewLoader()` instead.
loader := wasmedge.NewLoaderWithConfig(conf)
conf.Release()

// Load WASM or compiled-WASM from the file.
ast, err := loader.LoadFile(&quot;fibonacci.wasm&quot;)
if err != nil {
    fmt.Println(&quot;Load WASM from file FAILED:&quot;, err.Error())
} else {
    // The output AST object should be released.
    ast.Release()
}

// Load WASM or compiled-WASM from the buffer
ast, err = loader.LoadBuffer(buf)
if err != nil {
    fmt.Println(&quot;Load WASM from buffer FAILED:&quot;, err.Error())
} else {
    // The output AST object should be released.
    ast.Release()   
}

loader.Release()
</code></pre>
<h3 id="validator"><a class="header" href="#validator">Validator</a></h3>
<p>The <code>Validator</code> object can validate the WASM module.
Every WASM module should be validated before instantiation.</p>
<pre><code class="language-go">// ...
// Assume that the `ast` is the output `*wasmedge.AST` object from the loader context.
// Assume that the `conf` is the `*wasmedge.Configure` object.

// Create the validator context.
// For validator creation with default configuration, you can use `wasmedge.NewValidator()` instead.
validator := wasmedge.NewValidatorWithConfig(conf)

err := validator.Validate(ast)
if err != nil {
    fmt.Println(&quot;Validation FAILED:&quot;, err.Error())
}

validator.Release()
</code></pre>
<h3 id="executor"><a class="header" href="#executor">Executor</a></h3>
<p>The <code>Executor</code> object is the executor for both WASM and compiled-WASM.
This object should work base on the <code>Store</code> object. For the details of the <code>Store</code> object, please refer to the <a href="#Store">next chapter</a>.</p>
<ol>
<li>
<p>Register modules</p>
<p>As the same of <a href="#Host-Module-Registrations">registering host modules</a> or <a href="#WASM-Registrations-And-Executions">importing WASM modules</a> in <code>VM</code> objects, developers can register <code>ImportObject</code> or <code>AST</code> objects into the <code>Store</code> object by the <code>Executor</code> APIs.
For the details of import objects, please refer to the <a href="#Host-Functions">Host Functions</a>.</p>
<pre><code class="language-go">// ...
// Assume that the `ast` is the output `*wasmedge.AST` object from the loader
// and has passed the validation.
// Assume that the `conf` is the `*wasmedge.Configure` object.

// Create the statistics object. This step is not necessary if the statistics
// is not needed.
stat := wasmedge.NewStatistics()
// Create the executor object.
// For executor creation with default configuration and without statistics,
// you can use `wasmedge.NewExecutor()` instead.
executor := wasmedge.NewExecutorWithConfigAndStatistics(conf, stat)
// Create the store object. The store is the WASM runtime structure core.
store := wasmedge.NewStore()

// Register the loaded WASM `ast` into store with the export module name &quot;mod&quot;.
res := executor.RegisterModule(store, ast, &quot;mod&quot;)
if err != nil {
    fmt.Println(&quot;WASM registration FAILED:&quot;, err.Error())
    return
}

// Assume that the `impobj` is the `*wasmedge.ImportObject` for host functions.
impobj := ...
err = executor.RegisterImport(store, impobj)
if err != nil {
    fmt.Println(&quot;Import object registration FAILED:&quot;, err.Error())
    return
}

executor.Release()
stat.Release()
store.Release()
impobj.Release()
</code></pre>
</li>
<li>
<p>Instantiate modules</p>
<p>WASM or compiled-WASM modules should be instantiated before the function invocation.
Note that developers can only instantiate one module into the <code>Store</code> object, and in that case, the old instantiated module will be cleaned.
Before instantiating a WASM module, please check the <a href="https://webassembly.github.io/spec/core/syntax/modules.html#syntax-import">import section</a> for ensuring the imports are registered into the <code>Store</code> object.</p>
<pre><code class="language-go">// ...
// Assume that the `ast` is the output `*wasmedge.AST` object from the loader
// and has passed the validation.
// Assume that the `conf` is the `*wasmedge.Configure` object.

// Create the statistics object. This step is not necessary if the statistics
// is not needed.
stat := wasmedge.NewStatistics()
// Create the executor object.
// For executor creation with default configuration and without statistics,
// you can use `wasmedge.NewExecutor()` instead.
executor := wasmedge.NewExecutorWithConfigAndStatistics(conf, stat)
// Create the store object. The store is the WASM runtime structure core.
store := wasmedge.NewStore()

// Instantiate the WASM module.
err := executor.Instantiate(stpre, ast)
if err != nil {
    fmt.Println(&quot;WASM instantiation FAILED:&quot;, err.Error())
    return
}

executor.Release()
stat.Release()
store.Release()
</code></pre>
</li>
<li>
<p>Invoke functions</p>
<p>As the same as function invocation via the <code>VM</code> object, developers can invoke the functions of the instantiated or registered modules.
The APIs, <code>(*Executor).Invoke</code> and <code>(*Executor).InvokeRegistered</code>, are similar as the APIs of the <code>VM</code> object.
Please refer to the <a href="#WASM-Execution-Example-With-VM-Object">VM context workflows</a> for details.</p>
</li>
</ol>
<h3 id="ast-module"><a class="header" href="#ast-module">AST Module</a></h3>
<p>The <code>AST</code> object presents the loaded structure from a WASM file or buffer. Developer will get this object after loading a WASM file or buffer from <a href="#Loader">Loader</a>.
Before instantiation, developers can also query the imports and exports of an <code>AST</code> object.</p>
<pre><code class="language-go">ast := ...
// Assume that a WASM is loaded into an `*wasmedge.AST` object from loader.

// List the imports.
imports := ast.ListImports()
for _, import := range imports {
    fmt.Println(&quot;Import:&quot;, import.GetModuleName(), import.GetExternalName())
}

// List the exports.
exports := ast.ListExports()
for _, export := range exports {
    fmt.Println(&quot;Export:&quot;, export.GetExternalName())
}

ast.Release()
</code></pre>
<h3 id="store"><a class="header" href="#store">Store</a></h3>
<p><a href="https://webassembly.github.io/spec/core/exec/runtime.html#store">Store</a> is the runtime structure for the representation of all instances of <code>Function</code>s, <code>Table</code>s, <code>Memory</code>s, and <code>Global</code>s that have been allocated during the lifetime of the abstract machine.
The <code>Store</code> object in WasmEdge-go provides APIs to list the exported instances with their names or find the instances by exported names. For adding instances into <code>Store</code> objects, please instantiate or register WASM modules or <code>ImportObject</code> objects via the <code>Executor</code> APIs.</p>
<ol>
<li>
<p>List instances</p>
<pre><code class="language-go">store := wasmedge.NewStore()
// ...
// Instantiate a WASM module via the `*wasmedge.Executor` object.
// ...

// Try to list the exported functions of the instantiated WASM module.
// Take the function instances for example here.
funcnames := store.ListFunction()
for _, name := range funcnames {
    fmt.Println(&quot;Exported function name:&quot;, name)
}

store.Release()
</code></pre>
<p>Developers can list the function instance exported names of the registered modules via the <code>(*Store).ListFunctionRegistered()</code> API with the module name.</p>
</li>
<li>
<p>Find instances</p>
<pre><code class="language-go">store := wasmedge.NewStore()
// ...
// Instantiate a WASM module via the `*wasmedge.Executor` object.
// ...

// Try to find the exported functions of the instantiated WASM module.
// Take the function instances for example here.
funcobj := store.FindFunction(&quot;fib&quot;)
// `funcobj` will be `nil` if the function not found.

store.Release()
</code></pre>
<p>Developers can retrieve the exported function instances of the registered modules via the <code>(*Store).FindFunctionRegistered</code> API with the module name.</p>
</li>
<li>
<p>List registered modules</p>
<p>With the module names, developers can list the exported instances of the registered modules with their names.</p>
<pre><code class="language-go">store := wasmedge.NewStore()
// ...
// Instantiate a WASM module via the `*wasmedge.Executor` object.
// ...

// Try to list the registered WASM modules.
modnames := store.ListModule()
for _, name := range modnames {
    fmt.Println(&quot;Registered module names:&quot;, name)
}

store.Release()
</code></pre>
</li>
</ol>
<h3 id="instances"><a class="header" href="#instances">Instances</a></h3>
<p>The instances are the runtime structures of WASM. Developers can retrieve the instances from the <code>Store</code> objects.
The <code>Store</code> objects will allocate instances when a WASM module or an <code>ImportObject</code> is registered or instantiated through the <code>Executor</code>.
A single instance can be allocated by its creation function. Developers can construct instances into an <code>ImportObject</code> for registration. Please refer to the <a href="#Host-Functions">Host Functions</a> for details.
The instances created by their creation functions should be destroyed, EXCEPT they are added into an <code>ImportObject</code> object.</p>
<ol>
<li>
<p>Function instance</p>
<p><a href="https://webassembly.github.io/spec/core/exec/runtime.html#syntax-hostfunc">Host functions</a> are functions outside WebAssembly and passed to WASM modules as imports.
In WasmEdge, developers can create the <code>Function</code> objects for host functions and add them into an <code>ImportObject</code> object for registering into a <code>VM</code> or a <code>Store</code>.
For both host functions and the functions get from <code>Store</code>, developers can retrieve the <code>FunctionType</code> from the <code>Function</code> objects.
For the details of the <code>Host Function</code> guide, please refer to the <a href="#Host-Functions">next chapter</a>.</p>
<pre><code class="language-go">funcinst := ...
// `funcobj` is the `*wasmedge.Function` retrieved from the store object.
functype := funcobj.GetFunctionType()
// The `funcobj` retrieved from the store object should __NOT__ be released.
// The `functype` retrieved from the `funcobj` should __NOT__ be released.
</code></pre>
</li>
<li>
<p>Table instance</p>
<p>In WasmEdge, developers can create the <code>Table</code> objects and add them into an <code>ImportObject</code> object for registering into a <code>VM</code> or a <code>Store</code>.
The <code>Table</code> objects supply APIs to control the data in table instances.</p>
<pre><code class="language-go">lim := wasmedge.NewLimitWithMax(10, 20)
// Create the table type with limit and the `FuncRef` element type.
tabtype := wasmedge.NewTableType(wasmedge.RefType_FuncRef, lim)
// Create the table instance with table type.
tabinst := wasmedge.NewTable(tabtype)
// Delete the table type.
tabtype.Release()

gottabtype := tabinst.GetTableType()
// The `gottabtype` got from table instance is owned by the `tabinst`
// and should __NOT__ be released.
reftype := gottabtype.GetRefType()
// The `reftype` will be `wasmedge.RefType_FuncRef`.

var gotdata interface{}
data := wasmedge.NewFuncRef(5)
err := tabinst.SetData(data, 3)
// Set the function index 5 to the table[3].

// The following line will get an &quot;out of bounds table access&quot; error
// because the position (13) is out of the table size (10):
//   err = tabinst.SetData(data, 13)

gotdata, err = tabinst.GetData(3)
// Get the FuncRef value of the table[3].

// The following line will get an &quot;out of bounds table access&quot; error
// because the position (13) is out of the table size (10):
//   gotdata, err = tabinst.GetData(13)

tabsize := tabinst.GetSize()
// `tabsize` will be 10.
err = tabinst.Grow(6)
// Grow the table size of 6, the table size will be 16.

// The following line will get an &quot;out of bounds table access&quot; error
// because the size (16 + 6) will reach the table limit (20):
//   err = tabinst.Grow(6)

tabinst.Release()
</code></pre>
</li>
<li>
<p>Memory instance</p>
<p>In WasmEdge, developers can create the <code>Memory</code> objects and add them into an <code>ImportObject</code> object for registering into a <code>VM</code> or a <code>Store</code>.
The <code>Memory</code> objects supply APIs to control the data in memory instances.</p>
<pre><code class="language-go">lim := wasmedge.NewLimitWithMax(1, 5)
// Create the memory type with limit. The memory page size is 64KiB.
memtype := wasmedge.NewMemoryType(lim)
// Create the memory instance with memory type.
meminst := wasmedge.NewMemory(memtype)
// Delete the memory type.
memtype.Release()

data := []byte(&quot;A quick brown fox jumps over the lazy dog&quot;)
err := meminst.SetData(data, 0x1000, 10)
// Set the data[0:9] to the memory[4096:4105].

// The following line will get an &quot;out of bounds memory access&quot; error
// because [65535:65544] is out of 1 page size (65536):
//   err = meminst.SetData(data, 0xFFFF, 10)

var gotdata []byte
gotdata, err = meminst.GetData(0x1000, 10)
// Get the memory[4096:4105]. The `gotdata` will be `[]byte(&quot;A quick br&quot;).
// The following line will get an &quot;out of bounds memory access&quot; error
// because [65535:65544] is out of 1 page size (65536):
//   gotdata, err = meminst.Getdata(0xFFFF, 10)

pagesize := meminst.GetPageSize()
// `pagesize` will be 1.
err = meminst.GrowPage(2)
// Grow the page size of 2, the page size of the memory instance will be 3.

// The following line will get an &quot;out of bounds memory access&quot; error
// because the size (3 + 3) will reach the memory limit (5):
//   err = meminst.GetPageSize(3)

meminst.Release()
</code></pre>
</li>
<li>
<p>Global instance</p>
<p>In WasmEdge, developers can create the <code>Global</code> objects and add them into an <code>ImportObject</code> object for registering into a <code>VM</code> or a <code>Store</code>.
The <code>Global</code> objects supply APIs to control the value in global instances.</p>
<pre><code class="language-go">// Create the global type with value type and mutation.
globtype := wasmedge.NewGlobalType(wasmedge.ValType_I64, wasmedge.ValMut_Var)
// Create the global instance with value and global type.
globinst := wasmedge.NewGlobal(globtype, uint64(1000))
// Delete the global type.
globtype.Release()

gotglobtype := globinst.GetGlobalType()
// The `gotglobtype` got from global instance is owned by the `globinst`
// and should __NOT__ be released.
valtype := gotglobtype.GetValType()
// The `valtype` will be `wasmedge.ValType_I64`.
valmut := gotglobtype.GetMutability()
// The `valmut` will be `wasmedge.ValMut_Var`.

globinst.SetValue(uint64(888))
// Set the value u64(888) to the global.
// This function will do nothing if the value type mismatched or the
// global mutability is `wasmedge.ValMut_Const`.
gotval := globinst.GetValue()
// The `gotbal` will be `interface{}` which the type is `uint64` and
// the value is 888.

globinst.Release()
</code></pre>
</li>
</ol>
<h3 id="host-functions"><a class="header" href="#host-functions">Host Functions</a></h3>
<p><a href="https://webassembly.github.io/spec/core/exec/runtime.html#syntax-hostfunc">Host functions</a> are functions outside WebAssembly and passed to WASM modules as imports.
In WasmEdge-go, developers can create the <code>Function</code>, <code>Memory</code>, <code>Table</code>, and <code>Global</code> objects and add them into an <code>ImportObject</code> object for registering into a <code>VM</code> or a <code>Store</code>.</p>
<ol>
<li>
<p>Host function allocation</p>
<p>Developers can define Go functions with the following function signature as the host function body:</p>
<pre><code class="language-go">type hostFunctionSignature func(
    data interface{}, mem *Memory, params []interface{}) ([]interface{}, Result)
</code></pre>
<p>The example of an <code>add</code> host function to add 2 <code>i32</code> values:</p>
<pre><code class="language-c">func host_add(data interface{}, mem *wasmedge.Memory, params []interface{}) ([]interface{}, wasmedge.Result) {
    // add: i32, i32 -&gt; i32
    res := params[0].(int32) + params[1].(int32)

    /// Set the returns
    returns := make([]interface{}, 1)
    returns[0] = res

    /// Return
    return returns, wasmedge.Result_Success
}
</code></pre>
<p>Then developers can create <code>Function</code> object with the host function body and function type:</p>
<pre><code class="language-go">// Create a function type: {i32, i32} -&gt; {i32}.
functype := wasmedge.NewFunctionType(
    []wasmedge.ValType{wasmedge.ValType_I32, wasmedge.ValType_I32},
    []wasmedge.ValType{wasmedge.ValType_I32},
)

// Create a function context with the function type and host function body.
// The third parameter is the pointer to the additional data.
// Developers should guarantee the life cycle of the data, and it can be
// `nil` if the external data is not needed.
// The last parameter can be 0 if developers do not need the cost measuring.
func_add := wasmedge.NewFunction(functype, host_add, nil, 0)

// If the function object is not added into an import object object, it should be released.
func_add.Release()
functype.Release()
</code></pre>
</li>
<li>
<p>Import object object</p>
<p>The <code>ImportObject</code> object holds an exporting module name and the instances. Developers can add the <code>Function</code>, <code>Memory</code>, <code>Table</code>, and <code>Global</code> instances with their exporting names.</p>
<pre><code class="language-go">// Host function body definition.
func host_add(data interface{}, mem *wasmedge.Memory, params []interface{}) ([]interface{}, wasmedge.Result) {
    // add: i32, i32 -&gt; i32
    res := params[0].(int32) + params[1].(int32)

    /// Set the returns
    returns := make([]interface{}, 1)
    returns[0] = res

    /// Return
    return returns, wasmedge.Result_Success
}

// Create the import object with the module name &quot;module&quot;.
impobj := wasmedge.NewImportObject(&quot;module&quot;)

// Create and add a function instance into the import object with export name &quot;add&quot;.
functype := wasmedge.NewFunctionType(
    []wasmedge.ValType{wasmedge.ValType_I32, wasmedge.ValType_I32},
    []wasmedge.ValType{wasmedge.ValType_I32},
)
hostfunc := wasmedge.NewFunction(functype, host_add, nil, 0)
functype.Release()
impobj.AddFunction(&quot;add&quot;, hostfunc)

// Create and add a table instance into the import object with export name &quot;table&quot;.
tabtype := wasmedge.NewTableType(wasmedge.RefType_FuncRef ,wasmedge.NewLimitWithMax(10, 20))
hosttab := wasmedge.NewTable(tabtype)
tabtype.Release()
impobj.AddTable(&quot;table&quot;, hosttab)

// Create and add a memory instance into the import object with export name &quot;memory&quot;.
memtype := wasmedge.NewMemoryType(wasmedge.NewLimitWithMax(1, 2))
hostmem := wasmedge.NewMemory(memtype)
memtype.Release()
impobj.AddMemory(&quot;memory&quot;, hostmem)

// Create and add a global instance into the import object with export name &quot;global&quot;.
globtype := wasmedge.NewGlobalType(wasmedge.ValType_I32, wasmedge.ValMut_Var)
hostglob := wasmedge.NewGlobal(globtype, uint32(666))
globtype.Release()
impobj.AddGlobal(&quot;global&quot;, hostglob)

// The import objects should be released.
// Developers should __NOT__ release the instances added into the import object objects.
impobj.Release()
</code></pre>
</li>
<li>
<p>Specified import object</p>
<p><code>wasmedge.NewWasiImportObject()</code> API can create and initialize the <code>WASI</code> import object.
<code>wasmedge.NewWasmEdgeProcessImportObject()</code> API can create and initialize the <code>wasmedge_process</code> import object.
Developers can create these import object objects and register them into the <code>Store</code> or <code>VM</code> objects rather than adjust the settings in the <code>Configure</code> objects.</p>
<pre><code class="language-go">wasiobj := wasmedge.NewWasiImportObject(
    os.Args[1:],     // The args
    os.Environ(),    // The envs
    []string{&quot;.:.&quot;}, // The mapping preopens
)
procobj := wasmedge.NewWasmEdgeProcessImportObject(
    []string{&quot;ls&quot;, &quot;echo&quot;}, // The allowed commands
    false,                  // Not to allow all commands
)

// Register the WASI and WasmEdge_Process into the VM object.
vm := wasmedge.NewVM()
vm.RegisterImport(wasiobj)
vm.RegisterImport(procobj)

// ... Execute some WASM functions.

// Get the WASI exit code.
exitcode := wasiobj.WasiGetExitCode()
// The `exitcode` will be 0 if the WASI function &quot;_start&quot; execution has no error.
// Otherwise, it will return with the related exit code.

vm.Release()
// The import objects should be deleted.
wasiobj.Release()
procobj.Release()
</code></pre>
</li>
<li>
<p>Example</p>
<p>Create a new Go project first:</p>
<pre><code class="language-bash">$ mkdir wasmedge_test &amp;&amp; cd wasmedge_test
$ go mod init wasmedge_test
</code></pre>
<p>Assume that there is a simple WASM from the WAT as following:</p>
<pre><code>(module
  (type $t0 (func (param i32 i32) (result i32)))
  (import &quot;extern&quot; &quot;func-add&quot; (func $f-add (type $t0)))
  (func (export &quot;addTwo&quot;) (param i32 i32) (result i32)
    local.get 0
    local.get 1
    call $f-add)
)
</code></pre>
<p>Create and edit the Go file <code>main.go</code> as following:</p>
<pre><code class="language-go">package main

import (
    &quot;fmt&quot;

    &quot;github.com/second-state/WasmEdge-go/wasmedge&quot;
)

// Host function body definition.
func host_add(data interface{}, mem *wasmedge.Memory, params []interface{}) ([]interface{}, wasmedge.Result) {
    // add: i32, i32 -&gt; i32
    res := params[0].(int32) + params[1].(int32)

    /// Set the returns
    returns := make([]interface{}, 1)
    returns[0] = res

    /// Return
    return returns, wasmedge.Result_Success
}

func main() {
    // Create the VM object.
    vm := wasmedge.NewVM()

    // The WASM module buffer.
    wasmbuf := []byte{
        /* WASM header */
        0x00, 0x61, 0x73, 0x6D, 0x01, 0x00, 0x00, 0x00,
        /* Type section */
        0x01, 0x07, 0x01,
        /* function type {i32, i32} -&gt; {i32} */
        0x60, 0x02, 0x7F, 0x7F, 0x01, 0x7F,
        /* Import section */
        0x02, 0x13, 0x01,
        /* module name: &quot;extern&quot; */
        0x06, 0x65, 0x78, 0x74, 0x65, 0x72, 0x6E,
        /* extern name: &quot;func-add&quot; */
        0x08, 0x66, 0x75, 0x6E, 0x63, 0x2D, 0x61, 0x64, 0x64,
        /* import desc: func 0 */
        0x00, 0x00,
        /* Function section */
        0x03, 0x02, 0x01, 0x00,
        /* Export section */
        0x07, 0x0A, 0x01,
        /* export name: &quot;addTwo&quot; */
        0x06, 0x61, 0x64, 0x64, 0x54, 0x77, 0x6F,
        /* export desc: func 0 */
        0x00, 0x01,
        /* Code section */
        0x0A, 0x0A, 0x01,
        /* code body */
        0x08, 0x00, 0x20, 0x00, 0x20, 0x01, 0x10, 0x00, 0x0B,
    }

    // Create the import object with the module name &quot;extern&quot;.
    impobj := wasmedge.NewImportObject(&quot;extern&quot;)

    // Create and add a function instance into the import object with export name &quot;func-add&quot;.
    functype := wasmedge.NewFunctionType(
        []wasmedge.ValType{wasmedge.ValType_I32, wasmedge.ValType_I32},
        []wasmedge.ValType{wasmedge.ValType_I32},
    )
    hostfunc := wasmedge.NewFunction(functype, host_add, nil, 0)
    functype.Release()
    impobj.AddFunction(&quot;func-add&quot;, hostfunc)

    // Register the import object into VM.
    vm.RegisterImport(impobj)

    res, err := vm.RunWasmBuffer(wasmbuf, &quot;addTwo&quot;, uint32(1234), uint32(5678))
    if err == nil {
        fmt.Println(&quot;Get the result:&quot;, res[0].(int32))
    } else {
        fmt.Println(&quot;Error message:&quot;, err.Error())
    }

    impobj.Release()
    vm.Release()
}
</code></pre>
<p>Then you can build and run the Golang application with the WasmEdge Golang SDK:</p>
<pre><code class="language-bash">$ go get github.com/second-state/WasmEdge-go/wasmedge@v0.9.0
$ go build
$ ./wasmedge_test
Get the result: 6912
</code></pre>
</li>
<li>
<p>Host Data Example</p>
<p>Developers can set a external data object to the function object, and access to the object in the function body.
Assume that edit the Go file <code>main.go</code> above:</p>
<pre><code class="language-go">package main

import (
    &quot;fmt&quot;

    &quot;github.com/second-state/WasmEdge-go/wasmedge&quot;
)

// Host function body definition.
func host_add(data interface{}, mem *wasmedge.Memory, params []interface{}) ([]interface{}, wasmedge.Result) {
    // add: i32, i32 -&gt; i32
    res := params[0].(int32) + params[1].(int32)

    /// Set the returns
    returns := make([]interface{}, 1)
    returns[0] = res

    // Also set the result to the data.
    *data.(*int32) = res

    /// Return
    return returns, wasmedge.Result_Success
}

func main() {
    // Create the VM object.
    vm := wasmedge.NewVM()

    // The WASM module buffer.
    wasmbuf := []byte{
        /* WASM header */
        0x00, 0x61, 0x73, 0x6D, 0x01, 0x00, 0x00, 0x00,
        /* Type section */
        0x01, 0x07, 0x01,
        /* function type {i32, i32} -&gt; {i32} */
        0x60, 0x02, 0x7F, 0x7F, 0x01, 0x7F,
        /* Import section */
        0x02, 0x13, 0x01,
        /* module name: &quot;extern&quot; */
        0x06, 0x65, 0x78, 0x74, 0x65, 0x72, 0x6E,
        /* extern name: &quot;func-add&quot; */
        0x08, 0x66, 0x75, 0x6E, 0x63, 0x2D, 0x61, 0x64, 0x64,
        /* import desc: func 0 */
        0x00, 0x00,
        /* Function section */
        0x03, 0x02, 0x01, 0x00,
        /* Export section */
        0x07, 0x0A, 0x01,
        /* export name: &quot;addTwo&quot; */
        0x06, 0x61, 0x64, 0x64, 0x54, 0x77, 0x6F,
        /* export desc: func 0 */
        0x00, 0x01,
        /* Code section */
        0x0A, 0x0A, 0x01,
        /* code body */
        0x08, 0x00, 0x20, 0x00, 0x20, 0x01, 0x10, 0x00, 0x0B,
    }

    // The additional data to set into the host function.
    var data int32 = 0

    // Create the import object with the module name &quot;extern&quot;.
    impobj := wasmedge.NewImportObject(&quot;extern&quot;)

    // Create and add a function instance into the import object with export name &quot;func-add&quot;.
    functype := wasmedge.NewFunctionType(
        []wasmedge.ValType{wasmedge.ValType_I32, wasmedge.ValType_I32},
        []wasmedge.ValType{wasmedge.ValType_I32},
    )
    hostfunc := wasmedge.NewFunction(functype, host_add, &amp;data, 0)
    functype.Release()
    impobj.AddFunction(&quot;func-add&quot;, hostfunc)

    // Register the import object into VM.
    vm.RegisterImport(impobj)

    res, err := vm.RunWasmBuffer(wasmbuf, &quot;addTwo&quot;, uint32(1234), uint32(5678))
    if err == nil {
        fmt.Println(&quot;Get the result:&quot;, res[0].(int32))
    } else {
        fmt.Println(&quot;Error message:&quot;, err.Error())
    }
    fmt.Println(&quot;Data value:&quot;, data)

    impobj.Release()
    vm.Release()
}
</code></pre>
<p>Then you can build and run the Golang application with the WasmEdge Golang SDK:</p>
<pre><code class="language-bash">$ go get github.com/second-state/WasmEdge-go/wasmedge@v0.9.0
$ go build
$ ./wasmedge_test
Get the result: 6912
Data value: 6912
</code></pre>
</li>
</ol>
<h2 id="wasmedge-aot-compiler"><a class="header" href="#wasmedge-aot-compiler">WasmEdge AOT Compiler</a></h2>
<p>In this partition, we will introduce the WasmEdge AOT compiler and the options in Go.
WasmEdge runs the WASM files in interpreter mode, and WasmEdge also supports the AOT (ahead-of-time) mode running without modifying any code.
The WasmEdge AOT (ahead-of-time) compiler compiles the WASM files for running in AOT mode which is much faster than interpreter mode. Developers can compile the WASM files into the compiled-WASM files in shared library format for universal WASM format for the AOT mode execution.</p>
<h3 id="compilation-example"><a class="header" href="#compilation-example">Compilation Example</a></h3>
<p>The <a href="https://github.com/second-state/WasmEdge-go-examples/tree/master/go_WasmAOT">go_WasmAOT example</a> provide a tool for compiling a WASM file.</p>
<h3 id="compiler-options"><a class="header" href="#compiler-options">Compiler Options</a></h3>
<p>Developers can set options for AOT compilers such as optimization level and output format:</p>
<pre><code class="language-go">const (
    // Disable as many optimizations as possible.
    CompilerOptLevel_O0 = CompilerOptimizationLevel(C.WasmEdge_CompilerOptimizationLevel_O0)
    // Optimize quickly without destroying debuggability.
    CompilerOptLevel_O1 = CompilerOptimizationLevel(C.WasmEdge_CompilerOptimizationLevel_O1)
    // Optimize for fast execution as much as possible without triggering significant incremental compile time or code size growth.
    CompilerOptLevel_O2 = CompilerOptimizationLevel(C.WasmEdge_CompilerOptimizationLevel_O2)
    // Optimize for fast execution as much as possible.
    CompilerOptLevel_O3 = CompilerOptimizationLevel(C.WasmEdge_CompilerOptimizationLevel_O3)
    // Optimize for small code size as much as possible without triggering significant incremental compile time or execution time slowdowns.
    CompilerOptLevel_Os = CompilerOptimizationLevel(C.WasmEdge_CompilerOptimizationLevel_Os)
    /// Optimize for small code size as much as possible.
    CompilerOptLevel_Oz = CompilerOptimizationLevel(C.WasmEdge_CompilerOptimizationLevel_Oz)
)

const (
    /// Native dynamic library format.
    CompilerOutputFormat_Native = CompilerOutputFormat(C.WasmEdge_CompilerOutputFormat_Native)
    /// WebAssembly with AOT compiled codes in custom section.
    CompilerOutputFormat_Wasm = CompilerOutputFormat(C.WasmEdge_CompilerOutputFormat_Wasm)
)
</code></pre>
<p>Please refer to the <a href="#Configurations">AOT compiler options configuration</a> for details.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../../embed/go/bindgen.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                            <a rel="next" href="../../embed/node.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../../embed/go/bindgen.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                    <a rel="next" href="../../embed/node.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="../../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
    </body>
</html>
