<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>WasmEdge Runtime</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-NGPCK7VF2L"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-NGPCK7VF2L');
</script>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item "><a href="index.html"><strong aria-hidden="true">1.</strong> Getting started</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="start/install.html"><strong aria-hidden="true">1.1.</strong> Install and uninstall</a></li><li class="chapter-item "><a href="start/docker.html"><strong aria-hidden="true">1.2.</strong> Use Docker</a></li><li class="chapter-item "><a href="start/cli.html"><strong aria-hidden="true">1.3.</strong> WasmEdge command line</a></li><li class="chapter-item "><a href="start/universal.html"><strong aria-hidden="true">1.4.</strong> Universal Binary</a></li></ol></li><li class="chapter-item "><a href="intro.html"><strong aria-hidden="true">2.</strong> What is WasmEdge</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="intro/use.html"><strong aria-hidden="true">2.1.</strong> Use cases</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="intro/use/runtime.html"><strong aria-hidden="true">2.1.1.</strong> Cloud-native runtime</a></li><li class="chapter-item "><a href="intro/use/js.html"><strong aria-hidden="true">2.1.2.</strong> JavaScript or DSL runtime</a></li><li class="chapter-item "><a href="intro/use/serverless.html"><strong aria-hidden="true">2.1.3.</strong> Serverless function-as-a-service in public clouds</a></li><li class="chapter-item "><a href="intro/use/edge.html"><strong aria-hidden="true">2.1.4.</strong> Edge computing</a></li><li class="chapter-item "><a href="intro/use/saas.html"><strong aria-hidden="true">2.1.5.</strong> Reactive functions for SaaS</a></li></ol></li><li class="chapter-item "><a href="intro/features.html"><strong aria-hidden="true">2.2.</strong> Feature highlights</a></li><li class="chapter-item "><a href="intro/standard.html"><strong aria-hidden="true">2.3.</strong> Standard extensions</a></li><li class="chapter-item "><a href="intro/proprietary.html"><strong aria-hidden="true">2.4.</strong> Proprietary extensions</a></li><li class="chapter-item "><a href="intro/integrations.html"><strong aria-hidden="true">2.5.</strong> Integrations</a></li><li class="chapter-item "><a href="intro/faq.html"><strong aria-hidden="true">2.6.</strong> FAQ</a></li></ol></li><li class="chapter-item "><a href="dev.html"><strong aria-hidden="true">3.</strong> Develop a WasmEdge app</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="dev/rust.html"><strong aria-hidden="true">3.1.</strong> Rust</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="dev/rust/wasi.html"><strong aria-hidden="true">3.1.1.</strong> Access OS services</a></li><li class="chapter-item "><a href="dev/rust/tensorflow.html"><strong aria-hidden="true">3.1.2.</strong> Tensorflow</a></li><li class="chapter-item "><a href="dev/rust/networking.html"><strong aria-hidden="true">3.1.3.</strong> Networking sockets</a></li><li class="chapter-item "><a href="dev/rust/command.html"><strong aria-hidden="true">3.1.4.</strong> Command interface</a></li><li class="chapter-item "><a href="dev/rust/bindgen.html"><strong aria-hidden="true">3.1.5.</strong> rustwasmc</a></li></ol></li><li class="chapter-item "><a href="dev/js.html"><strong aria-hidden="true">3.2.</strong> JavaScript</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="dev/js/quickstart.html"><strong aria-hidden="true">3.2.1.</strong> Getting started</a></li><li class="chapter-item "><a href="dev/js/es6.html"><strong aria-hidden="true">3.2.2.</strong> ES6 module</a></li><li class="chapter-item "><a href="dev/js/cjs.html"><strong aria-hidden="true">3.2.3.</strong> CommonJS module</a></li><li class="chapter-item "><a href="dev/js/npm.html"><strong aria-hidden="true">3.2.4.</strong> NodeJS &amp; NPM module</a></li><li class="chapter-item "><a href="dev/js/ssr.html"><strong aria-hidden="true">3.2.5.</strong> Example: React SSR</a></li><li class="chapter-item "><a href="dev/js/tensorflow.html"><strong aria-hidden="true">3.2.6.</strong> Tensorflow</a></li><li class="chapter-item "><a href="dev/js/networking.html"><strong aria-hidden="true">3.2.7.</strong> Networking sockets</a></li><li class="chapter-item "><a href="dev/js/async.html"><strong aria-hidden="true">3.2.8.</strong> Async networking</a></li><li class="chapter-item "><a href="dev/js/rust.html"><strong aria-hidden="true">3.2.9.</strong> Use Rust to implement JS API</a></li></ol></li><li class="chapter-item "><a href="dev/go.html"><strong aria-hidden="true">3.3.</strong> Go</a></li><li class="chapter-item "><a href="dev/swift.html"><strong aria-hidden="true">3.4.</strong> Swift</a></li><li class="chapter-item "><a href="dev/as.html"><strong aria-hidden="true">3.5.</strong> AssemblyScript</a></li><li class="chapter-item "><a href="dev/kotlin.html"><strong aria-hidden="true">3.6.</strong> Kotlin</a></li><li class="chapter-item "><a href="dev/grain.html"><strong aria-hidden="true">3.7.</strong> Grain</a></li></ol></li><li class="chapter-item "><a href="embed.html"><strong aria-hidden="true">4.</strong> Embed WasmEdge functions</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="embed/c.html"><strong aria-hidden="true">4.1.</strong> C SDK</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="embed/c/ref.html"><strong aria-hidden="true">4.1.1.</strong> API references</a></li></ol></li><li class="chapter-item "><a href="embed/go.html"><strong aria-hidden="true">4.2.</strong> Go SDK</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="embed/go/app.html"><strong aria-hidden="true">4.2.1.</strong> Embed WASM apps</a></li><li class="chapter-item "><a href="embed/go/function.html"><strong aria-hidden="true">4.2.2.</strong> Embed WASM funcs</a></li><li class="chapter-item "><a href="embed/go/memory.html"><strong aria-hidden="true">4.2.3.</strong> Pass complex data</a></li><li class="chapter-item "><a href="embed/go/tensorflow.html"><strong aria-hidden="true">4.2.4.</strong> Tensorflow</a></li><li class="chapter-item "><a href="embed/go/bindgen.html"><strong aria-hidden="true">4.2.5.</strong> Embed bindgen funcs</a></li><li class="chapter-item "><a href="embed/go/ref.html"><strong aria-hidden="true">4.2.6.</strong> API references</a></li></ol></li><li class="chapter-item "><a href="embed/node.html"><strong aria-hidden="true">4.3.</strong> Node.js SDK</a></li><li class="chapter-item "><a href="embed/rust.html"><strong aria-hidden="true">4.4.</strong> Rust SDK</a></li><li class="chapter-item "><a href="embed/python.html"><strong aria-hidden="true">4.5.</strong> Python SDK</a></li></ol></li><li class="chapter-item "><a href="kubernetes.html"><strong aria-hidden="true">5.</strong> WasmEdge in Kubernetes</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="kubernetes/quickstart.html"><strong aria-hidden="true">5.1.</strong> Quick start</a></li><li class="chapter-item "><a href="kubernetes/demo.html"><strong aria-hidden="true">5.2.</strong> Demo apps</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="kubernetes/demo/wasi.html"><strong aria-hidden="true">5.2.1.</strong> Simple example</a></li><li class="chapter-item "><a href="kubernetes/demo/server.html"><strong aria-hidden="true">5.2.2.</strong> HTTP service</a></li></ol></li><li class="chapter-item "><a href="kubernetes/container.html"><strong aria-hidden="true">5.3.</strong> Container runtimes</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="kubernetes/container/crun.html"><strong aria-hidden="true">5.3.1.</strong> crun</a></li><li class="chapter-item "><a href="kubernetes/container/runc.html"><strong aria-hidden="true">5.3.2.</strong> runc</a></li><li class="chapter-item "><a href="kubernetes/container/youki.html"><strong aria-hidden="true">5.3.3.</strong> youki</a></li></ol></li><li class="chapter-item "><a href="kubernetes/cri.html"><strong aria-hidden="true">5.4.</strong> CRI runtimes</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="kubernetes/cri/crio.html"><strong aria-hidden="true">5.4.1.</strong> CRI-O</a></li><li class="chapter-item "><a href="kubernetes/cri/containerd.html"><strong aria-hidden="true">5.4.2.</strong> containerd</a></li></ol></li><li class="chapter-item "><a href="kubernetes/kubernetes.html"><strong aria-hidden="true">5.5.</strong> Kubernetes</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="kubernetes/kubernetes/kubernetes-crio.html"><strong aria-hidden="true">5.5.1.</strong> Kubernetes + CRI-O</a></li><li class="chapter-item "><a href="kubernetes/kubernetes/kubernetes-containerd.html"><strong aria-hidden="true">5.5.2.</strong> Kubernetes + containerd</a></li><li class="chapter-item "><a href="kubernetes/kubernetes/kubeedge.html"><strong aria-hidden="true">5.5.3.</strong> KubeEdge</a></li><li class="chapter-item "><a href="kubernetes/kubernetes/superedge.html"><strong aria-hidden="true">5.5.4.</strong> SuperEdge</a></li><li class="chapter-item "><a href="kubernetes/kubernetes/openyurt.html"><strong aria-hidden="true">5.5.5.</strong> OpenYurt</a></li></ol></li></ol></li><li class="chapter-item "><a href="frameworks.html"><strong aria-hidden="true">6.</strong> App frameworks &amp; platforms</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="frameworks/mesh.html"><strong aria-hidden="true">6.1.</strong> Service mesh &amp; runtimes</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="frameworks/mesh/dapr.html"><strong aria-hidden="true">6.1.1.</strong> Dapr</a></li><li class="chapter-item "><a href="frameworks/mesh/mosn.html"><strong aria-hidden="true">6.1.2.</strong> MOSN</a></li><li class="chapter-item "><a href="frameworks/mesh/eventmesh.html"><strong aria-hidden="true">6.1.3.</strong> Apache EventMesh</a></li></ol></li><li class="chapter-item "><a href="frameworks/app.html"><strong aria-hidden="true">6.2.</strong> Application frameworks</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="frameworks/app/yomo.html"><strong aria-hidden="true">6.2.1.</strong> YoMo</a></li><li class="chapter-item "><a href="frameworks/app/reactr.html"><strong aria-hidden="true">6.2.2.</strong> Reactr</a></li></ol></li><li class="chapter-item "><a href="frameworks/serverless.html"><strong aria-hidden="true">6.3.</strong> Serverless platforms</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="frameworks/serverless/vercel.html"><strong aria-hidden="true">6.3.1.</strong> Vercel</a></li><li class="chapter-item "><a href="frameworks/serverless/netlify.html"><strong aria-hidden="true">6.3.2.</strong> Netlify</a></li><li class="chapter-item "><a href="frameworks/serverless/aws.html"><strong aria-hidden="true">6.3.3.</strong> AWS</a></li><li class="chapter-item "><a href="frameworks/serverless/tencent.html"><strong aria-hidden="true">6.3.4.</strong> Tencent</a></li><li class="chapter-item "><a href="frameworks/serverless/secondstate.html"><strong aria-hidden="true">6.3.5.</strong> Second State</a></li></ol></li></ol></li><li class="chapter-item "><a href="os.html"><strong aria-hidden="true">7.</strong> Operating systems</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="os/linux.html"><strong aria-hidden="true">7.1.</strong> Linux</a></li><li class="chapter-item "><a href="os/windows.html"><strong aria-hidden="true">7.2.</strong> Windows</a></li><li class="chapter-item "><a href="os/mac.html"><strong aria-hidden="true">7.3.</strong> Mac</a></li><li class="chapter-item "><a href="os/sel4.html"><strong aria-hidden="true">7.4.</strong> seL4</a></li><li class="chapter-item "><a href="os/openharmony.html"><strong aria-hidden="true">7.5.</strong> Open Harmony</a></li><li class="chapter-item "><a href="os/raspberrypi.html"><strong aria-hidden="true">7.6.</strong> Raspberry Pi</a></li></ol></li><li class="chapter-item "><a href="extend.html"><strong aria-hidden="true">8.</strong> Contribute to WasmEdge</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="extend/build.html"><strong aria-hidden="true">8.1.</strong> Build WasmEdge from source</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="extend/build_on_mac.html"><strong aria-hidden="true">8.1.1.</strong> Build for Mac</a></li><li class="chapter-item "><a href="extend/build_on_windows.html"><strong aria-hidden="true">8.1.2.</strong> Build for Windows</a></li></ol></li><li class="chapter-item "><a href="extend/plugin.html"><strong aria-hidden="true">8.2.</strong> WasmEdge plug-in API</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="extend/plugin/hostfunction.html"><strong aria-hidden="true">8.2.1.</strong> Host functions</a></li><li class="chapter-item "><a href="extend/plugin/externref.html"><strong aria-hidden="true">8.2.2.</strong> External references</a></li></ol></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">WasmEdge Runtime</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/WasmEdge/WasmEdge" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="getting-started"><a class="header" href="#getting-started">Getting started</a></h1>
<p>The easiest way to get started with WasmEdge is to use its command line tools (CLI). 
You can then run our example WebAssembly and JavaScript programs in the WasmEdge CLI.
After that, you can create new programs for WasmEdge and run them in different
host applications or frameworks.</p>
<h2 id="install"><a class="header" href="#install">Install</a></h2>
<p>You can install WasmEdge using our one-line installer. 
Your system should have <code>git</code> and <code>wget</code> as prerequisites.</p>
<pre><code>wget -qO- https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/utils/install.sh | bash
</code></pre>
<p>If you would like to install WasmEdge with its <a href="https://www.secondstate.io/articles/wasi-tensorflow/">Tensorflow and image processing extensions</a>, 
please run the following command. It will attempt to install 
Tensorflow and image shared libraries on your system.</p>
<pre><code>wget -qO- https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/utils/install.sh | bash -s -- -e all
</code></pre>
<p>Run the following command to make the installed binary available 
in the current session source <code>$HOME/.wasmedge/env</code>.</p>
<h2 id="use-docker"><a class="header" href="#use-docker">Use Docker</a></h2>
<p>If you use Docker, you can simply run the WasmEdge application developer 
Docker images (<a href="https://hub.docker.com/repository/docker/wasmedge/appdev_x86_64">x86</a> and <a href="https://hub.docker.com/repository/docker/wasmedge/appdev_aarch64">arm64</a>). Those images contain all the tooling you need for quick
WasmEdge development.</p>
<pre><code>docker pull wasmedge/appdev_x86_64:0.9.0
docker run --rm -v $(pwd):/app -it wasmedge/appdev_x86_64:0.9.0
(docker) #
</code></pre>
<h2 id="webassembly-examples"><a class="header" href="#webassembly-examples">WebAssembly examples</a></h2>
<p>We have several WebAssembly bytecode program examples for you to try out on
your newly installed WasmEdge CLI! </p>
<h3 id="hello-world"><a class="header" href="#hello-world">Hello world</a></h3>
<p>The <a href="https://github.com/WasmEdge/WasmEdge/raw/master/tools/wasmedge/examples/hello.wasm">hello.wasm</a> WebAssembly program contains a <code>main()</code> function. 
Checkout its <a href="https://github.com/second-state/wasm-learning/tree/master/cli/hello">Rust source code project</a>. 
It prints out <code>hello</code> followed by the command line arguments.</p>
<pre><code>$ wasmedge hello.wasm second state
hello
second
state
</code></pre>
<h3 id="call-a-function-written-in-rust"><a class="header" href="#call-a-function-written-in-rust">Call a function written in Rust</a></h3>
<p>The <a href="https://github.com/WasmEdge/WasmEdge/raw/master/tools/wasmedge/examples/add.wasm">add.wasm</a> WebAssembly program contains an <code>add()</code> function. 
Checkout its <a href="https://github.com/second-state/wasm-learning/tree/master/cli/add">Rust source code project</a>. 
We use WasmEdge in reactor mode to call the <code>add()</code> with two integer input parameters.</p>
<pre><code>$ wasmedge --reactor add.wasm add 2 2
4
</code></pre>
<h3 id="call-a-function-written-in-wat"><a class="header" href="#call-a-function-written-in-wat">Call a function written in WAT</a></h3>
<p>We created the <a href="https://github.com/WasmEdge/WasmEdge/raw/master/tools/wasmedge/examples/fibonacci.wat">fibonacci.wat</a> program by hand and used 
the <a href="https://github.com/WebAssembly/wabt">wat2wasm</a> compiler to build the <a href="https://github.com/WasmEdge/WasmEdge/raw/master/tools/wasmedge/examples/fibonacci.wasm">fibonacci.wasm</a> WebAssembly program. 
It contains a <code>fib()</code> function which takes a single integer as input parameter. We use wasmedge in reactor mode to call the exported function.</p>
<pre><code>$ wasmedge --reactor fibonacci.wasm fib 10
89
</code></pre>
<h3 id="with-statistics-enabled"><a class="header" href="#with-statistics-enabled">With Statistics enabled</a></h3>
<p>The CLI supports <code>--enable-all-statistics</code> flags for the statistics and gas meter. </p>
<pre><code class="language-bash">$ wasmedge --enable-all-statistics hello.wasm second state
hello
second
state
[2021-12-09 16:03:33.261] [info] ====================  Statistics  ====================
[2021-12-09 16:03:33.261] [info]  Total execution time: 268266 ns
[2021-12-09 16:03:33.261] [info]  Wasm instructions execution time: 251610 ns
[2021-12-09 16:03:33.261] [info]  Host functions execution time: 16656 ns
[2021-12-09 16:03:33.261] [info]  Executed wasm instructions count: 20425
[2021-12-09 16:03:33.261] [info]  Gas costs: 20425
[2021-12-09 16:03:33.261] [info]  Instructions per second: 81177218
[2021-12-09 16:03:33.261] [info] =======================   End   ======================
</code></pre>
<h3 id="with-gas-limit-enabled"><a class="header" href="#with-gas-limit-enabled">With gas-limit enabled</a></h3>
<p>The CLI supports <code>--gas-limit</code> flags for controlling the execution costs. </p>
<pre><code class="language-bash"># cd &lt;path/to/WasmEdge&gt;
$ cd tools/wasmedge/examples
# With enough gas
$ wasmedge --enable-all-statistics --gas-limit 20425 hello.wasm second state
hello
second
state
[2021-12-09 16:03:33.261] [info] ====================  Statistics  ====================
[2021-12-09 16:03:33.261] [info]  Total execution time: 268266 ns
[2021-12-09 16:03:33.261] [info]  Wasm instructions execution time: 251610 ns
[2021-12-09 16:03:33.261] [info]  Host functions execution time: 16656 ns
[2021-12-09 16:03:33.261] [info]  Executed wasm instructions count: 20425
[2021-12-09 16:03:33.261] [info]  Gas costs: 20425
[2021-12-09 16:03:33.261] [info]  Instructions per second: 81177218
[2021-12-09 16:03:33.261] [info] =======================   End   ======================

# Without enough gas
$ wasmedge --enable-all-statistics --gas-limit 20 hello.wasm second state
[2021-12-23 15:19:06.690] [error] Cost exceeded limit. Force terminate the execution.
[2021-12-23 15:19:06.690] [error]     In instruction: ref.func (0xd2) , Bytecode offset: 0x00000000
[2021-12-23 15:19:06.690] [error]     At AST node: expression
[2021-12-23 15:19:06.690] [error]     At AST node: element segment
[2021-12-23 15:19:06.690] [error]     At AST node: element section
[2021-12-23 15:19:06.690] [error]     At AST node: module
[2021-12-23 15:19:06.690] [info] ====================  Statistics  ====================
[2021-12-23 15:19:06.690] [info]  Total execution time: 0 ns
[2021-12-23 15:19:06.690] [info]  Wasm instructions execution time: 0 ns
[2021-12-23 15:19:06.690] [info]  Host functions execution time: 0 ns
[2021-12-23 15:19:06.690] [info]  Executed wasm instructions count: 21
[2021-12-23 15:19:06.690] [info]  Gas costs: 20
</code></pre>
<h2 id="javascript-examples"><a class="header" href="#javascript-examples">JavaScript examples</a></h2>
<p>It is possible to use WasmEdge as a high-performance, secure, extensible, easy to deploy, and <a href="https://github.com/second-state/wasmedge-containers-examples">Kubernetes-compliant</a> JavaScript runtime. </p>
<p>The <a href="https://github.com/WasmEdge/WasmEdge/raw/master/tools/wasmedge/examples/js/qjs.wasm">qjs.wasm</a> program is a JavaScript interpreter compiled into WebAssembly. 
The <a href="https://github.com/WasmEdge/WasmEdge/raw/master/tools/wasmedge/examples/js/hello.js">hello.js</a> file is a very simple JavaScript program.</p>
<pre><code>$ wasmedge --dir .:. qjs.wasm hello.js 1 2 3
Hello 1 2 3
</code></pre>
<p>The <a href="https://github.com/WasmEdge/WasmEdge/raw/master/tools/wasmedge/examples/js/qjs_tf.wasm">qjs_tf.wasm</a> is a JavaScript interpreter with 
<a href="https://www.secondstate.io/articles/wasi-tensorflow/">WasmEdge Tensorflow extension</a> compiled into WebAssembly. 
To run <a href="https://github.com/WasmEdge/WasmEdge/raw/master/tools/wasmedge/examples/js/qjs_tf.wasm">qjs_tf.wasm</a>, you must use the <code>wasmedge-tensorflow-lite</code> CLI tool, which is a build of WasmEdge with Tensorflow extension built-in. 
You can download a full <a href="https://github.com/second-state/wasmedge-quickjs/tree/main/example_js/tensorflow_lite_demo">Tensorflow-based JavaScript example</a> to classify images.</p>
<pre><code># Download the Tensorflow example
$ wget https://raw.githubusercontent.com/second-state/wasmedge-quickjs/main/example_js/tensorflow_lite_demo/aiy_food_V1_labelmap.txt
$ wget https://raw.githubusercontent.com/second-state/wasmedge-quickjs/main/example_js/tensorflow_lite_demo/food.jpg
$ wget https://raw.githubusercontent.com/second-state/wasmedge-quickjs/main/example_js/tensorflow_lite_demo/lite-model_aiy_vision_classifier_food_V1_1.tflite
$ wget https://raw.githubusercontent.com/second-state/wasmedge-quickjs/main/example_js/tensorflow_lite_demo/main.js

$ wasmedge-tensorflow-lite --dir .:. qjs_tf.wasm main.js
label: Hot dog
confidence: 0.8941176470588236
</code></pre>
<p>Read on and continue your learning of WasmEdge.</p>
<ul>
<li><a href="start/install.html">Install and uninstall WasmEdge</a></li>
<li><a href="start/cli.html">Use the WasmEdge CLI</a></li>
<li><a href="intro/use.html">WasmEdge use cases</a></li>
<li><a href="intro/features.html">WasmEdge technical highlights</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="install-and-uninstall-wasmedge"><a class="header" href="#install-and-uninstall-wasmedge">Install and uninstall WasmEdge</a></h1>
<h2 id="quick-install"><a class="header" href="#quick-install">Quick install</a></h2>
<p>The easiest way to install WasmEdge is to run the following command. Your system should have <code>git</code> and <code>wget</code> as prerequisites.</p>
<pre><code class="language-bash">wget -qO- https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/utils/install.sh | bash
</code></pre>
<p>If you would like to install WasmEdge with its <a href="https://www.secondstate.io/articles/wasi-tensorflow/">Tensorflow and image processing extensions</a>, please run the following command. It will attempt to install Tensorflow and image shared libraries on your system.</p>
<pre><code class="language-bash">wget -qO- https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/utils/install.sh | bash -s -- -e all
</code></pre>
<p>Run the following command to make the installed binary available in the current session <code>source $HOME/.wasmedge/env</code></p>
<p><strong>That's it!</strong> You can now use WasmEdge from the CLI, or launch it from an application. To update WasmEdge to a new release, just re-run the above command to write over the old files.</p>
<h2 id="install-for-all-users"><a class="header" href="#install-for-all-users">Install for all users</a></h2>
<p>By default, WasmEdge is installed in the <code>$HOME/.wasmedge</code> directory. You can install it into a system directory, such as <code>/usr/local</code> to make it available to all users. To specify an install directory, you can run the <code>install.sh</code> script with the <code>-p</code> flag. You will need to run the following commands as the <code>root</code> user or <code>sudo</code> since they write into system directories.</p>
<pre><code class="language-bash">wget -qO- https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/utils/install.sh | bash -s -- -p /usr/local
</code></pre>
<p>Or, with all extensions</p>
<pre><code class="language-bash">wget -qO- https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/utils/install.sh | bash -s -- -e all -p /usr/local
</code></pre>
<h2 id="install-a-specific-version-of-wasmedge"><a class="header" href="#install-a-specific-version-of-wasmedge">Install a specific version of WasmEdge</a></h2>
<p>You could install specific versions of WasmEdge, including pre-releases or
old releases by passing the <code>-v</code> argument to the install script. Here is an example.</p>
<pre><code class="language-bash">wget -qO- https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/utils/install.sh | bash -s -- -e all -v 0.9.0-rc.5
</code></pre>
<p>If you are interested in the latest builds from the <code>HEAD</code> of the <code>master</code> branch, which is basically WasmEdge's nightly builds, you can download the 
release package directly from our Github Action's CI artifact. <a href="https://github.com/WasmEdge/WasmEdge/actions/runs/1521549504#artifacts">Here is an example</a>.</p>
<h2 id="whats-installed"><a class="header" href="#whats-installed">What's installed</a></h2>
<p>After installation, you have the following directories and files. Here we assume that you installed into the <code>$HOME/.wasmedge</code> directory. You could also change it to <code>/usr/local</code> if you did a system-wide install.</p>
<ul>
<li>The <code>$HOME/.wasmedge/bin</code> directory contains the WasmEdge Runtime CLI executable files. You can copy and move them around on your file system.
<ul>
<li>The <code>wasmedge</code> tool is the standard WasmEdge runtime. You can use it from the CLI. <code>wasmedge --dir .:. app.wasm</code></li>
<li>The <code>wasmedgec</code> tool is the AOT compiler to compile a <code>wasm</code> file into a native <code>so</code> file. <code>wasmedgec app.wasm app.so</code> The <code>wasmedge</code> can then execute the <code>so</code> file. <code>wasmedge --dir .:. app.so</code></li>
<li>The <code>wasmedge-tensorflow</code>, <code>wasmedge-tensorflow-lite</code> and <code>wasmedgec-tensorflow</code> tools are runtimes and compilers that support the WasmEdge tensorflow SDK.</li>
</ul>
</li>
<li>The <code>$HOME/.wasmedge/lib</code> directory contains WasmEdge shared libraries, as well as dependency libraries. They are useful for WasmEdge SDKs to launch WasmEdge programs and functions from host applications.</li>
<li>The <code>$HOME/.wasmedge/include</code> directory contains the WasmEdge header files. They are useful for WasmEdge SDKs.</li>
</ul>
<h2 id="uninstall"><a class="header" href="#uninstall">Uninstall</a></h2>
<p>To uninstall WasmEdge, you can run the following command.</p>
<pre><code class="language-bash">bash &lt;(wget -qO- https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/utils/uninstall.sh)
</code></pre>
<p>If <code>wasmedge</code> binary is not in <code>PATH</code> and it wasn't installed in the default <code>$HOME/.wasmedge</code> folder, then you must provide the installation path.</p>
<pre><code class="language-bash">bash &lt;(wget -qO- https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/utils/uninstall.sh) -p /path/to/parent/folder
</code></pre>
<p>If you wish to uninstall uninteractively, you can pass in the <code>--quick</code> or <code>-q</code> flag.</p>
<pre><code class="language-bash">bash &lt;(wget -qO- https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/utils/uninstall.sh) -q
</code></pre>
<blockquote>
<p>If a parent folder of the <code>wasmedge</code> binary contains <code>.wasmedge</code>, the folder will be considered for removal. For example, the script removes the default <code>$HOME/.wasmedge</code> folder altogether.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="use-docker-for-wasmedge-app-development"><a class="header" href="#use-docker-for-wasmedge-app-development">Use Docker for WasmEdge app development</a></h1>
<p>The <code>appdev</code> Docker images provide a complete WasmEdge application development environment. To use it, do the following.</p>
<h3 id="on-x86_64-machines"><a class="header" href="#on-x86_64-machines">On x86_64 machines</a></h3>
<pre><code>$ docker pull wasmedge/appdev_x86_64:0.9.0
$ docker run --rm -v $(pwd):/app -it wasmedge/appdev_x86_64:0.9.0
(docker) #
</code></pre>
<p>Here is the <a href="https://github.com/WasmEdge/WasmEdge/blob/master/utils/docker/Dockerfile.appdev_x86_64">Dockerfile</a> and <a href="https://hub.docker.com/repository/docker/wasmedge/appdev_x86_64">Docker Hub image</a>.</p>
<h3 id="on-arm64-machines"><a class="header" href="#on-arm64-machines">On arm64 machines</a></h3>
<pre><code>$ docker pull wasmedge/appdev_aarch64:0.9.0
$ docker run --rm -v $(pwd):/app -it wasmedge/appdev_aarch64:0.9.0
(docker) #
</code></pre>
<p>Here is the <a href="https://github.com/WasmEdge/WasmEdge/blob/master/utils/docker/Dockerfile.appdev_aarch64">Dockerfile</a> and <a href="https://hub.docker.com/repository/docker/wasmedge/appdev_aarch64">Docker Hub image</a>.</p>
<p>The WasmEdge application development Docker image installs the following components.</p>
<ul>
<li>WasmEdge CLI and shared libraries</li>
<li>WasmEdge with Tensorflow extension CLI and libraries (x86_64 only)</li>
<li>Golang</li>
<li>Rust</li>
<li>Node.js with WasmEdge addons</li>
<li>Examples in the <code>/root/examples/</code> folder</li>
</ul>
<h2 id="examples"><a class="header" href="#examples">Examples</a></h2>
<p>Hello World. <a href="https://github.com/WasmEdge/WasmEdge/tree/master/tools/wasmedge/examples">See more simple examples</a></p>
<pre><code>$ wasmedge hello.wasm world
hello
world
</code></pre>
<p>Use AOT to run it <em>much faster</em>.</p>
<pre><code>$ wasmedgec hello.wasm hello.wasm
$ wasmedge hello.wasm world
hello
world
</code></pre>
<p>Here are some JavaScript examples. <a href="https://github.com/WasmEdge/WasmEdge/tree/master/tools/wasmedge/examples/js">See more</a></p>
<pre><code>$ wasmedge --dir .:. qjs.wasm hello.js 1 2 3
Hello 1 2 3

$ wasmedge-tensorflow-lite --dir .:. qjs_tf.wasm tf_image_classify.js
label: Hot dog
confidence: 0.8941176470588236
</code></pre>
<h2 id="build-and-publish-the-appdev-images"><a class="header" href="#build-and-publish-the-appdev-images">Build and publish the appdev images</a></h2>
<p>Run these commands to build and publish the <code>appdev</code> Docker images.</p>
<h3 id="build-on-an-x86_64-machine"><a class="header" href="#build-on-an-x86_64-machine">Build on an x86_64 machine</a></h3>
<pre><code>docker build -t wasmedge/appdev_x86_64:0.9.0 -f Dockerfile.appdev_x86_64 ./ 
docker image push wasmedge/appdev_x86_64:0.9.0
</code></pre>
<h3 id="build-on-an-arm64--aarch64-machine"><a class="header" href="#build-on-an-arm64--aarch64-machine">Build on an ARM64 / aarch64 machine</a></h3>
<pre><code>docker build -t wasmedge/appdev_aarch64:0.9.0 -f Dockerfile.appdev_aarch64 ./
docker image push wasmedge/appdev_aarch64:0.9.0
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="wasmedge-command-line-tool-cli"><a class="header" href="#wasmedge-command-line-tool-cli">WasmEdge command line tool (CLI)</a></h1>
<p>After <a href="start/install.html">installing WasmEdge</a> or starting the <a href="start/docker.html">WasmEdge app dev Docker container</a>, there are several ways to run compiled WebAssembly programs. </p>
<h2 id="wasmedge"><a class="header" href="#wasmedge">wasmedge</a></h2>
<p>The <code>wasmedge</code> binary file is a command line interface (CLI) program that runs
WebAssembly bytecode programs.</p>
<ul>
<li>If the WebAssembly program contains a <code>main()</code> function, <code>wasmedge</code> would execute it as a standalone program in the command mode.</li>
<li>If the WebAssembly program contains one or more public functions, <code>wasmedge</code> could execute individual functions in the reactor mode.</li>
</ul>
<h3 id="command-line-options"><a class="header" href="#command-line-options">Command line options</a></h3>
<p>The options and flags for the <code>wasmedge</code> command are as follows.</p>
<ol>
<li>(Optional) Statistics information:
<ul>
<li>Use <code>--enable-time-measuring</code> to show the execution time.</li>
<li>Use <code>--enable-gas-measuring</code> to show the amount of used gas.</li>
<li>Use <code>--enable-instruction-count</code> to display the number of executed instructions.</li>
<li>Or use <code>--enable-all-statistics</code> to enable all of the statistics options.</li>
</ul>
</li>
<li>(Optional) Resource limitation:
<ul>
<li>Use <code>--gas-limit</code> to limit the execution cost.</li>
<li>Use <code>--memory-page-limit</code> to set the limitation of pages(as size of 64 KiB) in every memory instance.</li>
</ul>
</li>
<li>(Optional) Reactor mode: use <code>--reactor</code> to enable reactor mode. In the reactor mode, <code>wasmedge</code> runs a specified function from the WebAssembly program.
<ul>
<li>WasmEdge will execute the function which name should be given in <code>ARG[0]</code>.</li>
<li>If there's exported function which names <code>_initialize</code>, the function will be executed with the empty parameter at first.</li>
</ul>
</li>
<li>(Optional) Binding directories into WASI virtual filesystem.
<ul>
<li>Each directory can be specified as <code>--dir guest_path:host_path</code>.</li>
</ul>
</li>
<li>(Optional) Environ variables.
<ul>
<li>Each variable can be specified as <code>--env NAME=VALUE</code>.</li>
</ul>
</li>
<li>Wasm file (<code>/path/to/wasm/file</code>).</li>
<li>(Optional) Arguments.
<ul>
<li>In reactor mode, the first argument will be the function name, and the arguments after <code>ARG[0]</code> will be parameters of wasm function <code>ARG[0]</code>.</li>
<li>In command mode, the arguments will be parameters of function <code>_start</code>. They are also known as command line arguments for a standalone program.</li>
</ul>
</li>
</ol>
<p>Once installed, you can <a href="start/../index.html">review and run our examples</a>.</p>
<h2 id="wasmedgec"><a class="header" href="#wasmedgec">wasmedgec</a></h2>
<p>The <code>wasmedgec</code> binary file is a program to compile WebAssembly bytecode
programs into native machine code (i.e., the AOT compiler). 
The compiled machine code could be <a href="start/universal.html">stored in the original <code>wasm</code> file</a>, and
the <code>wasmedge</code> CLI will automatically choose to execute the native machine
code whenever it is available.</p>
<p>The options and flags for the <code>wasmedgec</code> are as follows.</p>
<ol>
<li>Input Wasm file(<code>/path/to/input/wasm/file</code>).</li>
<li>Output file name(<code>/path/to/output/file</code>).
<ul>
<li>By default, it will generate the <a href="start/universal.html">universal Wasm binary format</a>.</li>
<li>Users can still generate native binary only by specifying the <code>.so</code>, <code>.dylib</code>, or <code>.dll</code> extensions.</li>
</ul>
</li>
</ol>
<pre><code class="language-bash">// This is slow
$ wasmedge app.wasm

// AOT compile
$ wasmedgec app.wasm app.wasm

// This is now MUCH faster
$ wasmedge app.wasm
</code></pre>
<p>On Linux systems, it could generate 
a <code>so</code> shared library file, which is then executed by the <code>wasmedge</code> CLI.</p>
<pre><code class="language-bash">$ wasmedgec app.wasm app.so
$ wasmedge app.so
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="universal-wasm-binary-format"><a class="header" href="#universal-wasm-binary-format">Universal Wasm Binary Format</a></h1>
<p>WasmEdge could wrap the AOT-compiled native binary into a custom section in the origin wasm file. We call this the universal wasm binary format.</p>
<p>The AOT-compiled wasm file is compatible with any wasm runtime. However, when this wasm file is executed by the WasmEdge runtime, WasmEdge will extract the native binary from the custom section and execute it.</p>
<p>Of course, the user still has the option to generate the native binary file
with the <code>wasmedgec</code> AOT compiler.
WasmEdge uses the output file extension to determine generated file format. For example, if you set the <code>wasmedgec</code> output file extension to <code>.so</code>, it will generate native binary in Linux shared library format. Otherwise, it will generate a universal wasm binary by default.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="what-is-wasmedge"><a class="header" href="#what-is-wasmedge">What is WasmEdge</a></h1>
<p>WasmEdge is a lightweight, high-performance, and extensible WebAssembly runtime for cloud native, edge, and decentralized applications. It powers serverless apps, embedded functions, microservices, smart contracts, and IoT devices.</p>
<p>WasmEdge is a CNCF Sandbox project now.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="use-cases"><a class="header" href="#use-cases">Use cases</a></h1>
<p>WasmEdge is a cloud-native WebAssembly runtime hosted by the CNCF. It is widely used in edge computing, automotive, Jamstack, serverless, SaaS, service mesh, and even blockchain applications. Featuring AOT compiler optimization, WasmEdge is one of the fastest WebAssembly runtimes on the market today.</p>
<ul>
<li><a href="intro/use/runtime.html">Cloud-native runtime</a>
<ul>
<li>Dapr</li>
<li>Kubernetes</li>
</ul>
</li>
<li><a href="intro/use/js.html">JavaScript or DSL runtime</a>
<ul>
<li>JavaScript</li>
<li>DSL for image classification</li>
<li>DSL for chatbots</li>
</ul>
</li>
<li><a href="intro/use/serverless.html">Serverless function-as-a-service in public clouds</a>
<ul>
<li>AWS Lambda</li>
<li>Tencent Serverless Functions</li>
<li>Vercel Serverless Functions</li>
<li>Netlify Functions</li>
<li>Second State Functions</li>
</ul>
</li>
<li><a href="intro/use/edge.html">Edge computing</a>
<ul>
<li>YoMo Flow</li>
<li>seL4 micokernel and RTOS</li>
</ul>
</li>
<li><a href="intro/use/saas.html">Reactive functions for SaaS</a>
<ul>
<li>Slack</li>
<li>Lark</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cloud-native-runtime-as-a-lightweight-docker-alternative"><a class="header" href="#cloud-native-runtime-as-a-lightweight-docker-alternative">Cloud-native runtime (as a lightweight Docker alternative)</a></h1>
<p>WasmEdge can be embedded into cloud-native infrastructure via its SDKs in <a href="intro/use/c_api.html">C</a>, <a href="https://www.secondstate.io/articles/extend-golang-app-with-webassembly-rust/">Go</a>, <a href="intro/use/../bindings/rust/wasmedge-rs">Rust</a>, and <a href="https://www.secondstate.io/articles/getting-started-with-rust-function/">JavaScript</a>. It is also an OCI compliant runtime that can be directly <a href="https://www.secondstate.io/articles/manage-webassembly-apps-in-wasmedge-using-docker-tools/">managed by CRI-O and Docker tools</a> as a lightweight and high-performance alternative to Docker.</p>
<h2 id="dapr-distributed-application-runtime"><a class="header" href="#dapr-distributed-application-runtime">Dapr (Distributed Application Runtime)</a></h2>
<ul>
<li><a href="https://www.secondstate.io/articles/dapr-wasmedge-webassembly/">Tutorial</a></li>
<li><a href="https://github.com/second-state/dapr-wasm">Code template</a></li>
</ul>
<h2 id="service-mesh-work-in-progress"><a class="header" href="#service-mesh-work-in-progress">Service mesh (work in progress):</a></h2>
<ul>
<li>Linkerd</li>
<li>MOSN</li>
<li>Envoy</li>
</ul>
<h2 id="orchestration-and-management"><a class="header" href="#orchestration-and-management">Orchestration and management:</a></h2>
<ul>
<li><a href="https://www.secondstate.io/articles/manage-webassembly-apps-in-wasmedge-using-docker-tools/">Kubernetes</a></li>
<li>KubeEdge</li>
<li>SuperEdge</li>
<li>OpenYurt</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="javascript-or-dsl-runtime"><a class="header" href="#javascript-or-dsl-runtime">JavaScript or DSL runtime</a></h1>
<p>In order for WebAssembly to be widely adopted by developers as a runtime, it must support &quot;easy&quot; languages like JavaScript. Or, better yet, through its advanced compiler toolchain, WasmEdge could support high performance DSLs (Domain Specifc Languages), which are low code solutions designed for specific tasks.</p>
<h2 id="javascript"><a class="header" href="#javascript">JavaScript</a></h2>
<p>WasmEdge can act as a cloud-native JavaScript runtime by embedding a JS execution engine or interpreter. It is faster and lighter than running a JS engine inside Docker. WasmEdge supports JS APIs to access native extension libraries such as network sockets, tensorflow, and user-defined shared libraries. It also allows embedding JS into other high-performance languages (eg, Rust) or using Rust / C to implement JS functions.</p>
<ul>
<li>Tutorials
<ul>
<li><a href="https://www.secondstate.io/articles/run-javascript-in-webassembly-with-wasmedge/">Run JavaScript</a></li>
<li><a href="https://www.secondstate.io/articles/embed-javascript-in-rust/">Embed JavaScript in Rust</a></li>
<li><a href="https://www.secondstate.io/articles/embed-rust-in-javascript/">Create JavaScript API using Rust functions</a></li>
<li><a href="https://www.secondstate.io/articles/call-native-functions-from-javascript/">Call C native shared library functions from JavaScript</a></li>
</ul>
</li>
<li><a href="https://github.com/WasmEdge/WasmEdge/blob/master/tools/wasmedge/examples/js/README.md">Examples</a></li>
<li><a href="https://github.com/second-state/wasmedge-quickjs">WasmEdge’s embedded QuickJS engine</a></li>
</ul>
<h2 id="dsl-for-image-classification"><a class="header" href="#dsl-for-image-classification">DSL for image classification</a></h2>
<p>The image classification DSL is a YAML format that allows the user to specify a tensorflow model and its parameters. WasmEdge takes an image as the input of the DSL and outputs the detected item name / label.</p>
<ul>
<li>Example: <a href="https://github.com/second-state/wasm-learning/blob/master/cli/classify_yml/config/food.yml">Run a YAML to detect food items in an image</a></li>
</ul>
<h2 id="dsl-for-chatbots"><a class="header" href="#dsl-for-chatbots">DSL for chatbots</a></h2>
<p>A chatbot DSL function takes an input string and responds with a reply string. The DSL specifies the internal state transtions of the chatbot, as well as AI models for language understanding. This work is in progress.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="serverless-function-as-a-service-in-public-clouds"><a class="header" href="#serverless-function-as-a-service-in-public-clouds">Serverless function-as-a-service in public clouds</a></h1>
<p>WasmEdge works with existing serverless or Jamstack platforms to provide a high-performance, portable and secure runtime for functions. It offers significant benefits even when it runs inside Docker or microVMs on those platforms.</p>
<h2 id="aws-lambda"><a class="header" href="#aws-lambda">AWS Lambda</a></h2>
<ul>
<li><a href="https://www.cncf.io/blog/2021/08/25/webassembly-serverless-functions-in-aws-lambda/">Tutorial</a></li>
<li><a href="https://github.com/second-state/aws-lambda-wasm-runtime">Code template</a></li>
</ul>
<h2 id="tencent-serverless-functions"><a class="header" href="#tencent-serverless-functions">Tencent Serverless Functions</a></h2>
<ul>
<li><a href="https://my.oschina.net/u/4532842/blog/5172639">Tutorial in Chinese</a></li>
<li><a href="https://github.com/second-state/tencent-scf-wasm-runtime">Code template</a></li>
</ul>
<h2 id="vercel-serverless-functions"><a class="header" href="#vercel-serverless-functions">Vercel Serverless Functions</a></h2>
<ul>
<li><a href="https://www.secondstate.io/articles/vercel-wasmedge-webassembly-rust/">Tutorial</a></li>
<li><a href="https://github.com/second-state/vercel-wasm-runtime">Code template</a></li>
</ul>
<h2 id="netlify-functions"><a class="header" href="#netlify-functions">Netlify Functions</a></h2>
<ul>
<li><a href="https://www.secondstate.io/articles/netlify-wasmedge-webassembly-rust-serverless/">Tutorial</a></li>
<li><a href="https://github.com/second-state/netlify-wasm-runtime">Code template</a></li>
</ul>
<h2 id="second-state-functions"><a class="header" href="#second-state-functions">Second State Functions</a></h2>
<ul>
<li><a href="https://www.secondstate.io/faas/">Tutorials</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="edge-computing"><a class="header" href="#edge-computing">Edge computing</a></h1>
<p>WasmEdge is ideally suited to run on mission-critical edge devices or edge networks.</p>
<h2 id="yomo-flow"><a class="header" href="#yomo-flow">YoMo Flow</a></h2>
<p>YoMo is a high-performance data streaming framework for far edge networks. WasmEdge is integrated into YoMo to run user-defined workloads, such as image classification along a factory assembly line.</p>
<ul>
<li><a href="https://www.secondstate.io/articles/yomo-wasmedge-real-time-data-streams/">Tutorial</a></li>
<li><a href="https://github.com/yomorun/yomo-wasmedge-tensorflow">Code template</a></li>
</ul>
<h2 id="sel4-microkernel-os"><a class="header" href="#sel4-microkernel-os">seL4 microkernel OS</a></h2>
<p>seL4 is a highly secure real-time operating system. WasmEdge is the only WebAssembly runtime that can run on seL4, and it runs at native speed. We also provide a management tool to support the OTA deployment of wasm modules.</p>
<ul>
<li><a href="https://github.com/second-state/wasmedge-seL4">Demo</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="reactive-functions-for-saas"><a class="header" href="#reactive-functions-for-saas">Reactive functions for SaaS</a></h1>
<p>WasmEdge can support customized SaaS extensions or applications using serverless functions instead of traditional network APIs. That dramatically improves SaaS users' and developers' productivity.</p>
<h2 id="slack"><a class="header" href="#slack">Slack</a></h2>
<ul>
<li><a href="http://reactor.secondstate.info/en/docs/user_guideline.html">Build a serverless chatbot for Slack</a></li>
</ul>
<h2 id="lark"><a class="header" href="#lark">Lark</a></h2>
<p>It is also known as 飞书 aka the Chinese Slack. It is created by Byte Dance, the parent company of Tiktok.</p>
<ul>
<li><a href="http://reactor.secondstate.info/zh/docs/user_guideline.html">Build a serverless chatbot for Lark</a></li>
</ul>
<p>If you have any great ideas on WasmEdge, don't hesitate to open <a href="https://github.com/WasmEdge/WasmEdge/issues">a GitHub issue</a> to discuss together.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="features"><a class="header" href="#features">Features</a></h1>
<ul>
<li>One of the <a href="https://github.com/WasmEdge/WasmEdge#performance">fastest</a> WebAssembly VMs on the market (based on <strong>LLVM AOT</strong>)</li>
<li>WasmEdge feature extensions
<ul>
<li><strong>Network sockets</strong> (<a href="https://github.com/second-state/wasmedge_wasi_socket">Rust</a> and <a href="https://github.com/second-state/wasmedge-quickjs#http-request">JavaScript</a> SDKs)</li>
<li><strong>Async polling</strong> (for Rust Future and JS async)</li>
<li>Tensorflow inference (<a href="https://www.secondstate.io/articles/wasi-tensorflow/">Tutorial</a>)</li>
<li>Key value storage</li>
<li>Database connector</li>
<li><strong>Gas meters</strong> for resource constraints</li>
</ul>
</li>
<li>JavaScript support
<ul>
<li><a href="https://github.com/second-state/wasmedge-quickjs#es6-module-support">ES6 module</a> and std API support</li>
<li><strong>Implement JS APIs in Rust</strong> (<a href="https://www.secondstate.io/articles/embed-rust-in-javascript/">Tutorial</a>)</li>
<li>Import C native shared library functions as JS functions (<a href="https://www.secondstate.io/articles/call-native-functions-from-javascript/">Tutorial</a>)</li>
</ul>
</li>
<li>Cloud native management and orchestration
<ul>
<li><a href="https://www.secondstate.io/articles/manage-webassembly-apps-in-wasmedge-using-docker-tools/">CRI-O and Kubernetes compatibility</a></li>
<li>Sidecar apps in Kubernetes-based service meshes</li>
<li>Dapr microservices (<a href="https://www.secondstate.io/articles/dapr-wasmedge-webassembly/">Tutorial</a>)</li>
</ul>
</li>
<li>Cross-platform support
<ul>
<li>Linux OSes dated back to 2010 for both x86 and ARM CPUs</li>
<li>Mac OS X for both x86 and m1 CPUs</li>
<li>Windows</li>
<li>Microkernel and RTOS (e.g., the highly secure <a href="https://github.com/second-state/wasmedge-sel4">seL4 microkernel</a>)</li>
</ul>
</li>
<li>Easy extensibility
<ul>
<li>Build customized runtimes with native functions in <a href="https://github.com/WasmEdge/WasmEdge/blob/master/docs/c_api.md#Host-Functions">C</a> or <a href="https://github.com/second-state/WasmEdge-go-examples/tree/master/go_ExternRef">GO</a></li>
</ul>
</li>
<li>Easy to embed into a host application
<ul>
<li>Embed WasmEdge functions in <a href="https://github.com/WasmEdge/WasmEdge/blob/master/docs/c_api_quick_start.md">C</a>, <a href="https://www.secondstate.io/articles/extend-golang-app-with-webassembly-rust/">Go</a>, <a href="https://github.com/WasmEdge/WasmEdge/tree/master/bindings/rust">Rust</a>, <a href="https://www.secondstate.io/articles/getting-started-with-rust-function/">Node.js</a> and Python host applications</li>
<li>Embedded function runtime for service mesh proxies (e.g., <a href="https://github.com/proxy-wasm/proxy-wasm-cpp-host/pull/193">proxy-wasm</a> for Envoy and MOSN proxies)</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="webassembly-standard-extensions"><a class="header" href="#webassembly-standard-extensions">WebAssembly standard extensions</a></h1>
<p>WasmEdge supports optional WebAssembly features and proposals. Those proposals are likely to become official WebAssembly specifications in the future. WasmEdge supports the following proposals.</p>
<ul>
<li><a href="https://github.com/WebAssembly/WASI">WASI (WebAssembly Systems Interface) spec</a>. WasmEdge has supported the WASI spec for WebAssembly programs to interact with the host Linux operating system securely.</li>
<li><a href="https://webassembly.github.io/reference-types/core/">Reference Types</a>. It allows WebAssembly programs to exchange data with host applications and operating systems.</li>
<li><a href="https://github.com/WebAssembly/bulk-memory-operations/blob/master/proposals/bulk-memory-operations/Overview.md">Bulk memory operations</a>. The WebAssembly program sees faster memory access and performs better with bulk memory operations.</li>
<li><a href="https://github.com/second-state/SSVM/blob/master/docs/simd.md">SIMD (Single instruction, multiple data)</a>. For modern devices with multiple CPU cores, the SIMD allows data processing programs to take advantage of the CPUs fully. SIMD could significantly enhance the performance of data applications.</li>
</ul>
<p>Meanwhile, the WasmEdge team is exploring the wasi-socket proposal to support network access in WebAssembly programs. </p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="wasmedge-extensions"><a class="header" href="#wasmedge-extensions">WasmEdge extensions</a></h1>
<p>A key differentiator of WasmEdge from other WebAssembly VMs is its support for non-standard extensions. The WASI spec provides a mechanism for developers to extend WebAssembly VMs efficiently and securely. The WasmEdge team created the following WASI-like extensions based on real-world customer demands.</p>
<ul>
<li><a href="https://github.com/second-state/wasmedge-tensorflow">Tensorflow</a>. Developers can write Tensorflow inference functions using <a href="https://github.com/second-state/wasmedge_tensorflow_interface">a simple Rust API</a>, and then run the function securely and at native speed inside WasmEdge.</li>
<li>Other AI frameworks. Besides Tensorflow, the Second State team is building WASI-like extensions for AI frameworks such as ONNX and Tengine for WasmEdge.</li>
<li><a href="https://github.com/second-state/WasmEdge-image">Image processing</a>. WasmEdge uses native libraries to manipulate images for computer vision tasks.</li>
<li><a href="https://github.com/second-state/wasmedge-storage">KV Storage</a>. The WasmEdge <a href="https://github.com/second-state/rust_native_storage_library">storage interface</a> allows WebAssembly programs to read and write a key value store.</li>
<li><a href="https://github.com/second-state/wasmedge_wasi_socket">Network sockets</a>. WasmEdge applications can access the network sockets for <a href="https://github.com/second-state/wasmedge_wasi_socket/tree/main/examples">TCP and HTTP connections</a>.</li>
<li><a href="https://github.com/second-state/wasmedge_process_interface">Command interface</a>. WasmEdge enables webassembly functions execute native commands in the host operating system. It supports passing arguments, environment variables, STDIN / STDOUT pipes, and security policies for host access.</li>
<li><a href="https://github.com/second-state/wasmedge-evmc">Ethereum</a>. The WasmEdge Ewasm extension supports Ethereum smart contracts compiled to WebAssembly. It is a leading implementation for Ethereum flavored WebAssembly (Ewasm).</li>
<li><a href="https://github.com/second-state/substrate-ssvm-node">Substrate</a>. The <a href="https://github.com/second-state/pallet-ssvm">Pallet</a> allows WasmEdge to act as an Ethereum smart contract execution engine on any Substrate based blockchains.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="wasmedge-integrations"><a class="header" href="#wasmedge-integrations">WasmEdge integrations</a></h1>
<p>WasmEdge is a &quot;serverless&quot; runtime for cloud native and edge computing applications. It allows developers safely embed third-party or &quot;native&quot; functions into a host application or a distributed computing framework.</p>
<h1 id="embed-wasmedge-into-a-host-application"><a class="header" href="#embed-wasmedge-into-a-host-application">Embed WasmEdge into a host application</a></h1>
<p>A major use case of WasmEdge is to start an VM instance from a host application. Depending on your host application's programming language, you can use WasmEdge SDKs to start and call WasmEdge functions.</p>
<ul>
<li>Embed WasmEdge functions into a C-based application using the <a href="intro/c_api.html">WasmEdge C API</a>. Checkout the <a href="intro/c_api_quick_start.html">quick start guide</a>.</li>
<li>Embed WasmEdge functions into a Go application using the <a href="https://github.com/second-state/WasmEdge-go">WasmEdge Go API</a>. Here is a <a href="https://www.secondstate.io/articles/extend-golang-app-with-webassembly-rust/">tutorial</a> and are some <a href="https://github.com/second-state/WasmEdge-go-examples">examples</a>!</li>
<li>Embed WasmEdge functions into a Rust application using the <a href="intro/../bindings/rust/wasmedge-rs">WasmEdge Rust crate</a>.</li>
<li>Embed WasmEdge functions into a Node.js application using the NAPI. Here is a <a href="https://www.secondstate.io/articles/getting-started-with-rust-function/">tutorial</a>.</li>
<li>Embed WasmEdge functions into any application by spawning a new process. See examples for <a href="https://www.secondstate.io/articles/vercel-wasmedge-webassembly-rust/">Vercel Serverless Functions</a> and <a href="https://www.cncf.io/blog/2021/08/25/webassembly-serverless-functions-in-aws-lambda/">AWS Lambda</a>.</li>
</ul>
<p>However, the WebAssembly spec only supports very limited data types as input parameters and return values for the WebAssembly bytecode functions. In order to pass complex data types, such as a string of an array, as call arguments into Rust-based WasmEdge function, you should use the bindgen solution provided by the <a href="https://github.com/second-state/rustwasmc">rustwasmc</a> toolchain. We currently supports bindgen in the <a href="https://www.secondstate.io/articles/getting-started-with-rust-function/">Node.js</a> and in <a href="https://www.secondstate.io/articles/extend-golang-app-with-webassembly-rust/">Go</a>. We are working on <a href="https://github.com/WasmEdge/WasmEdge/issues/264">supporting interface types</a> in place of bindgen for future releases.</p>
<h1 id="use-wasmedge-as-a-docker-like-container"><a class="header" href="#use-wasmedge-as-a-docker-like-container">Use WasmEdge as a Docker-like container</a></h1>
<p>WasmEdge provides an OCI compliant interface. You can use container tools, such as CRI-O, Docker Hub, and Kubernetes, to orchestrate and manage WasmEdge runtimes.</p>
<ul>
<li><a href="https://www.secondstate.io/articles/manage-webassembly-apps-in-wasmedge-using-docker-tools/">Manage WasmEdge with CRI-O and Docker Hub</a>.</li>
</ul>
<h1 id="call-native-host-functions-from-wasmedge"><a class="header" href="#call-native-host-functions-from-wasmedge">Call native host functions from WasmEdge</a></h1>
<p>A key feature of WasmEdge is its extensibility. WasmEdge APIs allow developers to register &quot;host functions&quot; from any shared library into a WasmEdge instance, and then call these functions from the WebAssembly bytecode program. </p>
<ul>
<li>The WasmEdge C API supports a <a href="https://github.com/WasmEdge/WasmEdge/blob/master/docs/c_api.md#Host-Functions">host function API</a>.</li>
<li>The WasmEdge Go API supports <a href="https://github.com/second-state/WasmEdge-go-examples/tree/master/go_ExternRef">external functions</a>.</li>
</ul>
<p><a href="https://www.secondstate.io/articles/call-native-functions-from-javascript/">Here is an example</a> of a JavaScript program in WasmEdge calling a C-based host function in the underlying OS.</p>
<p>The host functions break the Wasm sandbox to access the underly OS or hardware. But the sandbox breaking is done with explicit permission from the system’s operator.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="faq-abut-webassembly-and-wasmedge"><a class="header" href="#faq-abut-webassembly-and-wasmedge">FAQ abut WebAssembly and WasmEdge</a></h1>
<p><strong>Q: What's the relationship between WebAssembly and Docker?</strong></p>
<p>A: Check out our infographic <a href="https://wasmedge.org/wasm_docker/">WebAssembly vs. Docker</a>. WebAssembly runs side by side with Docker in cloud native and edge native applications.</p>
<p><strong>Q: What's the difference for Native clients (NaCl), Application runtimes, and WebAssembly?</strong></p>
<p>A: We created a handy table for comparison.</p>
<table><thead><tr><th></th><th>NaCl</th><th>Application runtimes (eg Node &amp; Python)</th><th>Docker-like container</th><th>WebAssembly</th></tr></thead><tbody>
<tr><td>Performance</td><td>Great</td><td>Poor</td><td>OK</td><td>Great</td></tr>
<tr><td>Resource footprint</td><td>Great</td><td>Poor</td><td>Poor</td><td>Great</td></tr>
<tr><td>Isolation</td><td>Poor</td><td>OK</td><td>OK</td><td>Great</td></tr>
<tr><td>Safety</td><td>Poor</td><td>OK</td><td>OK</td><td>Great</td></tr>
<tr><td>Portability</td><td>Poor</td><td>Great</td><td>OK</td><td>Great</td></tr>
<tr><td>Security</td><td>Poor</td><td>OK</td><td>OK</td><td>Great</td></tr>
<tr><td>Language and framework choice</td><td>N/A</td><td>N/A</td><td>Great</td><td>OK</td></tr>
<tr><td>Ease of use</td><td>OK</td><td>Great</td><td>Great</td><td>OK</td></tr>
<tr><td>Manageability</td><td>Poor</td><td>Poor</td><td>Great</td><td>Great</td></tr>
</tbody></table>
<p><strong>Q: What's the difference between WebAssembly and eBPF</strong></p>
<p>A: eBPF is the bytecode format for a Linux kernel space VM that is suitable for network or security related tasks. WebAssembly is the bytecode format for a user space VM that is suited for business applications. <a href="https://medium.com/codex/ebpf-and-webassembly-whose-vm-reigns-supreme-c2861ce08f89">See details here</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="develop-a-wasmedge-app"><a class="header" href="#develop-a-wasmedge-app">Develop a WasmEdge app</a></h1>
<p>A key value proposition of WebAssembly is that it supports multiple 
programming languages. WebAssembly is a &quot;managed runtime&quot; for many 
programming languages including C/C++, Rust, Go, Swift, Kotlin, AssemblyScript, Grain
and even JavaScript and Python.</p>
<ul>
<li>For compiled languages (e.g., C and Rust), WasmEdge WebAssembly provides a safe, secure, isolated, and containerized runtime as opposed to Native Client (NaCl).</li>
<li>For interpreted or managed languages (e.g., JavaScript and Python), WasmEdge WebAssembly provides a secure, fast, lightweight, and containerized runtime as opposed to Docker + guest OS + native interpreter.</li>
</ul>
<p>In this chapter, we will discuss how to compile and run programs in different languages in WasmEdge.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rust"><a class="header" href="#rust">Rust</a></h1>
<p>Rust is one of the &quot;first-class citizen&quot; programming languages in the WebAssembly ecosystem. All WasmEdge extensions to WebAssembly also come with Rust APIs
for developers.
In this chapter, we will show you how to compile your Rust applications to wasm bytecode and to run in the WasmEdge runtime.</p>
<h2 id="prerequisites"><a class="header" href="#prerequisites">Prerequisites</a></h2>
<p>You need to install <a href="https://www.rust-lang.org/tools/install">Rust</a> and <a href="dev/../start/install.html">WasmEdge</a> in order to get started.
You should also install the <code>wasm32-wasi</code> target to the Rust toolchain.</p>
<pre><code class="language-bash">rustup target add wasm32-wasi
</code></pre>
<h2 id="hello-world-1"><a class="header" href="#hello-world-1">Hello world</a></h2>
<p>The Hello world example is a standalone Rust application that can be executed
by the <a href="dev/../start/cli.html">WasmEdge CLI</a>. Its <a href="https://github.com/second-state/wasm-learning/tree/master/cli/hello">source code is available</a>.</p>
<p>The full source code for the Rust <a href="https://github.com/second-state/wasm-learning/blob/master/cli/hello/src/main.rs">main.rs</a> file is as follows.
It echoes the command line arguments passed to this program at runtime.</p>
<pre><pre class="playground"><code class="language-rust">use std::env;

fn main() {
  println!(&quot;hello&quot;);
  for argument in env::args().skip(1) {
    println!(&quot;{}&quot;, argument);
  }
}
</code></pre></pre>
<h3 id="build-the-wasm-bytecode"><a class="header" href="#build-the-wasm-bytecode">Build the WASM bytecode</a></h3>
<pre><code class="language-bash">$ cargo build --target wasm32-wasi
</code></pre>
<h3 id="run-the-application-from-command-line"><a class="header" href="#run-the-application-from-command-line">Run the application from command line</a></h3>
<p>We will use the <code>wasmedge</code> command to run the program.</p>
<pre><code class="language-bash">$ wasmedge target/wasm32-wasi/debug/hello.wasm second state
hello
second
state
</code></pre>
<h2 id="a-simple-function"><a class="header" href="#a-simple-function">A simple function</a></h2>
<p>The <a href="https://github.com/second-state/wasm-learning/tree/master/cli/add">add example</a> is a Rust library function that can be executed
by the <a href="dev/../start/cli.html">WasmEdge CLI</a> in the reactor mode.</p>
<p>The full source code for the Rust <a href="https://github.com/second-state/wasm-learning/blob/master/cli/add/src/lib.rs">lib.rs</a> file is as follows.
It provides a simple <code>add()</code> function.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[no_mangle]
pub fn add(a: i32, b: i32) -&gt; i32 {
  return a + b;
}
<span class="boring">}
</span></code></pre></pre>
<h3 id="build-the-wasm-bytecode-1"><a class="header" href="#build-the-wasm-bytecode-1">Build the WASM bytecode</a></h3>
<pre><code class="language-bash">$ cargo build --target wasm32-wasi
</code></pre>
<h3 id="run-the-application-from-command-line-1"><a class="header" href="#run-the-application-from-command-line-1">Run the application from command line</a></h3>
<p>We will use <code>wasmedge</code> in reactor mode to run the program. We pass the function name and its input parameters as command line arguments.</p>
<pre><code class="language-bash">$ wasmedge --reactor target/wasm32-wasi/debug/add.wasm add 2 2
4
</code></pre>
<h3 id="pass-complex-call-parameters"><a class="header" href="#pass-complex-call-parameters">Pass complex call parameters</a></h3>
<p>Of course, in most cases, you will not call functions using CLI arguments.
Instead, you will probably need to use a <a href="dev/../../embed.html">language SDK from WasmEdge</a>
to call the function, pass call parameters, and receive return values.
Below are some SDK examples for complex call parameters and return values.</p>
<ul>
<li><a href="dev/../embed/node.html#more-examples">Use wasm-bindgen in a Node.js host app</a></li>
<li><a href="dev/../embed/go/bindgen.html">Use wasm-bindgen in a Go host app</a></li>
<li><a href="dev/">Use direct memory passing in a Go host app</a></li>
</ul>
<h2 id="improve-performance"><a class="header" href="#improve-performance">Improve performance</a></h2>
<p>To achieve native Rust performance for those applications, you
could use the <code>wasmedgec</code> command to AOT compile the <code>wasm</code> program,
and then run it with the <code>wasmedge</code> command.</p>
<pre><code class="language-bash">$ wasmedgec hello.wasm hello.wasm

$ wasmedge hello.wasm second state
hello
second
state
</code></pre>
<p>For the <code>--reactor</code> mode,</p>
<pre><code class="language-bash">$ wasmedgec add.wasm add.wasm

$ wasmedge --reactor add.wasm add 2 2
4
</code></pre>
<h2 id="further-readings"><a class="header" href="#further-readings">Further readings</a></h2>
<ul>
<li><a href="dev/rust/wasi.html">Access OS services via WASI</a> shows how the WebAssembly program can access the underlying OS services, such as file system and environment variables.</li>
<li><a href="dev/rust/tensorflow.html">Tensorflow</a> shows how to create Tensorflow-based AI inference applications for WebAssembly using the WasmEdge TensorFlow Rust SDK.</li>
<li><a href="dev/rust/networking.html">Networking socket</a> shows how to create networking applications for WebAssembly using the WasmEdge networking socket Rust SDK.</li>
<li><a href="dev/rust/command.html">Command interface</a> shows how to create native command applications for WebAssembly using the Wasmedge command interface Rust SDK.</li>
<li><a href="dev/rust/bindgen.html">Bindgen and rustwasmc</a> shows how to use the <code>rustwasmc</code> toolchain to compile Rust functions into WebAssembly, and then pass complex call parameters to the function from an external host application.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="access-os-services"><a class="header" href="#access-os-services">Access OS services</a></h1>
<p>The WASI (WebAssembly Systems Interface) standard is designed to allow
WebAssembly applications to access operating system services.
The <code>wasm32-wasi</code> target in the Rust compiler supports WASI. In this section,
we will use <a href="https://github.com/second-state/wasm-learning/tree/master/cli/wasi">an example project</a> to show how to use Rust standard APIs to access operating system services.</p>
<h2 id="random-numbers"><a class="header" href="#random-numbers">Random numbers</a></h2>
<p>The WebAssembly VM is a pure software construct. It does not have a hardware entropy source for random numbers. That's why WASI defines a function for WebAssembly programs to call its host operating system to get a random seed. As a Rust developer, all you need is to use the popular (de facto standard) <code>rand</code> and/or <code>getrandom</code> crates. With the <code>wasm32-wasi</code> compiler backend, these crates generate the correct WASI calls in the WebAssembly bytecode. The <code>Cargo.toml</code> dependencies are as follows.</p>
<pre><code>[dependencies]
rand = &quot;0.7.3&quot;
getrandom = &quot;0.1.14&quot;
</code></pre>
<p>The Rust code to get random number from WebAssembly is this.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use rand::prelude::*;

pub fn get_random_i32() -&gt; i32 {
  let x: i32 = random();
  return x;
}

pub fn get_random_bytes() -&gt; Vec&lt;u8&gt; {
  let mut rng = thread_rng();
  let mut arr = [0u8; 128];
  rng.fill(&amp;mut arr[..]);
  return arr.to_vec();
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="printing-and-debugging-from-rust"><a class="header" href="#printing-and-debugging-from-rust">Printing and debugging from Rust</a></h2>
<p>The Rust <code>println!</code> marco just works in WASI. The statements print to the <code>STDOUT</code> of the process that runs the WasmEdge. </p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn echo(content: &amp;str) -&gt; String {
  println!(&quot;Printed from wasi: {}&quot;, content);
  return content.to_string();
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="arguments-and-environment-variables"><a class="header" href="#arguments-and-environment-variables">Arguments and environment variables</a></h2>
<p>It is possible to pass CLI arguments to and access OS environment variables in a WasmEdge application.
They are just <code>env::args()</code> and <code>env::vars()</code> arrays in Rust.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::env;

pub fn print_env() {
  println!(&quot;The env vars are as follows.&quot;);
  for (key, value) in env::vars() {
    println!(&quot;{}: {}&quot;, key, value);
  }

  println!(&quot;The args are as follows.&quot;);
  for argument in env::args() {
    println!(&quot;{}&quot;, argument);
  }
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="reading-and-writing-files"><a class="header" href="#reading-and-writing-files">Reading and writing files</a></h2>
<p>WASI allows your Rust functions to access the host computer's file system through the standard Rust <code>std::fs</code> API. 
In the Rust program, you operate on files through a relative path. The relative
path's root is specified when you start the WasmEdge runtime.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fs;
use std::fs::File;
use std::io::{Write, Read};

pub fn create_file(path: &amp;str, content: &amp;str) {
  let mut output = File::create(path).unwrap();
  output.write_all(content.as_bytes()).unwrap();
}

pub fn read_file(path: &amp;str) -&gt; String {
  let mut f = File::open(path).unwrap();
  let mut s = String::new();
  match f.read_to_string(&amp;mut s) {
    Ok(_) =&gt; s,
    Err(e) =&gt; e.to_string(),
  }
}

pub fn del_file(path: &amp;str) {
  fs::remove_file(path).expect(&quot;Unable to delete&quot;);
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="a-main-app"><a class="header" href="#a-main-app">A main() app</a></h2>
<p>With a <code>main()</code> function, the Rust program can be compiled into a 
standalone WebAssembly program.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
  println!(&quot;Random number: {}&quot;, get_random_i32());
  println!(&quot;Random bytes: {:?}&quot;, get_random_bytes());
  println!(&quot;{}&quot;, echo(&quot;This is from a main function&quot;));
  print_env();
  create_file(&quot;tmp.txt&quot;, &quot;This is in a file&quot;);
  println!(&quot;File content is {}&quot;, read_file(&quot;tmp.txt&quot;));
  del_file(&quot;tmp.txt&quot;);
}
</code></pre></pre>
<p>Use the command below to compile <a href="https://github.com/second-state/wasm-learning/tree/master/cli/wasi">the Rust project</a>.</p>
<pre><code class="language-bash">$ cargo build --target wasm32-wasi
</code></pre>
<p>To run it in <code>wasmedge</code>, do the following. The <code>--dir</code> option maps the current
directory of the command shell to the file system current directory inside
the WebAssembly app.</p>
<pre><code class="language-bash">$ wasmedge --dir .:. target/wasm32-wasi/debug/wasi.wasm hello
Random number: -68634548
Random bytes: [87, 117, 194, 122, 74, 189, 29, 1, 113, 26, 90, 6, 151, 20, 11, 169, 131, 212, 161, 220, 216, 190, 77, 234, 30, 10, 159, 7, 14, 89, 81, 111, 247, 136, 39, 195, 83, 90, 153, 225, 66, 16, 150, 217, 137, 172, 216, 203, 251, 37, 4, 27, 32, 57, 76, 237, 99, 147, 24, 175, 208, 157, 3, 220, 46, 224, 199, 153, 144, 96, 120, 89, 160, 38, 171, 239, 87, 218, 41, 184, 220, 78, 157, 57, 229, 198, 222, 72, 219, 118, 237, 27, 229, 28, 51, 116, 88, 101, 40, 139, 160, 51, 156, 102, 66, 233, 101, 50, 131, 9, 253, 186, 73, 148, 85, 36, 155, 254, 168, 202, 23, 96, 181, 99, 120, 136, 28, 147]
This is from a main function
The env vars are as follows.
... ...
The args are as follows.
target/wasm32-wasi/debug/wasi.wasm
hello
File content is This is in a file
</code></pre>
<h2 id="functions"><a class="header" href="#functions">Functions</a></h2>
<p>As <a href="dev/rust/../rust.html#a-simple-function">we have seen</a>, you can create WebAssembly functions
in a Rust <code>lib.rs</code> project. You can also use WASI functions in those functions.
However, an important caveat is that, without a <code>main()</code> function, you
will need to explicitly call a helper function to initialize
environment for WASI functions to work properly.
In the Rust program, add a helper crate in Cargo.toml so that the WASI initialization code can be applied to your exported public library functions.</p>
<pre><code>[dependencies]
... ...
wasmedge-wasi-helper = &quot;=0.2.0&quot;
</code></pre>
<p>In the Rust function, we need to call <code>_initialize()</code> before we access any arguments and environment variables or operate any files.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn print_env() -&gt; i32 {
  _initialize();
  ... ...
}

pub fn create_file(path: &amp;str, content: &amp;str) -&gt; String {
  _initialize();
  ... ...
}

pub fn read_file(path: &amp;str) -&gt; String {
  _initialize();
  ... ...
}

pub fn del_file(path: &amp;str) -&gt; String {
  _initialize();
  ... ...
}
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tensorflow"><a class="header" href="#tensorflow">Tensorflow</a></h1>
<p>AI inference is a computationally intensive task that could benefit greatly from the speed of Rust and WebAssembly. However, the standard WebAssembly sandbox provides very limited access to the native OS and hardware, such as multi-core CPUs, GPU and specialized AI inference chips. It is not ideal for the AI workload.</p>
<p>The popular WebAssembly System Interface (WASI) provides a design pattern for sandboxed WebAssembly programs to securely access native host functions. The WasmEdge Runtime extends the WASI model to support access to native Tensorflow libraries from WebAssembly programs. The <a href="https://github.com/second-state/wasmedge_tensorflow_interface">WasmEdge Tensorflow Rust SDK</a> provides the security, portability, and ease-of-use of WebAssembly and native speed for Tensorflow.</p>
<blockquote>
<p>If you are not familiar with Rust, you can try our <a href="https://github.com/second-state/wasm-learning/tree/master/cli/classify_yml">experimental AI inference DSL</a> or try our <a href="dev/rust/../js/tensorflow.html">JavaScript examples</a>.</p>
</blockquote>
<h2 id="table-of-contents"><a class="header" href="#table-of-contents">Table of contents</a></h2>
<ul>
<li><a href="dev/rust/tensorflow.html#a-rust-example">A Rust example</a></li>
<li><a href="dev/rust/tensorflow.html#deployment-options">Deployment options</a></li>
</ul>
<h1 id="a-rust-example"><a class="header" href="#a-rust-example">A Rust example</a></h1>
<h3 id="prerequisite"><a class="header" href="#prerequisite">Prerequisite</a></h3>
<p>You need to install <a href="https://github.com/WasmEdge/WasmEdge/blob/master/docs/install.md">WasmEdge</a> and <a href="https://www.rust-lang.org/tools/install">Rust</a>.</p>
<h3 id="build"><a class="header" href="#build">Build</a></h3>
<p>Check out the example source code.</p>
<pre><code class="language-bash">$ git clone https://github.com/second-state/wasm-learning/
$ cd cli/tflite
</code></pre>
<p>Use Rust <code>Cargo</code> to build the WebAssembly target.</p>
<pre><code class="language-bash">$ rustup target add wasm32-wasi
$ cargo build --target wasm32-wasi --release
</code></pre>
<h3 id="run"><a class="header" href="#run">Run</a></h3>
<p>The <code>wasmedge-tensorflow-lite</code> utility is the WasmEdge build that includes the Tensorflow and Tensorflow Lite extensions.</p>
<pre><code class="language-bash">$ wasmedge-tensorflow-lite target/wasm32-wasi/release/classify.wasm &lt; grace_hopper.jpg
It is very likely a &lt;a href='https://www.google.com/search?q=military uniform'&gt;military uniform&lt;/a&gt; in the picture
</code></pre>
<h3 id="make-it-run-faster"><a class="header" href="#make-it-run-faster">Make it run faster</a></h3>
<p>To make Tensorflow inference run <em>much</em> faster, you could AOT compile it down to machine native code, and then use WasmEdge sandbox to run the native code.</p>
<pre><code class="language-bash">$ wasmedgec target/wasm32-wasi/release/classify.wasm classify.wasm
$ wasmedge-tensorflow-lite classify.wasm &lt; grace_hopper.jpg
It is very likely a &lt;a href='https://www.google.com/search?q=military uniform'&gt;military uniform&lt;/a&gt; in the picture
</code></pre>
<h3 id="code-walkthrough"><a class="header" href="#code-walkthrough">Code walkthrough</a></h3>
<p>It is fairly straightforward to use the WasmEdge Tensorflow API. You can see the entire source code in <a href="https://github.com/second-state/wasm-learning/blob/master/cli/tflite/src/main.rs">main.rs</a>.</p>
<p>First, it reads the trained TFLite model file (ImageNet) and its label file. The label file maps numeric output from the model to English names for the classified objects.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let model_data: &amp;[u8] = include_bytes!(&quot;models/mobilenet_v1_1.0_224/mobilenet_v1_1.0_224_quant.tflite&quot;);
    let labels = include_str!(&quot;models/mobilenet_v1_1.0_224/labels_mobilenet_quant_v1_224.txt&quot;);
<span class="boring">}
</span></code></pre></pre>
<p>Next, it reads the image from <code>STDIN</code> and converts it to the size and RGB pixel arrangement required by the Tensorflow Lite model.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let mut buf = Vec::new();
    io::stdin().read_to_end(&amp;mut buf).unwrap();

    let flat_img = wasmedge_tensorflow_interface::load_jpg_image_to_rgb8(&amp;buf, 224, 224);
<span class="boring">}
</span></code></pre></pre>
<p>Then, the program runs the TFLite model with its required input tensor (i.e., the flat image in this case), and receives the model output. In this case, the model output is an array of numbers. Each number corresponds to the probability of an object name in the label text file.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let mut session = wasmedge_tensorflow_interface::Session::new(&amp;model_data, wasmedge_tensorflow_interface::ModelType::TensorFlowLite);
    session.add_input(&quot;input&quot;, &amp;flat_img, &amp;[1, 224, 224, 3])
           .run();
    let res_vec: Vec&lt;u8&gt; = session.get_output(&quot;MobilenetV1/Predictions/Reshape_1&quot;);
<span class="boring">}
</span></code></pre></pre>
<p>Let's find the object with the highest probability, and then look up the name in the labels file.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let mut i = 0;
    let mut max_index: i32 = -1;
    let mut max_value: u8 = 0;
    while i &lt; res_vec.len() {
        let cur = res_vec[i];
        if cur &gt; max_value {
            max_value = cur;
            max_index = i as i32;
        }
        i += 1;
    }

    let mut label_lines = labels.lines();
    for _i in 0..max_index {
      label_lines.next();
    }

<span class="boring">}
</span></code></pre></pre>
<p>Finally, it prints the result to <code>STDOUT</code>.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let class_name = label_lines.next().unwrap().to_string();
    if max_value &gt; 50 {
      println!(&quot;It {} a &lt;a href='https://www.google.com/search?q={}'&gt;{}&lt;/a&gt; in the picture&quot;, confidence.to_string(), class_name, class_name);
    } else {
      println!(&quot;It does not appears to be any food item in the picture.&quot;);
    }
<span class="boring">}
</span></code></pre></pre>
<h1 id="deployment-options"><a class="header" href="#deployment-options">Deployment options</a></h1>
<p>All the tutorials below use the <a href="https://github.com/second-state/wasmedge_tensorflow_interface">WasmEdge Rust API for Tensorflow</a> to create AI inference functions. Those Rust functions are then compiled to WebAssembly and deployed together with WasmEdge on the cloud. </p>
<h3 id="serverless-functions"><a class="header" href="#serverless-functions">Serverless functions</a></h3>
<p>The following tutorials showcase how to deploy WebAssembly programs (written in Rust) on public cloud serverless platforms. The WasmEdge Runtime runs inside a Docker container on those platforms. Each serverless platform provides APIs to get data into and out of the WasmEdge runtime through STDIN and STDOUT.</p>
<ul>
<li><a href="https://www.secondstate.io/articles/vercel-wasmedge-webassembly-rust/">Vercel Serverless Functions</a></li>
<li><a href="https://www.secondstate.io/articles/netlify-wasmedge-webassembly-rust-serverless/">Netlify Functions</a></li>
<li><a href="https://github.com/second-state/aws-lambda-wasm-runtime">AWS Lambda</a></li>
<li><a href="https://github.com/second-state/tencent-scf-wasm-runtime">Tencent Serverless Functions</a> (in Chinese)</li>
</ul>
<h3 id="second-sate-faas-and-nodejs"><a class="header" href="#second-sate-faas-and-nodejs">Second Sate FaaS and Node.js</a></h3>
<p>The following tutorials showcase how to deploy WebAssembly functions (written in Rust) on the Second State FaaS. Since the FaaS service is running on Node.js, you can follow the same tutorials for running those functions in your own Node.js server.</p>
<ul>
<li><a href="https://www.secondstate.io/articles/faas-image-classification/">Tensorflow: Image classification using the MobileNet models</a> | <a href="https://second-state.github.io/wasm-learning/faas/mobilenet/html/index.html">Live demo</a></li>
<li><a href="https://www.secondstate.io/articles/faas-face-detection/">Tensorflow: Face detection using the MTCNN models</a> | <a href="https://second-state.github.io/wasm-learning/faas/mtcnn/html/index.html">Live demo</a></li>
</ul>
<h3 id="service-mesh"><a class="header" href="#service-mesh">Service mesh</a></h3>
<p>The following tutorials showcase how to deploy WebAssembly functions and programs (written in Rust) as sidecar microservices. </p>
<ul>
<li><a href="https://github.com/second-state/dapr-wasm">The Dapr template</a> shows how to build and deploy Dapr sidecars in Go and Rust languages. The sidecars then use the WasmEdge SDK to start WebAssembly programs to process workloads to the microservices.</li>
</ul>
<h3 id="data-streaming-framework"><a class="header" href="#data-streaming-framework">Data streaming framework</a></h3>
<p>The following tutorials showcase how to deploy WebAssembly functions (written in Rust) as embedded handler functions in data streaming frameworks for AIoT.</p>
<ul>
<li><a href="https://www.secondstate.io/articles/yomo-wasmedge-real-time-data-streams/">The YoMo template</a> starts the WasmEdge Runtime to process image data as the data streams in from a camera in a smart factory.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="networking-sockets"><a class="header" href="#networking-sockets">Networking sockets</a></h1>
<p>The <a href="https://github.com/second-state/wasmedge_wasi_socket">wasmedge_wasi_socket</a>
crate enables Rust developers to create networking applications
and compile them into WebAssembly for WasmEdge Runtime.</p>
<h2 id="the-http-client-example"><a class="header" href="#the-http-client-example">The HTTP client example</a></h2>
<p>The <a href="https://github.com/second-state/wasmedge_wasi_socket/tree/main/examples/http_client">source code</a> for the HTTP client is available as follows.</p>
<pre><pre class="playground"><code class="language-rust">use wasmedge_http_req::request;

fn main() {
    let mut writer = Vec::new(); //container for body of a response
    let res = request::get(&quot;http://127.0.0.1:1234/get&quot;, &amp;mut writer).unwrap();

    println!(&quot;GET&quot;);
    println!(&quot;Status: {} {}&quot;, res.status_code(), res.reason());
    println!(&quot;Headers {}&quot;, res.headers());
    println!(&quot;{}&quot;, String::from_utf8_lossy(&amp;writer));

    let mut writer = Vec::new(); //container for body of a response
    const BODY: &amp;[u8; 27] = b&quot;field1=value1&amp;field2=value2&quot;;
    // let res = request::post(&quot;https://httpbin.org/post&quot;, BODY, &amp;mut writer).unwrap();
    // no https , no dns
    let res = request::post(&quot;http://127.0.0.1:1234/post&quot;, BODY, &amp;mut writer).unwrap();

    println!(&quot;POST&quot;);
    println!(&quot;Status: {} {}&quot;, res.status_code(), res.reason());
    println!(&quot;Headers {}&quot;, res.headers());
    println!(&quot;{}&quot;, String::from_utf8_lossy(&amp;writer));
}
</code></pre></pre>
<p>To compile this source code, you must have the following in your <code>Cargo.toml</code>.</p>
<pre><code>[dependencies]
wasmedge_http_req  = &quot;0.8.1&quot;
</code></pre>
<p>The following command compiles the Rust program.</p>
<pre><code class="language-bash">cargo build --target wasm32-wasi --release
</code></pre>
<p>The following command runs the application in WasmEdge.</p>
<pre><code class="language-bash">wasmedge target/wasm32-wasi/release/http_client.wasm
</code></pre>
<h2 id="the-http-server-example"><a class="header" href="#the-http-server-example">The HTTP server example</a></h2>
<p>The <a href="https://github.com/second-state/wasmedge_wasi_socket/tree/main/examples/http_server">source code</a> for the HTTP server application is available as follows.</p>
<pre><pre class="playground"><code class="language-rust">use bytecodec::DecodeExt;
use httpcodec::{HttpVersion, ReasonPhrase, Request, RequestDecoder, Response, StatusCode};
use std::io::{Read, Write};
#[cfg(feature = &quot;std&quot;)]
use std::net::{Shutdown, TcpListener, TcpStream};
#[cfg(not(feature = &quot;std&quot;))]
use wasmedge_wasi_socket::{Shutdown, TcpListener, TcpStream};

fn handle_http(req: Request&lt;String&gt;) -&gt; bytecodec::Result&lt;Response&lt;String&gt;&gt; {
    Ok(Response::new(
        HttpVersion::V1_0,
        StatusCode::new(200)?,
        ReasonPhrase::new(&quot;&quot;)?,
        format!(&quot;echo: {}&quot;, req.body()),
    ))
}

fn handle_client(mut stream: TcpStream) -&gt; std::io::Result&lt;()&gt; {
    let mut buff = [0u8; 1024];
    let mut data = Vec::new();

    loop {
        let n = stream.read(&amp;mut buff)?;
        data.extend_from_slice(&amp;buff[0..n]);
        if n &lt; 1024 {
            break;
        }
    }

    let mut decoder =
        RequestDecoder::&lt;httpcodec::BodyDecoder&lt;bytecodec::bytes::Utf8Decoder&gt;&gt;::default();

    let req = match decoder.decode_from_bytes(data.as_slice()) {
        Ok(req) =&gt; handle_http(req),
        Err(e) =&gt; Err(e),
    };

    let r = match req {
        Ok(r) =&gt; r,
        Err(e) =&gt; {
            let err = format!(&quot;{:?}&quot;, e);
            Response::new(
                HttpVersion::V1_0,
                StatusCode::new(500).unwrap(),
                ReasonPhrase::new(err.as_str()).unwrap(),
                err.clone(),
            )
        }
    };

    let write_buf = r.to_string();
    stream.write(write_buf.as_bytes())?;
    stream.shutdown(Shutdown::Both)?;
    Ok(())
}

fn main() -&gt; std::io::Result&lt;()&gt; {
    let port = std::env::var(&quot;PORT&quot;).unwrap_or(1234.to_string());
    println!(&quot;new connection at {}&quot;, port);
    let listener = TcpListener::bind(format!(&quot;0.0.0.0:{}&quot;, port))?;
    loop {
        let _ = handle_client(listener.accept()?.0);
    }
}
</code></pre></pre>
<p>To compile this source code, you must have the following in your <code>Cargo.toml</code>.</p>
<pre><code>[dependencies]
wasmedge_http_req  = &quot;0.8.1&quot;
</code></pre>
<p>The following command compiles the Rust program.</p>
<pre><code class="language-bash">cargo build --target wasm32-wasi --release
</code></pre>
<p>The following command runs the application in WasmEdge.</p>
<pre><code class="language-bash">wasmedge target/wasm32-wasi/release/http_server.wasm
new connection at 1234
</code></pre>
<p>To test the HTTP server, you can submit a HTTP request to it via <code>curl</code>.</p>
<pre><code class="language-bash">curl -d &quot;name=WasmEdge&quot; -X POST http://127.0.0.1:1234
echo: name=WasmEdge
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="command-interface"><a class="header" href="#command-interface">Command interface</a></h1>
<p>WASI enables WebAssembly programs to call standard library functions in the host operating system. It does so through a fine-grained security model known as “capability-based security”. The WebAssembly VM owner can grant access to host system resources when the VM starts up. The program cannot access any resources (e.g., file folders) that are not explicitly allowed.</p>
<p>Now, why limit ourselves to standard library functions? The same approach can be used to call just any host functions from WebAssembly. The Second State WebAssembly VM provides a WASI-like extension to access any command line programs in the host operating system.</p>
<p>The command line program can</p>
<ul>
<li>Take input via command line arguments, as well as the <code>STDIN</code> stream.</li>
<li>Return value and data via the <code>STDOUT</code> stream.</li>
</ul>
<p>Application developers for WasmEdge can use our Rust interface crate to access this functionality. In <code>Cargo.toml</code>, make sure that you have this dependency.</p>
<pre><code>[dependencies]
rust_process_interface_library = &quot;0.1.3&quot;
</code></pre>
<p>In the Rust application, you can now use the API methods to start a new process for the operating system command program, pass in arguments via the <code>arg()</code> method as well as via the <code>STDIN</code>, and receives the return values via the <code>STDOUT</code>.</p>
<pre><code>let mut cmd = Command::new(&quot;http_proxy&quot;);

cmd.arg(&quot;post&quot;)
   .arg(&quot;https://api.sendgrid.com/v3/mail/send&quot;)
   .arg(auth_header);  
cmd.stdin_u8vec(payload.to_string().as_bytes());

let out = cmd.output();
</code></pre>
<p>The Rust function is then compiled into WebAssembly and can run in the WasmEdge.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bindgen-and-rustwasmc"><a class="header" href="#bindgen-and-rustwasmc">Bindgen and rustwasmc</a></h1>
<p>The <a href="https://github.com/second-state/rustwasmc">rustwasmc</a> tool is inspired by the wasm-pack project but is optimized for edge cloud and device applications. Specifically, it supports the <a href="https://github.com/WasmEdge/WasmEdge">WasmEdge</a> WebAssembly runtime.</p>
<p>One of the key features of <code>rustwasmc</code> over the standard <code>wasm32-wasi</code> compiler target is that <code>rustwasmc</code> processes compiled Rust functions using the <code>wasm-bindgen</code> tool.
By default, WebAssembly functions only support a few simple data types as
input call arguments. Tools like <code>wasm-bindgen</code> turn WebAssembly function
arguments into memory pointers, and allow host applications to
pass complex arguments, such as strings and arrays, to WebAssembly functions.
WasmEdge's <a href="dev/rust/../../embed/node.html">Node.js SDK</a> and <a href="dev/rust/../../embed/go.html">Go SDK</a> both support <code>wasm-bindgen</code>, allowing JavaScript and Go programs to call WebAssembly function with complex call arguments.</p>
<blockquote>
<p>At this time, we require Rust compiler version 1.50 or less in order for WebAssembly functions to work with <code>wasm-bindgen</code> and <code>rustwasmc</code>. We will <a href="https://github.com/WasmEdge/WasmEdge/issues/264">catch up to the latest Rust compiler</a> version once the Interface Types spec is finalized and supported.</p>
</blockquote>
<h2 id="prerequisites-1"><a class="header" href="#prerequisites-1">Prerequisites</a></h2>
<p>The <code>rustwasmc</code> depends on the Rust cargo toolchain to compile Rust source code to WebAssembly. You must have <a href="https://www.rust-lang.org/tools/install">Rust installed</a> on your machine.</p>
<pre><code class="language-src">$ curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh
$ source $HOME/.cargo/env
$ rustup override set 1.50.0
</code></pre>
<h2 id="install-1"><a class="header" href="#install-1">Install</a></h2>
<p>The easiest way to install <a href="https://github.com/second-state/rustwasmc">rustwasmc</a> is to use its installer.</p>
<pre><code class="language-src">$ curl https://raw.githubusercontent.com/second-state/rustwasmc/master/installer/init.sh -sSf | sh
</code></pre>
<p>Alternatively, you can <a href="https://github.com/second-state/rustwasmc#install">install using the NPM</a> if you'd like.</p>
<h2 id="usage"><a class="header" href="#usage">Usage</a></h2>
<p>To build <a href="dev/rust/../../embed/node.html">Rust functions for Node.js</a> applications, use the following command. See a <a href="https://github.com/second-state/wasmedge-nodejs-starter">template application</a>.</p>
<pre><code class="language-src">$ rustwasmc build
</code></pre>
<p>Use the <code>--enable-ext</code> flag to compile Rust programs that use WASI extensions, such as WasmEdge's storage and <a href="dev/rust/tensorflow.html">Tensorflow</a> APIs. The <code>rustwasmc</code> will generates the compiled WebAssembly bytecode program for the <code>wasmedge-extensions</code> Node.js module instead of the <code>wasmedge-core</code> module in this case.</p>
<pre><code class="language-src">$ rustwasmc build --enable-ext
</code></pre>
<h2 id="support-aot"><a class="header" href="#support-aot">Support AOT</a></h2>
<p>A key feature of the WasmEdge runtime is its support for Ahead-of-Time (AOT) compilers. When you run WebAssembly programs in Node.js <code>wasmedge-core</code> and <code>wasmedge-extensions</code> add-ons, you typically do not need to worry about it as the add-on handles AOT compilation transparently. However, in some cases, you do want the <code>rustwasmc</code> to compile and generate native code for the program. </p>
<p>Then, use the commands below to bring your operating system up to date with the latest developer tools. The commands here are tested on Ubuntu 20.04.</p>
<pre><code class="language-src">$ sudo apt-get update
$ sudo apt-get -y upgrade
$ sudo apt install build-essential curl wget git vim libboost-all-dev llvm-dev liblld-10-dev
</code></pre>
<p>Now, you can build the <code>.so</code> files for the AOT native target like the following.</p>
<pre><code class="language-src">$ rustwasmc build --enable-aot
</code></pre>
<p>Enjoy coding!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="javascript-1"><a class="header" href="#javascript-1">JavaScript</a></h1>
<p>WebAssembly started as a &quot;JavaScript alternative for browsers&quot;. The idea is to run high-performance applications compiled from languages like C/C++ or Rust safely in browsers. In the browser, WebAssembly runs side by side with JavaScript.</p>
<p>As WebAssembly is increasingly used in the cloud, it is now a universal runtime for cloud-native applications. Compared with Linux containers, WebAssembly runtimes achieve higher performance with lower resource consumption.</p>
<p>In cloud-native use cases, developers often want to use JavaScript to write business applications. That means we must now support JavaScript in WebAssembly. Furthermore, we should support calling C/C++ or Rust functions from JavaScript in a WebAssembly runtime to take advantage of WebAssembly's computational efficiency. The WasmEdge WebAssembly runtime allows you to do exactly that.</p>
<center>
<p><img src="dev/javascript.png" alt="" /></p>
</center>
<p>In this section, we will demonstrate how to run and enhance JavaScript in WasmEdge.</p>
<ul>
<li><a href="dev/js/quickstart.html">Getting started</a> demonstrates how to run simple JavaScript programs in WasmEdge.</li>
<li><a href="dev/js/es6.html">ES6 module</a> shows how to run ES6 modules in WasmEdge.</li>
<li><a href="dev/js/cjs.html">CommonJS module</a> shows how to run CommonJS modules in WasmEdge.</li>
<li><a href="dev/js/npm.html">NodeJS and NPM module</a> shows how to run NPM modules in WasmEdge.</li>
<li><a href="dev/js/ssr.html">React SSR</a> shows an example React SSR application in WasmEdge.</li>
<li><a href="dev/js/tensorflow.html">TensorFlow</a> shows how to use WasmEdge's TensorFlow extension from its JavaScript API.</li>
<li><a href="dev/js/networking.html">Networking sockets</a> shows how to create HTTP client and server applications using the WasmEdge networking extension and its JavaScript API.</li>
<li><a href="dev/js/async.html">Async networking</a> shows how to improve HTTP server application performance by supporting asynchronous and non-blocking I/O.</li>
<li><a href="dev/js/rust.html">Use Rust to implement JS API</a> discusses how to use Rust to implement and support a JavaScript API in WasmEdge.</li>
</ul>
<h2 id="a-note-on-v8"><a class="header" href="#a-note-on-v8">A note on v8</a></h2>
<p>Now, the choice of QuickJS as our JavaScript engine might raise the question of performance. Isn't QuickJS <a href="https://bellard.org/quickjs/bench.html">a lot slower</a> than v8 due to a lack of JIT support? Yes, but ...</p>
<p>First of all, QuickJS is a lot smaller than v8. In fact, it only takes 1/40 (or 2.5%) of the runtime resources v8 consumes. You can run a lot more QuickJS functions than v8 functions on a single physical machine.</p>
<p>Second, for most business logic applications, raw performance is not critical. The application may have computationally intensive tasks, such as AI inference on the fly. WasmEdge allows the QuickJS applications to drop to high-performance WebAssembly for these tasks while it is not so easy with v8 to add such extensions modules.</p>
<p>Third, WasmEdge is <a href="dev/../kubernetes.html">itself an OCI compliant container</a>. 
It is secure by default, supports resource isolation, and can be managed by container tools to run side by side
with Linux containers in a single k8s cluster.</p>
<p>Finally, v8 has a very large attack surface and requires <a href="https://blog.cloudflare.com/mitigating-spectre-and-other-security-threats-the-cloudflare-workers-security-model/">major efforts</a> to run securely in a public cloud environment.
It is known that <a href="https://www.theregister.com/2021/08/06/edge_super_duper_security_mode/">many JavaScript security issues arise from JIT</a>. Maybe turning off JIT in the cloud-native environment is not such a bad idea!</p>
<p>In the end, running v8 in a cloud-native environment often requires a full stack of software tools consisting of 
&quot;Linux container + guest OS + node or deno + v8&quot;, which makes it
much heavier and slower than a simple WasmEdge + QuickJS container runtime.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="quick-start-with-javascript-on-wasmedge"><a class="header" href="#quick-start-with-javascript-on-wasmedge">Quick start with JavaScript on WasmEdge</a></h1>
<p>First, let's build a WebAssembly-based JavaScript interpreter program for WasmEdge. It is based on <a href="https://bellard.org/quickjs/">QuickJS</a> with WasmEdge extensions, such as <a href="https://github.com/second-state/wasmedge_wasi_socket">network sockets</a> and <a href="https://www.secondstate.io/articles/wasi-tensorflow/">Tensorflow inference</a>, incorporated into the interpreter as JavaScript APIs. You will need to <a href="https://www.rust-lang.org/tools/install">install Rust</a> to build the interpreter.</p>
<blockquote>
<p>If you just want to use the interpreter to run JavaScript programs, you can skip this section. Make sure you have installed <a href="https://www.rust-lang.org/tools/install">Rust</a> and <a href="https://github.com/WasmEdge/WasmEdge/blob/master/docs/install.md">WasmEdge</a>.</p>
</blockquote>
<p>Fork or clone <a href="https://github.com/second-state/wasmedge-quickjs">the wasmedge-quickjs Github repository</a> to get started.</p>
<pre><code>$ git clone https://github.com/second-state/wasmedge-quickjs
</code></pre>
<p>Following the instructions from that repo, you will be able to build a JavaScript interpreter for WasmEdge.</p>
<pre><code># Install GCC
$ sudo apt update
$ sudo apt install build-essential

# Install wasm32-wasi target for Rust
$ rustup target add wasm32-wasi

# Build the QuickJS JavaScript interpreter
$ cargo build --target wasm32-wasi --release
</code></pre>
<p>The WebAssembly-based JavaScript interpreter program is located in the build target directory. You can now try a simple &quot;hello world&quot; JavaScript program (<a href="https://github.com/second-state/wasmedge-quickjs/blob/main/example_js/hello.js">example_js/hello.js</a>), which prints out the command line arguments to the console.</p>
<pre><code>args = args.slice(1)
print(&quot;Hello&quot;, ...args)
</code></pre>
<p>Run the <code>hello.js</code> file in WasmEdge’s QuickJS runtime as follows. </p>
<pre><code>$ cd example_js
$ wasmedge --dir .:. ../target/wasm32-wasi/release/wasmedge_quickjs.wasm hello.js WasmEdge Runtime
Hello WasmEdge Runtime
</code></pre>
<blockquote>
<p>Note, the <code>--dir .:.</code> on the command line is to give <code>wasmedge</code> permission to read the local directory in the file system for the <code>hello.js</code> file. We will use  <code>--dir .:.</code> in the following sections.</p>
</blockquote>
<h2 id="make-it-faster"><a class="header" href="#make-it-faster">Make it faster</a></h2>
<p>WasmEdge provides a <code>wasmedgec</code> utility to compile and add a native machine code section to the <code>wasm</code> file. You can use <code>wasmedge</code> to run the natively instrumented <code>wasm</code> file to get much faster performance.</p>
<pre><code class="language-bash">$ wasmedgec ../../target/wasm32-wasi/release/wasmedge_quickjs.wasm wasmedge_quickjs.wasm
$ wasmedge --dir .:. wasmedge_quickjs.wasm hello.js
</code></pre>
<p>Next, we will discuss more advanced use case for JavaScript in WasmEdge.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="es6-module"><a class="header" href="#es6-module">ES6 module</a></h1>
<p>The WasmEdge QuickJS runtime supports ES6 modules. This article will show you how to use ES6 module in WasmEdge.</p>
<p>We will take the example in <a href="https://github.com/second-state/wasmedge-quickjs/tree/main/example_js/es6_module_demo">example_js/es6_module_demo</a> folder as an example. The <a href="https://github.com/second-state/wasmedge-quickjs/blob/main/example_js/es6_module_demo/module_def.js">module_def.js</a> file defines and exports a simple JS function.</p>
<pre><code>function hello(){
    console.log('hello from module_def.js')
}

export {hello}
</code></pre>
<p>The <a href="https://github.com/second-state/wasmedge-quickjs/blob/main/example_js/es6_module_demo/module_def_async.js">module_def_async.js</a> file defines and exports an aysnc function and a variable.</p>
<pre><code>export async function hello(){
    console.log('hello from module_def_async.js')
    return &quot;module_def_async.js : return value&quot;
}

export var something = &quot;async thing&quot;
</code></pre>
<p>The <a href="https://github.com/second-state/wasmedge-quickjs/blob/main/example_js/es6_module_demo/demo.js">demo.js</a> file imports functions and variables from those modules and executes them.</p>
<pre><code>import { hello as module_def_hello } from './module_def.js'
module_def_hello()

var f = async ()=&gt;{
    let {hello , something} = await import('./module_def_async.js')
    await hello()
    console.log(&quot;./module_def_async.js `something` is &quot;,something)
}
f()
</code></pre>
<p>To run the example, you can do the following on the CLI.</p>
<pre><code>$ cd example_js/es6_module_demo
$ wasmedge --dir .:. ../../target/wasm32-wasi/release/wasmedge_quickjs.wasm demo.js
hello from module_def.js
hello from module_def_async.js
./module_def_async.js `something` is  async thing
</code></pre>
<blockquote>
<p>Note, the <code>--dir .:.</code> on the command line is to give wasmedge permission to read the local directory in the file system for the <code>demo.js</code> file.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="commonjs-module"><a class="header" href="#commonjs-module">CommonJS module</a></h1>
<p>The WasmEdge QuickJS runtime supports CommonJS (CJS) modules. This article will show you how to use CJS modules in WasmEdge.</p>
<p>The <a href="https://github.com/second-state/wasmedge-quickjs/tree/main/example_js/simple_common_js_demo">example_js/simple_common_js_demo</a> folder in the GitHub repo contains several examples for your reference.</p>
<p>The <a href="https://github.com/second-state/wasmedge-quickjs/blob/main/example_js/simple_common_js_demo/other_module/main.js">other_module/main.js</a> file defines and exports a simple CJS module.</p>
<pre><code>print('hello other_module')
module.exports = ['other module exports']
</code></pre>
<p>The <a href="https://github.com/second-state/wasmedge-quickjs/blob/main/example_js/simple_common_js_demo/one_module/main.js">one_module/main.js</a> file uses the CJS module.</p>
<pre><code>print('hello one_module');
print('dirname:',__dirname);
let other_module_exports = require('../other_module/main.js')
print('other_module_exports=',other_module_exports)
</code></pre>
<p>Then the <a href="https://github.com/second-state/wasmedge-quickjs/blob/main/example_js/simple_common_js_demo/file_module.js">file_module.js</a> file imports the module and runs it.</p>
<pre><code>import * as one from './one_module/main.js'
print('hello file_module')
</code></pre>
<p>To run the example, you need to build a WasmEdge QuickJS runtime with CJS support.</p>
<pre><code>$ cargo build --target wasm32-wasi --release --features=cjs
</code></pre>
<p>Finally, do the following on the CLI. </p>
<pre><code>$ cd example_js/simple_common_js_demo
$ wasmedge --dir .:. ../../target/wasm32-wasi/release/wasmedge_quickjs.wasm file_module.js
hello one_module
dirname: one_module
hello other_module
other_module_exports= other module exports
hello file_module
</code></pre>
<blockquote>
<p>Note, the <code>--dir .:.</code> on the command line is to give wasmedge permission to read the local directory in the file system for the <code>file_module.js</code> file.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="nodejs-and-npm-module"><a class="header" href="#nodejs-and-npm-module">NodeJS and NPM module</a></h1>
<p>With <a href="dev/js/cjs.html">CommonJS support</a>, we can run NodeJS modules in WasmEdge too. The <a href="https://github.com/second-state/wasmedge-quickjs/blob/main/example_js/simple_common_js_demo/npm_main.js">simple_common_js_demo/npm_main.js</a> demo shows how it works. It utilizes the third-party <code>md5</code> and <code>mathjs</code> modules.</p>
<pre><code>import * as std from 'std'

var md5 = require('md5');
console.log(__dirname);
console.log('md5(message)=',md5('message'));
const { sqrt } = require('mathjs')
console.log('sqrt(-4)=',sqrt(-4).toString())

print('write file')
let f = std.open('hello.txt','w')
let x = f.puts(&quot;hello wasm&quot;)
f.flush()
f.close()
</code></pre>
<p>In order to run it, we must first use the <a href="https://www.npmjs.com/package/@vercel/ncc">vercel ncc</a> tool to build all dependencies into a single file. The build script is <a href="https://github.com/second-state/wasmedge-quickjs/blob/main/example_js/simple_common_js_demo/package.json">package.json</a>.</p>
<pre><code>{
  &quot;dependencies&quot;: {
    &quot;mathjs&quot;: &quot;^9.5.1&quot;,
    &quot;md5&quot;: &quot;^2.3.0&quot;
  },
  &quot;devDependencies&quot;: {
    &quot;@vercel/ncc&quot;: &quot;^0.28.6&quot;
  },
  &quot;scripts&quot;: {
    &quot;ncc_build&quot;: &quot;ncc build npm_main.js&quot;
  }
}
</code></pre>
<p>Now, install <code>ncc</code> and <a href="https://github.com/second-state/wasmedge-quickjs/blob/main/example_js/simple_common_js_demo/npm_main.js">npm_main.js</a> dependencies via NPM, and then build the single JS file in <code>dist/index.js</code>.</p>
<pre><code>$ npm install
$ npm run ncc_build
ncc: Version 0.28.6
ncc: Compiling file index.js
</code></pre>
<p>To run the example, you need to build a WasmEdge QuickJS runtime with CJS support.</p>
<pre><code>$ cargo build --target wasm32-wasi --release --features=cjs
</code></pre>
<p>Run the JS file with NodeJS imports in WasmEdge CLI as follows.</p>
<pre><code>$ wasmedge --dir .:. ../../target/wasm32-wasi/release/wasmedge_quickjs.wasm dist/index.js
dist
md5(message)= 78e731027d8fd50ed642340b7c9a63b3
sqrt(-4)= 2i
write file
</code></pre>
<blockquote>
<p>Note, the <code>--dir .:.</code> on the command line is to give wasmedge permission to read the local directory in the file system for the <code>file_module.js</code> file.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="example-react-ssr"><a class="header" href="#example-react-ssr">Example: React SSR</a></h1>
<p><a href="https://medium.com/jspoint/a-beginners-guide-to-react-server-side-rendering-ssr-bf3853841d55">React Server-Side Rendering (SSR)</a>
is a common use of JavaScript in BFF (backend for frontend) functions. 
Instead of rending HTML DOM elements in the browser, 
it uses the React framework
to render HTML elements from the server side to 
speed up the application. It is an ideal use case for serverless functions
in <a href="https://jamstack.org/">Jamstack</a> applications.</p>
<p>In this article, we will show you how to use the WasmEdge QuickJS runtime
to implement a React SSR function. Compared with the Docker + Linux + nodejs + v8 approach, WasmEdge is much lighter (1% of the footprint) and safer,
provides better resource isolation and management,
and has similar non-JIT (safe) performance.</p>
<p>The <a href="https://github.com/second-state/wasmedge-quickjs/tree/main/example_js/react_ssr">example_js/react_ssr</a> folder in the GitHub repo contains the example's source code.</p>
<p>The <a href="https://github.com/second-state/wasmedge-quickjs/blob/main/example_js/react_ssr/component/Home.jsx">component/Home.jsx</a>
file is the main page template in React.</p>
<pre><code>import React from 'react';
import Page from './Page.jsx';
 
class Home extends React.Component {

  render() {
    const { dataList = [] } = this.props;
    return (
      &lt;div&gt;
        &lt;div&gt;This is home&lt;/div&gt;
        &lt;Page&gt;&lt;/Page&gt;
      &lt;/div&gt;
    )
  }
}

export default Home;
</code></pre>
<p>The <code>Home.jpx</code> template includes a <a href="https://github.com/second-state/wasmedge-quickjs/blob/main/example_js/react_ssr/component/Page.jsx">Page.jpx</a>
template for part of the page.</p>
<pre><code>import React from 'react';

class Page extends React.Component {

  render() {
    const { dataList = [] } = this.props;
    return (
      &lt;div&gt;
        &lt;div&gt;This is page&lt;/div&gt;
      &lt;/div&gt;
    )
  }
}

export default Page;
</code></pre>
<p>The <a href="https://github.com/second-state/wasmedge-quickjs/blob/main/example_js/react_ssr/main.js">main.js</a>
file calls React to render the templates into HTML.</p>
<pre><code>import Home from './component/Home.jsx';
import {renderToString} from 'react-dom/server';
import React from 'react';

const content = renderToString(React.createElement(Home));
console.log(content)
</code></pre>
<p>The <a href="https://github.com/second-state/wasmedge-quickjs/blob/main/example_js/react_ssr/rollup.config.js">rollup.config.js</a>
and <a href="https://github.com/second-state/wasmedge-quickjs/blob/main/example_js/react_ssr/package.json">package.json</a>
files are to build the React SSR dependencies into a single JavaScript file
for WasmEdge. You should use the <code>npm</code> command to build it.
The output is in the <code>dist/main.js</code> file.</p>
<pre><code>$ npm install
$ npm run build
</code></pre>
<p>To run the example, you need to build a WasmEdge QuickJS runtime with CJS support.</p>
<pre><code>$ cargo build --target wasm32-wasi --release --features=cjs
</code></pre>
<p>Finally, do the following on the CLI. </p>
<pre><code>$ wasmedge --dir .:. ../../target/wasm32-wasi/release/wasmedge_quickjs.wasm dist/main.js
&lt;div data-reactroot=&quot;&quot;&gt;&lt;div&gt;This is home&lt;/div&gt;&lt;div&gt;&lt;div&gt;This is page&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;
</code></pre>
<blockquote>
<p>Note, the <code>--dir .:.</code> on the command line is to give wasmedge permission to read the local directory in the file system for the <code>dist/main.js</code> file.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tensorflow-1"><a class="header" href="#tensorflow-1">TensorFlow</a></h1>
<p>The interpreter supports the WasmEdge TensorFlow lite inference extension so that your JavaScript can run an ImageNet model for image classification. This article will show you how to use the TensorFlow Rust SDK for WasmEdge from your javascript program.</p>
<p>Here is an example of JavaScript. You could find the full code from <a href="https://github.com/second-state/wasmedge-quickjs/tree/main/example_js/tensorflow_lite_demo">example_js/tensorflow_lite_demo/</a>.</p>
<pre><code>import {TensorflowLiteSession} from 'tensorflow_lite'
import {Image} from 'image'let img = new Image('./example_js/tensorflow_lite_demo/food.jpg')

let img_rgb = img.to_rgb().resize(192,192)
let rgb_pix = img_rgb.pixels()let session = new TensorflowLiteSession('./example_js/tensorflow_lite_demo/lite-model_aiy_vision_classifier_food_V1_1.tflite')

session.add_input('input',rgb_pix)
session.run()
let output = session.get_output('MobilenetV1/Predictions/Softmax');
let output_view = new Uint8Array(output)
let max = 0;
let max_idx = 0;
for (var i in output_view){
    let v = output_view[i]
    if(v&gt;max){
        max = v;
        max_idx = i;
    }
}
print(max,max_idx)
</code></pre>
<p>To run the JavaScript in the WasmEdge runtime, you can do the following on the CLI to re-build the QuickJS engine with TensorFlow and then run the JavaScript program with TensorFlow API.</p>
<pre><code>$ cargo build --target wasm32-wasi --release --features=tensorflow
... ...
$ cd example_js/tensorflow_lite_demo
$ wasmedge-tensorflow-lite --dir .:. ../../target/wasm32-wasi/release/wasmedge_quickjs.wasm main.js
label:
Hot dog
confidence:
0.8941176470588236
</code></pre>
<blockquote>
<p>Note, the <code>--dir .:.</code> on the command line is to give wasmedge permission to read the local directory in the file system for the <code>main.js</code> file.</p>
</blockquote>
<h4 id="note"><a class="header" href="#note">Note:</a></h4>
<ul>
<li>The <code>--features=tensorflow</code> compiler flag builds a version of the QuickJS engine with WasmEdge TensorFlow extensions.</li>
<li>The <code>wasmedge-tensorflow-lite</code> program is part of the WasmEdge package. It is the WasmEdge runtime with the Tensorflow extension built in.</li>
</ul>
<p>You should now see the name of the food item recognized by the TensorFlow lite ImageNet model.</p>
<h2 id="make-it-faster-1"><a class="header" href="#make-it-faster-1">Make it faster</a></h2>
<p>The above Tensorflow inference example takes 1–2 seconds to run. It is acceptable in web application scenarios but could be improved. Recall that WasmEdge is the fastest WebAssembly runtime today due to its AOT (Ahead-of-time compiler) optimization. WasmEdge provides a <code>wasmedgec</code> utility to compile and add a native machine code section to the <code>wasm</code> file for much faster performance.</p>
<p>The following example uses the extended versions to <code>wasmedge</code> and <code>wasmedgec</code> to support the WasmEdge Tensorflow extension.</p>
<pre><code>$ cd example_js/tensorflow_lite_demo
$ wasmedgec-tensorflow ../../target/wasm32-wasi/release/wasmedge_quickjs.wasm wasmedge_quickjs.wasm
$ wasmedge-tensorflow-lite --dir .:. wasmedge_quickjs.wasm main.js
label:
Hot dog
confidence:
0.8941176470588236
</code></pre>
<p>You can see that the image classification task can be completed within 0.1s. It is at least 10x improvement!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="networking-sockets-1"><a class="header" href="#networking-sockets-1">Networking sockets</a></h1>
<p>The QuickJS WasmEdge Runtime supports the WasmEdge <a href="https://github.com/second-state/wasmedge_wasi_socket">networking socket extension</a> so that the JavaScript programs can make HTTP connections to the Internet. This article will show you both <a href="https://github.com/second-state/wasmedge-quickjs/blob/main/example_js/http_demo.js">HTTP Client</a> and <a href="https://github.com/second-state/wasmedge-quickjs/blob/main/example_js/http_server_demo.js">HTTP Server</a> examples.</p>
<h2 id="a-javascript-networking-client-example"><a class="header" href="#a-javascript-networking-client-example">A JavaScript networking client example</a></h2>
<p>Below is an example of JavaScript running a HTTP client. You could find the code in <a href="https://github.com/second-state/wasmedge-quickjs/blob/main/example_js/http_demo.js">example_js/http_demo.js</a>.</p>
<pre><code>let r = GET(&quot;http://18.235.124.214/get?a=123&quot;,{&quot;a&quot;:&quot;b&quot;,&quot;c&quot;:[1,2,3]})
print(r.status)
    
let headers = r.headers
print(JSON.stringify(headers))let body = r.body;
let body_str = new Uint8Array(body)
print(String.fromCharCode.apply(null,body_str))
</code></pre>
<p>To run the JavaScript in the WasmEdge runtime, you can do this on the CLI.</p>
<pre><code>$ cd example_js
$ wasmedge --dir .:. ../target/wasm32-wasi/release/wasmedge_quickjs.wasm http_demo.js
</code></pre>
<p>You should now see the HTTP GET result printed on the console.</p>
<h2 id="a-javascript-networking-server-example"><a class="header" href="#a-javascript-networking-server-example">A JavaScript networking server example</a></h2>
<p>Below is an example of JavaScript running a HTTP server listening at port 3000. You could find the code in <a href="https://github.com/second-state/wasmedge-quickjs/blob/main/example_js/http_server_demo.js">example_js/http_server_demo.js</a>.</p>
<pre><code>import {HttpServer} from 'http'

let http_server = new HttpServer('0.0.0.0:8000')
print('listen on 0.0.0.0:8000')

while(true){
    http_server.accept((request)=&gt;{
        let body = request.body
        let body_str = String.fromCharCode.apply(null,new Uint8Array(body))
        print(JSON.stringify(request),'\n body_str:',body_str)

        return {
            status:200,
            header:{'Content-Type':'application/json'},
            body:'echo:'+body_str
        }
    });
}
</code></pre>
<p>To run the JavaScript in the WasmEdge runtime, you can do this on the CLI. Since it is a server, you should run it in the background.</p>
<pre><code>$ cd example_js
$ nohup wasmedge --dir .:. ../target/wasm32-wasi/release/wasmedge_quickjs.wasm http_server_demo.js &amp;
</code></pre>
<p>Then you can test the server by querying it over the network.</p>
<pre><code>$ curl -d &quot;WasmEdge&quot; -X POST http://localhost:8000
echo:WasmEdge
</code></pre>
<p>You should now see the HTTP POST body printed on the console.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="async-networking"><a class="header" href="#async-networking">Async networking</a></h1>
<p>Coming soon. </p>
<p>Check out the <a href="https://github.com/second-state/wasmedge-quickjs">WasmEdge-QuickJS proejct</a> to get the latest updates.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="use-rust-to-implement-js-api"><a class="header" href="#use-rust-to-implement-js-api">Use Rust to implement JS API</a></h1>
<p>For JavaScript developers, incorporating Rust functions into JavaScript APIs is useful. That enables developers to write programs in &quot;pure JavaScript&quot; and yet still take advantage of the high performance Rust functions. With the <a href="https://github.com/WasmEdge/WasmEdge">WasmEdge Runtime</a>, you can do exactly that.</p>
<p>Check out the <a href="https://github.com/second-state/wasmedge-quickjs/">wasmedge-quickjs</a> Github repo and change to the <code>examples/embed_js</code> folder to follow along.</p>
<pre><code>$ git clone https://github.com/second-state/wasmedge-quickjs
$ cd examples/embed_js
</code></pre>
<blockquote>
<p>You must have <a href="https://www.rust-lang.org/tools/install">Rust</a> and <a href="https://github.com/WasmEdge/WasmEdge/blob/master/docs/install.md">WasmEdge</a> installed to build and run the examples we show you.</p>
</blockquote>
<p>The <code>embed_js</code> demo showcases several different examples on how to embed JavaScript inside Rust. You can build and run all the examples as follows.</p>
<pre><code>$ cargo build --target wasm32-wasi --release
$ wasmedge --dir .:. target/wasm32-wasi/release/embed_js.wasm
</code></pre>
<blockquote>
<p>The <code>--dir .:.</code> on the command line is to give wasmedge permission to read the local directory in the file system.</p>
</blockquote>
<h2 id="create-a-javascript-function-api"><a class="header" href="#create-a-javascript-function-api">Create a JavaScript function API</a></h2>
<p>The following code snippet defines a Rust function that can be incorporate into the JavaScript interpreter as an API.</p>
<pre><code>fn run_rust_function(ctx: &amp;mut Context) {

    struct HelloFn;
    impl JsFn for HelloFn {
        fn call(_ctx: &amp;mut Context, _this_val: JsValue, argv: &amp;[JsValue]) -&gt; JsValue {
            println!(&quot;hello from rust&quot;);
            println!(&quot;argv={:?}&quot;, argv);
            JsValue::UnDefined
        }
    }
    
    ...
}
</code></pre>
<p>The following code snippet shows how to add this Rust function into the JavaScript interpreter, give a name <code>hi()</code> as its JavaScript API, and then call it from JavaScript code.</p>
<pre><code>fn run_rust_function(ctx: &amp;mut Context) {
    ...
    
    let f = ctx.new_function::&lt;HelloFn&gt;(&quot;hello&quot;);
    ctx.get_global().set(&quot;hi&quot;, f.into());
    let code = r#&quot;hi(1,2,3)&quot;#;
    let r = ctx.eval_global_str(code);
    println!(&quot;return value:{:?}&quot;, r);
}
</code></pre>
<p>The execution result is as follows.</p>
<pre><code>hello from rust
argv=[Int(1), Int(2), Int(3)]
return value:UnDefined
</code></pre>
<p>Using this approach, you can create a JavaScript interpreter with customized API functions. The interpreter runs inside WasmEdge, and can execute JavaScript code, which calls such API functions, from CLI or the network.</p>
<h2 id="create-a-javascript-object-api"><a class="header" href="#create-a-javascript-object-api">Create a JavaScript object API</a></h2>
<p>In the JavaScript API design, we sometimes need to provide an object that encapsulates both data and function. In the following example, we define a Rust function for the JavaScript API.</p>
<pre><code>fn rust_new_object_and_js_call(ctx: &amp;mut Context) {

    struct ObjectFn;
    impl JsFn for ObjectFn {
        fn call(_ctx: &amp;mut Context, this_val: JsValue, argv: &amp;[JsValue]) -&gt; JsValue {
            println!(&quot;hello from rust&quot;);
            println!(&quot;argv={:?}&quot;, argv);
            if let JsValue::Object(obj) = this_val {
                let obj_map = obj.to_map();
                println!(&quot;this={:#?}&quot;, obj_map);
            }
            JsValue::UnDefined
        }
    }
</code></pre>
<p>We then create an &quot;object&quot; on the Rust side, set its data fields, and then register the Rust function as a JavaScript function associated with the objects.</p>
<pre><code>    let mut obj = ctx.new_object();
    obj.set(&quot;a&quot;, 1.into());
    obj.set(&quot;b&quot;, ctx.new_string(&quot;abc&quot;).into());
    
    let f = ctx.new_function::&lt;ObjectFn&gt;(&quot;anything&quot;);
    obj.set(&quot;f&quot;, f.into());
</code></pre>
<p>Next, we make the Rust &quot;object&quot; available as JavaScript object <code>test_obj</code> in the JavaScript interpreter.</p>
<pre><code>    ctx.get_global().set(&quot;test_obj&quot;, obj.into());
</code></pre>
<p>In the JavaScript code, you can now directly use <code>test_obj</code> as part of the API.</p>
<pre><code>    let code = r#&quot;
      print('test_obj keys=',Object.keys(test_obj))
      print('test_obj.a=',test_obj.a)
      print('test_obj.b=',test_obj.b)
      test_obj.f(1,2,3,&quot;hi&quot;)
    &quot;#;

    ctx.eval_global_str(code);
}
</code></pre>
<p>The execution result is as follows.</p>
<pre><code>test_obj keys= a,b,f
test_obj.a= 1
test_obj.b= abc
hello from rust
argv=[Int(1), Int(2), Int(3), String(JsString(hi))]
this=Ok(
    {
        &quot;a&quot;: Int(
            1,
        ),
        &quot;b&quot;: String(
            JsString(
                abc,
            ),
        ),
        &quot;f&quot;: Function(
            JsFunction(
                function anything() {
                    [native code]
                },
            ),
        ),
    },
)
</code></pre>
<h2 id="a-complete-javascript-object-api"><a class="header" href="#a-complete-javascript-object-api">A complete JavaScript object API</a></h2>
<p>In the previous example, we demonstrated simple examples to create JavaScript APIs from Rust. In this example, we will create a complete Rust module and make it available as a JavaScript object API. The project is in the <a href="https://github.com/second-state/wasmedge-quickjs/tree/main/examples/embed_rust_module">examples/embed_rust_module</a> folder. You can build and run it as a standard Rust application in WasmEdge.</p>
<pre><code>$ cargo build --target wasm32-wasi --release
$ wasmedge --dir .:. target/wasm32-wasi/release/embed_rust_module.wasm
</code></pre>
<p>The Rust implementation of the object is a module as follows. It has data fields, constructor, getters and setters, and functions.</p>
<pre><code>mod point {
    use wasmedge_quickjs::*;

    #[derive(Debug)]
    struct Point(i32, i32);

    struct PointDef;

    impl JsClassDef&lt;Point&gt; for PointDef {
        const CLASS_NAME: &amp;'static str = &quot;Point\0&quot;;
        const CONSTRUCTOR_ARGC: u8 = 2;

        fn constructor(_: &amp;mut Context, argv: &amp;[JsValue]) -&gt; Option&lt;Point&gt; {
            println!(&quot;rust-&gt; new Point {:?}&quot;, argv);
            let x = argv.get(0);
            let y = argv.get(1);
            if let ((Some(JsValue::Int(ref x)), Some(JsValue::Int(ref y)))) = (x, y) {
                Some(Point(*x, *y))
            } else {
                None
            }
        }

        fn proto_init(p: &amp;mut JsClassProto&lt;Point, PointDef&gt;) {
            struct X;
            impl JsClassGetterSetter&lt;Point&gt; for X {
                const NAME: &amp;'static str = &quot;x\0&quot;;

                fn getter(_: &amp;mut Context, this_val: &amp;mut Point) -&gt; JsValue {
                    println!(&quot;rust-&gt; get x&quot;);
                    this_val.0.into()
                }

                fn setter(_: &amp;mut Context, this_val: &amp;mut Point, val: JsValue) {
                    println!(&quot;rust-&gt; set x:{:?}&quot;, val);
                    if let JsValue::Int(x) = val {
                        this_val.0 = x
                    }
                }
            }

            struct Y;
            impl JsClassGetterSetter&lt;Point&gt; for Y {
                const NAME: &amp;'static str = &quot;y\0&quot;;

                fn getter(_: &amp;mut Context, this_val: &amp;mut Point) -&gt; JsValue {
                    println!(&quot;rust-&gt; get y&quot;);
                    this_val.1.into()
                }

                fn setter(_: &amp;mut Context, this_val: &amp;mut Point, val: JsValue) {
                    println!(&quot;rust-&gt; set y:{:?}&quot;, val);
                    if let JsValue::Int(y) = val {
                        this_val.1 = y
                    }
                }
            }

            struct FnPrint;
            impl JsMethod&lt;Point&gt; for FnPrint {
                const NAME: &amp;'static str = &quot;pprint\0&quot;;
                const LEN: u8 = 0;

                fn call(_: &amp;mut Context, this_val: &amp;mut Point, _argv: &amp;[JsValue]) -&gt; JsValue {
                    println!(&quot;rust-&gt; pprint: {:?}&quot;, this_val);
                    JsValue::Int(1)
                }
            }

            p.add_getter_setter(X);
            p.add_getter_setter(Y);
            p.add_function(FnPrint);
        }
    }

    struct PointModule;
    impl ModuleInit for PointModule {
        fn init_module(ctx: &amp;mut Context, m: &amp;mut JsModuleDef) {
            m.add_export(&quot;Point\0&quot;, PointDef::class_value(ctx));
        }
    }

    pub fn init_point_module(ctx: &amp;mut Context) {
        ctx.register_class(PointDef);
        ctx.register_module(&quot;point\0&quot;, PointModule, &amp;[&quot;Point\0&quot;]);
    }
}
</code></pre>
<p>In the interpreter implementation, we call <code>point::init_point_module</code> first to register the Rust module with the JavaScript context, and then we can run a JavaScript program that simply use the <code>point</code> object.</p>
<pre><code>use wasmedge_quickjs::*;
fn main() {
    let mut ctx = Context::new();
    point::init_point_module(&amp;mut ctx);

    let code = r#&quot;
      import('point').then((point)=&gt;{
        let p0 = new point.Point(1,2)
        print(&quot;js-&gt;&quot;,p0.x,p0.y)
        p0.pprint()
        try{
            let p = new point.Point()
            print(&quot;js-&gt; p:&quot;,p)
            print(&quot;js-&gt;&quot;,p.x,p.y)
            p.x=2
            p.pprint()
        } catch(e) {
            print(&quot;An error has been caught&quot;);
            print(e)
        }    
      })
    &quot;#;

    ctx.eval_global_str(code);
    ctx.promise_loop_poll();
}
</code></pre>
<p>The execution result from the above application is as follows.</p>
<pre><code>rust-&gt; new Point [Int(1), Int(2)]
rust-&gt; get x
rust-&gt; get y
js-&gt; 1 2
rust-&gt; pprint: Point(1, 2)
rust-&gt; new Point []
js-&gt; p: undefined
An error has been caught
TypeError: cannot read property 'x' of undefined
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="go"><a class="header" href="#go">Go</a></h1>
<p>The best way to run Go programs in WasmEdge is to compile Go source code to WebAssembly using <a href="https://tinygo.org/">TinyGo</a>. In this article, we will show you how.</p>
<h2 id="install-tinygo"><a class="header" href="#install-tinygo">Install TinyGo</a></h2>
<p>You must have <a href="https://go.dev/doc/install">Go already installed</a> on your machine before installing TinyGo. Go v1.17 or above is recommended.</p>
<p>For Ubuntu or other Debian-based Linux systems on x86 processors, you could use the following command line to install TinyGo. For other platforms, please refer to <a href="https://tinygo.org/getting-started/install/">TinyGo docs</a>.</p>
<pre><code>wget https://github.com/tinygo-org/tinygo/releases/download/v0.21.0/tinygo_0.21.0_amd64.deb
sudo dpkg -i tinygo_0.21.0_amd64.deb`
</code></pre>
<p>Next, run the following command line to check out if the installation is successful.</p>
<pre><code>$ tinygo version
tinygo version 0.21.0 linux/amd64 (using go version go1.16.7 and LLVM version 11.0.0)
</code></pre>
<h2 id="hello-world-2"><a class="header" href="#hello-world-2">Hello world</a></h2>
<p>The simple Go app has a <code>main()</code> function to print a message to the console. 
The source code in <code>main.go</code> file is as follows.</p>
<pre><code class="language-go">package main

func main() {
    println(&quot;Hello TinyGo from WasmEdge!&quot;)
}
</code></pre>
<blockquote>
<p>Inside the <code>main()</code> function, you can use Go standard API to read / write 
files, and access command line arguments and <code>env</code> variables.</p>
</blockquote>
<h3 id="compile-and-build"><a class="header" href="#compile-and-build">Compile and build</a></h3>
<p>Next, compile the <code>main.go</code> program to WebAssembly using TinyGo.</p>
<pre><code class="language-bash">tinygo build -o hello.wasm -target wasi main.go
</code></pre>
<p>You will see a file named <code>hello.wasm</code> in the same directory. This is a WebAssembly bytecode file.</p>
<h3 id="run-1"><a class="header" href="#run-1">Run</a></h3>
<p>You can run it with the <a href="dev/../start/cli.html">WasmEdge CLI</a>.</p>
<pre><code class="language-bash">$ wasmedge hello.wasm
Hello TinyGo from WasmEdge!
</code></pre>
<h2 id="a-simple-function-1"><a class="header" href="#a-simple-function-1">A simple function</a></h2>
<p>The second example is a Go function that takes a call parameter to compute
a fibonacci number. However, in order for the Go application to set up
proper access to the OS (e.g., to access the command line arguments),
you must include an empty <code>main()</code> function in the source code.</p>
<pre><code class="language-go">package main

func main(){
}

//export fibArray
func fibArray(n int32) int32{
        arr := make([]int32, n)
        for i := int32(0); i &lt; n; i++ {
                switch {
                case i &lt; 2:
                        arr[i] = i
                default:
                        arr[i] = arr[i-1] + arr[i-2]
                }
        }
        return arr[n-1]
}
</code></pre>
<h3 id="compile-and-build-1"><a class="header" href="#compile-and-build-1">Compile and build</a></h3>
<p>Next, compile the <code>main.go</code> program to WebAssembly using TinyGo.</p>
<pre><code class="language-bash">tinygo build -o fib.wasm -target wasi main.go
</code></pre>
<p>You will see a file named <code>fib.wasm</code> in the same directory. This is a WebAssembly bytecode file.</p>
<h3 id="run-2"><a class="header" href="#run-2">Run</a></h3>
<p>You can run it with the <a href="dev/../start/cli.html">WasmEdge CLI</a> in its <code>--reactor</code> mode.
The command line arguments that follow the <code>wasm</code> file are the function name
and its call parameters.</p>
<pre><code class="language-bash">$ wasmedge --reactor fib.wasm fibArray 10
34
</code></pre>
<h2 id="improve-performance-1"><a class="header" href="#improve-performance-1">Improve performance</a></h2>
<p>To achieve native Go performance for those applications, you 
could use the <code>wasmedgec</code> command to AOT compile the <code>wasm</code> program,
and then run it with the <code>wasmedge</code> command.</p>
<pre><code class="language-bash">$ wasmedgec hello.wasm hello.wasm

$ wasmedge hello.wasm
Hello TinyGo from WasmEdge!
</code></pre>
<p>For the <code>--reactor</code> mode,</p>
<pre><code class="language-bash">$ wasmedgec fib.wasm fib.wasm

$ wasmedge --reactor fib.wasm fibArray 10
34
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="swift"><a class="header" href="#swift">Swift</a></h1>
<p>The <a href="https://swiftwasm.org/">swiftwasm</a> project compiles Swift source code to WebAssembly.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="assemblyscript"><a class="header" href="#assemblyscript">AssemblyScript</a></h1>
<p><a href="https://www.assemblyscript.org/">AssemblyScript</a> is a TypeScript-like language designed for WebAssembly. AssemblyScript programs can be easily compiled into WebAssembly.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="kotlin"><a class="header" href="#kotlin">Kotlin</a></h1>
<p>Check out how to <a href="https://blog.jdriven.com/2021/04/running-kotlin-in-the-browser-with-wasm/">compile Kotlin programs to WebAssembly</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="grain"><a class="header" href="#grain">Grain</a></h1>
<p><a href="https://grain-lang.org/">Grain</a> is a strongly typed languages designed
for WebAssembly. Checkout its <a href="https://grain-lang.org/docs/guide/hello_world">Hello world</a> example.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="embed-wasmedge-functions"><a class="header" href="#embed-wasmedge-functions">Embed WasmEdge functions</a></h1>
<p>A common use case for WasmEdge is to embed it in your own applications (called
a host application). It allows you to support 3rd party plug-ins and extensions for your applications.
Those plug-ins and extensions could be written in any of the languages
WasmEdge supports, and by anyone as they are safely and securely executed in
the WasmEdge sandbox.</p>
<p>In this chapter, we will discuss how to use WasmEdge SDKs to embed WasmEdge 
programs into C, Rust, Go, and Python host applications.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="wasmedge-c-sdk"><a class="header" href="#wasmedge-c-sdk">WasmEdge C SDK</a></h1>
<p>The WasmEdge C API denotes an interface to embed the WasmEdge runtime into a C program. The followings are the quick start guides to working with the C APIs of WasmEdge. For the details of the WasmEdge C API, please refer to the <a href="embed/c/ref.html">full documentation</a>.</p>
<p>The WasmEdge C API also the fundamental API for other languages' SDK.</p>
<h2 id="quick-start-guide-for-the-wasmedge-runner"><a class="header" href="#quick-start-guide-for-the-wasmedge-runner">Quick Start Guide for the WasmEdge runner</a></h2>
<p>The following is an example for running a WASM file.
Assume that the WASM file <a href="https://github.com/WasmEdge/WasmEdge/raw/master/tools/wasmedge/examples/fibonacci.wasm">fibonacci.wasm</a> is copied into the current directory, and the C file <code>test_wasmedge.c</code> is as following:</p>
<pre><code class="language-c">#include &lt;wasmedge/wasmedge.h&gt;
#include &lt;stdio.h&gt;
int main(int Argc, const char* Argv[]) {
  /* Create the configure context and add the WASI support. */
  /* This step is not necessary unless you need WASI support. */
  WasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();
  WasmEdge_ConfigureAddHostRegistration(ConfCxt, WasmEdge_HostRegistration_Wasi);
  /* The configure and store context to the VM creation can be NULL. */
  WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(ConfCxt, NULL);

  /* The parameters and returns arrays. */
  WasmEdge_Value Params[1] = { WasmEdge_ValueGenI32(32) };
  WasmEdge_Value Returns[1];
  /* Function name. */
  WasmEdge_String FuncName = WasmEdge_StringCreateByCString(&quot;fib&quot;);
  /* Run the WASM function from file. */
  WasmEdge_Result Res = WasmEdge_VMRunWasmFromFile(VMCxt, Argv[1], FuncName, Params, 1, Returns, 1);

  if (WasmEdge_ResultOK(Res)) {
    printf(&quot;Get result: %d\n&quot;, WasmEdge_ValueGetI32(Returns[0]));
  } else {
    printf(&quot;Error message: %s\n&quot;, WasmEdge_ResultGetMessage(Res));
  }

  /* Resources deallocations. */
  WasmEdge_VMDelete(VMCxt);
  WasmEdge_ConfigureDelete(ConfCxt);
  WasmEdge_StringDelete(FuncName);
  return 0;
}
</code></pre>
<p>Then you can compile and run: (the 32th fibonacci number is 3524578 in 0-based index)</p>
<pre><code class="language-bash">$ gcc test_wasmedge.c -lwasmedge_c -o test_wasmedge
$ ./test_wasmedge fibonacci.wasm
Get result: 3524578
</code></pre>
<p>For the details of APIs, please refer to the <a href="https://github.com/WasmEdge/WasmEdge/blob/master/include/api/wasmedge/wasmedge.h">API header file</a>.</p>
<h2 id="quick-start-guide-for-the-wasmedge-aot-compiler"><a class="header" href="#quick-start-guide-for-the-wasmedge-aot-compiler">Quick Start Guide for the WasmEdge AOT compiler</a></h2>
<p>Assume that the WASM file <a href="https://github.com/WasmEdge/WasmEdge/raw/master/tools/wasmedge/examples/fibonacci.wasm">fibonacci.wasm</a> is copied into the current directory, and the C file <code>test_wasmedge_compiler.c</code> is as following:</p>
<pre><code class="language-c">#include &lt;wasmedge/wasmedge.h&gt;
#include &lt;stdio.h&gt;
int main(int Argc, const char* Argv[]) {
  /* Create the configure context. */
  WasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();
  /* ... Adjust settings in the configure context. */
  /* Result. */
  WasmEdge_Result Res;

  /* Create the compiler context. The configure context can be NULL. */
  WasmEdge_CompilerContext *CompilerCxt = WasmEdge_CompilerCreate(ConfCxt);
  /* Compile the WASM file with input and output paths. */
  Res = WasmEdge_CompilerCompile(CompilerCxt, Argv[1], Argv[2]);
  if (!WasmEdge_ResultOK(Res)) {
      printf(&quot;Compilation failed: %s\n&quot;, WasmEdge_ResultGetMessage(Res));
      return 1;
  }

  WasmEdge_CompilerDelete(CompilerCxt);
  WasmEdge_ConfigureDelete(ConfCxt);
  return 0;
}
</code></pre>
<p>Then you can compile and run (the output file is <code>fibonacci.wasm.so</code>):</p>
<pre><code class="language-bash">$ gcc test_wasmedge_compiler.c -lwasmedge_c -o test_wasmedge_compiler
$ ./test_wasmedge_compiler fibonacci.wasm fibonacci.wasm.so
[2021-07-02 11:08:08.651] [info] compile start
[2021-07-02 11:08:08.653] [info] verify start
[2021-07-02 11:08:08.653] [info] optimize start
[2021-07-02 11:08:08.670] [info] codegen start
[2021-07-02 11:08:08.706] [info] compile done
</code></pre>
<p>The compiled-WASM file can be used as a WASM input for the WasmEdge runner.
The following is the comparison of the interpreter mode and the AOT mode:</p>
<pre><code class="language-bash">$ time ./test_wasmedge fibonacci.wasm
Get result: 5702887

real	0m2.715s
user	0m2.700s
sys	0m0.008s

$ time ./test_wasmedge fibonacci.wasm.so
Get result: 5702887

real	0m0.036s
user	0m0.022s
sys	0m0.011s
</code></pre>
<p>For the details of APIs, please refer to the <a href="https://github.com/WasmEdge/WasmEdge/blob/master/include/api/wasmedge/wasmedge.h">API header file</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="wasmedge-c-api-documentation"><a class="header" href="#wasmedge-c-api-documentation">WasmEdge C API Documentation</a></h1>
<p><a href="https://github.com/WasmEdge/WasmEdge/blob/master/include/api/wasmedge/wasmedge.h">WasmEdge C API</a> denotes an interface to access the WasmEdge runtime. The followings are the guides to working with the C APIs of WasmEdge.</p>
<h2 id="table-of-contents-1"><a class="header" href="#table-of-contents-1">Table of Contents</a></h2>
<ul>
<li><a href="embed/c/ref.html#wasmEdge-installation">WasmEdge Installation</a>
<ul>
<li><a href="embed/c/ref.html#download-and-install">Download And Install</a></li>
<li><a href="embed/c/ref.html#compile-sources">Compile Sources</a></li>
</ul>
</li>
<li><a href="embed/c/ref.html#wasmedge-basics">WasmEdge Basics</a>
<ul>
<li><a href="embed/c/ref.html#version">Version</a></li>
<li><a href="embed/c/ref.html#logging-settings">Logging Settings</a></li>
<li><a href="embed/c/ref.html#value-types">Value Types</a></li>
<li><a href="embed/c/ref.html#strings">Strings</a></li>
<li><a href="embed/c/ref.html#results">Results</a></li>
<li><a href="embed/c/ref.html#contexts">Contexts</a></li>
<li><a href="embed/c/ref.html#wasm-data-structures">WASM data structures</a></li>
<li><a href="embed/c/ref.html#configurations">Configurations</a></li>
<li><a href="embed/c/ref.html#statistics">Statistics</a></li>
</ul>
</li>
<li><a href="embed/c/ref.html#wasmedge-vm">WasmEdge VM</a>
<ul>
<li><a href="embed/c/ref.html#wasm-execution-example-with-vm-context">WASM Execution Example With VM Context</a></li>
<li><a href="embed/c/ref.html#vm-creations">VM Creations</a></li>
<li><a href="embed/c/ref.html#preregistrations">Preregistrations</a></li>
<li><a href="embed/c/ref.html#host-module-registrations">Host Module Registrations</a></li>
<li><a href="embed/c/ref.html#wasm-registrations-and-executions">WASM Registrations And Executions</a></li>
<li><a href="embed/c/ref.html#instance-tracing">Instance Tracing</a></li>
</ul>
</li>
<li><a href="embed/c/ref.html#wasmedge-runtime">WasmEdge Runtime</a>
<ul>
<li><a href="embed/c/ref.html#wasm-execution-example-step-by-step">WASM Execution Example Step-By-Step</a></li>
<li><a href="embed/c/ref.html#loader">Loader</a></li>
<li><a href="embed/c/ref.html#validator">Validator</a></li>
<li><a href="embed/c/ref.html#executor">Executor</a></li>
<li><a href="embed/c/ref.html#ast-module">AST Module</a></li>
<li><a href="embed/c/ref.html#store">Store</a></li>
<li><a href="embed/c/ref.html#instances">Instances</a></li>
<li><a href="embed/c/ref.html#host-functions">Host Functions</a></li>
</ul>
</li>
<li><a href="embed/c/ref.html#wasmEdge-aot-compiler">WasmEdge AOT Compiler</a>
<ul>
<li><a href="embed/c/ref.html#compilation-example">Compilation Example</a></li>
<li><a href="embed/c/ref.html#compiler-options">Compiler Options</a></li>
</ul>
</li>
</ul>
<h2 id="wasmedge-installation"><a class="header" href="#wasmedge-installation">WasmEdge Installation</a></h2>
<h3 id="download-and-install"><a class="header" href="#download-and-install">Download And Install</a></h3>
<p>The easiest way to install WasmEdge is to run the following command. Your system should have <code>git</code> and <code>wget</code> as prerequisites.</p>
<pre><code class="language-bash">wget -qO- https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/utils/install.sh | bash -s -- -v 0.9.0
</code></pre>
<p>For more details, please refer to the <a href="embed/c/install.html">Installation Guide</a> for the WasmEdge installation.</p>
<h3 id="compile-sources"><a class="header" href="#compile-sources">Compile Sources</a></h3>
<p>After the installation of WasmEdge, the following guide can help you to test for the availability of the WasmEdge C API.</p>
<ol>
<li>
<p>Prepare the test C file (and assumed saved as <code>test.c</code>):</p>
<pre><code class="language-c">#include &lt;wasmedge/wasmedge.h&gt;
#include &lt;stdio.h&gt;
int main() {
  printf(&quot;WasmEdge version: %s\n&quot;, WasmEdge_VersionGet());
  return 0;
}
</code></pre>
</li>
<li>
<p>Compile the file with <code>gcc</code> or <code>clang</code>.</p>
<pre><code class="language-bash">$ gcc test.c -lwasmedge_c
</code></pre>
</li>
<li>
<p>Run and get the expected output.</p>
<pre><code class="language-bash">$ ./a.out
WasmEdge version: 0.9.0
</code></pre>
</li>
</ol>
<h2 id="wasmedge-basics"><a class="header" href="#wasmedge-basics">WasmEdge Basics</a></h2>
<p>In this partition, we will introduce the utilities and concepts of WasmEdge shared library.</p>
<h3 id="version"><a class="header" href="#version">Version</a></h3>
<p>The <code>Version</code> related APIs provide developers to check for the WasmEdge shared library version.</p>
<pre><code class="language-c">#include &lt;wasmedge/wasmedge.h&gt;
printf(&quot;WasmEdge version: %s\n&quot;, WasmEdge_VersionGet());
printf(&quot;WasmEdge version major: %u\n&quot;, WasmEdge_VersionGetMajor());
printf(&quot;WasmEdge version minor: %u\n&quot;, WasmEdge_VersionGetMinor());
printf(&quot;WasmEdge version patch: %u\n&quot;, WasmEdge_VersionGetPatch());
</code></pre>
<h3 id="logging-settings"><a class="header" href="#logging-settings">Logging Settings</a></h3>
<p>The <code>WasmEdge_LogSetErrorLevel()</code> and <code>WasmEdge_LogSetDebugLevel()</code> APIs can set the logging system to debug level or error level. By default, the error level is set, and the debug info is hidden.</p>
<h3 id="value-types"><a class="header" href="#value-types">Value Types</a></h3>
<p>In WasmEdge, developers should convert the values to <code>WasmEdge_Value</code> objects through APIs for matching to the WASM value types.</p>
<ol>
<li>
<p>Number types: <code>i32</code>, <code>i64</code>, <code>f32</code>, <code>f64</code>, and <code>v128</code> for the <code>SIMD</code> proposal</p>
<pre><code class="language-c">WasmEdge_Value Val;
Val = WasmEdge_ValueGenI32(123456);
printf(&quot;%d\n&quot;, WasmEdge_ValueGetI32(Val));
/* Will print &quot;123456&quot; */
Val = WasmEdge_ValueGenI64(1234567890123LL);
printf(&quot;%ld\n&quot;, WasmEdge_ValueGetI64(Val));
/* Will print &quot;1234567890123&quot; */
Val = WasmEdge_ValueGenF32(123.456f);
printf(&quot;%f\n&quot;, WasmEdge_ValueGetF32(Val));
/* Will print &quot;123.456001&quot; */
Val = WasmEdge_ValueGenF64(123456.123456789);
printf(&quot;%.10f\n&quot;, WasmEdge_ValueGetF64(Val));
/* Will print &quot;123456.1234567890&quot; */
</code></pre>
</li>
<li>
<p>Reference types: <code>funcref</code> and <code>externref</code> for the <code>Reference-Types</code> proposal</p>
<pre><code class="language-c">WasmEdge_Value Val;
void *Ptr;
bool IsNull;
uint32_t Num = 10;
/* Genreate a externref to NULL. */
Val = WasmEdge_ValueGenNullRef(WasmEdge_RefType_ExternRef);
IsNull = WasmEdge_ValueIsNullRef(Val);
/* The `IsNull` will be `TRUE`. */
Ptr = WasmEdge_ValueGetExternRef(Val);
/* The `Ptr` will be `NULL`. */

/* Genreate a funcref with function index 20. */
Val = WasmEdge_ValueGenFuncRef(20);
uint32_t FuncIdx = WasmEdge_ValueGetFuncIdx(Val);
/* The `FuncIdx` will be 20. */

/* Genreate a externref to `Num`. */
Val = WasmEdge_ValueGenExternRef(&amp;Num);
Ptr = WasmEdge_ValueGetExternRef(Val);
/* The `Ptr` will be `&amp;Num`. */
printf(&quot;%u\n&quot;, *(uint32_t *)Ptr);
/* Will print &quot;10&quot; */
Num += 55;
printf(&quot;%u\n&quot;, *(uint32_t *)Ptr);
/* Will print &quot;65&quot; */
</code></pre>
</li>
</ol>
<h3 id="strings"><a class="header" href="#strings">Strings</a></h3>
<p>The <code>WasmEdge_String</code> object is for the instance names when invoking a WASM function or finding the contexts of instances.</p>
<ol>
<li>
<p>Create a <code>WasmEdge_String</code> from a C string (<code>const char *</code> with NULL termination) or a buffer with length.</p>
<p>The content of the C string or buffer will be copied into the <code>WasmEdge_String</code> object.</p>
<pre><code class="language-c">char Buf[4] = {50, 55, 60, 65};
WasmEdge_String Str1 = WasmEdge_StringCreateByCString(&quot;test&quot;);
WasmEdge_String Str2 = WasmEdge_StringCreateByBuffer(Buf, 4);
/* The objects should be deleted by `WasmEdge_StringDelete()`. */
WasmEdge_StringDelete(Str1);
WasmEdge_StringDelete(Str2);
</code></pre>
</li>
<li>
<p>Wrap a <code>WasmEdge_String</code> to a buffer with length.</p>
<p>The content will not be copied, and the caller should guarantee the life cycle of the input buffer.</p>
<pre><code class="language-c">const char CStr[] = &quot;test&quot;;
WasmEdge_String Str = WasmEdge_StringWrap(CStr, 4);
/* The object should __NOT__ be deleted by `WasmEdge_StringDelete()`. */
</code></pre>
</li>
<li>
<p>String comparison</p>
<pre><code class="language-c">const char CStr[] = &quot;abcd&quot;;
char Buf[4] = {0x61, 0x62, 0x63, 0x64};
WasmEdge_String Str1 = WasmEdge_StringWrap(CStr, 4);
WasmEdge_String Str2 = WasmEdge_StringCreateByBuffer(Buf, 4);
bool IsEq = WasmEdge_StringIsEqual(Str1, Str2);
/* The `IsEq` will be `TRUE`. */
WasmEdge_StringDelete(Str2);
</code></pre>
</li>
<li>
<p>Convert to C string</p>
<pre><code class="language-c">char Buf[256];
WasmEdge_String Str = WasmEdge_StringCreateByCString(&quot;test_wasmedge_string&quot;);
uint32_t StrLength = WasmEdge_StringCopy(Str, Buf, sizeof(Buf));
/* StrLength will be 20 */
printf(&quot;String: %s\n&quot;, Buf);
/* Will print &quot;test_wasmedge_string&quot;. */
</code></pre>
</li>
</ol>
<h3 id="results"><a class="header" href="#results">Results</a></h3>
<p>The <code>WasmEdge_Result</code> object specifies the execution status.
APIs about WASM execution will return the <code>WasmEdge_Result</code> to denote the status.</p>
<pre><code class="language-c">WasmEdge_Result Res = WasmEdge_Result_Success;
bool IsSucceeded = WasmEdge_ResultOK(Res);
/* The `IsSucceeded` will be `TRUE`. */
uint32_t Code = WasmEdge_ResultGetCode(Res);
/* The `Code` will be 0. */
const char *Msg = WasmEdge_ResultGetMessage(Res);
/* The `Msg` will be &quot;success&quot;. */
</code></pre>
<h3 id="contexts"><a class="header" href="#contexts">Contexts</a></h3>
<p>The objects, such as <code>VM</code>, <code>Store</code>, and <code>Function</code>, are composed of <code>Context</code>s.
All of the contexts can be created by calling the corresponding creation APIs and should be destroyed by calling the corresponding deletion APIs. Developers have responsibilities to manage the contexts for memory management.</p>
<pre><code class="language-c">/* Create the configure context. */
WasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();
/* Delete the configure context. */
WasmEdge_ConfigureDelete(ConfCxt);
</code></pre>
<p>The details of other contexts will be introduced later.</p>
<h3 id="wasm-data-structures"><a class="header" href="#wasm-data-structures">WASM Data Structures</a></h3>
<p>The WASM data structures are used for creating instances or can be queried from instance contexts.
The details of instances creation will be introduced in the <a href="embed/c/ref.html#Instances">Instances</a>.</p>
<ol>
<li>
<p>Limit</p>
<p>The <code>WasmEdge_Limit</code> struct is defined in the header:</p>
<pre><code class="language-c">/// Struct of WASM limit.
typedef struct WasmEdge_Limit {
  /// Boolean to describe has max value or not.
  bool HasMax;
  /// Minimum value.
  uint32_t Min;
  /// Maximum value. Will be ignored if the `HasMax` is false.
  uint32_t Max;
} WasmEdge_Limit;
</code></pre>
<p>Developers can initialize the struct by assigning it's value, and the <code>Max</code> value is needed to be larger or equal to the <code>Min</code> value.
The API <code>WasmEdge_LimitIsEqual()</code> is provided to compare with 2 <code>WasmEdge_Limit</code> structs.</p>
</li>
<li>
<p>Function type context</p>
<p>The <code>Function Type</code> context is used for the <code>Function</code> creation, checking the value types of a <code>Function</code> instance, or getting the function type with function name from VM. Developers can use the <code>Function Type</code> context APIs to get the parameter or return value types information.</p>
<pre><code class="language-c">enum WasmEdge_ValType ParamList[2] = { WasmEdge_ValType_I32, WasmEdge_ValType_I64 };
enum WasmEdge_ValType ReturnList[1] = { WasmEdge_ValType_FuncRef };
WasmEdge_FunctionTypeContext *FuncTypeCxt = WasmEdge_FunctionTypeCreate(ParamList, 2, ReturnList, 1);

enum WasmEdge_ValType Buf[16];
uint32_t ParamLen = WasmEdge_FunctionTypeGetParametersLength(FuncTypeCxt);
/* `ParamLen` will be 2. */
uint32_t GotParamLen = WasmEdge_FunctionTypeGetParameters(FuncTypeCxt, Buf, 16);
/* `GotParamLen` will be 2, and `Buf[0]` and `Buf[1]` will be the same as `ParamList`. */
uint32_t ReturnLen = WasmEdge_FunctionTypeGetReturnsLength(FuncTypeCxt);
/* `ReturnLen` will be 1. */
uint32_t GotReturnLen = WasmEdge_FunctionTypeGetReturns(FuncTypeCxt, Buf, 16);
/* `GotReturnLen` will be 1, and `Buf[0]` will be the same as `ReturnList`. */

WasmEdge_FunctionTypeDelete(FuncTypeCxt);
</code></pre>
</li>
<li>
<p>Table type context</p>
<p>The <code>Table Type</code> context is used for <code>Table</code> instance creation or getting information from <code>Table</code> instances.</p>
<pre><code class="language-c">WasmEdge_Limit TabLim = {.HasMax = true, .Min = 10, .Max = 20};
WasmEdge_TableTypeContext *TabTypeCxt = WasmEdge_TableTypeCreate(WasmEdge_RefType_ExternRef, TabLim);

enum WasmEdge_RefType GotRefType = WasmEdge_TableTypeGetRefType(TabTypeCxt);
/* `GotRefType` will be WasmEdge_RefType_ExternRef. */
WasmEdge_Limit GotTabLim = WasmEdge_TableTypeGetLimit(TabTypeCxt);
/* `GotTabLim` will be the same value as `TabLim`. */

WasmEdge_TableTypeDelete(TabTypeCxt);
</code></pre>
</li>
<li>
<p>Memory type context</p>
<p>The <code>Memory Type</code> context is used for <code>Memory</code> instance creation or getting information from <code>Memory</code> instances.</p>
<pre><code class="language-c">WasmEdge_Limit MemLim = {.HasMax = true, .Min = 10, .Max = 20};
WasmEdge_MemoryTypeContext *MemTypeCxt = WasmEdge_MemoryTypeCreate(MemLim);

WasmEdge_Limit GotMemLim = WasmEdge_MemoryTypeGetLimit(MemTypeCxt);
/* `GotMemLim` will be the same value as `MemLim`. */

WasmEdge_MemoryTypeDelete(MemTypeCxt)
</code></pre>
</li>
<li>
<p>Global type context</p>
<p>The <code>Global Type</code> context is used for <code>Global</code> instance creation or getting information from <code>Global</code> instances.</p>
<pre><code class="language-c">WasmEdge_GlobalTypeContext *GlobTypeCxt = WasmEdge_GlobalTypeCreate(WasmEdge_ValType_F64, WasmEdge_Mutability_Var);

WasmEdge_ValType GotValType = WasmEdge_GlobalTypeGetValType(GlobTypeCxt);
/* `GotValType` will be WasmEdge_ValType_F64. */
WasmEdge_Mutability GotValMut = WasmEdge_GlobalTypeGetMutability(GlobTypeCxt);
/* `GotValMut` will be WasmEdge_Mutability_Var. */

WasmEdge_GlobalTypeDelete(GlobTypeCxt);
</code></pre>
</li>
<li>
<p>Import type context</p>
<p>The <code>Import Type</code> context is used for getting the imports information from a <a href="embed/c/ref.html#AST-Module">AST Module</a>.
Developers can get the external type (<code>function</code>, <code>table</code>, <code>memory</code>, or <code>global</code>), import module name, and external name from an <code>Import Type</code> context.
The details about querying <code>Import Type</code> contexts will be introduced in the <a href="embed/c/ref.html#AST-Module">AST Module</a>.</p>
<pre><code class="language-c">WasmEdge_ASTModuleContext *ASTCxt = ...;
/* Assume that `ASTCxt` is returned by the `WasmEdge_LoaderContext` for the result of loading a WASM file. */
const WasmEdge_ImportTypeContext *ImpType = ...;
/* Assume that `ImpType` is queried from the `ASTCxt` for the import. */

enum WasmEdge_ExternalType ExtType = WasmEdge_ImportTypeGetExternalType(ImpType);
/*
 * The `ExtType` can be one of `WasmEdge_ExternalType_Function`, `WasmEdge_ExternalType_Table`,
 * `WasmEdge_ExternalType_Memory`, or `WasmEdge_ExternalType_Global`.
 */
WasmEdge_String ModName = WasmEdge_ImportTypeGetModuleName(ImpType);
WasmEdge_String ExtName = WasmEdge_ImportTypeGetExternalName(ImpType);
/* The `ModName` and `ExtName` should not be destroyed and the string buffers are binded into the `ASTCxt`. */
const WasmEdge_FunctionTypeContext *FuncTypeCxt = WasmEdge_ImportTypeGetFunctionType(ASTCxt, ImpType);
/* If the `ExtType` is not `WasmEdge_ExternalType_Function`, the `FuncTypeCxt` will be NULL. */
const WasmEdge_TableTypeContext *TabTypeCxt = WasmEdge_ImportTypeGetTableType(ASTCxt, ImpType);
/* If the `ExtType` is not `WasmEdge_ExternalType_Table`, the `TabTypeCxt` will be NULL. */
const WasmEdge_MemoryTypeContext *MemTypeCxt = WasmEdge_ImportTypeGetMemoryType(ASTCxt, ImpType);
/* If the `ExtType` is not `WasmEdge_ExternalType_Memory`, the `MemTypeCxt` will be NULL. */
const WasmEdge_GlobalTypeContext *GlobTypeCxt = WasmEdge_ImportTypeGetGlobalType(ASTCxt, ImpType);
/* If the `ExtType` is not `WasmEdge_ExternalType_Global`, the `GlobTypeCxt` will be NULL. */
</code></pre>
</li>
<li>
<p>Export type context</p>
<p>The <code>Export Type</code> context is used for getting the exports information from a <a href="embed/c/ref.html#AST-Module">AST Module</a>.
Developers can get the external type (<code>function</code>, <code>table</code>, <code>memory</code>, or <code>global</code>) and external name from an <code>Export Type</code> context.
The details about querying <code>Export Type</code> contexts will be introduced in the <a href="embed/c/ref.html#AST-Module">AST Module</a>.</p>
<pre><code class="language-c">WasmEdge_ASTModuleContext *ASTCxt = ...;
/* Assume that `ASTCxt` is returned by the `WasmEdge_LoaderContext` for the result of loading a WASM file. */
const WasmEdge_ExportTypeContext *ExpType = ...;
/* Assume that `ExpType` is queried from the `ASTCxt` for the export. */

enum WasmEdge_ExternalType ExtType = WasmEdge_ExportTypeGetExternalType(ExpType);
/*
 * The `ExtType` can be one of `WasmEdge_ExternalType_Function`, `WasmEdge_ExternalType_Table`,
 * `WasmEdge_ExternalType_Memory`, or `WasmEdge_ExternalType_Global`.
 */
WasmEdge_String ExtName = WasmEdge_ExportTypeGetExternalName(ExpType);
/* The `ExtName` should not be destroyed and the string buffer is binded into the `ASTCxt`. */
const WasmEdge_FunctionTypeContext *FuncTypeCxt = WasmEdge_ExportTypeGetFunctionType(ASTCxt, ExpType);
/* If the `ExtType` is not `WasmEdge_ExternalType_Function`, the `FuncTypeCxt` will be NULL. */
const WasmEdge_TableTypeContext *TabTypeCxt = WasmEdge_ExportTypeGetTableType(ASTCxt, ExpType);
/* If the `ExtType` is not `WasmEdge_ExternalType_Table`, the `TabTypeCxt` will be NULL. */
const WasmEdge_MemoryTypeContext *MemTypeCxt = WasmEdge_ExportTypeGetMemoryType(ASTCxt, ExpType);
/* If the `ExtType` is not `WasmEdge_ExternalType_Memory`, the `MemTypeCxt` will be NULL. */
const WasmEdge_GlobalTypeContext *GlobTypeCxt = WasmEdge_ExportTypeGetGlobalType(ASTCxt, ExpType);
/* If the `ExtType` is not `WasmEdge_ExternalType_Global`, the `GlobTypeCxt` will be NULL. */
</code></pre>
</li>
</ol>
<h3 id="configurations"><a class="header" href="#configurations">Configurations</a></h3>
<p>The configuration context, <code>WasmEdge_ConfigureContext</code>, manages the configurations for <code>Loader</code>, <code>Validator</code>, <code>Executor</code>, <code>VM</code>, and <code>Compiler</code>.
Developers can adjust the settings about the proposals, VM host pre-registrations (such as <code>WASI</code>), and AOT compiler options, and then apply the <code>Configure</code> context to create other runtime contexts.</p>
<ol>
<li>
<p>Proposals</p>
<p>WasmEdge supports turning on or off the WebAssembly proposals.
This configuration is effective in any contexts created with the <code>Configure</code> context.</p>
<pre><code class="language-c">enum WasmEdge_Proposal {
  WasmEdge_Proposal_ImportExportMutGlobals = 0,
  WasmEdge_Proposal_NonTrapFloatToIntConversions,
  WasmEdge_Proposal_SignExtensionOperators,
  WasmEdge_Proposal_MultiValue,
  WasmEdge_Proposal_BulkMemoryOperations,
  WasmEdge_Proposal_ReferenceTypes,
  WasmEdge_Proposal_SIMD,
  WasmEdge_Proposal_TailCall,
  WasmEdge_Proposal_Annotations,
  WasmEdge_Proposal_Memory64,
  WasmEdge_Proposal_Threads,
  WasmEdge_Proposal_ExceptionHandling,
  WasmEdge_Proposal_FunctionReferences
};
</code></pre>
<p>Developers can add or remove the proposals into the <code>Configure</code> context.</p>
<pre><code class="language-c">/* 
 * By default, the following proposals have turned on initially:
 * * Import/Export of mutable globals
 * * Non-trapping float-to-int conversions
 * * Sign-extension operators
 * * Multi-value returns
 * * Bulk memory operations
 * * Reference types
 * * Fixed-width SIMD
 */
WasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();
WasmEdge_ConfigureAddProposal(ConfCxt, WasmEdge_Proposal_SIMD);
WasmEdge_ConfigureRemoveProposal(ConfCxt, WasmEdge_Proposal_ReferenceTypes);
bool IsBulkMem = WasmEdge_ConfigureHasProposal(ConfCxt, WasmEdge_Proposal_BulkMemoryOperations);
/* The `IsBulkMem` will be `TRUE`. */
WasmEdge_ConfigureDelete(ConfCxt);
</code></pre>
</li>
<li>
<p>Host registrations</p>
<p>This configuration is used for the <code>VM</code> context to turn on the <code>WASI</code> or <code>wasmedge_process</code> supports and only effective in <code>VM</code> contexts.</p>
<pre><code class="language-c">enum WasmEdge_HostRegistration {
  WasmEdge_HostRegistration_Wasi = 0,
  WasmEdge_HostRegistration_WasmEdge_Process
};
</code></pre>
<p>The details will be introduced in the <a href="embed/c/ref.html###Preregistrations">preregistrations of VM context</a>.</p>
<pre><code class="language-c">WasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();
bool IsHostWasi = WasmEdge_ConfigureHasHostRegistration(ConfCxt, WasmEdge_HostRegistration_Wasi);
/* The `IsHostWasi` will be `FALSE`. */
WasmEdge_ConfigureAddHostRegistration(ConfCxt, WasmEdge_HostRegistration_Wasi);
IsHostWasi = WasmEdge_ConfigureHasHostRegistration(ConfCxt, WasmEdge_HostRegistration_Wasi);
/* The `IsHostWasi` will be `TRUE`. */
WasmEdge_ConfigureDelete(ConfCxt);
</code></pre>
</li>
<li>
<p>Maximum memory pages</p>
<p>Developers can limit the page size of memory instances by this configuration.
When growing the page size of memory instances in WASM execution and exceeding the limited size, the page growing will fail.
This configuration is only effective in the <code>Executor</code> and <code>VM</code> contexts.</p>
<pre><code class="language-c">WasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();
uint32_t PageSize = WasmEdge_ConfigureGetMaxMemoryPage(ConfCxt);
/* By default, the maximum memory page size is 65536. */
WasmEdge_ConfigureSetMaxMemoryPage(ConfCxt, 1024);
/* Limit the memory size of each memory instance with not larger than 1024 pages (64 MiB). */
PageSize = WasmEdge_ConfigureGetMaxMemoryPage(ConfCxt);
/* The `PageSize` will be 1024. */
WasmEdge_ConfigureDelete(ConfCxt);
</code></pre>
</li>
<li>
<p>AOT compiler options</p>
<p>The AOT compiler options configure the behavior about optimization level, output format, dump IR, and generic binary.</p>
<pre><code class="language-c">enum WasmEdge_CompilerOptimizationLevel {
  /// Disable as many optimizations as possible.
  WasmEdge_CompilerOptimizationLevel_O0 = 0,
  /// Optimize quickly without destroying debuggability.
  WasmEdge_CompilerOptimizationLevel_O1,
  /// Optimize for fast execution as much as possible without triggering
  /// significant incremental compile time or code size growth.
  WasmEdge_CompilerOptimizationLevel_O2,
  /// Optimize for fast execution as much as possible.
  WasmEdge_CompilerOptimizationLevel_O3,
  /// Optimize for small code size as much as possible without triggering
  /// significant incremental compile time or execution time slowdowns.
  WasmEdge_CompilerOptimizationLevel_Os,
  /// Optimize for small code size as much as possible.
  WasmEdge_CompilerOptimizationLevel_Oz
};

enum WasmEdge_CompilerOutputFormat {
  /// Native dynamic library format.
  WasmEdge_CompilerOutputFormat_Native = 0,
  /// WebAssembly with AOT compiled codes in custom section.
  WasmEdge_CompilerOutputFormat_Wasm
};
</code></pre>
<p>These configurations are only effective in <code>Compiler</code> contexts.</p>
<pre><code class="language-c">WasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();
/* By default, the optimization level is O3. */
WasmEdge_ConfigureCompilerSetOptimizationLevel(ConfCxt, WasmEdge_CompilerOptimizationLevel_O2);
/* By default, the output format is universal WASM. */
WasmEdge_ConfigureCompilerSetOutputFormat(ConfCxt, WasmEdge_CompilerOutputFormat_Native);
/* By default, the dump IR is `FALSE`. */
WasmEdge_ConfigureCompilerSetDumpIR(ConfCxt, TRUE);
/* By default, the generic binary is `FALSE`. */
WasmEdge_ConfigureCompilerSetGenericBinary(ConfCxt, TRUE);
WasmEdge_ConfigureDelete(ConfCxt);
</code></pre>
</li>
<li>
<p>Statistics options</p>
<p>The statistics options configure the behavior about instruction counting, cost measuring, and time measuring in both runtime and AOT compiler.
These configurations are effective in <code>Compiler</code>, <code>VM</code>, and <code>Executor</code> contexts.</p>
<pre><code class="language-c">WasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();
/* By default, the intruction counting is `FALSE` when running a compiled-WASM or a pure-WASM. */
WasmEdge_ConfigureStatisticsSetInstructionCounting(ConfCxt, TRUE);
/* By default, the cost measurement is `FALSE` when running a compiled-WASM or a pure-WASM. */
WasmEdge_ConfigureStatisticsSetCostMeasuring(ConfCxt, TRUE);
/* By default, the time measurement is `FALSE` when running a compiled-WASM or a pure-WASM. */
WasmEdge_ConfigureStatisticsSetTimeMeasuring(ConfCxt, TRUE);
WasmEdge_ConfigureDelete(ConfCxt);
</code></pre>
</li>
</ol>
<h3 id="statistics"><a class="header" href="#statistics">Statistics</a></h3>
<p>The statistics context, <code>WasmEdge_StatisticsContext</code>, provides the instruction counter, cost summation, and cost limitation at runtime.</p>
<p>Before using statistics, the statistics configuration must be set. Otherwise, the return values of calling statistics are undefined behaviour.</p>
<ol>
<li>
<p>Instruction counter</p>
<p>The instruction counter can help developers to profile the performance of WASM running.
Developers can retrieve the <code>Statistics</code> context from the <code>VM</code> context, or create a new one for the <code>Executor</code> creation.
The details will be introduced in the next partitions.</p>
<pre><code class="language-c">WasmEdge_StatisticsContext *StatCxt = WasmEdge_StatisticsCreate();
/* ....
 * After running the WASM functions with the `Statistics` context
 */
uint32_t Count = WasmEdge_StatisticsGetInstrCount(StatCxt);
double IPS = WasmEdge_StatisticsGetInstrPerSecond(StatCxt);
WasmEdge_StatisticsDelete(StatCxt);
</code></pre>
</li>
<li>
<p>Cost table</p>
<p>The cost table is to accumulate the cost of instructions with their weights.
Developers can set the cost table array (the indices are the byte code value of instructions, and the values are the cost of instructions) into the <code>Statistics</code> context.
If the cost limit value is set, the execution will return the <code>cost limit exceeded</code> error immediately when exceeds the cost limit in runtime.</p>
<pre><code class="language-c">WasmEdge_StatisticsContext *StatCxt = WasmEdge_StatisticsCreate();
uint64_t CostTable[16] = {
  0, 0,
  10, /* 0x02: Block */
  11, /* 0x03: Loop */
  12, /* 0x04: If */
  12, /* 0x05: Else */
  0, 0, 0, 0, 0, 0, 
  20, /* 0x0C: Br */
  21, /* 0x0D: Br_if */
  22, /* 0x0E: Br_table */
  0
};
/* Developers can set the costs of each instruction. The value not covered will be 0. */
WasmEdge_StatisticsSetCostTable(StatCxt, CostTable, 16);
WasmEdge_StatisticsSetCostLimit(StatCxt, 5000000);
/* ....
 * After running the WASM functions with the `Statistics` context
 */
uint64_t Cost = WasmEdge_StatisticsGetTotalCost(StatCxt);
WasmEdge_StatisticsDelete(StatCxt);
</code></pre>
</li>
</ol>
<h2 id="wasmedge-vm"><a class="header" href="#wasmedge-vm">WasmEdge VM</a></h2>
<p>In this partition, we will introduce the functions of <code>WasmEdge_VMContext</code> object and show examples of executing WASM functions.</p>
<h3 id="wasm-execution-example-with-vm-context"><a class="header" href="#wasm-execution-example-with-vm-context">WASM Execution Example With VM Context</a></h3>
<p>The following shows the example of running the WASM for getting the Fibonacci.
This example uses the <a href="embed/c/../tools/wasmedge/examples/fibonacci.wasm">fibonacci.wasm</a>, and the corresponding WAT file is at <a href="embed/c/../tools/wasmedge/examples/fibonacci.wat">fibonacci.wat</a>.</p>
<pre><code>(module
 (export &quot;fib&quot; (func $fib))
 (func $fib (param $n i32) (result i32)
  (if
   (i32.lt_s (get_local $n)(i32.const 2))
   (return (i32.const 1))
  )
  (return
   (i32.add
    (call $fib (i32.sub (get_local $n)(i32.const 2)))
    (call $fib (i32.sub (get_local $n)(i32.const 1)))
   )
  )
 )
)
</code></pre>
<ol>
<li>
<p>Run WASM functions rapidly</p>
<p>Assume that the WASM file <a href="embed/c/../tools/wasmedge/examples/fibonacci.wasm"><code>fibonacci.wasm</code></a> is copied into the current directory, and the C file <code>test.c</code> is as following:</p>
<pre><code class="language-c">#include &lt;wasmedge/wasmedge.h&gt;
#include &lt;stdio.h&gt;
int main() {
  /* Create the configure context and add the WASI support. */
  /* This step is not necessary unless you need WASI support. */
  WasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();
  WasmEdge_ConfigureAddHostRegistration(ConfCxt, WasmEdge_HostRegistration_Wasi);
  /* The configure and store context to the VM creation can be NULL. */
  WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(ConfCxt, NULL);

  /* The parameters and returns arrays. */
  WasmEdge_Value Params[1] = { WasmEdge_ValueGenI32(5) };
  WasmEdge_Value Returns[1];
  /* Function name. */
  WasmEdge_String FuncName = WasmEdge_StringCreateByCString(&quot;fib&quot;);
  /* Run the WASM function from file. */
  WasmEdge_Result Res = WasmEdge_VMRunWasmFromFile(VMCxt, &quot;fibonacci.wasm&quot;, FuncName, Params, 1, Returns, 1);
  /* 
   * Developers can run the WASM binary from buffer with the `WasmEdge_VMRunWasmFromBuffer()` API,
   * or from `WasmEdge_ASTModuleContext` object with the `WasmEdge_VMRunWasmFromASTModule()` API.
   */

  if (WasmEdge_ResultOK(Res)) {
    printf(&quot;Get the result: %d\n&quot;, WasmEdge_ValueGetI32(Returns[0]));
  } else {
    printf(&quot;Error message: %s\n&quot;, WasmEdge_ResultGetMessage(Res));
  }

  /* Resources deallocations. */
  WasmEdge_VMDelete(VMCxt);
  WasmEdge_ConfigureDelete(ConfCxt);
  WasmEdge_StringDelete(FuncName);
  return 0;
}
</code></pre>
<p>Then you can compile and run: (the 5th Fibonacci number is 8 in 0-based index)</p>
<pre><code class="language-bash">$ gcc test.c -lwasmedge_c
$ ./a.out
Get the result: 8
</code></pre>
</li>
<li>
<p>Instantiate and run WASM functions manually</p>
<p>Besides the above example, developers can run the WASM functions step-by-step with <code>VM</code> context APIs:</p>
<pre><code class="language-c">#include &lt;wasmedge/wasmedge.h&gt;
#include &lt;stdio.h&gt;
int main() {
  /* Create the configure context and add the WASI support. */
  /* This step is not necessary unless you need the WASI support. */
  WasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();
  WasmEdge_ConfigureAddHostRegistration(ConfCxt, WasmEdge_HostRegistration_Wasi);
  /* The configure and store context to the VM creation can be NULL. */
  WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(ConfCxt, NULL);

  /* The parameters and returns arrays. */
  WasmEdge_Value Params[1] = { WasmEdge_ValueGenI32(10) };
  WasmEdge_Value Returns[1];
  /* Function name. */
  WasmEdge_String FuncName = WasmEdge_StringCreateByCString(&quot;fib&quot;);
  /* Result. */
  WasmEdge_Result Res;
  
  /* Step 1: Load WASM file. */
  Res = WasmEdge_VMLoadWasmFromFile(VMCxt, &quot;fibonacci.wasm&quot;);
  /* 
   * Developers can load the WASM binary from buffer with the `WasmEdge_VMLoadWasmFromBuffer()` API,
   * or from `WasmEdge_ASTModuleContext` object with the `WasmEdge_VMLoadWasmFromASTModule()` API.
   */
  if (!WasmEdge_ResultOK(Res)) {
    printf(&quot;Loading phase failed: %s\n&quot;, WasmEdge_ResultGetMessage(Res));
    return 1;
  }
  /* Step 2: Validate the WASM module. */
  Res = WasmEdge_VMValidate(VMCxt);
  if (!WasmEdge_ResultOK(Res)) {
    printf(&quot;Validation phase failed: %s\n&quot;, WasmEdge_ResultGetMessage(Res));
    return 1;
  }
  /* Step 3: Instantiate the WASM module. */
  Res = WasmEdge_VMInstantiate(VMCxt);
  /* 
   * Developers can load, validate, and instantiate another WASM module to replace the
   * instantiated one. In this case, the old module will be cleared, but the registered
   * modules are still kept.
   */
  if (!WasmEdge_ResultOK(Res)) {
    printf(&quot;Instantiation phase failed: %s\n&quot;, WasmEdge_ResultGetMessage(Res));
    return 1;
  }
  /* Step 4: Execute WASM functions. You can execute functions repeatedly after instantiation. */
  Res = WasmEdge_VMExecute(VMCxt, FuncName, Params, 1, Returns, 1);
  if (WasmEdge_ResultOK(Res)) {
    printf(&quot;Get the result: %d\n&quot;, WasmEdge_ValueGetI32(Returns[0]));
  } else {
    printf(&quot;Execution phase failed: %s\n&quot;, WasmEdge_ResultGetMessage(Res));
  }
  return 0;
}
</code></pre>
<p>Then you can compile and run: (the 10th Fibonacci number is 89 in 0-based index)</p>
<pre><code class="language-bash">$ gcc test.c -lwasmedge_c
$ ./a.out
Get the result: 89
</code></pre>
<p>The following graph explains the status of the <code>VM</code> context.</p>
<pre><code>                       |========================|
              |-------&gt;|      VM: Initiated     |
              |        |========================|
              |                    |
              |                 LoadWasm
              |                    |
              |                    v
              |        |========================|
              |--------|       VM: Loaded       |&lt;-------|
              |        |========================|        |
              |              |            ^              |
              |         Validate          |              |
          Cleanup            |          LoadWasm         |
              |              v            |            LoadWasm
              |        |========================|        |
              |--------|      VM: Validated     |        |
              |        |========================|        |
              |              |            ^              |
              |      Instantiate          |              |
              |              |          RegisterModule   |
              |              v            |              |
              |        |========================|        |
              |--------|    VM: Instantiated    |--------|
                       |========================|
                             |            ^
                             |            |
                             --------------
                Instantiate, Execute, ExecuteRegistered
</code></pre>
<p>The status of the <code>VM</code> context would be <code>Inited</code> when created.
After loading WASM successfully, the status will be <code>Loaded</code>.
After validating WASM successfully, the status will be <code>Validated</code>.
After instantiating WASM successfully, the status will be <code>Instantiated</code>, and developers can invoke functions.
Developers can register WASM or import objects in any status, but they should instantiate WASM again.
Developers can also load WASM in any status, and they should validate and instantiate the WASM module before function invocation.
When in the <code>Instantiated</code> status, developers can instantiate the WASM module again to reset the old WASM runtime structures.</p>
</li>
</ol>
<h3 id="vm-creations"><a class="header" href="#vm-creations">VM Creations</a></h3>
<p>The <code>VM</code> creation API accepts the <code>Configure</code> context and the <code>Store</code> context.
If developers only need the default settings, just pass <code>NULL</code> to the creation API.
The details of the <code>Store</code> context will be introduced in <a href="embed/c/ref.html#Store">Store</a>.</p>
<pre><code class="language-c">WasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();
WasmEdge_StoreContext *StoreCxt = WasmEdge_StoreCreate();
WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(ConfCxt, StoreCxt);
/* The caller should guarantee the life cycle if the store context. */
WasmEdge_StatisticsContext *StatCxt = WasmEdge_VMGetStatisticsContext(VMCxt);
/* The VM context already contains the statistics context and can be retrieved by this API. */
/* 
 * Note that the retrieved store and statistics contexts from the VM contexts by VM APIs
 * should __NOT__ be destroyed and owned by the VM contexts.
 */
WasmEdge_VMDelete(VMCxt);
WasmEdge_StoreDelete(StoreCxt);
WasmEdge_ConfigureDelete(ConfCxt);
</code></pre>
<h3 id="preregistrations"><a class="header" href="#preregistrations">Preregistrations</a></h3>
<p>WasmEdge provides the following built-in pre-registrations.</p>
<ol>
<li>
<p><a href="https://github.com/WebAssembly/WASI">WASI (WebAssembly System Interface)</a></p>
<p>Developers can turn on the WASI support for VM in the <code>Configure</code> context.</p>
<pre><code class="language-c">WasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();
WasmEdge_ConfigureAddHostRegistration(ConfCxt, WasmEdge_HostRegistration_Wasi);
WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(ConfCxt, NULL);
/* The following API can retrieve the pre-registration import objects from the VM context. */
/* This API will return `NULL` if the corresponding pre-registration is not set into the configuration. */
WasmEdge_ImportObjectContext *WasiObject =
  WasmEdge_VMGetImportModuleContext(VMCxt, WasmEdge_HostRegistration_Wasi);
/* Initialize the WASI. */
WasmEdge_ImportObjectInitWASI(WasiObject, /* ... ignored */ );
WasmEdge_VMDelete(VMCxt);
WasmEdge_ConfigureDelete(ConfCxt);
</code></pre>
<p>And also can create the WASI import object from API. The details will be introduced in the <a href="embed/c/ref.html#Host-Functions">Host Functions</a> and the <a href="embed/c/ref.html#Host-Module-Registrations">Host Module Registrations</a>.</p>
</li>
<li>
<p><a href="https://crates.io/crates/wasmedge_process_interface">WasmEdge_Process</a></p>
<p>This pre-registration is for the process interface for WasmEdge on <code>Rust</code> sources.
After turning on this pre-registration, the VM will support the <code>wasmedge_process</code> host functions.</p>
<pre><code class="language-c">WasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();
WasmEdge_ConfigureAddHostRegistration(ConfCxt, WasmEdge_HostRegistration_WasmEdge_Process);
WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(ConfCxt, NULL);
/* The following API can retrieve the pre-registration import objects from the VM context. */
/* This API will return `NULL` if the corresponding pre-registration is not set into the configuration. */
WasmEdge_ImportObjectContext *ProcObject =
  WasmEdge_VMGetImportModuleContext(VMCxt, WasmEdge_HostRegistration_WasmEdge_Process);
/* Initialize the WasmEdge_Process. */
WasmEdge_ImportObjectInitWasmEdgeProcess(ProcObject, /* ... ignored */ );
WasmEdge_VMDelete(VMCxt);
WasmEdge_ConfigureDelete(ConfCxt);
</code></pre>
<p>And also can create the WasmEdge_Process import object from API. The details will be introduced in the <a href="embed/c/ref.html#Host-Functions">Host Functions</a> and the <a href="embed/c/ref.html#Host-Module-Registrations">Host Module Registrations</a>.</p>
</li>
</ol>
<h3 id="host-module-registrations"><a class="header" href="#host-module-registrations">Host Module Registrations</a></h3>
<p><a href="https://webassembly.github.io/spec/core/exec/runtime.html#syntax-hostfunc">Host functions</a> are functions outside WebAssembly and passed to WASM modules as imports.
In WasmEdge, the host functions are composed into host modules as <code>WasmEdge_ImportObjectContext</code> objects with module names.
Please refer to the <a href="embed/c/ref.html#Host-Functions">Host Functions in WasmEdge Runtime</a> for the details.
In this chapter, we show the example for registering the host modules into a <code>VM</code> context.</p>
<pre><code class="language-c">WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(NULL, NULL);
WasmEdge_ImportObjectContext *WasiObject =
  WasmEdge_ImportObjectCreateWASI( /* ... ignored ... */ );
/* You can also create and register the WASI host modules by this API. */
WasmEdge_Result Res = WasmEdge_VMRegisterModuleFromImport(VMCxt, WasiObject);
/* The result status should be checked. */
WasmEdge_ImportObjectDelete(WasiObject);
/* The created import objects should be deleted. */
WasmEdge_VMDelete(VMCxt);
</code></pre>
<h3 id="wasm-registrations-and-executions"><a class="header" href="#wasm-registrations-and-executions">WASM Registrations And Executions</a></h3>
<p>In WebAssembly, the instances in WASM modules can be exported and can be imported by other WASM modules.
WasmEdge VM provides APIs for developers to register and export any WASM modules, and execute the functions or host functions in the registered WASM modules.</p>
<ol>
<li>
<p>Register the WASM modules with exported module names</p>
<p>Unless the import objects have already contained the module names, every WASM module should be named uniquely when registering.
Assume that the WASM file <a href="embed/c/../tools/wasmedge/examples/fibonacci.wasm"><code>fibonacci.wasm</code></a> is copied into the current directory.</p>
<pre><code class="language-c">WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(NULL, NULL);
WasmEdge_String ModName = WasmEdge_StringCreateByCString(&quot;mod&quot;);
WasmEdge_Result Res = WasmEdge_VMRegisterModuleFromFile(VMCxt, ModName, &quot;fibonacci.wasm&quot;);
/* 
 * Developers can register the WASM module from buffer with the `WasmEdge_VMRegisterModuleFromBuffer()` API,
 * or from `WasmEdge_ASTModuleContext` object with the `WasmEdge_VMRegisterModuleFromASTModule()` API.
 */
/* 
 * The result status should be checked.
 * The error will occur if the WASM module instantiation failed or the module name conflicts.
 */
WasmEdge_StringDelete(ModName);
WasmEdge_VMDelete(VMCxt);
</code></pre>
</li>
<li>
<p>Execute the functions in registered WASM modules</p>
<p>Assume that the C file <code>test.c</code> is as follows:</p>
<pre><code class="language-c">#include &lt;wasmedge/wasmedge.h&gt;
#include &lt;stdio.h&gt;
int main() {
  WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(NULL, NULL);

  /* The parameters and returns arrays. */
  WasmEdge_Value Params[1] = { WasmEdge_ValueGenI32(20) };
  WasmEdge_Value Returns[1];
  /* Names. */
  WasmEdge_String ModName = WasmEdge_StringCreateByCString(&quot;mod&quot;);
  WasmEdge_String FuncName = WasmEdge_StringCreateByCString(&quot;fib&quot;);
  /* Result. */
  WasmEdge_Result Res;

  /* Register the WASM module into VM. */
  Res = WasmEdge_VMRegisterModuleFromFile(VMCxt, ModName, &quot;fibonacci.wasm&quot;);
  /* 
  * Developers can register the WASM module from buffer with the `WasmEdge_VMRegisterModuleFromBuffer()` API,
  * or from `WasmEdge_ASTModuleContext` object with the `WasmEdge_VMRegisterModuleFromASTModule()` API.
  */
  if (!WasmEdge_ResultOK(Res)) {
    printf(&quot;WASM registration failed: %s\n&quot;, WasmEdge_ResultGetMessage(Res));
    return 1;
  }
  /* 
  * The function &quot;fib&quot; in the &quot;fibonacci.wasm&quot; was exported with the module name &quot;mod&quot;.
  * As the same as host functions, other modules can import the function `&quot;mod&quot; &quot;fib&quot;`.
  */

  /* 
  * Execute WASM functions in registered modules.
  * Unlike the execution of functions, the registered functions can be invoked without
  * `WasmEdge_VMInstantiate()` because the WASM module was instantiated when registering.
  * Developers can also invoke the host functions directly with this API.
  */
  Res = WasmEdge_VMExecuteRegistered(VMCxt, ModName, FuncName, Params, 1, Returns, 1);
  if (WasmEdge_ResultOK(Res)) {
    printf(&quot;Get the result: %d\n&quot;, WasmEdge_ValueGetI32(Returns[0]));
  } else {
    printf(&quot;Execution phase failed: %s\n&quot;, WasmEdge_ResultGetMessage(Res));
  }
  WasmEdge_StringDelete(ModName);
  WasmEdge_StringDelete(FuncName);
  WasmEdge_VMDelete(VMCxt);
  return 0;
}
</code></pre>
<p>Then you can compile and run: (the 20th Fibonacci number is 89 in 0-based index)</p>
<pre><code class="language-bash">$ gcc test.c -lwasmedge_c
$ ./a.out
Get the result: 10946
</code></pre>
</li>
</ol>
<h3 id="instance-tracing"><a class="header" href="#instance-tracing">Instance Tracing</a></h3>
<p>Sometimes the developers may have requirements to get the instances of the WASM runtime.
The <code>VM</code> context supplies the APIs to retrieve the instances.</p>
<ol>
<li>
<p>Store</p>
<p>If the <code>VM</code> context is created without assigning a <code>Store</code> context, the <code>VM</code> context will allocate and own a <code>Store</code> context.</p>
<pre><code class="language-c">WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(NULL, NULL);
WasmEdge_StoreContext *StoreCxt = WasmEdge_VMGetStoreContext(VMCxt);
/* The object should __NOT__ be deleted by `WasmEdge_StoreDelete()`. */
WasmEdge_VMDelete(VMCxt);
</code></pre>
<p>Developers can also create the <code>VM</code> context with a <code>Store</code> context.
In this case, developers should guarantee the life cycle of the <code>Store</code> context.
Please refer to the <a href="embed/c/ref.html#Store">Store Contexts</a> for the details about the <code>Store</code> context APIs.</p>
<pre><code class="language-c">WasmEdge_StoreContext *StoreCxt = WasmEdge_StoreCreate();
WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(NULL, StoreCxt);
WasmEdge_StoreContext *StoreCxtMock = WasmEdge_VMGetStoreContext(VMCxt);
/* The `StoreCxt` and the `StoreCxtMock` are the same. */
WasmEdge_VMDelete(VMCxt);
WasmEdge_StoreDelete(StoreCxt);
</code></pre>
</li>
<li>
<p>List exported functions</p>
<p>After the WASM module instantiation, developers can use the <code>WasmEdge_VMExecute()</code> API to invoke the exported WASM functions. For this purpose, developers may need information about the exported WASM function list.
Please refer to the <a href="embed/c/ref.html#Instances">Instances in runtime</a> for the details about the function types.
Assume that the WASM file <a href="embed/c/../tools/wasmedge/examples/fibonacci.wasm"><code>fibonacci.wasm</code></a> is copied into the current directory, and the C file <code>test.c</code> is as following:</p>
<pre><code class="language-c">#include &lt;wasmedge/wasmedge.h&gt;
#include &lt;stdio.h&gt;
int main() {
  WasmEdge_StoreContext *StoreCxt = WasmEdge_StoreCreate();
  WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(NULL, StoreCxt);

  WasmEdge_VMLoadWasmFromFile(VMCxt, &quot;fibonacci.wasm&quot;);
  WasmEdge_VMValidate(VMCxt);
  WasmEdge_VMInstantiate(VMCxt);

  /* List the exported functions. */
  /* Get the number of exported functions. */
  uint32_t FuncNum = WasmEdge_VMGetFunctionListLength(VMCxt);
  /* Create the name buffers and the function type buffers. */
  const uint32_t BUF_LEN = 256;
  WasmEdge_String FuncNames[BUF_LEN];
  WasmEdge_FunctionTypeContext *FuncTypes[BUF_LEN];
  /* 
   * Get the export function list.
   * If the function list length is larger than the buffer length, the overflowed data will be discarded.
   * The `FuncNames` and `FuncTypes` can be NULL if developers don't need them.
   */
  uint32_t RealFuncNum = WasmEdge_VMGetFunctionList(VMCxt, FuncNames, FuncTypes, BUF_LEN);

  for (uint32_t I = 0; I &lt; RealFuncNum &amp;&amp; I &lt; BUF_LEN; I++) {
    char Buf[BUF_LEN];
    uint32_t Size = WasmEdge_StringCopy(FuncNames[I], Buf, sizeof(Buf));
    printf(&quot;Get exported function string length: %u, name: %s\n&quot;, Size, Buf);
    /* 
     * The function names should be __NOT__ destroyed.
     * The returned function type contexts should __NOT__ be destroyed.
     */
  }
  return 0;
}
</code></pre>
<p>Then you can compile and run: (the only exported function in <code>fibonacci.wasm</code> is <code>fib</code>)</p>
<pre><code class="language-bash">$ gcc test.c -lwasmedge_c
$ ./a.out
Get exported function string length: 3, name: fib
</code></pre>
<p>If developers want to get the exported function names in the registered WASM modules, please retrieve the <code>Store</code> context from the <code>VM</code> context and refer to the APIs of <a href="embed/c/ref.html#Store">Store Contexts</a> to list the registered functions by the module name.</p>
</li>
<li>
<p>Get function types</p>
<p>The <code>VM</code> context provides APIs to find the function type by function name.
Please refer to the <a href="embed/c/ref.html#Instances">Instances in runtime</a> for the details about the function types.</p>
<pre><code class="language-c">/* 
 * ...
 * Assume that a WASM module is instantiated in `VMCxt`.
 */
WasmEdge_String FuncName = WasmEdge_StringCreateByCString(&quot;fib&quot;);
const WasmEdge_FunctionTypeContext *FuncType = WasmEdge_VMGetFunctionType(VMCxt, FuncName);
/* 
 * Developers can get the function types of functions in the registered modules
 * via the `WasmEdge_VMGetFunctionTypeRegistered()` API with the module name.
 * If the function is not found, these APIs will return `NULL`.
 * The returned function type contexts should __NOT__ be destroyed.
 */
WasmEdge_StringDelete(FuncName);
</code></pre>
</li>
</ol>
<h2 id="wasmedge-runtime"><a class="header" href="#wasmedge-runtime">WasmEdge Runtime</a></h2>
<p>In this partition, we will introduce the objects of WasmEdge runtime manually.</p>
<h3 id="wasm-execution-example-step-by-step"><a class="header" href="#wasm-execution-example-step-by-step">WASM Execution Example Step-By-Step</a></h3>
<p>Besides the WASM execution through the <a href="embed/c/ref.html#WasmEdge-VM"><code>VM</code> context</a>, developers can execute the WASM functions or instantiate WASM modules step-by-step with the <code>Loader</code>, <code>Validator</code>, <code>Executor</code>, and <code>Store</code> contexts.
Assume that the WASM file <a href="embed/c/../tools/wasmedge/examples/fibonacci.wasm"><code>fibonacci.wasm</code></a> is copied into the current directory, and the C file <code>test.c</code> is as following:</p>
<pre><code class="language-c">#include &lt;wasmedge/wasmedge.h&gt;
#include &lt;stdio.h&gt;
int main() {
  /* Create the configure context. This step is not necessary because we didn't adjust any setting. */
  WasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();
  /* Create the statistics context. This step is not necessary if the statistics in runtime is not needed. */
  WasmEdge_StatisticsContext *StatCxt = WasmEdge_StatisticsCreate();
  /* Create the store context. The store context is the WASM runtime structure core. */
  WasmEdge_StoreContext *StoreCxt = WasmEdge_StoreCreate();
  /* Result. */
  WasmEdge_Result Res;

  /* Create the loader context. The configure context can be NULL. */
  WasmEdge_LoaderContext *LoadCxt = WasmEdge_LoaderCreate(ConfCxt);
  /* Create the validator context. The configure context can be NULL. */
  WasmEdge_ValidatorContext *ValidCxt = WasmEdge_ValidatorCreate(ConfCxt);
  /* Create the executor context. The configure context and the statistics context can be NULL. */
  WasmEdge_ExecutorContext *ExecCxt = WasmEdge_ExecutorCreate(ConfCxt, StatCxt);

  /* Load the WASM file or the compiled-WASM file and convert into the AST module context. */
  WasmEdge_ASTModuleContext *ASTCxt = NULL;
  Res = WasmEdge_LoaderParseFromFile(LoadCxt, &amp;ASTCxt, &quot;fibonacci.wasm&quot;);
  if (!WasmEdge_ResultOK(Res)) {
    printf(&quot;Loading phase failed: %s\n&quot;, WasmEdge_ResultGetMessage(Res));
    return 1;
  }
  /* Validate the WASM module. */
  Res = WasmEdge_ValidatorValidate(ValidCxt, ASTCxt);
  if (!WasmEdge_ResultOK(Res)) {
    printf(&quot;Validation phase failed: %s\n&quot;, WasmEdge_ResultGetMessage(Res));
    return 1;
  }
  /* Instantiate the WASM module into store context. */
  Res = WasmEdge_ExecutorInstantiate(ExecCxt, StoreCxt, ASTCxt);
  if (!WasmEdge_ResultOK(Res)) {
    printf(&quot;Instantiation phase failed: %s\n&quot;, WasmEdge_ResultGetMessage(Res));
    return 1;
  }

  /* Try to list the exported functions of the instantiated WASM module. */
  uint32_t FuncNum = WasmEdge_StoreListFunctionLength(StoreCxt);
  /* Create the name buffers. */
  const uint32_t BUF_LEN = 256;
  WasmEdge_String FuncNames[BUF_LEN];
  /* If the list length is larger than the buffer length, the overflowed data will be discarded. */
  uint32_t RealFuncNum = WasmEdge_StoreListFunction(StoreCxt, FuncNames, BUF_LEN);
  for (uint32_t I = 0; I &lt; RealFuncNum &amp;&amp; I &lt; BUF_LEN; I++) {
    char Buf[BUF_LEN];
    uint32_t Size = WasmEdge_StringCopy(FuncNames[I], Buf, sizeof(Buf));
    printf(&quot;Get exported function string length: %u, name: %s\n&quot;, Size, Buf);
    /* The function names should __NOT__ be destroyed. */
  }

  /* The parameters and returns arrays. */
  WasmEdge_Value Params[1] = { WasmEdge_ValueGenI32(18) };
  WasmEdge_Value Returns[1];
  /* Function name. */
  WasmEdge_String FuncName = WasmEdge_StringCreateByCString(&quot;fib&quot;);
  /* Invoke the WASM fnction. */
  Res = WasmEdge_ExecutorInvoke(ExecCxt, StoreCxt, FuncName, Params, 1, Returns, 1);
  if (WasmEdge_ResultOK(Res)) {
    printf(&quot;Get the result: %d\n&quot;, WasmEdge_ValueGetI32(Returns[0]));
  } else {
    printf(&quot;Execution phase failed: %s\n&quot;, WasmEdge_ResultGetMessage(Res));
  }

  /* Resources deallocations. */
  WasmEdge_StringDelete(FuncName);
  WasmEdge_ASTModuleDelete(ASTCxt);
  WasmEdge_LoaderDelete(LoadCxt);
  WasmEdge_ValidatorDelete(ValidCxt);
  WasmEdge_ExecutorDelete(ExecCxt);
  WasmEdge_ConfigureDelete(ConfCxt);
  WasmEdge_StoreDelete(StoreCxt);
  WasmEdge_StatisticsDelete(StatCxt);
  return 0;
}
</code></pre>
<p>Then you can compile and run: (the 18th Fibonacci number is 4181 in 0-based index)</p>
<pre><code class="language-bash">$ gcc test.c -lwasmedge_c
$ ./a.out
Get exported function string length: 3, name: fib
Get the result: 4181
</code></pre>
<h3 id="loader"><a class="header" href="#loader">Loader</a></h3>
<p>The <code>Loader</code> context loads the WASM binary from files or buffers.
Both the WASM and the compiled-WASM from the <a href="embed/c/ref.html#WasmEdge-AOT-Compiler">WasmEdge AOT Compiler</a> are supported.</p>
<pre><code class="language-c">uint32_t Buf[4096];
/* ... Read the WASM code to the buffer. */
uint32_t FileSize = ...;
/* The `FileSize` is the length of the WASM code. */

/* Developers can adjust settings in the configure context. */
WasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();
/* Create the loader context. The configure context can be NULL. */
WasmEdge_LoaderContext *LoadCxt = WasmEdge_LoaderCreate(ConfCxt);

WasmEdge_ASTModuleContext *ASTCxt = NULL;
WasmEdge_Result Res;

/* Load WASM or compiled-WASM from the file. */
Res = WasmEdge_LoaderParseFromFile(LoadCxt, &amp;ASTCxt, &quot;fibonacci.wasm&quot;);
if (!WasmEdge_ResultOK(Res)) {
  printf(&quot;Loading phase failed: %s\n&quot;, WasmEdge_ResultGetMessage(Res));
}
/* The output AST module context should be destroyed. */
WasmEdge_ASTModuleDelete(ASTCxt);

/* Load WASM or compiled-WASM from the buffer. */
Res = WasmEdge_LoaderParseFromBuffer(LoadCxt, &amp;ASTCxt, Buf, FileSize);
if (!WasmEdge_ResultOK(Res)) {
  printf(&quot;Loading phase failed: %s\n&quot;, WasmEdge_ResultGetMessage(Res));
}
/* The output AST module context should be destroyed. */
WasmEdge_ASTModuleDelete(ASTCxt);

WasmEdge_LoaderDelete(LoadCxt);
WasmEdge_ConfigureDelete(ConfCxt);
</code></pre>
<h3 id="validator"><a class="header" href="#validator">Validator</a></h3>
<p>The <code>Validator</code> context can validate the WASM module.
Every WASM module should be validated before instantiation.</p>
<pre><code class="language-c">/* 
 * ...
 * Assume that the `ASTCxt` is the output AST module context from the loader context.
 * Assume that the `ConfCxt` is the configure context.
 */
/* Create the validator context. The configure context can be NULL. */
WasmEdge_ValidatorContext *ValidCxt = WasmEdge_ValidatorCreate(ConfCxt);
WasmEdge_Result Res = WasmEdge_ValidatorValidate(ValidCxt, ASTCxt);
if (!WasmEdge_ResultOK(Res)) {
  printf(&quot;Validation phase failed: %s\n&quot;, WasmEdge_ResultGetMessage(Res));
}
WasmEdge_ValidatorDelete(ValidCxt);
</code></pre>
<h3 id="executor"><a class="header" href="#executor">Executor</a></h3>
<p>The <code>Executor</code> context is the executor for both WASM and compiled-WASM.
This object should work base on the <code>Store</code> context. For the details of the <code>Store</code> context, please refer to the <a href="embed/c/ref.html#Store">next chapter</a>.</p>
<ol>
<li>
<p>Register modules</p>
<p>As the same of <a href="embed/c/ref.html#Host-Module-Registrations">registering host modules</a> or <a href="embed/c/ref.html#WASM-Registrations-And-Executions">importing WASM modules</a> in <code>VM</code> context, developers can register <code>Import Object</code> or <code>AST module</code> contexts into the <code>Store</code> context by the <code>Executor</code> APIs.
For the details of import objects, please refer to the <a href="embed/c/ref.html#Host-Functions">Host Functions</a>.</p>
<pre><code class="language-c">/* 
* ...
* Assume that the `ASTCxt` is the output AST module context from the loader context
* and has passed the validation.
* Assume that the `ConfCxt` is the configure context.
*/
/* Create the statistics context. This step is not necessary. */
WasmEdge_StatisticsContext *StatCxt = WasmEdge_StatisticsCreate();
/* Create the executor context. The configure and the statistics contexts can be NULL. */
WasmEdge_ExecutorContext *ExecCxt = WasmEdge_ExecutorCreate(ConfCxt, StatCxt);
/* Create the store context. The store context is the WASM runtime structure core. */
WasmEdge_StoreContext *StoreCxt = WasmEdge_StoreCreate();
/* Result. */
WasmEdge_Result Res;

/* Register the WASM module into store with the export module name &quot;mod&quot;. */
WasmEdge_String ModName = WasmEdge_StringCreateByCString(&quot;mod&quot;);
Res = WasmEdge_ExecutorRegisterModule(ExecCxt, StoreCxt, ASTCxt, ModName);
if (!WasmEdge_ResultOK(Res)) {
  printf(&quot;WASM registration failed: %s\n&quot;, WasmEdge_ResultGetMessage(Res));
}
WasmEdge_StringDelete(ModName);

/* 
 * Assume that the `ImpCxt` is the import object context for host functions.
 */
WasmEdge_ImportObjectContext *ImpCxt = ...;
/* The import module context has already contained the export module name. */
Res = WasmEdge_ExecutorRegisterImport(ExecCxt, StoreCxt, ImpCxt);
if (!WasmEdge_ResultOK(Res)) {
  printf(&quot;Import object registration failed: %s\n&quot;, WasmEdge_ResultGetMessage(Res));
}

WasmEdge_ImportObjectDelete(ImpCxt);
WasmEdge_ExecutorDelete(ExecCxt);
WasmEdge_StatisticsDelete(StatCxt);
WasmEdge_StoreDelete(StoreCxt);
</code></pre>
</li>
<li>
<p>Instantiate modules</p>
<p>WASM or compiled-WASM modules should be instantiated before the function invocation.
Note that developers can only instantiate one module into the <code>Store</code> context, and in that case, the old instantiated module will be cleaned.
Before instantiating a WASM module, please check the <a href="https://webassembly.github.io/spec/core/syntax/modules.html#syntax-import">import section</a> for ensuring the imports are registered into the <code>Store</code> context.</p>
<pre><code class="language-c">/* 
* ...
* Assume that the `ASTCxt` is the output AST module context from the loader context
* and has passed the validation.
* Assume that the `ConfCxt` is the configure context.
*/
/* Create the statistics context. This step is not necessary. */
WasmEdge_StatisticsContext *StatCxt = WasmEdge_StatisticsCreate();
/* Create the executor context. The configure and the statistics contexts can be NULL. */
WasmEdge_ExecutorContext *ExecCxt = WasmEdge_ExecutorCreate(ConfCxt, StatCxt);
/* Create the store context. The store context is the WASM runtime structure core. */
WasmEdge_StoreContext *StoreCxt = WasmEdge_StoreCreate();

/* Instantiate the WASM module. */
WasmEdge_Result Res = WasmEdge_ExecutorInstantiate(ExecCxt, StoreCxt, ASTCxt);
if (!WasmEdge_ResultOK(Res)) {
  printf(&quot;WASM instantiation failed: %s\n&quot;, WasmEdge_ResultGetMessage(Res));
}

WasmEdge_ExecutorDelete(ExecCxt);
WasmEdge_StatisticsDelete(StatCxt);
WasmEdge_StoreDelete(StoreCxt);
</code></pre>
</li>
<li>
<p>Invoke functions</p>
<p>As the same as function invocation via the <code>VM</code> context, developers can invoke the functions of the instantiated or registered modules.
The APIs, <code>WasmEdge_ExecutorInvoke()</code> and <code>WasmEdge_ExecutorInvokeRegistered()</code>, are similar as the APIs of the <code>VM</code> context.
Please refer to the <a href="embed/c/ref.html#WASM-Execution-Example-With-VM-Context">VM context workflows</a> for details.</p>
</li>
</ol>
<h3 id="ast-module"><a class="header" href="#ast-module">AST Module</a></h3>
<p>The <code>AST Module</code> context presents the loaded structure from a WASM file or buffer. Developer will get this object after loading a WASM file or buffer from <a href="embed/c/ref.html#Loader">Loader</a>.
Before instantiation, developers can also query the imports and exports of an <code>AST Module</code> context.</p>
<pre><code class="language-c">WasmEdge_ASTModuleContext *ASTCxt = ...;
/* Assume that a WASM is loaded into an AST module context. */

/* Create the import type context buffers. */
const uint32_t BUF_LEN = 256;
const WasmEdge_ImportTypeContext *ImpTypes[BUF_LEN];
uint32_t ImportNum = WasmEdge_ASTModuleListImportsLength(ASTCxt);
/* If the list length is larger than the buffer length, the overflowed data will be discarded. */
uint32_t RealImportNum = WasmEdge_ASTModuleListImports(ASTCxt, ImpTypes, BUF_LEN);
for (uint32_t I = 0; I &lt; RealImportNum &amp;&amp; I &lt; BUF_LEN; I++) {
  /* Working with the import type `ImpTypes[I]` ... */
}

/* Create the export type context buffers. */
const WasmEdge_ExportTypeContext *ExpTypes[BUF_LEN];
uint32_t ExportNum = WasmEdge_ASTModuleListExportsLength(ASTCxt);
/* If the list length is larger than the buffer length, the overflowed data will be discarded. */
uint32_t RealExportNum = WasmEdge_ASTModuleListExports(ASTCxt, ExpTypes, BUF_LEN);
for (uint32_t I = 0; I &lt; RealExportNum &amp;&amp; I &lt; BUF_LEN; I++) {
  /* Working with the export type `ExpTypes[I]` ... */
}

WasmEdge_ASTModuleDelete(ASTCxt);
/* After deletion of `ASTCxt`, all data queried from the `ASTCxt` should not be accessed. */
</code></pre>
<h3 id="store"><a class="header" href="#store">Store</a></h3>
<p><a href="https://webassembly.github.io/spec/core/exec/runtime.html#store">Store</a> is the runtime structure for the representation of all instances of <code>Function</code>s, <code>Table</code>s, <code>Memory</code>s, and <code>Global</code>s that have been allocated during the lifetime of the abstract machine.
The <code>Store</code> context in WasmEdge provides APIs to list the exported instances with their names or find the instances by exported names. For adding instances into <code>Store</code> contexts, please instantiate or register WASM modules or <code>Import Object</code> contexts via the <code>Executor</code> context.</p>
<ol>
<li>
<p>List instances</p>
<pre><code class="language-c">WasmEdge_StoreContext *StoreCxt = WasmEdge_StoreCreate();
/* ... Instantiate a WASM module via the executor context. */
...

/* Try to list the exported functions of the instantiated WASM module. */
/* Take the function instances for example here. */
uint32_t FuncNum = WasmEdge_StoreListFunctionLength(StoreCxt);
/* Create the name buffers. */
const uint32_t BUF_LEN = 256;
WasmEdge_String FuncNames[BUF_LEN];
/* If the list length is larger than the buffer length, the overflowed data will be discarded. */
uint32_t RealFuncNum = WasmEdge_StoreListFunction(StoreCxt, FuncNames, BUF_LEN);
for (uint32_t I = 0; I &lt; RealFuncNum &amp;&amp; I &lt; BUF_LEN; I++) {
  /* Working with the function name `FuncNames[I]` ... */
  /* The function names should __NOT__ be destroyed. */
}
</code></pre>
<p>Developers can list the function instance exported names of the registered modules via the <code>WasmEdge_StoreListFunctionRegisteredLength()</code> and the <code>WasmEdge_StoreListFunctionRegistered()</code> APIs with the module name.</p>
</li>
<li>
<p>Find instances</p>
<pre><code class="language-c">WasmEdge_StoreContext *StoreCxt = WasmEdge_StoreCreate();
/* ... Instantiate a WASM module via the executor context. */
...

/* Try to find the exported instance of the instantiated WASM module. */
/* Take the function instances for example here. */
/* Function name. */
WasmEdge_String FuncName = WasmEdge_StringCreateByCString(&quot;fib&quot;);
WasmEdge_FunctionInstanceContext *FuncCxt = WasmEdge_StoreFindFunction(StoreCxt, FuncName);
/* `FuncCxt` will be `NULL` if the function not found. */
/* The returned instance is owned by the store context and should __NOT__ be destroyed. */
WasmEdge_StringDelete(FuncName);
</code></pre>
<p>Developers can retrieve the exported function instances of the registered modules via the <code>WasmEdge_StoreFindFunctionRegistered()</code> API with the module name.</p>
</li>
<li>
<p>List registered modules</p>
<p>With the module names, developers can list the exported instances of the registered modules with their names.</p>
<pre><code class="language-c">WasmEdge_StoreContext *StoreCxt = WasmEdge_StoreCreate();
/* ... Register a WASM module via the executor context. */
...

/* Try to list the registered WASM modules. */
uint32_t ModNum = WasmEdge_StoreListModuleLength(StoreCxt);
/* Create the name buffers. */
const uint32_t BUF_LEN = 256;
WasmEdge_String ModNames[BUF_LEN];
/* If the list length is larger than the buffer length, the overflowed data will be discarded. */
uint32_t RealModNum = WasmEdge_StoreListModule(StoreCxt, ModNames, BUF_LEN);
for (uint32_t I = 0; I &lt; RealModNum &amp;&amp; I &lt; BUF_LEN; I++) {
  /* Working with the module name `ModNames[I]` ... */
  /* The module names should __NOT__ be destroyed. */
}
</code></pre>
</li>
</ol>
<h3 id="instances"><a class="header" href="#instances">Instances</a></h3>
<p>The instances are the runtime structures of WASM. Developers can retrieve the instances from the <code>Store</code> contexts.
The <code>Store</code> contexts will allocate instances when a WASM module or <code>Import Object</code> is registered or instantiated through the <code>Executor</code>.
A single instance can be allocated by its creation function. Developers can construct instances into an <code>Import Object</code> for registration. Please refer to the <a href="embed/c/ref.html#Host-Functions">Host Functions</a> for details.
The instances created by their creation functions should be destroyed, EXCEPT they are added into an <code>Import Object</code> context.</p>
<ol>
<li>
<p>Function instance</p>
<p><a href="https://webassembly.github.io/spec/core/exec/runtime.html#syntax-hostfunc">Host functions</a> are functions outside WebAssembly and passed to WASM modules as imports.
In WasmEdge, developers can create the <code>Function</code> contexts for host functions and add them into an <code>Import Object</code> context for registering into a <code>VM</code> or a <code>Store</code>.
For both host functions and the functions get from <code>Store</code>, developers can retrieve the <code>Function Type</code> from the <code>Function</code> contexts.
For the details of the <code>Host Function</code> guide, please refer to the <a href="embed/c/ref.html#Host-Functions">next chapter</a>.</p>
<pre><code class="language-c">/* Retrieve the function instance from the store context. */
WasmEdge_FunctionInstanceContext *FuncCxt = ...;
WasmEdge_FunctionTypeContext *FuncTypeCxt = WasmEdge_FunctionInstanceGetFunctionType(FuncCxt);
/* The `FuncTypeCxt` is owned by the `FuncCxt` and should __NOT__ be destroyed. */
</code></pre>
</li>
<li>
<p>Table instance</p>
<p>In WasmEdge, developers can create the <code>Table</code> contexts and add them into an <code>Import Object</code> context for registering into a <code>VM</code> or a <code>Store</code>.
The <code>Table</code> contexts supply APIs to control the data in table instances.</p>
<pre><code class="language-c">WasmEdge_Limit TabLimit = {.HasMax = true, .Min = 10, .Max = 20};
/* Create the table type with limit and the `FuncRef` element type. */
WasmEdge_TableTypeContext *TabTypeCxt = WasmEdge_TableTypeCreate(WasmEdge_RefType_FuncRef, TabLimit);
/* Create the table instance with table type. */
WasmEdge_TableInstanceContext *HostTable = WasmEdge_TableInstanceCreate(TabTypeCxt);
/* Delete the table type. */
WasmEdge_TableTypeDelete(TabTypeCxt);
WasmEdge_Result Res;
WasmEdge_Value Data;

TabTypeCxt = WasmEdge_TableInstanceGetTableType(HostTable);
/* The `TabTypeCxt` got from table instance is owned by the `HostTable` and should __NOT__ be destroyed. */
enum WasmEdge_RefType RefType = WasmEdge_TableTypeGetRefType(TabTypeCxt);
/* `RefType` will be `WasmEdge_RefType_FuncRef`. */
Data = WasmEdge_ValueGenFuncRef(5);
Res = WasmEdge_TableInstanceSetData(HostTable, Data, 3);
/* Set the function index 5 to the table[3]. */
/*
 * This will get an &quot;out of bounds table access&quot; error
 * because the position (13) is out of the table size (10):
 *   Res = WasmEdge_TableInstanceSetData(HostTable, Data, 13);
 */
Res = WasmEdge_TableInstanceGetData(HostTable, &amp;Data, 3);
/* Get the FuncRef value of the table[3]. */
/*
 * This will get an &quot;out of bounds table access&quot; error
 * because the position (13) is out of the table size (10):
 *   Res = WasmEdge_TableInstanceGetData(HostTable, &amp;Data, 13);
 */

uint32_t Size = WasmEdge_TableInstanceGetSize(HostTable);
/* `Size` will be 10. */
Res = WasmEdge_TableInstanceGrow(HostTable, 6);
/* Grow the table size of 6, the table size will be 16. */
/*
 * This will get an &quot;out of bounds table access&quot; error because
 * the size (16 + 6) will reach the table limit(20):
 *   Res = WasmEdge_TableInstanceGrow(HostTable, 6);
 */

WasmEdge_TableInstanceDelete(HostTable);
</code></pre>
</li>
<li>
<p>Memory instance</p>
<p>In WasmEdge, developers can create the <code>Memory</code> contexts and add them into an <code>Import Object</code> context for registering into a <code>VM</code> or a <code>Store</code>.
The <code>Memory</code> contexts supply APIs to control the data in memory instances.</p>
<pre><code class="language-c">WasmEdge_Limit MemLimit = {.HasMax = true, .Min = 1, .Max = 5};
/* Create the memory type with limit. The memory page size is 64KiB. */
WasmEdge_MemoryTypeContext *MemTypeCxt = WasmEdge_MemoryTypeCreate(MemLimit);
/* Create the memory instance with memory type. */
WasmEdge_MemoryInstanceContext *HostMemory = WasmEdge_MemoryInstanceCreate(MemTypeCxt);
/* Delete the memory type. */
WasmEdge_MemoryTypeDelete(MemTypeCxt);
WasmEdge_Result Res;
uint8_t Buf[256];

Buf[0] = 0xAA;
Buf[1] = 0xBB;
Buf[2] = 0xCC;
Res = WasmEdge_MemoryInstanceSetData(HostMemory, Buf, 0x1000, 3);
/* Set the data[0:2] to the memory[4096:4098]. */
/*
 * This will get an &quot;out of bounds memory access&quot; error
 * because [65535:65537] is out of 1 page size (65536):
 *   Res = WasmEdge_MemoryInstanceSetData(HostMemory, Buf, 0xFFFF, 3);
 */
Buf[0] = 0;
Buf[1] = 0;
Buf[2] = 0;
Res = WasmEdge_MemoryInstanceGetData(HostMemory, Buf, 0x1000, 3);
/* Get the memory[4096:4098]. Buf[0:2] will be `{0xAA, 0xBB, 0xCC}`. */
/*
 * This will get an &quot;out of bounds memory access&quot; error
 * because [65535:65537] is out of 1 page size (65536):
 *   Res = WasmEdge_MemoryInstanceSetData(HostMemory, Buf, 0xFFFF, 3);
 */

uint32_t PageSize = WasmEdge_MemoryInstanceGetPageSize(HostMemory);
/* `PageSize` will be 1. */
Res = WasmEdge_MemoryInstanceGrowPage(HostMemory, 2);
/* Grow the page size of 2, the page size of the memory instance will be 3. */
/*
 * This will get an &quot;out of bounds memory access&quot; error because
 * the page size (3 + 3) will reach the memory limit(5):
 *   Res = WasmEdge_MemoryInstanceGrowPage(HostMemory, 3);
 */

WasmEdge_MemoryInstanceDelete(HostMemory);
</code></pre>
</li>
<li>
<p>Global instance</p>
<p>In WasmEdge, developers can create the <code>Global</code> contexts and add them into an <code>Import Object</code> context for registering into a <code>VM</code> or a <code>Store</code>.
The <code>Global</code> contexts supply APIs to control the value in global instances.</p>
<pre><code class="language-c">WasmEdge_Value Val = WasmEdge_ValueGenI64(1000);
/* Create the global type with value type and mutation. */
WasmEdge_GlobalTypeContext *GlobTypeCxt = WasmEdge_GlobalTypeCreate(WasmEdge_ValType_I64, WasmEdge_Mutability_Var);
/* Create the global instance with value and global type. */
WasmEdge_GlobalInstanceContext *HostGlobal = WasmEdge_GlobalInstanceCreate(GlobTypeCxt, Val);
/* Delete the global type. */
WasmEdge_GlobalTypeDelete(GlobTypeCxt);
WasmEdge_Result Res;

GlobTypeCxt = WasmEdge_GlobalInstanceGetGlobalType(HostGlobal);
/* The `GlobTypeCxt` got from global instance is owned by the `HostGlobal` and should __NOT__ be destroyed. */
enum WasmEdge_ValType ValType = WasmEdge_GlobalTypeGetValType(GlobTypeCxt);
/* `ValType` will be `WasmEdge_ValType_I64`. */
enum WasmEdge_Mutability ValMut = WasmEdge_GlobalTypeGetMutability(GlobTypeCxt);
/* `ValMut` will be `WasmEdge_Mutability_Var`. */

WasmEdge_GlobalInstanceSetValue(HostGlobal, WasmEdge_ValueGenI64(888));
/* 
 * Set the value u64(888) to the global.
 * This function will do nothing if the value type mismatched or
 * the global mutability is `WasmEdge_Mutability_Const`.
 */
WasmEdge_Value GlobVal = WasmEdge_GlobalInstanceGetValue(HostGlobal);
/* Get the value (888 now) of the global context. */

WasmEdge_GlobalInstanceDelete(HostGlobal);
</code></pre>
</li>
</ol>
<h3 id="host-functions"><a class="header" href="#host-functions">Host Functions</a></h3>
<p><a href="https://webassembly.github.io/spec/core/exec/runtime.html#syntax-hostfunc">Host functions</a> are functions outside WebAssembly and passed to WASM modules as imports.
In WasmEdge, developers can create the <code>Function</code>, <code>Memory</code>, <code>Table</code>, and <code>Global</code> contexts and add them into an <code>Import Object</code> context for registering into a <code>VM</code> or a <code>Store</code>.</p>
<ol>
<li>
<p>Host function allocation</p>
<p>Developers can define C functions with the following function signature as the host function body:</p>
<pre><code class="language-c">typedef WasmEdge_Result (*WasmEdge_HostFunc_t)(
  void *Data,
  WasmEdge_MemoryInstanceContext *MemCxt,
  const WasmEdge_Value *Params,
  WasmEdge_Value *Returns);
</code></pre>
<p>The example of an <code>add</code> host function to add 2 <code>i32</code> values:</p>
<pre><code class="language-c">WasmEdge_Result Add(void *, WasmEdge_MemoryInstanceContext *,
                    const WasmEdge_Value *In, WasmEdge_Value *Out) {
  /*
  * Params: {i32, i32}
  * Returns: {i32}
  * Developers should take care about the function type.
  */ 
  /* Retrieve the value 1. */
  int32_t Val1 = WasmEdge_ValueGetI32(In[0]);
  /* Retrieve the value 2. */
  int32_t Val2 = WasmEdge_ValueGetI32(In[1]);
  /* Output value 1 is Val1 + Val2. */
  Out[0] = WasmEdge_ValueGenI32(Val1 + Val2);
  /* Return the status of success. */
  return WasmEdge_Result_Success;
}
</code></pre>
<p>Then developers can create <code>Function</code> context with the host function body and function type:</p>
<pre><code class="language-c">enum WasmEdge_ValType ParamList[2] = { WasmEdge_ValType_I32, WasmEdge_ValType_I32 };
enum WasmEdge_ValType ReturnList[1] = { WasmEdge_ValType_I32 };
/* Create a function type: {i32, i32} -&gt; {i32}. */
HostFType = WasmEdge_FunctionTypeCreate(ParamList, 2, ReturnList, 1);
/* 
 * Create a function context with the function type and host function body.
 * The `Cost` parameter can be 0 if developers do not need the cost measuring.
 */
WasmEdge_FunctionInstanceContext *HostFunc = WasmEdge_FunctionInstanceCreate(HostFType, Add, NULL, 0);
/*
 * The third parameter is the pointer to the additional data.
 * Developers should guarantee the life cycle of the data, and it can be
 * `NULL` if the external data is not needed.
 */

/* If the function instance is not added into an import object context, it should be deleted. */
WasmEdge_FunctionInstanceDelete(HostFunc);
</code></pre>
</li>
<li>
<p>Import object context</p>
<p>The <code>Import Object</code> context holds an exporting module name and the instances. Developers can add the <code>Function</code>, <code>Memory</code>, <code>Table</code>, and <code>Global</code> instances with their exporting names.</p>
<pre><code class="language-c">/* Host function body definition. */
WasmEdge_Result Add(void *Data, WasmEdge_MemoryInstanceContext *MemCxt,
                    const WasmEdge_Value *In, WasmEdge_Value *Out) {
  int32_t Val1 = WasmEdge_ValueGetI32(In[0]);
  int32_t Val2 = WasmEdge_ValueGetI32(In[1]);
  Out[0] = WasmEdge_ValueGenI32(Val1 + Val2);
  return WasmEdge_Result_Success;
}

/* Create the import object. */
WasmEdge_String ExportName = WasmEdge_StringCreateByCString(&quot;module&quot;);
WasmEdge_ImportObjectContext *ImpObj = WasmEdge_ImportObjectCreate(ExportName);
WasmEdge_StringDelete(ExportName);

/* Create and add a function instance into the import object. */
enum WasmEdge_ValType ParamList[2] = { WasmEdge_ValType_I32, WasmEdge_ValType_I32 };
enum WasmEdge_ValType ReturnList[1] = { WasmEdge_ValType_I32 };
WasmEdge_FunctionTypeContext *HostFType = 
  WasmEdge_FunctionTypeCreate(ParamList, 2, ReturnList, 1);
WasmEdge_FunctionInstanceContext *HostFunc =
  WasmEdge_FunctionInstanceCreate(HostFType, Add, NULL, 0);
/*
 * The third parameter is the pointer to the additional data object.
 * Developers should guarantee the life cycle of the data, and it can be
 * `NULL` if the external data is not needed.
 */
WasmEdge_FunctionTypeDelete(HostFType);
WasmEdge_String FuncName = WasmEdge_StringCreateByCString(&quot;add&quot;);
WasmEdge_ImportObjectAddFunction(ImpObj, FuncName, HostFunc);
WasmEdge_StringDelete(FuncName);

/* Create and add a table instance into the import object. */
WasmEdge_Limit TableLimit = {.HasMax = true, .Min = 10, .Max = 20};
WasmEdge_TableTypeContext *HostTType = 
  WasmEdge_TableTypeCreate(WasmEdge_RefType_FuncRef, TableLimit);
WasmEdge_TableInstanceContext *HostTable = WasmEdge_TableInstanceCreate(HostTType);
WasmEdge_TableTypeDelete(HostTType);
WasmEdge_String TableName = WasmEdge_StringCreateByCString(&quot;table&quot;);
WasmEdge_ImportObjectAddTable(ImpObj, TableName, HostTable);
WasmEdge_StringDelete(TableName);

/* Create and add a memory instance into the import object. */
WasmEdge_Limit MemoryLimit = {.HasMax = true, .Min = 1, .Max = 2};
WasmEdge_MemoryTypeContext *HostMType = WasmEdge_MemoryTypeCreate(MemoryLimit);
WasmEdge_MemoryInstanceContext *HostMemory = WasmEdge_MemoryInstanceCreate(HostMType);
WasmEdge_MemoryTypeDelete(HostMType);
WasmEdge_String MemoryName = WasmEdge_StringCreateByCString(&quot;memory&quot;);
WasmEdge_ImportObjectAddMemory(ImpObj, MemoryName, HostMemory);
WasmEdge_StringDelete(MemoryName);

/* Create and add a global instance into the import object. */
WasmEdge_GlobalTypeContext *HostGType =
  WasmEdge_GlobalTypeCreate(WasmEdge_ValType_I32, WasmEdge_Mutability_Var);
WasmEdge_GlobalInstanceContext *HostGlobal =
  WasmEdge_GlobalInstanceCreate(HostGType, WasmEdge_ValueGenI32(666));
WasmEdge_GlobalTypeDelete(HostGType);
WasmEdge_String GlobalName = WasmEdge_StringCreateByCString(&quot;global&quot;);
WasmEdge_ImportObjectAddGlobal(ImpObj, GlobalName, HostGlobal);
WasmEdge_StringDelete(GlobalName);

/*
 * The import objects should be deleted.
 * Developers should __NOT__ destroy the instances added into the import object contexts.
 */
WasmEdge_ImportObjectDelete(ImpObj);
</code></pre>
</li>
<li>
<p>Specified import object</p>
<p><code>WasmEdge_ImportObjectCreateWASI()</code> API can create and initialize the <code>WASI</code> import object.
<code>WasmEdge_ImportObjectCreateWasmEdgeProcess()</code> API can create and initialize the <code>wasmedge_process</code> import object.
Developers can create these import object contexts and register them into the <code>Store</code> or <code>VM</code> contexts rather than adjust the settings in the <code>Configure</code> contexts.</p>
<pre><code class="language-c">WasmEdge_ImportObjectContext *WasiObj = WasmEdge_ImportObjectCreateWASI( /* ... ignored */ );
WasmEdge_ImportObjectContext *ProcObj = WasmEdge_ImportObjectCreateWasmEdgeProcess( /* ... ignored */ );
WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(NULL, NULL);
/* Register the WASI and WasmEdge_Process into the VM context. */
WasmEdge_VMRegisterModuleFromImport(VMCxt, WasiObj);
WasmEdge_VMRegisterModuleFromImport(VMCxt, ProcObj);
/* Get the WASI exit code. */
uint32_t ExitCode = WasmEdge_ImportObjectWASIGetExitCode(WasiObj);
/*
 * The `ExitCode` will be EXIT_SUCCESS if the execution has no error.
 * Otherwise, it will return with the related exit code.
 */
WasmEdge_VMDelete(VMCxt);
/* The import objects should be deleted. */
WasmEdge_ImportObjectDelete(WasiObj);
WasmEdge_ImportObjectDelete(ProcObj);
</code></pre>
</li>
<li>
<p>Example</p>
<p>Assume that a simple WASM from the WAT as following:</p>
<pre><code>(module
  (type $t0 (func (param i32 i32) (result i32)))
  (import &quot;extern&quot; &quot;func-add&quot; (func $f-add (type $t0)))
  (func (export &quot;addTwo&quot;) (param i32 i32) (result i32)
    local.get 0
    local.get 1
    call $f-add)
)
</code></pre>
<p>And the <code>test.c</code> as following:</p>
<pre><code class="language-c">#include &lt;wasmedge/wasmedge.h&gt;
#include &lt;stdio.h&gt;

/* Host function body definition. */
WasmEdge_Result Add(void *Data, WasmEdge_MemoryInstanceContext *MemCxt,
                    const WasmEdge_Value *In, WasmEdge_Value *Out) {
  int32_t Val1 = WasmEdge_ValueGetI32(In[0]);
  int32_t Val2 = WasmEdge_ValueGetI32(In[1]);
  printf(&quot;Host function \&quot;Add\&quot;: %d + %d\n&quot;, Val1, Val2);
  Out[0] = WasmEdge_ValueGenI32(Val1 + Val2);
  return WasmEdge_Result_Success;
}

int main() {
  /* Create the VM context. */
  WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(NULL, NULL);

  /* The WASM module buffer. */
  uint8_t WASM[] = {
    /* WASM header */
    0x00, 0x61, 0x73, 0x6D, 0x01, 0x00, 0x00, 0x00,
    /* Type section */
    0x01, 0x07, 0x01,
    /* function type {i32, i32} -&gt; {i32} */
    0x60, 0x02, 0x7F, 0x7F, 0x01, 0x7F,
    /* Import section */
    0x02, 0x13, 0x01,
    /* module name: &quot;extern&quot; */
    0x06, 0x65, 0x78, 0x74, 0x65, 0x72, 0x6E,
    /* extern name: &quot;func-add&quot; */
    0x08, 0x66, 0x75, 0x6E, 0x63, 0x2D, 0x61, 0x64, 0x64,
    /* import desc: func 0 */
    0x00, 0x00,
    /* Function section */
    0x03, 0x02, 0x01, 0x00,
    /* Export section */
    0x07, 0x0A, 0x01,
    /* export name: &quot;addTwo&quot; */
    0x06, 0x61, 0x64, 0x64, 0x54, 0x77, 0x6F,
    /* export desc: func 0 */
    0x00, 0x01,
    /* Code section */
    0x0A, 0x0A, 0x01,
    /* code body */
    0x08, 0x00, 0x20, 0x00, 0x20, 0x01, 0x10, 0x00, 0x0B
  };

  /* Create the import object. */
  WasmEdge_String ExportName = WasmEdge_StringCreateByCString(&quot;extern&quot;);
  WasmEdge_ImportObjectContext *ImpObj = WasmEdge_ImportObjectCreate(ExportName);
  enum WasmEdge_ValType ParamList[2] = { WasmEdge_ValType_I32, WasmEdge_ValType_I32 };
  enum WasmEdge_ValType ReturnList[1] = { WasmEdge_ValType_I32 };
  WasmEdge_FunctionTypeContext *HostFType = WasmEdge_FunctionTypeCreate(ParamList, 2, ReturnList, 1);
  WasmEdge_FunctionInstanceContext *HostFunc = WasmEdge_FunctionInstanceCreate(HostFType, Add, NULL, 0);
  WasmEdge_FunctionTypeDelete(HostFType);
  WasmEdge_String HostFuncName = WasmEdge_StringCreateByCString(&quot;func-add&quot;);
  WasmEdge_ImportObjectAddFunction(ImpObj, HostFuncName, HostFunc);
  WasmEdge_StringDelete(HostFuncName);

  WasmEdge_VMRegisterModuleFromImport(VMCxt, ImpObj);

  /* The parameters and returns arrays. */
  WasmEdge_Value Params[2] = { WasmEdge_ValueGenI32(1234), WasmEdge_ValueGenI32(5678) };
  WasmEdge_Value Returns[1];
  /* Function name. */
  WasmEdge_String FuncName = WasmEdge_StringCreateByCString(&quot;addTwo&quot;);
  /* Run the WASM function from file. */
  WasmEdge_Result Res = WasmEdge_VMRunWasmFromBuffer(
    VMCxt, WASM, sizeof(WASM), FuncName, Params, 2, Returns, 1);

  if (WasmEdge_ResultOK(Res)) {
    printf(&quot;Get the result: %d\n&quot;, WasmEdge_ValueGetI32(Returns[0]));
  } else {
    printf(&quot;Error message: %s\n&quot;, WasmEdge_ResultGetMessage(Res));
  }

  /* Resources deallocations. */
  WasmEdge_VMDelete(VMCxt);
  WasmEdge_StringDelete(FuncName);
  WasmEdge_ImportObjectDelete(ImpObj);
  return 0;
}
</code></pre>
<p>Then you can compile and run: (the result of 1234 + 5678 is 6912)</p>
<pre><code class="language-bash">$ gcc test.c -lwasmedge_c
$ ./a.out
Host function &quot;Add&quot;: 1234 + 5678
Get the result: 6912
</code></pre>
</li>
<li>
<p>Host Data Example</p>
<p>Developers can set a external data object to the function context, and access to the object in the function body.
Assume that a simple WASM from the WAT as following:</p>
<pre><code>(module
  (type $t0 (func (param i32 i32) (result i32)))
  (import &quot;extern&quot; &quot;func-add&quot; (func $f-add (type $t0)))
  (func (export &quot;addTwo&quot;) (param i32 i32) (result i32)
    local.get 0
    local.get 1
    call $f-add)
)
</code></pre>
<p>And the <code>test.c</code> as following:</p>
<pre><code class="language-c">#include &lt;wasmedge/wasmedge.h&gt;
#include &lt;stdio.h&gt;

/* Host function body definition. */
WasmEdge_Result Add(void *Data, WasmEdge_MemoryInstanceContext *MemCxt,
                    const WasmEdge_Value *In, WasmEdge_Value *Out) {
  int32_t Val1 = WasmEdge_ValueGetI32(In[0]);
  int32_t Val2 = WasmEdge_ValueGetI32(In[1]);
  printf(&quot;Host function \&quot;Add\&quot;: %d + %d\n&quot;, Val1, Val2);
  Out[0] = WasmEdge_ValueGenI32(Val1 + Val2);
  /* Also set the result to the data. */
  int32_t *DataPtr = (int32_t *)Data;
  *DataPtr = Val1 + Val2;
  return WasmEdge_Result_Success;
}

int main() {
  /* Create the VM context. */
  WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(NULL, NULL);

  /* The WASM module buffer. */
  uint8_t WASM[] = {
    /* WASM header */
    0x00, 0x61, 0x73, 0x6D, 0x01, 0x00, 0x00, 0x00,
    /* Type section */
    0x01, 0x07, 0x01,
    /* function type {i32, i32} -&gt; {i32} */
    0x60, 0x02, 0x7F, 0x7F, 0x01, 0x7F,
    /* Import section */
    0x02, 0x13, 0x01,
    /* module name: &quot;extern&quot; */
    0x06, 0x65, 0x78, 0x74, 0x65, 0x72, 0x6E,
    /* extern name: &quot;func-add&quot; */
    0x08, 0x66, 0x75, 0x6E, 0x63, 0x2D, 0x61, 0x64, 0x64,
    /* import desc: func 0 */
    0x00, 0x00,
    /* Function section */
    0x03, 0x02, 0x01, 0x00,
    /* Export section */
    0x07, 0x0A, 0x01,
    /* export name: &quot;addTwo&quot; */
    0x06, 0x61, 0x64, 0x64, 0x54, 0x77, 0x6F,
    /* export desc: func 0 */
    0x00, 0x01,
    /* Code section */
    0x0A, 0x0A, 0x01,
    /* code body */
    0x08, 0x00, 0x20, 0x00, 0x20, 0x01, 0x10, 0x00, 0x0B
  };

  /* The external data object: an integer. */
  int32_t Data;

  /* Create the import object. */
  WasmEdge_String ExportName = WasmEdge_StringCreateByCString(&quot;extern&quot;);
  WasmEdge_ImportObjectContext *ImpObj = WasmEdge_ImportObjectCreate(ExportName);
  enum WasmEdge_ValType ParamList[2] = { WasmEdge_ValType_I32, WasmEdge_ValType_I32 };
  enum WasmEdge_ValType ReturnList[1] = { WasmEdge_ValType_I32 };
  WasmEdge_FunctionTypeContext *HostFType = WasmEdge_FunctionTypeCreate(ParamList, 2, ReturnList, 1);
  WasmEdge_FunctionInstanceContext *HostFunc = WasmEdge_FunctionInstanceCreate(HostFType, Add, &amp;Data, 0);
  WasmEdge_FunctionTypeDelete(HostFType);
  WasmEdge_String HostFuncName = WasmEdge_StringCreateByCString(&quot;func-add&quot;);
  WasmEdge_ImportObjectAddFunction(ImpObj, HostFuncName, HostFunc);
  WasmEdge_StringDelete(HostFuncName);

  WasmEdge_VMRegisterModuleFromImport(VMCxt, ImpObj);

  /* The parameters and returns arrays. */
  WasmEdge_Value Params[2] = { WasmEdge_ValueGenI32(1234), WasmEdge_ValueGenI32(5678) };
  WasmEdge_Value Returns[1];
  /* Function name. */
  WasmEdge_String FuncName = WasmEdge_StringCreateByCString(&quot;addTwo&quot;);
  /* Run the WASM function from file. */
  WasmEdge_Result Res = WasmEdge_VMRunWasmFromBuffer(
    VMCxt, WASM, sizeof(WASM), FuncName, Params, 2, Returns, 1);

  if (WasmEdge_ResultOK(Res)) {
    printf(&quot;Get the result: %d\n&quot;, WasmEdge_ValueGetI32(Returns[0]));
  } else {
    printf(&quot;Error message: %s\n&quot;, WasmEdge_ResultGetMessage(Res));
  }
  printf(&quot;Data value: %d\n&quot;, Data);

  /* Resources deallocations. */
  WasmEdge_VMDelete(VMCxt);
  WasmEdge_StringDelete(FuncName);
  WasmEdge_ImportObjectDelete(ImpObj);
  return 0;
}
</code></pre>
<p>Then you can compile and run: (the result of 1234 + 5678 is 6912)</p>
<pre><code class="language-bash">$ gcc test.c -lwasmedge_c
$ ./a.out
Host function &quot;Add&quot;: 1234 + 5678
Get the result: 6912
Data value: 6912
</code></pre>
</li>
</ol>
<h2 id="wasmedge-aot-compiler"><a class="header" href="#wasmedge-aot-compiler">WasmEdge AOT Compiler</a></h2>
<p>In this partition, we will introduce the WasmEdge AOT compiler and the options.
WasmEdge runs the WASM files in interpreter mode, and WasmEdge also supports the AOT (ahead-of-time) mode running without modifying any code.
The WasmEdge AOT (ahead-of-time) compiler compiles the WASM files for running in AOT mode which is much faster than interpreter mode. Developers can compile the WASM files into the compiled-WASM files in shared library format for universal WASM format for the AOT mode execution.</p>
<h3 id="compilation-example"><a class="header" href="#compilation-example">Compilation Example</a></h3>
<p>Assume that the WASM file <a href="embed/c/../tools/wasmedge/examples/fibonacci.wasm"><code>fibonacci.wasm</code></a> is copied into the current directory, and the C file <code>test.c</code> is as following:</p>
<pre><code class="language-c">#include &lt;wasmedge/wasmedge.h&gt;
#include &lt;stdio.h&gt;
int main() {
  /* Create the configure context. */
  WasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();
  /* ... Adjust settings in the configure context. */
  /* Result. */
  WasmEdge_Result Res;

  /* Create the compiler context. The configure context can be NULL. */
  WasmEdge_CompilerContext *CompilerCxt = WasmEdge_CompilerCreate(ConfCxt);
  /* Compile the WASM file with input and output paths. */
  Res = WasmEdge_CompilerCompile(CompilerCxt, &quot;fibonacci.wasm&quot;, &quot;fibonacci.wasm.so&quot;);
  if (!WasmEdge_ResultOK(Res)) {
      printf(&quot;Compilation failed: %s\n&quot;, WasmEdge_ResultGetMessage(Res));
      return 1;
  }

  WasmEdge_CompilerDelete(CompilerCxt);
  WasmEdge_ConfigureDelete(ConfCxt);
  return 0;
}
</code></pre>
<p>Then you can compile and run (the output file is &quot;fibonacci.wasm.so&quot;):</p>
<pre><code class="language-bash">$ gcc test.c -lwasmedge_c
$ ./a.out
[2021-07-02 11:08:08.651] [info] compile start
[2021-07-02 11:08:08.653] [info] verify start
[2021-07-02 11:08:08.653] [info] optimize start
[2021-07-02 11:08:08.670] [info] codegen start
[2021-07-02 11:08:08.706] [info] compile done
</code></pre>
<h3 id="compiler-options"><a class="header" href="#compiler-options">Compiler Options</a></h3>
<p>Developers can set options for AOT compilers such as optimization level and output format:</p>
<pre><code class="language-c">/// AOT compiler optimization level enumeration.
enum WasmEdge_CompilerOptimizationLevel {
  /// Disable as many optimizations as possible.
  WasmEdge_CompilerOptimizationLevel_O0 = 0,
  /// Optimize quickly without destroying debuggability.
  WasmEdge_CompilerOptimizationLevel_O1,
  /// Optimize for fast execution as much as possible without triggering
  /// significant incremental compile time or code size growth.
  WasmEdge_CompilerOptimizationLevel_O2,
  /// Optimize for fast execution as much as possible.
  WasmEdge_CompilerOptimizationLevel_O3,
  /// Optimize for small code size as much as possible without triggering
  /// significant incremental compile time or execution time slowdowns.
  WasmEdge_CompilerOptimizationLevel_Os,
  /// Optimize for small code size as much as possible.
  WasmEdge_CompilerOptimizationLevel_Oz
};

/// AOT compiler output binary format enumeration.
enum WasmEdge_CompilerOutputFormat {
  /// Native dynamic library format.
  WasmEdge_CompilerOutputFormat_Native = 0,
  /// WebAssembly with AOT compiled codes in custom sections.
  WasmEdge_CompilerOutputFormat_Wasm
};
</code></pre>
<p>Please refer to the <a href="embed/c/ref.html#Configurations">AOT compiler options configuration</a> for details.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="wasmedge-go-sdk"><a class="header" href="#wasmedge-go-sdk">WasmEdge Go SDK</a></h1>
<p>The followings are the guides to working with the WasmEdge Go API. You can embed the WasmEdge into your go application through the WasmEdge Go API.</p>
<h2 id="getting-started-1"><a class="header" href="#getting-started-1">Getting Started</a></h2>
<p>The WasmEdge-go requires golang version &gt;= 1.15. Please check your golang version before installation. Developers can <a href="https://golang.org/dl/">download golang here</a>.</p>
<pre><code class="language-bash">$ go version
go version go1.16.5 linux/amd64
</code></pre>
<p>Developers must <a href="https://github.com/WasmEdge/WasmEdge/blob/master/docs/install.md">install the WasmEdge shared library</a> with the same <code>WasmEdge-go</code> release version.</p>
<pre><code class="language-bash">wget -qO- https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/utils/install.sh | bash -s -- -v 0.9.0-rc.4
</code></pre>
<p>For more details, please refer to the <a href="embed/../start/install.html">Installation Guide</a> for the WasmEdge installation.</p>
<p>For the developers need the <code>TensorFlow</code> or <code>Image</code> extension for <code>WasmEdge-go</code>, please install the <code>WasmEdge</code> with extensions:</p>
<pre><code class="language-bash">wget -qO- https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/utils/install.sh | bash -s -- -v 0.9.0-rc.4
</code></pre>
<p>Noticed that the <code>TensorFlow</code> and <code>Image</code> extensions are only for the <code>Linux</code> platforms.</p>
<p>Install the <code>WasmEdge-go</code> package and build in your Go project directory:</p>
<pre><code class="language-bash">$ go get github.com/second-state/WasmEdge-go/wasmedge@v0.9.0-rc3
$ go build
</code></pre>
<h2 id="wasmedge-go-extensions"><a class="header" href="#wasmedge-go-extensions">WasmEdge-go Extensions</a></h2>
<p>By default, the <code>WasmEdge-go</code> only turns on the basic runtime.</p>
<p><code>WasmEdge-go</code> has the following extensions:</p>
<ul>
<li>Tensorflow
<ul>
<li>This extension supports the host functions in <a href="https://github.com/second-state/WasmEdge-tensorflow">WasmEdge-tensorflow</a>.</li>
<li>The <code>TensorFlow</code> extension when installing <code>WasmEdge</code> is required. Please install <code>WasmEdge</code> with the <code>-e tensorflow</code> command.</li>
<li>For using this extension, the tag <code>tensorflow</code> when building is required:
<pre><code class="language-bash">$ go build -tags tensorflow
</code></pre>
</li>
</ul>
</li>
<li>Image
<ul>
<li>This extension supports the host functions in <a href="https://github.com/second-state/WasmEdge-image">WasmEdge-image</a>.</li>
<li>The <code>Image</code> extension when installing <code>WasmEdge</code> is required. Please install <code>WasmEdge</code> with the <code>-e image</code> command.</li>
<li>For using this extension, the tag <code>image</code> when building is required:
<pre><code class="language-bash">$ go build -tags image
</code></pre>
</li>
</ul>
</li>
</ul>
<p>Users can also turn on the multiple extensions when building:</p>
<pre><code class="language-bash">$ go build -tags image,tensorflow
</code></pre>
<p>For examples, please refer to the <a href="https://github.com/second-state/WasmEdge-go-examples/">example repository</a>.</p>
<h3 id="wasmedge-aot-compiler-in-go"><a class="header" href="#wasmedge-aot-compiler-in-go">WasmEdge AOT Compiler in Go</a></h3>
<p>The <a href="https://github.com/second-state/WasmEdge-go-examples/tree/master/go_WasmAOT">go_WasmAOT example</a> provide a tool for compiling a WASM file into compiled-WASM for AOT mode.</p>
<h2 id="examples-1"><a class="header" href="#examples-1">Examples</a></h2>
<ul>
<li><a href="embed/go/app.html">Embed a standalone Wasm app</a></li>
<li><a href="embed/go/function.html">Embed a Wasm function</a></li>
<li><a href="embed/go/memory.html">Pass complex parameters to Wasm functions</a></li>
<li><a href="embed/go/tensorflow.html">Embed a Tensorflow inference function</a></li>
<li><a href="embed/go/bindgen.html">Embed a bindgen function</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="embed-a-standalone-wasm-app"><a class="header" href="#embed-a-standalone-wasm-app">Embed a standalone WASM app</a></h1>
<p>The WasmEdge Go SDK can <a href="https://github.com/second-state/WasmEdge-go-examples/tree/master/go_ReadFile">embed standalone WebAssembly applications</a> — ie a Rust application with a <code>main()</code> function compiled into WebAssembly.</p>
<p>Our <a href="https://github.com/second-state/WasmEdge-go-examples/tree/master/go_ReadFile/rust_readfile">demo Rust application</a> reads from a file. Note that the WebAssembly program's input and output data are now passed by the STDIN and STDOUT.</p>
<pre><pre class="playground"><code class="language-rust">use std::env;
use std::fs::File;
use std::io::{self, BufRead};

fn main() {
    // Get the argv.
    let args: Vec&lt;String&gt; = env::args().collect();
    if args.len() &lt;= 1 {
        println!(&quot;Rust: ERROR - No input file name.&quot;);
        return;
    }

    // Open the file.
    println!(&quot;Rust: Opening input file \&quot;{}\&quot;...&quot;, args[1]);
    let file = match File::open(&amp;args[1]) {
        Err(why) =&gt; {
            println!(&quot;Rust: ERROR - Open file \&quot;{}\&quot; failed: {}&quot;, args[1], why);
            return;
        },
        Ok(file) =&gt; file,
    };

    // Read lines.
    let reader = io::BufReader::new(file);
    let mut texts:Vec&lt;String&gt; = Vec::new();
    for line in reader.lines() {
        if let Ok(text) = line {
            texts.push(text);
        }
    }
    println!(&quot;Rust: Read input file \&quot;{}\&quot; succeeded.&quot;, args[1]);

    // Get stdin to print lines.
    println!(&quot;Rust: Please input the line number to print the line of file.&quot;);
    let stdin = io::stdin();
    for line in stdin.lock().lines() {
        let input = line.unwrap();
        match input.parse::&lt;usize&gt;() {
            Ok(n) =&gt; if n &gt; 0 &amp;&amp; n &lt;= texts.len() {
                println!(&quot;{}&quot;, texts[n - 1]);
            } else {
                println!(&quot;Rust: ERROR - Line \&quot;{}\&quot; is out of range.&quot;, n);
            },
            Err(e) =&gt; println!(&quot;Rust: ERROR - Input \&quot;{}\&quot; is not an integer: {}&quot;, input, e),
        }
    }
    println!(&quot;Rust: Process end.&quot;);
}
</code></pre></pre>
<p>Compile the application into WebAssembly.</p>
<pre><code class="language-bash">$ cd rust_readfile
$ cargo build --target wasm32-wasi
# The output file will be target/wasm32-wasi/debug/rust_readfile.wasm
</code></pre>
<p>The Go source code to run the WebAssembly function in WasmEdge is as follows.</p>
<pre><code class="language-go">package main

import (
    &quot;os&quot;
    &quot;github.com/second-state/WasmEdge-go/wasmedge&quot;
)

func main() {
    wasmedge.SetLogErrorLevel()

    var conf = wasmedge.NewConfigure(wasmedge.REFERENCE_TYPES)
    conf.AddConfig(wasmedge.WASI)
    var vm = wasmedge.NewVMWithConfig(conf)
    var wasi = vm.GetImportObject(wasmedge.WASI)
    wasi.InitWasi(
        os.Args[1:],     /// The args
        os.Environ(),    /// The envs
        []string{&quot;.:.&quot;}, /// The mapping directories
    )

    /// Instantiate wasm. _start refers to the main() function
    vm.RunWasmFile(os.Args[1], &quot;_start&quot;)

    vm.Release()
    conf.Release()
}
</code></pre>
<p>Next, let's build the Go application with the WasmEdge Go SDK.</p>
<pre><code class="language-bash">$ go get github.com/second-state/WasmEdge-go/wasmedge@v0.9.0-rc3
$ go build
</code></pre>
<p>Run the Golang application.</p>
<pre><code class="language-bash">$ ./read_file rust_readfile/target/wasm32-wasi/debug/rust_readfile.wasm file.txt
Rust: Opening input file &quot;file.txt&quot;...
Rust: Read input file &quot;file.txt&quot; succeeded.
Rust: Please input the line number to print the line of file.
# Input &quot;5&quot; and press Enter.
5
# The output will be the 5th line of `file.txt`:
abcDEF___!@#$%^
# To terminate the program, send the EOF (Ctrl + D).
^D
# The output will print the terminate message:
Rust: Process end.
</code></pre>
<p>More examples can be found at <a href="https://github.com/second-state/WasmEdge-go-examples">the WasmEdge-go-examples GitHub repo.</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="embed-a-wasm-function"><a class="header" href="#embed-a-wasm-function">Embed a Wasm function</a></h1>
<p>The WasmEdge Go SDK allows WebAssembly functions to be embedded into
a Go host app. You can use the Go SDK API to pass call parameters
to the embedded WebAssembly functions, and then capture the return values.
However, the WebAssembly spec only supports a few simple data types out of the box. It <a href="https://medium.com/wasm/strings-in-webassembly-wasm-57a05c1ea333">does not support</a> types such as string and array. In order to pass rich types in Go to WebAssembly,
we could hand-code memory pointers (<a href="embed/go/memory.html">see here</a>), or use an
automated tool to manage the data exchange.</p>
<p>The <a href="https://github.com/second-state/wasmedge-bindgen">wasmedge-bindgen</a> 
project provides Rust macros for functions to accept and return complex data types, and then for Go functions to call such Rust functions running in WasmEdge.
The full source code for the demo in this chapter is <a href="https://github.com/second-state/WasmEdge-go-examples/tree/master/wasmedge-bindgen/go_BindgenFuncs">available here</a>.</p>
<h2 id="rust-function-compiled-into-webassembly"><a class="header" href="#rust-function-compiled-into-webassembly">Rust function compiled into WebAssembly</a></h2>
<p>In the <a href="https://github.com/second-state/WasmEdge-go-examples/tree/master/wasmedge-bindgen/go_BindgenFuncs/rust_bindgen_funcs">Rust project</a>, all you need is to annotate <a href="https://github.com/second-state/WasmEdge-go-examples/blob/master/wasmedge-bindgen/go_BindgenFuncs/rust_bindgen_funcs/src/lib.rs">your functions</a> with a <code>[wasmedge_bindgen]</code> macro.
Those annotated functions will be automatically instrumented by the Rust compiler and turned into
WebAssembly functions that can be called from the <code>wasmedge-bindgen</code> GO SDK.
In the example below, we have several Rust functions that take complex call
parameters and return complex values.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use wasmedge_bindgen::*;
use wasmedge_bindgen_macro::*;
use num_integer::lcm;
use sha3::{Digest, Sha3_256, Keccak256};
use serde::{Serialize, Deserialize};

#[derive(Serialize, Deserialize, Debug)]
struct Point {
  x: f32,
  y: f32
}

#[derive(Serialize, Deserialize, Debug)]
struct Line {
  points: Vec&lt;Point&gt;,
  valid: bool,
  length: f32,
  desc: String
}

#[wasmedge_bindgen]
pub fn create_line(p1: String, p2: String, desc: String) -&gt; Result&lt;Vec&lt;u8&gt;, String&gt; {
  let point1: Point = serde_json::from_str(p1.as_str()).unwrap();
  let point2: Point = serde_json::from_str(p2.as_str()).unwrap();
  let length = ((point1.x - point2.x) * (point1.x - point2.x) + (point1.y - point2.y) * (point1.y - point2.y)).sqrt();

  let valid = if length == 0.0 { false } else { true };

  let line = Line { points: vec![point1, point2], valid: valid, length: length, desc: desc };

  return Ok(serde_json::to_vec(&amp;line).unwrap());
}

#[wasmedge_bindgen]
pub fn say(s: String) -&gt; Result&lt;Vec&lt;u8&gt;, String&gt; {
  let r = String::from(&quot;hello &quot;);
  return Ok((r + s.as_str()).as_bytes().to_vec());
}

#[wasmedge_bindgen]
pub fn obfusticate(s: String) -&gt; Result&lt;Vec&lt;u8&gt;, String&gt; {
  let r: String = (&amp;s).chars().map(|c| {
    match c {
      'A' ..= 'M' | 'a' ..= 'm' =&gt; ((c as u8) + 13) as char,
      'N' ..= 'Z' | 'n' ..= 'z' =&gt; ((c as u8) - 13) as char,
      _ =&gt; c
    }
  }).collect();
  Ok(r.as_bytes().to_vec())
}

#[wasmedge_bindgen]
pub fn lowest_common_multiple(a: i32, b: i32) -&gt; Result&lt;Vec&lt;u8&gt;, String&gt; {
  let r = lcm(a, b);
  return Ok(r.to_string().as_bytes().to_vec());
}

#[wasmedge_bindgen]
pub fn sha3_digest(v: Vec&lt;u8&gt;) -&gt; Result&lt;Vec&lt;u8&gt;, String&gt; {
  return Ok(Sha3_256::digest(&amp;v).as_slice().to_vec());
}

#[wasmedge_bindgen]
pub fn keccak_digest(s: Vec&lt;u8&gt;) -&gt; Result&lt;Vec&lt;u8&gt;, String&gt; {
  return Ok(Keccak256::digest(&amp;s).as_slice().to_vec());
}
<span class="boring">}
</span></code></pre></pre>
<p>You can build the WebAssembly bytecode file using standard <code>Cargo</code> commands.</p>
<pre><code class="language-bash">$ cd rust_bindgen_funcs
$ cargo build --target wasm32-wasi --release

# The output WASM will be target/wasm32-wasi/release/rust_bindgen_funcs_lib.wasm.

$ cp target/wasm32-wasi/release/rust_bindgen_funcs_lib.wasm ../
$ cd ../
</code></pre>
<h2 id="go-host-application"><a class="header" href="#go-host-application">Go host application</a></h2>
<p>In the <a href="https://github.com/second-state/WasmEdge-go-examples/blob/master/wasmedge-bindgen/go_BindgenFuncs/bindgen_funcs.go">Go host application</a>,
you can create and set up the WasmEdge VM using the WasmEdge Go SDK.
However, instead of calling <code>vm.Instantiate()</code>, you should now call
<code>bindgen.Instantiate(vm)</code> to instantiate the VM and return a <code>bindgen</code>
object.</p>
<pre><code class="language-go">func main() {
	/// Expected Args[0]: program name (./bindgen_funcs)
	/// Expected Args[1]: wasm file (rust_bindgen_funcs_lib.wasm))
	
	wasmedge.SetLogErrorLevel()
	var conf = wasmedge.NewConfigure(wasmedge.WASI)
	var vm = wasmedge.NewVMWithConfig(conf)
	var wasi = vm.GetImportObject(wasmedge.WASI)
	wasi.InitWasi(
		os.Args[1:],     /// The args
		os.Environ(),    /// The envs
		[]string{&quot;.:.&quot;}, /// The mapping preopens
	)
	vm.LoadWasmFile(os.Args[1])
	vm.Validate()

	// Instantiate the bindgen and vm
	bg := bindgen.Instantiate(vm)
</code></pre>
<p>Next, you can call any <code>[wasmedge_bindgen]</code> annotated functions in the VM
via the <code>bindgen</code> object.</p>
<pre><code class="language-go">	/// create_line: string, string, string -&gt; string (inputs are JSON stringified)	
	res, err := bg.Execute(&quot;create_line&quot;, &quot;{\&quot;x\&quot;:2.5,\&quot;y\&quot;:7.8}&quot;, &quot;{\&quot;x\&quot;:2.5,\&quot;y\&quot;:5.8}&quot;, &quot;A thin red line&quot;)
	if err == nil {
		fmt.Println(&quot;Run bindgen -- create_line:&quot;, string(res))
	} else {
		fmt.Println(&quot;Run bindgen -- create_line FAILED&quot;, err)
	}

	/// say: string -&gt; string
	res, err = bg.Execute(&quot;say&quot;, &quot;bindgen funcs test&quot;)
	if err == nil {
		fmt.Println(&quot;Run bindgen -- say:&quot;, string(res))
	} else {
		fmt.Println(&quot;Run bindgen -- say FAILED&quot;)
	}

	/// obfusticate: string -&gt; string
	res, err = bg.Execute(&quot;obfusticate&quot;, &quot;A quick brown fox jumps over the lazy dog&quot;)
	if err == nil {
		fmt.Println(&quot;Run bindgen -- obfusticate:&quot;, string(res))
	} else {
		fmt.Println(&quot;Run bindgen -- obfusticate FAILED&quot;)
	}

	/// lowest_common_multiple: i32, i32 -&gt; i32
	res, err = bg.Execute(&quot;lowest_common_multiple&quot;, int32(123), int32(2))
	if err == nil {
		num, _ := strconv.ParseInt(string(res), 10, 32)
		fmt.Println(&quot;Run bindgen -- lowest_common_multiple:&quot;, num)
	} else {
		fmt.Println(&quot;Run bindgen -- lowest_common_multiple FAILED&quot;)
	}

	/// sha3_digest: array -&gt; array
	res, err = bg.Execute(&quot;sha3_digest&quot;, []byte(&quot;This is an important message&quot;))
	if err == nil {
		fmt.Println(&quot;Run bindgen -- sha3_digest:&quot;, res)
	} else {
		fmt.Println(&quot;Run bindgen -- sha3_digest FAILED&quot;)
	}

	/// keccak_digest: array -&gt; array
	res, err = bg.Execute(&quot;keccak_digest&quot;, []byte(&quot;This is an important message&quot;))
	if err == nil {
		fmt.Println(&quot;Run bindgen -- keccak_digest:&quot;, res)
	} else {
		fmt.Println(&quot;Run bindgen -- keccak_digest FAILED&quot;)
	}

	bg.Release()
	vm.Release()
	conf.Release()
}
</code></pre>
<p>Finally, you can build and run the Go host application.</p>
<pre><code class="language-bash">$ go build
$ ./bindgen_funcs rust_bindgen_funcs_lib.wasm
</code></pre>
<p>The standard output of this example will be the following.</p>
<pre><code class="language-bash">Run bindgen -- create_line: {&quot;points&quot;:[{&quot;x&quot;:1.5,&quot;y&quot;:3.8},{&quot;x&quot;:2.5,&quot;y&quot;:5.8}],&quot;valid&quot;:true,&quot;length&quot;:2.2360682,&quot;desc&quot;:&quot;A thin red line&quot;}
Run bindgen -- say: hello bindgen funcs test
Run bindgen -- obfusticate: N dhvpx oebja sbk whzcf bire gur ynml qbt
Run bindgen -- lowest_common_multiple: 246
Run bindgen -- sha3_digest: [87 27 231 209 189 105 251 49 159 10 211 250 15 159 154 181 43 218 26 141 56 199 25 45 60 10 20 163 54 211 195 203]
Run bindgen -- keccak_digest: [126 194 241 200 151 116 227 33 216 99 159 22 107 3 177 169 216 191 114 156 174 193 32 159 246 228 245 133 52 75 55 27]
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pass-complex-parameters-to-wasm-functions"><a class="header" href="#pass-complex-parameters-to-wasm-functions">Pass complex parameters to Wasm functions</a></h1>
<p>An issue with the WebAssembly spec is that it only supports a very limited
number of data types. If you want to embed a WebAssembly function with 
complex call parameters or return values, you will need to 
manage memory pointers both on Go SDK and WebAssembly function sides.
Such complex call parameters and return values include dynamic memory
structures such as strings and byte arrays.
In this section, we will discuss several examples.</p>
<ul>
<li><a href="embed/go/memory.html#pass-strings-to-rust-functions">Pass strings to Rust functions</a></li>
<li><a href="embed/go/memory.html#pass-strings-to-tinygo-functions">Pass strings to TinyGo functions</a></li>
<li><a href="embed/go/memory.html#pass-bytes-to-rust-functions">Pass bytes to Rust functions</a></li>
<li><a href="embed/go/memory.html#pass-bytes-to-tinygo-functions">Pass bytes to TinyGo functions</a></li>
</ul>
<h2 id="pass-strings-to-rust-functions"><a class="header" href="#pass-strings-to-rust-functions">Pass strings to Rust functions</a></h2>
<p>In <a href="https://github.com/second-state/WasmEdge-go-examples/tree/master/go_MemoryGreet">this example</a>, we will demonstrate how to call <a href="https://github.com/second-state/WasmEdge-go-examples/blob/master/go_MemoryGreet/rust_memory_greet/src/lib.rs">a Rust-based WebAssembly function</a> from a Go app.
Specially, we will discuss how to pass string data.</p>
<blockquote>
<p>An alternative approach to pass and return complex values to Rust functions in WebAssembly is to use the <code>wasm-bindgen</code> compiler tool. You can <a href="embed/go/bindgen.html">learn more here</a>.</p>
</blockquote>
<p>The Rust function takes a memory pointer for the string, and constructs the Rust string itself.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::ffi::{CStr, CString};
use std::mem;
use std::os::raw::{c_char, c_void};

#[no_mangle]
pub extern fn allocate(size: usize) -&gt; *mut c_void {
    let mut buffer = Vec::with_capacity(size);
    let pointer = buffer.as_mut_ptr();
    mem::forget(buffer);

    pointer as *mut c_void
}

#[no_mangle]
pub extern fn deallocate(pointer: *mut c_void, capacity: usize) {
    unsafe {
        let _ = Vec::from_raw_parts(pointer, 0, capacity);
    }
}

#[no_mangle]
pub extern fn greet(subject: *mut c_char) -&gt; *mut c_char {
    let subject = unsafe { CStr::from_ptr(subject).to_bytes().to_vec() };
    let mut output = b&quot;Hello, &quot;.to_vec();
    output.extend(&amp;subject);
    output.extend(&amp;[b'!']);

    unsafe { CString::from_vec_unchecked(output) }.into_raw()
}
<span class="boring">}
</span></code></pre></pre>
<p>Use standard Rust compiler tools to compile the Rust source code into a WebAssembly bytecode application.</p>
<pre><code class="language-bash">$ cd rust_memory_greet
$ cargo build --target wasm32-wasi
# The output WASM will be `target/wasm32-wasi/debug/rust_memory_greet_lib.wasm`.
</code></pre>
<p>The <a href="https://github.com/second-state/WasmEdge-go-examples/blob/master/go_MemoryGreet/greet_memory.go">Go SDK application</a> must call <code>allocate</code> from the WasmEdge
VM to get a pointer to the string parameter. It will then call the <code>greet</code> 
function in Rust with the pointer. After the function returns, the Go application will call <code>deallocate</code>
to free the memory space.</p>
<pre><code class="language-go">package main

import (
	&quot;fmt&quot;
	&quot;os&quot;
	&quot;strings&quot;

	&quot;github.com/second-state/WasmEdge-go/wasmedge&quot;
)

func main() {
	wasmedge.SetLogErrorLevel()
	conf := wasmedge.NewConfigure(wasmedge.WASI)
	store := wasmedge.NewStore()
	vm := wasmedge.NewVMWithConfigAndStore(conf, store)

	wasi := vm.GetImportObject(wasmedge.WASI)
	wasi.InitWasi(
		os.Args[1:],
		os.Environ(),
		[]string{&quot;.:.&quot;},
	)

	err := vm.LoadWasmFile(os.Args[1])
	if err != nil {
		fmt.Println(&quot;failed to load wasm&quot;)
	}
	vm.Validate()
	vm.Instantiate()

	subject := &quot;WasmEdge&quot;
	lengthOfSubject := len(subject)

	// Allocate memory for the subject, and get a pointer to it.
	// Include a byte for the NULL terminator we add below.
	allocateResult, _ := vm.Execute(&quot;allocate&quot;, int32(lengthOfSubject+1))
	inputPointer := allocateResult[0].(int32)

	// Write the subject into the memory.
	mem := store.FindMemory(&quot;memory&quot;)
	memData, _ := mem.GetData(uint(inputPointer), uint(lengthOfSubject+1))
	copy(memData, subject)

	// C-string terminates by NULL.
	memData[lengthOfSubject] = 0

	// Run the `greet` function. Given the pointer to the subject.
	greetResult, _ := vm.Execute(&quot;greet&quot;, inputPointer)
	outputPointer := greetResult[0].(int32)

	pageSize := mem.GetPageSize()
	// Read the result of the `greet` function.
	memData, _ = mem.GetData(uint(0), uint(pageSize * 65536))
	nth := 0
	var output strings.Builder

	for {
		if memData[int(outputPointer) + nth] == 0 {
			break
		}

		output.WriteByte(memData[int(outputPointer) + nth])
		nth++
	}

	lengthOfOutput := nth

	fmt.Println(output.String())

	// Deallocate the subject, and the output.
	vm.Execute(&quot;deallocate&quot;, inputPointer, int32(lengthOfSubject+1))
	vm.Execute(&quot;deallocate&quot;, outputPointer, int32(lengthOfOutput+1))

	vm.Release()
	store.Release()
	conf.Release()
}
</code></pre>
<p>To build the Go SDK example, run the following commands.</p>
<pre><code class="language-bash">$ go get github.com/second-state/WasmEdge-go/wasmedge@v0.9.0-rc5
$ go build greet_memory.go
</code></pre>
<p>Now you can use the Go application to run the WebAssembly plug-in compiled from Rust.</p>
<pre><code class="language-bash">$ ./greet_memory rust_memory_greet_lib.wasm
Hello, WasmEdge!
</code></pre>
<h2 id="pass-strings-to-tinygo-functions"><a class="header" href="#pass-strings-to-tinygo-functions">Pass strings to TinyGo functions</a></h2>
<p>In <a href="https://github.com/second-state/WasmEdge-go-examples/tree/master/go_MemoryGreetTinyGo">this example</a>, we will demonstrate how to call <a href="https://github.com/second-state/WasmEdge-go-examples/blob/master/go_MemoryGreetTinyGo/greet.go">a TinyGo-based WebAssembly function</a> from a Go app.</p>
<p>The TinyGo function takes a memory pointer for the string, and constructs the TinyGo string itself.</p>
<blockquote>
<p>The empty <code>main()</code> is needed to the compiled WebAssembly program to set up WASI properly.</p>
</blockquote>
<pre><code class="language-go">package main

import (
	&quot;strings&quot;
	&quot;unsafe&quot;
)

func main() {}

//export greet
func greet(subject *int32) *byte {
	nth := 0
	var subjectStr strings.Builder
	pointer := uintptr(unsafe.Pointer(subject))
	for {
		s := *(*int32)(unsafe.Pointer(pointer + uintptr(nth)))
		if s == 0 {
			break;
		}

		subjectStr.WriteByte(byte(s))
		nth++
	}

	output := subjectStr.String()
	output = &quot;Hello, &quot; + output + &quot;!&quot;

	return &amp;(([]byte)(output)[0])
}
</code></pre>
<p>Use the TinyGo compiler tools to compile the Go source code into a WebAssembly bytecode application.</p>
<pre><code class="language-bash">$ tinygo build -o greet.wasm -target wasi greet.go
</code></pre>
<p>The <a href="https://github.com/second-state/WasmEdge-go-examples/blob/master/go_MemoryGreetTinyGo/greet_memory.go">Go SDK application</a> must call <code>malloc</code> from the WasmEdge
VM to get a pointer to the string parameter. It will then call the <code>greet</code>
function in TinyGo with the pointer. After the function returns, the Go application will call <code>free</code>
to free the memory space.</p>
<pre><code class="language-go">package main

import (
	&quot;fmt&quot;
	&quot;os&quot;
	&quot;strings&quot;

	&quot;github.com/second-state/WasmEdge-go/wasmedge&quot;
)

func main() {
	wasmedge.SetLogErrorLevel()
	conf := wasmedge.NewConfigure(wasmedge.WASI)
	store := wasmedge.NewStore()
	vm := wasmedge.NewVMWithConfigAndStore(conf, store)

	wasi := vm.GetImportObject(wasmedge.WASI)
	wasi.InitWasi(
		os.Args[1:],
		os.Environ(),
		[]string{&quot;.:.&quot;},
	)

	err := vm.LoadWasmFile(os.Args[1])
	if err != nil {
		fmt.Println(&quot;failed to load wasm&quot;)
	}
	vm.Validate()
	vm.Instantiate()

	subject := &quot;WasmEdge&quot;
	lengthOfSubject := len(subject)

	// Allocate memory for the subject, and get a pointer to it.
	// Include a byte for the NULL terminator we add below.
	allocateResult, _ := vm.Execute(&quot;malloc&quot;, int32(lengthOfSubject+1))
	inputPointer := allocateResult[0].(int32)

	// Write the subject into the memory.
	mem := store.FindMemory(&quot;memory&quot;)
	memData, _ := mem.GetData(uint(inputPointer), uint(lengthOfSubject+1))
	copy(memData, subject)

	// C-string terminates by NULL.
	memData[lengthOfSubject] = 0

	// Run the `greet` function. Given the pointer to the subject.
	greetResult, _ := vm.Execute(&quot;greet&quot;, inputPointer)
	outputPointer := greetResult[0].(int32)

	pageSize := mem.GetPageSize()
	// Read the result of the `greet` function.
	memData, _ = mem.GetData(uint(0), uint(pageSize * 65536))
	nth := 0
	var output strings.Builder

	for {
		if memData[int(outputPointer) + nth] == 0 {
			break
		}

		output.WriteByte(memData[int(outputPointer) + nth])
		nth++
	}

	fmt.Println(output.String())

	// Deallocate the subject, and the output.
	vm.Execute(&quot;free&quot;, inputPointer)
	vm.Execute(&quot;free&quot;, outputPointer)

	vm.Release()
	store.Release()
	conf.Release()
}
</code></pre>
<p>To build the Go SDK example, run the following commands.</p>
<pre><code class="language-bash">$ go get github.com/second-state/WasmEdge-go/wasmedge@v0.9.0-rc5
$ go build greet_memory.go
</code></pre>
<p>Now you can use the Go application to run the WebAssembly plug-in compiled from TinyGo.</p>
<pre><code class="language-bash">$ ./greet_memory greet.wasm
Hello, WasmEdge!
</code></pre>
<h2 id="pass-bytes-to-rust-functions"><a class="header" href="#pass-bytes-to-rust-functions">Pass bytes to Rust functions</a></h2>
<p>In <a href="https://github.com/second-state/WasmEdge-go-examples/tree/master/go_AccessMemory">this example</a>, we will demonstrate how to call <a href="https://github.com/second-state/WasmEdge-go-examples/blob/master/go_AccessMemory/rust_access_memory/src/lib.rs">Rust-based WebAssembly functions</a> and pass arrays to and from a Go app.</p>
<blockquote>
<p>An alternative approach to pass and return complex values to Rust functions in WebAssembly is to use the <code>wasm-bindgen</code> compiler tool. You can <a href="embed/go/bindgen.html">learn more here</a>.</p>
</blockquote>
<p>The <code>fib_array()</code> function takes a array as a call parameter and fill it with
a fibonacci sequence of numbers. Alternatively, the <code>fib_array_return_memory()</code> function returns
a array of fibonacci sequence of numbers.</p>
<p>For the array in the call parameter, the Rust function <code>fib_array()</code> takes a memory pointer 
and constructs the Rust <code>Vec</code> using <code>from_raw_parts</code>. For the array return 
value, the Rust function <code>fib_array_return_memory()</code> simply returns the pointer.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::mem;
use std::os::raw::{c_void, c_int};

#[no_mangle]
pub extern fn allocate(size: usize) -&gt; *mut c_void {
    let mut buffer = Vec::with_capacity(size);
    let pointer = buffer.as_mut_ptr();
    mem::forget(buffer);

    pointer as *mut c_void
}

#[no_mangle]
pub extern fn deallocate(pointer: *mut c_void, capacity: usize) {
    unsafe {
        let _ = Vec::from_raw_parts(pointer, 0, capacity);
    }
}

#[no_mangle]
pub extern fn fib_array(n: i32, p: *mut c_int) -&gt; i32 {
    unsafe {
        let mut arr = Vec::&lt;i32&gt;::from_raw_parts(p, 0, (4*n) as usize);
        for i in 0..n {
            if i &lt; 2 {
                arr.push(i);
            } else {
                arr.push(arr[(i - 1) as usize] + arr[(i - 2) as usize]);
            }
        }
        let r = arr[(n - 1) as usize];
        mem::forget(arr);
        r
    }
}

#[no_mangle]
pub extern fn fib_array_return_memory(n: i32) -&gt; *mut c_int {
    let mut arr = Vec::with_capacity((4 * n) as usize);
    let pointer = arr.as_mut_ptr();
    for i in 0..n {
        if i &lt; 2 {
            arr.push(i);
        } else {
            arr.push(arr[(i - 1) as usize] + arr[(i - 2) as usize]);
        }
    }
    mem::forget(arr);
    pointer
}
<span class="boring">}
</span></code></pre></pre>
<p>Use standard Rust compiler tools to compile the Rust source code into a WebAssembly bytecode application.</p>
<pre><code class="language-bash">$ cd rust_access_memory
$ cargo build --target wasm32-wasi
# The output WASM will be target/wasm32-wasi/debug/rust_access_memory_lib.wasm.
</code></pre>
<p>The <a href="https://github.com/second-state/WasmEdge-go-examples/blob/master/go_AccessMemory/run.go">Go SDK application</a> must call <code>allocate</code> from the WasmEdge
VM to get a pointer to the array. It will then call the <code>fib_array()</code> 
function in Rust and pass in the pointer. After the functions return, the Go application 
will use the WasmEdge <code>store</code> API
to construct an array from the pointer in the call parameter (<code>fib_array()</code>) or in the return value (<code>fib_array_return_memory()</code>).
The Go app will eventually 
call <code>deallocate</code>
to free the memory space. </p>
<pre><code class="language-go">package main

import (
	&quot;fmt&quot;
	&quot;os&quot;
	&quot;unsafe&quot;

	&quot;github.com/second-state/WasmEdge-go/wasmedge&quot;
)

func main() {
	wasmedge.SetLogErrorLevel()
	conf := wasmedge.NewConfigure(wasmedge.WASI)
	store := wasmedge.NewStore()
	vm := wasmedge.NewVMWithConfigAndStore(conf, store)

	wasi := vm.GetImportObject(wasmedge.WASI)
	wasi.InitWasi(
		os.Args[1:],
		os.Environ(),
		[]string{&quot;.:.&quot;},
	)

	err := vm.LoadWasmFile(os.Args[1])
	if err != nil {
		fmt.Println(&quot;failed to load wasm&quot;)
	}
	vm.Validate()
	vm.Instantiate()

	n := int32(10)

	p, err := vm.Execute(&quot;allocate&quot;, 4 * n)
	if err != nil {
		fmt.Println(&quot;allocate failed:&quot;, err)
	}

	fib, err := vm.Execute(&quot;fib_array&quot;, n, p[0])
	if err != nil {
		fmt.Println(&quot;fib_rray failed:&quot;, err)
	} else {
		fmt.Println(&quot;fib_array() returned:&quot;, fib[0])
		fmt.Printf(&quot;fib_array memory at: %p\n&quot;, unsafe.Pointer((uintptr)(p[0].(int32))))
		mem := store.FindMemory(&quot;memory&quot;)
		if mem != nil {
			// int32 occupies 4 bytes
			fibArray, err := mem.GetData(uint(p[0].(int32)), uint(n * 4))
			if err == nil &amp;&amp; fibArray != nil {
				fmt.Println(&quot;fibArray:&quot;, fibArray)
			}
		}
	}

	fibP, err := vm.Execute(&quot;fib_array_return_memory&quot;, n)
	if err != nil {
		fmt.Println(&quot;fib_array_return_memory failed:&quot;, err)
	} else {
		fmt.Printf(&quot;fib_array_return_memory memory at: %p\n&quot;, unsafe.Pointer((uintptr)(fibP[0].(int32))))
		mem := store.FindMemory(&quot;memory&quot;)
		if mem != nil {
			// int32 occupies 4 bytes
			fibArrayReturnMemory, err := mem.GetData(uint(fibP[0].(int32)), uint(n * 4))
			if err == nil &amp;&amp; fibArrayReturnMemory != nil {
				fmt.Println(&quot;fibArrayReturnMemory:&quot;, fibArrayReturnMemory)
			}
		}
	}

	_, err = vm.Execute(&quot;deallocate&quot;, p[0].(int32), 4 * n)
	if err != nil {
		fmt.Println(&quot;free failed:&quot;, err)
	}


	exitcode := wasi.WasiGetExitCode()
	if exitcode != 0 {
		fmt.Println(&quot;Go: Running wasm failed, exit code:&quot;, exitcode)
	}

	vm.Release()
	store.Release()
	conf.Release()
}
</code></pre>
<p>To build the Go SDK example, run the following commands.</p>
<pre><code class="language-bash">$ go get github.com/second-state/WasmEdge-go/wasmedge@v0.9.0-rc5
$ go build run.go
</code></pre>
<p>Now you can use the Go application to run the WebAssembly plug-in compiled from Rust.</p>
<pre><code class="language-bash">$ ./run rust_access_memory_lib.wasm
fib_array() returned: 34
fib_array memory at: 0x102d80
fibArray: [0 0 0 0 1 0 0 0 1 0 0 0 2 0 0 0 3 0 0 0 5 0 0 0 8 0 0 0 13 0 0 0 21 0 0 0 34 0 0 0]
fib_array_return_memory memory at: 0x105430
fibArrayReturnMemory: [0 0 0 0 1 0 0 0 1 0 0 0 2 0 0 0 3 0 0 0 5 0 0 0 8 0 0 0 13 0 0 0 21 0 0 0 34 0 0 0]
</code></pre>
<h2 id="pass-bytes-to-tinygo-functions"><a class="header" href="#pass-bytes-to-tinygo-functions">Pass bytes to TinyGo functions</a></h2>
<p>In <a href="https://github.com/second-state/WasmEdge-go-examples/tree/master/go_AccessMemoryTinyGo">this example</a>, we will demonstrate how to call <a href="https://github.com/second-state/WasmEdge-go-examples/blob/master/go_AccessMemoryTinyGo/fib.go">TinyGo-based WebAssembly functions</a> and pass arrays to and from a Go app.</p>
<p>The <code>fibArray</code> function takes a array as a call parameter and fill it with 
a fibonacci sequence of numbers. Alternatively, the <code>fibArrayReturnMemory</code> function returns
a array of fibonacci sequence of numbers.</p>
<pre><code class="language-go">package main

import (
	&quot;fmt&quot;
	&quot;unsafe&quot;
)

func main() {
	println(&quot;in main&quot;)
	n := int32(10)
	arr := make([]int32, n)
	arrP := &amp;arr[0]
	fmt.Printf(&quot;call fibArray(%d, %p) = %d\n&quot;, n, arrP, fibArray(n, arrP))
	fmt.Printf(&quot;call fibArrayReturnMemory(%d) return %p\n&quot;, n, fibArrayReturnMemory(n))
}

//export fibArray
func fibArray(n int32, p *int32) int32 {
	arr := unsafe.Slice(p, n)
	for i := int32(0); i &lt; n; i++ {
		switch {
		case i &lt; 2:
			arr[i] = i
		default:
			arr[i] = arr[i-1] + arr[i-2]
		}
	}
	return arr[n-1]
}

//export fibArrayReturnMemory
func fibArrayReturnMemory(n int32) *int32 {
	arr := make([]int32, n)
	for i := int32(0); i &lt; n; i++ {
		switch {
		case i &lt; 2:
			arr[i] = i
		default:
			arr[i] = arr[i-1] + arr[i-2]
		}
	}
	return &amp;arr[0]
}
</code></pre>
<p>Use the TinyGo compiler tools to compile the Go source code into a WebAssembly bytecode application.</p>
<pre><code class="language-bash">$ tinygo build -o fib.wasm -target wasi fib.go
</code></pre>
<p>The <a href="https://github.com/second-state/WasmEdge-go-examples/blob/master/go_AccessMemoryTinyGo/run.go">Go SDK application</a> must call <code>malloc</code> from the WasmEdge
VM to get a pointer to the array. It will then call the <code>fibArray()</code>
function in TinyGo with the pointer. After the functions return, the
Go app uses the WasmEdge SDK's <code>store</code> API to construct an array from the
pointer in the call parameter (<code>fibArray()</code>) or in the return value (<code>fibArrayReturnMemory()</code>).
The Go application will eventually call <code>free</code>
to free the memory space.</p>
<pre><code class="language-go">package main

import (
	&quot;fmt&quot;
	&quot;os&quot;
	&quot;unsafe&quot;

	&quot;github.com/second-state/WasmEdge-go/wasmedge&quot;
)

func main() {
	wasmedge.SetLogErrorLevel()
	conf := wasmedge.NewConfigure(wasmedge.WASI)
	store := wasmedge.NewStore()
	vm := wasmedge.NewVMWithConfigAndStore(conf, store)

	wasi := vm.GetImportObject(wasmedge.WASI)
	wasi.InitWasi(
		os.Args[1:],
		os.Environ(),
		[]string{&quot;.:.&quot;},
	)

	err := vm.LoadWasmFile(os.Args[1])
	if err != nil {
		fmt.Println(&quot;failed to load wasm&quot;)
	}
	vm.Validate()
	vm.Instantiate()

	n := int32(10)

	p, err := vm.Execute(&quot;malloc&quot;, n)
	if err != nil {
		fmt.Println(&quot;malloc failed:&quot;, err)
	}

	fib, err := vm.Execute(&quot;fibArray&quot;, n, p[0])
	if err != nil {
		fmt.Println(&quot;fibArray failed:&quot;, err)
	} else {
		fmt.Println(&quot;fibArray() returned:&quot;, fib[0])
		fmt.Printf(&quot;fibArray memory at: %p\n&quot;, unsafe.Pointer((uintptr)(p[0].(int32))))
		mem := store.FindMemory(&quot;memory&quot;)
		if mem != nil {
			// int32 occupies 4 bytes
			fibArray, err := mem.GetData(uint(p[0].(int32)), uint(n * 4))
			if err == nil &amp;&amp; fibArray != nil {
				fmt.Println(&quot;fibArray:&quot;, fibArray)
			}
		}
	}

	fibP, err := vm.Execute(&quot;fibArrayReturnMemory&quot;, n)
	if err != nil {
		fmt.Println(&quot;fibArrayReturnMemory failed:&quot;, err)
	} else {
		fmt.Printf(&quot;fibArrayReturnMemory memory at: %p\n&quot;, unsafe.Pointer((uintptr)(fibP[0].(int32))))
		mem := store.FindMemory(&quot;memory&quot;)
		if mem != nil {
			// int32 occupies 4 bytes
			fibArrayReturnMemory, err := mem.GetData(uint(fibP[0].(int32)), uint(n * 4))
			if err == nil &amp;&amp; fibArrayReturnMemory != nil {
				fmt.Println(&quot;fibArrayReturnMemory:&quot;, fibArrayReturnMemory)
			}
		}
	}

	_, err = vm.Execute(&quot;free&quot;, p...)
	if err != nil {
		fmt.Println(&quot;free failed:&quot;, err)
	}


	exitcode := wasi.WasiGetExitCode()
	if exitcode != 0 {
		fmt.Println(&quot;Go: Running wasm failed, exit code:&quot;, exitcode)
	}

	vm.Release()
	store.Release()
	conf.Release()
}
</code></pre>
<p>To build the Go SDK example, run the following commands.</p>
<pre><code class="language-bash">$ go get github.com/second-state/WasmEdge-go/wasmedge@v0.9.0-rc5
$ go build run.go
</code></pre>
<p>Now you can use the Go application to run the WebAssembly plug-in compiled from TinyGo.</p>
<pre><code class="language-bash">$ ./run fib.wasm
fibArray() returned: 34
fibArray memory at: 0x14d3c
fibArray: [0 0 0 0 1 0 0 0 1 0 0 0 2 0 0 0 3 0 0 0 5 0 0 0 8 0 0 0 13 0 0 0 21 0 0 0 34 0 0 0]
fibArrayReturnMemory memory at: 0x14d4c
fibArrayReturnMemory: [0 0 0 0 1 0 0 0 1 0 0 0 2 0 0 0 3 0 0 0 5 0 0 0 8 0 0 0 13 0 0 0 21 0 0 0 34 0 0 0]
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tensorflow-2"><a class="header" href="#tensorflow-2">Tensorflow</a></h1>
<p>In this section, we will show you how to create a Tensorflow inference
function in Rust for image classification, and then embed it into 
a Go application. The project source code is <a href="https://github.com/second-state/WasmEdge-go-examples/tree/master/wasmedge-bindgen/go_TfliteFood">available here</a>.</p>
<h2 id="rust-function-compiled-into-webassembly-1"><a class="header" href="#rust-function-compiled-into-webassembly-1">Rust function compiled into WebAssembly</a></h2>
<p>The Rust function for image classification is <a href="https://github.com/second-state/WasmEdge-go-examples/blob/master/wasmedge-bindgen/go_TfliteFood/rust_tflite_food/src/lib.rs">available here</a>.
It utilizes the <a href="embed/go/../../dev/rust/tensorflow.html">WasmEdge Tensorflow extension API</a> as well as the <a href="embed/go/function.html">wasmedge_bindgen</a> for passing call parameters.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[wasmedge_bindgen]
fn infer(image_data: Vec&lt;u8&gt;) -&gt; Result&lt;Vec&lt;u8&gt;, String&gt; {
    ... ...
    let flat_img = image::imageops::thumbnail(&amp;img, 192, 192);

    let model_data: &amp;[u8] = include_bytes!(&quot;lite-model_aiy_vision_classifier_food_V1_1.tflite&quot;);
    let labels = include_str!(&quot;aiy_food_V1_labelmap.txt&quot;);

    let mut session = wasmedge_tensorflow_interface::Session::new(
        model_data,
        wasmedge_tensorflow_interface::ModelType::TensorFlowLite,
    );
    session
        .add_input(&quot;input&quot;, &amp;flat_img, &amp;[1, 192, 192, 3])
        .run();
    let res_vec: Vec&lt;u8&gt; = session.get_output(&quot;MobilenetV1/Predictions/Softmax&quot;);
    ... ...
}
<span class="boring">}
</span></code></pre></pre>
<p>You can use the standard <code>Cargo</code> command to build it into a WebAssembly function.</p>
<pre><code class="language-bash">$ cd rust_tflite_food
$ cargo build --target wasm32-wasi --release
$ cp target/wasm32-wasi/release/rust_tflite_food_lib.wasm ../
$ cd ../
</code></pre>
<p>You can use our AOT compiler <code>wasmedgec</code> to instrument the WebAssembly file to make 
it run much faster. <a href="embed/go/../../start/universal.html">Learn more</a>.</p>
<pre><code class="language-bash">$ wasmedgec rust_tflite_food_lib.wasm rust_tflite_food_lib.wasm
</code></pre>
<h2 id="go-host-app"><a class="header" href="#go-host-app">Go host app</a></h2>
<p>The <a href="https://github.com/second-state/WasmEdge-go-examples/blob/master/wasmedge-bindgen/go_TfliteFood/tflite_food.go">Go host app</a> source code shows how to instantiate a WasmEdge runtime with
the Tensorflow extension, and how to pass the image data to the Rust function
in WasmEdge to run the inference.</p>
<pre><code class="language-go">func main() {
	/// Expected Args[0]: program name (./tflite_food)
	/// Expected Args[1]: wasm file (rust_tflite_food_lib.wasm)
	/// Expected Args[2]: input image name (food.jpg)

	wasmedge.SetLogErrorLevel()

	/// Set Tensorflow not to print debug info
	os.Setenv(&quot;TF_CPP_MIN_LOG_LEVEL&quot;, &quot;3&quot;)
	os.Setenv(&quot;TF_CPP_MIN_VLOG_LEVEL&quot;, &quot;3&quot;)

	var conf = wasmedge.NewConfigure(wasmedge.WASI)
	var vm = wasmedge.NewVMWithConfig(conf)
	var wasi = vm.GetImportObject(wasmedge.WASI)
	wasi.InitWasi(
		os.Args[1:],     /// The args
		os.Environ(),    /// The envs
		[]string{&quot;.:.&quot;}, /// The mapping preopens
	)

	/// Register WasmEdge-tensorflow
	var tfobj = wasmedge.NewTensorflowImportObject()
	var tfliteobj = wasmedge.NewTensorflowLiteImportObject()
	vm.RegisterImport(tfobj)
	vm.RegisterImport(tfliteobj)

	/// Load and validate the wasm
	vm.LoadWasmFile(os.Args[1])
	vm.Validate()

	// Instantiate the bindgen and vm
	bg := bindgen.Instantiate(vm)

	img, _ := ioutil.ReadFile(os.Args[2])
	if res, err := bg.Execute(&quot;infer&quot;, img); err != nil {
		fmt.Println(err)
	} else {
		fmt.Println(string(res))
	}

	bg.Release()
	vm.Release()
	conf.Release()
	tfobj.Release()
	tfliteobj.Release()
}
</code></pre>
<h2 id="build-and-run"><a class="header" href="#build-and-run">Build and run</a></h2>
<blockquote>
<p>You must have WasmEdge with its tensorflow extension installed on your machine. <a href="embed/go/../../start/install.html">Checkout the install guide</a> for details.</p>
</blockquote>
<p>The following command builds the Go host application
with the WasmEdge Go SDK and its tensorflow extension.</p>
<pre><code class="language-bash">$ go build -tags tensorflow
</code></pre>
<p>Now you can run the Go application. It calls the WebAssembly function in WasmEdge
to run inference on the input image.</p>
<pre><code class="language-bash">$ ./tflite_food rust_tflite_food_lib.wasm food.jpg
</code></pre>
<p>The results are as follows.</p>
<pre><code class="language-bash">Go: Args: [./tflite_food rust_tflite_food_lib.wasm food.jpg]
It is very likely a Hot dog in the picture
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="embed-a-bindgen-function"><a class="header" href="#embed-a-bindgen-function">Embed a bindgen function</a></h1>
<blockquote>
<p>The <code>wasm_bindgen</code> approach discussed in this chapter is deprecated. We encourage you to check out the <a href="embed/go/function.html">wasmedge_bindgen</a> approach or to <a href="embed/go/memory.html">pass memory pointers directly</a> instead.</p>
</blockquote>
<p>In <a href="https://github.com/second-state/WasmEdge-go-examples/tree/master/go_BindgenFuncs">this example</a>, we will demonstrate how to call a few simple WebAssembly functions from a Go app. The <a href="https://github.com/second-state/WasmEdge-go-examples/blob/master/go_BindgenFuncs/rust_bindgen_funcs/src/lib.rs">functions</a> are written in Rust, and require complex call parameters and return values. The <code>#[wasm_bindgen]</code> macro is needed for the compiler tools to auto-generate the correct code to pass call parameters from Go to WebAssembly.</p>
<p>The WebAssembly spec only supports a few simple data types out of the box. It <a href="https://medium.com/wasm/strings-in-webassembly-wasm-57a05c1ea333">does not support</a> types such as string and array. In order to pass rich types in Go to WebAssembly, the compiler needs to convert them to simple integers. For example, it converts a string into an integer memory address and an integer length. The <code>wasm_bindgen</code> tool, embedded in <a href="embed/go/../../dev/rust/bindgen.html">rustwasmc</a>, does this conversion automatically.</p>
<blockquote>
<p>At this time, we require Rust compiler version 1.50 or less in order for WebAssembly functions to work with WasmEdge's Go API. We will <a href="https://github.com/WasmEdge/WasmEdge/issues/264">catch up to the latest Rust</a> compiler version once the Interface Types spec is finalized and supported.</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use wasm_bindgen::prelude::*;
use num_integer::lcm;
use sha3::{Digest, Sha3_256, Keccak256};

#[wasm_bindgen]
pub fn say(s: &amp;str) -&gt; String {
  let r = String::from(&quot;hello &quot;);
  return r + s;
}

#[wasm_bindgen]
pub fn obfusticate(s: String) -&gt; String {
  (&amp;s).chars().map(|c| {
    match c {
      'A' ..= 'M' | 'a' ..= 'm' =&gt; ((c as u8) + 13) as char,
      'N' ..= 'Z' | 'n' ..= 'z' =&gt; ((c as u8) - 13) as char,
      _ =&gt; c
    }
  }).collect()
}

#[wasm_bindgen]
pub fn lowest_common_multiple(a: i32, b: i32) -&gt; i32 {
  let r = lcm(a, b);
  return r;
}

#[wasm_bindgen]
pub fn sha3_digest(v: Vec&lt;u8&gt;) -&gt; Vec&lt;u8&gt; {
  return Sha3_256::digest(&amp;v).as_slice().to_vec();
}

#[wasm_bindgen]
pub fn keccak_digest(s: &amp;[u8]) -&gt; Vec&lt;u8&gt; {
  return Keccak256::digest(s).as_slice().to_vec();
}
<span class="boring">}
</span></code></pre></pre>
<p>First, we use the <a href="embed/go/../../dev/rust/bindgen.html">rustwasmc</a> tool to compile the Rust source code into WebAssembly bytecode functions using Rust 1.50 or less.</p>
<pre><code class="language-bash">$ rustup default 1.50.0
$ cd rust_bindgen_funcs
$ rustwasmc build
# The output WASM will be pkg/rust_bindgen_funcs_lib_bg.wasm
</code></pre>
<p>The <a href="https://github.com/second-state/WasmEdge-go-examples/blob/master/go_BindgenFuncs/bindgen_funcs.go">Go source code</a> to run the WebAssembly function in WasmEdge is as follows. The <code>ExecuteBindgen()</code> function calls the WebAssembly function and passes the call parameters using the <code>#[wasm_bindgen]</code> convention.</p>
<pre><code class="language-go">package main

import (
    &quot;fmt&quot;
    &quot;os&quot;
    &quot;github.com/second-state/WasmEdge-go/wasmedge&quot;
)

func main() {
    /// Expected Args[0]: program name (./bindgen_funcs)
    /// Expected Args[1]: wasm or wasm-so file (rust_bindgen_funcs_lib_bg.wasm))

    wasmedge.SetLogErrorLevel()

    var conf = wasmedge.NewConfigure(wasmedge.WASI)
    var vm = wasmedge.NewVMWithConfig(conf)
    var wasi = vm.GetImportObject(wasmedge.WASI)
    wasi.InitWasi(
        os.Args[1:],     /// The args
        os.Environ(),    /// The envs
        []string{&quot;.:.&quot;}, /// The mapping directories
    )

    /// Instantiate wasm
    vm.LoadWasmFile(os.Args[1])
    vm.Validate()
    vm.Instantiate()

    /// Run bindgen functions
    var res interface{}
    var err error
    
    res, err = vm.ExecuteBindgen(&quot;say&quot;, wasmedge.Bindgen_return_array, []byte(&quot;bindgen funcs test&quot;))
    if err == nil {
        fmt.Println(&quot;Run bindgen -- say:&quot;, string(res.([]byte)))
    } 
    res, err = vm.ExecuteBindgen(&quot;obfusticate&quot;, wasmedge.Bindgen_return_array, []byte(&quot;A quick brown fox jumps over the lazy dog&quot;))
    if err == nil {
        fmt.Println(&quot;Run bindgen -- obfusticate:&quot;, string(res.([]byte)))
    } 
    res, err = vm.ExecuteBindgen(&quot;lowest_common_multiple&quot;, wasmedge.Bindgen_return_i32, int32(123), int32(2))
    if err == nil {
        fmt.Println(&quot;Run bindgen -- lowest_common_multiple:&quot;, res.(int32))
    } 
    res, err = vm.ExecuteBindgen(&quot;sha3_digest&quot;, wasmedge.Bindgen_return_array, []byte(&quot;This is an important message&quot;))
    if err == nil {
        fmt.Println(&quot;Run bindgen -- sha3_digest:&quot;, res.([]byte))
    } 
    res, err = vm.ExecuteBindgen(&quot;keccak_digest&quot;, wasmedge.Bindgen_return_array, []byte(&quot;This is an important message&quot;))
    if err == nil {
        fmt.Println(&quot;Run bindgen -- keccak_digest:&quot;, res.([]byte))
    } 

    vm.Release()
    conf.Release()
}
</code></pre>
<p>Next, let's build the Go application with the WasmEdge Go SDK.</p>
<pre><code class="language-bash">$ go get github.com/second-state/WasmEdge-go/wasmedge@v0.9.0-rc3
$ go build
</code></pre>
<p>Run the Go application and it will run the WebAssembly functions embedded in the WasmEdge runtime.</p>
<pre><code class="language-bash">$ ./bindgen_funcs rust_bindgen_funcs/pkg/rust_bindgen_funcs_lib_bg.wasm
Run bindgen -- say: hello bindgen funcs test
Run bindgen -- obfusticate: N dhvpx oebja sbk whzcf bire gur ynml qbt
Run bindgen -- lowest_common_multiple: 246
Run bindgen -- sha3_digest: [87 27 231 209 189 105 251 49 159 10 211 250 15 159 154 181 43 218 26 141 56 199 25 45 60 10 20 163 54 211 195 203]
Run bindgen -- keccak_digest: [126 194 241 200 151 116 227 33 216 99 159 22 107 3 177 169 216 191 114 156 174 193 32 159 246 228 245 133 52 75 55 27]
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="wasmedge-go-api-references"><a class="header" href="#wasmedge-go-api-references">WasmEdge Go API references</a></h1>
<p>The followings are the guides to working with the WasmEdge-Go SDK.</p>
<h2 id="table-of-contents-2"><a class="header" href="#table-of-contents-2">Table of Contents</a></h2>
<ul>
<li><a href="embed/go/ref.html#Getting-Started">Getting Started</a>
<ul>
<li><a href="embed/go/ref.html#WasmEdge-Installation">WasmEdge Installation</a></li>
<li><a href="embed/go/ref.html#Get-WasmEdge-go">Get WasmEdge-go</a></li>
<li><a href="embed/go/ref.html#WasmEdge-go-Extensions">WasmEdge-go Extensions</a></li>
<li><a href="embed/go/ref.html#Example-of-Embedding-A-Function-with-wasm-bindgen">Example of Embedding A Function with wasm-bindgen</a></li>
<li><a href="embed/go/ref.html#Example-of-Embedding-A-Full-WASI-Program">Example of Embedding A Full WASI Program</a></li>
</ul>
</li>
<li><a href="embed/go/ref.html#WasmEdge-go-Basics">WasmEdge-go Basics</a>
<ul>
<li><a href="embed/go/ref.html#Version">Version</a></li>
<li><a href="embed/go/ref.html#Logging-Settings">Logging Settings</a></li>
<li><a href="embed/go/ref.html#Value-Types">Value Types</a></li>
<li><a href="embed/go/ref.html#Results">Results</a></li>
<li><a href="embed/go/ref.html#Contexts-And-Their-Life-Cycles">Contexts And Their Life Cycles</a></li>
<li><a href="embed/go/ref.html#Wasm-data-structures">WASM data structures</a></li>
<li><a href="embed/go/ref.html#Configurations">Configurations</a></li>
<li><a href="embed/go/ref.html#Statistics">Statistics</a></li>
</ul>
</li>
<li><a href="embed/go/ref.html#WasmEdge-VM">WasmEdge VM</a>
<ul>
<li><a href="embed/go/ref.html#WASM-Execution-Example-With-VM-Object">WASM Execution Example With VM Object</a></li>
<li><a href="embed/go/ref.html#VM-Creations">VM Creations</a></li>
<li><a href="embed/go/ref.html#Preregistrations">Preregistrations</a></li>
<li><a href="embed/go/ref.html#Host-Module-Registrations">Host Module Registrations</a></li>
<li><a href="embed/go/ref.html#WASM-Registrations-And-Executions">WASM Registrations And Executions</a></li>
<li><a href="embed/go/ref.html#Instance-Tracing">Instance Tracing</a></li>
</ul>
</li>
<li><a href="embed/go/ref.html#WasmEdge-Runtime">WasmEdge Runtime</a>
<ul>
<li><a href="embed/go/ref.html#WASM-Execution-Example-Step-By-Step">WASM Execution Example Step-By-Step</a></li>
<li><a href="embed/go/ref.html#Loader">Loader</a></li>
<li><a href="embed/go/ref.html#Validator">Validator</a></li>
<li><a href="embed/go/ref.html#Executor">Executor</a></li>
<li><a href="embed/go/ref.html#AST-Module">AST Module</a></li>
<li><a href="embed/go/ref.html#Store">Store</a></li>
<li><a href="embed/go/ref.html#Instances">Instances</a></li>
<li><a href="embed/go/ref.html#Host-Functions">Host Functions</a></li>
</ul>
</li>
<li><a href="embed/go/ref.html#WasmEdge-AOT-Compiler">WasmEdge AOT Compiler</a>
<ul>
<li><a href="embed/go/ref.html#Compilation-Example">Compilation Example</a></li>
<li><a href="embed/go/ref.html#Compiler-Options">Compiler Options</a></li>
</ul>
</li>
</ul>
<h2 id="getting-started-2"><a class="header" href="#getting-started-2">Getting Started</a></h2>
<p>The WasmEdge-go requires golang version &gt;= 1.15. Please check your golang version before installation. Developers can <a href="https://golang.org/dl/">download golang here</a>.</p>
<pre><code class="language-bash">$ go version
go version go1.16.5 linux/amd64
</code></pre>
<h3 id="wasmedge-installation-1"><a class="header" href="#wasmedge-installation-1">WasmEdge Installation</a></h3>
<p>Developers must <a href="embed/go/start/install.html">install the WasmEdge shared library</a> with the same <code>WasmEdge-go</code> release or pre-release version.</p>
<pre><code class="language-bash">wget -qO- https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/utils/install.sh | bash -s -- -v 0.9.0
</code></pre>
<p>For the developers need the <code>TensorFlow</code> or <code>Image</code> extension for <code>WasmEdge-go</code>, please install the <code>WasmEdge</code> with extensions:</p>
<pre><code class="language-bash">wget -qO- https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/utils/install.sh | bash -s -- -e tf,image -v 0.9.0
</code></pre>
<p>Noticed that the <code>TensorFlow</code> and <code>Image</code> extensions are only for the <code>Linux</code> platforms.
After installation, developers can use the <code>source</code> command to update the include and linking searching path.</p>
<h3 id="get-wasmedge-go"><a class="header" href="#get-wasmedge-go">Get WasmEdge-go</a></h3>
<p>After the WasmEdge installation, developers can get the <code>WasmEdge-go</code> package and build it in your Go project directory.</p>
<pre><code class="language-bash">$ go get github.com/second-state/WasmEdge-go/wasmedge@v0.9.0
$ go build
</code></pre>
<h3 id="wasmedge-go-extensions-1"><a class="header" href="#wasmedge-go-extensions-1">WasmEdge-go Extensions</a></h3>
<p>By default, the <code>WasmEdge-go</code> only turns on the basic runtime.</p>
<p><code>WasmEdge-go</code> has the following extensions (on the Linux platforms only):</p>
<ul>
<li>
<p>Tensorflow</p>
<ul>
<li>
<p>This extension supports the host functions in <a href="https://github.com/second-state/WasmEdge-tensorflow">WasmEdge-tensorflow</a>.</p>
</li>
<li>
<p>The <code>TensorFlow</code> extension when installing <code>WasmEdge</code> is required. Please install <code>WasmEdge</code> with the <code>-e tensorflow</code> command.</p>
</li>
<li>
<p>For using this extension, the tag <code>tensorflow</code> when building is required:</p>
<pre><code class="language-bash">$ go build -tags tensorflow
</code></pre>
</li>
</ul>
</li>
<li>
<p>Image</p>
<ul>
<li>
<p>This extension supports the host functions in <a href="https://github.com/second-state/WasmEdge-image">WasmEdge-image</a>.</p>
</li>
<li>
<p>The <code>Image</code> extension when installing <code>WasmEdge</code> is required. Please install <code>WasmEdge</code> with the <code>-e image</code> command.</p>
</li>
<li>
<p>For using this extension, the tag <code>image</code> when building is required:</p>
<pre><code class="language-bash">$ go build -tags image
</code></pre>
</li>
</ul>
</li>
</ul>
<p>Users can also turn on the multiple extensions when building:</p>
<pre><code class="language-bash">$ go build -tags image,tensorflow
</code></pre>
<h3 id="example-of-embedding-a-function-with-wasm-bindgen"><a class="header" href="#example-of-embedding-a-function-with-wasm-bindgen">Example of Embedding A Function with wasm-bindgen</a></h3>
<p>In <a href="https://github.com/second-state/WasmEdge-go-examples/tree/master/go_BindgenFuncs">this example</a>, we will demonstrate how to call a few simple WebAssembly functions with wasm-bindgen from a Golang app. The <a href="https://github.com/second-state/WasmEdge-go-examples/blob/master/go_BindgenFuncs/rust_bindgen_funcs/src/lib.rs">functions</a> are written in Rust, and require complex call parameters and return values. The <code>#[wasm_bindgen]</code> macro is needed for the compiler tools to auto-generate the correct code to pass call parameters from Golang to WebAssembly.</p>
<p>Note: At this time, we require Rust compiler version 1.50 or less in order for WebAssembly functions to work with WasmEdge’s Golang API. We will <a href="https://github.com/WasmEdge/WasmEdge/issues/264">catch up to the latest Rust</a> compiler version once the Interface Types specification is finalized and supported.</p>
<p>Note: The WebAssembly only supports a few simple data types out of the box. It <a href="https://medium.com/wasm/strings-in-webassembly-wasm-57a05c1ea333">does not support</a> types such as string and array. In order to pass rich types in Golang to WebAssembly, the compiler needs to convert them to simple integers. For example, it converts a string into an integer memory address and an integer length. The <code>wasm-bindgen</code> tool, embedded in rustwasmc, does this conversion automatically.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use wasm_bindgen::prelude::*;
use num_integer::lcm;
use sha3::{Digest, Sha3_256, Keccak256};

#[wasm_bindgen]
pub fn say(s: &amp;str) -&gt; String {
  let r = String::from(&quot;hello &quot;);
  return r + s;
}

#[wasm_bindgen]
pub fn obfusticate(s: String) -&gt; String {
  (&amp;s).chars().map(|c| {
    match c {
      'A' ..= 'M' | 'a' ..= 'm' =&gt; ((c as u8) + 13) as char,
      'N' ..= 'Z' | 'n' ..= 'z' =&gt; ((c as u8) - 13) as char,
      _ =&gt; c
    }
  }).collect()
}

#[wasm_bindgen]
pub fn lowest_common_multiple(a: i32, b: i32) -&gt; i32 {
  let r = lcm(a, b);
  return r;
}

#[wasm_bindgen]
pub fn sha3_digest(v: Vec&lt;u8&gt;) -&gt; Vec&lt;u8&gt; {
  return Sha3_256::digest(&amp;v).as_slice().to_vec();
}

#[wasm_bindgen]
pub fn keccak_digest(s: &amp;[u8]) -&gt; Vec&lt;u8&gt; {
  return Keccak256::digest(s).as_slice().to_vec();
}
<span class="boring">}
</span></code></pre></pre>
<p>First, we use the <a href="embed/go/dev/rust/bindgen.html"><code>rustwasmc</code> tool</a> to compile the Rust source code into WebAssembly bytecode functions using Rust 1.50 or less.</p>
<pre><code class="language-bash">$ rustup default 1.50.0
$ cd rust_bindgen_funcs
$ rustwasmc build
# The output WASM will be pkg/rust_bindgen_funcs_lib_bg.wasm
</code></pre>
<p>The <a href="https://github.com/second-state/WasmEdge-go-examples/blob/master/go_BindgenFuncs/bindgen_funcs.go">Golang source code</a> to run the WebAssembly function in WasmEdge is as follows. The <code>ExecuteBindgen()</code> function calls the WebAssembly function and passes the parameters with the <code>wasm-bindgen</code> supporting.</p>
<pre><code class="language-go">package main

import (
    &quot;fmt&quot;
    &quot;os&quot;

    &quot;github.com/second-state/WasmEdge-go/wasmedge&quot;
)

func main() {
    /// Expected Args[0]: program name (./bindgen_funcs)
    /// Expected Args[1]: wasm or wasm-so file (rust_bindgen_funcs_lib_bg.wasm)

    wasmedge.SetLogErrorLevel()

    var conf = wasmedge.NewConfigure(wasmedge.WASI)
    var vm = wasmedge.NewVMWithConfig(conf)
    var wasi = vm.GetImportObject(wasmedge.WASI)
    wasi.InitWasi(
        os.Args[1:],     /// The args
        os.Environ(),    /// The envs
        []string{&quot;.:.&quot;}, /// The mapping directories
    )

    /// Instantiate wasm
    vm.LoadWasmFile(os.Args[1])
    vm.Validate()
    vm.Instantiate()

    /// Run bindgen functions
    var res interface{}
    var err error
    
    res, err = vm.ExecuteBindgen(&quot;say&quot;, wasmedge.Bindgen_return_array, []byte(&quot;bindgen funcs test&quot;))
    if err == nil {
        fmt.Println(&quot;Run bindgen -- say:&quot;, string(res.([]byte)))
    } 
    res, err = vm.ExecuteBindgen(&quot;obfusticate&quot;, wasmedge.Bindgen_return_array, []byte(&quot;A quick brown fox jumps over the lazy dog&quot;))
    if err == nil {
        fmt.Println(&quot;Run bindgen -- obfusticate:&quot;, string(res.([]byte)))
    } 
    res, err = vm.ExecuteBindgen(&quot;lowest_common_multiple&quot;, wasmedge.Bindgen_return_i32, int32(123), int32(2))
    if err == nil {
        fmt.Println(&quot;Run bindgen -- lowest_common_multiple:&quot;, res.(int32))
    } 
    res, err = vm.ExecuteBindgen(&quot;sha3_digest&quot;, wasmedge.Bindgen_return_array, []byte(&quot;This is an important message&quot;))
    if err == nil {
        fmt.Println(&quot;Run bindgen -- sha3_digest:&quot;, res.([]byte))
    } 
    res, err = vm.ExecuteBindgen(&quot;keccak_digest&quot;, wasmedge.Bindgen_return_array, []byte(&quot;This is an important message&quot;))
    if err == nil {
        fmt.Println(&quot;Run bindgen -- keccak_digest:&quot;, res.([]byte))
    } 

    vm.Release()
    conf.Release()
}
</code></pre>
<p>Next, build the Golang application with the WasmEdge Golang SDK.</p>
<pre><code class="language-bash">$ go get github.com/second-state/WasmEdge-go/wasmedge@v0.9.0
$ go build
</code></pre>
<p>Run the Golang application and it will run the WebAssembly functions embedded in the WasmEdge runtime.</p>
<pre><code class="language-bash">$ ./bindgen_funcs rust_bindgen_funcs/pkg/rust_bindgen_funcs_lib_bg.wasm
Run bindgen -- say: hello bindgen funcs test
Run bindgen -- obfusticate: N dhvpx oebja sbk whzcf bire gur ynml qbt
Run bindgen -- lowest_common_multiple: 246
Run bindgen -- sha3_digest: [87 27 231 209 189 105 251 49 159 10 211 250 15 159 154 181 43 218 26 141 56 199 25 45 60 10 20 163 54 211 195 203]
Run bindgen -- keccak_digest: [126 194 241 200 151 116 227 33 216 99 159 22 107 3 177 169 216 191 114 156 174 193 32 159 246 228 245 133 52 75 55 27]
</code></pre>
<h3 id="example-of-embedding-a-full-wasi-program"><a class="header" href="#example-of-embedding-a-full-wasi-program">Example of Embedding A Full WASI Program</a></h3>
<p>Note: You can use the latest Rust compiler to create a standalone WasmEdge application with a <code>main.rs</code> functions and then embed it into a Golang application.</p>
<p>Besides functions, the WasmEdge Golang SDK can also <a href="https://github.com/second-state/WasmEdge-go-examples/tree/master/go_ReadFile">embed standalone WebAssembly applications</a> — i.e. a Rust application with a <code>main()</code> function compiled into WebAssembly.</p>
<p>Our <a href="https://github.com/second-state/WasmEdge-go-examples/tree/master/go_ReadFile/rust_readfile">demo Rust application</a> reads from a file. Note that there is no need for <code>#[wasm_bindgen]</code> here, as the WebAssembly program’s WASI supporting for the <code>argv</code> input and <code>exit code</code> output of the <code>main()</code> function.</p>
<pre><pre class="playground"><code class="language-rust">use std::env;
use std::fs::File;
use std::io::{self, BufRead};

fn main() {
    // Get the argv.
    let args: Vec&lt;String&gt; = env::args().collect();
    if args.len() &lt;= 1 {
        println!(&quot;Rust: ERROR - No input file name.&quot;);
        return;
    }

    // Open the file.
    println!(&quot;Rust: Opening input file \&quot;{}\&quot;...&quot;, args[1]);
    let file = match File::open(&amp;args[1]) {
        Err(why) =&gt; {
            println!(&quot;Rust: ERROR - Open file \&quot;{}\&quot; failed: {}&quot;, args[1], why);
            return;
        },
        Ok(file) =&gt; file,
    };

    // Read lines.
    let reader = io::BufReader::new(file);
    let mut texts:Vec&lt;String&gt; = Vec::new();
    for line in reader.lines() {
        if let Ok(text) = line {
            texts.push(text);
        }
    }
    println!(&quot;Rust: Read input file \&quot;{}\&quot; succeeded.&quot;, args[1]);

    // Get stdin to print lines.
    println!(&quot;Rust: Please input the line number to print the line of file.&quot;);
    let stdin = io::stdin();
    for line in stdin.lock().lines() {
        let input = line.unwrap();
        match input.parse::&lt;usize&gt;() {
            Ok(n) =&gt; if n &gt; 0 &amp;&amp; n &lt;= texts.len() {
                println!(&quot;{}&quot;, texts[n - 1]);
            } else {
                println!(&quot;Rust: ERROR - Line \&quot;{}\&quot; is out of range.&quot;, n);
            },
            Err(e) =&gt; println!(&quot;Rust: ERROR - Input \&quot;{}\&quot; is not an integer: {}&quot;, input, e),
        }
    }
    println!(&quot;Rust: Process end.&quot;);
}
</code></pre></pre>
<p>Use the <code>rustwasmc</code> tool to compile the application into WebAssembly.</p>
<pre><code class="language-bash">$ cd rust_readfile
$ rustwasmc build
# The output file will be at `pkg/rust_readfile.wasm`.
</code></pre>
<p>Or you can compile the application into WebAssembly directly by <code>cargo</code>:</p>
<pre><code class="language-bash">$ cd rust_readfile
# Need to add the `wasm32-wasi` target.
$ rustup target add wasm32-wasi
$ cargo build --release --target=wasm32-wasi
# The output wasm will be at `target/wasm32-wasi/release/rust_readfile.wasm`.
</code></pre>
<p>The Golang source code to run the WebAssembly function in WasmEdge is as follows.</p>
<pre><code class="language-go">package main

import (
    &quot;os&quot;

    &quot;github.com/second-state/WasmEdge-go/wasmedge&quot;
)

func main() {
    wasmedge.SetLogErrorLevel()

    var conf = wasmedge.NewConfigure(wasmedge.REFERENCE_TYPES)
    conf.AddConfig(wasmedge.WASI)
    var vm = wasmedge.NewVMWithConfig(conf)
    var wasi = vm.GetImportObject(wasmedge.WASI)
    wasi.InitWasi(
        os.Args[1:],     /// The args
        os.Environ(),    /// The envs
        []string{&quot;.:.&quot;}, /// The mapping directories
    )

    /// Instantiate and run WASM &quot;_start&quot; function, which refers to the main() function
    vm.RunWasmFile(os.Args[1], &quot;_start&quot;)

    vm.Release()
    conf.Release()
}
</code></pre>
<p>Next, build the Golang application with the WasmEdge Golang SDK.</p>
<pre><code class="language-bash">$ go get github.com/second-state/WasmEdge-go/wasmedge@v0.9.0
$ go build
</code></pre>
<p>Run the Golang application.</p>
<pre><code class="language-bash">$ ./read_file rust_readfile/pkg/rust_readfile.wasm file.txt
Rust: Opening input file &quot;file.txt&quot;...
Rust: Read input file &quot;file.txt&quot; succeeded.
Rust: Please input the line number to print the line of file.
# Input &quot;5&quot; and press Enter.
5
# The output will be the 5th line of `file.txt`:
abcDEF___!@#$%^
# To terminate the program, send the EOF (Ctrl + D).
^D
# The output will print the terminate message:
Rust: Process end.
</code></pre>
<p>For more examples, please refer to the <a href="https://github.com/second-state/WasmEdge-go-examples/">example repository</a>.</p>
<h2 id="wasmedge-go-basics"><a class="header" href="#wasmedge-go-basics">WasmEdge-go Basics</a></h2>
<p>In this partition, we will introduce the utilities and concepts of WasmEdge-go APIs and data structures.</p>
<h3 id="version-1"><a class="header" href="#version-1">Version</a></h3>
<p>The <code>Version</code> related APIs provide developers to check for the installed WasmEdge shared library version.</p>
<pre><code class="language-go">import &quot;github.com/second-state/WasmEdge-go/wasmedge&quot;

verstr := wasmedge.GetVersion() // Will be `string` of WasmEdge version.
vermajor := wasmedge.GetVersionMajor() // Will be `uint` of WasmEdge major version number.
verminor := wasmedge.GetVersionMinor() // Will be `uint` of WasmEdge minor version number.
verpatch := wasmedge.GetVersionPatch() // Will be `uint` of WasmEdge patch version number.
</code></pre>
<h3 id="logging-settings-1"><a class="header" href="#logging-settings-1">Logging Settings</a></h3>
<p>The <code>wasmedge.SetLogErrorLevel()</code> and <code>wasmedge.SetLogDebugLevel()</code> APIs can set the logging system to debug level or error level. By default, the error level is set, and the debug info is hidden.</p>
<h3 id="value-types-1"><a class="header" href="#value-types-1">Value Types</a></h3>
<p>In WasmEdge-go, the APIs will automatically do the conversion for the built-in types, and implement the data structure for the reference types.</p>
<ol>
<li>
<p>Number types: <code>i32</code>, <code>i64</code>, <code>f32</code>, and <code>f64</code></p>
<ul>
<li>Convert the <code>uint32</code> and <code>int32</code> to <code>i32</code> automatically when passing a value into WASM.</li>
<li>Convert the <code>uint64</code> and <code>int64</code> to <code>i64</code> automatically when passing a value into WASM.</li>
<li>Convert the <code>uint</code> and <code>int</code> to <code>i32</code> automatically when passing a value into WASM in 32-bit system.</li>
<li>Convert the <code>uint</code> and <code>int</code> to <code>i64</code> automatically when passing a value into WASM in 64-bit system.</li>
<li>Convert the <code>float32</code> to <code>f32</code> automatically when passing a value into WASM.</li>
<li>Convert the <code>float64</code> to <code>f64</code> automatically when passing a value into WASM.</li>
<li>Convert the <code>i32</code> from WASM to <code>int32</code> when getting a result.</li>
<li>Convert the <code>i64</code> from WASM to <code>int64</code> when getting a result.</li>
<li>Convert the <code>f32</code> from WASM to <code>float32</code> when getting a result.</li>
<li>Convert the <code>f64</code> from WASM to <code>float64</code> when getting a result.</li>
</ul>
</li>
<li>
<p>Number type: <code>v128</code> for the <code>SIMD</code> proposal</p>
<p>Developers should use the <code>wasmedge.NewV128()</code> to generate a <code>v128</code> value, and use the <code>wasmedge.GetV128()</code> to get the value.</p>
<pre><code class="language-go">val := wasmedge.NewV128(uint64(1234), uint64(5678))
high, low := val.GetVal()
// `high` will be uint64(1234), `low` will be uint64(5678)
</code></pre>
</li>
<li>
<p>Reference types: <code>FuncRef</code> and <code>ExternRef</code> for the <code>Reference-Types</code> proposal</p>
<pre><code class="language-go">funcref := wasmedge.NewFuncRef(10)
// Create a `FuncRef` with function index 10.

num := 1234
// `num` is a `int`.
externref := wasmedge.NewExternRef(&amp;num)
// Create an `ExternRef` which reference to the `num`.
num = 5678
// Modify the `num` to 5678.
numref := externref.GetRef().(*int)
// Get the original reference from the `ExternRef`.
fmt.Println(*numref)
// Will print `5678`.
numref.Release()
// Should call the `Release` method.
</code></pre>
</li>
</ol>
<h3 id="results-1"><a class="header" href="#results-1">Results</a></h3>
<p>The <code>Result</code> object specifies the execution status. Developers can use the <code>Error()</code> function to get the error message.</p>
<pre><code class="language-go">// Assume that `vm` is a `wasmedge.VM` object.
res, err = vm.Execute(...) // Ignore the detail of parameters.
// Assume that `res, err` are the return values for executing a function with `vm`.
if err != nil {
    fmt.Println(&quot;Error message:&quot;, err.Error())
}
</code></pre>
<h3 id="contexts-and-their-life-cycles"><a class="header" href="#contexts-and-their-life-cycles">Contexts And Their Life Cycles</a></h3>
<p>The objects, such as <code>VM</code>, <code>Store</code>, and <code>Function</code>, etc., are composed of <code>Context</code>s in the WasmEdge shared library.
All of the contexts can be created by calling the corresponding <code>New</code> APIs, developers should also call the corresponding <code>Release</code> functions of the contexts to release the resources.
Noticed that it's not necessary to call the <code>Release</code> functions for the contexts which are retrieved from other contexts but not created from the <code>New</code> APIs.</p>
<pre><code class="language-go">// Create a Configure.
conf := wasmedge.NewConfigure()
// Release the `conf` immediately.
conf.Release()
</code></pre>
<p>The details of other contexts will be introduced later.</p>
<h3 id="wasm-data-structures-1"><a class="header" href="#wasm-data-structures-1">WASM Data Structures</a></h3>
<p>The WASM data structures are used for creating instances or can be queried from instance contexts.
The details of instances creation will be introduced in the <a href="embed/go/ref.html#Instances">Instances</a>.</p>
<ol>
<li>
<p>Limit</p>
<p>The <code>Limit</code> struct presents the minimum and maximum value data structure.</p>
<pre><code class="language-go">lim1 := wasmedge.NewLimit(12)
fmt.Println(lim1.HasMax())
// Will print `false`.
fmt.Println(lim1.GetMin())
// Will print `12`.

lim2 := wasmedge.NewLimitWithMax(15, 50)
fmt.Println(lim2.HasMax())
// Will print `true`.
fmt.Println(lim2.GetMin())
// Will print `15`.
fmt.Println(lim2.GetMax())
// Will print `50`.
</code></pre>
</li>
<li>
<p>Function type context</p>
<p>The <code>FunctionType</code> is an object holds the function type context and used for the <code>Function</code> creation, checking the value types of a <code>Function</code> instance, or getting the function type with function name from VM.
Developers can use the <code>FunctionType</code> APIs to get the parameter or return value types information.</p>
<pre><code class="language-go">functype := wasmedge.NewFunctionType(
    []wasmedge.ValType{
        wasmedge.ValType_ExternRef,
        wasmedge.ValType_I32,
        wasmedge.ValType_I64,
    }, []wasmedge.ValType{
        wasmedge.ValType_F32,
        wasmedge.ValType_F64,
    })

plen := functype.GetParametersLength()
// `plen` will be 3.
rlen := functype.GetReturnsLength()
// `rlen` will be 2.
plist := functype.GetParameters()
// `plist` will be `[]wasmedge.ValType{wasmedge.ValType_ExternRef, wasmedge.ValType_I32, wasmedge.ValType_I64}`.
rlist := functype.GetReturns()
// `rlist` will be `[]wasmedge.ValType{wasmedge.ValType_F32, wasmedge.ValType_F64}`.

functype.Release()
</code></pre>
</li>
<li>
<p>Table type context</p>
<p>The <code>TableType</code> is an object holds the table type context and used for <code>Table</code> instance creation or getting information from <code>Table</code> instances.</p>
<pre><code class="language-go">lim := wasmedge.NewLimit(12)
tabtype := wasmedge.NewTableType(wasmedge.RefType_ExternRef, lim)

rtype := tabtype.GetRefType()
// `rtype` will be `wasmedge.RefType_ExternRef`.
getlim := tabtype.GetLimit()
// `getlim` will be the same value as `lim`.

tabtype.Release()
</code></pre>
</li>
<li>
<p>Memory type context</p>
<p>The <code>MemoryType</code> is an object holds the memory type context and used for <code>Memory</code> instance creation or getting information from <code>Memory</code> instances.</p>
<pre><code class="language-go">lim := wasmedge.NewLimit(1)
memtype := wasmedge.NewMemoryType(lim)

getlim := memtype.GetLimit()
// `getlim` will be the same value as `lim`.

memtype.Release()
</code></pre>
</li>
<li>
<p>Global type context</p>
<p>The <code>GlobalType</code> is an object holds the global type context and used for <code>Global</code> instance creation or getting information from <code>Global</code> instances.</p>
<pre><code class="language-go">globtype := wasmedge.NewGlobalType(wasmedge.ValType_F64, wasmedge.ValMut_Var)

vtype := globtype.GetValType()
// `vtype` will be `wasmedge.ValType_F64`.
vmut := globtype.GetMutability()
// `vmut` will be `wasmedge.ValMut_Var`.

globtype.Release()
</code></pre>
</li>
<li>
<p>Import type context</p>
<p>The <code>ImportType</code> is an object holds the import type context and used for getting the imports information from a <a href="embed/go/ref.html#AST-Module">AST Module</a>.
Developers can get the external type (<code>function</code>, <code>table</code>, <code>memory</code>, or <code>global</code>), import module name, and external name from an <code>ImportType</code> object.
The details about querying <code>ImportType</code> objects will be introduced in the <a href="embed/go/ref.html#AST-Module">AST Module</a>.</p>
<pre><code class="language-go">var ast *wasmedge.AST = ...
// Assume that `ast` is returned by the `Loader` for the result of loading a WASM file.
imptypelist := ast.ListImports()
// Assume that `imptypelist` is an array listed from the `ast` for the imports.

for i, imptype := range imptypelist {
    exttype := imptype.GetExternalType()
    // The `exttype` must be one of `wasmedge.ExternType_Function`, `wasmedge.ExternType_Table`,
    // wasmedge.ExternType_Memory`, or `wasmedge.ExternType_Global`.

    modname := imptype.GetModuleName()
    extname := imptype.GetExternalName()
    // Get the module name and external name of the imports.

    extval := imptype.GetExternalValue()
    // The `extval` is the type of `interface{}` which indicates one of `*wasmedge.FunctionType`,
    // `*wasmedge.TableType`, `*wasmedge.MemoryType`, or `*wasmedge.GlobalType`.
}
</code></pre>
</li>
<li>
<p>Export type context</p>
<p>The <code>ExportType</code> is an object holds the export type context is used for getting the exports information from a <a href="embed/go/ref.html#AST-Module">AST Module</a>.
Developers can get the external type (<code>function</code>, <code>table</code>, <code>memory</code>, or <code>global</code>) and external name from an <code>Export Type</code> context.
The details about querying <code>ExportType</code> objects will be introduced in the <a href="embed/go/ref.html#AST-Module">AST Module</a>.</p>
<pre><code class="language-go">var ast *wasmedge.AST = ...
// Assume that `ast` is returned by the `Loader` for the result of loading a WASM file.
exptypelist := ast.ListExports()
// Assume that `exptypelist` is an array listed from the `ast` for the exports.

for i, exptype := range exptypelist {
    exttype := exptype.GetExternalType()
    // The `exttype` must be one of `wasmedge.ExternType_Function`, `wasmedge.ExternType_Table`,
    // wasmedge.ExternType_Memory`, or `wasmedge.ExternType_Global`.

    extname := exptype.GetExternalName()
    // Get the external name of the exports.

    extval := exptype.GetExternalValue()
    // The `extval` is the type of `interface{}` which indicates one of `*wasmedge.FunctionType`,
    // `*wasmedge.TableType`, `*wasmedge.MemoryType`, or `*wasmedge.GlobalType`.
}
</code></pre>
</li>
</ol>
<h3 id="configurations-1"><a class="header" href="#configurations-1">Configurations</a></h3>
<p>The configuration object, <code>wasmedge.Configure</code>, manages the configurations for <code>Loader</code>, <code>Validator</code>, <code>Executor</code>, <code>VM</code>, and <code>Compiler</code>.
Developers can adjust the settings about the proposals, VM host pre-registrations (such as <code>WASI</code>), and AOT compiler options, and then apply the <code>Configure</code> object to create other runtime objects.</p>
<ol>
<li>
<p>Proposals</p>
<p>WasmEdge supports turning on or off the WebAssembly proposals.
This configuration is effective in any contexts created with the <code>Configure</code> object.</p>
<pre><code class="language-go">const (
    IMPORT_EXPORT_MUT_GLOBALS         = Proposal(C.WasmEdge_Proposal_ImportExportMutGlobals)
    NON_TRAP_FLOAT_TO_INT_CONVERSIONS = Proposal(C.WasmEdge_Proposal_NonTrapFloatToIntConversions)
    SIGN_EXTENSION_OPERATORS          = Proposal(C.WasmEdge_Proposal_SignExtensionOperators)
    MULTI_VALUE                       = Proposal(C.WasmEdge_Proposal_MultiValue)
    BULK_MEMORY_OPERATIONS            = Proposal(C.WasmEdge_Proposal_BulkMemoryOperations)
    REFERENCE_TYPES                   = Proposal(C.WasmEdge_Proposal_ReferenceTypes)
    SIMD                              = Proposal(C.WasmEdge_Proposal_SIMD)
    TAIL_CALL                         = Proposal(C.WasmEdge_Proposal_TailCall)
    ANNOTATIONS                       = Proposal(C.WasmEdge_Proposal_Annotations)
    MEMORY64                          = Proposal(C.WasmEdge_Proposal_Memory64)
    THREADS                           = Proposal(C.WasmEdge_Proposal_Threads)
    EXCEPTION_HANDLING                = Proposal(C.WasmEdge_Proposal_ExceptionHandling)
    FUNCTION_REFERENCES               = Proposal(C.WasmEdge_Proposal_FunctionReferences)
)
</code></pre>
<p>Developers can add or remove the proposals into the <code>Configure</code> object.</p>
<pre><code class="language-go">// By default, the following proposals have turned on initially:
// * IMPORT_EXPORT_MUT_GLOBALS
// * NON_TRAP_FLOAT_TO_INT_CONVERSIONS
// * SIGN_EXTENSION_OPERATORS
// * MULTI_VALUE
// * BULK_MEMORY_OPERATIONS
// * REFERENCE_TYPES
// * SIMD
conf := wasmedge.NewConfigure()
// Developers can also pass the proposals as parameters:
// conf := wasmedge.NewConfigure(wasmedge.SIMD, wasmedge.BULK_MEMORY_OPERATIONS)
conf.AddConfig(wasmedge.SIMD)
conf.RemoveConfig(wasmedge.REFERENCE_TYPES)
is_bulkmem := conf.HasConfig(wasmedge.BULK_MEMORY_OPERATIONS)
// The `is_bulkmem` will be `true`.
conf.Release()
</code></pre>
</li>
<li>
<p>Host registrations</p>
<p>This configuration is used for the <code>VM</code> context to turn on the <code>WASI</code> or <code>wasmedge_process</code> supports and only effective in <code>VM</code> objects.</p>
<pre><code class="language-go">const (
    WASI             = HostRegistration(C.WasmEdge_HostRegistration_Wasi)
    WasmEdge_PROCESS = HostRegistration(C.WasmEdge_HostRegistration_WasmEdge_Process)
)
</code></pre>
<p>The details will be introduced in the <a href="embed/go/ref.html###Preregistrations">preregistrations of VM context</a>.</p>
<pre><code class="language-go">conf := wasmedge.NewConfigure()
// Developers can also pass the proposals as parameters:
// conf := wasmedge.NewConfigure(wasmedge.WASI)
conf.AddConfig(wasmedge.WASI)
conf.Release()
</code></pre>
</li>
<li>
<p>Maximum memory pages</p>
<p>Developers can limit the page size of memory instances by this configuration.
When growing the page size of memory instances in WASM execution and exceeding the limited size, the page growing will fail.
This configuration is only effective in the <code>Executor</code> and <code>VM</code> objects.</p>
<pre><code class="language-go">conf := wasmedge.NewConfigure()

pagesize := conf.GetMaxMemoryPage()
// By default, the maximum memory page size in each memory instances is 65536.
conf.SetMaxMemoryPage(1234)
pagesize := conf.GetMaxMemoryPage()
// `pagesize` will be 1234.

conf.Release()
</code></pre>
</li>
<li>
<p>AOT compiler options</p>
<p>The AOT compiler options configure the behavior about optimization level, output format, dump IR, and generic binary.</p>
<pre><code class="language-go">const (
    // Disable as many optimizations as possible.
    CompilerOptLevel_O0 = CompilerOptimizationLevel(C.WasmEdge_CompilerOptimizationLevel_O0)
    // Optimize quickly without destroying debuggability.
    CompilerOptLevel_O1 = CompilerOptimizationLevel(C.WasmEdge_CompilerOptimizationLevel_O1)
    // Optimize for fast execution as much as possible without triggering significant incremental compile time or code size growth.
    CompilerOptLevel_O2 = CompilerOptimizationLevel(C.WasmEdge_CompilerOptimizationLevel_O2)
    // Optimize for fast execution as much as possible.
    CompilerOptLevel_O3 = CompilerOptimizationLevel(C.WasmEdge_CompilerOptimizationLevel_O3)
    // Optimize for small code size as much as possible without triggering significant incremental compile time or execution time slowdowns.
    CompilerOptLevel_Os = CompilerOptimizationLevel(C.WasmEdge_CompilerOptimizationLevel_Os)
    /// Optimize for small code size as much as possible.
    CompilerOptLevel_Oz = CompilerOptimizationLevel(C.WasmEdge_CompilerOptimizationLevel_Oz)
)

const (
    /// Native dynamic library format.
    CompilerOutputFormat_Native = CompilerOutputFormat(C.WasmEdge_CompilerOutputFormat_Native)
    /// WebAssembly with AOT compiled codes in custom section.
    CompilerOutputFormat_Wasm = CompilerOutputFormat(C.WasmEdge_CompilerOutputFormat_Wasm)
)
</code></pre>
<p>These configurations are only effective in <code>Compiler</code> contexts.</p>
<pre><code class="language-go">conf := wasmedge.NewConfigure()

// By default, the optimization level is O3.
conf.SetCompilerOptimizationLevel(wasmedge.CompilerOptLevel_O2)
// By default, the output format is universal WASM.
conf.SetCompilerOutputFormat(wasmedge.CompilerOutputFormat_Native)
// By default, the dump IR is `false`.
conf.SetCompilerDumpIR(true)
// By default, the generic binary is `false`.
conf.SetCompilerGenericBinary(true)

conf.Release()
</code></pre>
</li>
<li>
<p>Statistics options</p>
<p>The statistics options configure the behavior about instruction counting, cost measuring, and time measuring in both runtime and AOT compiler.
These configurations are effective in <code>Compiler</code>, <code>VM</code>, and <code>Executor</code> objects.</p>
<pre><code class="language-go">conf := wasmedge.NewConfigure()

// By default, the intruction counting is `false` when running a compiled-WASM or a pure-WASM.
conf.SetStatisticsInstructionCounting(true)
// By default, the cost measurement is `false` when running a compiled-WASM or a pure-WASM.
conf.SetStatisticsTimeMeasuring(true)
// By default, the time measurement is `false` when running a compiled-WASM or a pure-WASM.
conf.SetStatisticsCostMeasuring(true)

conf.Release()
</code></pre>
</li>
</ol>
<h2 id="wasmedge-vm-1"><a class="header" href="#wasmedge-vm-1">WasmEdge VM</a></h2>
<p>In this partition, we will introduce the functions of <code>wasmedge.VM</code> object and show examples of executing WASM functions.</p>
<h3 id="wasm-execution-example-with-vm-object"><a class="header" href="#wasm-execution-example-with-vm-object">WASM Execution Example With VM Object</a></h3>
<p>The following shows the example of running the WASM for getting the Fibonacci.
This example uses the <a href="embed/go/../tools/wasmedge/examples/fibonacci.wasm">fibonacci.wasm</a>, and the corresponding WAT file is at <a href="embed/go/../tools/wasmedge/examples/fibonacci.wat">fibonacci.wat</a>.</p>
<pre><code>(module
 (export &quot;fib&quot; (func $fib))
 (func $fib (param $n i32) (result i32)
  (if
   (i32.lt_s (get_local $n)(i32.const 2))
   (return (i32.const 1))
  )
  (return
   (i32.add
    (call $fib (i32.sub (get_local $n)(i32.const 2)))
    (call $fib (i32.sub (get_local $n)(i32.const 1)))
   )
  )
 )
)
</code></pre>
<ol>
<li>
<p>Run WASM functions rapidly</p>
<p>Create a new Go project first:</p>
<pre><code class="language-bash">$ mkdir wasmedge_test &amp;&amp; cd wasmedge_test
$ go mod init wasmedge_test
</code></pre>
<p>Assume that the WASM file <a href="embed/go/../tools/wasmedge/examples/fibonacci.wasm"><code>fibonacci.wasm</code></a> is copied into the current <code>wasmedge_test</code> directory, and create and edit the Go file <code>main.go</code> as following:</p>
<pre><code class="language-go">package main

import (
    &quot;fmt&quot;

    &quot;github.com/second-state/WasmEdge-go/wasmedge&quot;
)

func main() {
    // Set the logging level.
    wasmedge.SetLogErrorLevel()

    // Create the configure context and add the WASI support.
    // This step is not necessary unless you need WASI support.
    conf := wasmedge.NewConfigure(wasmedge.WASI)
    // Create VM with the configure.
    vm := wasmedge.NewVMWithConfig(conf)

    res, err := vm.RunWasmFile(&quot;fibonacci.wasm&quot;, &quot;fib&quot;, uint32(21))
    if err == nil {
        fmt.Println(&quot;Get fibonacci[21]:&quot;, res[0].(int32))
    } else {
        fmt.Println(&quot;Run failed:&quot;, err.Error())
    }

    vm.Release()
    conf.Release()
}
</code></pre>
<p>Then you can build and run the Golang application with the WasmEdge Golang SDK: (the 21 Fibonacci number is 17711 in 0-based index)</p>
<pre><code class="language-bash">$ go get github.com/second-state/WasmEdge-go/wasmedge@v0.9.0
$ go build
$ ./wasmedge_test
Get fibonacci[21]: 17711
</code></pre>
</li>
<li>
<p>Instantiate and run WASM functions manually</p>
<p>Besides the above example, developers can run the WASM functions step-by-step with <code>VM</code> object APIs:</p>
<pre><code class="language-go">package main

import (
    &quot;fmt&quot;

    &quot;github.com/second-state/WasmEdge-go/wasmedge&quot;
)

func main() {
    // Set the logging level.
    wasmedge.SetLogErrorLevel()

    // Create VM.
    vm := wasmedge.NewVM()
    var err error
    var res []interface{}

    // Step 1: Load WASM file.
    err = vm.LoadWasmFile(&quot;fibonacci.wasm&quot;)
    if err != nil {
        fmt.Println(&quot;Load WASM from file FAILED:&quot;, err.Error())
        return
    }

    // Step 2: Validate the WASM module.
    err = vm.Validate()
    if err != nil {
        fmt.Println(&quot;Validation FAILED:&quot;, err.Error())
        return
    }

    // Step 3: Instantiate the WASM module.
    err = vm.Instantiate()
    // Developers can load, validate, and instantiate another WASM module
    // to replace the instantiated one. In this case, the old module will
    // be cleared, but the registered modules are still kept.
    if err != nil {
        fmt.Println(&quot;Instantiation FAILED:&quot;, err.Error())
        return
    }

    // Step 4: Execute WASM functions. Parameters: (funcname, args...)
    res, err = vm.Execute(&quot;fib&quot;, uint32(25))
    // Developers can execute functions repeatedly after instantiation.
    if err == nil {
        fmt.Println(&quot;Get fibonacci[25]:&quot;, res[0].(int32))
    } else {
        fmt.Println(&quot;Run failed:&quot;, err.Error())
    }

    vm.Release()
}
</code></pre>
<p>Then you can build and run: (the 25th Fibonacci number is 121393 in 0-based index)</p>
<pre><code class="language-bash">$ go build
$ ./wasmedge_test
Get fibonacci[25]: 121393
</code></pre>
<p>The following graph explains the status of the <code>VM</code> object.</p>
<pre><code>                       |========================|
              |-------&gt;|      VM: Initiated     |
              |        |========================|
              |                    |
              |                 LoadWasm
              |                    |
              |                    v
              |        |========================|
              |--------|       VM: Loaded       |&lt;-------|
              |        |========================|        |
              |              |            ^              |
              |         Validate          |              |
          Cleanup            |          LoadWasm         |
              |              v            |            LoadWasm
              |        |========================|        |
              |--------|      VM: Validated     |        |
              |        |========================|        |
              |              |            ^              |
              |      Instantiate          |              |
              |              |          RegisterModule   |
              |              v            |              |
              |        |========================|        |
              |--------|    VM: Instantiated    |--------|
                       |========================|
                             |            ^
                             |            |
                             --------------
                Instantiate, Execute, ExecuteRegistered,
                ExecuteBindgen, ExecuteBindgenRegistered
</code></pre>
<p>The status of the <code>VM</code> context would be <code>Inited</code> when created.
After loading WASM successfully, the status will be <code>Loaded</code>.
After validating WASM successfully, the status will be <code>Validated</code>.
After instantiating WASM successfully, the status will be <code>Instantiated</code>, and developers can invoke functions.
Developers can register WASM or import objects in any status, but they should instantiate WASM again.
Developers can also load WASM in any status, and they should validate and instantiate the WASM module before function invocation.
When in the <code>Instantiated</code> status, developers can instantiate the WASM module again to reset the old WASM runtime structures.</p>
</li>
<li>
<p>Wasm-bindgen Supporting</p>
<p>The <code>(*VM).ExecuteBindgen</code> and the <code>(*VM).ExecuteBindgenRegistered</code> are the special functions for supporting the <code>wasm-bindgen</code> functions execution.
In WasmEdge-go, we support the following return types of the <code>wasm-bindgen</code> functions:</p>
<pre><code class="language-go">type bindgen int

const (
    Bindgen_return_void  bindgen = iota
    Bindgen_return_i32   bindgen = iota
    Bindgen_return_i64   bindgen = iota
    Bindgen_return_array bindgen = iota
)
</code></pre>
<p>And only the <code>int32</code>, <code>uint32</code>, <code>int64</code>, <code>uint64</code>, and <code>[]byte</code> parameters are accepted.
Each <code>wasm-bindgen</code> function has at most only 1 return value.</p>
<pre><code class="language-go">// Take the wasm-bindgen case for example.
var res interface{}
var err error
res, err = vm.ExecuteBindgen(
    &quot;lowest_common_multiple&quot;,       // Function name
    wasmedge.Bindgen_return_i32,    // Return type: int32
    int32(123), int32(2)            // Parameters: int32, int32
)
if err == nil {
    fmt.Println(&quot;Run bindgen -- lowest_common_multiple:&quot;, res.(int32))
} 
res, err = vm.ExecuteBindgen(
    &quot;sha3_digest&quot;,                          // Function name
    wasmedge.Bindgen_return_array,          // Return type: []byte
    []byte(&quot;This is an important message&quot;)  // Parameter: []byte
)
if err == nil {
    fmt.Println(&quot;Run bindgen -- sha3_digest:&quot;, res.([]byte))
} 
</code></pre>
<p>For the full example, please refer to <a href="embed/go/ref.html#Example-of-Embedding-A-Function-with-wasm-bindgen">the example above</a>.</p>
</li>
</ol>
<h3 id="vm-creations-1"><a class="header" href="#vm-creations-1">VM Creations</a></h3>
<p>The <code>VM</code> creation APIs accepts the <code>Configure</code> object and the <code>Store</code> object.
Noticed that if the <code>VM</code> created with the outside <code>Store</code> object, the <code>VM</code> will execute WASM on that <code>Store</code> object. If the <code>Store</code> object is set into multiple <code>VM</code> objects, it may causes data conflict when in execution.
The details of the <code>Store</code> object will be introduced in <a href="embed/go/ref.html#Store">Store</a>.</p>
<pre><code class="language-go">conf := wasmedge.NewConfigure()
store := wasmedge.NewStore()

// Create a VM with default configure and store.
vm := wasmedge.NewVM()
vm.Release()

// Create a VM with the specified configure and default store.
vm = wasmedge.NewVMWithConfig(conf)
vm.Release()

// Create a VM with the default configure and specified store.
vm = wasmedge.NewVMWithStore(store)
vm.Release()

// Create a VM with the specified configure and store.
vm = wasmedge.NewVMWithConfigAndStore(conf, store)
vm.Release()

conf.Release()
store.Release()
</code></pre>
<h3 id="preregistrations-1"><a class="header" href="#preregistrations-1">Preregistrations</a></h3>
<p>WasmEdge provides the following built-in pre-registrations.</p>
<ol>
<li>
<p><a href="https://github.com/WebAssembly/WASI">WASI (WebAssembly System Interface)</a></p>
<p>Developers can turn on the WASI support for VM in the <code>Configure</code> object.</p>
<pre><code class="language-go">conf := wasmedge.NewConfigure(wasmedge.WASI)
// Or you can set the `wasmedge.WASI` into the configure object through `(*Configure).AddConfig`.
vm := wasmedge.NewVMWithConfig(conf)
vm.Release()

// The following API can retrieve the pre-registration import objects from the VM object.
// This API will return `nil` if the corresponding pre-registration is not set into the configuration.
wasiconf := conf.GetImportObject(wasmedge.WASI)
// Initialize the WASI.
wasiconf.InitWasi(/* ... ignored */)

conf.Release()
</code></pre>
<p>And also can create the WASI import object from API. The details will be introduced in the <a href="embed/go/ref.html#Host-Functions">Host Functions</a> and the <a href="embed/go/ref.html#Host-Module-Registrations">Host Module Registrations</a>.</p>
</li>
<li>
<p><a href="https://crates.io/crates/wasmedge_process_interface">WasmEdge_Process</a></p>
<p>This pre-registration is for the process interface for WasmEdge on <code>Rust</code> sources.
After turning on this pre-registration, the VM will support the <code>wasmedge_process</code> host functions.</p>
<pre><code class="language-go">conf := wasmedge.NewConfigure(wasmedge.WasmEdge_PROCESS)
vm := wasmedge.NewVMWithConfig(conf)
vm.Release()

// The following API can retrieve the pre-registration import objects from the VM object.
// This API will return `nil` if the corresponding pre-registration is not set into the configuration.
procconf := conf.GetImportObject(wasmedge.WasmEdge_PROCESS)
// Initialize the WasmEdge_Process.
procconf.InitWasmEdgeProcess(/* ... ignored */)

conf.Release()
</code></pre>
<p>And also can create the WasmEdge_Process import object from API. The details will be introduced in the <a href="embed/go/ref.html#Host-Functions">Host Functions</a> and the <a href="embed/go/ref.html#Host-Module-Registrations">Host Module Registrations</a>.</p>
</li>
</ol>
<h3 id="host-module-registrations-1"><a class="header" href="#host-module-registrations-1">Host Module Registrations</a></h3>
<p><a href="https://webassembly.github.io/spec/core/exec/runtime.html#syntax-hostfunc">Host functions</a> are functions outside WebAssembly and passed to WASM modules as imports.
In WasmEdge-go, the host functions are composed into host modules as <code>ImportObject</code> objects with module names.
Please refer to the <a href="embed/go/ref.html#Host-Functions">Host Functions in WasmEdge Runtime</a> for the details.
In this chapter, we show the example for registering the host modules into a <code>VM</code> object.</p>
<pre><code class="language-go">vm := wasmedge.NewVM()
// You can also create and register the WASI host modules by this API.
wasiobj := wasmedge.NewWasiImportObject(/* ... ignored ... */)

res := vm.RegisterImport(wasiobj)
// The result status should be checked.

vm.Release()
// The created import objects should be released.
wasiobj.Release()
</code></pre>
<h3 id="wasm-registrations-and-executions-1"><a class="header" href="#wasm-registrations-and-executions-1">WASM Registrations And Executions</a></h3>
<p>In WebAssembly, the instances in WASM modules can be exported and can be imported by other WASM modules.
WasmEdge VM provides APIs for developers to register and export any WASM modules, and execute the functions or host functions in the registered WASM modules.</p>
<ol>
<li>
<p>Register the WASM modules with exported module names</p>
<p>Unless the import objects have already contained the module names, every WASM module should be named uniquely when registering. The following shows the example.</p>
<p>Create a new Go project first:</p>
<pre><code class="language-bash">$ mkdir wasmedge_test &amp;&amp; cd wasmedge_test
$ go mod init wasmedge_test
</code></pre>
<p>Assume that the WASM file <a href="embed/go/../tools/wasmedge/examples/fibonacci.wasm"><code>fibonacci.wasm</code></a> is copied into the current directory.
Then create and edit the Go file <code>main.go</code> as following:</p>
<pre><code class="language-go">package main

import &quot;github.com/second-state/WasmEdge-go/wasmedge&quot;

func main() {
    // Create VM.
    vm := wasmedge.NewVM()

    var err error
    err = vm.RegisterWasmFile(&quot;module_name&quot;, &quot;fibonacci.wasm&quot;)
    // Developers can register the WASM module from `[]byte` with the
    // `(*VM).RegisterWasmBuffer` function, or from `AST` object with
    // the `(*VM).RegisterAST` function.
    // The result status should be checked. The error will occur if the
    // WASM module instantiation failed or the module name conflicts.

    vm.Release()
}
</code></pre>
</li>
<li>
<p>Execute the functions in registered WASM modules</p>
<p>Edit the Go file <code>main.go</code> as following:</p>
<pre><code class="language-go">package main

import (
    &quot;fmt&quot;

    &quot;github.com/second-state/WasmEdge-go/wasmedge&quot;
)

func main() {
    // Create VM.
    vm := wasmedge.NewVM()

    var res []interface{}
    var err error
    // Register the WASM module from file into VM with the module name &quot;mod&quot;.
    err = vm.RegisterWasmFile(&quot;mod&quot;, &quot;fibonacci.wasm&quot;)
    // Developers can register the WASM module from `[]byte` with the
    // `(*VM).RegisterWasmBuffer` function, or from `AST` object with
    // the `(*VM).RegisterAST` function.
    if err != nil {
        fmt.Println(&quot;WASM registration failed:&quot;, err.Error())
        return
    }
    // The function &quot;fib&quot; in the &quot;fibonacci.wasm&quot; was exported with the module
    // name &quot;mod&quot;. As the same as host functions, other modules can import the
    // function `&quot;mod&quot; &quot;fib&quot;`.

    // Execute WASM functions in registered modules.
    // Unlike the execution of functions, the registered functions can be
    // invoked without `(*VM).Instantiate` because the WASM module was
    // instantiated when registering.
    // Developers can also invoke the host functions directly with this API.
    res, err = vm.ExecuteRegistered(&quot;mod&quot;, &quot;fib&quot;, int32(25))
    if err == nil {
        fmt.Println(&quot;Get fibonacci[25]:&quot;, res[0].(int32))
    } else {
        fmt.Println(&quot;Run failed:&quot;, err.Error())
    }

    vm.Release()
}
</code></pre>
<p>Then you can build and run: (the 25th Fibonacci number is 121393 in 0-based index)</p>
<pre><code class="language-bash">$ go get github.com/second-state/WasmEdge-go/wasmedge@v0.9.0
$ go build
$ ./wasmedge_test
Get fibonacci[25]: 121393
</code></pre>
</li>
</ol>
<h3 id="instance-tracing-1"><a class="header" href="#instance-tracing-1">Instance Tracing</a></h3>
<p>Sometimes the developers may have requirements to get the instances of the WASM runtime.
The <code>VM</code> object supplies the APIs to retrieve the instances.</p>
<ol>
<li>
<p>Store</p>
<p>If the <code>VM</code> object is created without assigning a <code>Store</code> object, the <code>VM</code> context will allocate and own a <code>Store</code>.</p>
<pre><code class="language-go">vm := wasmedge.NewVM()
store := vm.GetStore()
// The object should __NOT__ be deleted by calling `(*Store).Release`.
vm.Release()
</code></pre>
<p>Developers can also create the <code>VM</code> object with a <code>Store</code> object.
In this case, developers should guarantee that the <code>Store</code> object cannot be released before the <code>VM</code> object.
Please refer to the <a href="embed/go/ref.html#Store">Store Objects</a> for the details about the <code>Store</code> APIs.</p>
<pre><code class="language-go">store := wasmedge.NewStore()
vm := wasmedge.NewVMWithStore(store)

storemock := vm.GetStore()
// The internal store context of the `store` and the `storemock` are the same.

vm.Release()
store.Release()
</code></pre>
</li>
<li>
<p>List exported functions</p>
<p>After the WASM module instantiation, developers can use the <code>(*VM).Execute</code> function to invoke the exported WASM functions. For this purpose, developers may need information about the exported WASM function list.
Please refer to the <a href="embed/go/ref.html#Instances">Instances in runtime</a> for the details about the function types.</p>
<p>Assume that a new Go project is created as following:</p>
<pre><code class="language-bash">$ mkdir wasmedge_test &amp;&amp; cd wasmedge_test
$ go mod init wasmedge_test
</code></pre>
<p>Then assume that the WASM file <a href="embed/go/../tools/wasmedge/examples/fibonacci.wasm"><code>fibonacci.wasm</code></a> is copied into the current directory, and create and edit a Go file <code>main.go</code>:</p>
<pre><code class="language-go">package main

import (
    &quot;fmt&quot;

    &quot;github.com/second-state/WasmEdge-go/wasmedge&quot;
)

func main() {
    // Create VM.
    vm := wasmedge.NewVM()

    // Step 1: Load WASM file.
    err := vm.LoadWasmFile(&quot;fibonacci.wasm&quot;)
    if err != nil {
        fmt.Println(&quot;Load WASM from file FAILED:&quot;, err.Error())
        return
    }

    // Step 2: Validate the WASM module.
    err = vm.Validate()
    if err != nil {
        fmt.Println(&quot;Validation FAILED:&quot;, err.Error())
        return
    }

    // Step 3: Instantiate the WASM module.
    err = vm.Instantiate()
    if err != nil {
        fmt.Println(&quot;Instantiation FAILED:&quot;, err.Error())
        return
    }

    // List the exported functions for the names and function types.
    funcnames, functypes := vm.GetFunctionList()
    for _, fname := range funcnames {
        fmt.Println(&quot;Exported function name:&quot;, fname)
    }
    for _, ftype := range functypes {
        // `ftype` is the `FunctionType` object of the same index in the `funcnames` array.
        // Developers should __NOT__ call the `ftype.Release()`.
    }

    vm.Release()
}
</code></pre>
<p>Then you can build and run: (the only exported function in <code>fibonacci.wasm</code> is <code>fib</code>)</p>
<pre><code class="language-bash">$ go get github.com/second-state/WasmEdge-go/wasmedge@v0.9.0
$ go build
$ ./wasmedge_test
Exported function name: fib
</code></pre>
<p>If developers want to get the exported function names in the registered WASM modules, please retrieve the <code>Store</code> object from the <code>VM</code> object and refer to the APIs of <a href="embed/go/ref.html#Store">Store Contexts</a> to list the registered functions by the module name.</p>
</li>
<li>
<p>Get function types</p>
<p>The <code>VM</code> object provides APIs to find the function type by function name.
Please refer to the <a href="embed/go/ref.html#Instances">Instances in runtime</a> for the details about the function types.</p>
<pre><code class="language-go">// Assume that a WASM module is instantiated in `vm` which is a `wasmedge.VM` object.
functype := vm.GetFunctionType(&quot;fib&quot;)
// Developers can get the function types of functions in the registered modules via the 
// `(*VM).GetFunctionTypeRegistered` API with the functon name and the module name.
// If the function is not found, these APIs will return `nil`.
// Developers should __NOT__ call the `(*FunctionType).Release` function of the returned object.
</code></pre>
</li>
</ol>
<h2 id="wasmedge-runtime-1"><a class="header" href="#wasmedge-runtime-1">WasmEdge Runtime</a></h2>
<p>In this partition, we will introduce the objects of WasmEdge runtime manually.</p>
<h3 id="wasm-execution-example-step-by-step-1"><a class="header" href="#wasm-execution-example-step-by-step-1">WASM Execution Example Step-By-Step</a></h3>
<p>Besides the WASM execution through the <a href="embed/go/ref.html#WasmEdge-VM"><code>VM</code> object</a> rapidly, developers can execute the WASM functions or instantiate WASM modules step-by-step with the <code>Loader</code>, <code>Validator</code>, <code>Executor</code>, and <code>Store</code> objects.</p>
<p>Assume that a new Go project is created as following:</p>
<pre><code class="language-bash">$ mkdir wasmedge_test &amp;&amp; cd wasmedge_test
$ go mod init wasmedge_test
</code></pre>
<p>Then assume that the WASM file <a href="embed/go/../tools/wasmedge/examples/fibonacci.wasm"><code>fibonacci.wasm</code></a> is copied into the current directory, and create and edit a Go file <code>main.go</code>:</p>
<pre><code class="language-go">package main

import (
    &quot;fmt&quot;

    &quot;github.com/second-state/WasmEdge-go/wasmedge&quot;
)

func main() {
    // Set the logging level to debug to print the statistics info.
    wasmedge.SetLogDebugLevel()
    // Create the configure object. This is not necessary if developers use the default configuration.
    conf := wasmedge.NewConfigure()
    // Turn on the runtime instruction counting and time measuring.
    conf.SetStatisticsInstructionCounting(true)
    conf.SetStatisticsTimeMeasuring(true)
    // Create the statistics object. This is not necessary if the statistics in runtime is not needed.
    stat := wasmedge.NewStatistics()
    // Create the store object. The store object is the WASM runtime structure core.
    store := wasmedge.NewStore()

    var err error
    var res []interface{}
    var ast *wasmedge.AST

    // Create the loader object.
    // For loader creation with default configuration, you can use `wasmedge.NewLoader()` instead.
    loader := wasmedge.NewLoaderWithConfig(conf)
    // Create the validator object.
    // For validator creation with default configuration, you can use `wasmedge.NewValidator()` instead.
    validator := wasmedge.NewValidatorWithConfig(conf)
    // Create the executor object.
    // For executor creation with default configuration and without statistics, you can use `wasmedge.NewExecutor()` instead.
    executor := wasmedge.NewExecutorWithConfigAndStatistics(conf, stat)

    // Load the WASM file or the compiled-WASM file and convert into the AST module object.
    ast, err = loader.LoadFile(&quot;fibonacci.wasm&quot;)
    if err != nil {
        fmt.Println(&quot;Load WASM from file FAILED:&quot;, err.Error())
        return
    }
    // Validate the WASM module.
    err = validator.Validate(ast)
    if err != nil {
        fmt.Println(&quot;Validation FAILED:&quot;, err.Error())
        return
    }
    // Instantiate the WASM module into the Store object.
    err = executor.Instantiate(store, ast)
    if err != nil {
        fmt.Println(&quot;Instantiation FAILED:&quot;, err.Error())
        return
    }

    // Try to list the exported functions of the instantiated WASM module.
    funcnames := store.ListFunction()
    for _, fname := range funcnames {
        fmt.Println(&quot;Exported function name:&quot;, fname)
    }

    // Invoke the WASM function.
    res, err = executor.Invoke(store, &quot;fib&quot;, int32(30))
    if err == nil {
        fmt.Println(&quot;Get fibonacci[30]:&quot;, res[0].(int32))
    } else {
        fmt.Println(&quot;Run failed:&quot;, err.Error())
    }

    // Resources deallocations.
    conf.Release()
    stat.Release()
    ast.Release()
    loader.Release()
    validator.Release()
    executor.Release()
    store.Release()
}
</code></pre>
<p>Then you can build and run: (the 18th Fibonacci number is 1346269 in 30-based index)</p>
<pre><code class="language-bash">$ go get github.com/second-state/WasmEdge-go/wasmedge@v0.9.0
$ go build
$ ./wasmedge_test
Exported function name: fib
[2021-11-24 18:53:01.451] [debug]  Execution succeeded.
[2021-11-24 18:53:01.452] [debug]
 ====================  Statistics  ====================
 Total execution time: 556372295 ns
 Wasm instructions execution time: 556372295 ns
 Host functions execution time: 0 ns
 Executed wasm instructions count: 28271634
 Gas costs: 0
 Instructions per second: 50814237
Get fibonacci[30]: 1346269
</code></pre>
<h3 id="loader-1"><a class="header" href="#loader-1">Loader</a></h3>
<p>The <code>Loader</code> object loads the WASM binary from files or buffers.
Both the WASM and the compiled-WASM from the <a href="embed/go/ref.html#WasmEdge-AOT-Compiler">WasmEdge AOT Compiler</a> are supported.</p>
<pre><code class="language-go">var buf []byte
// ... Read the WASM code to the `buf`.

// Developers can adjust settings in the configure object.
conf := wasmedge.NewConfigure()
// Create the loader object.
// For loader creation with default configuration, you can use `wasmedge.NewLoader()` instead.
loader := wasmedge.NewLoaderWithConfig(conf)
conf.Release()

// Load WASM or compiled-WASM from the file.
ast, err := loader.LoadFile(&quot;fibonacci.wasm&quot;)
if err != nil {
    fmt.Println(&quot;Load WASM from file FAILED:&quot;, err.Error())
} else {
    // The output AST object should be released.
    ast.Release()
}

// Load WASM or compiled-WASM from the buffer
ast, err = loader.LoadBuffer(buf)
if err != nil {
    fmt.Println(&quot;Load WASM from buffer FAILED:&quot;, err.Error())
} else {
    // The output AST object should be released.
    ast.Release()   
}

loader.Release()
</code></pre>
<h3 id="validator-1"><a class="header" href="#validator-1">Validator</a></h3>
<p>The <code>Validator</code> object can validate the WASM module.
Every WASM module should be validated before instantiation.</p>
<pre><code class="language-go">// ...
// Assume that the `ast` is the output `*wasmedge.AST` object from the loader context.
// Assume that the `conf` is the `*wasmedge.Configure` object.

// Create the validator context.
// For validator creation with default configuration, you can use `wasmedge.NewValidator()` instead.
validator := wasmedge.NewValidatorWithConfig(conf)

err := validator.Validate(ast)
if err != nil {
    fmt.Println(&quot;Validation FAILED:&quot;, err.Error())
}

validator.Release()
</code></pre>
<h3 id="executor-1"><a class="header" href="#executor-1">Executor</a></h3>
<p>The <code>Executor</code> object is the executor for both WASM and compiled-WASM.
This object should work base on the <code>Store</code> object. For the details of the <code>Store</code> object, please refer to the <a href="embed/go/ref.html#Store">next chapter</a>.</p>
<ol>
<li>
<p>Register modules</p>
<p>As the same of <a href="embed/go/ref.html#Host-Module-Registrations">registering host modules</a> or <a href="embed/go/ref.html#WASM-Registrations-And-Executions">importing WASM modules</a> in <code>VM</code> objects, developers can register <code>ImportObject</code> or <code>AST</code> objects into the <code>Store</code> object by the <code>Executor</code> APIs.
For the details of import objects, please refer to the <a href="embed/go/ref.html#Host-Functions">Host Functions</a>.</p>
<pre><code class="language-go">// ...
// Assume that the `ast` is the output `*wasmedge.AST` object from the loader
// and has passed the validation.
// Assume that the `conf` is the `*wasmedge.Configure` object.

// Create the statistics object. This step is not necessary if the statistics
// is not needed.
stat := wasmedge.NewStatistics()
// Create the executor object.
// For executor creation with default configuration and without statistics,
// you can use `wasmedge.NewExecutor()` instead.
executor := wasmedge.NewExecutorWithConfigAndStatistics(conf, stat)
// Create the store object. The store is the WASM runtime structure core.
store := wasmedge.NewStore()

// Register the loaded WASM `ast` into store with the export module name &quot;mod&quot;.
res := executor.RegisterModule(store, ast, &quot;mod&quot;)
if err != nil {
    fmt.Println(&quot;WASM registration FAILED:&quot;, err.Error())
    return
}

// Assume that the `impobj` is the `*wasmedge.ImportObject` for host functions.
impobj := ...
err = executor.RegisterImport(store, impobj)
if err != nil {
    fmt.Println(&quot;Import object registration FAILED:&quot;, err.Error())
    return
}

executor.Release()
stat.Release()
store.Release()
impobj.Release()
</code></pre>
</li>
<li>
<p>Instantiate modules</p>
<p>WASM or compiled-WASM modules should be instantiated before the function invocation.
Note that developers can only instantiate one module into the <code>Store</code> object, and in that case, the old instantiated module will be cleaned.
Before instantiating a WASM module, please check the <a href="https://webassembly.github.io/spec/core/syntax/modules.html#syntax-import">import section</a> for ensuring the imports are registered into the <code>Store</code> object.</p>
<pre><code class="language-go">// ...
// Assume that the `ast` is the output `*wasmedge.AST` object from the loader
// and has passed the validation.
// Assume that the `conf` is the `*wasmedge.Configure` object.

// Create the statistics object. This step is not necessary if the statistics
// is not needed.
stat := wasmedge.NewStatistics()
// Create the executor object.
// For executor creation with default configuration and without statistics,
// you can use `wasmedge.NewExecutor()` instead.
executor := wasmedge.NewExecutorWithConfigAndStatistics(conf, stat)
// Create the store object. The store is the WASM runtime structure core.
store := wasmedge.NewStore()

// Instantiate the WASM module.
err := executor.Instantiate(stpre, ast)
if err != nil {
    fmt.Println(&quot;WASM instantiation FAILED:&quot;, err.Error())
    return
}

executor.Release()
stat.Release()
store.Release()
</code></pre>
</li>
<li>
<p>Invoke functions</p>
<p>As the same as function invocation via the <code>VM</code> object, developers can invoke the functions of the instantiated or registered modules.
The APIs, <code>(*Executor).Invoke</code> and <code>(*Executor).InvokeRegistered</code>, are similar as the APIs of the <code>VM</code> object.
Please refer to the <a href="embed/go/ref.html#WASM-Execution-Example-With-VM-Object">VM context workflows</a> for details.</p>
</li>
</ol>
<h3 id="ast-module-1"><a class="header" href="#ast-module-1">AST Module</a></h3>
<p>The <code>AST</code> object presents the loaded structure from a WASM file or buffer. Developer will get this object after loading a WASM file or buffer from <a href="embed/go/ref.html#Loader">Loader</a>.
Before instantiation, developers can also query the imports and exports of an <code>AST</code> object.</p>
<pre><code class="language-go">ast := ...
// Assume that a WASM is loaded into an `*wasmedge.AST` object from loader.

// List the imports.
imports := ast.ListImports()
for _, import := range imports {
    fmt.Println(&quot;Import:&quot;, import.GetModuleName(), import.GetExternalName())
}

// List the exports.
exports := ast.ListExports()
for _, export := range exports {
    fmt.Println(&quot;Export:&quot;, export.GetExternalName())
}

ast.Release()
</code></pre>
<h3 id="store-1"><a class="header" href="#store-1">Store</a></h3>
<p><a href="https://webassembly.github.io/spec/core/exec/runtime.html#store">Store</a> is the runtime structure for the representation of all instances of <code>Function</code>s, <code>Table</code>s, <code>Memory</code>s, and <code>Global</code>s that have been allocated during the lifetime of the abstract machine.
The <code>Store</code> object in WasmEdge-go provides APIs to list the exported instances with their names or find the instances by exported names. For adding instances into <code>Store</code> objects, please instantiate or register WASM modules or <code>ImportObject</code> objects via the <code>Executor</code> APIs.</p>
<ol>
<li>
<p>List instances</p>
<pre><code class="language-go">store := wasmedge.NewStore()
// ...
// Instantiate a WASM module via the `*wasmedge.Executor` object.
// ...

// Try to list the exported functions of the instantiated WASM module.
// Take the function instances for example here.
funcnames := store.ListFunction()
for _, name := range funcnames {
    fmt.Println(&quot;Exported function name:&quot;, name)
}

store.Release()
</code></pre>
<p>Developers can list the function instance exported names of the registered modules via the <code>(*Store).ListFunctionRegistered()</code> API with the module name.</p>
</li>
<li>
<p>Find instances</p>
<pre><code class="language-go">store := wasmedge.NewStore()
// ...
// Instantiate a WASM module via the `*wasmedge.Executor` object.
// ...

// Try to find the exported functions of the instantiated WASM module.
// Take the function instances for example here.
funcobj := store.FindFunction(&quot;fib&quot;)
// `funcobj` will be `nil` if the function not found.

store.Release()
</code></pre>
<p>Developers can retrieve the exported function instances of the registered modules via the <code>(*Store).FindFunctionRegistered</code> API with the module name.</p>
</li>
<li>
<p>List registered modules</p>
<p>With the module names, developers can list the exported instances of the registered modules with their names.</p>
<pre><code class="language-go">store := wasmedge.NewStore()
// ...
// Instantiate a WASM module via the `*wasmedge.Executor` object.
// ...

// Try to list the registered WASM modules.
modnames := store.ListModule()
for _, name := range modnames {
    fmt.Println(&quot;Registered module names:&quot;, name)
}

store.Release()
</code></pre>
</li>
</ol>
<h3 id="instances-1"><a class="header" href="#instances-1">Instances</a></h3>
<p>The instances are the runtime structures of WASM. Developers can retrieve the instances from the <code>Store</code> objects.
The <code>Store</code> objects will allocate instances when a WASM module or an <code>ImportObject</code> is registered or instantiated through the <code>Executor</code>.
A single instance can be allocated by its creation function. Developers can construct instances into an <code>ImportObject</code> for registration. Please refer to the <a href="embed/go/ref.html#Host-Functions">Host Functions</a> for details.
The instances created by their creation functions should be destroyed, EXCEPT they are added into an <code>ImportObject</code> object.</p>
<ol>
<li>
<p>Function instance</p>
<p><a href="https://webassembly.github.io/spec/core/exec/runtime.html#syntax-hostfunc">Host functions</a> are functions outside WebAssembly and passed to WASM modules as imports.
In WasmEdge, developers can create the <code>Function</code> objects for host functions and add them into an <code>ImportObject</code> object for registering into a <code>VM</code> or a <code>Store</code>.
For both host functions and the functions get from <code>Store</code>, developers can retrieve the <code>FunctionType</code> from the <code>Function</code> objects.
For the details of the <code>Host Function</code> guide, please refer to the <a href="embed/go/ref.html#Host-Functions">next chapter</a>.</p>
<pre><code class="language-go">funcinst := ...
// `funcobj` is the `*wasmedge.Function` retrieved from the store object.
functype := funcobj.GetFunctionType()
// The `funcobj` retrieved from the store object should __NOT__ be released.
// The `functype` retrieved from the `funcobj` should __NOT__ be released.
</code></pre>
</li>
<li>
<p>Table instance</p>
<p>In WasmEdge, developers can create the <code>Table</code> objects and add them into an <code>ImportObject</code> object for registering into a <code>VM</code> or a <code>Store</code>.
The <code>Table</code> objects supply APIs to control the data in table instances.</p>
<pre><code class="language-go">lim := wasmedge.NewLimitWithMax(10, 20)
// Create the table type with limit and the `FuncRef` element type.
tabtype := wasmedge.NewTableType(wasmedge.RefType_FuncRef, lim)
// Create the table instance with table type.
tabinst := wasmedge.NewTable(tabtype)
// Delete the table type.
tabtype.Release()

gottabtype := tabinst.GetTableType()
// The `gottabtype` got from table instance is owned by the `tabinst`
// and should __NOT__ be released.
reftype := gottabtype.GetRefType()
// The `reftype` will be `wasmedge.RefType_FuncRef`.

var gotdata interface{}
data := wasmedge.NewFuncRef(5)
err := tabinst.SetData(data, 3)
// Set the function index 5 to the table[3].

// The following line will get an &quot;out of bounds table access&quot; error
// because the position (13) is out of the table size (10):
//   err = tabinst.SetData(data, 13)

gotdata, err = tabinst.GetData(3)
// Get the FuncRef value of the table[3].

// The following line will get an &quot;out of bounds table access&quot; error
// because the position (13) is out of the table size (10):
//   gotdata, err = tabinst.GetData(13)

tabsize := tabinst.GetSize()
// `tabsize` will be 10.
err = tabinst.Grow(6)
// Grow the table size of 6, the table size will be 16.

// The following line will get an &quot;out of bounds table access&quot; error
// because the size (16 + 6) will reach the table limit (20):
//   err = tabinst.Grow(6)

tabinst.Release()
</code></pre>
</li>
<li>
<p>Memory instance</p>
<p>In WasmEdge, developers can create the <code>Memory</code> objects and add them into an <code>ImportObject</code> object for registering into a <code>VM</code> or a <code>Store</code>.
The <code>Memory</code> objects supply APIs to control the data in memory instances.</p>
<pre><code class="language-go">lim := wasmedge.NewLimitWithMax(1, 5)
// Create the memory type with limit. The memory page size is 64KiB.
memtype := wasmedge.NewMemoryType(lim)
// Create the memory instance with memory type.
meminst := wasmedge.NewMemory(memtype)
// Delete the memory type.
memtype.Release()

data := []byte(&quot;A quick brown fox jumps over the lazy dog&quot;)
err := meminst.SetData(data, 0x1000, 10)
// Set the data[0:9] to the memory[4096:4105].

// The following line will get an &quot;out of bounds memory access&quot; error
// because [65535:65544] is out of 1 page size (65536):
//   err = meminst.SetData(data, 0xFFFF, 10)

var gotdata []byte
gotdata, err = meminst.GetData(0x1000, 10)
// Get the memory[4096:4105]. The `gotdata` will be `[]byte(&quot;A quick br&quot;).
// The following line will get an &quot;out of bounds memory access&quot; error
// because [65535:65544] is out of 1 page size (65536):
//   gotdata, err = meminst.Getdata(0xFFFF, 10)

pagesize := meminst.GetPageSize()
// `pagesize` will be 1.
err = meminst.GrowPage(2)
// Grow the page size of 2, the page size of the memory instance will be 3.

// The following line will get an &quot;out of bounds memory access&quot; error
// because the size (3 + 3) will reach the memory limit (5):
//   err = meminst.GetPageSize(3)

meminst.Release()
</code></pre>
</li>
<li>
<p>Global instance</p>
<p>In WasmEdge, developers can create the <code>Global</code> objects and add them into an <code>ImportObject</code> object for registering into a <code>VM</code> or a <code>Store</code>.
The <code>Global</code> objects supply APIs to control the value in global instances.</p>
<pre><code class="language-go">// Create the global type with value type and mutation.
globtype := wasmedge.NewGlobalType(wasmedge.ValType_I64, wasmedge.ValMut_Var)
// Create the global instance with value and global type.
globinst := wasmedge.NewGlobal(globtype, uint64(1000))
// Delete the global type.
globtype.Release()

gotglobtype := globinst.GetGlobalType()
// The `gotglobtype` got from global instance is owned by the `globinst`
// and should __NOT__ be released.
valtype := gotglobtype.GetValType()
// The `valtype` will be `wasmedge.ValType_I64`.
valmut := gotglobtype.GetMutability()
// The `valmut` will be `wasmedge.ValMut_Var`.

globinst.SetValue(uint64(888))
// Set the value u64(888) to the global.
// This function will do nothing if the value type mismatched or the
// global mutability is `wasmedge.ValMut_Const`.
gotval := globinst.GetValue()
// The `gotbal` will be `interface{}` which the type is `uint64` and
// the value is 888.

globinst.Release()
</code></pre>
</li>
</ol>
<h3 id="host-functions-1"><a class="header" href="#host-functions-1">Host Functions</a></h3>
<p><a href="https://webassembly.github.io/spec/core/exec/runtime.html#syntax-hostfunc">Host functions</a> are functions outside WebAssembly and passed to WASM modules as imports.
In WasmEdge-go, developers can create the <code>Function</code>, <code>Memory</code>, <code>Table</code>, and <code>Global</code> objects and add them into an <code>ImportObject</code> object for registering into a <code>VM</code> or a <code>Store</code>.</p>
<ol>
<li>
<p>Host function allocation</p>
<p>Developers can define Go functions with the following function signature as the host function body:</p>
<pre><code class="language-go">type hostFunctionSignature func(
    data interface{}, mem *Memory, params []interface{}) ([]interface{}, Result)
</code></pre>
<p>The example of an <code>add</code> host function to add 2 <code>i32</code> values:</p>
<pre><code class="language-c">func host_add(data interface{}, mem *wasmedge.Memory, params []interface{}) ([]interface{}, wasmedge.Result) {
    // add: i32, i32 -&gt; i32
    res := params[0].(int32) + params[1].(int32)

    /// Set the returns
    returns := make([]interface{}, 1)
    returns[0] = res

    /// Return
    return returns, wasmedge.Result_Success
}
</code></pre>
<p>Then developers can create <code>Function</code> object with the host function body and function type:</p>
<pre><code class="language-go">// Create a function type: {i32, i32} -&gt; {i32}.
functype := wasmedge.NewFunctionType(
    []wasmedge.ValType{wasmedge.ValType_I32, wasmedge.ValType_I32},
    []wasmedge.ValType{wasmedge.ValType_I32},
)

// Create a function context with the function type and host function body.
// The third parameter is the pointer to the additional data.
// Developers should guarantee the life cycle of the data, and it can be
// `nil` if the external data is not needed.
// The last parameter can be 0 if developers do not need the cost measuring.
func_add := wasmedge.NewFunction(functype, host_add, nil, 0)

// If the function object is not added into an import object object, it should be released.
func_add.Release()
functype.Release()
</code></pre>
</li>
<li>
<p>Import object object</p>
<p>The <code>ImportObject</code> object holds an exporting module name and the instances. Developers can add the <code>Function</code>, <code>Memory</code>, <code>Table</code>, and <code>Global</code> instances with their exporting names.</p>
<pre><code class="language-go">// Host function body definition.
func host_add(data interface{}, mem *wasmedge.Memory, params []interface{}) ([]interface{}, wasmedge.Result) {
    // add: i32, i32 -&gt; i32
    res := params[0].(int32) + params[1].(int32)

    /// Set the returns
    returns := make([]interface{}, 1)
    returns[0] = res

    /// Return
    return returns, wasmedge.Result_Success
}

// Create the import object with the module name &quot;module&quot;.
impobj := wasmedge.NewImportObject(&quot;module&quot;)

// Create and add a function instance into the import object with export name &quot;add&quot;.
functype := wasmedge.NewFunctionType(
    []wasmedge.ValType{wasmedge.ValType_I32, wasmedge.ValType_I32},
    []wasmedge.ValType{wasmedge.ValType_I32},
)
hostfunc := wasmedge.NewFunction(functype, host_add, nil, 0)
functype.Release()
impobj.AddFunction(&quot;add&quot;, hostfunc)

// Create and add a table instance into the import object with export name &quot;table&quot;.
tabtype := wasmedge.NewTableType(wasmedge.RefType_FuncRef ,wasmedge.NewLimitWithMax(10, 20))
hosttab := wasmedge.NewTable(tabtype)
tabtype.Release()
impobj.AddTable(&quot;table&quot;, hosttab)

// Create and add a memory instance into the import object with export name &quot;memory&quot;.
memtype := wasmedge.NewMemoryType(wasmedge.NewLimitWithMax(1, 2))
hostmem := wasmedge.NewMemory(memtype)
memtype.Release()
impobj.AddMemory(&quot;memory&quot;, hostmem)

// Create and add a global instance into the import object with export name &quot;global&quot;.
globtype := wasmedge.NewGlobalType(wasmedge.ValType_I32, wasmedge.ValMut_Var)
hostglob := wasmedge.NewGlobal(globtype, uint32(666))
globtype.Release()
impobj.AddGlobal(&quot;global&quot;, hostglob)

// The import objects should be released.
// Developers should __NOT__ release the instances added into the import object objects.
impobj.Release()
</code></pre>
</li>
<li>
<p>Specified import object</p>
<p><code>wasmedge.NewWasiImportObject()</code> API can create and initialize the <code>WASI</code> import object.
<code>wasmedge.NewWasmEdgeProcessImportObject()</code> API can create and initialize the <code>wasmedge_process</code> import object.
Developers can create these import object objects and register them into the <code>Store</code> or <code>VM</code> objects rather than adjust the settings in the <code>Configure</code> objects.</p>
<pre><code class="language-go">wasiobj := wasmedge.NewWasiImportObject(
    os.Args[1:],     // The args
    os.Environ(),    // The envs
    []string{&quot;.:.&quot;}, // The mapping preopens
)
procobj := wasmedge.NewWasmEdgeProcessImportObject(
    []string{&quot;ls&quot;, &quot;echo&quot;}, // The allowed commands
    false,                  // Not to allow all commands
)

// Register the WASI and WasmEdge_Process into the VM object.
vm := wasmedge.NewVM()
vm.RegisterImport(wasiobj)
vm.RegisterImport(procobj)

// ... Execute some WASM functions.

// Get the WASI exit code.
exitcode := wasiobj.WasiGetExitCode()
// The `exitcode` will be 0 if the WASI function &quot;_start&quot; execution has no error.
// Otherwise, it will return with the related exit code.

vm.Release()
// The import objects should be deleted.
wasiobj.Release()
procobj.Release()
</code></pre>
</li>
<li>
<p>Example</p>
<p>Create a new Go project first:</p>
<pre><code class="language-bash">$ mkdir wasmedge_test &amp;&amp; cd wasmedge_test
$ go mod init wasmedge_test
</code></pre>
<p>Assume that there is a simple WASM from the WAT as following:</p>
<pre><code>(module
  (type $t0 (func (param i32 i32) (result i32)))
  (import &quot;extern&quot; &quot;func-add&quot; (func $f-add (type $t0)))
  (func (export &quot;addTwo&quot;) (param i32 i32) (result i32)
    local.get 0
    local.get 1
    call $f-add)
)
</code></pre>
<p>Create and edit the Go file <code>main.go</code> as following:</p>
<pre><code class="language-go">package main

import (
    &quot;fmt&quot;

    &quot;github.com/second-state/WasmEdge-go/wasmedge&quot;
)

// Host function body definition.
func host_add(data interface{}, mem *wasmedge.Memory, params []interface{}) ([]interface{}, wasmedge.Result) {
    // add: i32, i32 -&gt; i32
    res := params[0].(int32) + params[1].(int32)

    /// Set the returns
    returns := make([]interface{}, 1)
    returns[0] = res

    /// Return
    return returns, wasmedge.Result_Success
}

func main() {
    // Create the VM object.
    vm := wasmedge.NewVM()

    // The WASM module buffer.
    wasmbuf := []byte{
        /* WASM header */
        0x00, 0x61, 0x73, 0x6D, 0x01, 0x00, 0x00, 0x00,
        /* Type section */
        0x01, 0x07, 0x01,
        /* function type {i32, i32} -&gt; {i32} */
        0x60, 0x02, 0x7F, 0x7F, 0x01, 0x7F,
        /* Import section */
        0x02, 0x13, 0x01,
        /* module name: &quot;extern&quot; */
        0x06, 0x65, 0x78, 0x74, 0x65, 0x72, 0x6E,
        /* extern name: &quot;func-add&quot; */
        0x08, 0x66, 0x75, 0x6E, 0x63, 0x2D, 0x61, 0x64, 0x64,
        /* import desc: func 0 */
        0x00, 0x00,
        /* Function section */
        0x03, 0x02, 0x01, 0x00,
        /* Export section */
        0x07, 0x0A, 0x01,
        /* export name: &quot;addTwo&quot; */
        0x06, 0x61, 0x64, 0x64, 0x54, 0x77, 0x6F,
        /* export desc: func 0 */
        0x00, 0x01,
        /* Code section */
        0x0A, 0x0A, 0x01,
        /* code body */
        0x08, 0x00, 0x20, 0x00, 0x20, 0x01, 0x10, 0x00, 0x0B,
    }

    // Create the import object with the module name &quot;extern&quot;.
    impobj := wasmedge.NewImportObject(&quot;extern&quot;)

    // Create and add a function instance into the import object with export name &quot;func-add&quot;.
    functype := wasmedge.NewFunctionType(
        []wasmedge.ValType{wasmedge.ValType_I32, wasmedge.ValType_I32},
        []wasmedge.ValType{wasmedge.ValType_I32},
    )
    hostfunc := wasmedge.NewFunction(functype, host_add, nil, 0)
    functype.Release()
    impobj.AddFunction(&quot;func-add&quot;, hostfunc)

    // Register the import object into VM.
    vm.RegisterImport(impobj)

    res, err := vm.RunWasmBuffer(wasmbuf, &quot;addTwo&quot;, uint32(1234), uint32(5678))
    if err == nil {
        fmt.Println(&quot;Get the result:&quot;, res[0].(int32))
    } else {
        fmt.Println(&quot;Error message:&quot;, err.Error())
    }

    impobj.Release()
    vm.Release()
}
</code></pre>
<p>Then you can build and run the Golang application with the WasmEdge Golang SDK:</p>
<pre><code class="language-bash">$ go get github.com/second-state/WasmEdge-go/wasmedge@v0.9.0
$ go build
$ ./wasmedge_test
Get the result: 6912
</code></pre>
</li>
<li>
<p>Host Data Example</p>
<p>Developers can set a external data object to the function object, and access to the object in the function body.
Assume that edit the Go file <code>main.go</code> above:</p>
<pre><code class="language-go">package main

import (
    &quot;fmt&quot;

    &quot;github.com/second-state/WasmEdge-go/wasmedge&quot;
)

// Host function body definition.
func host_add(data interface{}, mem *wasmedge.Memory, params []interface{}) ([]interface{}, wasmedge.Result) {
    // add: i32, i32 -&gt; i32
    res := params[0].(int32) + params[1].(int32)

    /// Set the returns
    returns := make([]interface{}, 1)
    returns[0] = res

    // Also set the result to the data.
    *data.(*int32) = res

    /// Return
    return returns, wasmedge.Result_Success
}

func main() {
    // Create the VM object.
    vm := wasmedge.NewVM()

    // The WASM module buffer.
    wasmbuf := []byte{
        /* WASM header */
        0x00, 0x61, 0x73, 0x6D, 0x01, 0x00, 0x00, 0x00,
        /* Type section */
        0x01, 0x07, 0x01,
        /* function type {i32, i32} -&gt; {i32} */
        0x60, 0x02, 0x7F, 0x7F, 0x01, 0x7F,
        /* Import section */
        0x02, 0x13, 0x01,
        /* module name: &quot;extern&quot; */
        0x06, 0x65, 0x78, 0x74, 0x65, 0x72, 0x6E,
        /* extern name: &quot;func-add&quot; */
        0x08, 0x66, 0x75, 0x6E, 0x63, 0x2D, 0x61, 0x64, 0x64,
        /* import desc: func 0 */
        0x00, 0x00,
        /* Function section */
        0x03, 0x02, 0x01, 0x00,
        /* Export section */
        0x07, 0x0A, 0x01,
        /* export name: &quot;addTwo&quot; */
        0x06, 0x61, 0x64, 0x64, 0x54, 0x77, 0x6F,
        /* export desc: func 0 */
        0x00, 0x01,
        /* Code section */
        0x0A, 0x0A, 0x01,
        /* code body */
        0x08, 0x00, 0x20, 0x00, 0x20, 0x01, 0x10, 0x00, 0x0B,
    }

    // The additional data to set into the host function.
    var data int32 = 0

    // Create the import object with the module name &quot;extern&quot;.
    impobj := wasmedge.NewImportObject(&quot;extern&quot;)

    // Create and add a function instance into the import object with export name &quot;func-add&quot;.
    functype := wasmedge.NewFunctionType(
        []wasmedge.ValType{wasmedge.ValType_I32, wasmedge.ValType_I32},
        []wasmedge.ValType{wasmedge.ValType_I32},
    )
    hostfunc := wasmedge.NewFunction(functype, host_add, &amp;data, 0)
    functype.Release()
    impobj.AddFunction(&quot;func-add&quot;, hostfunc)

    // Register the import object into VM.
    vm.RegisterImport(impobj)

    res, err := vm.RunWasmBuffer(wasmbuf, &quot;addTwo&quot;, uint32(1234), uint32(5678))
    if err == nil {
        fmt.Println(&quot;Get the result:&quot;, res[0].(int32))
    } else {
        fmt.Println(&quot;Error message:&quot;, err.Error())
    }
    fmt.Println(&quot;Data value:&quot;, data)

    impobj.Release()
    vm.Release()
}
</code></pre>
<p>Then you can build and run the Golang application with the WasmEdge Golang SDK:</p>
<pre><code class="language-bash">$ go get github.com/second-state/WasmEdge-go/wasmedge@v0.9.0
$ go build
$ ./wasmedge_test
Get the result: 6912
Data value: 6912
</code></pre>
</li>
</ol>
<h2 id="wasmedge-aot-compiler-1"><a class="header" href="#wasmedge-aot-compiler-1">WasmEdge AOT Compiler</a></h2>
<p>In this partition, we will introduce the WasmEdge AOT compiler and the options in Go.
WasmEdge runs the WASM files in interpreter mode, and WasmEdge also supports the AOT (ahead-of-time) mode running without modifying any code.
The WasmEdge AOT (ahead-of-time) compiler compiles the WASM files for running in AOT mode which is much faster than interpreter mode. Developers can compile the WASM files into the compiled-WASM files in shared library format for universal WASM format for the AOT mode execution.</p>
<h3 id="compilation-example-1"><a class="header" href="#compilation-example-1">Compilation Example</a></h3>
<p>The <a href="https://github.com/second-state/WasmEdge-go-examples/tree/master/go_WasmAOT">go_WasmAOT example</a> provide a tool for compiling a WASM file.</p>
<h3 id="compiler-options-1"><a class="header" href="#compiler-options-1">Compiler Options</a></h3>
<p>Developers can set options for AOT compilers such as optimization level and output format:</p>
<pre><code class="language-go">const (
    // Disable as many optimizations as possible.
    CompilerOptLevel_O0 = CompilerOptimizationLevel(C.WasmEdge_CompilerOptimizationLevel_O0)
    // Optimize quickly without destroying debuggability.
    CompilerOptLevel_O1 = CompilerOptimizationLevel(C.WasmEdge_CompilerOptimizationLevel_O1)
    // Optimize for fast execution as much as possible without triggering significant incremental compile time or code size growth.
    CompilerOptLevel_O2 = CompilerOptimizationLevel(C.WasmEdge_CompilerOptimizationLevel_O2)
    // Optimize for fast execution as much as possible.
    CompilerOptLevel_O3 = CompilerOptimizationLevel(C.WasmEdge_CompilerOptimizationLevel_O3)
    // Optimize for small code size as much as possible without triggering significant incremental compile time or execution time slowdowns.
    CompilerOptLevel_Os = CompilerOptimizationLevel(C.WasmEdge_CompilerOptimizationLevel_Os)
    /// Optimize for small code size as much as possible.
    CompilerOptLevel_Oz = CompilerOptimizationLevel(C.WasmEdge_CompilerOptimizationLevel_Oz)
)

const (
    /// Native dynamic library format.
    CompilerOutputFormat_Native = CompilerOutputFormat(C.WasmEdge_CompilerOutputFormat_Native)
    /// WebAssembly with AOT compiled codes in custom section.
    CompilerOutputFormat_Wasm = CompilerOutputFormat(C.WasmEdge_CompilerOutputFormat_Wasm)
)
</code></pre>
<p>Please refer to the <a href="embed/go/ref.html#Configurations">AOT compiler options configuration</a> for details.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="nodejs-sdk"><a class="header" href="#nodejs-sdk">Node.js SDK</a></h1>
<p>In this tutorial, I will show you how to incorporate WebAssembly functions, written in Rust, into Node.js applications on the server via the WasmEdge Node.js SDK. This approach combines Rust's <strong>performance</strong>, WebAssembly's <strong>security and portability</strong>, and JavaScript's <strong>ease-of-use</strong>. A typical application works like this.</p>
<ul>
<li>The host application is a Node.js web application written in JavaScript. It makes WebAssembly function calls.</li>
<li>The WebAssembly bytecode program is written in Rust. It runs inside the WasmEdge Runtime, and is called from the Node.js web application.</li>
</ul>
<blockquote>
<p><a href="https://github.com/second-state/wasmedge-nodejs-starter/fork">Fork this Github repository</a> to start coding!</p>
</blockquote>
<h2 id="prerequisites-2"><a class="header" href="#prerequisites-2">Prerequisites</a></h2>
<p>To set up a high-performance Node.js environment with Rust and WebAssembly, you will need the following:</p>
<ul>
<li>A modern Linux distribution, such as Ubuntu Server 20.04 LTS</li>
<li><a href="https://www.rust-lang.org/tools/install">Rust language</a></li>
<li><a href="https://nodejs.org/en/download/package-manager/">Node.js</a></li>
<li><a href="https://github.com/WasmEdge/WasmEdge/blob/master/docs/install.md">The WasmEdge Runtime</a> for Node.js</li>
<li><a href="embed//articles/rustwasmc">The rustwasmc compiler toolchain</a></li>
</ul>
<h3 id="docker"><a class="header" href="#docker">Docker</a></h3>
<p>The easiest way to get started is to use Docker to build a dev environment. Just <a href="https://github.com/second-state/wasmedge-nodejs-starter/">clone this template project</a> to your computer and run the following Docker commands.</p>
<pre><code class="language-src"># Get the code
$ git clone https://github.com/second-state/wasmedge-nodejs-starter
$ cd wasmedge-nodejs-starter

# Run Docker container
$ docker pull wasmedge/appdev_x86_64:0.8.2
$ docker run -p 3000:3000 --rm -it -v $(pwd):/app wasmedge/appdev_x86_64:0.8.2
(docker) $ cd /app
</code></pre>
<p>That's it! You are now ready to compile and run the code.</p>
<h3 id="manual-setup-without-docker"><a class="header" href="#manual-setup-without-docker">Manual setup without Docker</a></h3>
<p>The commands are as follows.</p>
<pre><code class="language-src"># Install Rust
$ curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh
$ source $HOME/.cargo/env
$ rustup override set 1.50.0

# Install Node.js and npm
$ curl -sL https://deb.nodesource.com/setup_14.x |  bash
$ sudo apt-get install -y nodejs npm

# Install rustwasmc toolchain
$ npm install -g rustwasmc # Append --unsafe-perm if permission denied

# OS dependencies for WasmEdge
$ sudo apt-get update
$ sudo apt-get -y upgrade
$ sudo apt install -y build-essential curl wget git vim libboost-all-dev llvm-dev liblld-10-dev

# Install the nodejs addon for WasmEdge
$ npm install wasmedge-core
$ npm install wasmedge-extensions
</code></pre>
<blockquote>
<p>The WasmEdge Runtime depends on the latest version of <code>libstdc++</code>. Ubuntu 20.04 LTS already has the latest libraries. If you are running an older Linux distribution, you have <a href="embed//articles/ubuntu-req-ssvm-20200715/">several options to upgrade</a>.</p>
</blockquote>
<p>Next, clone the example source code repository.</p>
<pre><code class="language-src">$ git clone https://github.com/second-state/wasmedge-nodejs-starter
$ cd wasmedge-nodejs-starter
</code></pre>
<h2 id="hello-world-3"><a class="header" href="#hello-world-3">Hello World</a></h2>
<p>The first example is a hello world to show you how various parts of the application fit together.</p>
<h3 id="webassembly-program-in-rust"><a class="header" href="#webassembly-program-in-rust">WebAssembly program in Rust</a></h3>
<p>In this example, our Rust program appends the input string after “hello”. Below is the content of the Rust program <code>src/lib.rs</code>. You can define multiple external functions in this library file, and all of them will be available to the host JavaScript app via WebAssembly. Just remember to annotate each function with <code>#[wasm_bindgen]</code> so that <a href="https://github.com/second-state/rustwasmc">rustwasmc</a> knows to generate the correct JavaScript to Rust interface for it when you build it.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use wasm_bindgen::prelude::*;

#[wasm_bindgen]
pub fn say(s: String) -&gt; String {
  let r = String::from(&quot;hello &quot;);
  return r + &amp;s;
}
<span class="boring">}
</span></code></pre></pre>
<p>Next, you can compile the Rust source code into WebAssembly bytecode and generate the accompanying JavaScript module for the Node.js host environment.</p>
<pre><code class="language-src">$ rustwasmc build
</code></pre>
<p>The result are files in the <code>pkg/</code> directory. the <code>.wasm</code> file is the WebAssembly bytecode program, and the <code>.js</code> files are for the JavaScript module.</p>
<h3 id="the-nodejs-host-application"><a class="header" href="#the-nodejs-host-application">The Node.js host application</a></h3>
<p>Next, go to the <code>node</code> folder and examine the JavaScript program <code>app.js</code>. With the generated <code>wasmedge_nodejs_starter_lib.js</code> module, it is very easy to write JavaScript to call WebAssembly functions. Below is the node application <code>app.js</code>. It simply imports the <code>say()</code> function from the generated module. The node application takes the <code>name</code> parameter from incoming an HTTP GET request, and responds with “hello <code>name</code>”.</p>
<pre><code class="language-javascript">const { say } = require('../pkg/wasmedge_nodejs_starter_lib.js');

const http = require('http');
const url = require('url');
const hostname = '127.0.0.1';
const port = 3000;

const server = http.createServer((req, res) =&gt; {
  const queryObject = url.parse(req.url,true).query;
  res.statusCode = 200;
  res.setHeader('Content-Type', 'text/plain');
  res.end(say(queryObject['name']));
});

server.listen(port, hostname, () =&gt; {
  console.log(`Server running at http://${hostname}:${port}/`);
});
</code></pre>
<p>Start the Node.js application server as follows.</p>
<pre><code class="language-src">$ node node/app.js
Server running at http://127.0.0.1:3000/
</code></pre>
<p>Then, you can test it from another terminal window.</p>
<pre><code class="language-src">$ curl http://127.0.0.1:3000/?name=Wasm
hello Wasm
</code></pre>
<h2 id="a-complete-web-application"><a class="header" href="#a-complete-web-application">A complete web application</a></h2>
<p>The next example shows a web application that computes the roots for quadratic equations. Please checkout the <a href="https://github.com/second-state/wasm-learning/tree/master/nodejs/quadratic">full source code here</a>.</p>
<p>The user enters the values for <code>a</code>, <code>b</code>, <code>c</code> on the web form, and the web application calls the web service at <code>/solve</code> to compute the roots for the quadratic equation.</p>
<pre><code class="language-src">a*X^2 + b*X + c = 0
</code></pre>
<p>The roots for <code>X</code> are displayed in the area below the input form.</p>
<p><img src="embed//articles/getting-started-with-rust-function-01.png" alt="" /></p>
<p>The <a href="https://github.com/second-state/wasm-learning/blob/master/nodejs/quadratic/node/public/index.html">HTML file</a> contains the client side JavaScript to submit the web form to <code>/solve</code>, and put result into the <code>#roots</code> HTML element on the page. </p>
<pre><code class="language-javascript">$(function() {
    var options = {
      target: '#roots',
      url: &quot;/solve&quot;,
      type: &quot;post&quot;
    };
    $('#solve').ajaxForm(options);
});
</code></pre>
<p>The <a href="https://github.com/second-state/wasm-learning/blob/master/nodejs/quadratic/node/server.js">Node.js application</a> behind the <code>/solve</code> URL endpoint is as follows. It reads the data from the input form, passes them into the <code>solve</code> function as an array, and puts the return value in the HTTP response.</p>
<pre><code class="language-javascript">app.post('/solve', function (req, res) {
  var a = parseFloat(req.body.a);
  var b = parseFloat(req.body.b);
  var c = parseFloat(req.body.c);
  res.send(solve([a, b, c]))
})
</code></pre>
<p>The <a href="https://github.com/second-state/wasm-learning/blob/master/nodejs/quadratic/src/lib.rs"><code>solve</code> function is written in Rust</a> and runs inside the WasmEdge Runtime. While the call arguments in the JavaScript side is an array of values, the Rust function receives a JSON object that encapsulates the array. In the Rust code, we first decode the JSON, perform the computation, and return the result values in a JSON string.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[wasm_bindgen]
pub fn solve(params: &amp;str) -&gt; String {
  let ps: (f32, f32, f32) = serde_json::from_str(&amp;params).unwrap();
  let discriminant: f32 = (ps.1 * ps.1) - (4. * ps.0 * ps.2);
  let mut solution: (f32, f32) = (0., 0.);
  if discriminant &gt;= 0. {
    solution.0 = (((-1.) * ps.1) + discriminant.sqrt()) / (2. * ps.0);
    solution.1 = (((-1.) * ps.1) - discriminant.sqrt()) / (2. * ps.0);
    return serde_json::to_string(&amp;solution).unwrap();
  } else {
    return String::from(&quot;not real numbers&quot;);
  }
}
<span class="boring">}
</span></code></pre></pre>
<p>Let's try it.</p>
<pre><code class="language-src">$ rustwasmc build
$ npm install express # The application requires the Express framework in Node.js

$ node node/server.js
</code></pre>
<p>From the web browser, go to <code>http://ip-addr:8080/</code> to access this application. Note: If you are using Docker, make sure that the Docker container port 8080 is mapped to the host port 8080.</p>
<p>That’s it for the quadratic equation example.</p>
<h2 id="more-examples"><a class="header" href="#more-examples">More examples</a></h2>
<p>Besides passing string values between Rust and JavaScript, the <code>rustwasmc</code> tool supports the following data types.</p>
<ul>
<li>Rust call parameters can be any combo of <code>i32</code>, <code>String</code>, <code>&amp;str</code>, <code>Vec&lt;u8&gt;</code>, and <code>&amp;[u8]</code></li>
<li>Return value can be <code>i32</code> or <code>String</code> or <code>Vec&lt;u8&gt;</code> or void</li>
<li>For complex data types, such as structs, you could use JSON strings to pass data. </li>
</ul>
<blockquote>
<p>With JSON support, you can call Rust functions with any number of input parameters and return any number of return values of any type.</p>
</blockquote>
<p>The Rust program <code>src/lib.rs</code> in the <a href="https://github.com/second-state/wasm-learning/tree/master/nodejs/functions">functions example</a> demonstrates  how to pass in call arguments in various supported types, and return values.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[wasm_bindgen]
pub fn obfusticate(s: String) -&gt; String {
  (&amp;s).chars().map(|c| {
    match c {
      'A' ..= 'M' | 'a' ..= 'm' =&gt; ((c as u8) + 13) as char,
      'N' ..= 'Z' | 'n' ..= 'z' =&gt; ((c as u8) - 13) as char,
      _ =&gt; c
    }
  }).collect()
}

#[wasm_bindgen]
pub fn lowest_common_denominator(a: i32, b: i32) -&gt; i32 {
  let r = lcm(a, b);
  return r;
}

#[wasm_bindgen]
pub fn sha3_digest(v: Vec&lt;u8&gt;) -&gt; Vec&lt;u8&gt; {
  return Sha3_256::digest(&amp;v).as_slice().to_vec();
}

#[wasm_bindgen]
pub fn keccak_digest(s: &amp;[u8]) -&gt; Vec&lt;u8&gt; {
  return Keccak256::digest(s).as_slice().to_vec();
}
<span class="boring">}
</span></code></pre></pre>
<p>Perhaps the most interesting is the <code>create_line()</code> function. It takes two JSON strings, each representing a <code>Point</code> struct, and returns a JSON string representing a <code>Line</code> struct. Notice that both the <code>Point</code> and <code>Line</code> structs are annotated with <code>Serialize</code> and <code>Deserialize</code> so that the Rust compiler automatically generates necessary code to support their conversion to and from JSON strings.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use wasm_bindgen::prelude::*;
use serde::{Serialize, Deserialize};

#[derive(Serialize, Deserialize, Debug)]
struct Point {
  x: f32, 
  y: f32
}

#[derive(Serialize, Deserialize, Debug)]
struct Line {
  points: Vec&lt;Point&gt;,
  valid: bool,
  length: f32,
  desc: String
}

#[wasm_bindgen]
pub fn create_line (p1: &amp;str, p2: &amp;str, desc: &amp;str) -&gt; String {
  let point1: Point = serde_json::from_str(p1).unwrap();
  let point2: Point = serde_json::from_str(p2).unwrap();
  let length = ((point1.x - point2.x) * (point1.x - point2.x) + (point1.y - point2.y) * (point1.y - point2.y)).sqrt();

  let valid = if length == 0.0 { false } else { true };
  let line = Line { points: vec![point1, point2], valid: valid, length: length, desc: desc.to_string() };
  return serde_json::to_string(&amp;line).unwrap();
}

#[wasm_bindgen]
pub fn say(s: &amp;str) -&gt; String {
  let r = String::from(&quot;hello &quot;);
  return r + s;
}
<span class="boring">}
</span></code></pre></pre>
<p>Next, let's examine the JavaScript program <a href="https://github.com/second-state/wasm-learning/blob/master/nodejs/functions/node/app.js"><code>app.js</code></a>. It shows how to call the Rust functions. As you can see <code>String</code> and <code>&amp;str</code> are simply strings in JavaScript, <code>i32</code> are numbers, and <code>Vec&lt;u8&gt;</code> or <code>&amp;[8]</code> are JavaScript <code>Uint8Array</code>. JavaScript objects need to go through <code>JSON.stringify()</code> or <code>JSON.parse()</code> before being passed into or returned from Rust functions.</p>
<pre><code class="language-javascript">const { say, obfusticate, lowest_common_denominator, sha3_digest, keccak_digest, create_line } = require('./functions_lib.js');

var util = require('util');
const encoder = new util.TextEncoder();
console.hex = (d) =&gt; console.log((Object(d).buffer instanceof ArrayBuffer ? new Uint8Array(d.buffer) : typeof d === 'string' ? (new util.TextEncoder('utf-8')).encode(d) : new Uint8ClampedArray(d)).reduce((p, c, i, a) =&gt; p + (i % 16 === 0 ? i.toString(16).padStart(6, 0) + '  ' : ' ') + c.toString(16).padStart(2, 0) + (i === a.length - 1 || i % 16 === 15 ?  ' '.repeat((15 - i % 16) * 3) + Array.from(a).splice(i - i % 16, 16).reduce((r, v) =&gt; r + (v &gt; 31 &amp;&amp; v &lt; 127 || v &gt; 159 ? String.fromCharCode(v) : '.'), '  ') + '\n' : ''), ''));

console.log( say(&quot;WasmEdge&quot;) );
console.log( obfusticate(&quot;A quick brown fox jumps over the lazy dog&quot;) );
console.log( lowest_common_denominator(123, 2) );
console.hex( sha3_digest(encoder.encode(&quot;This is an important message&quot;)) );
console.hex( keccak_digest(encoder.encode(&quot;This is an important message&quot;)) );

var p1 = {x:1.5, y:3.8};
var p2 = {x:2.5, y:5.8};
var line = JSON.parse(create_line(JSON.stringify(p1), JSON.stringify(p2), &quot;A thin red line&quot;));
console.log( line );
</code></pre>
<p>After running <code>rustwasmc</code> to build the Rust library, running <code>app.js</code> in Node.js environment produces the following output.</p>
<pre><code class="language-src">$ rustwasmc build
... Building the wasm file and JS shim file in pkg/ ...

$ node node/app.js
hello WasmEdge
N dhvpx oebja sbk whzcf bire gur ynml qbt
246
000000  57 1b e7 d1 bd 69 fb 31 9f 0a d3 fa 0f 9f 9a b5  W.çÑ½iû1..Óú...µ
000010  2b da 1a 8d 38 c7 19 2d 3c 0a 14 a3 36 d3 c3 cb  +Ú..8Ç.-&lt;..£6ÓÃË

000000  7e c2 f1 c8 97 74 e3 21 d8 63 9f 16 6b 03 b1 a9  ~ÂñÈ.tã!Øc..k.±©
000010  d8 bf 72 9c ae c1 20 9f f6 e4 f5 85 34 4b 37 1b  Ø¿r.®Á .öäõ.4K7.

{ points: [ { x: 1.5, y: 3.8 }, { x: 2.5, y: 5.8 } ],
  valid: true,
  length: 2.2360682,
  desc: 'A thin red line' }  
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rust-sdk"><a class="header" href="#rust-sdk">Rust SDK</a></h1>
<p>You can also embed WasmEdge into your Rust application via the WasmEdge Rust SDK.</p>
<p>The WasmEdge Rust SDK includes two Rust crates, wasmedge-sys and wasmedge-rs, for the Rust API. </p>
<ul>
<li>The <a href="https://crates.io/crates/wasmedge-sys">wasmedge-sys</a> is a low-level API generated from the WasmEdge C API. </li>
<li>The <a href="https://crates.io/crates/wasmedge-sdk">wasmedge-sdk</a> is an idiomatic Rust API wrapped around the low-level wasmedge-sys to make it safer and more developer-friendly. The full wasmedge-sdk crate is still under active development. Check out <a href="https://github.com/WasmEdge/WasmEdge/tree/master/bindings/rust">the source code</a> on GitHub. Feedbacks and contributions are welcome.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="python-sdk"><a class="header" href="#python-sdk">Python SDK</a></h1>
<p>Coming soon, or you can <a href="https://github.com/WasmEdge/WasmEdge/pull/633">help out</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="wasmedge-in-kubernetes"><a class="header" href="#wasmedge-in-kubernetes">WasmEdge in Kubernetes</a></h1>
<p>Developers can leverage container tools such as Kubernetes, Docker and CRI-O to deploy, manage, and run lightweight WebAssembly applications. In this chapter, we will demonstrate how Kubernetes ecosystem tools work with <a href="https://github.com/WasmEdge/WasmEdge">WasmEdge</a> WebAssembly applications.</p>
<p>Compared with Linux containers, <a href="https://www.infoq.com/articles/arm-vs-x86-cloud-performance/">WebAssembly could be 100x faster at startup</a>, have a much smaller memory and disk footprint, and have a better-defined safety sandbox. However, the trade-off is that WebAssembly requires its own language SDKs, and compiler toolchains, making it a more constrained developer environment than Linux containers. WebAssembly is increasingly used in Edge Computing scenarios where it is difficult to deploy Linux containers or when the application performance is vital.</p>
<p>One of the great advantages of Linux application containers is the rich ecosystem of tools. The good news is that you can use the exact same tools to manage WebAssembly applications, enabling Linux containers and WebAssembly apps to run side-by-side in the same system.</p>
<center>
<p><img src="kubernetes.png" alt="" /></p>
</center>
<p>The contents of this chapter are organized as follows.</p>
<ul>
<li><a href="kubernetes/quickstart.html">Quick start</a> provides simple and scripted tutorials to run WasmEdge-based applications as container images in Kubernetes.</li>
<li><a href="kubernetes/demo.html">Demo apps</a> discusses the two demo WasmEdge applications we will run in Kubernetes clusters. Those applications are compiled from Rust source code, packaged as OCI images, and uploaded to Docker Hub.</li>
<li><a href="kubernetes/container.html">Container runtimes</a> covers how to configure low level container runtimes, such as crun, to load and run WebAssembly OCI images.</li>
<li><a href="kubernetes/cri.html">CRI runtimes</a> covers how to configure and use high level container runtimes, such as CRI-O and containerd, to load and run WebAssembly OCI images on top of low level container runtimes.</li>
<li><a href="kubernetes/kubernetes.html">Kubernetes</a> covers how to configure and use Kubernetes and Kubernetes variations, such as KubeEdge and SuperEdge, to load and run WebAssembly OCI images on top of CRI runtimes.</li>
</ul>
<p>The goal is to load and run WebAssembly OCI images side by side with Linux OCI images (e.g., today's Docker containers) across the entire Kubernetes stack.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="quick-start"><a class="header" href="#quick-start">Quick start</a></h1>
<p>We have created Ubuntu-based scripts for you to quickly get started
with the following combination of runtimes in a standard Kubernetes setup.</p>
<table><thead><tr><th>CRI (high level) runtime</th><th>OCI (low level) runtime</th><th></th></tr></thead><tbody>
<tr><td>CRI-O</td><td>crun + WasmEdge</td><td><a href="https://github.com/second-state/wasmedge-containers-examples/blob/main/.github/workflows/kubernetes-crio.yml">Script</a></td></tr>
<tr><td>containerd</td><td>crun + WasmEdge</td><td><a href="https://github.com/second-state/wasmedge-containers-examples/blob/main/.github/workflows/kubernetes-containerd.yml">Script</a></td></tr>
</tbody></table>
<h2 id="cri-o-and-crun"><a class="header" href="#cri-o-and-crun">CRI-O and crun</a></h2>
<p>You can use the CRI-O <a href="https://github.com/second-state/wasmedge-containers-examples/blob/main/crio/install.sh">install.sh</a> script to install CRI-O and <code>crun</code> on Ubuntu 20.04.</p>
<pre><code class="language-bash">wget -qO- https://raw.githubusercontent.com/second-state/wasmedge-containers-examples/main/crio/install.sh | bash
</code></pre>
<p>Next, install Kubernetes using the <a href="https://github.com/second-state/wasmedge-containers-examples/blob/main/kubernetes_crio/install.sh">following script</a>.</p>
<pre><code class="language-bash">wget -qO- https://raw.githubusercontent.com/second-state/wasmedge-containers-examples/main/kubernetes_crio/install.sh | bash
</code></pre>
<p>The <a href="https://github.com/second-state/wasmedge-containers-examples/blob/main/kubernetes_crio/simple_wasi_application.sh">simple_wasi_application.sh</a> script shows how to pull <a href="kubernetes/demo/wasi.html">a WebAssembly application</a> from Docker Hub, and then run it as a containerized application in Kubernetes.</p>
<pre><code class="language-bash">wget -qO- https://raw.githubusercontent.com/second-state/wasmedge-containers-examples/main/kubernetes_crio/simple_wasi_application.sh | bash
</code></pre>
<p>You should see results from the WebAssembly program printed in the console log. <a href="https://github.com/second-state/wasmedge-containers-examples/runs/4186005677?check_suite_focus=true#step:6:3007">Here is an example</a>.</p>
<h2 id="containerd-and-crun"><a class="header" href="#containerd-and-crun">containerd and crun</a></h2>
<p>You can use the containerd <a href="https://github.com/second-state/wasmedge-containers-examples/blob/main/containerd/install.sh">install.sh</a> script to install <code>containerd</code> and <code>crun</code> on Ubuntu 20.04.</p>
<pre><code class="language-bash">wget -qO- https://raw.githubusercontent.com/second-state/wasmedge-containers-examples/main/containerd/install.sh | bash
</code></pre>
<p>Next, install Kubernetes using the <a href="https://github.com/second-state/wasmedge-containers-examples/blob/main/kubernetes_containerd/install.sh">following script</a>.</p>
<pre><code class="language-bash">wget -qO- https://raw.githubusercontent.com/second-state/wasmedge-containers-examples/main/kubernetes_containerd/install.sh | bash
</code></pre>
<p>The <a href="https://github.com/second-state/wasmedge-containers-examples/blob/main/kubernetes_containerd/simple_wasi_application.sh">simple_wasi_application.sh</a> script shows how to pull <a href="kubernetes/demo/wasi.html">a WebAssembly application</a> from Docker Hub, and then run it as a containerized application in Kubernetes.</p>
<pre><code class="language-bash">wget -qO- https://raw.githubusercontent.com/second-state/wasmedge-containers-examples/main/kubernetes_containerd/simple_wasi_application.sh | bash
</code></pre>
<p>You should see results from the WebAssembly program printed in the console log. <a href="https://github.com/second-state/wasmedge-containers-examples/runs/4577789181?check_suite_focus=true#step:6:3010">Here is an example</a>.</p>
<p>Read on to the rest of this chapter to learn how exactly those runtimes
are configured.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="demo-apps"><a class="header" href="#demo-apps">Demo apps</a></h1>
<p>In this chapter, we will cover two demo apps. We will build them from Rust
source code, build OCI images around them, and then publish the images to
Docker Hub.</p>
<p>If you have not done so, please</p>
<ul>
<li><a href="https://www.rust-lang.org/tools/install">Install Rust</a></li>
<li><a href="https://hub.docker.com/">Register for Docker Hub</a></li>
</ul>
<p>Next, explore the examples</p>
<ul>
<li><a href="kubernetes/demo/wasi.html">A simple WASI example</a></li>
<li><a href="kubernetes/demo/server.html">A HTTP server example</a></li>
</ul>
<p>Since we have already built and published those demo apps on Docker Hub,
you could also just go straight to the container runtime sections to 
use these images.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="a-simple-webassembly-example"><a class="header" href="#a-simple-webassembly-example">A simple WebAssembly example</a></h1>
<p>In this article, I will show you how to build a container image for a WebAssembly application. It can then be started and managed by Kubernetes ecosystem tools, such as CRI-O, Docker, crun, and Kubernetes.</p>
<h2 id="prerequisites-3"><a class="header" href="#prerequisites-3">Prerequisites</a></h2>
<blockquote>
<p>If you simply want a wasm bytecode file to test as a container image, you can skip the building process and just <a href="https://github.com/second-state/wasm-learning/blob/master/cli/wasi/wasi_example_main.wasm">download the wasm file here</a>.</p>
</blockquote>
<p>If you have not done so already, follow these simple instructions to <a href="https://www.rust-lang.org/tools/install">install Rust</a>.</p>
<h2 id="download-example-code"><a class="header" href="#download-example-code">Download example code</a></h2>
<pre><code class="language-bash">git clone https://github.com/second-state/wasm-learning
cd wasm-learning/cli/wasi
</code></pre>
<h2 id="build-the-wasm-bytecode-2"><a class="header" href="#build-the-wasm-bytecode-2">Build the WASM bytecode</a></h2>
<pre><code class="language-bash">rustup target add wasm32-wasi
cargo build --target wasm32-wasi --release
</code></pre>
<p>The wasm bytecode application is in the <code>target/wasm32-wasi/release/wasi_example_main.wasm</code> file. You can now publish and use it as a container image.</p>
<h2 id="apply-executable-permission-on-the-wasm-bytecode"><a class="header" href="#apply-executable-permission-on-the-wasm-bytecode">Apply executable permission on the Wasm bytecode</a></h2>
<pre><code class="language-bash">chmod +x target/wasm32-wasi/release/wasi_example_main.wasm
</code></pre>
<h2 id="create-dockerfile"><a class="header" href="#create-dockerfile">Create Dockerfile</a></h2>
<p>Create a file called <code>Dockerfile</code> in the <code>target/wasm32-wasi/release/</code> folder with the following content:</p>
<pre><code>FROM scratch
ADD wasi_example_main.wasm /
CMD [&quot;/wasi_example_main.wasm&quot;]
</code></pre>
<h2 id="create-container-image-with-annotations"><a class="header" href="#create-container-image-with-annotations">Create container image with annotations</a></h2>
<blockquote>
<p>Please note that adding self-defined annotation is still a new feature in buildah.</p>
</blockquote>
<p>The <code>crun</code> container runtime can start the above WebAssembly-based container image. But it requires the <code>module.wasm.image/variant=compat</code> annotation on the container image to indicate that it is a WebAssembly application without a guest OS. You can find the details in <a href="https://github.com/containers/crun/blob/main/docs/wasm-wasi-example.md">Official crun repo</a>.</p>
<p>To add <code>module.wasm.image/variant=compat</code> annotation in the container image, you will need the latest <a href="https://buildah.io/">buildah</a>. Currently, Docker does not support this feature. Please follow <a href="https://github.com/containers/buildah/blob/main/install.md">the install instructions of buildah</a> to build the latest buildah binary.</p>
<h3 id="build-and-install-the-latest-buildah-on-ubuntu"><a class="header" href="#build-and-install-the-latest-buildah-on-ubuntu">Build and install the latest buildah on Ubuntu</a></h3>
<p>On Ubuntu zesty and xenial, use these commands to prepare for buildah.</p>
<pre><code class="language-bash">sudo apt-get -y install software-properties-common

export OS=&quot;xUbuntu_20.04&quot;
sudo bash -c &quot;echo \&quot;deb https://download.opensuse.org/repositories/devel:/kubic:/libcontainers:/stable/$OS/ /\&quot; &gt; /etc/apt/sources.list.d/devel:kubic:libcontainers:stable.list&quot;
sudo bash -c &quot;curl -L https://download.opensuse.org/repositories/devel:/kubic:/libcontainers:/stable/$OS/Release.key | apt-key add -&quot;

sudo add-apt-repository -y ppa:alexlarsson/flatpak
sudo apt-get -y -qq update
sudo apt-get -y install bats git libapparmor-dev libdevmapper-dev libglib2.0-dev libgpgme-dev libseccomp-dev libselinux1-dev skopeo-containers go-md2man containers-common
sudo apt-get -y install golang-1.16 make
</code></pre>
<p>Then, follow these steps to build and install buildah on Ubuntu.</p>
<pre><code class="language-bash">mkdir -p ~/buildah
cd ~/buildah
export GOPATH=`pwd`
git clone https://github.com/containers/buildah ./src/github.com/containers/buildah
cd ./src/github.com/containers/buildah
PATH=/usr/lib/go-1.16/bin:$PATH make
cp bin/buildah /usr/bin/buildah
buildah --help
</code></pre>
<h3 id="create-and-publish-a-container-image-with-buildah"><a class="header" href="#create-and-publish-a-container-image-with-buildah">Create and publish a container image with buildah</a></h3>
<p>In the <code>target/wasm32-wasi/release/</code> folder, do the following.</p>
<pre><code class="language-bash">sudo buildah build --annotation &quot;module.wasm.image/variant=compat&quot; -t wasm-wasi-example .
# make sure docker is install and running
# systemctl status docker
# to make sure regular user can use docker
# sudo usermod -aG docker $USER
# newgrp docker

# You may need to use docker login to create the `~/.docker/config.json` for auth.
sudo buildah push --authfile ~/.docker/config.json wasm-wasi-example docker://docker.io/hydai/wasm-wasi-example:with-wasm-annotation
</code></pre>
<p>That's it! Now you can try to run it in <a href="kubernetes/demo/../cri/crio.html#run-a-simple-webassembly-app">CRI-O</a> or <a href="kubernetes/demo/../kubernetes/kubernetes.html#run-a-simple-webassembly-app">Kubernetes</a>!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="http-server-example"><a class="header" href="#http-server-example">HTTP server example</a></h1>
<p>Let's build a container image for a WebAssembly HTTP service.
The HTTP service application is developed in Rust using the <a href="https://github.com/second-state/wasmedge_wasi_socket">WasmEdge networking socket API</a>.
Kubernetes could manage the wasm application lifecycle
with CRI-O, Docker and Containerd.</p>
<h2 id="prerequisites-4"><a class="header" href="#prerequisites-4">Prerequisites</a></h2>
<p>This is a Rust example, which require you to install <a href="https://www.rust-lang.org/tools/install">Rust</a>
and <a href="https://github.com/WasmEdge/WasmEdge/blob/master/docs/install.md">WasmEdge</a>
before you can Compile and Run the http service.</p>
<h2 id="download-example-code-1"><a class="header" href="#download-example-code-1">Download example code</a></h2>
<pre><code class="language-bash">mkdir http_server
cd http_server
wget -q https://raw.githubusercontent.com/second-state/wasmedge_wasi_socket/main/examples/http_server/Cargo.toml
mkdir src
cd src
wget -q https://raw.githubusercontent.com/second-state/wasmedge_wasi_socket/main/examples/http_server/src/main.rs
cd ../
</code></pre>
<h2 id="build-the-wasm-bytecode-3"><a class="header" href="#build-the-wasm-bytecode-3">Build the WASM bytecode</a></h2>
<pre><code class="language-bash">rustup target add wasm32-wasi
cargo build --target wasm32-wasi --release
</code></pre>
<p>The wasm bytecode application is now should be located in the <code>./target/wasm32-wasi/release/http_server.wasm</code>
You can now test run it with wasmedge and then publish it as a container image.</p>
<h2 id="apply-executable-permission-on-the-wasm-bytecode-1"><a class="header" href="#apply-executable-permission-on-the-wasm-bytecode-1">Apply executable permission on the Wasm bytecode</a></h2>
<pre><code class="language-bash">chmod +x ./target/wasm32-wasi/release/http_server.wasm
</code></pre>
<h2 id="running-the-http_server-application-bytecode-with-wasmedge"><a class="header" href="#running-the-http_server-application-bytecode-with-wasmedge">Running the http_server application bytecode with wasmedge</a></h2>
<p>When you run the bytecode with wasmedge and see the result as the following, you
are ready to package the bytecode into the container.</p>
<pre><code class="language-bash">wasmedge ./target/wasm32-wasi/release/http_server.wasm
new connection at 1234
</code></pre>
<p>You can test the server from another terminal window.</p>
<pre><code class="language-bash">$ curl -X POST http://127.0.0.1:1234 -d 'name=WasmEdge'
echo: name=WasmEdge
</code></pre>
<h2 id="create-dockerfile-1"><a class="header" href="#create-dockerfile-1">Create Dockerfile</a></h2>
<p>Create a file called <code>Dockerfile</code> in the <code>target/wasm32-wasi/release/</code> folder with the following content:</p>
<pre><code>FROM scratch
ADD http_server.wasm /
CMD [&quot;/http_server.wasm&quot;]
</code></pre>
<h2 id="create-container-image-with-annotations-1"><a class="header" href="#create-container-image-with-annotations-1">Create container image with annotations</a></h2>
<blockquote>
<p>Please note that adding self-defined annotation is still a new feature in buildah.</p>
</blockquote>
<p>The <code>crun</code> container runtime can start the above WebAssembly-based container image. But it requires the <code>module.wasm.image/variant=compat</code> annotation on the container image to indicate that it is a WebAssembly application without a guest OS. You can find the details in <a href="https://github.com/containers/crun/blob/main/docs/wasm-wasi-example.md">Official crun repo</a>.</p>
<p>To add <code>module.wasm.image/variant=compat</code> annotation in the container image, you will need the latest <a href="https://buildah.io/">buildah</a>. Currently, Docker does not support this feature. Please follow <a href="https://github.com/containers/buildah/blob/main/install.md">the install instructions of buildah</a> to build the latest buildah binary.</p>
<h3 id="build-and-install-the-latest-buildah-on-ubuntu-1"><a class="header" href="#build-and-install-the-latest-buildah-on-ubuntu-1">Build and install the latest buildah on Ubuntu</a></h3>
<p>On Ubuntu zesty and xenial, use these commands to prepare for buildah.</p>
<pre><code class="language-bash">sudo apt-get -y install software-properties-common

export OS=&quot;xUbuntu_20.04&quot;
sudo bash -c &quot;echo \&quot;deb https://download.opensuse.org/repositories/devel:/kubic:/libcontainers:/stable/$OS/ /\&quot; &gt; /etc/apt/sources.list.d/devel:kubic:libcontainers:stable.list&quot;
sudo bash -c &quot;curl -L https://download.opensuse.org/repositories/devel:/kubic:/libcontainers:/stable/$OS/Release.key | apt-key add -&quot;

sudo add-apt-repository -y ppa:alexlarsson/flatpak
sudo apt-get -y -qq update

sudo apt-get -y install bats git libapparmor-dev libdevmapper-dev libglib2.0-dev libgpgme-dev libseccomp-dev libselinux1-dev skopeo-containers go-md2man containers-common
sudo apt-get -y install golang-1.16 make
</code></pre>
<p>Then, follow these steps to build and install buildah on Ubuntu.</p>
<pre><code class="language-bash">mkdir -p ~/buildah
cd ~/buildah
export GOPATH=`pwd`
git clone https://github.com/containers/buildah ./src/github.com/containers/buildah
cd ./src/github.com/containers/buildah
PATH=/usr/lib/go-1.16/bin:$PATH make
cp bin/buildah /usr/bin/buildah
buildah --help
</code></pre>
<h3 id="create-and-publish-a-container-image-with-buildah-1"><a class="header" href="#create-and-publish-a-container-image-with-buildah-1">Create and publish a container image with buildah</a></h3>
<p>In the <code>target/wasm32-wasi/release/</code> folder, do the following.</p>
<pre><code class="language-bash">sudo buildah build --annotation &quot;module.wasm.image/variant=compat&quot; -t http_server .

#
# make sure docker is install and running
# systemctl status docker
# to make sure regular user can use docker
# sudo usermod -aG docker $USER#
# newgrp docker

# You may need to use docker login to create the `~/.docker/config.json` for auth.
#
# docker login

sudo buildah push --authfile ~/.docker/config.json http_server docker://docker.io/avengermojo/http_server:with-wasm-annotation
</code></pre>
<p>That's it! Now you can try to run it in <a href="kubernetes/demo/../cri/crio.html#run-a-http-server-app">CRI-O</a> or <a href="kubernetes/demo/../kubernetes/kubernetes.html#run-a-http-server-app">Kubernetes</a>!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="container-runtimes"><a class="header" href="#container-runtimes">Container runtimes</a></h1>
<p>The container image can be started by any OCI-compliant container runtime, such as</p>
<ul>
<li><a href="kubernetes/container/crun.html">crun</a>: a high performance and lightweight container runtime written in C</li>
<li><a href="kubernetes/container/runc.html">runc</a>: a widely used container runtime written in Go</li>
<li><a href="kubernetes/container/youki.html">youki</a>: a OCI-compatible container runtime implementation written in Rust</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="crun"><a class="header" href="#crun">crun</a></h1>
<p>The <a href="https://github.com/containers/crun">crun project</a> has WasmEdge support baked in.
For now, the easiest approach is just built it yourself from source. First, let's make sure that <code>crun</code> dependencies are installed on your Ubuntu 20.04.
For other Linux distributions, please <a href="https://github.com/containers/crun#readme">see here</a>.</p>
<pre><code class="language-bash">sudo apt update
sudo apt install -y make git gcc build-essential pkgconf libtool \
   libsystemd-dev libprotobuf-c-dev libcap-dev libseccomp-dev libyajl-dev \
   go-md2man libtool autoconf python3 automake
</code></pre>
<p>Next, configure, build, and install a <code>crun</code> binary with WasmEdge support.</p>
<pre><code class="language-bash">git clone https://github.com/containers/crun
cd crun
./autogen.sh
./configure --with-wasmedge
make
sudo make install
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="runc"><a class="header" href="#runc">runc</a></h1>
<p>Coming soon, or you can <a href="https://github.com/WasmEdge/WasmEdge/issues/639">help out</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="youki"><a class="header" href="#youki">youki</a></h1>
<p>Coming soon, or you can <a href="https://github.com/WasmEdge/WasmEdge/issues/664">help out</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cri-runtimes"><a class="header" href="#cri-runtimes">CRI runtimes</a></h1>
<p>The high-level container runtime, such as <a href="https://cri-o.io/">CRI-O</a> and <a href="https://containerd.io/">containerd</a>, pulls container images from registries (e.g., Docker Hub), manages them on disk, and launches a lower-level runtime to run container processes.
From this chapter, you can check out specific tutorials for CRI-O and containerd.</p>
<ul>
<li><a href="kubernetes/cri/crio.html">CRI-O</a></li>
<li><a href="kubernetes/cri/containerd.html">containerd</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cri-o"><a class="header" href="#cri-o">CRI-O</a></h1>
<h2 id="quick-start-1"><a class="header" href="#quick-start-1">Quick start</a></h2>
<p>The <a href="https://github.com/second-state/wasmedge-containers-examples/">GitHub repo</a> contains scripts and Github Actions for running our example
apps on CRI-O.</p>
<ul>
<li>Simple WebAssembly example <a href="https://github.com/second-state/wasmedge-containers-examples/blob/main/crio/README.md">Quick start</a> | <a href="https://github.com/second-state/wasmedge-containers-examples/blob/main/.github/workflows/crio.yml">Github Actions</a> | <a href="https://github.com/second-state/wasmedge-containers-examples/runs/4317457300?check_suite_focus=true#step:4:37">Successful run</a></li>
<li>HTTP service example <a href="https://github.com/second-state/wasmedge-containers-examples/blob/main/crio/http_server/README.md">Quick start</a> | <a href="https://github.com/second-state/wasmedge-containers-examples/blob/main/.github/workflows/crio-server.yml">Github Actions</a> | <a href="https://github.com/second-state/wasmedge-containers-examples/runs/4317457313?check_suite_focus=true#step:4:54">Successful run</a></li>
</ul>
<p>In the sections below, we will explain the steps in the quick start scripts.</p>
<ul>
<li><a href="kubernetes/cri/crio.html#install-cri-o">Install CRI-O</a></li>
<li><a href="kubernetes/cri/crio.html#configure-cri-o-to-use-crun">Configure CRI-O and crun</a></li>
<li><a href="kubernetes/cri/crio.html#run-a-simple-webassembly-app">Example 1: Simple WebAssembly</a></li>
<li><a href="kubernetes/cri/crio.html#run-a-http-server-app">Example 2: HTTP server in WebAssembly</a></li>
</ul>
<h2 id="install-cri-o"><a class="header" href="#install-cri-o">Install CRI-O</a></h2>
<p>Use the following commands to install CRI-O on your system.</p>
<pre><code class="language-bash">export OS=&quot;xUbuntu_20.04&quot;
export VERSION=&quot;1.21&quot;
apt update
apt install -y libseccomp2 || sudo apt update -y libseccomp2
echo &quot;deb https://download.opensuse.org/repositories/devel:/kubic:/libcontainers:/stable/$OS/ /&quot; &gt; /etc/apt/sources.list.d/devel:kubic:libcontainers:stable.list
echo &quot;deb https://download.opensuse.org/repositories/devel:/kubic:/libcontainers:/stable:/cri-o:/$VERSION/$OS/ /&quot; &gt; /etc/apt/sources.list.d/devel:kubic:libcontainers:stable:cri-o:$VERSION.list

curl -L https://download.opensuse.org/repositories/devel:kubic:libcontainers:stable:cri-o:$VERSION/$OS/Release.key | apt-key add -
curl -L https://download.opensuse.org/repositories/devel:/kubic:/libcontainers:/stable/$OS/Release.key | apt-key add -

apt-get update
apt-get install criu libyajl2
apt-get install cri-o cri-o-runc cri-tools containernetworking-plugins
systemctl start crio
</code></pre>
<h2 id="configure-cri-o-to-use-crun"><a class="header" href="#configure-cri-o-to-use-crun">Configure CRI-O to use crun</a></h2>
<p>CRI-O uses the <code>runc</code> runtime by default and we need to configure it to use <code>crun</code> instead.
That is done by adding to two configuration files.</p>
<blockquote>
<p>Make sure that you have <a href="kubernetes/cri/../container/crun.html">built and installed the <code>crun</code> binary with WasmEdge support</a> before starting the following steps.</p>
</blockquote>
<p>First, create a <code>/etc/crio/crio.conf</code> file and add the following lines as its content. It tells CRI-O to use <code>crun</code> by default.</p>
<pre><code>[crio.runtime]
default_runtime = &quot;crun&quot;
</code></pre>
<p>The <code>crun</code> runtime is in turn defined in the <code>/etc/crio/crio.conf.d/01-crio-runc.conf</code> file.</p>
<pre><code>[crio.runtime.runtimes.runc]
runtime_path = &quot;/usr/lib/cri-o-runc/sbin/runc&quot;
runtime_type = &quot;oci&quot;
runtime_root = &quot;/run/runc&quot;
# The above is the original content

# Add our crunw runtime here
[crio.runtime.runtimes.crun]
runtime_path = &quot;/usr/bin/crun&quot;
runtime_type = &quot;oci&quot;
runtime_root = &quot;/run/crun&quot;
</code></pre>
<p>Next, restart CRI-O to apply the configuration changes.</p>
<pre><code class="language-bash">systemctl restart crio
</code></pre>
<h2 id="run-a-simple-webassembly-app"><a class="header" href="#run-a-simple-webassembly-app">Run a simple WebAssembly app</a></h2>
<p>Now, we can run a simple WebAssembly program using CRI-O.
<a href="kubernetes/cri/../demo/wasi.html">A separate article</a> explains how to compile, package, and publish the WebAssembly
program as a container image to Docker hub.
In this section, we will start off pulling this WebAssembly-based container
image from Docker hub using CRI-O tools.</p>
<pre><code class="language-bash">sudo crictl pull docker.io/hydai/wasm-wasi-example:with-wasm-annotation
</code></pre>
<p>Next, we need to create two simple configuration files that specifies how
CRI-O should run this WebAssembly image in a sandbox. We already have those
two files <a href="https://github.com/second-state/wasmedge-containers-examples/blob/main/crio/container_wasi.json">container_wasi.json</a> and <a href="https://github.com/second-state/wasmedge-containers-examples/blob/main/crio/sandbox_config.json">sandbox_config.json</a>.
You can just download them to your local directory as follows.</p>
<pre><code class="language-bash">wget https://raw.githubusercontent.com/second-state/wasmedge-containers-examples/main/crio/sandbox_config.json
wget https://raw.githubusercontent.com/second-state/wasmedge-containers-examples/main/crio/container_wasi.json
</code></pre>
<p>Now you can use CRI-O to create a pod and a container using the specified configurations.</p>
<pre><code class="language-bash"># Create the POD. Output will be different from example.
sudo crictl runp sandbox_config.json
7992e75df00cc1cf4bff8bff660718139e3ad973c7180baceb9c84d074b516a4
# Set a helper variable for later use.
POD_ID=7992e75df00cc1cf4bff8bff660718139e3ad973c7180baceb9c84d074b516a4

# Create the container instance. Output will be different from example.
sudo crictl create $POD_ID container_wasi.json sandbox_config.json
# Set a helper variable for later use.
CONTAINER_ID=1d056e4a8a168f0c76af122d42c98510670255b16242e81f8e8bce8bd3a4476f
</code></pre>
<p>Starting the container would execute the WebAssembly program. You can see the output in the console.</p>
<pre><code class="language-bash"># List the container, the state should be `Created`
sudo crictl ps -a

CONTAINER           IMAGE                                          CREATED              STATE               NAME                     ATTEMPT             POD ID
1d056e4a8a168       hydai/wasm-wasi-example:with-wasm-annotation   About a minute ago   Created             podsandbox1-wasm-wasi   0                   7992e75df00cc

# Start the container
sudo crictl start $CONTAINER_ID

# Check the container status again.
# If the container is not finishing its job, you will see the Running state
# Because this example is very tiny. You may see Exited at this moment.
sudo crictl ps -a
CONTAINER           IMAGE                                          CREATED              STATE               NAME                     ATTEMPT             POD ID
1d056e4a8a168       hydai/wasm-wasi-example:with-wasm-annotation   About a minute ago   Running             podsandbox1-wasm-wasi   0                   7992e75df00cc

# When the container is finished. You can see the state becomes Exited.
sudo crictl ps -a
CONTAINER           IMAGE                                          CREATED              STATE               NAME                     ATTEMPT             POD ID
1d056e4a8a168       hydai/wasm-wasi-example:with-wasm-annotation   About a minute ago   Exited              podsandbox1-wasm-wasi   0                   7992e75df00cc

# Check the container's logs. It should show outputs from the WebAssembly programs
sudo crictl logs $CONTAINER_ID

Test 1: Print Random Number
Random number: 960251471

Test 2: Print Random Bytes
Random bytes: [50, 222, 62, 128, 120, 26, 64, 42, 210, 137, 176, 90, 60, 24, 183, 56, 150, 35, 209, 211, 141, 146, 2, 61, 215, 167, 194, 1, 15, 44, 156, 27, 179, 23, 241, 138, 71, 32, 173, 159, 180, 21, 198, 197, 247, 80, 35, 75, 245, 31, 6, 246, 23, 54, 9, 192, 3, 103, 72, 186, 39, 182, 248, 80, 146, 70, 244, 28, 166, 197, 17, 42, 109, 245, 83, 35, 106, 130, 233, 143, 90, 78, 155, 29, 230, 34, 58, 49, 234, 230, 145, 119, 83, 44, 111, 57, 164, 82, 120, 183, 194, 201, 133, 106, 3, 73, 164, 155, 224, 218, 73, 31, 54, 28, 124, 2, 38, 253, 114, 222, 217, 202, 59, 138, 155, 71, 178, 113]

Test 3: Call an echo function
Printed from wasi: This is from a main function
This is from a main function

Test 4: Print Environment Variables
The env vars are as follows.
PATH: /usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
TERM: xterm
HOSTNAME: crictl_host
PATH: /usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
The args are as follows.
/var/lib/containers/storage/overlay/006e7cf16e82dc7052994232c436991f429109edea14a8437e74f601b5ee1e83/merged/wasi_example_main.wasm
50000000

Test 5: Create a file `/tmp.txt` with content `This is in a file`

Test 6: Read the content from the previous file
File content is This is in a file

Test 7: Delete the previous file
</code></pre>
<p>Next, you can try to run the app in <a href="kubernetes/cri/../kubernetes/kubernetes-crio.html">Kubernetes</a>!</p>
<h2 id="run-a-http-server-app"><a class="header" href="#run-a-http-server-app">Run a HTTP server app</a></h2>
<p>Finally, we can run a simple WebAssembly-based HTTP micro-service in CRI-O.
<a href="kubernetes/cri/../demo/server.html">A separate article</a> explains how to compile, package, and publish the WebAssembly
program as a container image to Docker hub.
In this section, we will start off pulling this WebAssembly-based container
image from Docker hub using CRI-O tools.</p>
<pre><code class="language-bash">sudo crictl pull docker.io/avengermojo/http_server:with-wasm-annotation
</code></pre>
<p>Next, we need to create two simple configuration files that specifies how
CRI-O should run this WebAssembly image in a sandbox. We already have those
two files <a href="https://raw.githubusercontent.com/second-state/wasmedge-containers-examples/main/crio/http_server/container_http_server.json">container_http_server.json</a> and <a href="https://github.com/second-state/wasmedge-containers-examples/blob/main/crio/sandbox_config.json">sandbox_config.json</a>.
You can just download them to your local directory as follows.</p>
<blockquote>
<p>The <code>sandbox_config.json</code> file is the same for the simple WASI example and the HTTP server example. The other <code>container_*.json</code> file is application specific as it contains the application's Docker Hub URL.</p>
</blockquote>
<pre><code class="language-bash">wget https://raw.githubusercontent.com/second-state/wasmedge-containers-examples/main/crio/sandbox_config.json
wget https://raw.githubusercontent.com/second-state/wasmedge-containers-examples/main/crio/http_server/container_http_server.json
</code></pre>
<p>Now you can use CRI-O to create a pod and a container using the specified configurations.</p>
<pre><code class="language-bash"># Create the POD. Output will be different from example.
sudo crictl runp sandbox_config.json
7992e75df00cc1cf4bff8bff660718139e3ad973c7180baceb9c84d074b516a4
# Set a helper variable for later use.
POD_ID=7992e75df00cc1cf4bff8bff660718139e3ad973c7180baceb9c84d074b516a4

# Create the container instance. Output will be different from example.
sudo crictl create $POD_ID container_http_server.json sandbox_config.json
# Set a helper variable for later use.
CONTAINER_ID=1d056e4a8a168f0c76af122d42c98510670255b16242e81f8e8bce8bd3a4476f
</code></pre>
<p>Starting the container would execute the WebAssembly program. You can see the output in the console.</p>
<pre><code class="language-bash"># Start the container
sudo crictl start $CONTAINER_ID

# Check the container status. It should be Running. 
# If not, wait a few seconds and check again
sudo crictl ps -a
CONTAINER           IMAGE                                          CREATED                  STATE               NAME                ATTEMPT             POD ID
4eeddf8613691       avengermojo/http_server:with-wasm-annotation   Less than a second ago   Running             http_server         0                   1d84f30e7012e

# Check the container's logs to see the HTTP server is listening at port 1234
sudo crictl logs $CONTAINER_ID
new connection at 1234

# Get the IP address assigned to the container
sudo crictl inspect $CONTAINER_ID | grep IP.0 | cut -d: -f 2 | cut -d'&quot;' -f 2
10.85.0.2

# Test the HTTP service at that IP address
curl -d &quot;name=WasmEdge&quot; -X POST http://10.85.0.2:1234
echo: name=WasmEdge
</code></pre>
<p>Next, you can try to run it in <a href="kubernetes/cri/../kubernetes/kubernetes-crio.html">Kubernetes</a>!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="containerd"><a class="header" href="#containerd">containerd</a></h1>
<h2 id="quick-start-2"><a class="header" href="#quick-start-2">Quick start</a></h2>
<p>The <a href="https://github.com/second-state/wasmedge-containers-examples/">GitHub repo</a> contains scripts and Github Actions for running our example
apps on containerd.</p>
<ul>
<li>Simple WebAssembly example <a href="https://github.com/second-state/wasmedge-containers-examples/blob/main/containerd/README.md">Quick start</a> | <a href="https://github.com/second-state/wasmedge-containers-examples/blob/main/.github/workflows/containerd.yml">Github Actions</a> | <a href="https://github.com/second-state/wasmedge-containers-examples/runs/4328930139?check_suite_focus=true#step:4:25">Successful run</a></li>
<li>HTTP service example <a href="https://github.com/second-state/wasmedge-containers-examples/blob/main/containerd/http_server/README.md">Quick start</a> | <a href="https://github.com/second-state/wasmedge-containers-examples/blob/main/.github/workflows/containerd-server.yml">Github Actions</a> | <a href="https://github.com/second-state/wasmedge-containers-examples/runs/4328930141?check_suite_focus=true#step:4:44">Successful run</a></li>
</ul>
<p>In the sections below, we will explain the steps in the quick start scripts.</p>
<ul>
<li><a href="kubernetes/cri/containerd.html#install-containerd">Install containerd</a></li>
<li><a href="kubernetes/cri/containerd.html#run-a-simple-webassembly-app">Example 1: Simple WebAssembly</a></li>
<li><a href="kubernetes/cri/containerd.html#run-a-http-server-app">Example 2: HTTP server in WebAssembly</a></li>
</ul>
<h2 id="install-containerd"><a class="header" href="#install-containerd">Install containerd</a></h2>
<p>Use the following commands to install containerd on your system.</p>
<pre><code class="language-bash">export VERSION=&quot;1.5.7&quot;
echo -e &quot;Version: $VERSION&quot;
echo -e &quot;Installing libseccomp2 ...&quot;
sudo apt install -y libseccomp2
echo -e &quot;Installing wget&quot;
sudo apt install -y wget

wget https://github.com/containerd/containerd/releases/download/v${VERSION}/cri-containerd-cni-${VERSION}-linux-amd64.tar.gz
wget https://github.com/containerd/containerd/releases/download/v${VERSION}/cri-containerd-cni-${VERSION}-linux-amd64.tar.gz.sha256sum
sha256sum --check cri-containerd-cni-${VERSION}-linux-amd64.tar.gz.sha256sum

sudo tar --no-overwrite-dir -C / -xzf cri-containerd-cni-${VERSION}-linux-amd64.tar.gz
sudo systemctl daemon-reload
</code></pre>
<p>Configure containerd to use <code>crun</code> as the underlying OCI runtime.
It makes changes to the <code>/etc/containerd/config.toml</code> file.</p>
<pre><code class="language-bash">sudo mkdir -p /etc/containerd/
sudo bash -c &quot;containerd config default &gt; /etc/containerd/config.toml&quot;
wget https://raw.githubusercontent.com/second-state/wasmedge-containers-examples/main/containerd/containerd_config.diff
sudo patch -d/ -p0 &lt; containerd_config.diff
</code></pre>
<p>Start the containerd service.</p>
<pre><code class="language-bash">sudo systemctl start containerd
</code></pre>
<p>Next, make sure that you have <a href="kubernetes/cri/../container/crun.html">built and installed the <code>crun</code> binary with WasmEdge support</a> before running the following examples.</p>
<h2 id="run-a-simple-webassembly-app-1"><a class="header" href="#run-a-simple-webassembly-app-1">Run a simple WebAssembly app</a></h2>
<p>Now, we can run a simple WebAssembly program using containerd.
<a href="kubernetes/cri/../demo/wasi.html">A separate article</a> explains how to compile, package, and publish the WebAssembly
program as a container image to Docker hub.
In this section, we will start off pulling this WebAssembly-based container
image from Docker hub using containerd tools.</p>
<pre><code class="language-bash">sudo ctr i pull docker.io/hydai/wasm-wasi-example:with-wasm-annotation
</code></pre>
<p>Now, you can run the example in just one line with ctr (the containerd cli).</p>
<pre><code class="language-bash">sudo ctr run --rm --runc-binary crun --runtime io.containerd.runc.v2 --label module.wasm.image/variant=compat docker.io/hydai/wasm-wasi-example:with-wasm-annotation wasm-example /wasi_example_main.wasm 50000000
</code></pre>
<p>Starting the container would execute the WebAssembly program. You can see the output in the console.</p>
<pre><code class="language-bash">Creating POD ...
Random number: -1678124602
Random bytes: [12, 222, 246, 184, 139, 182, 97, 3, 74, 155, 107, 243, 20, 164, 175, 250, 60, 9, 98, 25, 244, 92, 224, 233, 221, 196, 112, 97, 151, 155, 19, 204, 54, 136, 171, 93, 204, 129, 177, 163, 187, 52, 33, 32, 63, 104, 128, 20, 204, 60, 40, 183, 236, 220, 130, 41, 74, 181, 103, 178, 43, 231, 92, 211, 219, 47, 223, 137, 70, 70, 132, 96, 208, 126, 142, 0, 133, 166, 112, 63, 126, 164, 122, 49, 94, 80, 26, 110, 124, 114, 108, 90, 62, 250, 195, 19, 189, 203, 175, 189, 236, 112, 203, 230, 104, 130, 150, 39, 113, 240, 17, 252, 115, 42, 12, 185, 62, 145, 161, 3, 37, 161, 195, 138, 232, 39, 235, 222]
Printed from wasi: This is from a main function
This is from a main function
The env vars are as follows.
The args are as follows.
/wasi_example_main.wasm
50000000
File content is This is in a file
</code></pre>
<p>Next, you can try to run it in <a href="kubernetes/cri/../kubernetes/kubernetes.html#run-a-simple-webassembly-app">Kubernetes</a>!</p>
<h2 id="run-a-http-server-app-1"><a class="header" href="#run-a-http-server-app-1">Run a HTTP server app</a></h2>
<p>Finally, we can run a simple WebAssembly-based HTTP micro-service in containerd.
<a href="kubernetes/cri/../demo/server.html">A separate article</a> explains how to compile, package, and publish the WebAssembly
program as a container image to Docker hub.
In this section, we will start off pulling this WebAssembly-based container
image from Docker hub using containerd tools.</p>
<pre><code class="language-bash">sudo ctr i pull docker.io/avengermojo/http_server:with-wasm-annotation
</code></pre>
<p>Now, you can run the example in just one line with ctr (the containerd cli). Notice that we are running the container with <code>--net-host</code> so that the HTTP server inside the WasmEdge container is accessible from the outside shell.</p>
<pre><code class="language-bash">sudo ctr run --rm --net-host --runc-binary crun --runtime io.containerd.runc.v2 --label module.wasm.image/variant=compat docker.io/avengermojo/http_server:with-wasm-annotation http-server-example /http_server.wasm
</code></pre>
<p>Starting the container would execute the WebAssembly program. You can see the output in the console.</p>
<pre><code class="language-bash">new connection at 1234

# Test the HTTP service at that IP address
curl -d &quot;name=WasmEdge&quot; -X POST http://127.0.0.1:1234
echo: name=WasmEdge
</code></pre>
<p>Next, you can try to run it in <a href="kubernetes/cri/../kubernetes/kubernetes.html#run-a-http-server-app">Kubernetes</a>!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="kubernetes"><a class="header" href="#kubernetes">Kubernetes</a></h1>
<p>Most high-level container runtimes implement Kubernetes' CRI (Container Runtime Interface) spec so that they can be managed by Kubernetes tools. That means you can use Kubernetes tools to manage the WebAssembly app image in pods and namespaces.
Check out specific instructions for different flavors of Kubernetes setup 
in this chapter.</p>
<ul>
<li><a href="kubernetes/kubernetes/kubernetes-crio.html">Kubernetes + CRI-O</a></li>
<li><a href="kubernetes/kubernetes/kubernetes-containerd.html">Kubernetes + containerd</a></li>
<li><a href="kubernetes/kubernetes/kubeedge.html">KubeEdge</a></li>
<li><a href="kubernetes/kubernetes/superedge.html">SuperEdge</a></li>
<li><a href="kubernetes/kubernetes/openyurt.html">OpenYurt</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="kubernetes--cri-o"><a class="header" href="#kubernetes--cri-o">Kubernetes + CRI-O</a></h1>
<h2 id="quick-start-3"><a class="header" href="#quick-start-3">Quick start</a></h2>
<p>The <a href="https://github.com/second-state/wasmedge-containers-examples/">GitHub repo</a> contains scripts and Github Actions for running our example
apps on Kubernetes + CRI-O.</p>
<ul>
<li>Simple WebAssembly example <a href="https://github.com/second-state/wasmedge-containers-examples/blob/main/kubernetes_crio/README.md">Quick start</a> | <a href="https://github.com/second-state/wasmedge-containers-examples/blob/main/.github/workflows/kubernetes-crio.yml">Github Actions</a> | <a href="https://github.com/second-state/wasmedge-containers-examples/runs/4328930134?check_suite_focus=true#step:6:3007">Successful run</a></li>
<li>WebAssembly-based HTTP service <a href="https://github.com/second-state/wasmedge-containers-examples/blob/main/kubernetes_crio/http_server/README.md">Quick start</a> | <a href="https://github.com/second-state/wasmedge-containers-examples/blob/main/.github/workflows/kubernetes-crio-server.yml">Github Actions</a> | <a href="https://github.com/second-state/wasmedge-containers-examples/runs/4577789182?check_suite_focus=true#step:6:3030">Successful run</a></li>
</ul>
<p>In the rest of this section, we will explain the steps in detail.
We will assume that you have already <a href="kubernetes/kubernetes/../cri/crio.html">installed and configured CRI-O</a>
to work with WasmEdge container images.</p>
<h2 id="install-and-start-kubernetes"><a class="header" href="#install-and-start-kubernetes">Install and start Kubernetes</a></h2>
<p>Run the following commands from a terminal window.
It sets up Kubernetes for local development.</p>
<pre><code class="language-bash"># Install go
wget https://golang.org/dl/go1.17.1.linux-amd64.tar.gz
sudo rm -rf /usr/local/go
sudo tar -C /usr/local -xzf go1.17.1.linux-amd64.tar.gz
source /home/${USER}/.profile

# Clone k8s
git clone https://github.com/kubernetes/kubernetes.git
cd kubernetes
git checkout v1.22.2

# Install etcd with hack script in k8s
sudo CGROUP_DRIVER=systemd CONTAINER_RUNTIME=remote CONTAINER_RUNTIME_ENDPOINT='unix:///var/run/crio/crio.sock' ./hack/install-etcd.sh
export PATH=&quot;/home/${USER}/kubernetes/third_party/etcd:${PATH}&quot;
sudo cp third_party/etcd/etcd* /usr/local/bin/

# After run the above command, you can find the following files: /usr/local/bin/etcd  /usr/local/bin/etcdctl  /usr/local/bin/etcdutl

# Build and run k8s with CRI-O
sudo apt-get install -y build-essential
sudo CGROUP_DRIVER=systemd CONTAINER_RUNTIME=remote CONTAINER_RUNTIME_ENDPOINT='unix:///var/run/crio/crio.sock' ./hack/local-up-cluster.sh

... ...
Local Kubernetes cluster is running. Press Ctrl-C to shut it down.
</code></pre>
<p>Do NOT close your terminal window. Kubernetes is running!</p>
<h2 id="run-webassembly-container-images-in-kubernetes"><a class="header" href="#run-webassembly-container-images-in-kubernetes">Run WebAssembly container images in Kubernetes</a></h2>
<p>Finally, we can run WebAssembly programs in Kubernetes as containers in pods.
In this section, we will start from <strong>another terminal window</strong> and start using the cluster.</p>
<pre><code class="language-bash">export KUBERNETES_PROVIDER=local

sudo cluster/kubectl.sh config set-cluster local --server=https://localhost:6443 --certificate-authority=/var/run/kubernetes/server-ca.crt
sudo cluster/kubectl.sh config set-credentials myself --client-key=/var/run/kubernetes/client-admin.key --client-certificate=/var/run/kubernetes/client-admin.crt
sudo cluster/kubectl.sh config set-context local --cluster=local --user=myself
sudo cluster/kubectl.sh config use-context local
sudo cluster/kubectl.sh
</code></pre>
<p>Let's check the status to make sure that the cluster is running.</p>
<pre><code class="language-bash">sudo cluster/kubectl.sh cluster-info

# Expected output
Cluster &quot;local&quot; set.
User &quot;myself&quot; set.
Context &quot;local&quot; created.
Switched to context &quot;local&quot;.
Kubernetes control plane is running at https://localhost:6443
CoreDNS is running at https://localhost:6443/api/v1/namespaces/kube-system/services/kube-dns:dns/proxy

To further debug and diagnose cluster problems, use 'kubectl cluster-info dump'.
</code></pre>
<h3 id="a-simple-webassembly-app"><a class="header" href="#a-simple-webassembly-app">A simple WebAssembly app</a></h3>
<p><a href="kubernetes/kubernetes/../demo/wasi.html">A separate article</a> explains how to compile, package, and publish a simple WebAssembly WASI
program as a container image to Docker hub.
Run the WebAssembly-based image from Docker Hub in the Kubernetes cluster as follows.</p>
<pre><code class="language-bash">sudo cluster/kubectl.sh run -it --rm --restart=Never wasi-demo --image=hydai/wasm-wasi-example:with-wasm-annotation --annotations=&quot;module.wasm.image/variant=compat&quot; /wasi_example_main.wasm 50000000
</code></pre>
<p>The output from the containerized application is printed into the console.</p>
<pre><code class="language-bash">Random number: 401583443
Random bytes: [192, 226, 162, 92, 129, 17, 186, 164, 239, 84, 98, 255, 209, 79, 51, 227, 103, 83, 253, 31, 78, 239, 33, 218, 68, 208, 91, 56, 37, 200, 32, 12, 106, 101, 241, 78, 161, 16, 240, 158, 42, 24, 29, 121, 78, 19, 157, 185, 32, 162, 95, 214, 175, 46, 170, 100, 212, 33, 27, 190, 139, 121, 121, 222, 230, 125, 251, 21, 210, 246, 215, 127, 176, 224, 38, 184, 201, 74, 76, 133, 233, 129, 48, 239, 106, 164, 190, 29, 118, 71, 79, 203, 92, 71, 68, 96, 33, 240, 228, 62, 45, 196, 149, 21, 23, 143, 169, 163, 136, 206, 214, 244, 26, 194, 25, 101, 8, 236, 247, 5, 164, 117, 40, 220, 52, 217, 92, 179]
Printed from wasi: This is from a main function
This is from a main function
The env vars are as follows.
The args are as follows.
/wasi_example_main.wasm
50000000
File content is This is in a file
pod &quot;wasi-demo-2&quot; deleted
</code></pre>
<h3 id="a-webassembly-based-http-service"><a class="header" href="#a-webassembly-based-http-service">A WebAssembly-based HTTP service</a></h3>
<p><a href="kubernetes/kubernetes/../demo/server.html">A separate article</a> explains how to compile, package, and publish a simple WebAssembly HTTP service application
as a container image to Docker hub.
Since the HTTP service container requires networking support provided by
Kubernetes, we will use a <a href="https://github.com/second-state/wasmedge-containers-examples/blob/main/kubernetes_crio/http_server/k8s-http_server.yaml">k8s-http_server.yaml</a> file to specify its exact configuration.</p>
<pre><code class="language-yaml">apiVersion: v1
kind: Pod
metadata:
  name: http-server
  namespace: default
  annotations:
    module.wasm.image/variant: compat
spec:
  hostNetwork: true
  containers:
  - name: http-server
    image: avengermojo/http_server:with-wasm-annotation
    command: [ &quot;/http_server.wasm&quot; ]
    ports:
    - containerPort: 1234
      protocol: TCP
    livenessProbe:
      tcpSocket:
        port: 1234
      initialDelaySeconds: 3
      periodSeconds: 30
</code></pre>
<p>Run the WebAssembly-based image from Docker Hub using the above <code>k8s-http_server.yaml</code> file in the Kubernetes cluster as follows.</p>
<pre><code class="language-bash">sudo ./kubernetes/cluster/kubectl.sh apply -f k8s-http_server.yaml
</code></pre>
<p>Use the following command to see the running container applications and their IP addresses.
Since we are using <code>hostNetwork</code> in the yaml configuration, the HTTP server 
image is running on the local network with IP address <code>127.0.0.1</code>.</p>
<pre><code class="language-bash">sudo cluster/kubectl.sh get pod --all-namespaces -o wide

NAMESPACE     NAME                       READY   STATUS             RESTARTS      AGE   IP          NODE        NOMINATED NODE   READINESS GATES
default       http-server                1/1     Running            1 (26s ago)     60s     127.0.0.1   127.0.0.1   &lt;none&gt;           &lt;none&gt;
</code></pre>
<p>Now, you can use the <code>curl</code> command to access the HTTP service.</p>
<pre><code class="language-bash">curl -d &quot;name=WasmEdge&quot; -X POST http://127.0.0.1:1234
echo: name=WasmEdge
</code></pre>
<p>That's it!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="kubernetes--containerd"><a class="header" href="#kubernetes--containerd">Kubernetes + containerd</a></h1>
<h2 id="quick-start-4"><a class="header" href="#quick-start-4">Quick start</a></h2>
<p>The <a href="https://github.com/second-state/wasmedge-containers-examples/">GitHub repo</a> contains scripts and Github Actions for running our example
apps on Kubernetes + containerd.</p>
<ul>
<li>Simple WebAssembly example <a href="https://github.com/second-state/wasmedge-containers-examples/blob/main/kubernetes_containerd/README.md">Quick start</a> | <a href="https://github.com/second-state/wasmedge-containers-examples/blob/main/.github/workflows/kubernetes-containerd.yml">Github Actions</a> | <a href="https://github.com/second-state/wasmedge-containers-examples/runs/4577789181?check_suite_focus=true#step:6:3010">Successful run</a></li>
<li>WebAssembly-based HTTP service <a href="https://github.com/second-state/wasmedge-containers-examples/blob/main/kubernetes_containerd/http_server/README.md">Quick start</a> | <a href="https://github.com/second-state/wasmedge-containers-examples/blob/main/.github/workflows/kubernetes-containerd-server.yml">Github Actions</a> | <a href="https://github.com/second-state/wasmedge-containers-examples/runs/4577789184?check_suite_focus=true#step:6:3016">Successful run</a></li>
</ul>
<p>In the rest of this section, we will explain the steps in detail.
We will assume that you have already <a href="kubernetes/kubernetes/../cri/containerd.html">installed and configured containerd</a>
to work with WasmEdge container images.</p>
<h2 id="install-and-start-kubernetes-1"><a class="header" href="#install-and-start-kubernetes-1">Install and start Kubernetes</a></h2>
<p>Run the following commands from a terminal window.
It sets up Kubernetes for local development.</p>
<pre><code class="language-bash"># Install go
wget https://golang.org/dl/go1.17.1.linux-amd64.tar.gz
sudo rm -rf /usr/local/go
sudo tar -C /usr/local -xzf go1.17.1.linux-amd64.tar.gz
source /home/${USER}/.profile

# Clone k8s
git clone https://github.com/kubernetes/kubernetes.git
cd kubernetes
git checkout v1.22.2

# Install etcd with hack script in k8s
sudo CGROUP_DRIVER=systemd CONTAINER_RUNTIME=remote CONTAINER_RUNTIME_ENDPOINT='unix:///var/run/crio/crio.sock' ./hack/install-etcd.sh
export PATH=&quot;/home/${USER}/kubernetes/third_party/etcd:${PATH}&quot;
sudo cp third_party/etcd/etcd* /usr/local/bin/

# After run the above command, you can find the following files: /usr/local/bin/etcd  /usr/local/bin/etcdctl  /usr/local/bin/etcdutl

# Build and run k8s with containerd
sudo apt-get install -y build-essential
sudo CGROUP_DRIVER=systemd CONTAINER_RUNTIME=remote CONTAINER_RUNTIME_ENDPOINT='unix:///var/run/crio/crio.sock' ./hack/local-up-cluster.sh

... ...
Local Kubernetes cluster is running. Press Ctrl-C to shut it down.
</code></pre>
<p>Do NOT close your terminal window. Kubernetes is running!</p>
<h2 id="run-webassembly-container-images-in-kubernetes-1"><a class="header" href="#run-webassembly-container-images-in-kubernetes-1">Run WebAssembly container images in Kubernetes</a></h2>
<p>Finally, we can run WebAssembly programs in Kubernetes as containers in pods.
In this section, we will start from <strong>another terminal window</strong> and start using the cluster.</p>
<pre><code class="language-bash">export KUBERNETES_PROVIDER=local

sudo cluster/kubectl.sh config set-cluster local --server=https://localhost:6443 --certificate-authority=/var/run/kubernetes/server-ca.crt
sudo cluster/kubectl.sh config set-credentials myself --client-key=/var/run/kubernetes/client-admin.key --client-certificate=/var/run/kubernetes/client-admin.crt
sudo cluster/kubectl.sh config set-context local --cluster=local --user=myself
sudo cluster/kubectl.sh config use-context local
sudo cluster/kubectl.sh
</code></pre>
<p>Let's check the status to make sure that the cluster is running.</p>
<pre><code class="language-bash">sudo cluster/kubectl.sh cluster-info

# Expected output
Cluster &quot;local&quot; set.
User &quot;myself&quot; set.
Context &quot;local&quot; created.
Switched to context &quot;local&quot;.
Kubernetes control plane is running at https://localhost:6443
CoreDNS is running at https://localhost:6443/api/v1/namespaces/kube-system/services/kube-dns:dns/proxy

To further debug and diagnose cluster problems, use 'kubectl cluster-info dump'.
</code></pre>
<h3 id="a-simple-webassembly-app-1"><a class="header" href="#a-simple-webassembly-app-1">A simple WebAssembly app</a></h3>
<p><a href="kubernetes/kubernetes/../demo/wasi.html">A separate article</a> explains how to compile, package, and publish a simple WebAssembly WASI
program as a container image to Docker hub.
Run the WebAssembly-based image from Docker Hub in the Kubernetes cluster as follows.</p>
<pre><code class="language-bash">sudo cluster/kubectl.sh run -it --rm --restart=Never wasi-demo --image=hydai/wasm-wasi-example:with-wasm-annotation --annotations=&quot;module.wasm.image/variant=compat&quot; --overrides='{&quot;kind&quot;:&quot;Pod&quot;, &quot;apiVersion&quot;:&quot;v1&quot;, &quot;spec&quot;: {&quot;hostNetwork&quot;: true}}' /wasi_example_main.wasm 50000000
</code></pre>
<p>The output from the containerized application is printed into the console.</p>
<pre><code class="language-bash">Random number: 401583443
Random bytes: [192, 226, 162, 92, 129, 17, 186, 164, 239, 84, 98, 255, 209, 79, 51, 227, 103, 83, 253, 31, 78, 239, 33, 218, 68, 208, 91, 56, 37, 200, 32, 12, 106, 101, 241, 78, 161, 16, 240, 158, 42, 24, 29, 121, 78, 19, 157, 185, 32, 162, 95, 214, 175, 46, 170, 100, 212, 33, 27, 190, 139, 121, 121, 222, 230, 125, 251, 21, 210, 246, 215, 127, 176, 224, 38, 184, 201, 74, 76, 133, 233, 129, 48, 239, 106, 164, 190, 29, 118, 71, 79, 203, 92, 71, 68, 96, 33, 240, 228, 62, 45, 196, 149, 21, 23, 143, 169, 163, 136, 206, 214, 244, 26, 194, 25, 101, 8, 236, 247, 5, 164, 117, 40, 220, 52, 217, 92, 179]
Printed from wasi: This is from a main function
This is from a main function
The env vars are as follows.
The args are as follows.
/wasi_example_main.wasm
50000000
File content is This is in a file
pod &quot;wasi-demo-2&quot; deleted
</code></pre>
<h3 id="a-webassembly-based-http-service-1"><a class="header" href="#a-webassembly-based-http-service-1">A WebAssembly-based HTTP service</a></h3>
<p><a href="kubernetes/kubernetes/../demo/server.html">A separate article</a> explains how to compile, package, and publish a simple WebAssembly HTTP service application
as a container image to Docker hub.
Run the WebAssembly-based image from Docker Hub in the Kubernetes cluster as follows.</p>
<pre><code class="language-bash">sudo cluster/kubectl.sh run --restart=Never http-server --image=avengermojo/http_server:with-wasm-annotation --annotations=&quot;module.wasm.image/variant=compat&quot; --overrides='{&quot;kind&quot;:&quot;Pod&quot;, &quot;apiVersion&quot;:&quot;v1&quot;, &quot;spec&quot;: {&quot;hostNetwork&quot;: true}}'
</code></pre>
<p>Since we are using <code>hostNetwork</code> in the <code>kubectl run</code> command, the HTTP server 
image is running on the local network with IP address <code>127.0.0.1</code>.
Now, you can use the <code>curl</code> command to access the HTTP service.</p>
<pre><code class="language-bash">curl -d &quot;name=WasmEdge&quot; -X POST http://127.0.0.1:1234
echo: name=WasmEdge
</code></pre>
<p>That's it!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="kubeedge"><a class="header" href="#kubeedge">KubeEdge</a></h1>
<p>Coming soon, checkout our ongoing work <a href="https://github.com/yenhsunli/Create-a-crun-demo-for-KubeEdge">here</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="superedge"><a class="header" href="#superedge">SuperEdge</a></h1>
<p>Coming soon, or you can <a href="https://github.com/WasmEdge/WasmEdge/issues/598">help out</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="openyurt"><a class="header" href="#openyurt">OpenYurt</a></h1>
<p>Coming soon, or you can <a href="https://github.com/WasmEdge/WasmEdge/issues/597">help out</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="app-frameworks-and-platforms"><a class="header" href="#app-frameworks-and-platforms">App frameworks and platforms</a></h1>
<p>WasmEdge applications can be plugged into existing application frameworks or
platforms. WasmEdge provides a safe and efficient extension mechanism for those
frameworks.</p>
<p>In this chapter, we will cover several such framework and platforms.</p>
<ul>
<li><a href="frameworks/mesh.html">Service mesh and frameworks</a> support WasmEdge to run as containers for microservices. We will cover distributed application framework <a href="frameworks/mesh/dapr.html">Dapr</a>, service mesh <a href="frameworks/mesh/mosn.html">MOSN</a>, and event mesh <a href="frameworks/mesh/eventmesh.html">Apache EventMesh</a>.</li>
<li><a href="frameworks/app.html">Application frameworks</a> support WasmEdge as an embedded function or plug-in runtime. We will cover streaming data framework <a href="frameworks/app/yomo.html">YoMo</a> and Go function schedulder / framework <a href="frameworks/app/reactr.html">Reactr</a>.</li>
<li><a href="frameworks/serverless.html">Serverless platforms</a> allows WasmEdge programs to run as serverless functions in their infrastructure. We will cover <a href="frameworks/serverless/aws.html">AWS Lambda</a>, <a href="frameworks/serverless/tencent.html">Tencent Serverless Cloud Functions</a>, <a href="frameworks/serverless/vercel.html">Vercel Serverless Functions</a>, <a href="frameworks/serverless/netlify.html">Netlify Functions</a>, and <a href="frameworks/serverless/secondstate.html">Second State Functions</a>.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="service-mesh-and-distributed-runtimes"><a class="header" href="#service-mesh-and-distributed-runtimes">Service mesh and distributed runtimes</a></h1>
<p>WasmEdge could be a lightweight runtime for sidecar microservices and the API proxy as the Docker alternative.</p>
<h2 id="sidecar-microservices"><a class="header" href="#sidecar-microservices">Sidecar microservices</a></h2>
<p>For sidecar frameworks that support multiple application runtimes, we could simply embed WasmEdge applications into the sidecar through its C, Go, Rust, or Node.js SDKs. In addition, WasmEdge applications could be managed directly by container tools and act as sidecar microservices.</p>
<ul>
<li><a href="frameworks/mesh/dapr.html">Dapr</a> showcases how to run WasmEdge microservices as Dapr sidecars.</li>
<li><a href="frameworks/mesh/evenmesh.html">Apache EventMesh</a> showcases how to run WasmEdge microservices as Apache EventMesh sidecars</li>
</ul>
<h2 id="extension-for-the-api-proxy"><a class="header" href="#extension-for-the-api-proxy">Extension for the API proxy</a></h2>
<p>The API proxy is another crucial component in the service mesh. It manages and directs API requests to sidecars in a manner that keeps the system scalable. Developers need to script those proxies to route traffic according to changing infrastructure and ops requirements. Seeing widespread demand for using WebAssembly instead of the LUA scripting language, the community came together and created the proxy-wasm spec. It defines the host interface that WebAssembly runtimes must support to plug into the proxy. WasmEdge supports proxy-wasm now.</p>
<ul>
<li><a href="frameworks/mesh/mosn.html">MOSN</a> shows how to use WasmEdge as extensions for MOSN.</li>
</ul>
<p>If you have some great ideas on WasmEdge and microservices, feel free to create an issue or PR on the <a href="https://github.com/WasmEdge/WasmEdge">WasmEdge</a> GitHub repo!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="dapr"><a class="header" href="#dapr">Dapr</a></h1>
<p>In this article, I will demonstrate how to use WasmEdge as a sidecar application runtime for Dapr. We use a simple NaCl written in Rust or Go to listen for API requests to the microservice. It passes the request data to a WebAssembly runtime for processing. The business logic of the microservice is a WebAssembly function created and deployed by an application developer. You can also watch <a href="https://www.youtube.com/watch?v=t_sQP6Qpf7U">a walk-through video</a>.</p>
<blockquote>
<p>For more insights on WasmEdge on Dapr, please refer to the article <a href="https://www.secondstate.io/articles/dapr-wasmedge-webassembly/">A Lightweight, Safe, Portable, and High-performance Runtime for Dapr</a></p>
</blockquote>
<h2 id="quick-start-5"><a class="header" href="#quick-start-5">Quick start</a></h2>
<p>First you need to install <a href="https://golang.org/doc/install">Go</a>, <a href="https://www.rust-lang.org/tools/install">Rust</a>, <a href="https://docs.dapr.io/getting-started/install-dapr-cli">Dapr</a>, <a href="https://github.com/WasmEdge/WasmEdge/blob/master/docs/install.md">WasmEdge</a>, and the <a href="frameworks/mesh/../../dev/rust/bindgen.html">rustwasmc</a> compiler tool.</p>
<p>Next, fork or clone the demo application from Github. You can use this repo as your own application template.</p>
<pre><code>$ git clone https://github.com/second-state/dapr-wasm
</code></pre>
<p>The demo has 3 Dapr sidecar applications.</p>
<ul>
<li>The <a href="https://github.com/second-state/dapr-wasm/tree/main/web-port">web-port</a> project provides a public web service for a static HTML page. This is the application’s UI.</li>
<li>The <a href="https://github.com/second-state/dapr-wasm/tree/main/image-api-rs">image-api-rs</a> project provides a WasmEdge microservice to turn an input image into a grayscale image using the <a href="https://github.com/second-state/dapr-wasm/tree/main/functions/grayscale&amp;sa=D&amp;source=editors&amp;ust=1634144162467000&amp;usg=AOvVaw1uNZEDmOfXXXzLHHZWVFyD">grayscale</a> function.
It demonstrates the use of Rust SDKs for Dapr and WasmEdge.</li>
<li>The <a href="https://github.com/second-state/dapr-wasm/tree/main/image-api-go&amp;sa=D&amp;source=editors&amp;ust=1634144162467000&amp;usg=AOvVaw3pG0m0DQap9XTUAfBMyi1s">image-api-go</a> project provides a WasmEdge microservice to recognize and classify the object on an input image using the <a href="https://github.com/second-state/dapr-wasm/tree/main/functions/classify&amp;sa=D&amp;source=editors&amp;ust=1634144162468000&amp;usg=AOvVaw0zYdNzIz6MiDkZCAvm_D9q">classify</a> function.
It demonstrates the use of Go SDKs for Dapr and WasmEdge.</li>
</ul>
<p><img src="frameworks/mesh/dapr-wasmedge.png" alt="dapr-wasmedge" /></p>
<p>Dapr sidecar microservices in the demo application.</p>
<p>You can follow the instructions in the <a href="https://github.com/second-state/dapr-wasm/blob/main/README.md">README</a> to start the sidecar services. Here are commands to build the WebAssembly functions and start the 3 sidecar services.</p>
<pre><code># Build the classify and grayscale WebAssembly functions, and deploy them to the sidecar projects
$ cd functions/grayscale
$ ./build.sh
$ cd ../../
$ cd functions/classify
$ ./build.sh
$ cd ../../

# Build and start the web service for the application UI
$ cd web-port
$ go build
$ ./run_web.sh
$ cd ../

# Build and start the microservice for image processing (grayscale)
$ cd image-api-rs
$ cargo build
$ ./run_api_rs.sh
$ cd ../

# Build and start the microservice for tensorflow-based image classification
$ cd image-api-go
$ go build --tags &quot;tensorflow image&quot;
$ ./run_api_go.sh
$ cd ../
</code></pre>
<p>Finally, you should be able to see the web UI in your browser.</p>
<p><img src="frameworks/mesh/dapr-wasmedge-in-action.png" alt="dapr-wasmedge" /></p>
<p>The demo application in action.</p>
<h2 id="the-two-webassembly-functions"><a class="header" href="#the-two-webassembly-functions">The two WebAssembly functions</a></h2>
<p>We have two functions written in Rust and compiled into WebAssembly. They are deployed in the sidecar microservices to perform the actual work of image processing and classification.</p>
<p>While our example WebAssembly functions are written in Rust, you can compile functions written in C/C++, Swift, Kotlin, and AssemblyScript to WebAssembly. WasmEdge also provides support for functions written in
JavaScript and DSLs.</p>
<p>The <a href="https://github.com/second-state/dapr-wasm/tree/main/functions/grayscale">grayscale</a> function is a Rust program that reads image data from <code>STDIN</code> and writes the grayscale image into <code>STDOUT</code>.</p>
<pre><code>use image::{ImageFormat, ImageOutputFormat};
use std::io::{self, Read, Write};

fn main() {
   let mut buf = Vec::new();
   io::stdin().read_to_end(&amp;mut buf).unwrap();

   let image_format_detected: ImageFormat = image::guess_format(&amp;buf).unwrap();
   let img = image::load_from_memory(&amp;buf).unwrap();
   let filtered = img.grayscale();
   let mut buf = vec![];
   match image_format_detected {
       ImageFormat::Gif =&gt; {
           filtered.write_to(&amp;mut buf, ImageOutputFormat::Gif).unwrap();
       }
       _ =&gt; {
           filtered.write_to(&amp;mut buf, ImageOutputFormat::Png).unwrap();
       }
   };
   io::stdout().write_all(&amp;buf).unwrap();
   io::stdout().flush().unwrap();
}
</code></pre>
<p>We use <a href="https://www.secondstate.io/articles/rustwasmc/">rustwasmc</a> to build it and then copy it to the
<a href="https://github.com/second-state/dapr-wasm/tree/main/image-api-rs">image-api-rs</a> sidecar.</p>
<pre><code>$ cd functions/grayscale
$ rustup override set 1.50.0
$ rustwasmc  build --enable-ext
$ cp ./pkg/grayscale.wasm ../../image-api-rs/lib
</code></pre>
<p>The <a href="https://github.com/second-state/dapr-wasm/tree/main/functions/classify">classify</a> function
is a Rust function that takes a byte array for image data as input and returns a string for the classification. It uses the <a href="https://www.secondstate.io/articles/wasi-tensorflow/">WasmEdge
TensorFlow API</a>.</p>
<pre><code>use wasmedge_tensorflow_interface;

pub fn infer_internal(image_data: &amp;[u8]) -&gt; String {
   let model_data: &amp;[u8] = include_bytes!(&quot;models/mobilenet_v1_1.0_224/mobilenet_v1_1.0_224_quant.tflite&quot;);
   let labels = include_str!(&quot;models/mobilenet_v1_1.0_224/labels_mobilenet_quant_v1_224.txt&quot;);

   let flat_img = wasmedge_tensorflow_interface::load_jpg_image_to_rgb8(image_data, 224, 224);

   let mut session = wasmedge_tensorflow_interface::Session::new(
       &amp;model_data,
       wasmedge_tensorflow_interface::ModelType::TensorFlowLite,
   );
   session
       .add_input(&quot;input&quot;, &amp;flat_img, &amp;[1, 224, 224, 3])
       .run();
   let res_vec: Vec&lt;u8&gt; = session.get_output(&quot;MobilenetV1/Predictions/Reshape_1&quot;);

   // ... Map the probabilities in res_vec to text labels in the labels file ...
  
   if max_value &gt; 50 {
       format!(
           &quot;It {} a &lt;a href='https://www.google.com/search?q={}'&gt;{}&lt;/a&gt; in the picture&quot;,
           confidence.to_string(),
           class_name,
           class_name
       )
   } else {
       format!(&quot;It does not appears to be any food item in the picture.&quot;)
   }
}
</code></pre>
<p>We use <a href="https://www.secondstate.io/articles/rustwasmc/">rustwasmc</a> to build it and then copy it to the <a href="https://github.com/second-state/dapr-wasm/tree/main/image-api-go">image-api-go</a> sidecar.</p>
<pre><code>$ cd functions/classify
$ rustup override set 1.50.0
$ rustwasmc  build --enable-ext
$ cp ./pkg/classify_bg.wasm ../../image-api-go/lib/classify_bg.wasm
</code></pre>
<p>In the next three sections, we will look into those three sidecar services.</p>
<h2 id="the-image-processing-sidecar"><a class="header" href="#the-image-processing-sidecar">The image processing sidecar</a></h2>
<p>The <a href="https://github.com/second-state/dapr-wasm/tree/main/image-api-rs">image-api-rs</a> sidecar application is written in Rust. It should already have the WebAssembly function lib/grayscale.wasm installed from the previous step. Please refer to the <a href="https://github.com/second-state/dapr-wasm/blob/main/functions/bin/install.sh">functions/bin/install.sh</a> script to install the WasmEdge Runtime binary <code>lib/wasmedge-tensorflow-lite</code> and
its dependencies.</p>
<p>The sidecar microservice runs a Tokio-based event loop that listens for incoming HTTP requests at the path <code>/api/image</code>.</p>
<pre><code>#[tokio::main]
pub async fn run_server(port: u16) {
   pretty_env_logger::init();

   let home = warp::get().map(warp::reply);

   let image = warp::post()
       .and(warp::path(&quot;api&quot;))
       .and(warp::path(&quot;image&quot;))
       .and(warp::body::bytes())
       .map(|bytes: bytes::Bytes| {
           let v: Vec&lt;u8&gt; = bytes.iter().map(|&amp;x| x).collect();
           let res = image_process(&amp;v);
           Ok(Box::new(res))
       });

   let routes = home.or(image);
   let routes = routes.with(warp::cors().allow_any_origin());

   let log = warp::log(&quot;dapr_wasm&quot;);
   let routes = routes.with(log);
   warp::serve(routes).run((Ipv4Addr::UNSPECIFIED, port)).await
}
</code></pre>
<p>Once it receives an image file in the HTTP POST request, it invokes a WebAssembly function in WasmEdge to perform the image processing task. It creates a WasmEdge instance to interact with the WebAssembly program.</p>
<pre><code>pub fn image_process(buf: &amp;Vec&lt;u8&gt;) -&gt; Vec&lt;u8&gt; {
   let mut child = Command::new(&quot;./lib/wasmedge-tensorflow-lite&quot;)
       .arg(&quot;./lib/grayscale.wasm&quot;)
       .stdin(Stdio::piped())
       .stdout(Stdio::piped())
       .spawn()
       .expect(&quot;failed to execute child&quot;);
   {
       // limited borrow of stdin
       let stdin = child.stdin.as_mut().expect(&quot;failed to get stdin&quot;);
       stdin.write_all(buf).expect(&quot;failed to write to stdin&quot;);
   }
   let output = child.wait_with_output().expect(&quot;failed to wait on child&quot;);
   output.stdout
}
</code></pre>
<p>The following Dapr CLI command starts the microservice in the Dapr runtime environment.</p>
<pre><code>$ cd image-api-rs
$ sudo dapr run --app-id image-api-rs \
        --app-protocol http \
        --app-port 9004 \
        --dapr-http-port 3502 \
        --components-path ../config \
        --log-level debug \
        ./target/debug/image-api-rs
$ cd ../
</code></pre>
<h2 id="the-tensorflow-sidecar"><a class="header" href="#the-tensorflow-sidecar">The Tensorflow sidecar</a></h2>
<p>The <a href="https://github.com/second-state/dapr-wasm/tree/main/image-api-go">image-api-go</a> sidecar application is written in Go. It should already have the WebAssembly function <code>lib/classify\_bg.wasm</code> installed from the previous step. Please refer to the <a href="https://github.com/second-state/dapr-wasm/blob/main/functions/bin/install.sh">functions/bin/install.sh</a> script to install the WasmEdge Runtime Go SDK.</p>
<p>The sidecar microservice runs an event loop that listens for incoming HTTP requests at the path <code>/api/image</code>.</p>
<pre><code>func main() {
   s := daprd.NewService(&quot;:9003&quot;)

   if err := s.AddServiceInvocationHandler(&quot;/api/image&quot;, imageHandlerWASI); err != nil {
       log.Fatalf(&quot;error adding invocation handler: %v&quot;, err)
   }

   if err := s.Start(); err != nil &amp;&amp; err != http.ErrServerClosed {
       log.Fatalf(&quot;error listenning: %v&quot;, err)
   }
}
</code></pre>
<p>Once it receives an image file in the HTTP POST request, it invokes a WebAssembly function in WasmEdge to perform the Tensorflow-based image classification task. It utilizes the Go API for WasmEdge to interact with the WebAssembly program.</p>
<pre><code>func imageHandlerWASI(_ context.Context, in *common.InvocationEvent) (out *common.Content, err error) {
   image := in.Data

   var conf = wasmedge.NewConfigure(wasmedge.REFERENCE_TYPES)
   conf.AddConfig(wasmedge.WASI)
   var vm = wasmedge.NewVMWithConfig(conf)

   var wasi = vm.GetImportObject(wasmedge.WASI)
   wasi.InitWasi(
       os.Args[1:],     /// The args
       os.Environ(),    /// The envs
       []string{&quot;.:.&quot;}, /// The mapping directories
       []string{},      /// The preopens will be empty
   )

   /// Register WasmEdge-tensorflow and WasmEdge-image
   var tfobj = wasmedge.NewTensorflowImportObject()
   var tfliteobj = wasmedge.NewTensorflowLiteImportObject()
   vm.RegisterImport(tfobj)
   vm.RegisterImport(tfliteobj)
   var imgobj = wasmedge.NewImageImportObject()
   vm.RegisterImport(imgobj)

   vm.LoadWasmFile(&quot;./lib/classify_bg.wasm&quot;)
   vm.Validate()
   vm.Instantiate()

   res, err := vm.ExecuteBindgen(&quot;infer&quot;, wasmedge.Bindgen_return_array, image)
   ans := string(res.([]byte))
  
   vm.Delete()
   conf.Delete()

   out = &amp;common.Content{
       Data:        []byte(ans),
       ContentType: in.ContentType,
       DataTypeURL: in.DataTypeURL,
   }
   return out, nil
}
</code></pre>
<p>The following Dapr CLI command starts the microservice in the Dapr runtime environment.</p>
<pre><code>$ cd image-api-go
$ sudo dapr run --app-id image-api-go \
        --app-protocol http \
        --app-port 9003 \
        --dapr-http-port 3501 \
        --log-level debug \
        --components-path ../config \
        ./image-api-go
$ cd ../
</code></pre>
<h2 id="the-web-ui-sidecar"><a class="header" href="#the-web-ui-sidecar">The web UI sidecar</a></h2>
<p>The web UI service <a href="https://github.com/second-state/dapr-wasm/tree/main/web-port">web-port</a> is a simple web server written in Go. It serves static HTML and JavaScript files from the static folder and sends images uploaded to <code>/api/hello</code> to
the <a href="https://github.com/second-state/dapr-wasm/tree/main/image-api-rs">grayscale</a> or <a href="https://github.com/second-state/dapr-wasm/tree/main/image-api-go">classify</a> sidecars’ <code>/api/image</code> endpoints.</p>
<pre><code>func main() {
   http.HandleFunc(&quot;/static/&quot;, staticHandler)
   http.HandleFunc(&quot;/api/hello&quot;, imageHandler)
   println(&quot;listen to 8080 ...&quot;)
   log.Fatal(http.ListenAndServe(&quot;:8080&quot;, nil))
}

func staticHandler(w http.ResponseWriter, r *http.Request) {
   // ... read and return the contents of HTML CSS and JS files ...
}

func imageHandler(w http.ResponseWriter, r *http.Request) {
   // ... ...
   api := r.Header.Get(&quot;api&quot;)
   if api == &quot;go&quot; {
       daprClientSend(body, w)
   } else {
       httpClientSend(body, w)
   }
}

// Send to the image-api-go sidecar (classify) via the Dapr API
func daprClientSend(image []byte, w http.ResponseWriter) {
   // ... ...
   resp, err := client.InvokeMethodWithContent(ctx, &quot;image-api-go&quot;, &quot;/api/image&quot;, &quot;post&quot;, content)
   // ... ...
}

// Send to the image-api-rs sidecar (grayscale) via the HTTP API
func httpClientSend(image []byte, w http.ResponseWriter) {
   // ... ...
   req, err := http.NewRequest(&quot;POST&quot;, &quot;http://localhost:3502/v1.0/invoke/image-api-rs/method/api/image&quot;, bytes.NewBuffer(image))
   // ... ...
}
</code></pre>
<p>The JavaScript in <a href="https://github.com/second-state/dapr-wasm/blob/main/web-port/static/page.js">page.js</a> simply
uploads images to the <a href="https://github.com/second-state/dapr-wasm/tree/main/web-port">web-port</a> sidecar’s <code>/api/hello</code> endpoint and the <a href="https://github.com/second-state/dapr-wasm/tree/main/web-port">web-port</a> will request the classify or grayscale microservice based on the request header api.</p>
<pre><code>function runWasm(e) {
   const reader = new FileReader();
   reader.onload = function (e) {
       setLoading(true);
       var req = new XMLHttpRequest();
       req.open(&quot;POST&quot;, '/api/hello', true);
       req.setRequestHeader('api', getApi());
       req.onload = function () {
           // ...  display results ...
       };
       const blob = new Blob([e.target.result], {
           type: 'application/octet-stream'
       });
       req.send(blob);
   };
   console.log(image.file)
   reader.readAsArrayBuffer(image.file);
}
</code></pre>
<p>The following Dapr CLI command starts the web service for the static UI
files.</p>
<pre><code>$ cd web-port
$ sudo dapr run --app-id go-web-port \
        --app-protocol http \
        --app-port 8080 \
        --dapr-http-port 3500 \
        --components-path ../config \
        --log-level debug \
        ./web-port
$ cd ../
</code></pre>
<p>That's it. You now have a three part distributed application written in two languages!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mosn"><a class="header" href="#mosn">MOSN</a></h1>
<p>Coming soon.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="apache-eventmesh"><a class="header" href="#apache-eventmesh">Apache EventMesh</a></h1>
<p>Coming soon, or you can <a href="https://github.com/WasmEdge/WasmEdge/issues/632">help out</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="app-frameworks"><a class="header" href="#app-frameworks">App frameworks</a></h1>
<p>WasmEdge provides a safe and efficient extension mechanism for applications.
Of course, application developers can always use <a href="frameworks/../embed.html">WasmEdge SDKs</a> to embed 
WebAssembly functions. But some applications and frameworks opt to
build their own extension / embedding APIs on top of the WasmEdge SDK,
which supports more ergonomic integration with the application's 
native use cases and programming models.</p>
<ul>
<li><a href="frameworks/app/yomo.html">YoMo</a> is a data stream processing framework. WasmEdge functions can be plugged into the framework to process data in-stream.</li>
<li><a href="frameworks/app/reactr.html">Reactr</a> is a Go language framework for managing and extending WebAssembly functions for the purpose of easy embedding into other Go applications.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="yomo"><a class="header" href="#yomo">YoMo</a></h1>
<p><a href="https://yomo.run/">YoMo</a> is a programming framework enabling developers to build a distributed cloud system (Geo-Distributed Cloud System). YoMo's communication layer is made on top of the QUIC protocol, which brings high-speed data transmission. In addition, it has a built-in Streaming Serverless &quot;streaming function&quot;, which significantly improves the development experience of distributed cloud systems. The distributed cloud system built by YoMo provides an ultra-high-speed communication mechanism between near-field computing power and terminals. It has a wide range of use cases in Metaverse, VR/AR, IoT, etc.</p>
<blockquote>
<p>YoMo is written in the Go language. For streaming Serverless, Golang plugins and shared libraries are used to load users' code dynamically, which also have certain limitations for developers. Coupled with Serverless architecture's rigid demand for isolation, this makes WebAssembly an excellent choice for running user-defined functions.</p>
</blockquote>
<p>For example, in the process of real-time AI inference in AR/VR devices or smart factories, the camera sends real-time unstructured data to the computing node in the near-field MEC (multi-access edge computing) device through YoMo.  YoMo sends the AI computing result to the end device in real-time when the AI inference is completed. Thus, the hosted AI inference function will be automatically executed.</p>
<p>However, a challenge for YoMo is to incorporate and manage handler functions written by multiple outside developers in an edge computing node. It requires runtime isolation for those functions without sacrificing performance. Traditional software container solutions, such as Docker, are not up to the task. They are too heavy and slow to handle real-time tasks.</p>
<p>WebAssembly provides a lightweight and high-performance software container. It is ideally suited as a runtime for YoMo’s data processing handler functions.</p>
<p>In this article, we will show you how to create a Rust function for Tensorflow-based image classification, compile it into WebAssembly, and then use YoMo to run it as a stream data handler. We use <a href="https://wasmedge.org/">WasmEdge</a> as our WebAssembly runtime because it offers the highest performance and flexibility compared with other WebAssembly runtimes. It is the only WebAssembly VM that reliably supports Tensorflow. YoMo manages WasmEdge VM instances and the contained WebAssembly bytecode apps through <a href="https://www.secondstate.io/articles/extend-golang-app-with-webassembly-rust/">WasmEdge’s Golang API</a>.</p>
<blockquote>
<p>Source code: https://github.com/yomorun/yomo-wasmedge-tensorflow</p>
</blockquote>
<p>Checkout <a href="https://www.youtube.com/watch?v=E0ltsn6cLIU">the WasmEdge image classification function in action in YoMo</a></p>
<h2 id="prerequisite-1"><a class="header" href="#prerequisite-1">Prerequisite</a></h2>
<p>Obviously, you will need to have <a href="https://golang.org/doc/install">Golang installed</a>, but I will assume you already did.</p>
<blockquote>
<p>Golang version should be newer than 1.15 for our example to work.</p>
</blockquote>
<p>You also need to install the YoMo CLI application. It orchestrates and coordinates data streaming and handler function invocations. </p>
<pre><code>$ go install github.com/yomorun/cli/yomo@latest
$ yomo version
YoMo CLI version: v0.1.3
</code></pre>
<p>Next, please install the WasmEdge and its Tensorflow shared libraries. <a href="https://wasmedge.org/">WasmEdge</a> is a leading WebAssembly runtime hosted by the CNCF. We will use it to embed and run WebAssembly programs from YoMo.</p>
<pre><code>$ wget -qO- https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/utils/install.sh | bash -s -- -e all -p /usr/local
</code></pre>
<p>Finally, since our demo WebAssembly functions are written in Rust, you will also need a <a href="https://www.rust-lang.org/tools/install">Rust compiler</a>.</p>
<p>For the rest of the demo, fork and clone the <a href="https://github.com/yomorun/yomo-wasmedge-tensorflow">source code repository</a>.</p>
<pre><code>$ git clone https://github.com/yomorun/yomo-wasmedge-tensorflow.git
</code></pre>
<h2 id="the-image-classification-function"><a class="header" href="#the-image-classification-function">The image classification function</a></h2>
<p>The <a href="https://github.com/yomorun/yomo-wasmedge-tensorflow/tree/main/flow/rust_mobilenet_food">image classification function</a> to process the YoMo image stream is written in Rust. It utilizes the WasmEdge Tensorflow API to process an input image.</p>
<pre><code>#[wasmedge_bindgen]
pub fn infer(image_data: Vec&lt;u8&gt;) -&gt; Result&lt;Vec&lt;u8&gt;, String&gt; {
    let start = Instant::now();

    // Load the TFLite model and its meta data (the text label for each recognized object number)
    let model_data: &amp;[u8] = include_bytes!(&quot;lite-model_aiy_vision_classifier_food_V1_1.tflite&quot;);
    let labels = include_str!(&quot;aiy_food_V1_labelmap.txt&quot;);

    // Pre-process the image to a format that can be used by this model
    let flat_img = wasmedge_tensorflow_interface::load_jpg_image_to_rgb8(&amp;image_data[..], 192, 192);
    println!(&quot;RUST: Loaded image in ... {:?}&quot;, start.elapsed());

    // Run the TFLite model using the WasmEdge Tensorflow API
    let mut session = wasmedge_tensorflow_interface::Session::new(&amp;model_data, wasmedge_tensorflow_interface::ModelType::TensorFlowLite);
    session.add_input(&quot;input&quot;, &amp;flat_img, &amp;[1, 192, 192, 3])
           .run();
    let res_vec: Vec&lt;u8&gt; = session.get_output(&quot;MobilenetV1/Predictions/Softmax&quot;);

    // Find the object index in res_vec that has the greatest probability
    // Translate the probability into a confidence level
    // Translate the object index into a label from the model meta data food_name
    let mut i = 0;
    let mut max_index: i32 = -1;
    let mut max_value: u8 = 0;
    while i &lt; res_vec.len() {
        let cur = res_vec[i];
        if cur &gt; max_value {
            max_value = cur;
            max_index = i as i32;
        }
        i += 1;
    }
    println!(&quot;RUST: index {}, prob {}&quot;, max_index, max_value);

    let confidence: String;
    if max_value &gt; 200 {
        confidence = &quot;is very likely&quot;.to_string();
    } else if max_value &gt; 125 {
        confidence = &quot;is likely&quot;.to_string();
    } else {
        confidence = &quot;could be&quot;.to_string();
    }

    let ret_str: String;
    if max_value &gt; 50 {
        let mut label_lines = labels.lines();
        for _i in 0..max_index {
            label_lines.next();
        }
        let food_name = label_lines.next().unwrap().to_string();
        ret_str = format!(
            &quot;It {} a &lt;a href='https://www.google.com/search?q={}'&gt;{}&lt;/a&gt; in the picture&quot;,
            confidence, food_name, food_name
        );
    } else {
        ret_str = &quot;It does not appears to be a food item in the picture.&quot;.to_string();
    }

    println!(
        &quot;RUST: Finished post-processing in ... {:?}&quot;,
        start.elapsed()
    );
    return Ok(ret_str.as_bytes().to_vec());
}
</code></pre>
<p>You should add <code>wasm32-wasi</code> target to rust to compile this function into WebAssembly bytecode. </p>
<pre><code>$ rustup target add wasm32-wasi

$ cd flow/rust_mobilenet_food
$ cargo build --target wasm32-wasi --release
# The output WASM will be target/wasm32-wasi/release/rust_mobilenet_food_lib.wasm

# Copy the wasm bytecode file to the flow/ directory
$ cp target/wasm32-wasi/release/rust_mobilenet_food_lib.wasm ../
</code></pre>
<p>To release the best performance of WasmEdge, you should enable the AOT mode by compiling the <code>.wasm</code> file to the <code>.so</code>.</p>
<pre><code>$ wasmedgec rust_mobilenet_food_lib.wasm rust_mobilenet_food_lib.so
</code></pre>
<h2 id="integration-with-yomo"><a class="header" href="#integration-with-yomo">Integration with YoMo</a></h2>
<p>On the YoMo side, we use the WasmEdge Golang API to start and run WasmEdge VM for the image classification function. The <a href="https://github.com/yomorun/yomo-wasmedge-tensorflow/blob/main/flow/app.go">app.go</a> file in the source code project is as follows. </p>
<pre><code>package main

import (
	&quot;crypto/sha1&quot;
	&quot;fmt&quot;
	&quot;log&quot;
	&quot;os&quot;
	&quot;sync/atomic&quot;

	&quot;github.com/second-state/WasmEdge-go/wasmedge&quot;
	bindgen &quot;github.com/second-state/wasmedge-bindgen/host/go&quot;
	&quot;github.com/yomorun/yomo&quot;
)

var (
	counter uint64
)

const ImageDataKey = 0x10

func main() {
	// Connect to Zipper service
	sfn := yomo.NewStreamFunction(&quot;image-recognition&quot;, yomo.WithZipperAddr(&quot;localhost:9900&quot;))
	defer sfn.Close()

	// set only monitoring data
	sfn.SetObserveDataID(ImageDataKey)

	// set handler
	sfn.SetHandler(Handler)

	// start
	err := sfn.Connect()
	if err != nil {
		log.Print(&quot;❌ Connect to zipper failure: &quot;, err)
		os.Exit(1)
	}

	select {}
}

// Handler process the data in the stream
func Handler(img []byte) (byte, []byte) {
	// Initialize WasmEdge's VM
	vmConf, vm := initVM()
	bg := bindgen.Instantiate(vm)
	defer bg.Release()
	defer vm.Release()
	defer vmConf.Release()

	// recognize the image
	res, err := bg.Execute(&quot;infer&quot;, img)
	if err == nil {
		fmt.Println(&quot;GO: Run bindgen -- infer:&quot;, string(res))
	} else {
		fmt.Println(&quot;GO: Run bindgen -- infer FAILED&quot;)
	}

	// print logs
	hash := genSha1(img)
	log.Printf(&quot;✅ received image-%d hash %v, img_size=%d \n&quot;, atomic.AddUint64(&amp;counter, 1), hash, len(img))

	return 0x11, nil
}

// genSha1 generate the hash value of the image
func genSha1(buf []byte) string {
	h := sha1.New()
	h.Write(buf)
	return fmt.Sprintf(&quot;%x&quot;, h.Sum(nil))
}

// initVM initialize WasmEdge's VM
func initVM() (*wasmedge.Configure, *wasmedge.VM) {
	wasmedge.SetLogErrorLevel()
	/// Set Tensorflow not to print debug info
	os.Setenv(&quot;TF_CPP_MIN_LOG_LEVEL&quot;, &quot;3&quot;)
	os.Setenv(&quot;TF_CPP_MIN_VLOG_LEVEL&quot;, &quot;3&quot;)

	/// Create configure
	vmConf := wasmedge.NewConfigure(wasmedge.WASI)

	/// Create VM with configure
	vm := wasmedge.NewVMWithConfig(vmConf)

	/// Init WASI
	var wasi = vm.GetImportObject(wasmedge.WASI)
	wasi.InitWasi(
		os.Args[1:],     /// The args
		os.Environ(),    /// The envs
		[]string{&quot;.:.&quot;}, /// The mapping directories
	)

	/// Register WasmEdge-tensorflow and WasmEdge-image
	var tfobj = wasmedge.NewTensorflowImportObject()
	var tfliteobj = wasmedge.NewTensorflowLiteImportObject()
	vm.RegisterImport(tfobj)
	vm.RegisterImport(tfliteobj)
	var imgobj = wasmedge.NewImageImportObject()
	vm.RegisterImport(imgobj)

	/// Instantiate wasm
	vm.LoadWasmFile(&quot;rust_mobilenet_food_lib.so&quot;)
	vm.Validate()

	return vmConf, vm
}
</code></pre>
<h2 id="in-action"><a class="header" href="#in-action">In action</a></h2>
<p>Finally, we can start YoMo and see the entire data processing pipeline in action. Start the YoMo CLI application from the project folder. The <a href="https://github.com/yomorun/yomo-wasmedge-tensorflow/blob/main/zipper/workflow.yaml">yaml file</a> defines port YoMo should listen on and the workflow handler to trigger for incoming data.  Note that the flow name <code>image-recognition</code> matches the name in the aforementioned data handler <a href="https://github.com/yomorun/yomo-wasmedge-tensorflow/blob/main/flow/app.go">app.go</a>.</p>
<pre><code>$ yomo serve -c ./zipper/workflow.yaml
</code></pre>
<p>Start the handler function by running the aforementioned <a href="https://github.com/yomorun/yomo-wasmedge-tensorflow/blob/main/flow/app.go">app.go</a> program. </p>
<pre><code>$ cd flow
$ go run --tags &quot;tensorflow image&quot; app.go
</code></pre>
<p><a href="https://github.com/yomorun/yomo-wasmedge-tensorflow/blob/main/source/main.go">Start a simulated data source</a> by sending a video to YoMo. The video is a series of image frames. The WasmEdge function in <a href="https://github.com/yomorun/yomo-wasmedge-tensorflow/blob/main/flow/app.go">app.go</a> will be invoked against every image frame in the video.</p>
<pre><code># Download a video file
$ wget -P source 'https://github.com/yomorun/yomo-wasmedge-tensorflow/releases/download/v0.1.0/hot-dog.mp4'

# Stream the video to YoMo
$ go run ./source/main.go ./source/hot-dog.mp4
</code></pre>
<p>You can see the output from the WasmEdge handler function in the console. It prints the names of the objects detected in each image frame in the video. </p>
<h2 id="whats-next"><a class="header" href="#whats-next">What's next</a></h2>
<p>In this article, we have seen how to use the WasmEdge Tensorflow API and Golang SDK in YoMo framework to process an image stream in near real-time.</p>
<p>In collaboration with YoMo, we will soon deploy WasmEdge in production in smart factories for a variety of assembly line tasks. WasmEdge is the software runtime for edge computing!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="reactr"><a class="header" href="#reactr">Reactr</a></h1>
<p><a href="https://github.com/suborbital/reactr">Reactr</a> is a fast, performant function scheduling library written in Go. Reactr is designed to be flexible, with the ability to run embedded in your Go applications and first-class support for WebAssembly.
Taking advantage of Go's superior concurrency capabilities, Reactr can manage
and execute hundreds of WebAssembly runtime instances all at once,
making a great framework for server-side applications.</p>
<p>Reactr allows you to run WebAssembly functions in Go. But so does the <a href="frameworks/app/../../embed/go.html">WasmEdge Go SDK</a>.
The unique feature of Reactr is that it provides a rich set of host functions
in Go, which support access to networks and databases etc. Reactr then provides
Rust (and Swift / AssemblyScript) APIs to call those host functions from 
within the WebAssembly function.</p>
<p>In this article, we will show you how to use WasmEdge together with Reactr
to take advantage of the best of both worlds. WasmEdge is the
<a href="frameworks/app/../../intro/features.html">fastest and most extensible WebAssembly runtime</a>.
It is also the fastest in <a href="https://github.com/suborbital/reactr/runs/4476074960?check_suite_focus=true">Reactr's official test suite</a>.
We will show you how to run Rust functions compiled to WebAssembly as well
as JavaScript programs in WasmEdge and Reactr.</p>
<blockquote>
<p>WasmEdge provides <a href="frameworks/app/../../dev/js.html">advanced support for JavaScript</a> including <a href="frameworks/app/../../dev/js/rust.html">mixing Rust with JavaScript</a> for improved performance.</p>
</blockquote>
<ul>
<li><a href="frameworks/app/reactr.html#hello-world">Hello world</a></li>
<li><a href="frameworks/app/reactr.html#database-query">Database query</a></li>
<li><a href="frameworks/app/reactr.html#embed-javascript-in-go">Embed JavaScript in Go</a></li>
</ul>
<h2 id="prerequisites-5"><a class="header" href="#prerequisites-5">Prerequisites</a></h2>
<p>You need have <a href="https://www.rust-lang.org/tools/install">Rust</a>, <a href="https://go.dev/doc/install">Go</a>, and <a href="frameworks/app/../../start/install.html">WasmEdge</a> installed on your system.
The GCC compiler (installed via the <code>build-essential</code> package) is also needed
for WasmEdge.</p>
<pre><code>$ sudo apt-get update
$ sudo apt-get -y upgrade
$ sudo apt install build-essential

$ curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh
$ source $HOME/.cargo/env
$ rustup target add wasm32-wasi

$ curl -OL https://golang.org/dl/go1.17.5.linux-amd64.tar.gz
$ sudo tar -C /usr/local -xvf go1.17.5.linux-amd64.tar.gz
$ export PATH=$PATH:/usr/local/go/bin

$ wget -qO- https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/utils/install.sh | bash
$ source $HOME/.wasmedge/env
</code></pre>
<h2 id="hello-world-4"><a class="header" href="#hello-world-4">Hello world</a></h2>
<p>A simple <code>hello world</code> example for Reactr is <a href="https://github.com/second-state/wasm-learning/tree/master/reactr/hello">available here</a>.</p>
<h3 id="rust-function-compiled-to-webassembly"><a class="header" href="#rust-function-compiled-to-webassembly">Rust function compiled to WebAssembly</a></h3>
<p>Let's first create <a href="https://github.com/second-state/wasm-learning/blob/master/reactr/hello/hello-echo/src/lib.rs">a simple Rust function</a> to echo hello.
The Rust function <code>HelloEcho::run()</code> is as follows. It will be exposed to the Go host
application through Reactr.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use suborbital::runnable::*;

struct HelloEcho{}

impl Runnable for HelloEcho {
    fn run(&amp;self, input: Vec&lt;u8&gt;) -&gt; Result&lt;Vec&lt;u8&gt;, RunErr&gt; {
        let in_string = String::from_utf8(input).unwrap();

    
        Ok(format!(&quot;hello {}&quot;, in_string).as_bytes().to_vec())
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Let's build the Rust function into a WebAssembly bytecode file.</p>
<pre><code class="language-bash">$ cd hello-echo
$ cargo build --target wasm32-wasi --release
$ cp target/wasm32-wasi/release/hello_echo.wasm ..
$ cd ..
</code></pre>
<h3 id="go-host-application-1"><a class="header" href="#go-host-application-1">Go host application</a></h3>
<p>Next, lets look into the <a href="https://github.com/second-state/wasm-learning/blob/master/reactr/hello/main.go">Go host app</a>
that executes the WebAssembly functions.
The <code>runBundle()</code> function executes the <code>run()</code> function in the
<code>Runnable</code> struct once.</p>
<pre><code class="language-go">func runBundle() {
	r := rt.New()
	doWasm := r.Register(&quot;hello-echo&quot;, rwasm.NewRunner(&quot;./hello_echo.wasm&quot;))

	res, err := doWasm([]byte(&quot;wasmWorker!&quot;)).Then()
	if err != nil {
		fmt.Println(err)
		return
	}

	fmt.Println(string(res.([]byte)))
}
</code></pre>
<p>The <code>runGroup()</code> function executes the Rust-compiled WebAssembly <code>run()</code> function
multiple times asynchronously in a group, and receives the results as they come
in.</p>
<pre><code class="language-go">func runGroup() {
	r := rt.New()

	doWasm := r.Register(&quot;hello-echo&quot;, rwasm.NewRunner(&quot;./hello_echo.wasm&quot;))

	grp := rt.NewGroup()
	for i := 0; i &lt; 100000; i++ {
		grp.Add(doWasm([]byte(fmt.Sprintf(&quot;world %d&quot;, i))))
	}

	if err := grp.Wait(); err != nil {
		fmt.Println(err)
	}
}
</code></pre>
<p>Finally, let's run the Go host application and see the results printed to the console.</p>
<blockquote>
<p>You must use the <code>-tags wasmedge</code> flag to take advantage of the performance
and extended WebAssembly APIs provided by WasmEdge.</p>
</blockquote>
<pre><code class="language-bash">$ go mod tidy
$ go run -tags wasmedge main.go
</code></pre>
<h2 id="database-query"><a class="header" href="#database-query">Database query</a></h2>
<p>In <a href="https://github.com/second-state/wasm-learning/tree/master/reactr/db">this example</a>,
we will demonstrate how to use Reactr host functions and APIs to query a 
PostgreSQL database from your WebAssembly function.</p>
<h3 id="install-and-set-up-a-postgresql-database"><a class="header" href="#install-and-set-up-a-postgresql-database">Install and set up a PostgreSQL database</a></h3>
<p>We will start a PostgreSQL instance through Docker.</p>
<pre><code class="language-bash">$ docker pull postgres
$ docker run --name reactr-postgres -p 5432:5432 -e POSTGRES_PASSWORD=12345 -d postgres
</code></pre>
<p>Next, let's create a database and populate it with some sample data.</p>
<pre><code class="language-bash">$ docker run -it --rm --network host postgres psql -h 127.0.0.1 -U postgres
postgres=# CREATE DATABASE reactr;
postgres=# \c reactr;

# Create a table:
postgres=# CREATE TABLE users (
    uuid        varchar(100) CONSTRAINT firstkey PRIMARY KEY,
    email       varchar(50) NOT NULL,
    created_at  date,
    state       char(1),
    identifier  integer
);
</code></pre>
<p>Leave this running and start another terminal window to interact with this PostgreSQL server.</p>
<h3 id="rust-function-compiled-to-webassembly-1"><a class="header" href="#rust-function-compiled-to-webassembly-1">Rust function compiled to WebAssembly</a></h3>
<p>Let's create <a href="https://github.com/second-state/wasm-learning/blob/master/reactr/db/rs-db/src/lib.rs">a Rust function</a> to access the PostgreSQL database.
The Rust function <code>RsDbtest::run()</code> is as follows. It will be exposed to the Go host
application through Reactr. It uses named queries such as <code>PGInsertUser</code> and <code>PGSelectUserWithUUID</code> to operate the database. Those queries are defined in the
Go host application, and we will see them later.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use suborbital::runnable::*;
use suborbital::db;
use suborbital::util;
use suborbital::db::query;
use suborbital::log;
use uuid::Uuid;

struct RsDbtest{}

impl Runnable for RsDbtest {
    fn run(&amp;self, _: Vec&lt;u8&gt;) -&gt; Result&lt;Vec&lt;u8&gt;, RunErr&gt; {
        let uuid = Uuid::new_v4().to_string();

        let mut args: Vec&lt;query::QueryArg&gt; = Vec::new();
        args.push(query::QueryArg::new(&quot;uuid&quot;, uuid.as_str()));
        args.push(query::QueryArg::new(&quot;email&quot;, &quot;connor@suborbital.dev&quot;));

        match db::insert(&quot;PGInsertUser&quot;, args) {
            Ok(_) =&gt; log::info(&quot;insert successful&quot;),
            Err(e) =&gt; {
                return Err(RunErr::new(500, e.message.as_str()))
            }
        };

        let mut args2: Vec&lt;query::QueryArg&gt; = Vec::new();
        args2.push(query::QueryArg::new(&quot;uuid&quot;, uuid.as_str()));

        match db::update(&quot;PGUpdateUserWithUUID&quot;, args2.clone()) {
            Ok(rows) =&gt; log::info(format!(&quot;update: {}&quot;, util::to_string(rows).as_str()).as_str()),
            Err(e) =&gt; {
                return Err(RunErr::new(500, e.message.as_str()))
            }
        }

        match db::select(&quot;PGSelectUserWithUUID&quot;, args2.clone()) {
            Ok(result) =&gt; log::info(format!(&quot;select: {}&quot;, util::to_string(result).as_str()).as_str()),
            Err(e) =&gt; {
                return Err(RunErr::new(500, e.message.as_str()))
            }
        }

        match db::delete(&quot;PGDeleteUserWithUUID&quot;, args2.clone()) {
            Ok(rows) =&gt; log::info(format!(&quot;delete: {}&quot;, util::to_string(rows).as_str()).as_str()),
            Err(e) =&gt; {
                return Err(RunErr::new(500, e.message.as_str()))
            }
        }

        ... ...
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Let's build the Rust function into a WebAssembly bytecode file.</p>
<pre><code class="language-bash">$ cd rs-db
$ cargo build --target wasm32-wasi --release
$ cp target/wasm32-wasi/release/rs_db.wasm ..
$ cd ..
</code></pre>
<h3 id="go-host-application-2"><a class="header" href="#go-host-application-2">Go host application</a></h3>
<p>The <a href="https://github.com/second-state/wasm-learning/blob/master/reactr/db/main.go">Go host app</a>
first defines the SQL queries and gives each of them a name.
We will then pass those queries to the Reactr runtime as a configuration.</p>
<pre><code class="language-go">func main() {
	dbConnString, exists := os.LookupEnv(&quot;REACTR_DB_CONN_STRING&quot;)
	if !exists {
		fmt.Println(&quot;skipping as conn string env var not set&quot;)
		return
	}

	q1 := rcap.Query{
		Type:     rcap.QueryTypeInsert,
		Name:     &quot;PGInsertUser&quot;,
		VarCount: 2,
		Query: `
		INSERT INTO users (uuid, email, created_at, state, identifier)
		VALUES ($1, $2, NOW(), 'A', 12345)`,
	}

	q2 := rcap.Query{
		Type:     rcap.QueryTypeSelect,
		Name:     &quot;PGSelectUserWithUUID&quot;,
		VarCount: 1,
		Query: `
		SELECT * FROM users
		WHERE uuid = $1`,
	}

	q3 := rcap.Query{
		Type:     rcap.QueryTypeUpdate,
		Name:     &quot;PGUpdateUserWithUUID&quot;,
		VarCount: 1,
		Query: `
		UPDATE users SET state='B' WHERE uuid = $1`,
	}

	q4 := rcap.Query{
		Type:     rcap.QueryTypeDelete,
		Name:     &quot;PGDeleteUserWithUUID&quot;,
		VarCount: 1,
		Query: `
		DELETE FROM users WHERE uuid = $1`,
	}

	config := rcap.DefaultConfigWithDB(vlog.Default(), rcap.DBTypePostgres, dbConnString, []rcap.Query{q1, q2, q3, q4})

	r, err := rt.NewWithConfig(config)
	if err != nil {
		fmt.Println(err)
		return
	}

	... ...
}
</code></pre>
<p>Then, we can run the WebAssembly function from Reactr.</p>
<pre><code class="language-go">func main() {
	... ...

	doWasm := r.Register(&quot;rs-db&quot;, rwasm.NewRunner(&quot;./rs_db.wasm&quot;))

	res, err := doWasm(nil).Then()
	if err != nil {
		fmt.Println(err)
		return
	}

	fmt.Println(string(res.([]byte)))
}
</code></pre>
<p>Finally, let's run the Go host application and see the results printed to the console.</p>
<blockquote>
<p>You must use the <code>-tags wasmedge</code> flag to take advantage of the performance
and extended WebAssembly APIs provided by WasmEdge.</p>
</blockquote>
<pre><code class="language-bash">$ export REACTR_DB_CONN_STRING='postgresql://postgres:12345@127.0.0.1:5432/reactr'
$ go mod tidy
$ go run -tags wasmedge main.go
</code></pre>
<h2 id="embed-javascript-in-go"><a class="header" href="#embed-javascript-in-go">Embed JavaScript in Go</a></h2>
<p>As we mentioned, a key feature of the WasmEdge Runtime is its advanced
<a href="frameworks/app/../../dev/js.html">JavaScript support</a>, which allows JavaScript programs to run in lightweight,
high-performance, safe, multi-language, and <a href="frameworks/app/../../kubernetes.html">Kubernetes-managed WasmEdge containers</a>.
A simple example of embedded JavaScript function in Reactr is <a href="https://github.com/second-state/wasm-learning/tree/master/reactr/quickjs">available here</a>.</p>
<h3 id="javascript-example"><a class="header" href="#javascript-example">JavaScript example</a></h3>
<p>The <a href="https://github.com/second-state/wasm-learning/tree/master/reactr/quickjs/hello.js">JavaScript example function</a> is very simple. It just returns a string value.</p>
<pre><code class="language-javascript">let h = 'hello';
let w = 'wasmedge';
`${h} ${w}`;
</code></pre>
<h3 id="go-host-application-3"><a class="header" href="#go-host-application-3">Go host application</a></h3>
<p>The <a href="https://github.com/second-state/wasm-learning/tree/master/reactr/quickjs/main.go">Go host app</a> uses the Reactr API to run WasmEdge's standard JavaScript
interpreter <a href="https://github.com/second-state/wasm-learning/blob/master/reactr/quickjs/rs_embed_js.wasm">rs_embed_js.wasm</a>. You can build your own version of 
JavaScript interpreter by modifying <a href="https://github.com/second-state/wasm-learning/tree/master/reactr/quickjs/rs-embed-js">this Rust project</a>.</p>
<blockquote>
<p>Learn more about how to embed <a href="https://github.com/second-state/wasmedge-quickjs/tree/main/examples/embed_js">JavaScript code in Rust</a>, and how to <a href="frameworks/app/../../dev/js/rust.html">use Rust to implement JavaScript APIs</a> in WasmEdge.</p>
</blockquote>
<p>The Go host application just need to start the job for <code>rs_embed_js.wasm</code> and pass the JavaScript content to it. The Go application can then capture and print the return value from JavaScript.</p>
<pre><code class="language-go">func main() {
	r := rt.New()
	doWasm := r.Register(&quot;hello-quickjs&quot;, rwasm.NewRunner(&quot;./rs_embed_js.wasm&quot;))

	code, err := ioutil.ReadFile(os.Args[1])
	if err != nil {
		fmt.Print(err)
	}
	res, err := doWasm(code).Then()
	if err != nil {
		fmt.Println(err)
		return
	}

	fmt.Println(string(res.([]byte)))
}
</code></pre>
<p>Run the Go host application as follows.</p>
<pre><code class="language-bash">$ cd quickjs
$ go mod tidy
$ go run -tags wasmedge main.go hello.js
String(JsString(hello wasmedge))
</code></pre>
<p>The printed result shows the type information of the string in Rust and Go APIs. You can strip out this information by changing the Rust or Go applications.</p>
<h3 id="feature-examples"><a class="header" href="#feature-examples">Feature examples</a></h3>
<p>WasmEdge supports many advanced JavaScript features. For the next step, you
could try our <a href="https://github.com/second-state/wasmedge-quickjs/tree/main/example_js/react_ssr">React SSR example</a> to generate an HTML UI from a Reactr function!
You can just build the <code>dist/main.js</code> from the React SSR example, and copy
it over to this example folder to see it in action!</p>
<pre><code class="language-bash">$ cd quickjs
# copy over the dist/main.js file from the react ssr example
$ go mod tidy
$ go run -tags wasmedge main.go main.js
&lt;div data-reactroot=&quot;&quot;&gt;&lt;div&gt;This is home&lt;/div&gt;&lt;div&gt;&lt;div&gt;This is page&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;
UnDefined
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="serverless-platforms"><a class="header" href="#serverless-platforms">Serverless platforms</a></h1>
<p>Our vision for the future is to run WebAssembly as an alternative lightweight runtime side-by-side with Docker and microVMs in cloud native infrastructure. WebAssembly offers much higher performance and consumes much less resources than Docker-like containers or microVMs. However, the public cloud only supports running WebAssembly inside a microVM. Nonetheless, running WebAssembly functions inside a microVM still offers many advantages over running containerized NaCl programs.</p>
<p>Running WebAssembly functions inside Docker-like containers offer advantages over running NaCl programs directly in Docker.</p>
<p>For starters, WebAssembly provides fine-grained runtime isolation for individual functions. A microservice could have multiple functions and support services running inside a Docker-like container. WebAssembly can make the microservice more secure and more stable.</p>
<p>Second, the WebAssembly bytecode is portable. Developers only need to build it once and do not need to worry about changes or updates to the underlying Vercel serverless container (OS and hardware). It also allows developers to reuse the same WebAssembly functions in other cloud environments.</p>
<p>Third, WebAssembly apps are easy to deploy and manage. They have much less platform dependencies and complexities compared with NaCl dynamic libraries and executables.</p>
<p>Finally, the <a href="https://www.secondstate.io/articles/wasi-tensorflow/">WasmEdge Tensorflow API</a> provides the most ergonomic way to execute Tensorflow models in the Rust programming language. WasmEdge installs the correct combination of Tensorflow dependency libraries, and provides a unified API for developers.</p>
<p>In this section, we will show you how to run WebAssembly serverless functions in public clouds. Each platform has its own code template and contains two examples in Rust, one is the normal image processing, The other one is TensorFlow inference using the WasmEdge TensorFlow SDK.</p>
<ul>
<li><a href="frameworks/serverless/vercel.html">Vercel</a> discuss how to leverage WasmEdge to accelerate the Jamstack application deployed on Vercel.</li>
<li><a href="frameworks/serverless/netlify.html">Netlify</a> discuss how to leverage WasmEdge to accelerate the Jamstack application deployed on Netlify.</li>
<li><a href="frameworks/serverless/aws.html">AWS Lambda</a> discuss how to leverage WasmEdge to accelerate the serverless functions deployed on AWS Lambda.</li>
<li><a href="frameworks/serverless/tencent.html">Tencent</a> discuss how to leverage WasmEdge to accelerate the serverless functions deployed on Tencent cloud.</li>
</ul>
<blockquote>
<p>If you would like to add more WasmEdge examples on public cloud platform,like Google Cloud Functions, feel free to create a PR for WasmEdge and let the community know what you did.</p>
</blockquote>
<p><img src="frameworks/serverless-wasmedge.png" alt="" /></p>
<p>Running WasmEdge from Docker containers deployed on public cloud is an easy way to add high-performance functions to web applications. Going forward an even better approach is to use <a href="https://www.computer.org/csdl/magazine/so/5555/01/09214403/1nHNGfu2Ypi">WasmEdge as the container itself</a>. There will be no Docker and no Node.js to bootstrap WasmEdge. This way, we can reach much higher efficiency for running serverless functions.</p>
<ul>
<li><a href="frameworks/serverless/secondstate.html">Second State Functions</a> will discuss how to use WasmEdge ad the container itself, since Second State Functions is a serverless platform with pure WebAssembly/WasmEdge. </li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rust-and-webassembly-serverless-functions-in-vercel"><a class="header" href="#rust-and-webassembly-serverless-functions-in-vercel">Rust and WebAssembly Serverless functions in Vercel</a></h1>
<p>In this article, we will show you two serverless functions in Rust and WasmEdge deployed on Vercel. One is the image processing function, the other one is the TensorFlow inference function.</p>
<blockquote>
<p>For more insights on why WasmEdge on Vercel, please refer to the article <a href="https://www.secondstate.io/articles/vercel-wasmedge-webassembly-rust/">Rust and WebAssembly Serverless Functions in Vercel</a>.</p>
</blockquote>
<h2 id="prerequisite-2"><a class="header" href="#prerequisite-2">Prerequisite</a></h2>
<p>Since our demo WebAssembly functions are written in Rust, you will need a <a href="https://www.rust-lang.org/tools/install">Rust compiler</a>. Make sure that you install the <code>wasm32-wasi</code> compiler target as follows, in order to generate WebAssembly bytecode.</p>
<pre><code>$ rustup target add wasm32-wasi
</code></pre>
<p>The demo application front end is written in <a href="https://nextjs.org/">Next.js</a>, and deployed on Vercel. We will assume that you already have the basic knowledge of how to work with Vercel.</p>
<h2 id="example-1-image-processing"><a class="header" href="#example-1-image-processing">Example 1: Image processing</a></h2>
<p>Our first demo application allows users to upload an image and then invoke a serverless function to turn it into black and white. A <a href="https://vercel-wasm-runtime.vercel.app/">live demo</a> deployed on Vercel is available.</p>
<p>Fork the <a href="https://github.com/second-state/vercel-wasm-runtime">demo application’s GitHub repo</a> to get started. To deploy the application on Vercel, just <a href="https://vercel.com/docs/git#deploying-a-git-repository">import the Github repo</a> from <a href="https://vercel.com/docs/git/vercel-for-github">Vercel for Github</a> web page.</p>
<p>This repo is a standard Next.js application for the Vercel platform. The backend serverless function is in the <a href="https://github.com/second-state/vercel-wasm-runtime/tree/main/api/functions/image-grayscale"><code>api/functions/image_grayscale</code></a> folder. The <a href="https://github.com/second-state/vercel-wasm-runtime/blob/main/api/functions/image-grayscale/src/main.rs"><code>src/main.rs</code></a> file contains the Rust program’s source code. The Rust program reads image data from the <code>STDIN</code>, and then outputs the black-white image to the <code>STDOUT</code>.</p>
<pre><code>use hex;
use std::io::{self, Read};
use image::{ImageOutputFormat, ImageFormat};

fn main() {
  let mut buf = Vec::new();
  io::stdin().read_to_end(&amp;mut buf).unwrap();

  let image_format_detected: ImageFormat = image::guess_format(&amp;buf).unwrap();
  let img = image::load_from_memory(&amp;buf).unwrap();
  let filtered = img.grayscale();
  let mut buf = vec![];
  match image_format_detected {
    ImageFormat::Gif =&gt; {
        filtered.write_to(&amp;mut buf, ImageOutputFormat::Gif).unwrap();
    },
    _ =&gt; {
        filtered.write_to(&amp;mut buf, ImageOutputFormat::Png).unwrap();
    },
  };
  io::stdout().write_all(&amp;buf).unwrap();
  io::stdout().flush().unwrap();
}
</code></pre>
<p>You can use Rust’s <code>cargo</code> tool to build the Rust program into WebAssembly bytecode or native code. </p>
<pre><code>$ cd api/functions/image-grayscale/
$ cargo build --release --target wasm32-wasi 
</code></pre>
<p>Copy the build artifacts to the <code>api</code> folder. </p>
<pre><code>$ cp target/wasm32-wasi/release/grayscale.wasm ../../
</code></pre>
<blockquote>
<p>Vercel runs <a href="https://github.com/second-state/vercel-wasm-runtime/blob/main/api/pre.sh"><code>api/pre.sh</code></a> upon setting up the serverless environment. It installs the WasmEdge runtime, and then compiles each WebAssembly bytecode program into a native <code>so</code> library for faster execution. </p>
</blockquote>
<p>The <a href="https://github.com/second-state/vercel-wasm-runtime/blob/main/api/hello.js"><code>api/hello.js</code></a> file conforms Vercel serverless specification. It loads the WasmEdge runtime, starts the compiled WebAssembly program in WasmEdge, and passes the uploaded image data via <code>STDIN</code>. Notice <a href="https://github.com/second-state/vercel-wasm-runtime/blob/main/api/hello.js"><code>api/hello.js</code></a> runs the compiled <code>grayscale.so</code> file generated by <a href="https://github.com/second-state/vercel-wasm-runtime/blob/main/api/pre.sh"><code>api/pre.sh</code></a> for better performance.</p>
<pre><code>const fs = require('fs');
const { spawn } = require('child_process');
const path = require('path');

module.exports = (req, res) =&gt; {
  const wasmedge = spawn(
      path.join(__dirname, 'wasmedge'), 
      [path.join(__dirname, 'grayscale.so')]);

  let d = [];
  wasmedge.stdout.on('data', (data) =&gt; {
    d.push(data);
  });

  wasmedge.on('close', (code) =&gt; {
    let buf = Buffer.concat(d);

    res.setHeader('Content-Type', req.headers['image-type']);
    res.send(buf);
  });

  wasmedge.stdin.write(req.body);
  wasmedge.stdin.end('');
}
</code></pre>
<p>That's it. <a href="https://vercel.com/docs/git#deploying-a-git-repository">Deploy the repo to Vercel</a> and you now have a Vercel Jamstack app with a high-performance Rust and WebAssembly based serverless backend. </p>
<h2 id="example-2-ai-inference"><a class="header" href="#example-2-ai-inference">Example 2: AI inference</a></h2>
<p>The <a href="https://vercel-wasm-runtime-cozpr5z84-wangshishuo1.vercel.app/">second demo</a> application allows users to upload an image and then invoke a serverless function to classify the main subject on the image.</p>
<p>It is in <a href="https://github.com/second-state/vercel-wasm-runtime">the same GitHub repo</a> as the previous example but in the <code>tensorflow</code> branch. Note: when you <a href="https://vercel.com/docs/git#deploying-a-git-repository">import this GitHub repo</a> on the Vercel website, it will create a <a href="https://vercel.com/docs/platform/deployments#preview">preview URL</a> for each branch. The <code>tensorflow</code> branch would have its own deployment URL.</p>
<p>The backend serverless function for image classification is in the <a href="https://github.com/second-state/vercel-wasm-runtime/tree/tensorflow/api/functions/image-classification"><code>api/functions/image-classification</code></a> folder in the <code>tensorflow</code> branch.  The <a href="https://github.com/second-state/vercel-wasm-runtime/blob/tensorflow/api/functions/image-classification/src/main.rs"><code>src/main.rs</code></a> file contains the Rust program’s source code. The Rust program reads image data from the <code>STDIN</code>, and then outputs the text output to the <code>STDOUT</code>. It utilizes the WasmEdge Tensorflow API to run the AI inference. </p>
<pre><code>pub fn main() {
    // Step 1: Load the TFLite model
    let model_data: &amp;[u8] = include_bytes!(&quot;models/mobilenet_v1_1.0_224/mobilenet_v1_1.0_224_quant.tflite&quot;);
    let labels = include_str!(&quot;models/mobilenet_v1_1.0_224/labels_mobilenet_quant_v1_224.txt&quot;);

    // Step 2: Read image from STDIN
    let mut buf = Vec::new();
    io::stdin().read_to_end(&amp;mut buf).unwrap();

    // Step 3: Resize the input image for the tensorflow model
    let flat_img = wasmedge_tensorflow_interface::load_jpg_image_to_rgb8(&amp;buf, 224, 224);

    // Step 4: AI inference
    let mut session = wasmedge_tensorflow_interface::Session::new(&amp;model_data, wasmedge_tensorflow_interface::ModelType::TensorFlowLite);
    session.add_input(&quot;input&quot;, &amp;flat_img, &amp;[1, 224, 224, 3])
           .run();
    let res_vec: Vec&lt;u8&gt; = session.get_output(&quot;MobilenetV1/Predictions/Reshape_1&quot;);

    // Step 5: Find the food label that responds to the highest probability in res_vec
    // ... ...
    let mut label_lines = labels.lines();
    for _i in 0..max_index {
      label_lines.next();
    }

    // Step 6: Generate the output text
    let class_name = label_lines.next().unwrap().to_string();
    if max_value &gt; 50 {
      println!(&quot;It {} a &lt;a href='https://www.google.com/search?q={}'&gt;{}&lt;/a&gt; in the picture&quot;, confidence.to_string(), class_name, class_name);
    } else {
      println!(&quot;It does not appears to be any food item in the picture.&quot;);
    }
}
</code></pre>
<p>You can use the <code>cargo</code> tool to build the Rust program into WebAssembly bytecode or native code. </p>
<pre><code>$ cd api/functions/image-classification/
$ cargo build --release --target wasm32-wasi
</code></pre>
<p>Copy the build artifacts to the <code>api</code> folder. </p>
<pre><code>$ cp target/wasm32-wasi/release/classify.wasm ../../
</code></pre>
<p>Again, the <a href="https://github.com/second-state/vercel-wasm-runtime/blob/tensorflow/api/pre.sh"><code>api/pre.sh</code></a> script installs WasmEdge runtime and its Tensorflow dependencies in this application. It also compiles the <code>classify.wasm</code> bytecode program to the <code>classify.so</code> native shared library at the time of deployment.</p>
<p>The <a href="https://github.com/second-state/vercel-wasm-runtime/blob/tensorflow/api/hello.js"><code>api/hello.js</code></a> file conforms Vercel serverless specification. It loads the WasmEdge runtime, starts the compiled WebAssembly program in WasmEdge, and passes the uploaded image data via <code>STDIN</code>. Notice <a href="https://github.com/second-state/vercel-wasm-runtime/blob/tensorflow/api/hello.js"><code>api/hello.js</code></a> runs the compiled <code>classify.so</code> file generated by <a href="https://github.com/second-state/vercel-wasm-runtime/blob/tensorflow/api/pre.sh"><code>api/pre.sh</code></a> for better performance.</p>
<pre><code>const fs = require('fs');
const { spawn } = require('child_process');
const path = require('path');

module.exports = (req, res) =&gt; {
  const wasmedge = spawn(
    path.join(__dirname, 'wasmedge-tensorflow-lite'),
    [path.join(__dirname, 'classify.so')],
    {env: {'LD_LIBRARY_PATH': __dirname}}
  );

  let d = [];
  wasmedge.stdout.on('data', (data) =&gt; {
    d.push(data);
  });

  wasmedge.on('close', (code) =&gt; {
    res.setHeader('Content-Type', `text/plain`);
    res.send(d.join(''));
  });

  wasmedge.stdin.write(req.body);
  wasmedge.stdin.end('');
}
</code></pre>
<p>You can now <a href="https://vercel.com/docs/git#deploying-a-git-repository">deploy your forked repo to Vercel</a> and have a web app for subject classification.</p>
<p>Next, it's your turn to use <a href="https://github.com/second-state/vercel-wasm-runtime">the vercel-wasm-runtime repo</a> as a template to develop your own Rust serverless functions in Vercel. Looking forward to your great work.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="webassembly-serverless-functions-in-netlify"><a class="header" href="#webassembly-serverless-functions-in-netlify">WebAssembly Serverless Functions in Netlify</a></h1>
<p>In this article we will show you two serverless functions in Rust and WasmEdge deployed on Netlify. One is the image processing function, the other one is the TensorFlow inference function.</p>
<blockquote>
<p>For more insights on why WasmEdge on Netlify, please refer to the article <a href="https://www.secondstate.io/articles/netlify-wasmedge-webassembly-rust-serverless/">WebAssembly Serverless Functions in Netlify</a>.</p>
</blockquote>
<h2 id="prerequisite-3"><a class="header" href="#prerequisite-3">Prerequisite</a></h2>
<p>Since our demo WebAssembly functions are written in Rust, you will need a <a href="https://www.rust-lang.org/tools/install">Rust compiler</a>. Make sure that you install the <code>wasm32-wasi</code> compiler target as follows, in order to generate WebAssembly bytecode.</p>
<pre><code>$ rustup target add wasm32-wasi
</code></pre>
<p>The demo application front end is written in <a href="https://nextjs.org/">Next.js</a>, and deployed on Netlify. We will assume that you already have the basic knowledge of how to work with Next.js and Netlify.</p>
<h2 id="example-1-image-processing-1"><a class="header" href="#example-1-image-processing-1">Example 1: Image processing</a></h2>
<p>Our first demo application allows users to upload an image and then invoke a serverless function to turn it into black and white. A <a href="https://60fe22f9ff623f0007656040--reverent-hodgkin-dc1f51.netlify.app/">live demo</a> deployed on Netlify is available.</p>
<p>Fork the <a href="https://github.com/second-state/netlify-wasm-runtime">demo application’s GitHub repo</a> to get started. To deploy the application on Netlify, just <a href="https://www.netlify.com/blog/2016/09/29/a-step-by-step-guide-deploying-on-netlify/">add your github repo to Netlify</a>.</p>
<p>This repo is a standard Next.js application for the Netlify platform. The backend serverless function is in the <a href="https://github.com/second-state/netlify-wasm-runtime/tree/main/api/functions/image-grayscale"><code>api/functions/image_grayscale</code></a> folder. The <a href="https://github.com/second-state/netlify-wasm-runtime/blob/main/api/functions/image-grayscale/src/main.rs"><code>src/main.rs</code></a> file contains the Rust program’s source code. The Rust program reads image data from the <code>STDIN</code>, and then outputs the black-white image to the <code>STDOUT</code>.</p>
<pre><code>use hex;
use std::io::{self, Read};
use image::{ImageOutputFormat, ImageFormat};

fn main() {
  let mut buf = Vec::new();
  io::stdin().read_to_end(&amp;mut buf).unwrap();

  let image_format_detected: ImageFormat = image::guess_format(&amp;buf).unwrap();
  let img = image::load_from_memory(&amp;buf).unwrap();
  let filtered = img.grayscale();
  let mut buf = vec![];
  match image_format_detected {
    ImageFormat::Gif =&gt; {
        filtered.write_to(&amp;mut buf, ImageOutputFormat::Gif).unwrap();
    },
    _ =&gt; {
        filtered.write_to(&amp;mut buf, ImageOutputFormat::Png).unwrap();
    },
  };
  io::stdout().write_all(&amp;buf).unwrap();
  io::stdout().flush().unwrap();
}
</code></pre>
<p>You can use Rust’s <code>cargo</code> tool to build the Rust program into WebAssembly bytecode or native code. </p>
<pre><code>$ cd api/functions/image-grayscale/
$ cargo build --release --target wasm32-wasi 
</code></pre>
<p>Copy the build artifacts to the <code>api</code> folder. </p>
<pre><code>$ cp target/wasm32-wasi/release/grayscale.wasm ../../
</code></pre>
<blockquote>
<p>The Netlify function runs <a href="https://github.com/second-state/netlify-wasm-runtime/blob/main/api/pre.sh"><code>api/pre.sh</code></a> upon setting up the serverless environment. It installs the WasmEdge runtime, and then compiles each WebAssembly bytecode program into a native <code>so</code> library for faster execution. </p>
</blockquote>
<p>The <a href="https://github.com/second-state/netlify-wasm-runtime/blob/main/api/hello.js"><code>api/hello.js</code></a> script loads the WasmEdge runtime, starts the compiled WebAssembly program in WasmEdge, and passes the uploaded image data via <code>STDIN</code>. Notice <a href="https://github.com/second-state/netlify-wasm-runtime/blob/main/api/hello.js"><code>api/hello.js</code></a> runs the compiled <code>grayscale.so</code> file generated by <a href="https://github.com/second-state/netlify-wasm-runtime/blob/main/api/pre.sh"><code>api/pre.sh</code></a> for better performance.</p>
<pre><code>const fs = require('fs');
const { spawn } = require('child_process');
const path = require('path');

module.exports = (req, res) =&gt; {
  const wasmedge = spawn(
      path.join(__dirname, 'wasmedge'), 
      [path.join(__dirname, 'grayscale.so')]);

  let d = [];
  wasmedge.stdout.on('data', (data) =&gt; {
    d.push(data);
  });

  wasmedge.on('close', (code) =&gt; {
    let buf = Buffer.concat(d);

    res.setHeader('Content-Type', req.headers['image-type']);
    res.send(buf);
  });

  wasmedge.stdin.write(req.body);
  wasmedge.stdin.end('');
}
</code></pre>
<p>That's it. <a href="https://www.netlify.com/blog/2016/09/29/a-step-by-step-guide-deploying-on-netlify/">Deploy the repo to Netlify</a> and you now have a Netlify Jamstack app with a high-performance Rust and WebAssembly based serverless backend. </p>
<h2 id="example-2-ai-inference-1"><a class="header" href="#example-2-ai-inference-1">Example 2: AI inference</a></h2>
<p>The <a href="https://60ff7e2d10fe590008db70a9--reverent-hodgkin-dc1f51.netlify.app/">second demo</a> application allows users to upload an image and then invoke a serverless function to classify the main subject on the image.</p>
<p>It is in <a href="https://github.com/second-state/netlify-wasm-runtime/tree/tensorflow">the same GitHub repo</a> as the previous example but in the <code>tensorflow</code> branch. The backend serverless function for image classification is in the <a href="https://github.com/second-state/netlify-wasm-runtime/tree/tensorflow/api/functions/image-classification"><code>api/functions/image-classification</code></a> folder in the <code>tensorflow</code> branch.  The <a href="https://github.com/second-state/netlify-wasm-runtime/blob/tensorflow/api/functions/image-classification/src/main.rs"><code>src/main.rs</code></a> file contains the Rust program’s source code. The Rust program reads image data from the <code>STDIN</code>, and then outputs the text output to the <code>STDOUT</code>. It utilizes the WasmEdge Tensorflow API to run the AI inference. </p>
<pre><code>pub fn main() {
    // Step 1: Load the TFLite model
    let model_data: &amp;[u8] = include_bytes!(&quot;models/mobilenet_v1_1.0_224/mobilenet_v1_1.0_224_quant.tflite&quot;);
    let labels = include_str!(&quot;models/mobilenet_v1_1.0_224/labels_mobilenet_quant_v1_224.txt&quot;);

    // Step 2: Read image from STDIN
    let mut buf = Vec::new();
    io::stdin().read_to_end(&amp;mut buf).unwrap();

    // Step 3: Resize the input image for the tensorflow model
    let flat_img = wasmedge_tensorflow_interface::load_jpg_image_to_rgb8(&amp;buf, 224, 224);

    // Step 4: AI inference
    let mut session = wasmedge_tensorflow_interface::Session::new(&amp;model_data, wasmedge_tensorflow_interface::ModelType::TensorFlowLite);
    session.add_input(&quot;input&quot;, &amp;flat_img, &amp;[1, 224, 224, 3])
           .run();
    let res_vec: Vec&lt;u8&gt; = session.get_output(&quot;MobilenetV1/Predictions/Reshape_1&quot;);

    // Step 5: Find the food label that responds to the highest probability in res_vec
    // ... ...
    let mut label_lines = labels.lines();
    for _i in 0..max_index {
      label_lines.next();
    }

    // Step 6: Generate the output text
    let class_name = label_lines.next().unwrap().to_string();
    if max_value &gt; 50 {
      println!(&quot;It {} a &lt;a href='https://www.google.com/search?q={}'&gt;{}&lt;/a&gt; in the picture&quot;, confidence.to_string(), class_name, class_name);
    } else {
      println!(&quot;It does not appears to be any food item in the picture.&quot;);
    }
}
</code></pre>
<p>You can use the <code>cargo</code> tool to build the Rust program into WebAssembly bytecode or native code. </p>
<pre><code>$ cd api/functions/image-classification/
$ cargo build --release --target wasm32-wasi
</code></pre>
<p>Copy the build artifacts to the <code>api</code> folder. </p>
<pre><code>$ cp target/wasm32-wasi/release/classify.wasm ../../
</code></pre>
<p>Again, the <a href="https://github.com/second-state/netlify-wasm-runtime/blob/tensorflow/api/pre.sh"><code>api/pre.sh</code></a> script installs WasmEdge runtime and its Tensorflow dependencies in this application. It also compiles the <code>classify.wasm</code> bytecode program to the <code>classify.so</code> native shared library at the time of deployment.</p>
<p>The <a href="https://github.com/second-state/netlify-wasm-runtime/blob/tensorflow/api/hello.js"><code>api/hello.js</code></a> script loads the WasmEdge runtime, starts the compiled WebAssembly program in WasmEdge, and passes the uploaded image data via <code>STDIN</code>. Notice <a href="https://github.com/second-state/netlify-wasm-runtime/blob/tensorflow/api/hello.js"><code>api/hello.js</code></a> runs the compiled <code>classify.so</code> file generated by <a href="https://github.com/second-state/netlify-wasm-runtime/blob/tensorflow/api/pre.sh"><code>api/pre.sh</code></a> for better performance.</p>
<pre><code>const fs = require('fs');
const { spawn } = require('child_process');
const path = require('path');

module.exports = (req, res) =&gt; {
  const wasmedge = spawn(
    path.join(__dirname, 'wasmedge-tensorflow-lite'),
    [path.join(__dirname, 'classify.so')],
    {env: {'LD_LIBRARY_PATH': __dirname}}
  );

  let d = [];
  wasmedge.stdout.on('data', (data) =&gt; {
    d.push(data);
  });

  wasmedge.on('close', (code) =&gt; {
    res.setHeader('Content-Type', `text/plain`);
    res.send(d.join(''));
  });

  wasmedge.stdin.write(req.body);
  wasmedge.stdin.end('');
}
</code></pre>
<p>You can now <a href="https://www.netlify.com/blog/2016/09/29/a-step-by-step-guide-deploying-on-netlify/">deploy your forked repo to Netlify</a> and have a web app for subject classification.</p>
<p>Next, it's your turn to develop Rust serverless functions in Netlify using the <a href="https://github.com/second-state/netlify-wasm-runtime">netlify-wasm-runtime repo</a> as a template. Looking forward to your great work.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="webassembly-serverless-functions-in-aws-lambda"><a class="header" href="#webassembly-serverless-functions-in-aws-lambda">WebAssembly Serverless Functions in AWS Lambda</a></h1>
<p>In this article, we will show you two serverless functions in Rust and WasmEdge deployed on AWS Lambda. One is the image processing function, the other one is the TensorFlow inference function.</p>
<blockquote>
<p>For the insight on why WasmEdge on AWS Lambda, please refer to the article <a href="https://www.secondstate.io/articles/webassembly-serverless-functions-in-aws-lambda/">WebAssembly Serverless Functions in AWS Lambda</a></p>
</blockquote>
<h2 id="prerequisites-6"><a class="header" href="#prerequisites-6">Prerequisites</a></h2>
<p>Since our demo WebAssembly functions are written in Rust, you will need a <a href="https://www.rust-lang.org/tools/install">Rust compiler</a>. Make sure that you install the <code>wasm32-wasi</code> compiler target as follows, in order to generate WebAssembly bytecode.</p>
<pre><code>$ rustup target add wasm32-wasi
</code></pre>
<p>The demo application front end is written in <a href="https://nextjs.org/">Next.js</a>, and deployed on AWS Lambda. We will assume that you already have the basic knowledge of how to work with Next.js and Lambda.</p>
<h2 id="example-1-image-processing-2"><a class="header" href="#example-1-image-processing-2">Example 1: Image processing</a></h2>
<p>Our first demo application allows users to upload an image and then invoke a serverless function to turn it into black and white. A <a href="https://second-state.github.io/aws-lambda-wasm-runtime/">live demo</a> deployed through GitHub Pages is available.</p>
<p>Fork the <a href="https://github.com/second-state/aws-lambda-wasm-runtime">demo application’s GitHub repo</a> to get started. To deploy the application on AWS Lambda, follow the guide in the repository <a href="https://github.com/second-state/aws-lambda-wasm-runtime/blob/tensorflow/README.md">README</a>.</p>
<h3 id="create-the-function"><a class="header" href="#create-the-function">Create the function</a></h3>
<p>This repo is a standard Next.js application. The backend serverless function is in the <code>api/functions/image_grayscale</code> folder. The <code>src/main.rs</code> file contains the Rust program’s source code. The Rust program reads image data from the <code>STDIN</code>, and then outputs the black-white image to the <code>STDOUT</code>.</p>
<pre><code>use hex;
use std::io::{self, Read};
use image::{ImageOutputFormat, ImageFormat};

fn main() {
  let mut buf = Vec::new();
  io::stdin().read_to_end(&amp;mut buf).unwrap();

  let image_format_detected: ImageFormat = image::guess_format(&amp;buf).unwrap();
  let img = image::load_from_memory(&amp;buf).unwrap();
  let filtered = img.grayscale();
  let mut buf = vec![];
  match image_format_detected {
    ImageFormat::Gif =&gt; {
        filtered.write_to(&amp;mut buf, ImageOutputFormat::Gif).unwrap();
    },
    _ =&gt; {
        filtered.write_to(&amp;mut buf, ImageOutputFormat::Png).unwrap();
    },
  };
  io::stdout().write_all(&amp;buf).unwrap();
  io::stdout().flush().unwrap();
}
</code></pre>
<p>You can use Rust’s <code>cargo</code> tool to build the Rust program into WebAssembly bytecode or native code. </p>
<pre><code>$ cd api/functions/image-grayscale/
$ cargo build --release --target wasm32-wasi 
</code></pre>
<p>Copy the build artifacts to the <code>api</code> folder. </p>
<pre><code>$ cp target/wasm32-wasi/release/grayscale.wasm ../../
</code></pre>
<blockquote>
<p>When we build the docker image, <code>api/pre.sh</code> is executed. <code>pre.sh</code> installs the WasmEdge runtime, and then compiles each WebAssembly bytecode program into a native <code>so</code> library for faster execution. </p>
</blockquote>
<h3 id="create-the-service-script-to-load-the-function"><a class="header" href="#create-the-service-script-to-load-the-function">Create the service script to load the function</a></h3>
<p>The <a href="https://github.com/second-state/aws-lambda-wasm-runtime/blob/main/api/hello.js"><code>api/hello.js</code></a> script loads the WasmEdge runtime, starts the compiled WebAssembly program in WasmEdge, and passes the uploaded image data via <code>STDIN</code>. Notice that <a href="https://github.com/second-state/aws-lambda-wasm-runtime/blob/main/api/hello.js"><code>api/hello.js</code></a> runs the compiled <code>grayscale.so</code> file generated by <a href="https://github.com/second-state/aws-lambda-wasm-runtime/blob/main/api/pre.sh"><code>api/pre.sh</code></a> for better performance.</p>
<pre><code>const { spawn } = require('child_process');
const path = require('path');

function _runWasm(reqBody) {
  return new Promise(resolve =&gt; {
    const wasmedge = spawn(path.join(__dirname, 'wasmedge'), [path.join(__dirname, 'grayscale.so')]);

    let d = [];
    wasmedge.stdout.on('data', (data) =&gt; {
      d.push(data);
    });

    wasmedge.on('close', (code) =&gt; {
      let buf = Buffer.concat(d);
      resolve(buf);
    });

    wasmedge.stdin.write(reqBody);
    wasmedge.stdin.end('');
  });
}
</code></pre>
<p>The <code>exports.handler</code> part of <code>hello.js</code> exports an async function handler, used to handle different events every time the serverless function is called. In this example, we simply process the image by calling the function above and return the result, but more complicated event-handling behavior may be defined based on your need. We also need to return some <code>Access-Control-Allow</code> headers to avoid <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS">Cross-Origin Resource Sharing (CORS)</a> errors when calling the serverless function from a browser. You can read more about CORS errors <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS/Errors">here</a> if you encounter them when replicating our example.</p>
<pre><code>exports.handler = async function(event, context) {
  var typedArray = new Uint8Array(event.body.match(/[\da-f]{2}/gi).map(function (h) {
    return parseInt(h, 16);
  }));
  let buf = await _runWasm(typedArray);
  return {
    statusCode: 200,
    headers: {
      &quot;Access-Control-Allow-Headers&quot; : &quot;Content-Type,X-Amz-Date,Authorization,X-Api-Key,X-Amz-Security-Token&quot;,
      &quot;Access-Control-Allow-Origin&quot;: &quot;*&quot;,
      &quot;Access-Control-Allow-Methods&quot;: &quot;DELETE, GET, HEAD, OPTIONS, PATCH, POST, PUT&quot;
    },
    body: buf.toString('hex')
  };
}
</code></pre>
<h3 id="build-the-docker-image-for-lambda-deployment"><a class="header" href="#build-the-docker-image-for-lambda-deployment">Build the Docker image for Lambda deployment</a></h3>
<p>Now we have the WebAssembly bytecode function and the script to load and connect to the web request. In order to deploy them as a function service on AWS Lambda, you still need to package the whole thing into a Docker image. </p>
<p>We are not going to cover in detail about how to build the Docker image and deploy on AWS Lambda, as there are detailed steps in the <a href="https://github.com/second-state/aws-lambda-wasm-runtime/blob/tensorflow/README.md#deploy">Deploy section of the repository README</a>. However, we will highlight some lines in the <a href="https://github.com/second-state/aws-lambda-wasm-runtime/blob/tensorflow/api/Dockerfile"><code>Dockerfile</code></a> for you to avoid some pitfalls.</p>
<pre><code>FROM public.ecr.aws/lambda/nodejs:14

# Change directory to /var/task
WORKDIR /var/task

RUN yum update -y &amp;&amp; yum install -y curl tar gzip

# Bundle and pre-compile the wasm files
COPY *.wasm ./
COPY pre.sh ./
RUN chmod +x pre.sh
RUN ./pre.sh

# Bundle the JS files
COPY *.js ./

CMD [ &quot;hello.handler&quot; ]
</code></pre>
<p>First, we are building the image from <a href="https://hub.docker.com/r/amazon/aws-lambda-nodejs">AWS Lambda's Node.js base image</a>. The advantage of using AWS Lambda's base image is that it includes the <a href="https://github.com/aws/aws-lambda-nodejs-runtime-interface-client">Lambda Runtime Interface Client (RIC)</a>, which we need to implement in our Docker image as it is required by AWS Lambda. The Amazon Linux uses <code>yum</code> as the package manager. </p>
<blockquote>
<p>These base images contain the Amazon Linux Base operating system, the runtime for a given language, dependencies and the Lambda Runtime Interface Client (RIC), which implements the Lambda <a href="https://docs.aws.amazon.com/lambda/latest/dg/runtimes-api.html">Runtime API</a>. The Lambda Runtime Interface Client allows your runtime to receive requests from and send requests to the Lambda service.</p>
</blockquote>
<p>Second, we need to put our function and all its dependencies in the <code>/var/task</code> directory. Files in other folders will not be executed by AWS Lambda.</p>
<p>Third, we need to define the default command when we start our container. <code>CMD [ &quot;hello.handler&quot; ]</code> means that we will call the <code>handler</code> function in <code>hello.js</code> whenever our serverless function is called. Recall that we have defined and exported the handler function in the previous steps through <code>exports.handler = ...</code> in <code>hello.js</code>.</p>
<h3 id="optional-test-the-docker-image-locally"><a class="header" href="#optional-test-the-docker-image-locally">Optional: test the Docker image locally</a></h3>
<p>Docker images built from AWS Lambda's base images can be tested locally following <a href="https://docs.aws.amazon.com/lambda/latest/dg/images-test.html">this guide</a>. Local testing requires <a href="https://github.com/aws/aws-lambda-runtime-interface-emulator">AWS Lambda Runtime Interface Emulator (RIE)</a>, which is already installed in all of AWS Lambda's base images. To test your image, first, start the Docker container by running:</p>
<pre><code>docker run -p 9000:8080  myfunction:latest 
</code></pre>
<p>This command sets a function endpoint on your local machine at <code>http://localhost:9000/2015-03-31/functions/function/invocations</code>.</p>
<p>Then, from a separate terminal window, run:</p>
<pre><code>curl -XPOST &quot;http://localhost:9000/2015-03-31/functions/function/invocations&quot; -d '{}'
</code></pre>
<p>And you should get your expected output in the terminal.</p>
<p>If you don't want to use a base image from AWS Lambda, you can also use your own base image and install RIC and/or RIE while building your Docker image. Just follow <strong>Create an image from an alternative base image</strong> section from <a href="https://docs.aws.amazon.com/lambda/latest/dg/images-create.html">this guide</a>.</p>
<p>That's it! After building your Docker image, you can deploy it to AWS Lambda following steps outlined in the repository <a href="https://github.com/second-state/aws-lambda-wasm-runtime/blob/tensorflow/README.md#deploy">README</a>. Now your serverless function is ready to rock!</p>
<h2 id="example-2-ai-inference-2"><a class="header" href="#example-2-ai-inference-2">Example 2: AI inference</a></h2>
<p>The <a href="https://github.com/second-state/aws-lambda-wasm-runtime/tree/tensorflow">second demo</a> application allows users to upload an image and then invoke a serverless function to classify the main subject on the image.</p>
<p>It is in <a href="https://github.com/second-state/aws-lambda-wasm-runtime/tree/tensorflow">the same GitHub repo</a> as the previous example but in the <code>tensorflow</code> branch. The backend serverless function for image classification is in the <code>api/functions/image-classification</code> folder in the <code>tensorflow</code> branch. The <code>src/main.rs</code> file contains the Rust program’s source code. The Rust program reads image data from the <code>STDIN</code>, and then outputs the text output to the <code>STDOUT</code>. It utilizes the WasmEdge Tensorflow API to run the AI inference. </p>
<pre><code>pub fn main() {
    // Step 1: Load the TFLite model
    let model_data: &amp;[u8] = include_bytes!(&quot;models/mobilenet_v1_1.0_224/mobilenet_v1_1.0_224_quant.tflite&quot;);
    let labels = include_str!(&quot;models/mobilenet_v1_1.0_224/labels_mobilenet_quant_v1_224.txt&quot;);

    // Step 2: Read image from STDIN
    let mut buf = Vec::new();
    io::stdin().read_to_end(&amp;mut buf).unwrap();

    // Step 3: Resize the input image for the tensorflow model
    let flat_img = wasmedge_tensorflow_interface::load_jpg_image_to_rgb8(&amp;buf, 224, 224);

    // Step 4: AI inference
    let mut session = wasmedge_tensorflow_interface::Session::new(&amp;model_data, wasmedge_tensorflow_interface::ModelType::TensorFlowLite);
    session.add_input(&quot;input&quot;, &amp;flat_img, &amp;[1, 224, 224, 3])
           .run();
    let res_vec: Vec&lt;u8&gt; = session.get_output(&quot;MobilenetV1/Predictions/Reshape_1&quot;);

    // Step 5: Find the food label that responds to the highest probability in res_vec
    // ... ...
    let mut label_lines = labels.lines();
    for _i in 0..max_index {
      label_lines.next();
    }

    // Step 6: Generate the output text
    let class_name = label_lines.next().unwrap().to_string();
    if max_value &gt; 50 {
      println!(&quot;It {} a &lt;a href='https://www.google.com/search?q={}'&gt;{}&lt;/a&gt; in the picture&quot;, confidence.to_string(), class_name, class_name);
    } else {
      println!(&quot;It does not appears to be any food item in the picture.&quot;);
    }
}
</code></pre>
<p>You can use the <code>cargo</code> tool to build the Rust program into WebAssembly bytecode or native code. </p>
<pre><code>$ cd api/functions/image-classification/
$ cargo build --release --target wasm32-wasi
</code></pre>
<p>Copy the build artifacts to the <code>api</code> folder. </p>
<pre><code>$ cp target/wasm32-wasi/release/classify.wasm ../../
</code></pre>
<p>Again, the <code>api/pre.sh</code> script installs WasmEdge runtime and its Tensorflow dependencies in this application. It also compiles the <code>classify.wasm</code> bytecode program to the <code>classify.so</code> native shared library at the time of deployment.</p>
<p>The <a href="https://github.com/second-state/aws-lambda-wasm-runtime/blob/tensorflow/api/hello.js"><code>api/hello.js</code></a> script loads the WasmEdge runtime, starts the compiled WebAssembly program in WasmEdge, and passes the uploaded image data via <code>STDIN</code>. Notice <a href="https://github.com/second-state/aws-lambda-wasm-runtime/blob/tensorflow/api/hello.js"><code>api/hello.js</code></a> runs the compiled <code>classify.so</code> file generated by <a href="https://github.com/second-state/aws-lambda-wasm-runtime/blob/tensorflow/api/pre.sh"><code>api/pre.sh</code></a> for better performance. The handler function is similar to our previous example, and is omitted here.</p>
<pre><code>const { spawn } = require('child_process');
const path = require('path');

function _runWasm(reqBody) {
  return new Promise(resolve =&gt; {
    const wasmedge = spawn(
      path.join(__dirname, 'wasmedge-tensorflow-lite'),
      [path.join(__dirname, 'classify.so')],
      {env: {'LD_LIBRARY_PATH': __dirname}}
    );

    let d = [];
    wasmedge.stdout.on('data', (data) =&gt; {
      d.push(data);
    });

    wasmedge.on('close', (code) =&gt; {
      resolve(d.join(''));
    });

    wasmedge.stdin.write(reqBody);
    wasmedge.stdin.end('');
  });
}

exports.handler = ... // _runWasm(reqBody) is called in the handler
</code></pre>
<p>You can build your Docker image and deploy the function in the same way as outlined in the previous example. Now you have created a web app for subject classification!</p>
<p>Next, it's your turn to use the <a href="https://github.com/second-state/aws-lambda-wasm-runtime/tree/main">aws-lambda-wasm-runtime repo</a> as a template to develop Rust serverless function on AWS Lambda. Looking forward to your great work.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="webassembly-serverless-functions-on-tencent-cloud"><a class="header" href="#webassembly-serverless-functions-on-tencent-cloud">WebAssembly serverless functions on Tencent Cloud</a></h1>
<p>As the main users of Tencent Cloud are from China, so the tutorial is <a href="https://my.oschina.net/u/4532842/blog/5172639">written in Chinese</a>.</p>
<p>We also provide a code template for deploying serverless WebAssembly functions on Tencent Cloud, please check out <a href="https://github.com/second-state/tencent-scf-wasm-runtime">the tencent-scf-wasm-runtime repo</a>.</p>
<p>Fork the repo and start writing your own rust functions.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="second-state-functions-1"><a class="header" href="#second-state-functions-1">Second State Functions</a></h1>
<p>Second State Functions, powered by WasmEdge, supports the Rust language as a first class citizen.</p>
<p>It could</p>
<ul>
<li><a href="https://www.secondstate.io/articles/getting-started-with-function-as-a-service-in-rust/">Handle text-based input and output</a></li>
<li><a href="https://www.secondstate.io/articles/use-binary-data-as-function-input-and-output/">Use Binary date as function input and output</a></li>
<li><a href="https://www.secondstate.io/articles/use-binary-data-as-function-input-and-output/">Mix bytes and strings in function argument and return value</a></li>
<li><a href="https://www.secondstate.io/articles/internet-of-functions-webhooks/">Use webhooks as function input and output</a></li>
<li><a href="https://www.secondstate.io/articles/internet-of-functions-http-proxy/">Access internet resources via a <code>http_proxy</code> API</a></li>
<li><a href="https://www.secondstate.io/articles/wasi-tensorflow/">Running TensorFlow models at native speed via the WasmEdge TensorFlow API</a></li>
</ul>
<p>Check out the <a href="https://www.secondstate.io/faas/">Second State Functions</a> website for more tutorials.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="operating-systems"><a class="header" href="#operating-systems">Operating systems</a></h1>
<p>WasmEdge supports a wide range of operating systems and hardware platforms.
It allows WebAssembly bytecode applications to be truly portable
across platforms.
It runs not only on Linux-like systems, but also on microkernels such as the seL4 system.</p>
<p>WasmEdge now supports</p>
<ul>
<li>Linux</li>
<li>Windows</li>
<li>macOS</li>
<li>seL4</li>
<li>OpenHarmony(ongoing)</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="linux"><a class="header" href="#linux">Linux</a></h1>
<p>WasmEdge supports a wide range of Linux distributions dated back to
2007. The official release contains statically linked binaries and libraries
for older Linux systems.
The table below shows build targets in WasmEdge's official release packages.</p>
<table><thead><tr><th>tag name</th><th>arch</th><th>based operating system</th><th>LLVM version</th><th>ENVs</th><th>compatibility</th><th>comments</th></tr></thead><tbody>
<tr><td><code>latest</code></td><td>x86_64</td><td>Ubuntu 20.04 LTS</td><td>12.0.0</td><td>CC=clang, CXX=clang++</td><td>Ubuntu 20.04+</td><td>This is for CI, will always use the latest Ubuntu release</td></tr>
<tr><td><code>ubuntu-build-gcc</code></td><td>x86_64</td><td>Ubuntu 20.04 LTS</td><td>12.0.0</td><td>CC=gcc, CXX=g++</td><td>Ubuntu 20.04+</td><td>This is for CI, will always use the latest Ubuntu release</td></tr>
<tr><td><code>ubuntu-build-clang</code></td><td>x86_64</td><td>Ubuntu 20.04 LTS</td><td>12.0.0</td><td>CC=clang, CXX=clang++</td><td>Ubuntu 20.04+</td><td>This is for CI, will always use the latest Ubuntu release</td></tr>
<tr><td><code>ubuntu2004_x86_64</code></td><td>x86_64</td><td>Ubuntu 20.04 LTS</td><td>10.0.0</td><td>CC=gcc, CXX=g++</td><td>Ubuntu 20.04+</td><td>This is for developers who familiar with Ubuntu 20.04 LTS release</td></tr>
<tr><td><code>ubuntu2104_armv7l</code></td><td>armhf</td><td>Ubuntu 21.04</td><td>12.0.0</td><td>CC=gcc, CXX=g++</td><td>Ubuntu 21.04+</td><td>This is for armhf release</td></tr>
<tr><td><code>manylinux2014_x86_64</code></td><td>x86_64</td><td>CentOS 7, 7.9.2009</td><td>12.0.0</td><td>CC=gcc, CXX=g++</td><td>Ubuntu 16.04+, CentOS 7+</td><td>This is for developers who familiar with CentOS on x86_64 architecture</td></tr>
<tr><td><code>manylinux2014_aarch64</code></td><td>aarch64</td><td>CentOS 7, 7.9.2009</td><td>12.0.0</td><td>CC=gcc, CXX=g++</td><td>Ubuntu 16.04+, CentOS 7+</td><td>This is for developers who familiar with CentOS on aarch64 architecture</td></tr>
<tr><td><code>manylinux2010_x86_64</code></td><td>x86_64</td><td>CentOS 6, 6.10</td><td>12.0.0</td><td>CC=gcc, CXX=g++</td><td>Ubuntu 14.04+, CentOS 6+</td><td>This is for developers who familiar with legacy system on x86_64 architecture, EOL</td></tr>
<tr><td><code>manylinux1_x86_64</code></td><td>x86_64</td><td>CentOS 5, 5.11</td><td>12.0.0</td><td>CC=gcc, CXX=g++</td><td>Ubuntu 14.04+, CentOS 5+</td><td>This is for developers who familiar with legacy system on x86_64 architecture, EOL</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h1 id="windows"><a class="header" href="#windows">Windows</a></h1>
<p>WasmEdge provides a standard Windows PowerShell binary build as part 
of its official release package. You can install it via our standard 
install script.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mac"><a class="header" href="#mac">Mac</a></h1>
<p>WasmEdge provides both x86 and m1 binary builds for Mac OS X.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="wasmedge-on-sel4"><a class="header" href="#wasmedge-on-sel4">WasmEdge on seL4</a></h1>
<p><a href="https://youtu.be/2Qu-Trtkspk">Video demo</a> | <a href="https://github.com/second-state/wasmedge-seL4/runs/3982081148?check_suite_focus=true">Build logs</a> | <a href="https://github.com/second-state/wasmedge-seL4/actions/runs/1374510169">Build artifact</a></p>
<p>In this article, we demonstrate how to run WasmEdge on the seL4 RTOS, there are two parts:</p>
<ol>
<li>Guest Linux OS on seL4: This is the controller of WasmEdge runtime, which will send wasm program to WasmEdge runner that is a agent on seL4 to execute.</li>
<li>WasmEdge runner on seL4: This is the wasm program runtime, which will execute the given wasm program from Guest Linux OS.</li>
</ol>
<p>The figure below illustrates the architecture of the system.</p>
<p><img src="os/wasmedge-sel4.png" alt="" /></p>
<p>This demo is based on the seL4 simulator on Linux.</p>
<h2 id="getting-started-3"><a class="header" href="#getting-started-3">Getting Started</a></h2>
<h3 id="system-requirements"><a class="header" href="#system-requirements">System requirements</a></h3>
<p>Hardware:</p>
<ul>
<li>at least 4GB of RAM</li>
<li>at least 20GB of disk storage (the wasmedge_sel4 directory will contain over 11 GB of data after the following installation completes) </li>
</ul>
<p>Software: Ubuntu 20.04 with dev tools packages (ep. Python) installed. We recommend the <a href="https://github.com/actions/virtual-environments/blob/main/images/linux/Ubuntu2004-README.md">GitHub Actions Ubuntu 20.04 VM</a> (See a list of <a href="https://github.com/actions/virtual-environments/blob/main/images/linux/Ubuntu2004-README.md#installed-apt-packages">installed apt packages</a>). Or, you could use our Docker image (see the <a href="https://github.com/second-state/wasmedge-seL4/blob/main/docs/Dockerfile.sel4_build">Dockerfile</a>).</p>
<pre><code class="language-bash">$ docker pull wasmedge/sel4_build
$ docker run --rm -v $(pwd):/app -it wasmedge/sel4_build
(docker) root#
</code></pre>
<blockquote>
<p>If you do not want to build the seL4 system simulator yourself, you can download the <a href="https://github.com/second-state/wasmedge-seL4/actions/runs/1374510169">build artifact</a> from our GitHub Actions, and skip directly to <a href="os/sel4.html#boot-wasmedge-sel4">Boot wasmedge-seL4</a></p>
</blockquote>
<h3 id="automatic-installation-all-in-one-script"><a class="header" href="#automatic-installation-all-in-one-script">Automatic installation: all-in-one script</a></h3>
<p>Use our all-in-one build script:</p>
<pre><code class="language-bash">wget -qO- https://raw.githubusercontent.com/second-state/wasmedge-seL4/main/build.sh | bash
</code></pre>
<p>And this will clone and build our wasmedge on seL4 to an image.</p>
<p>After finishing the build script, you will have a folder <code>sel4_wasmedge</code>. </p>
<p>If this automatic installation completed successfully, skip over the manual installation information and proceed to <a href="https://github.com/second-state/wasmedge-seL4#boot-wasmedge-sel4">boot wasmedge-sel4</a></p>
<h3 id="manual-installation-managing-memory-usage"><a class="header" href="#manual-installation-managing-memory-usage">Manual installation: managing memory usage</a></h3>
<p>The above all-in-one script will work in most cases. However, if your system resources were stressed and you encountered an error such as <code>ninja: build stopped: subcommand failed</code> please note that you can decrease the parallelization of the install by explicitly passing in a <code>-j</code> parameter to the <code>ninja</code> command (on the last line of the <code>build.sh</code> file). You see, Ninja runs the most amount of parallel processes by default and so the following procedure is a way to explicitly set/reduce parallelization.</p>
<p>Manually fetch the `wasmedge-sel4 repository.</p>
<pre><code class="language-bash">cd ~
git clone https://github.com/second-state/wasmedge-seL4.git
cd wasmedge-seL4
</code></pre>
<p>Manually edit the <code>build.sh</code> file.</p>
<pre><code class="language-bash">vi build.sh
</code></pre>
<p>Add the following <code>-j</code> parameter to the last line of the file i.e.</p>
<pre><code class="language-bash">ninja -j 2
</code></pre>
<p>Make the <code>build.sh</code> file executable.</p>
<pre><code class="language-bash">sudo chmod a+x build.sh
</code></pre>
<p>Run the edited `build.sh file.</p>
<pre><code class="language-bash">./build.sh
</code></pre>
<p>Once this manual installation is complete, follow along with the following steps; boot wasmedge-sel4</p>
<h3 id="boot-wasmedge-sel4"><a class="header" href="#boot-wasmedge-sel4">Boot wasmedge-seL4</a></h3>
<pre><code class="language-bash">cd sel4_wasmedge/build
./simulate
</code></pre>
<p>Expected output:</p>
<pre><code class="language-bash">./simulate: qemu-system-aarch64 -machine virt,virtualization=on,highmem=off,secure=off -cpu cortex-a53 -nographic  -m size=2048  -kernel images/capdl-loader-image-arm-qemu-arm-virt
ELF-loader started on CPU: ARM Ltd. Cortex-A53 r0p4
  paddr=[6abd8000..750cf0af]
No DTB passed in from boot loader.
Looking for DTB in CPIO archive...found at 6ad18f58.
Loaded DTB from 6ad18f58.
   paddr=[60243000..60244fff]
ELF-loading image 'kernel' to 60000000
  paddr=[60000000..60242fff]
  vaddr=[ff8060000000..ff8060242fff]
  virt_entry=ff8060000000
ELF-loading image 'capdl-loader' to 60245000
  paddr=[60245000..6a7ddfff]
  vaddr=[400000..a998fff]
  virt_entry=408f38
Enabling hypervisor MMU and paging
Jumping to kernel-image entry point...

Bootstrapping kernel
Warning: Could not infer GIC interrupt target ID, assuming 0.
Booting all finished, dropped to user space
&lt;&lt;seL4(CPU 0) [decodeUntypedInvocation/205 T0xff80bf85d400 &quot;rootserver&quot; @4006f8]: Untyped Retype: Insufficient memory (1 * 2097152 bytes needed, 0 bytes available).&gt;&gt;
Loading Linux: 'linux' dtb: 'linux-dtb'

...(omitted)...

Starting syslogd: OK
Starting klogd: OK
Running sysctl: OK
Initializing random number generator... [    3.512482] random: dd: uninitialized urandom read (512 bytes read)
done.
Starting network: OK
[    4.086059] connection: loading out-of-tree module taints kernel.
[    4.114686] Event Bar (dev-0) initalised
[    4.123771] 2 Dataports (dev-0) initalised
[    4.130626] Event Bar (dev-1) initalised
[    4.136096] 2 Dataports (dev-1) initalised

Welcome to Buildroot
buildroot login:
</code></pre>
<h3 id="login-on-guest-linux"><a class="header" href="#login-on-guest-linux">Login on guest linux</a></h3>
<p>Enter <code>root</code> to login</p>
<pre><code class="language-bash">buildroot login: root
</code></pre>
<p>Expected output:</p>
<pre><code class="language-bash">buildroot login: root
#
</code></pre>
<h3 id="execute-wasm-examples"><a class="header" href="#execute-wasm-examples">Execute wasm examples</a></h3>
<h4 id="example-a-nbody-cwasm"><a class="header" href="#example-a-nbody-cwasm">Example A: nbody-c.wasm</a></h4>
<p>Run nbody simulation.</p>
<pre><code class="language-bash">wasmedge_emit /usr/bin/nbody-c.wasm 10
</code></pre>
<p>Expected output:</p>
<pre><code class="language-bash">[1900-01-00 00:00:00.000] [info] executing wasm file
-0.169075164
-0.169073022
[1900-01-00 00:00:00.000] [info] execution success, exit code:0
</code></pre>
<h4 id="example-b-hellowasm"><a class="header" href="#example-b-hellowasm">Example B: hello.wasm</a></h4>
<p>Run an easy application to print <code>hello, sel4</code> and a simple calculation.</p>
<pre><code class="language-bash">wasmedge_emit /usr/bin/hello.wasm
</code></pre>
<p>Expected output:</p>
<pre><code class="language-bash">[1900-01-00 00:00:00.000] [info] executing wasm file
hello, sel4
1+2-3*4 = -9
[1900-01-00 00:00:00.000] [info] execution success, exit code:0
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="open-harmony"><a class="header" href="#open-harmony">Open Harmony</a></h1>
<p>WIP. For Chinese speakers, please <a href="https://github.com/WasmEdge/WasmEdge/blob/master/utils/ohos/README-zh.md">check out this instruction</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="raspberry-pi-34"><a class="header" href="#raspberry-pi-34">Raspberry Pi 3/4</a></h1>
<p>Raspberry Pi uses 64-bit processors starting with the 3B model, so WasmEdge can be executed on Raspberry Pi as well. You can choose any 64-bit Linux distribution, such as Raspbian, Ubuntu or Manjaro for ARM. This document has been tested on the Manjaro for ARM distribution and the hardware is the Raspberry Pi 3b.</p>
<p>The installation steps are no different from the <a href="https://wasmedge.org/book/en/start/install.html">installation document</a>, and the execution is the same. Here's a video about installing WasmEdge and running a simple WebAssembly module to add two numbers up.</p>
<p><a href="https://asciinema.org/a/458453"><img src="https://asciinema.org/a/458453.svg" alt="asciicast" /></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="contribute-to-wasmedge"><a class="header" href="#contribute-to-wasmedge">Contribute to WasmEdge</a></h1>
<p>One of the most important features of WasmEdge is its extensibility.
Through extensions, WasmEdge applications can use languages like 
Rust, C, and JavaScript to access features and functionalities
provided by the operating systems or shared libraries.</p>
<p>In this chapter, we will cover how to build WasmEdge from source code
for different operating systems and platforms. We will then discuss
the WasmEdge plug-in API, which allows developers to create extensions that can be distributed with official WasmEdge releases.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="build-wasmedge-from-source"><a class="header" href="#build-wasmedge-from-source">Build WasmEdge from source</a></h1>
<p>Please follow this guide to build and test WasmEdge from source code.</p>
<p>The following guide is based on Linux distributions. For MacOS, please refer to <a href="extend/build_on_mac.html">Build for macOS</a>. For Windows, please refer to <a href="extend/build_on_windows.html">Build for Windows</a></p>
<blockquote>
<p>If you just want the latest builds from the <code>HEAD</code> of the <code>master</code> branch, and do not want to build it yourself, you can download the release package directly from our Github Action's CI artifact. <a href="https://github.com/WasmEdge/WasmEdge/actions/runs/1521549504#artifacts">Here is an example</a>.</p>
</blockquote>
<h2 id="get-source-code"><a class="header" href="#get-source-code">Get Source Code</a></h2>
<pre><code class="language-bash">$ git clone https://github.com/WasmEdge/WasmEdge.git
$ cd WasmEdge
</code></pre>
<h2 id="check-dependencies"><a class="header" href="#check-dependencies">Check Dependencies</a></h2>
<p>WasmEdge will try to use the latest LLVM release to create our nightly build. 
If you want to build from source, you may need to install these dependencies by yourself or using our docker images which provides several Linux distribution support.</p>
<ul>
<li>LLVM 12.0.0 (&gt;= 10.0.0)</li>
<li>GCC 11.1.0 (&gt;= 9.4.0)</li>
</ul>
<h2 id="prepare-the-environment"><a class="header" href="#prepare-the-environment">Prepare the Environment</a></h2>
<h3 id="docker-images"><a class="header" href="#docker-images">Docker Images</a></h3>
<p>Repository on dockerhub <code>wasmedge/wasmedge</code></p>
<p>You can use the following commands to get our latest docker image:</p>
<pre><code class="language-bash">$ docker pull wasmedge/wasmedge # Equals to wasmedge/wasmedge:latest
</code></pre>
<h4 id="available-tags"><a class="header" href="#available-tags">Available Tags</a></h4>
<table><thead><tr><th>tag name</th><th>arch</th><th>based operating system</th><th>LLVM version</th><th>ENVs</th><th>compatibility</th><th>comments</th></tr></thead><tbody>
<tr><td><code>latest</code></td><td>x86_64</td><td>Ubuntu 20.04 LTS</td><td>12.0.0</td><td>CC=clang, CXX=clang++</td><td>Ubuntu 20.04+</td><td>This is for CI, will always use the latest Ubuntu release</td></tr>
<tr><td><code>ubuntu-build-gcc</code></td><td>x86_64</td><td>Ubuntu 20.04 LTS</td><td>12.0.0</td><td>CC=gcc, CXX=g++</td><td>Ubuntu 20.04+</td><td>This is for CI, will always use the latest Ubuntu release</td></tr>
<tr><td><code>ubuntu-build-clang</code></td><td>x86_64</td><td>Ubuntu 20.04 LTS</td><td>12.0.0</td><td>CC=clang, CXX=clang++</td><td>Ubuntu 20.04+</td><td>This is for CI, will always use the latest Ubuntu release</td></tr>
<tr><td><code>ubuntu2004_x86_64</code></td><td>x86_64</td><td>Ubuntu 20.04 LTS</td><td>10.0.0</td><td>CC=gcc, CXX=g++</td><td>Ubuntu 20.04+</td><td>This is for developers who familiar with Ubuntu 20.04 LTS release</td></tr>
<tr><td><code>ubuntu2104_armv7l</code></td><td>armhf</td><td>Ubuntu 21.04</td><td>12.0.0</td><td>CC=gcc, CXX=g++</td><td>Ubuntu 21.04+</td><td>This is for armhf release</td></tr>
<tr><td><code>manylinux2014_x86_64</code></td><td>x86_64</td><td>CentOS 7, 7.9.2009</td><td>12.0.0</td><td>CC=gcc, CXX=g++</td><td>Ubuntu 16.04+, CentOS 7+</td><td>This is for developers who familiar with CentOS on x86_64 architecture</td></tr>
<tr><td><code>manylinux2014_aarch64</code></td><td>aarch64</td><td>CentOS 7, 7.9.2009</td><td>12.0.0</td><td>CC=gcc, CXX=g++</td><td>Ubuntu 16.04+, CentOS 7+</td><td>This is for developers who familiar with CentOS on aarch64 architecture</td></tr>
<tr><td><code>manylinux2010_x86_64</code></td><td>x86_64</td><td>CentOS 6, 6.10</td><td>12.0.0</td><td>CC=gcc, CXX=g++</td><td>Ubuntu 14.04+, CentOS 6+</td><td>This is for developers who familiar with legacy system on x86_64 architecture, EOL</td></tr>
<tr><td><code>manylinux1_x86_64</code></td><td>x86_64</td><td>CentOS 5, 5.11</td><td>12.0.0</td><td>CC=gcc, CXX=g++</td><td>Ubuntu 14.04+, CentOS 5+</td><td>This is for developers who familiar with legacy system on x86_64 architecture, EOL</td></tr>
</tbody></table>
<h3 id="install-dependencies-on-ubuntu-2004-manually"><a class="header" href="#install-dependencies-on-ubuntu-2004-manually">Install dependencies on Ubuntu 20.04 manually</a></h3>
<pre><code class="language-bash"># Tools and libraries
$ sudo apt install -y \
	software-properties-common \
	cmake \
	libboost-all-dev

# And you will need to install llvm for wasmedgec tool
$ sudo apt install -y \
	llvm-12-dev \
	liblld-12-dev

# WasmEdge supports both clang++ and g++ compilers
# You can choose one of them for building this project
# If you prefer GCC
$ sudo apt install -y gcc g++
# Else you can choose clang
$ sudo apt install -y clang-12
</code></pre>
<h3 id="support-for-legacy-operating-systems"><a class="header" href="#support-for-legacy-operating-systems">Support for legacy operating systems</a></h3>
<p>Our development environment requires <code>libLLVM-12</code> and <code>&gt;=GLIBCXX_3.4.33</code>.</p>
<p>If users are using the older operating system than Ubuntu 20.04, please use our special docker image to build WasmEdge.
If you are looking for the pre-built binaries for the older operating system, we also provide several pre-built binaries based on manylinux* distribution.</p>
<table><thead><tr><th>Portable Linux Built Distributions Tags</th><th>Base Image</th><th>Provided Requirements</th><th>Docker Image</th></tr></thead><tbody>
<tr><td><code>manylinux1</code></td><td>CentOS 5.11</td><td>GLIBC &lt;= 2.5<br>CXXABI &lt;= 3.4.8<br>GLIBCXX &lt;= 3.4.9<br>GCC &lt;= 4.2.0</td><td>wasmedge/wasmedge:manylinux1_x86_64</td></tr>
<tr><td><code>manylinux2010</code></td><td>CentOS 6.10</td><td>GLIBC &lt;= 2.12<br>CXXABI &lt;= 1.3.3<br>GLIBCXX &lt;= 3.4.13<br>GCC &lt;= 4.5.0</td><td>wasmedge/wasmedge:manylinux2010_x86_64</td></tr>
<tr><td><code>manylinux2014</code></td><td>CentOS 7.9</td><td>GLIBC &lt;= 2.17<br>CXXABI &lt;= 1.3.7<br>GLIBCXX &lt;= 3.4.19<br>GCC &lt;= 4.8.0</td><td>wasmedge/wasmedge:manylinux2014_x86_64</td></tr>
<tr><td><code>manylinux2014</code></td><td>CentOS 7.9</td><td>GLIBC &lt;= 2.17<br>CXXABI &lt;= 1.3.7<br>GLIBCXX &lt;= 3.4.19<br>GCC &lt;= 4.8.0</td><td>wasmedge/wasmedge:manylinux2014_aarch64</td></tr>
</tbody></table>
<h3 id="if-you-dont-want-to-build-ahead-of-time-runtimecompiler"><a class="header" href="#if-you-dont-want-to-build-ahead-of-time-runtimecompiler">If you don't want to build Ahead-of-Time runtime/compiler</a></h3>
<p>If users don't need Ahead-of-Time runtime/compiler support, they can set the CMake option <code>WASMEDGE_BUILD_AOT_RUNTIME</code> to <code>OFF</code>.</p>
<pre><code class="language-bash">$ cmake -DCMAKE_BUILD_TYPE=Release -DWASMEDGE_BUILD_AOT_RUNTIME=OFF ..
</code></pre>
<h2 id="build-wasmedge"><a class="header" href="#build-wasmedge">Build WasmEdge</a></h2>
<p>WasmEdge provides various tools for enabling different runtime environments for optimal performance.
After the build is finished, you can find there are several wasmedge related tools:</p>
<ol>
<li><code>wasmedge</code> is for general wasm runtime.
<ul>
<li><code>wasmedge</code> executes a <code>WASM</code> file in interpreter mode or a compiled WASM <code>so</code> file in ahead-of-time compilation mode.</li>
<li>To disable building all tools, you can set the CMake option <code>WASMEDGE_BUILD_TOOLS</code> to <code>OFF</code>.</li>
</ul>
</li>
<li><code>wasmedgec</code> is for ahead-of-time <code>WASM</code> compiler.
<ul>
<li><code>wasmedgec</code> compiles a general <code>WASM</code> file into a <code>so</code> file.</li>
<li>To disable building the ahead-of-time compiler only, you can set the CMake option <code>WASMEDGE_BUILD_AOT_RUNTIME</code> to <code>OFF</code>.</li>
</ul>
</li>
<li><code>libwasmedge_c.so</code> is the WasmEdge C API shared library.
<ul>
<li><code>libwasmedge_c.so</code> provides C API for the ahead-of-time compiler and the WASM runtime.</li>
<li>The APIs about the ahead-of-time compiler will always return failed if the CMake option <code>WASMEDGE_BUILD_AOT_RUNTIME</code> is set as <code>OFF</code>.</li>
<li>To disable building the shared library only, you can set the CMake option <code>WASMEDGE_BUILD_SHARED_LIB</code> to <code>OFF</code>.</li>
</ul>
</li>
<li><code>ssvm-qitc</code> is for AI application, supporting ONNC runtime for AI model in ONNX format.
<ul>
<li>If you want to try <code>ssvm-qitc</code>, please refer to <a href="https://github.com/ONNC/onnc-wasm">ONNC-Wasm</a> project to set up the working environment and run several examples.</li>
<li>And here is our <a href="https://www.youtube.com/watch?v=cbiPuHMS-iQ">tutorial for ONNC-Wasm project(YouTube Video)</a>.</li>
</ul>
</li>
</ol>
<pre><code class="language-bash"># After pulling our wasmedge docker image
$ docker run -it --rm \
    -v &lt;path/to/your/wasmedge/source/folder&gt;:/root/wasmedge \
    wasmedge/wasmedge:latest
(docker)$ cd /root/wasmedge
(docker)$ mkdir -p build &amp;&amp; cd build
(docker)$ cmake -DCMAKE_BUILD_TYPE=Release -DWASMEDGE_BUILD_TESTS=ON .. &amp;&amp; make -j
</code></pre>
<h2 id="run-built-in-tests"><a class="header" href="#run-built-in-tests">Run built-in tests</a></h2>
<p>The following built-in tests are only available when the build flag <code>WASMEDGE_BUILD_TESTS</code> sets to <code>ON</code>.</p>
<p>Users can use these tests to verify the correctness of WasmEdge binaries.</p>
<pre><code class="language-bash">$ cd &lt;path/to/wasmedge/build_folder&gt;
$ LD_LIBRARY_PATH=$(pwd)/lib/api ctest
</code></pre>
<h2 id="run-applications"><a class="header" href="#run-applications">Run applications</a></h2>
<p>Next, follow <a href="extend/../index.html">this guide</a> to run WebAssembly bytecode programs in <code>wasmedge</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="build-from-source-on-macos"><a class="header" href="#build-from-source-on-macos">Build from source on MacOS</a></h1>
<p>Currently, WasmEdge project on MacOS supports both Intel and M1 models. However, we only test and develop on Big Sur and Catalina.</p>
<ul>
<li>Model:
<ul>
<li>Intel</li>
<li>M1</li>
</ul>
</li>
<li>Operating System
<ul>
<li>Big Sur</li>
<li>Catalina</li>
</ul>
</li>
</ul>
<p>If you would like to develop WasmEdge on MacOS, please follow this guide to build and test from source code.</p>
<h2 id="get-source-code-1"><a class="header" href="#get-source-code-1">Get Source Code</a></h2>
<pre><code class="language-bash">$ git clone https://github.com/WasmEdge/WasmEdge.git
$ cd WasmEdge
</code></pre>
<h2 id="requirements-and-dependencies"><a class="header" href="#requirements-and-dependencies">Requirements and Dependencies</a></h2>
<p>WasmEdge will try to use the latest LLVM release to create our nightly build. 
If you want to build from source, you may need to install these dependencies 
by yourself.</p>
<ul>
<li>LLVM 12.0.0 (&gt;= 10.0.0), installed via brew, please don't use the built-in one.</li>
<li>Because the default version of LLVM on the latest brew is 13. Please use <code>llvm@12</code> to fix the LLVM version.</li>
</ul>
<h3 id="prepare-the-environment-1"><a class="header" href="#prepare-the-environment-1">Prepare the environment</a></h3>
<pre><code class="language-bash"># Tools and libraries
brew install boost cmake ninja llvm@12
# Use brew version of llvm, not the built-in one.
export PATH=&quot;/usr/local/opt/llvm@12/bin:$PATH&quot;
export LDFLAGS=&quot;-L/usr/local/opt/llvm@12/lib -Wl,-rpath,/usr/local/opt/llvm@12/lib&quot;
export CPPFLAGS=&quot;-I/usr/local/opt/llvm@12/include&quot;
</code></pre>
<h3 id="if-you-dont-want-to-build-ahead-of-time-runtimecompiler-1"><a class="header" href="#if-you-dont-want-to-build-ahead-of-time-runtimecompiler-1">If you don't want to build Ahead-of-Time runtime/compiler</a></h3>
<p>If users don't need Ahead-of-Time runtime/compiler support, they can set the CMake option <code>WASMEDGE_BUILD_AOT_RUNTIME</code> to <code>OFF</code>.</p>
<pre><code class="language-bash">$ cmake -DCMAKE_BUILD_TYPE=Release -DWASMEDGE_BUILD_AOT_RUNTIME=OFF ..
</code></pre>
<h2 id="build-wasmedge-1"><a class="header" href="#build-wasmedge-1">Build WasmEdge</a></h2>
<p>WasmEdge provides various tools for enabling different runtime environments for optimal performance.
After the build is finished, you can find there are several wasmedge related tools:</p>
<ol>
<li><code>wasmedge</code> is for general wasm runtime.
<ul>
<li><code>wasmedge</code> executes a <code>WASM</code> file in interpreter mode or a compiled WASM <code>dyld</code> file in ahead-of-time compilation mode.</li>
<li>To disable building all tools, you can set the CMake option <code>WASMEDGE_BUILD_TOOLS</code> to <code>OFF</code>.</li>
</ul>
</li>
<li><code>wasmedgec</code> is for ahead-of-time <code>WASM</code> compiler.
<ul>
<li><code>wasmedgec</code> compiles a general <code>WASM</code> file into a <code>dyld</code> file.</li>
<li>To disable building the ahead-of-time compiler only, you can set the CMake option <code>WASMEDGE_BUILD_AOT_RUNTIME</code> to <code>OFF</code>.</li>
</ul>
</li>
<li><code>libwasmedge_c.dyld</code> is the WasmEdge C API shared library.
<ul>
<li><code>libwasmedge_c.dyld</code> provides C API for the ahead-of-time compiler and the WASM runtime.</li>
<li>The APIs about the ahead-of-time compiler will always return failed if the CMake option <code>WASMEDGE_BUILD_AOT_RUNTIME</code> is set as <code>OFF</code>.</li>
<li>To disable building the shared library only, you can set the CMake option <code>WASMEDGE_BUILD_SHARED_LIB</code> to <code>OFF</code>.</li>
</ul>
</li>
</ol>
<pre><code class="language-bash">cmake -Bbuild -GNinja -DWASMEDGE_BUILD_PACKAGE=&quot;TGZ&quot; -DWASMEDGE_BUILD_TESTS=ON .
cmake --build build
</code></pre>
<h2 id="run-built-in-tests-1"><a class="header" href="#run-built-in-tests-1">Run built-in tests</a></h2>
<p>The following built-in tests are only available when the build flag <code>WASMEDGE_BUILD_TESTS</code> sets to <code>ON</code>.</p>
<p>Users can use these tests to verify the correctness of WasmEdge binaries.</p>
<pre><code class="language-bash">export DYLD_LIBRARY_PATH=&quot;$(pwd)/build/lib/api:$DYLD_LIBRARY_PATH&quot;
cmake --build build --target test
</code></pre>
<h2 id="run-applications-1"><a class="header" href="#run-applications-1">Run applications</a></h2>
<p>Next, follow <a href="extend/../index.html">this guide</a> to run WebAssembly bytecode programs in <code>wasmedge</code>.</p>
<h2 id="known-issues"><a class="header" href="#known-issues">Known issues</a></h2>
<p>The following tests can not pass on macos, we are investigating these issues:</p>
<ul>
<li>wasmedgeAPIVMCoreTests</li>
<li>wasmedgeAPIStepsCoreTests</li>
<li>wasmedgeAPIAOTCoreTests</li>
<li>wasmedgeProcessTests</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="build-from-source-on-windows-10"><a class="header" href="#build-from-source-on-windows-10">Build from source on Windows 10</a></h1>
<p>WasmEdge supports Windows 10. Currently, we also provide pre-built binaries and libraries for Windows.</p>
<p>You can find the details <a href="https://github.com/WasmEdge/WasmEdge/blob/master/.github/workflows/build.yml#L266-L322">here</a></p>
<p>If you would like to develop WasmEdge on Windows 10, please follow this guide to build and test from source code.</p>
<h2 id="get-source-code-2"><a class="header" href="#get-source-code-2">Get Source Code</a></h2>
<pre><code class="language-bash">$ git clone https://github.com/WasmEdge/WasmEdge.git
$ cd WasmEdge
</code></pre>
<h2 id="requirements-and-dependencies-1"><a class="header" href="#requirements-and-dependencies-1">Requirements and Dependencies</a></h2>
<p>WasmEdge will try to use the latest LLVM release to create our nightly build. 
If you want to build from source, you may need to install these dependencies 
by yourself.</p>
<ul>
<li>Chocolatey, we use it to install cmake, ninja, and vswhere</li>
<li>Windows SDK 19041</li>
<li>LLVM 13.0.0, you can find the pre-built files in the following section.</li>
</ul>
<h3 id="prepare-the-environment-2"><a class="header" href="#prepare-the-environment-2">Prepare the environment</a></h3>
<pre><code class="language-powershell"># Instal tools
choco install cmake ninja vswhere

$vsPath = (vswhere -latest -property installationPath)
Import-Module (Join-Path $vsPath &quot;Common7\Tools\Microsoft.VisualStudio.DevShell.dll&quot;)
Enter-VsDevShell -VsInstallPath $vsPath -SkipAutomaticLocation -DevCmdArguments &quot;-arch=x64 -host_arch=x64 -winsdk=10.0.19041.0&quot;

# Download our pre-built LLVM 13
$llvm = &quot;LLVM-13.0.0-win64.zip&quot;
curl -sLO https://github.com/WasmEdge/llvm-windows/releases/download/llvmorg-13.0.0/LLVM-13.0.0-win64.zip -o $llvm
Expand-Archive -Path $llvm

# Set LLVM environment
$llvm_dir = &quot;$pwd\\LLVM-13.0.0-win64\\LLVM-13.0.0-win64\\lib\\cmake\\llvm&quot;
$Env:CC = &quot;clang-cl&quot;
$Env:CXX = &quot;clang-cl&quot;
</code></pre>
<h3 id="if-you-dont-want-to-build-ahead-of-time-runtimecompiler-2"><a class="header" href="#if-you-dont-want-to-build-ahead-of-time-runtimecompiler-2">If you don't want to build Ahead-of-Time runtime/compiler</a></h3>
<p>If users don't need Ahead-of-Time runtime/compiler support, they can set the CMake option <code>WASMEDGE_BUILD_AOT_RUNTIME</code> to <code>OFF</code>.</p>
<pre><code class="language-bash">$ cmake -DCMAKE_BUILD_TYPE=Release -DWASMEDGE_BUILD_AOT_RUNTIME=OFF ..
</code></pre>
<h2 id="build-wasmedge-2"><a class="header" href="#build-wasmedge-2">Build WasmEdge</a></h2>
<p>WasmEdge provides various tools for enabling different runtime environments for optimal performance.
After the build is finished, you can find there are several wasmedge related tools:</p>
<ol>
<li><code>wasmedge</code> is for general wasm runtime.
<ul>
<li><code>wasmedge</code> executes a <code>WASM</code> file in interpreter mode or a compiled WASM <code>dyld</code> file in ahead-of-time compilation mode.</li>
<li>To disable building all tools, you can set the CMake option <code>WASMEDGE_BUILD_TOOLS</code> to <code>OFF</code>.</li>
</ul>
</li>
<li><code>wasmedgec</code> is for ahead-of-time <code>WASM</code> compiler.
<ul>
<li><code>wasmedgec</code> compiles a general <code>WASM</code> file into a <code>dyld</code> file.</li>
<li>To disable building the ahead-of-time compiler only, you can set the CMake option <code>WASMEDGE_BUILD_AOT_RUNTIME</code> to <code>OFF</code>.</li>
</ul>
</li>
<li><code>libwasmedge_c.dyld</code> is the WasmEdge C API shared library.
<ul>
<li><code>libwasmedge_c.dyld</code> provides C API for the ahead-of-time compiler and the WASM runtime.</li>
<li>The APIs about the ahead-of-time compiler will always return failed if the CMake option <code>WASMEDGE_BUILD_AOT_RUNTIME</code> is set as <code>OFF</code>.</li>
<li>To disable building the shared library only, you can set the CMake option <code>WASMEDGE_BUILD_SHARED_LIB</code> to <code>OFF</code>.</li>
</ul>
</li>
</ol>
<pre><code class="language-bash">$vsPath = (vswhere -latest -property installationPath)
Import-Module (Join-Path $vsPath &quot;Common7\Tools\Microsoft.VisualStudio.DevShell.dll&quot;)
Enter-VsDevShell -VsInstallPath $vsPath -SkipAutomaticLocation -DevCmdArguments &quot;-arch=x64 -host_arch=x64 -winsdk=10.0.19041.0&quot;

cmake -Bbuild -GNinja -DCMAKE_SYSTEM_VERSION=10.0.19041.0 -DCMAKE_MSVC_RUNTIME_LIBRARY=MultiThreadedDLL &quot;-DLLVM_DIR=$llvm_dir&quot; -DWASMEDGE_BUILD_TESTS=ON -DWASMEDGE_BUILD_PACKAGE=&quot;ZIP&quot; .
cmake --build build
</code></pre>
<h2 id="run-built-in-tests-2"><a class="header" href="#run-built-in-tests-2">Run built-in tests</a></h2>
<p>The following built-in tests are only available when the build flag <code>WASMEDGE_BUILD_TESTS</code> sets to <code>ON</code>.</p>
<p>Users can use these tests to verify the correctness of WasmEdge binaries.</p>
<pre><code class="language-bash">$vsPath = (vswhere -latest -property installationPath)
Import-Module (Join-Path $vsPath &quot;Common7\Tools\Microsoft.VisualStudio.DevShell.dll&quot;)
Enter-VsDevShell -VsInstallPath $vsPath -SkipAutomaticLocation -DevCmdArguments &quot;-arch=x64 -host_arch=x64 -winsdk=10.0.19041.0&quot;

$Env:PATH += &quot;;$pwd\\build\\lib\\api&quot;
cd build
ctest --output-on-failure
cd -
</code></pre>
<h2 id="run-applications-2"><a class="header" href="#run-applications-2">Run applications</a></h2>
<p>Next, follow <a href="extend/run.html">this guide</a> to run WebAssembly bytecode programs in <code>wasmedge</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="wasmedge-plug-in-api"><a class="header" href="#wasmedge-plug-in-api">WasmEdge plug-in API</a></h1>
<p>WasmEdge provides a C++ based API for registering extensions 
and host functions. While the WasmEdge language SDKs allow
registering host functions from a host (wrapping) application, the
plugin API allows such extensions to be incorporated into WasmEdge's
own building and releasing process.</p>
<p>In fact, the WasmEdge extensions for Tensorflow, image processing, 
key-value storage etc are all implemented using the plugin API. 
The plugin API is how you could contribute new functions to the
WasmEdge Runtime itself.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="host-functions-2"><a class="header" href="#host-functions-2">Host Functions</a></h1>
<p><a href="https://webassembly.github.io/spec/core/exec/runtime.html#syntax-hostfunc">Host functions</a> are functions outside WebAssembly and passed to WASM modules as imports. The following steps give an example of registering a <code>host module</code> into WasmEdge runtime.</p>
<p>This example is for the sources compile with the WasmEdge project in C++.
If developers want to implement the host functions in C/C++ with WasmEdge C API and without compiling with the WasmEdge project, please refer to the <a href="extend/plugin/c_api.html#host-functions">C API Documentation</a>.</p>
<h2 id="definitions-of-host-instances"><a class="header" href="#definitions-of-host-instances">Definitions of Host Instances</a></h2>
<p>WasmEdge supports registering <code>host function</code>, <code>memory</code>, <code>table</code>, and <code>global</code> instances as imports.
For more details, samples can be found in <code>include/host/wasi/</code> and <code>test/core/spectest.h</code>.</p>
<h3 id="functions-1"><a class="header" href="#functions-1">Functions</a></h3>
<p>A simple host function class can be declared as follows:</p>
<pre><code class="language-cpp">#include &quot;common/errcode.h&quot;
#include &quot;runtime/hostfunc.h&quot;
#include &quot;runtime/instance/memory.h&quot;

namespace WasmEdge {
namespace Host {

class TestHost : public Runtime::HostFunction&lt;TestHost&gt; {
public:
  Expect&lt;uint32_t&gt; body(Runtime::Instance::MemoryInstance *MemInst, uint32_t Param1, float Param2);
};

} // namespace Host
} // namespace WasmEdge
</code></pre>
<p>According to example, return type <code>Expect&lt;T&gt;</code> presents the expected return number type <code>T</code> of this host function. Types of <code>Param1</code> and <code>Param2</code> presents argument types of this <code>host function</code>. Only WASM built-in types (aka. <code>uint32_t</code>, <code>uint64_t</code>, <code>float</code>, and <code>double</code>) are supported in <code>host functions</code>. When instantiating, the function signature of <code>vec(valtype) -&gt; resulttype</code> is generated and can be imported by WASM modules.</p>
<p>Note: In the current state, only a single value returning is supported.</p>
<p>Another situation is passing environments or information which need to be accessed by <code>host function</code> body. The following sample shows how to implement host function clusters:</p>
<pre><code class="language-cpp">#include &quot;common/errcode.h&quot;
#include &quot;runtime/hostfunc.h&quot;
#include &quot;runtime/instance/memory.h&quot;
#include &lt;vector&gt;

namespace WasmEdge {
namespace Host {

template &lt;typename T&gt; class TestCluster : public Runtime::HostFunction&lt;T&gt; {
public:
  TestCluster(std::vector&lt;uint8_t&gt; &amp;Vec) : Data(Vec) {}

protected:
  std::vector&lt;uint8_t&gt; &amp;Data;
};

class TestHost1 : public TestCluster&lt;TestHost1&gt; {
public:
  TestHost1(std::vector&lt;uint8_t&gt; &amp;Vec) : TestCluster(Vec) {}
  Expect&lt;uint32_t&gt; body(Runtime::Instance::MemoryInstance *MemInst, uint32_t Param1, float Param2) {
    /// Operations to `Data` ...
    return {};
  }
};

class TestHost2 : public TestCluster&lt;TestHost2&gt; {
public:
  TestHost2(std::vector&lt;uint8_t&gt; &amp;Vec) : TestCluster(Vec) {}
  Expect&lt;uint64_t&gt; body(Runtime::Instance::MemoryInstance *MemInst, uint64_t Param1, double Param2) {
    /// Operations to `Data` ...
    return {};
  }
};

} // namespace Host
} // namespace WasmEdge
</code></pre>
<h3 id="tables-memories-and-globals"><a class="header" href="#tables-memories-and-globals">Tables, Memories, and Globals</a></h3>
<p>To create a <code>host table</code>, <code>memory</code>, and <code>global</code> instance, the only way is to create them with their constructor in the <code>host module</code>. The following chapter about the <code>host module</code> will provide examples.</p>
<h2 id="host-modules"><a class="header" href="#host-modules">Host Modules</a></h2>
<p><code>Host module</code> is an object which can be registered into WasmEdge runtime. <code>Host module</code> contains <code>host functions</code>, <code>tables</code>, <code>memories</code>, <code>globals</code>, and other user-customized data. WasmEdge provides API to register <code>host modules</code>. After registering, these host instances in the <code>host module</code> can be imported by WASM modules.</p>
<h3 id="declaration"><a class="header" href="#declaration">Declaration</a></h3>
<p><code>Host module</code> supplies exported module name and can contain customized data. A module name is needed when constructing <code>host modules</code>.</p>
<pre><code class="language-cpp">#include &quot;common/errcode.h&quot;
#include &quot;runtime/hostfunc.h&quot;
#include &quot;runtime/importobj.h&quot;

namespace WasmEdge {
namespace Host {

class TestModule : public Runtime::ImportObject {
public:
  TestModule() : ImportObject(&quot;test&quot;);
  virtual ~TestModule() = default;
};

} // namespace Host
} // namespace WasmEdge
</code></pre>
<h3 id="add-instances"><a class="header" href="#add-instances">Add Instances</a></h3>
<p><code>Host module</code> provides <code>addHostFunc()</code>, <code>addHostTable()</code>, <code>addHostMemory()</code>, and <code>addHostGlobal()</code> to insert instances with their unique names. Insertion can be done in constructor. The following example also shows how to create <code>host memories</code>, <code>tables</code>, and <code>globals</code>.</p>
<pre><code class="language-cpp">#include &quot;common/errcode.h&quot;
#include &quot;runtime/hostfunc.h&quot;
#include &quot;runtime/importobj.h&quot;
#include &lt;memory&gt;
#include &lt;vector&gt;

namespace WasmEdge {
namespace Host {

template &lt;typename T&gt; class TestCluster : public Runtime::HostFunction&lt;T&gt; {
public:
  TestCluster(std::vector&lt;uint8_t&gt; &amp;Vec) : Data(Vec) {}

protected:
  std::vector&lt;uint8_t&gt; &amp;Data;
};

class TestHost1 : public TestCluster&lt;TestHost1&gt; {
public:
  TestHost1(std::vector&lt;uint8_t&gt; &amp;Vec) : TestCluster(Vec) {}
  Expect&lt;uint32_t&gt; body(Runtime::Instance::MemoryInstance *MemInst, uint32_t Param1, float Param2) {
    /// Operations to `Data` ...
    return {};
  }
};

class TestHost2 : public TestCluster&lt;TestHost2&gt; {
public:
  TestHost2(std::vector&lt;uint8_t&gt; &amp;Vec) : TestCluster(Vec) {}
  Expect&lt;uint64_t&gt; body(Runtime::Instance::MemoryInstance *MemInst, uint64_t Param1, double Param2) {
    /// Operations to `Data` ...
    return {};
  }
};

class TestModule : public Runtime::ImportObject {
public:
  TestModule(std::vector&lt;uint8_t&gt; &amp;Vec) : ImportObject(&quot;test&quot;), Data(Vec) {
    /// Add function instances with exporting name
    addHostFunc(&quot;test_func1&quot;, std::make_unique&lt;TestHost1&gt;(Data));
    addHostFunc(&quot;test_func2&quot;, std::make_unique&lt;TestHost2&gt;(Data));

    /// Add table instance with exporting name
    addHostTable(&quot;table&quot;, std::make_unique&lt;Runtime::Instance::TableInstance&gt;(
                              TableType(RefType::FuncRef, 10, 20)));

    /// Add memory instance with exporting name
    addHostMemory(&quot;memory&quot;, std::make_unique&lt;Runtime::Instance::MemoryInstance&gt;(
                                MemoryType(1, 2)));

    /// Add global instance with exporting name
    addHostGlobal(&quot;global_i32&quot;,
                  std::make_unique&lt;Runtime::Instance::GlobalInstance&gt;(
                      GlobalType(ValType::I32, ValMut::Const), uint32_t(666)));
    addHostGlobal(&quot;global_i64&quot;,
                  std::make_unique&lt;Runtime::Instance::GlobalInstance&gt;(
                      GlobalType(ValType::I64, ValMut::Const), uint64_t(666)));
    addHostGlobal(&quot;global_f32&quot;,
                  std::make_unique&lt;Runtime::Instance::GlobalInstance&gt;(
                      GlobalType(ValType::F32, ValMut::Const), float(666)));
    addHostGlobal(&quot;global_f64&quot;,
                  std::make_unique&lt;Runtime::Instance::GlobalInstance&gt;(
                      GlobalType(ValType::F64, ValMut::Const), double(666)));
  }
  virtual ~TestModule() = default;

private:
  std::vector&lt;uint8_t&gt; &amp;Data;
};

} // namespace Host
} // namespace WasmEdge
</code></pre>
<p><code>Host module</code> supplies <code>getFuncs()</code>, <code>getTables()</code>, <code>getMems()</code>, and <code>getGlobals()</code> to search registered instances by unique exporting name. For more details, APIs can be found in <code>include/runtime/importobj.h</code>.</p>
<h3 id="register-host-modules-to-wasmedge"><a class="header" href="#register-host-modules-to-wasmedge">Register Host Modules to WasmEdge</a></h3>
<p>Users can register host modules via <code>WasmEdge::VM::registerModule()</code> API.</p>
<pre><code class="language-cpp">#include &quot;common/configure.h&quot;
#include &quot;vm/vm.h&quot;
#include &lt;vector&gt;

WasmEdge::Configure Conf;
WasmEdge::VM::VM VM(Conf);
std::vector&lt;uint8_t&gt; Data;
WasmEdge::Host::TestModule TestMod(Data);
VM.registerModule(TestMod);
</code></pre>
<h3 id="link-libraries-and-include-directories-in-cmakefile"><a class="header" href="#link-libraries-and-include-directories-in-cmakefile">Link Libraries And Include Directories in CMakeFile</a></h3>
<p>For finding headers from WasmEdge include directories and linking static libraries, some settings are necessary for CMakeFile:</p>
<pre><code>add_library(wasmedgeHostModuleTest  # Static library name of host modules
  test.cpp  # Path to host modules cpp files
)

target_include_directories(wasmedgeHostModuleTest
  PUBLIC
  ${Boost_INCLUDE_DIRS}
  ${PROJECT_SOURCE_DIR}/include
)
</code></pre>
<h2 id="implementation-of-host-function-body"><a class="header" href="#implementation-of-host-function-body">Implementation of Host Function Body</a></h2>
<p>There are some tips about implementing host function bodies.</p>
<h3 id="checking-memory-instance-when-using"><a class="header" href="#checking-memory-instance-when-using">Checking Memory Instance When Using</a></h3>
<p>Host function can access WASM memory, which passed as <code>MemoryInstance *</code> argument. When a <a href="https://webassembly.github.io/spec/core/exec/instructions.html#function-calls">function call occurs</a>, a frame with module which the called function belonging to will be pushed onto the <code>stack</code>. In the <code>host function</code> case, the <code>memory</code> instance of the module of the top frame on the <code>stack</code> will be passed as the <code>host function</code> body's argument. But there can be no <code>memory</code> instance in a WASM module. Therefore, users should check if the memory instance pointer is a <code>nullptr</code> or not when accessing.</p>
<h3 id="returning-expectation"><a class="header" href="#returning-expectation">Returning Expectation</a></h3>
<p>From our mechanism, <code>Expect&lt;T&gt;</code> declared in <code>include/common/errcode.h</code> is used as the result type of function body. In <code>Expect&lt;void&gt;</code> case, <code>return {};</code> is needed for an expected situation. In other cases, <code>return Value;</code> is needed, where <code>Value</code> is a variable of type <code>T</code>. If an unexpected situation occurs, users can call <code>return Unexpect(Code);</code> to return an error, which <code>Code</code> is an element of enumeration <code>ErrCode</code>.</p>
<h3 id="forcing-termination"><a class="header" href="#forcing-termination">Forcing Termination</a></h3>
<p>WasmEdge provides a method for terminating WASM execution in host functions. Developers can return <code>ErrCode::Terminated</code> to trigger the forcing termination of the current execution and pass the <code>ErrCode::Terminated</code> to the caller of the host functions.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="customized-external-references"><a class="header" href="#customized-external-references">Customized External References</a></h1>
<p><a href="https://webassembly.github.io/reference-types/core/syntax/types.html#syntax-reftype">External References</a> denotes an opaque and unforgeable reference to a host object. A new <code>externref</code> type can be passed into a Wasm module or return from it. The Wasm module cannot reveal an <code>externref</code> value's bit pattern, nor create a fake host reference by an integer value.</p>
<h2 id="tutorial"><a class="header" href="#tutorial">Tutorial</a></h2>
<p>The following tutorial is the summary of the <code>externref</code> example in WasmEdge.</p>
<h3 id="prepare-your-wasm-file"><a class="header" href="#prepare-your-wasm-file">Prepare Your Wasm File</a></h3>
<p>The Wasm file should contain importing host functions that would take the <code>externref</code>.
Take <a href="extend/plugin/../test/externref/externrefTestData/funcs.wasm">the test WASM file</a> (<a href="extend/plugin/../test/externref/externrefTestData/funcs.wat">this WAT</a> is the corresponding text format) as an example:</p>
<pre><code>(module
  (type $t0 (func (param externref i32) (result i32)))
  (type $t1 (func (param externref i32 i32) (result i32)))
  (type $t2 (func (param externref externref i32 i32) (result i32)))
  (import &quot;extern_module&quot; &quot;functor_square&quot; (func $functor_square (type $t0)))
  (import &quot;extern_module&quot; &quot;class_add&quot; (func $class_add (type $t1)))
  (import &quot;extern_module&quot; &quot;func_mul&quot; (func $func_mul (type $t1)))
  (func $call_add (export &quot;call_add&quot;) (type $t1) (param $p0 externref) (param $p1 i32) (param $p2 i32) (result i32)
    (call $class_add
      (local.get $p0)
      (local.get $p1)
      (local.get $p2)))
  (func $call_mul (export &quot;call_mul&quot;) (type $t1) (param $p0 externref) (param $p1 i32) (param $p2 i32) (result i32)
    (call $func_mul
      (local.get $p0)
      (local.get $p1)
      (local.get $p2)))
  (func $call_square (export &quot;call_square&quot;) (type $t0) (param $p0 externref) (param $p1 i32) (result i32)
    (call $functor_square
      (local.get $p0)
      (local.get $p1)))
  (func $call_add_square (export &quot;call_add_square&quot;) (type $t2) (param $p0 externref) (param $p1 externref) (param $p2 i32) (param $p3 i32) (result i32)
    (call $functor_square
      (local.get $p1)
      (call $class_add
        (local.get $p0)
        (local.get $p2)
        (local.get $p3))))
  (memory $memory (export &quot;memory&quot;) 1))
</code></pre>
<p>Users can convert <code>wat</code> to <code>wasm</code> through <a href="https://webassembly.github.io/wabt/demo/wat2wasm/">wat2wasm</a> live tool. Noted that <code>reference types</code> checkbox should be checked on this page.</p>
<h3 id="implement-host-module-and-register-into-wasmedge"><a class="header" href="#implement-host-module-and-register-into-wasmedge">Implement Host Module and Register into WasmEdge</a></h3>
<p>The host module should be implemented and registered into WasmEdge before executing Wasm. Assume that the following code is saved as <code>main.c</code>:</p>
<pre><code class="language-cpp">#include &lt;wasmedge/wasmedge.h&gt;

#include &lt;stdio.h&gt;

uint32_t SquareFunc(uint32_t A) { return A * A; }
uint32_t AddFunc(uint32_t A, uint32_t B) { return A + B; }
uint32_t MulFunc(uint32_t A, uint32_t B) { return A * B; }

/// Host function to call `SquareFunc` by external reference
WasmEdge_Result ExternSquare(void *Data, WasmEdge_MemoryInstanceContext *MemCxt,
                             const WasmEdge_Value *In, WasmEdge_Value *Out) {
  /// Function type: {externref, i32} -&gt; {i32}
  uint32_t (*Func)(uint32_t) = WasmEdge_ValueGetExternRef(In[0]);
  uint32_t C = Func(WasmEdge_ValueGetI32(In[1]));
  Out[0] = WasmEdge_ValueGenI32(C);
  return WasmEdge_Result_Success;
}

/// Host function to call `AddFunc` by external reference
WasmEdge_Result ExternAdd(void *Data, WasmEdge_MemoryInstanceContext *MemCxt,
                          const WasmEdge_Value *In, WasmEdge_Value *Out) {
  /// Function type: {externref, i32, i32} -&gt; {i32}
  uint32_t (*Func)(uint32_t, uint32_t) = WasmEdge_ValueGetExternRef(In[0]);
  uint32_t C = Func(WasmEdge_ValueGetI32(In[1]), WasmEdge_ValueGetI32(In[2]));
  Out[0] = WasmEdge_ValueGenI32(C);
  return WasmEdge_Result_Success;
}

/// Host function to call `ExternMul` by external reference
WasmEdge_Result ExternMul(void *Data, WasmEdge_MemoryInstanceContext *MemCxt,
                          const WasmEdge_Value *In, WasmEdge_Value *Out) {
  /// Function type: {externref, i32, i32} -&gt; {i32}
  uint32_t (*Func)(uint32_t, uint32_t) = WasmEdge_ValueGetExternRef(In[0]);
  uint32_t C = Func(WasmEdge_ValueGetI32(In[1]), WasmEdge_ValueGetI32(In[2]));
  Out[0] = WasmEdge_ValueGenI32(C);
  return WasmEdge_Result_Success;
}

/// Helper function to create the &quot;extern_module&quot; import object.
WasmEdge_ImportObjectContext *CreateExternModule() {
  WasmEdge_String HostName;
  WasmEdge_FunctionTypeContext *HostFType = NULL;
  WasmEdge_FunctionInstanceContext *HostFunc = NULL;
  enum WasmEdge_ValType P[3], R[1];

  HostName = WasmEdge_StringCreateByCString(&quot;extern_module&quot;);
  WasmEdge_ImportObjectContext *ImpObj = WasmEdge_ImportObjectCreate(HostName);
  WasmEdge_StringDelete(HostName);

  /// Add host function &quot;functor_square&quot;: {externref, i32} -&gt; {i32}
  P[0] = WasmEdge_ValType_ExternRef;
  P[1] = WasmEdge_ValType_I32;
  R[0] = WasmEdge_ValType_I32;
  HostFType = WasmEdge_FunctionTypeCreate(P, 2, R, 1);
  HostFunc = WasmEdge_FunctionInstanceCreate(HostFType, ExternSquare, NULL, 0);
  WasmEdge_FunctionTypeDelete(HostFType);
  HostName = WasmEdge_StringCreateByCString(&quot;functor_square&quot;);
  WasmEdge_ImportObjectAddFunction(ImpObj, HostName, HostFunc);
  WasmEdge_StringDelete(HostName);

  /// Add host function &quot;class_add&quot;: {externref, i32, i32} -&gt; {i32}
  P[2] = WasmEdge_ValType_I32;
  HostFType = WasmEdge_FunctionTypeCreate(P, 3, R, 1);
  HostFunc = WasmEdge_FunctionInstanceCreate(HostFType, ExternAdd, NULL, 0);
  WasmEdge_FunctionTypeDelete(HostFType);
  HostName = WasmEdge_StringCreateByCString(&quot;class_add&quot;);
  WasmEdge_ImportObjectAddFunction(ImpObj, HostName, HostFunc);
  WasmEdge_StringDelete(HostName);

  /// Add host function &quot;func_mul&quot;: {externref, i32, i32} -&gt; {i32}
  HostFType = WasmEdge_FunctionTypeCreate(P, 3, R, 1);
  HostFunc = WasmEdge_FunctionInstanceCreate(HostFType, ExternMul, NULL, 0);
  WasmEdge_FunctionTypeDelete(HostFType);
  HostName = WasmEdge_StringCreateByCString(&quot;func_mul&quot;);
  WasmEdge_ImportObjectAddFunction(ImpObj, HostName, HostFunc);
  WasmEdge_StringDelete(HostName);

  return ImpObj;
}

int main() {
  WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(NULL, NULL);
  WasmEdge_ImportObjectContext *ImpObj = CreateExternModule();
  WasmEdge_Value P[3], R[1];
  WasmEdge_String FuncName;
  WasmEdge_Result Res;

  Res = WasmEdge_VMRegisterModuleFromImport(VMCxt, ImpObj);
  if (!WasmEdge_ResultOK(Res)) {
    printf(&quot;Import object registration failed\n&quot;);
    return EXIT_FAILURE;
  }
  Res = WasmEdge_VMLoadWasmFromFile(VMCxt, &quot;funcs.wasm&quot;);
  if (!WasmEdge_ResultOK(Res)) {
    printf(&quot;WASM file loading failed\n&quot;);
    return EXIT_FAILURE;
  }
  Res = WasmEdge_VMValidate(VMCxt);
  if (!WasmEdge_ResultOK(Res)) {
    printf(&quot;WASM validation failed\n&quot;);
    return EXIT_FAILURE;
  }
  Res = WasmEdge_VMInstantiate(VMCxt);
  if (!WasmEdge_ResultOK(Res)) {
    printf(&quot;WASM instantiation failed\n&quot;);
    return EXIT_FAILURE;
  }

  /// Test 1: call add -- 1234 + 5678
  P[0] = WasmEdge_ValueGenExternRef(AddFunc);
  P[1] = WasmEdge_ValueGenI32(1234);
  P[2] = WasmEdge_ValueGenI32(5678);
  FuncName = WasmEdge_StringCreateByCString(&quot;call_add&quot;);
  Res = WasmEdge_VMExecute(VMCxt, FuncName, P, 3, R, 1);
  WasmEdge_StringDelete(FuncName);
  if (WasmEdge_ResultOK(Res)) {
    printf(&quot;Test 1 -- `call_add` -- 1234 + 5678 = %d\n&quot;,
           WasmEdge_ValueGetI32(R[0]));
  } else {
    printf(&quot;Test 1 -- `call_add` -- 1234 + 5678 -- failed\n&quot;);
    return EXIT_FAILURE;
  }

  /// Test 2: call mul -- 789 * 4321
  P[0] = WasmEdge_ValueGenExternRef(MulFunc);
  P[1] = WasmEdge_ValueGenI32(789);
  P[2] = WasmEdge_ValueGenI32(4321);
  FuncName = WasmEdge_StringCreateByCString(&quot;call_mul&quot;);
  Res = WasmEdge_VMExecute(VMCxt, FuncName, P, 3, R, 1);
  WasmEdge_StringDelete(FuncName);
  if (WasmEdge_ResultOK(Res)) {
    printf(&quot;Test 2 -- `call_mul` -- 789 * 4321 = %d\n&quot;,
           WasmEdge_ValueGetI32(R[0]));
  } else {
    printf(&quot;Test 2 -- `call_mul` -- 789 * 4321 -- failed\n&quot;);
    return EXIT_FAILURE;
  }

  /// Test 3: call square -- 8256^2
  P[0] = WasmEdge_ValueGenExternRef(SquareFunc);
  P[1] = WasmEdge_ValueGenI32(8256);
  FuncName = WasmEdge_StringCreateByCString(&quot;call_square&quot;);
  Res = WasmEdge_VMExecute(VMCxt, FuncName, P, 2, R, 1);
  if (WasmEdge_ResultOK(Res)) {
    printf(&quot;Test 3 -- `call_mul` -- 8256 ^ 2 = %d\n&quot;,
           WasmEdge_ValueGetI32(R[0]));
  } else {
    printf(&quot;Test 3 -- `call_mul` -- 8256 ^ 2 -- failed\n&quot;);
    return EXIT_FAILURE;
  }

  return EXIT_SUCCESS;
}
</code></pre>
<h3 id="setup-the-environment-and-compile"><a class="header" href="#setup-the-environment-and-compile">Setup the Environment And Compile</a></h3>
<ol>
<li>
<p>Install the WasmEdge shared library.</p>
<p>Please refer to the <a href="extend/plugin/install.html">Installation</a> for details.</p>
</li>
<li>
<p>Prepare the WASM file and the <code>main.c</code> source file as above.</p>
</li>
<li>
<p>Compile</p>
<pre><code class="language-bash">$ gcc main.c -lwasmedge_c
# Or you can use g++ for the C++ case, or use the clang.
</code></pre>
</li>
<li>
<p>Run the Test</p>
<pre><code class="language-bash">$ ./a.out
Test 1 -- `call_add` -- 1234 + 5678 = 6912
Test 2 -- `call_mul` -- 789 * 4321 = 3409269
Test 3 -- `call_mul` -- 8256 ^ 2 = 68161536
</code></pre>
</li>
</ol>
<h2 id="wasm-module-with-external-references"><a class="header" href="#wasm-module-with-external-references">Wasm module with External References</a></h2>
<p>Take the following <code>wat</code> for example:</p>
<pre><code>(module
  (type $t0 (func (param externref i32) (result i32)))
  ;; Import a host function which type is {externref i32} -&gt; {i32}
  (import &quot;extern_module&quot; &quot;functor_square&quot; (func $functor_square (type $t0)))
  ;; Wasm function which type is {externref i32} -&gt; {i32} and exported as &quot;call_square&quot;
  (func $call_square (export &quot;call_square&quot;) (type $t0) (param $p0 externref) (param $p1 i32) (result i32)
    (call $functor_square (local.get $p0) (local.get $p1))
  )
  (memory $memory (export &quot;memory&quot;) 1))
</code></pre>
<p>The Wasm function &quot;<code>call_square</code>&quot; takes an <code>externref</code> parameter, and calls the imported host function <code>functor_square</code> with that <code>externref</code>.
Therefore, the <code>functor_square</code> host function can get the object reference when users call &quot;<code>call_square</code>&quot; Wasm function and pass the object's reference.</p>
<h2 id="wasmedge-externref-example"><a class="header" href="#wasmedge-externref-example">WasmEdge ExternRef Example</a></h2>
<p>The following examples are how to use <code>externref</code> in Wasm with WasmEdge C API.</p>
<h3 id="wasm-code"><a class="header" href="#wasm-code">Wasm Code</a></h3>
<p>The Wasm code must pass the <code>externref</code> to host functions that want to access it.
Take the following <code>wat</code> for example, which is a part of <a href="extend/plugin/../test/externref/externrefTestData/funcs.wat">the test WASM file</a>:</p>
<pre><code>(module
  (type $t0 (func (param externref i32 i32) (result i32)))
  (import &quot;extern_module&quot; &quot;func_mul&quot; (func $func_mul (type $t0)))
  (func $call_mul (export &quot;call_mul&quot;) (type $t0) (param $p0 externref) (param $p1 i32) (param $p2 i32) (result i32)
    (call $func_mul (local.get $p0) (local.get $p1) (local.get $p2))
  )
  (memory $memory (export &quot;memory&quot;) 1))
</code></pre>
<p>The host function &quot;<code>extern_module::func_mul</code>&quot; takes <code>externref</code> as a function pointer to multiply parameters 1 and 2 and then return the result. The exported Wasm function &quot;<code>call_mul</code>&quot; calls &quot;<code>func_mul</code>&quot; and pass the <code>externref</code> and 2 numbers as arguments.</p>
<h3 id="host-functions-3"><a class="header" href="#host-functions-3">Host Functions</a></h3>
<p>To instantiate the above example Wasm, the host functions must be registered into WasmEdge. See <a href="extend/plugin/c_api.html#host-functions">Host Functions</a> for more details.
The host functions which take <code>externref</code>s must know the original objects' types. We take the function pointer case for example.</p>
<pre><code class="language-c">/* Function to pass as function pointer. */
uint32_t MulFunc(uint32_t A, uint32_t B) { return A * B; }

/* Host function to call function by external reference as a function pointer */
WasmEdge_Result ExternMul(void *, WasmEdge_MemoryInstanceContext *,
                          const WasmEdge_Value *In, WasmEdge_Value *Out) {
  /* Function type: {externref, i32, i32} -&gt; {i32} */
  void *Ptr = WasmEdge_ValueGetExternRef(In[0]);
  uint32_t (*Obj)(uint32_t, uint32_t) = Ptr;
  /*
   * For C++, the `reinterpret_cast` is needed:
   * uint32_t (*Obj)(uint32_t, uint32_t) = 
   *   *reinterpret_cast&lt;uint32_t (*)(uint32_t, uint32_t)&gt;(Ptr);
   */
  uint32_t C = Obj(WasmEdge_ValueGetI32(In[1]), WasmEdge_ValueGetI32(In[2]));
  Out[0] = WasmEdge_ValueGenI32(C);
  return WasmEdge_Result_Success;
}
</code></pre>
<p>&quot;<code>MulFunc</code>&quot; is a function that will be passed into Wasm as <code>externref</code>. In the &quot;<code>func_mul</code>&quot; host function, users can use &quot;<code>WasmEdge_ValueGetExternRef</code>&quot; API to get the pointer from the <code>WasmEdge_Value</code> which contains a <code>externref</code>.</p>
<p>Developers can add the host functions with names into an import object.</p>
<pre><code class="language-c">/* Create an import object. */
WasmEdge_String HostName = WasmEdge_StringCreateByCString(&quot;extern_module&quot;);
WasmEdge_ImportObjectContext *ImpObj = WasmEdge_ImportObjectCreate(HostName);
WasmEdge_StringDelete(HostName);

/* Create a function instance and add into an import object. */
enum WasmEdge_ValType P[3], R[1];
P[0] = WasmEdge_ValType_ExternRef;
P[1] = WasmEdge_ValType_I32;
P[2] = WasmEdge_ValType_I32;
R[0] = WasmEdge_ValType_I32;
WasmEdge_FunctionTypeContext *HostFType = WasmEdge_FunctionTypeCreate(P, 3, R, 1);
WasmEdge_FunctionInstanceContext *HostFunc = WasmEdge_FunctionInstanceCreate(HostFType, ExternFuncMul, NULL, 0);
WasmEdge_FunctionTypeDelete(HostFType);
HostName = WasmEdge_StringCreateByCString(&quot;func_mul&quot;);
WasmEdge_ImportObjectAddFunction(ImpObj, HostName, HostFunc);
WasmEdge_StringDelete(HostName);

...
</code></pre>
<h3 id="execution"><a class="header" href="#execution">Execution</a></h3>
<p>Take <a href="extend/plugin/../test/externref/externrefTestData/funcs.wasm">the test WASM file</a> (<a href="extend/plugin/../test/externref/externrefTestData/funcs.wat">this WAT</a> is the corresponding text format) for example.
Assume that the <code>funcs.wasm</code> is copied into current directory.
The following is the example to execute WASM with <code>externref</code> through the WasmEdge C API.</p>
<pre><code class="language-c">/* Create the VM context. */
WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(NULL, NULL);
/* Create the import object context that contains the host functions. */
WasmEdge_ImportObjectContext *ImpObj = /* Ignored ... */;
/* Assume that the host functions are added into the import object above. */
WasmEdge_Value P[3], R[1];
WasmEdge_String FuncName;
WasmEdge_Result Res;

/* Register the import object into VM. */
Res = WasmEdge_VMRegisterModuleFromImport(VMCxt, ImpObj);
if (!WasmEdge_ResultOK(Res)) {
  printf(&quot;Import object registration failed\n&quot;);
  return EXIT_FAILURE;
}
/* Load WASM from file. */
Res = WasmEdge_VMLoadWasmFromFile(VMCxt, &quot;funcs.wasm&quot;);
if (!WasmEdge_ResultOK(Res)) {
  printf(&quot;WASM file loading failed\n&quot;);
  return EXIT_FAILURE;
}
/* Validate WASM. */
Res = WasmEdge_VMValidate(VMCxt);
if (!WasmEdge_ResultOK(Res)) {
  printf(&quot;WASM validation failed\n&quot;);
  return EXIT_FAILURE;
}
/* Instantiate the WASM module. */
Res = WasmEdge_VMInstantiate(VMCxt);
if (!WasmEdge_ResultOK(Res)) {
  printf(&quot;WASM instantiation failed\n&quot;);
  return EXIT_FAILURE;
}

/* Run a WASM function. */
P[0] = WasmEdge_ValueGenExternRef(AddFunc);
P[1] = WasmEdge_ValueGenI32(1234);
P[2] = WasmEdge_ValueGenI32(5678);
/* Run the `call_add` function. */
FuncName = WasmEdge_StringCreateByCString(&quot;call_add&quot;);
Res = WasmEdge_VMExecute(VMCxt, FuncName, P, 3, R, 1);
WasmEdge_StringDelete(FuncName);
if (WasmEdge_ResultOK(Res)) {
  printf(&quot;Run -- `call_add` -- 1234 + 5678 = %d\n&quot;,
          WasmEdge_ValueGetI32(R[0]));
} else {
  printf(&quot;Run -- `call_add` -- 1234 + 5678 -- failed\n&quot;);
  return EXIT_FAILURE;
}
</code></pre>
<h2 id="passing-objects"><a class="header" href="#passing-objects">Passing Objects</a></h2>
<p>The above example is passing a function reference as <code>externref</code>. The following examples are about how to pass an object reference into WASM as <code>externref</code> in C++.</p>
<h3 id="passing-a-class"><a class="header" href="#passing-a-class">Passing a Class</a></h3>
<p>To pass a class as <code>externref</code>, the object instance is needed.</p>
<pre><code class="language-cpp">class AddClass {
public:
  uint32_t add(uint32_t A, uint32_t B) const { return A + B; }
};

AddClass AC;
</code></pre>
<p>Then users can pass the object into WasmEdge by using <code>WasmEdge_ValueGenExternRef()</code> API.</p>
<pre><code class="language-cpp">WasmEdge_Value P[3], R[1];
P[0] = WasmEdge_ValueGenExternRef(&amp;AC);
P[1] = WasmEdge_ValueGenI32(1234);
P[2] = WasmEdge_ValueGenI32(5678);
WasmEdge_String FuncName = WasmEdge_StringCreateByCString(&quot;call_add&quot;);
WasmEdge_Result Res = WasmEdge_VMExecute(VMCxt, FuncName, P, 3, R, 1);
WasmEdge_StringDelete(FuncName);
if (WasmEdge_ResultOK(Res)) {
  std::cout &lt;&lt; &quot;Result : &quot; &lt;&lt; WasmEdge_ValueGetI32(R[0]) std::endl;
  /// Will print `6912`.
} else {
  return EXIT_FAILURE;
}
</code></pre>
<p>In the host function which would access the object by reference, users can use the <code>WasmEdge_ValueGetExternRef()</code> API to retrieve the reference to the object.</p>
<pre><code class="language-cpp">/// Modify the `ExternAdd` in the above tutorial.
WasmEdge_Result ExternAdd(void *, WasmEdge_MemoryInstanceContext *,
                          const WasmEdge_Value *In, WasmEdge_Value *Out) {
  /// Function type: {externref, i32, i32} -&gt; {i32}
  void *Ptr = WasmEdge_ValueGetExternRef(In[0]);
  AddClass &amp;Obj = *reinterpret_cast&lt;AddClass *&gt;(Ptr);
  uint32_t C =
      Obj.add(WasmEdge_ValueGetI32(In[1]), WasmEdge_ValueGetI32(In[2]));
  Out[0] = WasmEdge_ValueGenI32(C);
  return WasmEdge_Result_Success;
}
</code></pre>
<h3 id="passing-an-object-as-functor"><a class="header" href="#passing-an-object-as-functor">Passing an Object As Functor</a></h3>
<p>As the same as passing a class instance, the functor object instance is needed.</p>
<pre><code class="language-cpp">struct SquareStruct {
  uint32_t operator()(uint32_t Val) const { return Val * Val; }
};

SquareStruct SS;
</code></pre>
<p>Then users can pass the object into WasmEdge by using the <code>WasmEdge_ValueGenExternRef()</code> API.</p>
<pre><code class="language-cpp">WasmEdge_Value P[2], R[1];
P[0] = WasmEdge_ValueGenExternRef(&amp;SS);
P[1] = WasmEdge_ValueGenI32(1024);
WasmEdge_String FuncName = WasmEdge_StringCreateByCString(&quot;call_square&quot;);
WasmEdge_Result Res = WasmEdge_VMExecute(VMCxt, FuncName, P, 2, R, 1);
WasmEdge_StringDelete(FuncName);
if (WasmEdge_ResultOK(Res)) {
  std::cout &lt;&lt; &quot;Result : &quot; &lt;&lt; WasmEdge_ValueGetI32(R[0]) std::endl;
  /// Will print `1048576`.
} else {
  return EXIT_FAILURE;
}
</code></pre>
<p>In the host function which would access the object by reference, users can use the <code>WasmEdge_ValueGetExternRef</code> API to retrieve the reference to the object, and the reference is a functor.</p>
<pre><code class="language-cpp">/// Modify the `ExternSquare` in the above tutorial.
WasmEdge_Result ExternSquare(void *, WasmEdge_MemoryInstanceContext *,
                          const WasmEdge_Value *In, WasmEdge_Value *Out) {
  /// Function type: {externref, i32, i32} -&gt; {i32}
  void *Ptr = WasmEdge_ValueGetExternRef(In[0]);
  SquareStruct &amp;Obj = *reinterpret_cast&lt;SquareStruct *&gt;(Ptr);
  uint32_t C = Obj(WasmEdge_ValueGetI32(In[1]));
  Out[0] = WasmEdge_ValueGenI32(C);
  return WasmEdge_Result_Success;
}
</code></pre>
<h3 id="passing-stl-objects"><a class="header" href="#passing-stl-objects">Passing STL Objects</a></h3>
<p>The <a href="extend/plugin/../test/externref/externrefTestData/stl.wasm">example Wasm binary</a> (<a href="extend/plugin/../test/externref/externrefTestData/stl.wat">this WAT</a> is the corresponding text format) provides functions to interact with host functions which can access C++ STL objects.
Assume that the WASM file <code>stl.wasm</code> is copied into the current directory.</p>
<p>Take the <code>std::ostream</code> and <code>std::string</code> objects for example. Assume that there's a host function accesses to a <code>std::ostream</code> and a <code>std::string</code> through <code>externref</code>s:</p>
<pre><code class="language-cpp">/// Host function to output std::string through std::ostream
WasmEdge_Result ExternSTLOStreamStr(void *, WasmEdge_MemoryInstanceContext *,
                                    const WasmEdge_Value *In,
                                    WasmEdge_Value *) {
  /// Function type: {externref, externref} -&gt; {}
  void *Ptr0 = WasmEdge_ValueGetExternRef(In[0]);
  void *Ptr1 = WasmEdge_ValueGetExternRef(In[1]);
  std::ostream &amp;RefOS = *reinterpret_cast&lt;std::ostream *&gt;(Ptr0);
  std::string &amp;RefStr = *reinterpret_cast&lt;std::string *&gt;(Ptr1);
  RefOS &lt;&lt; RefStr;
  return WasmEdge_Result_Success;
}
</code></pre>
<p>Assume that the above host function is added into an import object <code>ImpObj</code>, and the <code>ImpObj</code> is register into a VM context <code>VMCxt</code>.
Then users can instantiate the Wasm module:</p>
<pre><code class="language-cpp">WasmEdge_Result Res = WasmEdge_VMLoadWasmFromFile(VMCxt, &quot;stl.wasm&quot;);
if (!WasmEdge_ResultOK(Res)) {
  printf(&quot;WASM file loading failed\n&quot;);
  return EXIT_FAILURE;
}
Res = WasmEdge_VMValidate(VMCxt);
if (!WasmEdge_ResultOK(Res)) {
  printf(&quot;WASM validation failed\n&quot;);
  return EXIT_FAILURE;
}
Res = WasmEdge_VMInstantiate(VMCxt);
if (!WasmEdge_ResultOK(Res)) {
  printf(&quot;WASM instantiation failed\n&quot;);
  return EXIT_FAILURE;
}
</code></pre>
<p>Last, pass the <code>std::cout</code> and a <code>std::string</code> object by external references.</p>
<pre><code class="language-cpp">std::string PrintStr(&quot;Hello world!&quot;);
WasmEdge_Value P[2], R[1];
P[0] = WasmEdge_ValueGenExternRef(&amp;std::cout);
P[1] = WasmEdge_ValueGenExternRef(&amp;PrintStr);
WasmEdge_String FuncName = WasmEdge_StringCreateByCString(&quot;call_ostream_str&quot;);
WasmEdge_Result Res = WasmEdge_VMExecute(VMCxt, FuncName, P, 2, R, 1);
/// Will print &quot;Hello world!&quot; to stdout.
WasmEdge_StringDelete(FuncName);
if (!WasmEdge_ResultOK(Res)) {
  return EXIT_FAILURE;
}
</code></pre>
<p>For other C++ STL objects cases, such as <code>std::vector&lt;T&gt;</code>, <code>std::map&lt;T, U&gt;</code>, or <code>std::set&lt;T&gt;</code>, the object can be accessed correctly in host functions if the type in <code>reinterpret_cast</code> is correct.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
    </body>
</html>
