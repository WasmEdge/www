<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>WasmEdge Runtime</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-NGPCK7VF2L"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-NGPCK7VF2L');
</script>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item "><a href="index.html"><strong aria-hidden="true">1.</strong> Getting started</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="start/install.html"><strong aria-hidden="true">1.1.</strong> Install and uninstall</a></li><li class="chapter-item "><a href="start/docker.html"><strong aria-hidden="true">1.2.</strong> Use Docker</a></li><li class="chapter-item "><a href="start/cli.html"><strong aria-hidden="true">1.3.</strong> WasmEdge command line</a></li><li class="chapter-item "><a href="start/universal.html"><strong aria-hidden="true">1.4.</strong> Universal Binary</a></li></ol></li><li class="chapter-item "><a href="intro.html"><strong aria-hidden="true">2.</strong> What is WasmEdge</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="intro/use.html"><strong aria-hidden="true">2.1.</strong> Use cases</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="intro/use/jamstack.html"><strong aria-hidden="true">2.1.1.</strong> Server-side rendering</a></li><li class="chapter-item "><a href="intro/use/microservice.html"><strong aria-hidden="true">2.1.2.</strong> Microservices</a></li><li class="chapter-item "><a href="intro/use/saas.html"><strong aria-hidden="true">2.1.3.</strong> Serverless SaaS API</a></li><li class="chapter-item "><a href="intro/use/device.html"><strong aria-hidden="true">2.1.4.</strong> Smart devices</a></li></ol></li><li class="chapter-item "><a href="intro/features.html"><strong aria-hidden="true">2.2.</strong> Feature highlights</a></li><li class="chapter-item "><a href="intro/standard.html"><strong aria-hidden="true">2.3.</strong> Standard extensions</a></li><li class="chapter-item "><a href="intro/proprietary.html"><strong aria-hidden="true">2.4.</strong> Proprietary extensions</a></li><li class="chapter-item "><a href="intro/integrations.html"><strong aria-hidden="true">2.5.</strong> Integrations</a></li><li class="chapter-item "><a href="intro/faq.html"><strong aria-hidden="true">2.6.</strong> FAQ</a></li></ol></li><li class="chapter-item "><a href="dev.html"><strong aria-hidden="true">3.</strong> Develop a WasmEdge app</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="dev/rust.html"><strong aria-hidden="true">3.1.</strong> Rust</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="dev/rust/bindgen.html"><strong aria-hidden="true">3.1.1.</strong> Call Rust functions</a></li><li class="chapter-item "><a href="dev/rust/wasi.html"><strong aria-hidden="true">3.1.2.</strong> Access OS services</a></li><li class="chapter-item "><a href="dev/rust/tensorflow.html"><strong aria-hidden="true">3.1.3.</strong> Tensorflow</a></li><li class="chapter-item "><a href="dev/rust/networking.html"><strong aria-hidden="true">3.1.4.</strong> Simple HTTP client & server</a></li><li class="chapter-item "><a href="dev/rust/networking-nonblocking.html"><strong aria-hidden="true">3.1.5.</strong> Non-blocking network apps</a></li><li class="chapter-item "><a href="dev/rust/ssr.html"><strong aria-hidden="true">3.1.6.</strong> Server-side rendering</a></li><li class="chapter-item "><a href="dev/rust/command.html"><strong aria-hidden="true">3.1.7.</strong> Command interface</a></li></ol></li><li class="chapter-item "><a href="dev/js.html"><strong aria-hidden="true">3.2.</strong> JavaScript</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="dev/js/quickstart.html"><strong aria-hidden="true">3.2.1.</strong> Getting started</a></li><li class="chapter-item "><a href="dev/js/networking.html"><strong aria-hidden="true">3.2.2.</strong> Networking sockets</a></li><li class="chapter-item "><a href="dev/js/fetch.html"><strong aria-hidden="true">3.2.3.</strong> Fetch</a></li><li class="chapter-item "><a href="dev/js/tensorflow.html"><strong aria-hidden="true">3.2.4.</strong> Tensorflow</a></li><li class="chapter-item "><a href="dev/js/ssr.html"><strong aria-hidden="true">3.2.5.</strong> React SSR</a></li><li class="chapter-item "><a href="dev/js/es6.html"><strong aria-hidden="true">3.2.6.</strong> ES6 module</a></li><li class="chapter-item "><a href="dev/js/npm.html"><strong aria-hidden="true">3.2.7.</strong> NodeJS & NPM module</a></li><li class="chapter-item "><a href="dev/js/rust.html"><strong aria-hidden="true">3.2.8.</strong> Use Rust to implement JS API</a></li></ol></li><li class="chapter-item "><a href="dev/go.html"><strong aria-hidden="true">3.3.</strong> Go</a></li><li class="chapter-item "><a href="dev/swift.html"><strong aria-hidden="true">3.4.</strong> Swift</a></li><li class="chapter-item "><a href="dev/as.html"><strong aria-hidden="true">3.5.</strong> AssemblyScript</a></li><li class="chapter-item "><a href="dev/kotlin.html"><strong aria-hidden="true">3.6.</strong> Kotlin</a></li><li class="chapter-item "><a href="dev/grain.html"><strong aria-hidden="true">3.7.</strong> Grain</a></li><li class="chapter-item "><a href="dev/python.html"><strong aria-hidden="true">3.8.</strong> Python</a></li></ol></li><li class="chapter-item "><a href="embed.html"><strong aria-hidden="true">4.</strong> Embed WasmEdge functions</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="embed/c.html"><strong aria-hidden="true">4.1.</strong> C SDK</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="embed/c/ref.html"><strong aria-hidden="true">4.1.1.</strong> API references</a></li></ol></li><li class="chapter-item "><a href="embed/go.html"><strong aria-hidden="true">4.2.</strong> Go SDK</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="embed/go/app.html"><strong aria-hidden="true">4.2.1.</strong> Embed WASM apps</a></li><li class="chapter-item "><a href="embed/go/function.html"><strong aria-hidden="true">4.2.2.</strong> Embed WASM funcs</a></li><li class="chapter-item "><a href="embed/go/memory.html"><strong aria-hidden="true">4.2.3.</strong> Pass complex data</a></li><li class="chapter-item "><a href="embed/go/tensorflow.html"><strong aria-hidden="true">4.2.4.</strong> Tensorflow</a></li><li class="chapter-item "><a href="embed/go/bindgen.html"><strong aria-hidden="true">4.2.5.</strong> Embed bindgen funcs</a></li><li class="chapter-item "><a href="embed/go/ref.html"><strong aria-hidden="true">4.2.6.</strong> API references</a></li></ol></li><li class="chapter-item "><a href="embed/node.html"><strong aria-hidden="true">4.3.</strong> Node.js SDK</a></li><li class="chapter-item "><a href="embed/rust.html"><strong aria-hidden="true">4.4.</strong> Rust SDK</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="embed/rust/sys_run_host_func.html"><strong aria-hidden="true">4.4.1.</strong> Run a WebAssembly function with WasmEdge low-level APIs</a></li><li class="chapter-item "><a href="embed/rust/concurrent_fib.html"><strong aria-hidden="true">4.4.2.</strong> Compute Fibonacci numbers concurrently</a></li></ol></li><li class="chapter-item "><a href="embed/python.html"><strong aria-hidden="true">4.5.</strong> Python SDK</a></li></ol></li><li class="chapter-item "><a href="kubernetes.html"><strong aria-hidden="true">5.</strong> WasmEdge in Kubernetes</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="kubernetes/quickstart.html"><strong aria-hidden="true">5.1.</strong> Quick start</a></li><li class="chapter-item "><a href="kubernetes/demo.html"><strong aria-hidden="true">5.2.</strong> Demo apps</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="kubernetes/demo/wasi.html"><strong aria-hidden="true">5.2.1.</strong> Simple example</a></li><li class="chapter-item "><a href="kubernetes/demo/server.html"><strong aria-hidden="true">5.2.2.</strong> HTTP service</a></li></ol></li><li class="chapter-item "><a href="kubernetes/container.html"><strong aria-hidden="true">5.3.</strong> Container runtimes</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="kubernetes/container/crun.html"><strong aria-hidden="true">5.3.1.</strong> crun</a></li><li class="chapter-item "><a href="kubernetes/container/runc.html"><strong aria-hidden="true">5.3.2.</strong> runc</a></li><li class="chapter-item "><a href="kubernetes/container/youki.html"><strong aria-hidden="true">5.3.3.</strong> youki</a></li></ol></li><li class="chapter-item "><a href="kubernetes/cri.html"><strong aria-hidden="true">5.4.</strong> CRI runtimes</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="kubernetes/cri/crio.html"><strong aria-hidden="true">5.4.1.</strong> CRI-O</a></li><li class="chapter-item "><a href="kubernetes/cri/containerd.html"><strong aria-hidden="true">5.4.2.</strong> containerd</a></li></ol></li><li class="chapter-item "><a href="kubernetes/kubernetes.html"><strong aria-hidden="true">5.5.</strong> Kubernetes</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="kubernetes/kubernetes/kubernetes-crio.html"><strong aria-hidden="true">5.5.1.</strong> Kubernetes + CRI-O</a></li><li class="chapter-item "><a href="kubernetes/kubernetes/kubernetes-containerd.html"><strong aria-hidden="true">5.5.2.</strong> Kubernetes + containerd</a></li><li class="chapter-item "><a href="kubernetes/kubernetes/kind.html"><strong aria-hidden="true">5.5.3.</strong> KinD</a></li><li class="chapter-item "><a href="kubernetes/kubernetes/kubeedge.html"><strong aria-hidden="true">5.5.4.</strong> KubeEdge</a></li><li class="chapter-item "><a href="kubernetes/kubernetes/superedge.html"><strong aria-hidden="true">5.5.5.</strong> SuperEdge</a></li><li class="chapter-item "><a href="kubernetes/kubernetes/openyurt.html"><strong aria-hidden="true">5.5.6.</strong> OpenYurt</a></li></ol></li></ol></li><li class="chapter-item "><a href="frameworks.html"><strong aria-hidden="true">6.</strong> App frameworks & platforms</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="frameworks/mesh.html"><strong aria-hidden="true">6.1.</strong> Service mesh & runtimes</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="frameworks/mesh/dapr.html"><strong aria-hidden="true">6.1.1.</strong> Dapr</a></li><li class="chapter-item "><a href="frameworks/mesh/mosn.html"><strong aria-hidden="true">6.1.2.</strong> MOSN</a></li><li class="chapter-item "><a href="frameworks/mesh/eventmesh.html"><strong aria-hidden="true">6.1.3.</strong> Apache EventMesh</a></li></ol></li><li class="chapter-item "><a href="frameworks/app.html"><strong aria-hidden="true">6.2.</strong> Application frameworks</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="frameworks/app/yomo.html"><strong aria-hidden="true">6.2.1.</strong> YoMo</a></li><li class="chapter-item "><a href="frameworks/app/reactr.html"><strong aria-hidden="true">6.2.2.</strong> Reactr</a></li></ol></li><li class="chapter-item "><a href="frameworks/serverless.html"><strong aria-hidden="true">6.3.</strong> Serverless platforms</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="frameworks/serverless/vercel.html"><strong aria-hidden="true">6.3.1.</strong> Vercel</a></li><li class="chapter-item "><a href="frameworks/serverless/netlify.html"><strong aria-hidden="true">6.3.2.</strong> Netlify</a></li><li class="chapter-item "><a href="frameworks/serverless/aws.html"><strong aria-hidden="true">6.3.3.</strong> AWS</a></li><li class="chapter-item "><a href="frameworks/serverless/tencent.html"><strong aria-hidden="true">6.3.4.</strong> Tencent</a></li><li class="chapter-item "><a href="frameworks/serverless/secondstate.html"><strong aria-hidden="true">6.3.5.</strong> Second State</a></li></ol></li></ol></li><li class="chapter-item "><a href="os.html"><strong aria-hidden="true">7.</strong> Operating systems</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="os/linux.html"><strong aria-hidden="true">7.1.</strong> Linux</a></li><li class="chapter-item "><a href="os/windows.html"><strong aria-hidden="true">7.2.</strong> Windows</a></li><li class="chapter-item "><a href="os/mac.html"><strong aria-hidden="true">7.3.</strong> Mac</a></li><li class="chapter-item "><a href="os/android.html"><strong aria-hidden="true">7.4.</strong> Android</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="os/android/cli.html"><strong aria-hidden="true">7.4.1.</strong> CLI tools</a></li><li class="chapter-item "><a href="os/android/ndk.html"><strong aria-hidden="true">7.4.2.</strong> NDK native app</a></li><li class="chapter-item "><a href="os/android/apk.html"><strong aria-hidden="true">7.4.3.</strong> APK app</a></li></ol></li><li class="chapter-item "><a href="os/sel4.html"><strong aria-hidden="true">7.5.</strong> seL4</a></li><li class="chapter-item "><a href="os/openharmony.html"><strong aria-hidden="true">7.6.</strong> Open Harmony</a></li><li class="chapter-item "><a href="os/raspberrypi.html"><strong aria-hidden="true">7.7.</strong> Raspberry Pi</a></li></ol></li><li class="chapter-item "><a href="extend.html"><strong aria-hidden="true">8.</strong> Contribute to WasmEdge</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="extend/build.html"><strong aria-hidden="true">8.1.</strong> Build WasmEdge from source</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="extend/build_on_mac.html"><strong aria-hidden="true">8.1.1.</strong> Build for Mac</a></li><li class="chapter-item "><a href="extend/build_on_windows.html"><strong aria-hidden="true">8.1.2.</strong> Build for Windows</a></li><li class="chapter-item "><a href="extend/build_for_android.html"><strong aria-hidden="true">8.1.3.</strong> Build for Android</a></li></ol></li><li class="chapter-item "><a href="extend/plugin.html"><strong aria-hidden="true">8.2.</strong> WasmEdge plug-in API</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="extend/plugin/hostfunction.html"><strong aria-hidden="true">8.2.1.</strong> Host functions</a></li><li class="chapter-item "><a href="extend/plugin/externref.html"><strong aria-hidden="true">8.2.2.</strong> External references</a></li></ol></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">WasmEdge Runtime</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/WasmEdge/WasmEdge" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="getting-started"><a class="header" href="#getting-started">Getting started</a></h1>
<p>The easiest way to get started with WasmEdge is to use its command line tools (CLI).
You can then run our example WebAssembly and JavaScript programs in the WasmEdge CLI.
After that, you can create new programs for WasmEdge and run them in different host applications or frameworks.</p>
<h2 id="install"><a class="header" href="#install">Install</a></h2>
<p>You can install WasmEdge using our one-line installer.
Your system should have <code>git</code> and <code>curl</code> as prerequisites.</p>
<pre><code class="language-bash">curl -sSf https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/utils/install.sh | bash
</code></pre>
<p>For Windows 10, you could use Windows Package Manager Client (aka winget.exe) to install WasmEdge with a single command in your terminal.</p>
<pre><code class="language-bash">winget install wasmedge
</code></pre>
<p>If you would like to install WasmEdge with its <a href="https://www.secondstate.io/articles/wasi-tensorflow/">Tensorflow and image processing extensions</a>, please run the following command. It will attempt to install Tensorflow and image shared libraries on your system.</p>
<pre><code class="language-bash">curl -sSf https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/utils/install.sh | bash -s -- -e all
</code></pre>
<p>Run the following command to make the installed binary available in the current session.</p>
<pre><code class="language-bash">source $HOME/.wasmedge/env
</code></pre>
<h2 id="use-docker"><a class="header" href="#use-docker">Use Docker</a></h2>
<p>If you use Docker, you can simply run the WasmEdge application developer Docker images (<a href="https://hub.docker.com/repository/docker/wasmedge/appdev_x86_64">x86</a> and <a href="https://hub.docker.com/repository/docker/wasmedge/appdev_aarch64">arm64</a>). Those images contain all the tooling you need for quick WasmEdge development.</p>
<pre><code class="language-bash">$ docker pull wasmedge/appdev_x86_64:0.9.0
$ docker run --rm -v $(pwd):/app -it wasmedge/appdev_x86_64:0.9.0
(docker) #
</code></pre>
<h2 id="webassembly-examples"><a class="header" href="#webassembly-examples">WebAssembly examples</a></h2>
<p>We have several WebAssembly bytecode program examples for you to try out on your newly installed WasmEdge CLI.</p>
<h3 id="hello-world"><a class="header" href="#hello-world">Hello world</a></h3>
<p>The <a href="https://github.com/WasmEdge/WasmEdge/raw/master/tools/wasmedge/examples/hello.wasm">hello.wasm</a> WebAssembly program contains a <code>main()</code> function.
Checkout its <a href="https://github.com/second-state/wasm-learning/tree/master/cli/hello">Rust source code project</a>.
It prints out <code>hello</code> followed by the command line arguments.</p>
<pre><code class="language-bash">$ wasmedge hello.wasm second state
hello
second
state
</code></pre>
<h3 id="call-a-function-written-in-rust"><a class="header" href="#call-a-function-written-in-rust">Call a function written in Rust</a></h3>
<p>The <a href="https://github.com/WasmEdge/WasmEdge/raw/master/tools/wasmedge/examples/add.wasm">add.wasm</a> WebAssembly program contains an <code>add()</code> function.
Checkout its <a href="https://github.com/second-state/wasm-learning/tree/master/cli/add">Rust source code project</a>.
We use WasmEdge in reactor mode to call the <code>add()</code> with two integer input parameters.</p>
<pre><code class="language-bash">$ wasmedge --reactor add.wasm add 2 2
4
</code></pre>
<h3 id="call-a-function-written-in-wat"><a class="header" href="#call-a-function-written-in-wat">Call a function written in WAT</a></h3>
<p>We created the <a href="https://github.com/WasmEdge/WasmEdge/raw/master/tools/wasmedge/examples/fibonacci.wat">fibonacci.wat</a> program by hand and used the <a href="https://github.com/WebAssembly/wabt">wat2wasm</a> compiler to build the <a href="https://github.com/WasmEdge/WasmEdge/raw/master/tools/wasmedge/examples/fibonacci.wasm">fibonacci.wasm</a> WebAssembly program.
It contains a <code>fib()</code> function which takes a single integer as input parameter. We use wasmedge in reactor mode to call the exported function.</p>
<pre><code class="language-bash">$ wasmedge --reactor fibonacci.wasm fib 10
89
</code></pre>
<h3 id="with-statistics-enabled"><a class="header" href="#with-statistics-enabled">With Statistics enabled</a></h3>
<p>The CLI supports <code>--enable-all-statistics</code> flags for the statistics and gas meter.</p>
<pre><code class="language-bash">$ wasmedge --enable-all-statistics hello.wasm second state
hello
second
state
[2021-12-09 16:03:33.261] [info] ====================  Statistics  ====================
[2021-12-09 16:03:33.261] [info]  Total execution time: 268266 ns
[2021-12-09 16:03:33.261] [info]  Wasm instructions execution time: 251610 ns
[2021-12-09 16:03:33.261] [info]  Host functions execution time: 16656 ns
[2021-12-09 16:03:33.261] [info]  Executed wasm instructions count: 20425
[2021-12-09 16:03:33.261] [info]  Gas costs: 20425
[2021-12-09 16:03:33.261] [info]  Instructions per second: 81177218
[2021-12-09 16:03:33.261] [info] =======================   End   ======================
</code></pre>
<h3 id="with-gas-limit-enabled"><a class="header" href="#with-gas-limit-enabled">With gas-limit enabled</a></h3>
<p>The CLI supports <code>--gas-limit</code> flags for controlling the execution costs.</p>
<pre><code class="language-bash"># cd &lt;path/to/WasmEdge&gt;
$ cd tools/wasmedge/examples
# With enough gas
$ wasmedge --enable-all-statistics --gas-limit 20425 hello.wasm second state
hello
second
state
[2021-12-09 16:03:33.261] [info] ====================  Statistics  ====================
[2021-12-09 16:03:33.261] [info]  Total execution time: 268266 ns
[2021-12-09 16:03:33.261] [info]  Wasm instructions execution time: 251610 ns
[2021-12-09 16:03:33.261] [info]  Host functions execution time: 16656 ns
[2021-12-09 16:03:33.261] [info]  Executed wasm instructions count: 20425
[2021-12-09 16:03:33.261] [info]  Gas costs: 20425
[2021-12-09 16:03:33.261] [info]  Instructions per second: 81177218
[2021-12-09 16:03:33.261] [info] =======================   End   ======================

# Without enough gas
$ wasmedge --enable-all-statistics --gas-limit 20 hello.wasm second state
[2021-12-23 15:19:06.690] [error] Cost exceeded limit. Force terminate the execution.
[2021-12-23 15:19:06.690] [error]     In instruction: ref.func (0xd2) , Bytecode offset: 0x00000000
[2021-12-23 15:19:06.690] [error]     At AST node: expression
[2021-12-23 15:19:06.690] [error]     At AST node: element segment
[2021-12-23 15:19:06.690] [error]     At AST node: element section
[2021-12-23 15:19:06.690] [error]     At AST node: module
[2021-12-23 15:19:06.690] [info] ====================  Statistics  ====================
[2021-12-23 15:19:06.690] [info]  Total execution time: 0 ns
[2021-12-23 15:19:06.690] [info]  Wasm instructions execution time: 0 ns
[2021-12-23 15:19:06.690] [info]  Host functions execution time: 0 ns
[2021-12-23 15:19:06.690] [info]  Executed wasm instructions count: 21
[2021-12-23 15:19:06.690] [info]  Gas costs: 20
</code></pre>
<h2 id="javascript-examples"><a class="header" href="#javascript-examples">JavaScript examples</a></h2>
<p>It is possible to use WasmEdge as a high-performance, secure, extensible, easy to deploy, and <a href="https://github.com/second-state/wasmedge-containers-examples">Kubernetes-compliant</a> JavaScript runtime.</p>
<p>The <a href="https://github.com/WasmEdge/WasmEdge/raw/master/tools/wasmedge/examples/js/qjs.wasm">qjs.wasm</a> program is a JavaScript interpreter compiled into WebAssembly.
The <a href="https://github.com/WasmEdge/WasmEdge/raw/master/tools/wasmedge/examples/js/hello.js">hello.js</a> file is a very simple JavaScript program.</p>
<pre><code class="language-bash">$ wasmedge --dir .:. qjs.wasm hello.js 1 2 3
Hello 1 2 3
</code></pre>
<p>The <a href="https://github.com/WasmEdge/WasmEdge/raw/master/tools/wasmedge/examples/js/qjs_tf.wasm">qjs_tf.wasm</a> is a JavaScript interpreter with <a href="https://www.secondstate.io/articles/wasi-tensorflow/">WasmEdge Tensorflow extension</a> compiled into WebAssembly.
To run <a href="https://github.com/WasmEdge/WasmEdge/raw/master/tools/wasmedge/examples/js/qjs_tf.wasm">qjs_tf.wasm</a>, you must use the <code>wasmedge-tensorflow-lite</code> CLI tool, which is a build of WasmEdge with Tensorflow extension built-in.
You can download a full <a href="https://github.com/second-state/wasmedge-quickjs/tree/main/example_js/tensorflow_lite_demo">Tensorflow-based JavaScript example</a> to classify images.</p>
<pre><code class="language-bash"># Download the Tensorflow example
$ wget https://raw.githubusercontent.com/second-state/wasmedge-quickjs/main/example_js/tensorflow_lite_demo/aiy_food_V1_labelmap.txt
$ wget https://raw.githubusercontent.com/second-state/wasmedge-quickjs/main/example_js/tensorflow_lite_demo/food.jpg
$ wget https://raw.githubusercontent.com/second-state/wasmedge-quickjs/main/example_js/tensorflow_lite_demo/lite-model_aiy_vision_classifier_food_V1_1.tflite
$ wget https://raw.githubusercontent.com/second-state/wasmedge-quickjs/main/example_js/tensorflow_lite_demo/main.js

$ wasmedge-tensorflow-lite --dir .:. qjs_tf.wasm main.js
label: Hot dog
confidence: 0.8941176470588236
</code></pre>
<p>Read on and continue your learning of WasmEdge.</p>
<ul>
<li><a href="start/install.html">Install and uninstall WasmEdge</a></li>
<li><a href="start/cli.html">Use the WasmEdge CLI</a></li>
<li><a href="intro/use.html">WasmEdge use cases</a></li>
<li><a href="intro/features.html">WasmEdge technical highlights</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="install-and-uninstall-wasmedge"><a class="header" href="#install-and-uninstall-wasmedge">Install and uninstall WasmEdge</a></h1>
<h2 id="quick-install"><a class="header" href="#quick-install">Quick install</a></h2>
<p>The easiest way to install WasmEdge is to run the following command. Your system should have <code>git</code> and <code>curl</code> as prerequisites.</p>
<pre><code class="language-bash">curl -sSf https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/utils/install.sh | bash
</code></pre>
<p>For Windows 10, you could use Windows Package Manager Client (aka winget.exe) to install WasmEdge with a single command in your terminal.</p>
<pre><code class="language-bash">winget install wasmedge
</code></pre>
<p>If you would like to install WasmEdge with its <a href="https://www.secondstate.io/articles/wasi-tensorflow/">Tensorflow and image processing extensions</a>, please run the following command. It will attempt to install Tensorflow and image shared libraries on your system.</p>
<pre><code class="language-bash">curl -sSf https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/utils/install.sh | bash -s -- -e all
</code></pre>
<p>Run the following command to make the installed binary available in the current session.</p>
<pre><code class="language-bash">source $HOME/.wasmedge/env
</code></pre>
<p><strong>That's it!</strong> You can now use WasmEdge from the CLI, or launch it from an application. To update WasmEdge to a new release, just re-run the above command to write over the old files.</p>
<h2 id="install-for-all-users"><a class="header" href="#install-for-all-users">Install for all users</a></h2>
<p>By default, WasmEdge is installed in the <code>$HOME/.wasmedge</code> directory. You can install it into a system directory, such as <code>/usr/local</code> to make it available to all users. To specify an install directory, you can run the <code>install.sh</code> script with the <code>-p</code> flag. You will need to run the following commands as the <code>root</code> user or <code>sudo</code> since they write into system directories.</p>
<pre><code class="language-bash">curl -sSf https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/utils/install.sh | bash -s -- -p /usr/local
</code></pre>
<p>Or, with all extensions</p>
<pre><code class="language-bash">curl -sSf https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/utils/install.sh | bash -s -- -e all -p /usr/local
</code></pre>
<h2 id="install-a-specific-version-of-wasmedge"><a class="header" href="#install-a-specific-version-of-wasmedge">Install a specific version of WasmEdge</a></h2>
<p>You could install specific versions of WasmEdge, including pre-releases or old releases by passing the <code>-v</code> argument to the install script. Here is an example.</p>
<pre><code class="language-bash">curl -sSf https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/utils/install.sh | bash -s -- -e all -v 0.9.1
</code></pre>
<p>If you are interested in the latest builds from the <code>HEAD</code> of the <code>master</code> branch, which is basically WasmEdge's nightly builds, you can download the release package directly from our Github Action's CI artifact. <a href="https://github.com/WasmEdge/WasmEdge/actions/runs/1521549504#artifacts">Here is an example</a>.</p>
<h2 id="whats-installed"><a class="header" href="#whats-installed">What's installed</a></h2>
<p>After installation, you have the following directories and files. Here we assume that you installed into the <code>$HOME/.wasmedge</code> directory. You could also change it to <code>/usr/local</code> if you did a system-wide install.</p>
<p>If you used winget to install WasmEdge, files are located at <code>C:\Program Files\WasmEdge</code>.</p>
<ul>
<li>The <code>$HOME/.wasmedge/bin</code> directory contains the WasmEdge Runtime CLI executable files. You can copy and move them around on your file system.
<ul>
<li>The <code>wasmedge</code> tool is the standard WasmEdge runtime. You can use it from the CLI. <code>wasmedge --dir .:. app.wasm</code></li>
<li>The <code>wasmedgec</code> tool is the AOT compiler to compile a <code>wasm</code> file into a native <code>so</code> file. <code>wasmedgec app.wasm app.so</code> The <code>wasmedge</code> can then execute the <code>so</code> file. <code>wasmedge --dir .:. app.so</code></li>
<li>The <code>wasmedge-tensorflow</code>, <code>wasmedge-tensorflow-lite</code> tools are runtimes that support the WasmEdge tensorflow SDK.</li>
</ul>
</li>
<li>The <code>$HOME/.wasmedge/lib</code> directory contains WasmEdge shared libraries, as well as dependency libraries. They are useful for WasmEdge SDKs to launch WasmEdge programs and functions from host applications.</li>
<li>The <code>$HOME/.wasmedge/include</code> directory contains the WasmEdge header files. They are useful for WasmEdge SDKs.</li>
</ul>
<h2 id="uninstall"><a class="header" href="#uninstall">Uninstall</a></h2>
<p>To uninstall WasmEdge, you can run the following command.</p>
<pre><code class="language-bash">bash &lt;(curl -sSf https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/utils/uninstall.sh)
</code></pre>
<p>If <code>wasmedge</code> binary is not in <code>PATH</code> and it wasn't installed in the default <code>$HOME/.wasmedge</code> folder, then you must provide the installation path.</p>
<pre><code class="language-bash">bash &lt;(curl -sSf https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/utils/uninstall.sh) -p /path/to/parent/folder
</code></pre>
<p>If you wish to uninstall uninteractively, you can pass in the <code>--quick</code> or <code>-q</code> flag.</p>
<pre><code class="language-bash">bash &lt;(curl -sSf https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/utils/uninstall.sh) -q
</code></pre>
<blockquote>
<p>If a parent folder of the <code>wasmedge</code> binary contains <code>.wasmedge</code>, the folder will be considered for removal. For example, the script removes the default <code>$HOME/.wasmedge</code> folder altogether.</p>
</blockquote>
<p>If you used winget to install WasmEdge, run the following command.</p>
<pre><code class="language-bash">winget uninstall wasmedge
</code></pre>
<h2 id="install-wasmedge-for-nodejs"><a class="header" href="#install-wasmedge-for-nodejs">Install WasmEdge for Node.js</a></h2>
<p>WasmEdge can run <a href="https://www.secondstate.io/articles/getting-started-with-rust-function/">WebAssembly functions emebedded in Node.js</a> applications. To install the WasmEdge module in your Node.js environment is easy. Just use the <code>npm</code> tool.</p>
<pre><code class="language-bash">npm install -g wasmedge-core # Append --unsafe-perm if permission denied
</code></pre>
<p>To install WasmEdge with <a href="https://www.secondstate.io/articles/wasi-tensorflow/">Tensorflow and other extensions</a>.</p>
<pre><code class="language-bash">npm install -g wasmedge-extensions # Append --unsafe-perm if permission denied
</code></pre>
<p>The <a href="https://www.secondstate.io/faas/">Second State Functions</a> is a WasmEdge-based FaaS service build on Node.js.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="use-docker-for-wasmedge-app-development"><a class="header" href="#use-docker-for-wasmedge-app-development">Use Docker for WasmEdge app development</a></h1>
<p>The <code>appdev</code> Docker images provide a complete WasmEdge application development environment. To use it, do the following.</p>
<h2 id="on-x86_64-machines"><a class="header" href="#on-x86_64-machines">On x86_64 machines</a></h2>
<pre><code class="language-bash">$ docker pull wasmedge/appdev_x86_64:0.9.0
$ docker run --rm -v $(pwd):/app -it wasmedge/appdev_x86_64:0.9.0
(docker) #
</code></pre>
<p>Here is the <a href="https://github.com/WasmEdge/WasmEdge/blob/master/utils/docker/Dockerfile.appdev_x86_64">Dockerfile</a> and <a href="https://hub.docker.com/repository/docker/wasmedge/appdev_x86_64">Docker Hub image</a>.</p>
<h2 id="on-arm64-machines"><a class="header" href="#on-arm64-machines">On arm64 machines</a></h2>
<pre><code class="language-bash">$ docker pull wasmedge/appdev_aarch64:0.9.0
$ docker run --rm -v $(pwd):/app -it wasmedge/appdev_aarch64:0.9.0
(docker) #
</code></pre>
<p>Here is the <a href="https://github.com/WasmEdge/WasmEdge/blob/master/utils/docker/Dockerfile.appdev_aarch64">Dockerfile</a> and <a href="https://hub.docker.com/repository/docker/wasmedge/appdev_aarch64">Docker Hub image</a>.</p>
<p>The WasmEdge application development Docker image installs the following components.</p>
<ul>
<li>WasmEdge CLI and shared libraries</li>
<li>WasmEdge with Tensorflow extension CLI and libraries (x86_64 only)</li>
<li>Golang</li>
<li>Rust</li>
<li>Node.js with WasmEdge addons</li>
<li>Examples in the <code>/root/examples/</code> folder</li>
</ul>
<h2 id="examples"><a class="header" href="#examples">Examples</a></h2>
<p>Hello World. <a href="https://github.com/WasmEdge/WasmEdge/tree/master/tools/wasmedge/examples">See more simple examples</a></p>
<pre><code class="language-bash">$ wasmedge hello.wasm world
hello
world
</code></pre>
<p>Use AOT to run it <em>much faster</em>.</p>
<pre><code class="language-bash">$ wasmedgec hello.wasm hello.wasm
$ wasmedge hello.wasm world
hello
world
</code></pre>
<p>Here are some JavaScript examples. <a href="https://github.com/WasmEdge/WasmEdge/tree/master/tools/wasmedge/examples/js">See more</a></p>
<pre><code class="language-bash">$ wasmedge --dir .:. qjs.wasm hello.js 1 2 3
Hello 1 2 3

$ wasmedge-tensorflow-lite --dir .:. qjs_tf.wasm tf_image_classify.js
label: Hot dog
confidence: 0.8941176470588236
</code></pre>
<h2 id="build-and-publish-the-appdev-images"><a class="header" href="#build-and-publish-the-appdev-images">Build and publish the appdev images</a></h2>
<p>Run these commands to build and publish the <code>appdev</code> Docker images.</p>
<h3 id="build-on-an-x86_64-machine"><a class="header" href="#build-on-an-x86_64-machine">Build on an x86_64 machine</a></h3>
<pre><code class="language-bash">docker build -t wasmedge/appdev_x86_64:0.9.0 -f Dockerfile.appdev_x86_64 ./ 
docker image push wasmedge/appdev_x86_64:0.9.0
</code></pre>
<h3 id="build-on-an-arm64--aarch64-machine"><a class="header" href="#build-on-an-arm64--aarch64-machine">Build on an ARM64 / aarch64 machine</a></h3>
<pre><code class="language-bash">docker build -t wasmedge/appdev_aarch64:0.9.0 -f Dockerfile.appdev_aarch64 ./
docker image push wasmedge/appdev_aarch64:0.9.0
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="wasmedge-command-line-tool-cli"><a class="header" href="#wasmedge-command-line-tool-cli">WasmEdge command line tool (CLI)</a></h1>
<p>After <a href="start/install.html">installing WasmEdge</a> or starting the <a href="start/docker.html">WasmEdge app dev Docker container</a>, there are several ways to run compiled WebAssembly programs.</p>
<h2 id="wasmedge"><a class="header" href="#wasmedge">wasmedge</a></h2>
<p>The <code>wasmedge</code> binary file is a command line interface (CLI) program that runs WebAssembly bytecode programs.</p>
<ul>
<li>If the WebAssembly program contains a <code>main()</code> function, <code>wasmedge</code> would execute it as a standalone program in the command mode.</li>
<li>If the WebAssembly program contains one or more public functions, <code>wasmedge</code> could execute individual functions in the reactor mode.</li>
</ul>
<h3 id="command-line-options"><a class="header" href="#command-line-options">Command line options</a></h3>
<p>The options and flags for the <code>wasmedge</code> command are as follows.</p>
<ol>
<li>(Optional) Statistics information:
<ul>
<li>Use <code>--enable-time-measuring</code> to show the execution time.</li>
<li>Use <code>--enable-gas-measuring</code> to show the amount of used gas.</li>
<li>Use <code>--enable-instruction-count</code> to display the number of executed instructions.</li>
<li>Or use <code>--enable-all-statistics</code> to enable all of the statistics options.</li>
</ul>
</li>
<li>(Optional) Resource limitation:
<ul>
<li>Use <code>--gas-limit</code> to limit the execution cost.</li>
<li>Use <code>--memory-page-limit</code> to set the limitation of pages(as size of 64 KiB) in every memory instance.</li>
</ul>
</li>
<li>(Optional) Reactor mode: use <code>--reactor</code> to enable reactor mode. In the reactor mode, <code>wasmedge</code> runs a specified function from the WebAssembly program.
<ul>
<li>WasmEdge will execute the function which name should be given in <code>ARG[0]</code>.</li>
<li>If there's exported function which names <code>_initialize</code>, the function will be executed with the empty parameter at first.</li>
</ul>
</li>
<li>(Optional) Binding directories into WASI virtual filesystem.
<ul>
<li>Each directory can be specified as <code>--dir guest_path:host_path</code>.</li>
</ul>
</li>
<li>(Optional) Environ variables.
<ul>
<li>Each variable can be specified as <code>--env NAME=VALUE</code>.</li>
</ul>
</li>
<li>Wasm file (<code>/path/to/wasm/file</code>).</li>
<li>(Optional) Arguments.
<ul>
<li>In reactor mode, the first argument will be the function name, and the arguments after <code>ARG[0]</code> will be parameters of wasm function <code>ARG[0]</code>.</li>
<li>In command mode, the arguments will be parameters of function <code>_start</code>. They are also known as command line arguments for a standalone program.</li>
</ul>
</li>
</ol>
<p>Once installed, you can <a href="start/../index.html">review and run our examples</a>.</p>
<h2 id="wasmedgec"><a class="header" href="#wasmedgec">wasmedgec</a></h2>
<p>The <code>wasmedgec</code> binary file is a program to compile WebAssembly bytecode programs into native machine code (i.e., the AOT compiler).
The compiled machine code could be <a href="start/universal.html">stored in the original <code>wasm</code> file</a>, and the <code>wasmedge</code> CLI will automatically choose to execute the native machine code whenever it is available.</p>
<p>The options and flags for the <code>wasmedgec</code> are as follows.</p>
<ol>
<li>Input Wasm file(<code>/path/to/input/wasm/file</code>).</li>
<li>Output file name(<code>/path/to/output/file</code>).
<ul>
<li>By default, it will generate the <a href="start/universal.html">universal Wasm binary format</a>.</li>
<li>Users can still generate native binary only by specifying the <code>.so</code>, <code>.dylib</code>, or <code>.dll</code> extensions.</li>
</ul>
</li>
</ol>
<pre><code class="language-bash"># This is slow
wasmedge app.wasm

# AOT compile
wasmedgec app.wasm app.wasm

# This is now MUCH faster
wasmedge app.wasm
</code></pre>
<p>On Linux systems, it could generate a <code>so</code> shared library file, which is then executed by the <code>wasmedge</code> CLI.</p>
<pre><code class="language-bash">wasmedgec app.wasm app.so
wasmedge app.so
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="universal-wasm-binary-format"><a class="header" href="#universal-wasm-binary-format">Universal Wasm Binary Format</a></h1>
<p>WasmEdge could wrap the AOT-compiled native binary into a custom section in the origin wasm file. We call this the universal wasm binary format.</p>
<p>The AOT-compiled wasm file is compatible with any wasm runtime. However, when this wasm file is executed by the WasmEdge runtime, WasmEdge will extract the native binary from the custom section and execute it.</p>
<p>Of course, the user still has the option to generate the native binary file with the <code>wasmedgec</code> AOT compiler.
WasmEdge uses the output file extension to determine generated file format. For example, if you set the <code>wasmedgec</code> output file extension to <code>.so</code>, it will generate native binary in Linux shared library format. Otherwise, it will generate a universal wasm binary by default.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="what-is-wasmedge"><a class="header" href="#what-is-wasmedge">What is WasmEdge</a></h1>
<p>WasmEdge is a lightweight, high-performance, and extensible WebAssembly runtime for cloud native, edge, and decentralized applications. It powers serverless apps, embedded functions, microservices, smart contracts, and IoT devices.</p>
<p>WasmEdge is a CNCF Sandbox project now.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="use-cases"><a class="header" href="#use-cases">Use cases</a></h1>
<p>WasmEdge is a cloud-native WebAssembly runtime hosted by the CNCF. It is widely used in edge computing, automotive, Jamstack, serverless, SaaS, service mesh, and even blockchain applications. Featuring AOT compiler optimization, WasmEdge is one of the fastest WebAssembly runtimes on the market today.</p>
<ul>
<li>
<p><a href="intro/use/jamstack.html">Modern web apps</a> feature rich UIs that are rendered in the browser and/or on the edge cloud. WasmEdge works with popular web UI frameworks, such as React, Vue, Yew, and Percy, to support isomorphic server-side rendering (SSR) functions on edge servers. It could also support server-side rendering of Unity3D animations and AI-generated interactive videos for web applications on the edge cloud.</p>
</li>
<li>
<p>WasmEdge provides a lighweight, secure and high-performance runtime for <a href="intro/use/microservice.html">microservices</a>. It is fully compatible with application service frameworks such as Dapr, and service orchestrators like Kubernetes. WasmEdge microservices can run on edge servers, and have access to distributed cache, to support both stateless and stateful business logic functions for modern web apps. Also related: <a href="intro/use/serverless.html">Serverless function-as-a-service in public clouds</a>.</p>
</li>
<li>
<p><a href="intro/use/saas.html">Serverless SaaS functions</a> enables users to extend and customize their SaaS experience without operating their own API callback servers. The serverless functions can be embedded into the SaaS or reside on edge servers next to the SaaS servers. Developers simply upload functions to respond to SaaS events or to connect SaaS APIs.</p>
</li>
<li>
<p><a href="intro/use/device.html">Smart device apps</a> could embed WasmEdge as a middleware runtime to render interactive content on the UI, connect to native device drivers, and access specialized hardware features (i.e, the GPU for AI inference). The benefits of the WasmEdge runtime over native-compiled machine code include security, safety, portability, manageability, and developer productivity. WasmEdge runs on Android, OpenHarmony, and seL4 RTOS devices.</p>
</li>
</ul>
<p>If you have any great ideas on WasmEdge, don't hesitate to open <a href="https://github.com/WasmEdge/WasmEdge/issues">a GitHub issue</a> to discuss together.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rendering-modern-web-ui-on-the-edge"><a class="header" href="#rendering-modern-web-ui-on-the-edge">Rendering modern web UI on the edge</a></h1>
<p>Traditional web applications follows the client-server model. In the past era of application servers, the entire UI is dynamically generated from the server. The browser is simply a thin client that displays the rendered web pages at real time. However, as the browser becomes more capable and sophisticated, the client can now take on more workload to improve application UX, performance, and security.</p>
<p>That gives rise to the era of Jamstack. There is now a clear separation between frontend and backend services. The frontend is a static web site (HTML + JavaScript + WebAssembly) generated from UI frameworks such as React.js, Vue.js, Yew or Percy, and the backend consists of microservices. Yet, as Jamstack gains popularity, the diversity of clients (both browsers and apps) makes it very difficult to achieve great performance across all use cases.</p>
<p>The solution is server-side rendering (SSR). That is to have edge servers run the &quot;client side&quot; UI code (ie the React generated JavaScript OR Percy generated WebAssembly), and send back the rendered HTML DOM objects to the browser. In this case, the edge server must execute the exact same code (ie <a href="intro/use/../../dev/js.html">JavaScript</a> and WebAssembly) as the browser to render the UI. That is called isomorphic Jamstack applications. The WasmEdge runtime provides a lightweight, high performance, OCI complaint, and polyglot container to run all kinds of SSR functions on edge servers.</p>
<ul>
<li><a href="intro/use/../../dev/js/ssr.html">React JS SSR function</a></li>
<li>Vue JS SSR function (coming soon)</li>
<li>Yew Rust compiled to WebAssembly SSR function (coming soon)</li>
<li><a href="intro/use/../../dev/rust/ssr.html">Percy Rust compiled to WebAssembly SSR function</a></li>
</ul>
<p>We also exploring ways to render more complex UI and interactions on WasmEdge-based edge servers, and then stream the rendered results to the client application. Potential examples include</p>
<ul>
<li>Render Unity3D animations on the edge server (based on <a href="https://docs.unity3d.com/2020.1/Documentation/Manual/webgl-gettingstarted.html">WebAssembly rendering of Unity3D</a>)</li>
<li>Render interactive video (generated from AI) on the edge server</li>
</ul>
<p>Of course, the edge cloud could grow well beyond SSR for UI components. It could also host high-performance microservices for business logic and serverless functions. Read on to the next chapter.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="microservice-runtime"><a class="header" href="#microservice-runtime">Microservice runtime</a></h1>
<p>The edge cloud can run application logic microservices very close to the client device.</p>
<ul>
<li>The microservices could be stateless computational tasks, such as <a href="intro/use/../../dev/rust/tensorflow.html">AI inference</a> and <a href="intro/use/../../frameworks/app/yomo.html">stream data analysis</a>, which offload computation from the client.</li>
<li>The microservices could also <a href="https://github.com/second-state/wasmedge-anna-rs">interact with data cache services</a> that sync with backend databases.</li>
</ul>
<p>The edge cloud has advantages such as low latency, high security, and high performance. Operationally, WasmEdge can be embedded into cloud-native infrastructure via its SDKs in <a href="intro/use/../../embed/c.html">C</a>, <a href="intro/use/../../embed/go.html">Go</a> and <a href="intro/use/../../embed/rust.html">Rust</a>. It is also an OCI compliant runtime that can be directly <a href="intro/use/../../kubernetes/cri.html">managed by container tools</a> as a lightweight and high-performance alternative to Linux containers. The following application frameworks have been tested to work with WasmEdge-based microservices.</p>
<h2 id="dapr-distributed-application-runtime"><a class="header" href="#dapr-distributed-application-runtime">Dapr (Distributed Application Runtime)</a></h2>
<ul>
<li><a href="intro/use/../../frameworks/mesh/dapr.html">Tutorial</a></li>
<li><a href="https://github.com/second-state/dapr-wasm">Code template</a></li>
</ul>
<h2 id="service-mesh-work-in-progress"><a class="header" href="#service-mesh-work-in-progress">Service mesh (work in progress)</a></h2>
<ul>
<li>Linkerd</li>
<li>MOSN</li>
<li>Envoy</li>
</ul>
<h2 id="orchestration-and-management"><a class="header" href="#orchestration-and-management">Orchestration and management</a></h2>
<ul>
<li><a href="intro/use/../../kubernetes.html">Kubernetes</a></li>
<li><a href="intro/use/../../kubernetes/kubernetes/kubeedge.html">KubeEdge</a></li>
<li><a href="intro/use/../../kubernetes/kubernetes/superedge.html">SuperEdge</a></li>
<li><a href="intro/use/../../kubernetes/kubernetes/openyurt.html">OpenYurt</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="serverless-functions-for-saas"><a class="header" href="#serverless-functions-for-saas">Serverless functions for SaaS</a></h1>
<p>WasmEdge can support customized SaaS extensions or applications using serverless functions instead of traditional network APIs. That dramatically improves SaaS users' and developers' productivity.</p>
<ul>
<li>WasmEdge could be embedded into SaaS products to execute user-defined functions. In this scenario, the WasmEdge function API replaces the SaaS web API. The embedded WasmEdge functions are much faster, safer, and easier to use than RPC functions over the web.</li>
<li>Edge servers could provide WasmEdge-based containers to interact with existing SaaS or PaaS APIs without requiring the user to run his own servers (eg callback servers). The serverless API services can be co-located in the same networks as the SaaS to provide optimal performance and security.</li>
</ul>
<p>The examples below showcase how WasmEdge-based serverless functions connect together SaaS APIs from different services, and process data flows across those SaaS APIs according each user's business logic.</p>
<h2 id="slack"><a class="header" href="#slack">Slack</a></h2>
<ul>
<li><a href="http://reactor.secondstate.info/en/docs/user_guideline.html">Build a serverless chatbot for Slack</a></li>
</ul>
<h2 id="lark"><a class="header" href="#lark">Lark</a></h2>
<p>It is also known as 飞书 aka the Chinese Slack. It is created by Byte Dance, the parent company of Tiktok.</p>
<ul>
<li><a href="http://reactor.secondstate.info/zh/docs/user_guideline.html">Build a serverless chatbot for Lark</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="smart-devices"><a class="header" href="#smart-devices">Smart devices</a></h1>
<p>Smart device apps could embed WasmEdge as a middleware runtime to render interactive content on the UI, connect to native device drivers, and access specialized hardware features (i.e, the GPU for AI inference). The benefits of the WasmEdge runtime over native-compiled machine code include security, safety, portability, manageability, OTA upgradability, and developer productivity. WasmEdge runs on the following device OSes.</p>
<ul>
<li><a href="intro/use/../../os/android.html">Android</a></li>
<li><a href="intro/use/../../os/openharmony.html">OpenHarmony</a></li>
<li><a href="intro/use/../../os/raspberrypi.html">Raspberry Pi</a></li>
<li><a href="intro/use/../../os/sel4.html">The seL4 RTOS</a></li>
</ul>
<p>With WasmEdge on both the device and the edge server, we can support <a href="intro/use/jamstack.html">isomorphic Server-Side Rendering (SSR)</a> and <a href="intro/use/microservice.html">microservices</a> for rich-client mobile applications that is both portable and upgradable.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="features"><a class="header" href="#features">Features</a></h1>
<ul>
<li>One of the <a href="https://github.com/WasmEdge/WasmEdge#performance">fastest</a> WebAssembly VMs on the market (based on <strong>LLVM AOT</strong>)</li>
<li>WasmEdge feature extensions
<ul>
<li><strong>Network sockets</strong> (<a href="https://github.com/second-state/wasmedge_wasi_socket">Rust</a> and <a href="https://github.com/second-state/wasmedge-quickjs#http-request">JavaScript</a> SDKs)</li>
<li><strong>Async polling</strong> (for Rust Future and JS async)</li>
<li>Tensorflow inference (<a href="https://www.secondstate.io/articles/wasi-tensorflow/">Tutorial</a>)</li>
<li>Key value storage</li>
<li>Database connector</li>
<li><strong>Gas meters</strong> for resource constraints</li>
</ul>
</li>
<li>JavaScript support
<ul>
<li><a href="https://github.com/second-state/wasmedge-quickjs#es6-module-support">ES6 module</a> and std API support</li>
<li><strong>Implement JS APIs in Rust</strong> (<a href="https://www.secondstate.io/articles/embed-rust-in-javascript/">Tutorial</a>)</li>
<li>Import C native shared library functions as JS functions (<a href="https://www.secondstate.io/articles/call-native-functions-from-javascript/">Tutorial</a>)</li>
</ul>
</li>
<li>Cloud native management and orchestration
<ul>
<li><a href="https://www.secondstate.io/articles/manage-webassembly-apps-in-wasmedge-using-docker-tools/">CRI-O and Kubernetes compatibility</a></li>
<li>Sidecar apps in Kubernetes-based service meshes</li>
<li>Dapr microservices (<a href="https://www.secondstate.io/articles/dapr-wasmedge-webassembly/">Tutorial</a>)</li>
</ul>
</li>
<li>Cross-platform support
<ul>
<li>Linux OSes dated back to 2010 for both x86 and ARM CPUs</li>
<li>Mac OS X for both x86 and m1 CPUs</li>
<li>Windows</li>
<li>Microkernel and RTOS (e.g., the highly secure <a href="https://github.com/second-state/wasmedge-sel4">seL4 microkernel</a>)</li>
</ul>
</li>
<li>Easy extensibility
<ul>
<li>Build customized runtimes with native functions in <a href="intro/../embed/c/ref.html#host-functions">C</a> or <a href="intro/../embed/go/ref.html#host-functions">GO</a></li>
</ul>
</li>
<li>Easy to embed into a host application
<ul>
<li>Embed WasmEdge functions in <a href="intro/../embed/c.html">C</a>, <a href="https://www.secondstate.io/articles/extend-golang-app-with-webassembly-rust/">Go</a>, <a href="https://github.com/WasmEdge/WasmEdge/tree/master/bindings/rust">Rust</a>, <a href="https://www.secondstate.io/articles/getting-started-with-rust-function/">Node.js</a> and Python host applications</li>
<li>Embedded function runtime for service mesh proxies (e.g., <a href="https://github.com/proxy-wasm/proxy-wasm-cpp-host/pull/193">proxy-wasm</a> for Envoy and MOSN proxies)</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="webassembly-standard-extensions"><a class="header" href="#webassembly-standard-extensions">WebAssembly standard extensions</a></h1>
<p>WasmEdge supports optional WebAssembly features and proposals. Those proposals are likely to become official WebAssembly specifications in the future. WasmEdge supports the following proposals.</p>
<ul>
<li><a href="https://github.com/WebAssembly/WASI">WASI (WebAssembly Systems Interface) spec</a>. WasmEdge has supported the WASI spec for WebAssembly programs to interact with the host Linux operating system securely.</li>
<li><a href="https://webassembly.github.io/reference-types/core/">Reference Types</a>. It allows WebAssembly programs to exchange data with host applications and operating systems.</li>
<li><a href="https://github.com/WebAssembly/bulk-memory-operations">Bulk memory operations</a>. The WebAssembly program sees faster memory access and performs better with bulk memory operations.</li>
<li><a href="https://github.com/WasmEdge/WasmEdge/blob/master/docs/simd.md">SIMD (Single instruction, multiple data)</a>. For modern devices with multiple CPU cores, the SIMD allows data processing programs to take advantage of the CPUs fully. SIMD could significantly enhance the performance of data applications.</li>
</ul>
<p>Meanwhile, the WasmEdge team is exploring the wasi-socket proposal to support network access in WebAssembly programs.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="wasmedge-extensions"><a class="header" href="#wasmedge-extensions">WasmEdge extensions</a></h1>
<p>A key differentiator of WasmEdge from other WebAssembly VMs is its support for non-standard extensions. The WASI spec provides a mechanism for developers to extend WebAssembly VMs efficiently and securely. The WasmEdge team created the following WASI-like extensions based on real-world customer demands.</p>
<ul>
<li><a href="https://github.com/second-state/wasmedge-tensorflow">Tensorflow</a>. Developers can write Tensorflow inference functions using <a href="https://github.com/second-state/wasmedge_tensorflow_interface">a simple Rust API</a>, and then run the function securely and at native speed inside WasmEdge.</li>
<li>Other AI frameworks. Besides Tensorflow, the Second State team is building WASI-like extensions for AI frameworks such as ONNX and Tengine for WasmEdge.</li>
<li><a href="https://github.com/second-state/WasmEdge-image">Image processing</a>. WasmEdge uses native libraries to manipulate images for computer vision tasks.</li>
<li><a href="https://github.com/second-state/wasmedge-storage">KV Storage</a>. The WasmEdge <a href="https://github.com/second-state/rust_native_storage_library">storage interface</a> allows WebAssembly programs to read and write a key value store.</li>
<li><a href="https://github.com/second-state/wasmedge_wasi_socket">Network sockets</a>. WasmEdge applications can access the network sockets for <a href="https://github.com/second-state/wasmedge_wasi_socket/tree/main/examples">TCP and HTTP connections</a>.</li>
<li><a href="https://github.com/second-state/wasmedge_process_interface">Command interface</a>. WasmEdge enables webassembly functions execute native commands in the host operating system. It supports passing arguments, environment variables, STDIN / STDOUT pipes, and security policies for host access.</li>
<li><a href="https://github.com/second-state/wasmedge-evmc">Ethereum</a>. The WasmEdge Ewasm extension supports Ethereum smart contracts compiled to WebAssembly. It is a leading implementation for Ethereum flavored WebAssembly (Ewasm).</li>
<li><a href="https://github.com/second-state/substrate-ssvm-node">Substrate</a>. The <a href="https://github.com/second-state/pallet-ssvm">Pallet</a> allows WasmEdge to act as an Ethereum smart contract execution engine on any Substrate based blockchains.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="wasmedge-integrations"><a class="header" href="#wasmedge-integrations">WasmEdge integrations</a></h1>
<p>WasmEdge is a &quot;serverless&quot; runtime for cloud native and edge computing applications. It allows developers safely embed third-party or &quot;native&quot; functions into a host application or a distributed computing framework.</p>
<h2 id="embed-wasmedge-into-a-host-application"><a class="header" href="#embed-wasmedge-into-a-host-application">Embed WasmEdge into a host application</a></h2>
<p>A major use case of WasmEdge is to start an VM instance from a host application. Depending on your host application's programming language, you can use WasmEdge SDKs to start and call WasmEdge functions.</p>
<ul>
<li>Embed WasmEdge functions into a C-based application using the <a href="intro/../embed/c/ref.html">WasmEdge C API</a>. Checkout the <a href="intro/../embed/c.html">quick start guide</a>.</li>
<li>Embed WasmEdge functions into a Go application using the <a href="intro/../embed/go.html">WasmEdge Go API</a>. Here is a <a href="https://www.secondstate.io/articles/extend-golang-app-with-webassembly-rust/">tutorial</a> and are some <a href="https://github.com/second-state/WasmEdge-go-examples">examples</a>!</li>
<li>Embed WasmEdge functions into a Rust application using the <a href="intro/../bindings/rust/wasmedge-rs">WasmEdge Rust crate</a>.</li>
<li>Embed WasmEdge functions into a Node.js application using the NAPI. Here is a <a href="https://www.secondstate.io/articles/getting-started-with-rust-function/">tutorial</a>.</li>
<li>Embed WasmEdge functions into any application by spawning a new process. See examples for <a href="https://www.secondstate.io/articles/vercel-wasmedge-webassembly-rust/">Vercel Serverless Functions</a> and <a href="https://www.cncf.io/blog/2021/08/25/webassembly-serverless-functions-in-aws-lambda/">AWS Lambda</a>.</li>
</ul>
<p>However, the WebAssembly spec only supports very limited data types as input parameters and return values for the WebAssembly bytecode functions. In order to pass complex data types, such as a string of an array, as call arguments into Rust-based WasmEdge function, you should use the bindgen solution provided by the <a href="https://github.com/second-state/rustwasmc">rustwasmc</a> toolchain. We currently supports bindgen in the <a href="https://www.secondstate.io/articles/getting-started-with-rust-function/">Node.js</a> and in <a href="https://www.secondstate.io/articles/extend-golang-app-with-webassembly-rust/">Go</a>. We are working on <a href="https://github.com/WasmEdge/WasmEdge/issues/264">supporting interface types</a> in place of bindgen for future releases.</p>
<h2 id="use-wasmedge-as-a-docker-like-container"><a class="header" href="#use-wasmedge-as-a-docker-like-container">Use WasmEdge as a Docker-like container</a></h2>
<p>WasmEdge provides an OCI compliant interface. You can use container tools, such as CRI-O, Docker Hub, and Kubernetes, to orchestrate and manage WasmEdge runtimes.</p>
<ul>
<li><a href="https://www.secondstate.io/articles/manage-webassembly-apps-in-wasmedge-using-docker-tools/">Manage WasmEdge with CRI-O and Docker Hub</a>.</li>
</ul>
<h2 id="call-native-host-functions-from-wasmedge"><a class="header" href="#call-native-host-functions-from-wasmedge">Call native host functions from WasmEdge</a></h2>
<p>A key feature of WasmEdge is its extensibility. WasmEdge APIs allow developers to register &quot;host functions&quot; from any shared library into a WasmEdge instance, and then call these functions from the WebAssembly bytecode program.</p>
<ul>
<li>The WasmEdge C API supports the <a href="intro/../embed/c/ref.html#host-functions">C host functions</a>.</li>
<li>The WasmEdge Go API supports the <a href="intro/../embed/go/ref.html#host-functions">Go host functions</a>.</li>
</ul>
<p><a href="https://www.secondstate.io/articles/call-native-functions-from-javascript/">Here is an example</a> of a JavaScript program in WasmEdge calling a C-based host function in the underlying OS.</p>
<p>The host functions break the Wasm sandbox to access the underly OS or hardware. But the sandbox breaking is done with explicit permission from the system’s operator.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="faq-abut-webassembly-and-wasmedge"><a class="header" href="#faq-abut-webassembly-and-wasmedge">FAQ abut WebAssembly and WasmEdge</a></h1>
<p><strong>Q: What's the relationship between WebAssembly and Docker?</strong></p>
<p>A: Check out our infographic <a href="https://wasmedge.org/wasm_docker/">WebAssembly vs. Docker</a>. WebAssembly runs side by side with Docker in cloud native and edge native applications.</p>
<p><strong>Q: What's the difference for Native clients (NaCl), Application runtimes, and WebAssembly?</strong></p>
<p>A: We created a handy table for comparison.</p>
<table><thead><tr><th></th><th>NaCl</th><th>Application runtimes (eg Node &amp; Python)</th><th>Docker-like container</th><th>WebAssembly</th></tr></thead><tbody>
<tr><td>Performance</td><td>Great</td><td>Poor</td><td>OK</td><td>Great</td></tr>
<tr><td>Resource footprint</td><td>Great</td><td>Poor</td><td>Poor</td><td>Great</td></tr>
<tr><td>Isolation</td><td>Poor</td><td>OK</td><td>OK</td><td>Great</td></tr>
<tr><td>Safety</td><td>Poor</td><td>OK</td><td>OK</td><td>Great</td></tr>
<tr><td>Portability</td><td>Poor</td><td>Great</td><td>OK</td><td>Great</td></tr>
<tr><td>Security</td><td>Poor</td><td>OK</td><td>OK</td><td>Great</td></tr>
<tr><td>Language and framework choice</td><td>N/A</td><td>N/A</td><td>Great</td><td>OK</td></tr>
<tr><td>Ease of use</td><td>OK</td><td>Great</td><td>Great</td><td>OK</td></tr>
<tr><td>Manageability</td><td>Poor</td><td>Poor</td><td>Great</td><td>Great</td></tr>
</tbody></table>
<p><strong>Q: What's the difference between WebAssembly and eBPF?</strong></p>
<p>A: eBPF is the bytecode format for a Linux kernel space VM that is suitable for network or security related tasks. WebAssembly is the bytecode format for a user space VM that is suited for business applications. <a href="https://medium.com/codex/ebpf-and-webassembly-whose-vm-reigns-supreme-c2861ce08f89">See details here</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="develop-a-wasmedge-app"><a class="header" href="#develop-a-wasmedge-app">Develop a WasmEdge app</a></h1>
<p>A key value proposition of WebAssembly is that it supports multiple programming languages. WebAssembly is a &quot;managed runtime&quot; for many programming languages including C/C++, Rust, Go, Swift, Kotlin, AssemblyScript, Grain and even JavaScript and Python.</p>
<ul>
<li>For compiled languages (e.g., C and Rust), WasmEdge WebAssembly provides a safe, secure, isolated, and containerized runtime as opposed to Native Client (NaCl).</li>
<li>For interpreted or managed languages (e.g., JavaScript and Python), WasmEdge WebAssembly provides a secure, fast, lightweight, and containerized runtime as opposed to Docker + guest OS + native interpreter.</li>
</ul>
<p>In this chapter, we will discuss how to compile and run programs in different languages in WasmEdge.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rust"><a class="header" href="#rust">Rust</a></h1>
<p>Rust is one of the &quot;first-class citizen&quot; programming languages in the WebAssembly ecosystem. All WasmEdge extensions to WebAssembly also come with Rust APIs for developers.
In this chapter, we will show you how to compile your Rust applications to wasm bytecode and to run in the WasmEdge runtime.</p>
<h2 id="prerequisites"><a class="header" href="#prerequisites">Prerequisites</a></h2>
<p>You need to install <a href="https://www.rust-lang.org/tools/install">Rust</a> and <a href="dev/../start/install.html">WasmEdge</a> in order to get started.
You should also install the <code>wasm32-wasi</code> target to the Rust toolchain.</p>
<pre><code class="language-bash">rustup target add wasm32-wasi
</code></pre>
<h2 id="hello-world-1"><a class="header" href="#hello-world-1">Hello world</a></h2>
<p>The Hello world example is a standalone Rust application that can be executed
by the <a href="dev/../start/cli.html">WasmEdge CLI</a>. Its <a href="https://github.com/second-state/wasm-learning/tree/master/cli/hello">source code is available</a>.</p>
<p>The full source code for the Rust <a href="https://github.com/second-state/wasm-learning/blob/master/cli/hello/src/main.rs">main.rs</a> file is as follows.
It echoes the command line arguments passed to this program at runtime.</p>
<pre><pre class="playground"><code class="language-rust">use std::env;

fn main() {
  println!(&quot;hello&quot;);
  for argument in env::args().skip(1) {
    println!(&quot;{}&quot;, argument);
  }
}
</code></pre></pre>
<h3 id="hello-world-build-the-wasm-bytecode"><a class="header" href="#hello-world-build-the-wasm-bytecode">Hello world: Build the WASM bytecode</a></h3>
<pre><code class="language-bash">cargo build --target wasm32-wasi
</code></pre>
<h3 id="hello-world-run-the-application-from-command-line"><a class="header" href="#hello-world-run-the-application-from-command-line">Hello world: Run the application from command line</a></h3>
<p>We will use the <code>wasmedge</code> command to run the program.</p>
<pre><code class="language-bash">$ wasmedge target/wasm32-wasi/debug/hello.wasm second state
hello
second
state
</code></pre>
<h2 id="a-simple-function"><a class="header" href="#a-simple-function">A simple function</a></h2>
<p>The <a href="https://github.com/second-state/wasm-learning/tree/master/cli/add">add example</a> is a Rust library function that can be executed
by the <a href="dev/../start/cli.html">WasmEdge CLI</a> in the reactor mode.</p>
<p>The full source code for the Rust <a href="https://github.com/second-state/wasm-learning/blob/master/cli/add/src/lib.rs">lib.rs</a> file is as follows.
It provides a simple <code>add()</code> function.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[no_mangle]
pub fn add(a: i32, b: i32) -&gt; i32 {
  return a + b;
}
<span class="boring">}
</span></code></pre></pre>
<h3 id="a-simple-function-build-the-wasm-bytecode"><a class="header" href="#a-simple-function-build-the-wasm-bytecode">A simple function: Build the WASM bytecode</a></h3>
<pre><code class="language-bash">cargo build --target wasm32-wasi
</code></pre>
<h3 id="a-simple-function-run-the-application-from-command-line"><a class="header" href="#a-simple-function-run-the-application-from-command-line">A simple function: Run the application from command line</a></h3>
<p>We will use <code>wasmedge</code> in reactor mode to run the program. We pass the function name and its input parameters as command line arguments.</p>
<pre><code class="language-bash">$ wasmedge --reactor target/wasm32-wasi/debug/add.wasm add 2 2
4
</code></pre>
<h2 id="pass-complex-call-parameters"><a class="header" href="#pass-complex-call-parameters">Pass complex call parameters</a></h2>
<p>Of course, in most cases, you will not call functions using CLI arguments.
Instead, you will probably need to use a <a href="dev/../../embed.html">language SDK from WasmEdge</a>
to call the function, pass call parameters, and receive return values.
Below are some SDK examples for complex call parameters and return values.</p>
<ul>
<li><a href="dev/../embed/go/function.html">Use wasmedge-bindgen in a Go host app</a></li>
<li><a href="dev/../embed/go/memory.html">Use direct memory passing in a Go host app</a></li>
</ul>
<h2 id="improve-performance"><a class="header" href="#improve-performance">Improve performance</a></h2>
<p>To achieve native Rust performance for those applications, you
could use the <code>wasmedgec</code> command to AOT compile the <code>wasm</code> program,
and then run it with the <code>wasmedge</code> command.</p>
<pre><code class="language-bash">$ wasmedgec hello.wasm hello.wasm

$ wasmedge hello.wasm second state
hello
second
state
</code></pre>
<p>For the <code>--reactor</code> mode,</p>
<pre><code class="language-bash">$ wasmedgec add.wasm add.wasm

$ wasmedge --reactor add.wasm add 2 2
4
</code></pre>
<h2 id="further-readings"><a class="header" href="#further-readings">Further readings</a></h2>
<ul>
<li><a href="dev/rust/wasi.html">Access OS services via WASI</a> shows how the WebAssembly program can access the underlying OS services, such as file system and environment variables.</li>
<li><a href="dev/rust/tensorflow.html">Tensorflow</a> shows how to create Tensorflow-based AI inference applications for WebAssembly using the WasmEdge TensorFlow Rust SDK.</li>
<li><a href="dev/rust/networking.html">Simple networking socket</a> shows how to create simple HTTP client and server applications using the WasmEdge networking socket Rust SDK.</li>
<li><a href="dev/rust/networking-nonblocking.html">Non-blocking networking socket</a> shows how to create a high-performance non-blocking networking applications with concurrent open connections using the WasmEdge networking socket Rust SDK.</li>
<li><a href="dev/rust/ssr.html">Server-side rendering</a> shows how to build an interactive web app with Rust, and then render the HTML DOM UI on the server using WasmEdge. The Rust source code is compiled to WebAssembly to render the HTML DOM in the browser or on the server.</li>
<li><a href="dev/rust/command.html">Command interface</a> shows how to create native command applications for WebAssembly using the Wasmedge command interface Rust SDK.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="call-rust-functions"><a class="header" href="#call-rust-functions">Call Rust functions</a></h1>
<p>If your Rust program has a <code>main()</code> function, you could compile it into a WASM bytecode file, and run it using the <code>wasmedge</code> CLI tool as a standalone application. However, a far more common use case is to compile a Rust function into a WASM bytecode file, and then call it from a host application. That is known as an embedded WASM function. The host application uses WasmEdge language SDKs (e.g., <a href="dev/rust/../../embed/go.html">Go</a>, <a href="dev/rust/../../embed/rust.html">Rust</a>, <a href="dev/rust/../../embed/c.html">C</a>, <a href="dev/rust/../../embed/go.html">Python</a> and <a href="dev/rust/../../embed/node.html">Node.js</a>) to call those WASM functions compiled from Rust source code.</p>
<p>All the WasmEdge host language SDKs support simple function calls. However, the WASM spec only supports a few simple data types as call parameters and return values. The <code>wasmedge-bindgen</code> crate would transform call parameters and return values of Rust functions into simple integer types when the Rust function is compiled into WASM. For example, a string is automatically converted into two integers, a memory address and a length, which can be handled by the standard WASM spec. It is very easy to do this in Rust source code. Just annotate your function with the <code>#[wasmedge-bindgen]</code> macro. You can compile the annotated Rust code using the standard Rust compiler toolchain (e.g., the latest <code>Cargo</code>).</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use wasmedge_bindgen::*;
use wasmedge_bindgen_macro::*;

#[wasmedge_bindgen]
pub fn say(s: String) -&gt; Result&lt;Vec&lt;u8&gt;, String&gt; {
  let r = String::from(&quot;hello &quot;);
  return Ok((r + s.as_str()).as_bytes().to_vec());
}
<span class="boring">}
</span></code></pre></pre>
<p>Of course, once the above Rust code is compiled into WASM, the function <code>say()</code> no longer takes the <code>String</code> parameter nor returns the <code>Vec&lt;u8&gt;</code>. So, the caller (i.e., the host application) must also deconstruct the call parameter into the memory pointer first before the call, and assemble the return value from the memory pointer after the call. These actions can be handled automagically by the WasmEdge language SDKs. To see a complete example, including the Rust WASM function and the Go host application, check out our tutorial in the Go SDK documentation.</p>
<p><strong><a href="dev/rust/../../embed/go/function.html">A complete wasmedge-bindgen example in Rust (WASM) and Go (host)</a></strong></p>
<p>Of course, the developer could choose to do <code>wasmedge-bindgen</code>'s work by hand and pass a memory pointer directly. If you are interested in this approach to call Rust compiled WASM functions, check out our <a href="dev/rust/../../embed/go/memory.html">examples in the Go SDK</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="access-os-services"><a class="header" href="#access-os-services">Access OS services</a></h1>
<p>The WASI (WebAssembly Systems Interface) standard is designed to allow WebAssembly applications to access operating system services.
The <code>wasm32-wasi</code> target in the Rust compiler supports WASI.
In this section, we will use <a href="https://github.com/second-state/wasm-learning/tree/master/cli/wasi">an example project</a> to show how to use Rust standard APIs to access operating system services.</p>
<h2 id="random-numbers"><a class="header" href="#random-numbers">Random numbers</a></h2>
<p>The WebAssembly VM is a pure software construct. It does not have a hardware entropy source for random numbers. That's why WASI defines a function for WebAssembly programs to call its host operating system to get a random seed. As a Rust developer, all you need is to use the popular (de facto standard) <code>rand</code> and/or <code>getrandom</code> crates. With the <code>wasm32-wasi</code> compiler backend, these crates generate the correct WASI calls in the WebAssembly bytecode. The <code>Cargo.toml</code> dependencies are as follows.</p>
<pre><code class="language-toml">[dependencies]
rand = &quot;0.7.3&quot;
getrandom = &quot;0.1.14&quot;
</code></pre>
<p>The Rust code to get random number from WebAssembly is this.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use rand::prelude::*;

pub fn get_random_i32() -&gt; i32 {
  let x: i32 = random();
  return x;
}

pub fn get_random_bytes() -&gt; Vec&lt;u8&gt; {
  let mut rng = thread_rng();
  let mut arr = [0u8; 128];
  rng.fill(&amp;mut arr[..]);
  return arr.to_vec();
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="printing-and-debugging-from-rust"><a class="header" href="#printing-and-debugging-from-rust">Printing and debugging from Rust</a></h2>
<p>The Rust <code>println!</code> marco just works in WASI. The statements print to the <code>STDOUT</code> of the process that runs the WasmEdge.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn echo(content: &amp;str) -&gt; String {
  println!(&quot;Printed from wasi: {}&quot;, content);
  return content.to_string();
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="arguments-and-environment-variables"><a class="header" href="#arguments-and-environment-variables">Arguments and environment variables</a></h2>
<p>It is possible to pass CLI arguments to and access OS environment variables in a WasmEdge application.
They are just <code>env::args()</code> and <code>env::vars()</code> arrays in Rust.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::env;

pub fn print_env() {
  println!(&quot;The env vars are as follows.&quot;);
  for (key, value) in env::vars() {
    println!(&quot;{}: {}&quot;, key, value);
  }

  println!(&quot;The args are as follows.&quot;);
  for argument in env::args() {
    println!(&quot;{}&quot;, argument);
  }
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="reading-and-writing-files"><a class="header" href="#reading-and-writing-files">Reading and writing files</a></h2>
<p>WASI allows your Rust functions to access the host computer's file system through the standard Rust <code>std::fs</code> API.
In the Rust program, you operate on files through a relative path. The relative
path's root is specified when you start the WasmEdge runtime.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fs;
use std::fs::File;
use std::io::{Write, Read};

pub fn create_file(path: &amp;str, content: &amp;str) {
  let mut output = File::create(path).unwrap();
  output.write_all(content.as_bytes()).unwrap();
}

pub fn read_file(path: &amp;str) -&gt; String {
  let mut f = File::open(path).unwrap();
  let mut s = String::new();
  match f.read_to_string(&amp;mut s) {
    Ok(_) =&gt; s,
    Err(e) =&gt; e.to_string(),
  }
}

pub fn del_file(path: &amp;str) {
  fs::remove_file(path).expect(&quot;Unable to delete&quot;);
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="a-main-app"><a class="header" href="#a-main-app">A main() app</a></h2>
<p>With a <code>main()</code> function, the Rust program can be compiled into a
standalone WebAssembly program.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
  println!(&quot;Random number: {}&quot;, get_random_i32());
  println!(&quot;Random bytes: {:?}&quot;, get_random_bytes());
  println!(&quot;{}&quot;, echo(&quot;This is from a main function&quot;));
  print_env();
  create_file(&quot;tmp.txt&quot;, &quot;This is in a file&quot;);
  println!(&quot;File content is {}&quot;, read_file(&quot;tmp.txt&quot;));
  del_file(&quot;tmp.txt&quot;);
}
</code></pre></pre>
<p>Use the command below to compile <a href="https://github.com/second-state/wasm-learning/tree/master/cli/wasi">the Rust project</a>.</p>
<pre><code class="language-bash">cargo build --target wasm32-wasi
</code></pre>
<p>To run it in <code>wasmedge</code>, do the following. The <code>--dir</code> option maps the current
directory of the command shell to the file system current directory inside
the WebAssembly app.</p>
<pre><code class="language-bash">$ wasmedge --dir .:. target/wasm32-wasi/debug/wasi.wasm hello
Random number: -68634548
Random bytes: [87, 117, 194, 122, 74, 189, 29, 1, 113, 26, 90, 6, 151, 20, 11, 169, 131, 212, 161, 220, 216, 190, 77, 234, 30, 10, 159, 7, 14, 89, 81, 111, 247, 136, 39, 195, 83, 90, 153, 225, 66, 16, 150, 217, 137, 172, 216, 203, 251, 37, 4, 27, 32, 57, 76, 237, 99, 147, 24, 175, 208, 157, 3, 220, 46, 224, 199, 153, 144, 96, 120, 89, 160, 38, 171, 239, 87, 218, 41, 184, 220, 78, 157, 57, 229, 198, 222, 72, 219, 118, 237, 27, 229, 28, 51, 116, 88, 101, 40, 139, 160, 51, 156, 102, 66, 233, 101, 50, 131, 9, 253, 186, 73, 148, 85, 36, 155, 254, 168, 202, 23, 96, 181, 99, 120, 136, 28, 147]
This is from a main function
The env vars are as follows.
... ...
The args are as follows.
target/wasm32-wasi/debug/wasi.wasm
hello
File content is This is in a file
</code></pre>
<h2 id="functions"><a class="header" href="#functions">Functions</a></h2>
<p>As <a href="dev/rust/../rust.html#a-simple-function">we have seen</a>, you can create WebAssembly functions
in a Rust <code>lib.rs</code> project. You can also use WASI functions in those functions.
However, an important caveat is that, without a <code>main()</code> function, you
will need to explicitly call a helper function to initialize
environment for WASI functions to work properly.
In the Rust program, add a helper crate in Cargo.toml so that the WASI initialization code can be applied to your exported public library functions.</p>
<pre><code class="language-toml">[dependencies]
... ...
wasmedge-wasi-helper = &quot;=0.2.0&quot;
</code></pre>
<p>In the Rust function, we need to call <code>_initialize()</code> before we access any arguments and environment variables or operate any files.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn print_env() -&gt; i32 {
  _initialize();
  ... ...
}

pub fn create_file(path: &amp;str, content: &amp;str) -&gt; String {
  _initialize();
  ... ...
}

pub fn read_file(path: &amp;str) -&gt; String {
  _initialize();
  ... ...
}

pub fn del_file(path: &amp;str) -&gt; String {
  _initialize();
  ... ...
}
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tensorflow"><a class="header" href="#tensorflow">Tensorflow</a></h1>
<p>AI inference is a computationally intensive task that could benefit greatly from the speed of Rust and WebAssembly. However, the standard WebAssembly sandbox provides very limited access to the native OS and hardware, such as multi-core CPUs, GPU and specialized AI inference chips. It is not ideal for the AI workload.</p>
<p>The popular WebAssembly System Interface (WASI) provides a design pattern for sandboxed WebAssembly programs to securely access native host functions. The WasmEdge Runtime extends the WASI model to support access to native Tensorflow libraries from WebAssembly programs. The <a href="https://github.com/second-state/wasmedge_tensorflow_interface">WasmEdge Tensorflow Rust SDK</a> provides the security, portability, and ease-of-use of WebAssembly and native speed for Tensorflow.</p>
<blockquote>
<p>If you are not familiar with Rust, you can try our <a href="https://github.com/second-state/wasm-learning/tree/master/cli/classify_yml">experimental AI inference DSL</a> or try our <a href="dev/rust/../js/tensorflow.html">JavaScript examples</a>.</p>
</blockquote>
<h2 id="table-of-contents"><a class="header" href="#table-of-contents">Table of contents</a></h2>
<ul>
<li><a href="dev/rust/tensorflow.html#a-rust-example">A Rust example</a></li>
<li><a href="dev/rust/tensorflow.html#deployment-options">Deployment options</a></li>
</ul>
<h2 id="a-rust-example"><a class="header" href="#a-rust-example">A Rust example</a></h2>
<h3 id="prerequisite"><a class="header" href="#prerequisite">Prerequisite</a></h3>
<p>You need to install <a href="dev/rust/../../start/install.html">WasmEdge</a> and <a href="https://www.rust-lang.org/tools/install">Rust</a>.</p>
<h3 id="build"><a class="header" href="#build">Build</a></h3>
<p>Check out the example source code.</p>
<pre><code class="language-bash">git clone https://github.com/second-state/wasm-learning/
cd cli/tflite
</code></pre>
<p>Use Rust <code>Cargo</code> to build the WebAssembly target.</p>
<pre><code class="language-bash">rustup target add wasm32-wasi
cargo build --target wasm32-wasi --release
</code></pre>
<h3 id="run"><a class="header" href="#run">Run</a></h3>
<p>The <code>wasmedge-tensorflow-lite</code> utility is the WasmEdge build that includes the Tensorflow and Tensorflow Lite extensions.</p>
<pre><code class="language-bash">$ wasmedge-tensorflow-lite target/wasm32-wasi/release/classify.wasm &lt; grace_hopper.jpg
It is very likely a &lt;a href='https://www.google.com/search?q=military uniform'&gt;military uniform&lt;/a&gt; in the picture
</code></pre>
<h3 id="make-it-run-faster"><a class="header" href="#make-it-run-faster">Make it run faster</a></h3>
<p>To make Tensorflow inference run <em>much</em> faster, you could AOT compile it down to machine native code, and then use WasmEdge sandbox to run the native code.</p>
<pre><code class="language-bash">$ wasmedgec target/wasm32-wasi/release/classify.wasm classify.wasm
$ wasmedge-tensorflow-lite classify.wasm &lt; grace_hopper.jpg
It is very likely a &lt;a href='https://www.google.com/search?q=military uniform'&gt;military uniform&lt;/a&gt; in the picture
</code></pre>
<h3 id="code-walkthrough"><a class="header" href="#code-walkthrough">Code walkthrough</a></h3>
<p>It is fairly straightforward to use the WasmEdge Tensorflow API. You can see the entire source code in <a href="https://github.com/second-state/wasm-learning/blob/master/cli/tflite/src/main.rs">main.rs</a>.</p>
<p>First, it reads the trained TFLite model file (ImageNet) and its label file. The label file maps numeric output from the model to English names for the classified objects.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>  let model_data: &amp;[u8] = include_bytes!(&quot;models/mobilenet_v1_1.0_224/mobilenet_v1_1.0_224_quant.tflite&quot;);
  let labels = include_str!(&quot;models/mobilenet_v1_1.0_224/labels_mobilenet_quant_v1_224.txt&quot;);
<span class="boring">}
</span></code></pre></pre>
<p>Next, it reads the image from <code>STDIN</code> and converts it to the size and RGB pixel arrangement required by the Tensorflow Lite model.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>  let mut buf = Vec::new();
  io::stdin().read_to_end(&amp;mut buf).unwrap();

  let flat_img = wasmedge_tensorflow_interface::load_jpg_image_to_rgb8(&amp;buf, 224, 224);
<span class="boring">}
</span></code></pre></pre>
<p>Then, the program runs the TFLite model with its required input tensor (i.e., the flat image in this case), and receives the model output. In this case, the model output is an array of numbers. Each number corresponds to the probability of an object name in the label text file.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>  let mut session = wasmedge_tensorflow_interface::Session::new(&amp;model_data, wasmedge_tensorflow_interface::ModelType::TensorFlowLite);
  session.add_input(&quot;input&quot;, &amp;flat_img, &amp;[1, 224, 224, 3])
         .run();
  let res_vec: Vec&lt;u8&gt; = session.get_output(&quot;MobilenetV1/Predictions/Reshape_1&quot;);
<span class="boring">}
</span></code></pre></pre>
<p>Let's find the object with the highest probability, and then look up the name in the labels file.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>  let mut i = 0;
  let mut max_index: i32 = -1;
  let mut max_value: u8 = 0;
  while i &lt; res_vec.len() {
    let cur = res_vec[i];
    if cur &gt; max_value {
      max_value = cur;
      max_index = i as i32;
    }
    i += 1;
  }

  let mut label_lines = labels.lines();
  for _i in 0..max_index {
    label_lines.next();
  }
<span class="boring">}
</span></code></pre></pre>
<p>Finally, it prints the result to <code>STDOUT</code>.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>  let class_name = label_lines.next().unwrap().to_string();
  if max_value &gt; 50 {
    println!(&quot;It {} a &lt;a href='https://www.google.com/search?q={}'&gt;{}&lt;/a&gt; in the picture&quot;, confidence.to_string(), class_name, class_name);
  } else {
    println!(&quot;It does not appears to be any food item in the picture.&quot;);
  }
<span class="boring">}
</span></code></pre></pre>
<h2 id="deployment-options"><a class="header" href="#deployment-options">Deployment options</a></h2>
<p>All the tutorials below use the <a href="https://github.com/second-state/wasmedge_tensorflow_interface">WasmEdge Rust API for Tensorflow</a> to create AI inference functions. Those Rust functions are then compiled to WebAssembly and deployed together with WasmEdge on the cloud.</p>
<h3 id="serverless-functions"><a class="header" href="#serverless-functions">Serverless functions</a></h3>
<p>The following tutorials showcase how to deploy WebAssembly programs (written in Rust) on public cloud serverless platforms. The WasmEdge Runtime runs inside a Docker container on those platforms. Each serverless platform provides APIs to get data into and out of the WasmEdge runtime through STDIN and STDOUT.</p>
<ul>
<li><a href="https://www.secondstate.io/articles/vercel-wasmedge-webassembly-rust/">Vercel Serverless Functions</a></li>
<li><a href="https://www.secondstate.io/articles/netlify-wasmedge-webassembly-rust-serverless/">Netlify Functions</a></li>
<li><a href="https://github.com/second-state/aws-lambda-wasm-runtime">AWS Lambda</a></li>
<li><a href="https://github.com/second-state/tencent-scf-wasm-runtime">Tencent Serverless Functions</a> (in Chinese)</li>
</ul>
<h3 id="second-sate-faas-and-nodejs"><a class="header" href="#second-sate-faas-and-nodejs">Second Sate FaaS and Node.js</a></h3>
<p>The following tutorials showcase how to deploy WebAssembly functions (written in Rust) on the Second State FaaS. Since the FaaS service is running on Node.js, you can follow the same tutorials for running those functions in your own Node.js server.</p>
<ul>
<li><a href="https://www.secondstate.io/articles/faas-image-classification/">Tensorflow: Image classification using the MobileNet models</a> | <a href="https://second-state.github.io/wasm-learning/faas/mobilenet/html/index.html">Live demo</a></li>
<li><a href="https://www.secondstate.io/articles/faas-face-detection/">Tensorflow: Face detection using the MTCNN models</a> | <a href="https://second-state.github.io/wasm-learning/faas/mtcnn/html/index.html">Live demo</a></li>
</ul>
<h3 id="service-mesh"><a class="header" href="#service-mesh">Service mesh</a></h3>
<p>The following tutorials showcase how to deploy WebAssembly functions and programs (written in Rust) as sidecar microservices.</p>
<ul>
<li><a href="https://github.com/second-state/dapr-wasm">The Dapr template</a> shows how to build and deploy Dapr sidecars in Go and Rust languages. The sidecars then use the WasmEdge SDK to start WebAssembly programs to process workloads to the microservices.</li>
</ul>
<h3 id="data-streaming-framework"><a class="header" href="#data-streaming-framework">Data streaming framework</a></h3>
<p>The following tutorials showcase how to deploy WebAssembly functions (written in Rust) as embedded handler functions in data streaming frameworks for AIoT.</p>
<ul>
<li><a href="https://www.secondstate.io/articles/yomo-wasmedge-real-time-data-streams/">The YoMo template</a> starts the WasmEdge Runtime to process image data as the data streams in from a camera in a smart factory.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="simple-networking-sockets"><a class="header" href="#simple-networking-sockets">Simple networking sockets</a></h1>
<p>The <a href="https://github.com/second-state/wasmedge_wasi_socket">wasmedge_wasi_socket</a> crate enables Rust developers to create networking applications and compile them into WebAssembly for WasmEdge Runtime. One of the key features of WasmEdge is that it supports non-blocking sockets. That allows even a single threaded WASM application to handle concurrent network requests. For example, while the program is waiting for data to stream in from one connection, it can start or handle another connection.</p>
<p>In this chapter, we will start with simple HTTP client and server examples. Then <a href="dev/rust/networking-nonblocking.html">in the next chapter</a>, we will cover the more complex non-blocking examples.</p>
<h2 id="an-http-client-example"><a class="header" href="#an-http-client-example">An HTTP client example</a></h2>
<p>The <a href="https://github.com/second-state/wasmedge_wasi_socket/tree/main/examples/http_client">source code</a> for the HTTP client is available as follows.</p>
<pre><pre class="playground"><code class="language-rust">use wasmedge_http_req::request;

fn main() {
  let mut writer = Vec::new(); //container for body of a response
  let res = request::get(&quot;http://127.0.0.1:1234/get&quot;, &amp;mut writer).unwrap();

  println!(&quot;GET&quot;);
  println!(&quot;Status: {} {}&quot;, res.status_code(), res.reason());
  println!(&quot;Headers {}&quot;, res.headers());
  println!(&quot;{}&quot;, String::from_utf8_lossy(&amp;writer));

  let mut writer = Vec::new(); //container for body of a response
  const BODY: &amp;[u8; 27] = b&quot;field1=value1&amp;field2=value2&quot;;
  // let res = request::post(&quot;https://httpbin.org/post&quot;, BODY, &amp;mut writer).unwrap();
  // no https , no dns
  let res = request::post(&quot;http://127.0.0.1:1234/post&quot;, BODY, &amp;mut writer).unwrap();

  println!(&quot;POST&quot;);
  println!(&quot;Status: {} {}&quot;, res.status_code(), res.reason());
  println!(&quot;Headers {}&quot;, res.headers());
  println!(&quot;{}&quot;, String::from_utf8_lossy(&amp;writer));
}
</code></pre></pre>
<p>The following command compiles the Rust program.</p>
<pre><code class="language-bash">cargo build --target wasm32-wasi --release
</code></pre>
<p>The following command runs the application in WasmEdge.</p>
<pre><code class="language-bash">wasmedge target/wasm32-wasi/release/http_client.wasm
</code></pre>
<h2 id="an-http-server-example"><a class="header" href="#an-http-server-example">An HTTP server example</a></h2>
<p>The <a href="https://github.com/second-state/wasmedge_wasi_socket/tree/main/examples/http_server">source code</a> for the HTTP server application is available as follows.</p>
<pre><pre class="playground"><code class="language-rust">use bytecodec::DecodeExt;
use httpcodec::{HttpVersion, ReasonPhrase, Request, RequestDecoder, Response, StatusCode};
use std::io::{Read, Write};
#[cfg(feature = &quot;std&quot;)]
use std::net::{Shutdown, TcpListener, TcpStream};
#[cfg(not(feature = &quot;std&quot;))]
use wasmedge_wasi_socket::{Shutdown, TcpListener, TcpStream};

fn handle_http(req: Request&lt;String&gt;) -&gt; bytecodec::Result&lt;Response&lt;String&gt;&gt; {
  Ok(Response::new(
    HttpVersion::V1_0,
    StatusCode::new(200)?,
    ReasonPhrase::new(&quot;&quot;)?,
    format!(&quot;echo: {}&quot;, req.body()),
  ))
}

fn handle_client(mut stream: TcpStream) -&gt; std::io::Result&lt;()&gt; {
  let mut buff = [0u8; 1024];
  let mut data = Vec::new();

  loop {
    let n = stream.read(&amp;mut buff)?;
    data.extend_from_slice(&amp;buff[0..n]);
    if n &lt; 1024 {
      break;
    }
  }

  let mut decoder =
    RequestDecoder::&lt;httpcodec::BodyDecoder&lt;bytecodec::bytes::Utf8Decoder&gt;&gt;::default();

  let req = match decoder.decode_from_bytes(data.as_slice()) {
    Ok(req) =&gt; handle_http(req),
    Err(e) =&gt; Err(e),
  };

  let r = match req {
    Ok(r) =&gt; r,
    Err(e) =&gt; {
      let err = format!(&quot;{:?}&quot;, e);
      Response::new(
        HttpVersion::V1_0,
        StatusCode::new(500).unwrap(),
        ReasonPhrase::new(err.as_str()).unwrap(),
        err.clone(),
      )
    }
  };

  let write_buf = r.to_string();
  stream.write(write_buf.as_bytes())?;
  stream.shutdown(Shutdown::Both)?;
  Ok(())
}

fn main() -&gt; std::io::Result&lt;()&gt; {
  let port = std::env::var(&quot;PORT&quot;).unwrap_or(1234.to_string());
  println!(&quot;new connection at {}&quot;, port);
  let listener = TcpListener::bind(format!(&quot;0.0.0.0:{}&quot;, port))?;
  loop {
    let _ = handle_client(listener.accept()?.0);
  }
}
</code></pre></pre>
<p>The following command compiles the Rust program.</p>
<pre><code class="language-bash">cargo build --target wasm32-wasi --release
</code></pre>
<p>The following command runs the application in WasmEdge.</p>
<pre><code class="language-bash">$ wasmedge target/wasm32-wasi/release/http_server.wasm
new connection at 1234
</code></pre>
<p>To test the HTTP server, you can submit a HTTP request to it via <code>curl</code>.</p>
<pre><code class="language-bash">$ curl -d &quot;name=WasmEdge&quot; -X POST http://127.0.0.1:1234
echo: name=WasmEdge
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="non-blocking-networking-sockets"><a class="header" href="#non-blocking-networking-sockets">Non-blocking networking sockets</a></h1>
<p>While the simple HTTP connections from the previous chapter are easy to implement, they are not ready for production use. If the program can only have one connection open at a time (e.g., blocking), the fast CPU would be waiting for the slow network. Non-blocking I/O means that the application program can keep multiple connections open at the same time, and process data in and out of those connections as they come in. The program can either alternatingly poll those open connections or wait for incoming data to trigger async functions. That allows I/O intensive programs to run much faster even in a single-threaded environment. In this chapter, we will cover both polling and async programming models.</p>
<h2 id="a-non-blocking-http-client-example"><a class="header" href="#a-non-blocking-http-client-example">A non-blocking HTTP client example</a></h2>
<p>The <a href="https://github.com/second-state/wasmedge_wasi_socket/tree/main/examples/nonblock_http_client">source code</a> for a non-blocking HTTP client application is available. The following <code>main()</code> function starts two HTTP connections. The program keeps both connections open, and alternatingly checks for incoming data from them. In another word, the two connections are not blocking each other. Their data are handled concurrently (or alternatingly) as the data comes in.</p>
<pre><pre class="playground"><code class="language-rust">use httparse::{Response, EMPTY_HEADER};
use std::io::{self, Read, Write};
use std::str::from_utf8;
use wasmedge_wasi_socket::TcpStream;

fn main() {
    let req = &quot;GET / HTTP/1.0\n\n&quot;;
    let mut first_connection = TcpStream::connect(&quot;127.0.0.1:80&quot;).unwrap();
    first_connection.set_nonblocking(true).unwrap();
    first_connection.write_all(req.as_bytes()).unwrap();

    let mut second_connection = TcpStream::connect(&quot;127.0.0.1:80&quot;).unwrap();
    second_connection.set_nonblocking(true).unwrap();
    second_connection.write_all(req.as_bytes()).unwrap();

    let mut first_buf = vec![0; 4096];
    let mut first_bytes_read = 0;
    let mut second_buf = vec![0; 4096];
    let mut second_bytes_read = 0;

    loop {
        let mut first_complete = false;
        let mut second_complete = false;
        if !first_complete {
            match read_data(&amp;mut first_connection, &amp;mut first_buf, first_bytes_read) {
                Ok((bytes_read, false)) =&gt; {
                    first_bytes_read = bytes_read;
                }
                Ok((bytes_read, true)) =&gt; {
                    println!(&quot;First connection completed&quot;);
                    if bytes_read != 0 {
                        parse_data(&amp;first_buf, bytes_read);
                    }
                    first_complete = true;
                }
                Err(e) =&gt; {
                    println!(&quot;First connection error: {}&quot;, e);
                    first_complete = true;
                }
            }
        }
        if !second_complete {
            match read_data(&amp;mut second_connection, &amp;mut second_buf, second_bytes_read) {
                Ok((bytes_read, false)) =&gt; {
                    second_bytes_read = bytes_read;
                }
                Ok((bytes_read, true)) =&gt; {
                    println!(&quot;Second connection completed&quot;);
                    if bytes_read != 0 {
                        parse_data(&amp;second_buf, bytes_read);
                    }
                    second_complete = true;
                }
                Err(e) =&gt; {
                    println!(&quot;Second connection error: {}&quot;, e);
                    second_complete = true;
                }
            }
        }
        if first_complete &amp;&amp; second_complete {
            break;
        }
    }
}
</code></pre></pre>
<p>The following command compiles the Rust program.</p>
<pre><code class="language-bash">cargo build --target wasm32-wasi --release
</code></pre>
<p>The following command runs the application in WasmEdge.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>wasmedge target/wasm32-wasi/release/nonblock_http_client.wasm
<span class="boring">}
</span></code></pre></pre>
<h2 id="a-non-blocking-http-server-example"><a class="header" href="#a-non-blocking-http-server-example">A non-blocking HTTP server example</a></h2>
<p>The <a href="https://github.com/second-state/wasmedge_wasi_socket/tree/main/examples/poll_http_server">source code</a> for a non-blocking HTTP server application is available. The following <code>main()</code> function starts an HTTP server. It receives events from multiple open connections, and processes those events as they are received by calling the async handler functions registered to each connection. This server can process events from multiple open connections concurrently.</p>
<pre><pre class="playground"><code class="language-rust">fn main() -&gt; std::io::Result&lt;()&gt; {
    let mut poll = Poll::new();
    let server = TcpListener::bind(&quot;127.0.0.1:1234&quot;, true)?;
    println!(&quot;Listening on 127.0.0.1:1234&quot;);
    let mut connections = HashMap::new();
    let mut handlers = HashMap::new();
    const SERVER: Token = Token(0);
    let mut unique_token = Token(SERVER.0 + 1);

    poll.register(&amp;server, SERVER, Interest::Read);

    loop {
        let events = poll.poll().unwrap();

        for event in events {
            match event.token {
                SERVER =&gt; loop {
                    let (connection, address) = match server.accept(FDFLAGS_NONBLOCK) {
                        Ok((connection, address)) =&gt; (connection, address),
                        Err(ref e) if e.kind() == std::io::ErrorKind::WouldBlock =&gt; break,
                        Err(e) =&gt; panic!(&quot;accept error: {}&quot;, e),
                    };

                    println!(&quot;Accepted connection from: {}&quot;, address);

                    let token = unique_token.add();
                    poll.register(&amp;connection, token, Interest::Read);
                    connections.insert(token, connection);
                },
                token =&gt; {
                    let done = if let Some(connection) = connections.get_mut(&amp;token) {
                        let handler = match handlers.get_mut(&amp;token) {
                            Some(handler) =&gt; handler,
                            None =&gt; {
                                let handler = Handler::new();
                                handlers.insert(token, handler);
                                handlers.get_mut(&amp;token).unwrap()
                            }
                        };
                        handle_connection(&amp;mut poll, connection, handler, &amp;event)?
                    } else {
                        false
                    };
                    if done {
                        if let Some(connection) = connections.remove(&amp;token) {
                            connection.shutdown(Shutdown::Both)?;
                            poll.unregister(&amp;connection);
                            handlers.remove(&amp;token);
                        }
                    }
                }
            }
        }
    }
}
</code></pre></pre>
<p>The <code>handle_connection()</code> function processes the data from those open connections. In this case, it just writes the request body into the response. It is also done asynchronously -- meaning that the <code>handle_connection()</code> function creates an event for the response, and puts it in the queue. The main application loop processes the event and sends the response when it is waiting for data from other connections.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn handle_connection(
    poll: &amp;mut Poll,
    connection: &amp;mut TcpStream,
    handler: &amp;mut Handler,
    event: &amp;Event,
) -&gt; io::Result&lt;bool&gt; {
    if event.is_readable() {
        let mut connection_closed = false;
        let mut received_data = vec![0; 4096];
        let mut bytes_read = 0;
        loop {
            match connection.read(&amp;mut received_data[bytes_read..]) {
                Ok(0) =&gt; {
                    connection_closed = true;
                    break;
                }
                Ok(n) =&gt; {
                    bytes_read += n;
                    if bytes_read == received_data.len() {
                        received_data.resize(received_data.len() + 1024, 0);
                    }
                }
                Err(ref err) if would_block(err) =&gt; {
                    if bytes_read != 0 {
                        let received_data = &amp;received_data[..bytes_read];
                        let mut bs: parsed::stream::ByteStream =
                            match String::from_utf8(received_data.to_vec()) {
                                Ok(s) =&gt; s,
                                Err(_) =&gt; {
                                    continue;
                                }
                            }
                            .into();
                        let req = match parsed::http::parse_http_request(&amp;mut bs) {
                            Some(req) =&gt; req,
                            None =&gt; {
                                break;
                            }
                        };
                        for header in req.headers.iter() {
                            if header.name.eq(&quot;Conntent-Length&quot;) {
                                let content_length = header.value.parse::&lt;usize&gt;().unwrap();
                                if content_length &gt; received_data.len() {
                                    return Ok(true);
                                }
                            }
                        }
                        println!(
                            &quot;{:?} request: {:?} {:?}&quot;,
                            connection.peer_addr().unwrap(),
                            req.method,
                            req.path
                        );
                        let res = Response {
                            protocol: &quot;HTTP/1.1&quot;.to_string(),
                            code: 200,
                            message: &quot;OK&quot;.to_string(),
                            headers: vec![
                                Header {
                                    name: &quot;Content-Length&quot;.to_string(),
                                    value: req.content.len().to_string(),
                                },
                                Header {
                                    name: &quot;Connection&quot;.to_string(),
                                    value: &quot;close&quot;.to_string(),
                                },
                            ],
                            content: req.content,
                        };

                        handler.response = Some(res.into());

                        poll.reregister(connection, event.token, Interest::Write);
                        break;
                    } else {
                        println!(&quot;Empty request&quot;);
                        return Ok(true);
                    }
                }
                Err(ref err) if interrupted(err) =&gt; continue,
                Err(err) =&gt; return Err(err),
            }
        }

        if connection_closed {
            println!(&quot;Connection closed&quot;);
            return Ok(true);
        }
    }

    if event.is_writable() &amp;&amp; handler.response.is_some() {
        let resp = handler.response.clone().unwrap();
        match connection.write(resp.as_bytes()) {
            Ok(n) if n &lt; resp.len() =&gt; return Err(io::ErrorKind::WriteZero.into()),
            Ok(_) =&gt; {
                return Ok(true);
            }
            Err(ref err) if would_block(err) =&gt; {}
            Err(ref err) if interrupted(err) =&gt; {
                return handle_connection(poll, connection, handler, event)
            }
            Err(err) =&gt; return Err(err),
        }
    }

    Ok(false)
}
<span class="boring">}
</span></code></pre></pre>
<p>The following command compiles the Rust program.</p>
<pre><code class="language-bash">cargo build --target wasm32-wasi --release
</code></pre>
<p>The following command runs the application in WasmEdge.</p>
<pre><code class="language-bash">$ wasmedge target/wasm32-wasi/release/poll_http_server.wasm
new connection at 1234
</code></pre>
<p>To test the HTTP server, you can submit a HTTP request to it via <code>curl</code>.</p>
<pre><code class="language-bash">$ curl -d &quot;name=WasmEdge&quot; -X POST http://127.0.0.1:1234
echo: name=WasmEdge
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="server-side-rendering"><a class="header" href="#server-side-rendering">Server-side rendering</a></h1>
<p>Frontend web frameworks allow developers to create web apps in a high level language and component model. The web app is built into a static web site to be rendered in the browser. While many frontend web frameworks are based on JavaScript, such as React and Vue, Rust-based frameworks are also emerging as the Rust language gains traction among developers. Those web frameworks render the HTML DOM UI using the WebAssembly, which is compiled from Rust source code. They use <a href="https://github.com/rustwasm/wasm-bindgen">wasm-bindgen</a> to tie the Rust to the HTML DOM.
While all of these frameworks send <code>.wasm</code> files to the browser to render the UI on the client-side, some provide the additional choice for <a href="https://en.wikipedia.org/wiki/Server-side_scripting">Server-side rendering</a>. That is to run the WebAssembly code and build the HTML DOM UI on the server, and stream the HTML content to the browser for faster performance and startup time on slow devices and networks.</p>
<blockquote>
<p>If you are interested in JavaScript-based Jamstack and SSR frameworks, such as React, please <a href="dev/rust/../js/ssr.html">checkout our JavaScript SSR chapter</a>.</p>
</blockquote>
<p>This article will explore how to render the web UI on the server using WasmEdge.
We pick <a href="https://github.com/chinedufn/percy">Percy</a> as our framework because it is relatively mature in SSR and <a href="https://en.wikipedia.org/wiki/Hydration_(web_development)">Hydration</a>. Percy already provides an <a href="https://github.com/chinedufn/percy/tree/master/examples/isomorphic">example</a> for SSR. It's highly recommended to read it first to understand how it works. The default SSR setup with Percy utilizes a native Rust web server. The Rust code is compiled to machine native code for the server. However, in order to host user applications on the server, we need a sandbox. While we could run native code inside a Linux container (Docker), a far more efficient (and safer) approach is to run the compiled code in a WebAssembly VM on the server, especially considerring the rendering code is already compiled into WebAssembly.</p>
<p>Now, let's go through the steps to run a Percy SSR service in a WasmEdge server.</p>
<p>Assuming we are in the <code>examples/isomorphic</code> directory, make a new crate beside the existing <code>server</code>.</p>
<pre><code class="language-bash">cargo new server-wasmedge
</code></pre>
<p>You'll receive a warning to let you put the new crate into the workspace, so insert below into <code>members</code> of <code>[workspace]</code>. The file is <code>../../Cargo.toml</code>.</p>
<pre><code class="language-toml">&quot;examples/isomorphic/server-wasmedge&quot;
</code></pre>
<p>With the file open, put these two lines in the bottom:</p>
<pre><code class="language-toml">[patch.crates-io]
wasm-bindgen = { git = &quot;https://github.com/KernelErr/wasm-bindgen.git&quot;, branch = &quot;wasi-compat&quot; }
</code></pre>
<blockquote>
<p>Why do we need a forked <code>wasm-bindgen</code>? That is because <code>wasm-bindgen</code> is the required glue between Rust and HTML in the browser. On the server, however, we need to build the Rust code to the <code>wasm32-wasi</code> target, which is incompatible with <code>wasm-bindgen</code>. Our forked <code>wasm-bindgen</code> has conditional configs that removes browser-specific code in the generated <code>.wasm</code> file for the <code>wasm32-wasi</code> target.</p>
</blockquote>
<p>Then replace the crate's <code>Cargo.toml</code> with following content.</p>
<pre><code class="language-toml">[package]
name = &quot;isomorphic-server-wasmedge&quot;
version = &quot;0.1.0&quot;
edition = &quot;2021&quot;

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]
wasmedge_wasi_socket = &quot;0&quot;
querystring = &quot;1.1.0&quot;
parsed = { version = &quot;0.3&quot;, features = [&quot;http&quot;] }
anyhow = &quot;1&quot;
serde = { version = &quot;1.0&quot;, features = [&quot;derive&quot;] }
isomorphic-app = { path = &quot;../app&quot; } 
</code></pre>
<p>The <code>wasmedge_wasi_socket</code> crate is the socket API of WasmEdge. This project is under development. Next copy the <code>index.html</code> file into the crate's root.</p>
<pre><code class="language-bash">cp server/src/index.html server-wasmedge/src/
</code></pre>
<p>Then let's create some Rust code to start a web service in WasmEdge! The <code>main.rs</code> program listens to the request and sends the response via the stream.</p>
<pre><pre class="playground"><code class="language-rust">use std::io::Write;
use wasmedge_wasi_socket::{Shutdown, TcpListener};

mod handler;
mod mime;
mod response;

fn main() {
    let server = TcpListener::bind(&quot;127.0.0.1:3000&quot;, false).unwrap();
    println!(&quot;Server listening on 127.0.0.1:3000&quot;);

    // Simple single thread HTTP server
    // For server with Pool support, see https://github.com/second-state/wasmedge_wasi_socket/tree/main/examples/poll_http_server
    loop {
        let (mut stream, addr) = server.accept(0).unwrap();
        println!(&quot;Accepted connection from {}&quot;, addr);
        match handler::handle_req(&amp;mut stream, addr) {
            Ok((res, binary)) =&gt; {
                let res: String = res.into();
                let bytes = res.as_bytes();
                stream.write_all(bytes).unwrap();
                if let Some(binary) = binary {
                    stream.write_all(&amp;binary).unwrap();
                }
            }
            Err(e) =&gt; {
                println!(&quot;Error: {:?}&quot;, e);
            }
        };
        stream.shutdown(Shutdown::Both).unwrap();
    }
}
</code></pre></pre>
<p>The <code>handler.rs</code> parses the received data to the path and query objects and return the corresponding response.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use crate::response;
use anyhow::Result;
use parsed::http::Response;
use std::io::Read;
use wasmedge_wasi_socket::{SocketAddr, TcpStream};

pub fn handle_req(stream: &amp;mut TcpStream, addr: SocketAddr) -&gt; Result&lt;(Response, Option&lt;Vec&lt;u8&gt;&gt;)&gt; {
    let mut buf = [0u8; 1024];
    let mut received_data: Vec&lt;u8&gt; = Vec::new();

    loop {
        let n = stream.read(&amp;mut buf)?;
        received_data.extend_from_slice(&amp;buf[..n]);
        if n &lt; 1024 {
            break;
        }
    }

    let mut bs: parsed::stream::ByteStream = match String::from_utf8(received_data) {
        Ok(s) =&gt; s.into(),
        Err(_) =&gt; return Ok((response::bad_request(), None)),
    };

    let req = match parsed::http::parse_http_request(&amp;mut bs) {
        Some(req) =&gt; req,
        None =&gt; return Ok((response::bad_request(), None)),
    };

    println!(&quot;{:?} request: {:?} {:?}&quot;, addr, req.method, req.path);

    let mut path_split = req.path.split(&quot;?&quot;);
    let path = path_split.next().unwrap_or(&quot;/&quot;);
    let query_str = path_split.next().unwrap_or(&quot;&quot;);
    let query = querystring::querify(&amp;query_str);
    let mut init_count: Option&lt;u32&gt; = None;
    for (k, v) in query {
        if k.eq(&quot;init&quot;) {
            match v.parse::&lt;u32&gt;() {
                Ok(v) =&gt; init_count = Some(v),
                Err(_) =&gt; return Ok((response::bad_request(), None)),
            }
        }
    }

    let (res, binary) = if path.starts_with(&quot;/static&quot;) {
        response::file(&amp;path)
    } else {
        // render page
        response::ssr(&amp;path, init_count)
    }
    .unwrap_or_else(|_| response::internal_error());

    Ok((res, binary))
}
<span class="boring">}
</span></code></pre></pre>
<p>The <code>response.rs</code> program packs the response object for static assets and for server rendered content.
For the latter, you could see that SSR happens at <code>app.render().to_string()</code>, the result string is put into HTML by replacing the placeholder text.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use crate::mime::MimeType;
use anyhow::Result;
use parsed::http::{Header, Response};
use std::fs::{read};
use std::path::Path;
use isomorphic_app::App;

const HTML_PLACEHOLDER: &amp;str = &quot;#HTML_INSERTED_HERE_BY_SERVER#&quot;;
const STATE_PLACEHOLDER: &amp;str = &quot;#INITIAL_STATE_JSON#&quot;;

pub fn ssr(path: &amp;str, init: Option&lt;u32&gt;) -&gt; Result&lt;(Response, Option&lt;Vec&lt;u8&gt;&gt;)&gt; {
    let html = format!(&quot;{}&quot;, include_str!(&quot;./index.html&quot;));

    let app = App::new(init.unwrap_or(1001), path.to_string());
    let state = app.store.borrow();

    let html = html.replace(HTML_PLACEHOLDER, &amp;app.render().to_string());
    let html = html.replace(STATE_PLACEHOLDER, &amp;state.to_json());

    Ok((Response {
        protocol: &quot;HTTP/1.0&quot;.to_string(),
        code: 200,
        message: &quot;OK&quot;.to_string(),
        headers: vec![
            Header {
                name: &quot;content-type&quot;.to_string(),
                value: MimeType::from_ext(&quot;html&quot;).get(),
            },
            Header {
                name: &quot;content-length&quot;.to_string(),
                value: html.len().to_string(),
            },
        ],
        content: html.into_bytes(),
    }, None))
}

/// Get raw file content
pub fn file(path: &amp;str) -&gt; Result&lt;(Response, Option&lt;Vec&lt;u8&gt;&gt;)&gt; {
    let path = Path::new(&amp;path);
    if path.exists() {
        let content_type: MimeType = match path.extension() {
            Some(ext) =&gt; MimeType::from_ext(ext.to_str().get_or_insert(&quot;&quot;)),
            None =&gt; MimeType::from_ext(&quot;&quot;),
        };
        let content = read(path)?;

        Ok((Response {
            protocol: &quot;HTTP/1.0&quot;.to_string(),
            code: 200,
            message: &quot;OK&quot;.to_string(),
            headers: vec![
                Header {
                    name: &quot;content-type&quot;.to_string(),
                    value: content_type.get(),
                },
                Header {
                    name: &quot;content-length&quot;.to_string(),
                    value: content.len().to_string(),
                },
            ],
            content: vec![],
        }, Some(content)))
    } else {
        Ok((Response {
            protocol: &quot;HTTP/1.0&quot;.to_string(),
            code: 404,
            message: &quot;Not Found&quot;.to_string(),
            headers: vec![],
            content: vec![],
        }, None))
    }
}

/// Bad Request
pub fn bad_request() -&gt; Response {
    Response {
        protocol: &quot;HTTP/1.0&quot;.to_string(),
        code: 400,
        message: &quot;Bad Request&quot;.to_string(),
        headers: vec![],
        content: vec![],
    }
}

/// Internal Server Error
pub fn internal_error() -&gt; (Response, Option&lt;Vec&lt;u8&gt;&gt;) {
    (Response {
        protocol: &quot;HTTP/1.0&quot;.to_owned(),
        code: 500,
        message: &quot;Internal Server Error&quot;.to_owned(),
        headers: vec![],
        content: vec![],
    }, None)
}
<span class="boring">}
</span></code></pre></pre>
<p>The <code>mime.rs</code> program is a map for assets' extension name and the Mime type.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct MimeType {
    pub r#type: String,
}

impl MimeType {
    pub fn new(r#type: &amp;str) -&gt; Self {
        MimeType {
            r#type: r#type.to_string(),
        }
    }

    pub fn from_ext(ext: &amp;str) -&gt; Self {
        match ext {
            &quot;html&quot; =&gt; MimeType::new(&quot;text/html&quot;),
            &quot;css&quot; =&gt; MimeType::new(&quot;text/css&quot;),
            &quot;map&quot; =&gt; MimeType::new(&quot;application/json&quot;),
            &quot;js&quot; =&gt; MimeType::new(&quot;application/javascript&quot;),
            &quot;json&quot; =&gt; MimeType::new(&quot;application/json&quot;),
            &quot;svg&quot; =&gt; MimeType::new(&quot;image/svg+xml&quot;),
            &quot;wasm&quot; =&gt; MimeType::new(&quot;application/wasm&quot;),
            _ =&gt; MimeType::new(&quot;text/plain&quot;),
        }
    }

    pub fn get(self) -&gt; String {
        self.r#type
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>That's it! Now let's build and run the web application. If you have tested the original example, you probably have already built the client WebAssembly.</p>
<pre><code class="language-bash">cd client
./build-wasm.sh
</code></pre>
<p>Next, build and run the server.</p>
<pre><code class="language-bash">cd ../server-wasmedge
cargo build --target wasm32-wasi
OUTPUT_CSS=&quot;$(pwd)/../client/build/app.css&quot; wasmedge --dir /static:../client/build ../../../target/wasm32-wasi/debug/isomorphic-server-wasmedge.wasm
</code></pre>
<p>Navigate to <code>http://127.0.0.1:3000</code> and you will see the web application in action.</p>
<p>Furthermore, you can place all the steps into a shell script <code>../start-wasmedge.sh</code>.</p>
<pre><code class="language-bash">#!/bin/bash

cd $(dirname $0)

cd ./client

./build-wasm.sh

cd ../server-wasmedge

OUTPUT_CSS=&quot;$(pwd)/../client/build/app.css&quot; cargo run -p isomorphic-server-wasmedge
</code></pre>
<p>Add the following to the <code>.cargo/config.toml</code> file.</p>
<pre><code class="language-toml">[build]
target = &quot;wasm32-wasi&quot;

[target.wasm32-wasi]
runner = &quot;wasmedge --dir /static:../client/build&quot; 
</code></pre>
<p>After that, a single CLI command <code>./start-wasmedge.sh</code> would perform all the tasks to build and run the web application!</p>
<p>We forked the Percy repository and made a ready-to-build <a href="https://github.com/second-state/percy/tree/master/examples/isomorphic/server-wasmedge">server-wasmedge</a> example project for you. Happy coding!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="command-interface"><a class="header" href="#command-interface">Command interface</a></h1>
<p>WASI enables WebAssembly programs to call standard library functions in the host operating system. It does so through a fine-grained security model known as “capability-based security”. The WebAssembly VM owner can grant access to host system resources when the VM starts up. The program cannot access any resources (e.g., file folders) that are not explicitly allowed.</p>
<p>Now, why limit ourselves to standard library functions? The same approach can be used to call just any host functions from WebAssembly. The Second State WebAssembly VM provides a WASI-like extension to access any command line programs in the host operating system.</p>
<p>The command line program can</p>
<ul>
<li>Take input via command line arguments, as well as the <code>STDIN</code> stream.</li>
<li>Return value and data via the <code>STDOUT</code> stream.</li>
</ul>
<p>Application developers for WasmEdge can use our Rust interface crate to access this functionality. In <code>Cargo.toml</code>, make sure that you have this dependency.</p>
<pre><code class="language-toml">[dependencies]
rust_process_interface_library = &quot;0.1.3&quot;
</code></pre>
<p>In the Rust application, you can now use the API methods to start a new process for the operating system command program, pass in arguments via the <code>arg()</code> method as well as via the <code>STDIN</code>, and receives the return values via the <code>STDOUT</code>.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut cmd = Command::new(&quot;http_proxy&quot;);

cmd.arg(&quot;post&quot;)
   .arg(&quot;https://api.sendgrid.com/v3/mail/send&quot;)
   .arg(auth_header);  
cmd.stdin_u8vec(payload.to_string().as_bytes());

let out = cmd.output();
<span class="boring">}
</span></code></pre></pre>
<p>The Rust function is then compiled into WebAssembly and can run in the WasmEdge.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="javascript"><a class="header" href="#javascript">JavaScript</a></h1>
<p>WebAssembly started as a &quot;JavaScript alternative for browsers&quot;. The idea is to run high-performance applications compiled from languages like C/C++ or Rust safely in browsers. In the browser, WebAssembly runs side by side with JavaScript.</p>
<p>As WebAssembly is increasingly used in the cloud, it is now a universal runtime for cloud-native applications. Compared with Linux containers, WebAssembly runtimes achieve higher performance with lower resource consumption.</p>
<p>In cloud-native use cases, developers often want to use JavaScript to write business applications. That means we must now support JavaScript in WebAssembly. Furthermore, we should support calling C/C++ or Rust functions from JavaScript in a WebAssembly runtime to take advantage of WebAssembly's computational efficiency. The WasmEdge WebAssembly runtime allows you to do exactly that.</p>
<p><img src="dev/javascript.png" alt="javascript" /></p>
<p>In this section, we will demonstrate how to run and enhance JavaScript in WasmEdge.</p>
<ul>
<li><a href="dev/js/quickstart.html">Getting started</a> demonstrates how to run simple JavaScript programs in WasmEdge.</li>
<li><a href="dev/js/networking.html">Networking sockets</a> shows how to create non-blocking (async) HTTP client and server applications using the WasmEdge networking extension and its JavaScript API.</li>
<li><a href="dev/js/fetch.html">Fetch</a> shows how to use the popular <code>fetch</code> API to fetch content across the network asynchronously.</li>
<li><a href="dev/js/tensorflow.html">TensorFlow</a> shows how to use WasmEdge's TensorFlow extension from its JavaScript API.</li>
<li><a href="dev/js/ssr.html">React SSR</a> shows example React SSR applications, including streaming SSR support.</li>
<li><a href="dev/js/es6.html">ES6 module</a> shows how to incorporate ES6 modules in WasmEdge.</li>
<li><a href="dev/js/npm.html">NodeJS and NPM module</a> shows how to incorporate NPM modules in WasmEdge.</li>
<li><a href="dev/js/rust.html">Use Rust to implement JS API</a> discusses how to use Rust to implement and support a JavaScript API.</li>
</ul>
<h2 id="a-note-on-v8"><a class="header" href="#a-note-on-v8">A note on v8</a></h2>
<p>Now, the choice of QuickJS as our JavaScript engine might raise the question of performance. Isn't QuickJS <a href="https://bellard.org/quickjs/bench.html">a lot slower</a> than v8 due to a lack of JIT support? Yes, but ...</p>
<p>First of all, QuickJS is a lot smaller than v8. In fact, it only takes 1/40 (or 2.5%) of the runtime resources v8 consumes. You can run a lot more QuickJS functions than v8 functions on a single physical machine.</p>
<p>Second, for most business logic applications, raw performance is not critical. The application may have computationally intensive tasks, such as AI inference on the fly. WasmEdge allows the QuickJS applications to drop to high-performance WebAssembly for these tasks while it is not so easy with v8 to add such extensions modules.</p>
<p>Third, WasmEdge is <a href="dev/../kubernetes.html">itself an OCI compliant container</a>.
It is secure by default, supports resource isolation, and can be managed by container tools to run side by side with Linux containers in a single k8s cluster.</p>
<p>Finally, v8 has a very large attack surface and requires <a href="https://blog.cloudflare.com/mitigating-spectre-and-other-security-threats-the-cloudflare-workers-security-model/">major efforts</a> to run securely in a public cloud environment.
It is known that <a href="https://www.theregister.com/2021/08/06/edge_super_duper_security_mode/">many JavaScript security issues arise from JIT</a>. Maybe turning off JIT in the cloud-native environment is not such a bad idea!</p>
<p>In the end, running v8 in a cloud-native environment often requires a full stack of software tools consisting of &quot;Linux container + guest OS + node or deno + v8&quot;, which makes it much heavier and slower than a simple WasmEdge + QuickJS container runtime.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="quick-start-with-javascript-on-wasmedge"><a class="header" href="#quick-start-with-javascript-on-wasmedge">Quick start with JavaScript on WasmEdge</a></h1>
<p>First, let's build a WebAssembly-based JavaScript interpreter program for WasmEdge. It is based on <a href="https://bellard.org/quickjs/">QuickJS</a> with WasmEdge extensions, such as <a href="https://github.com/second-state/wasmedge_wasi_socket">network sockets</a> and <a href="https://www.secondstate.io/articles/wasi-tensorflow/">Tensorflow inference</a>, incorporated into the interpreter as JavaScript APIs. You will need to <a href="https://www.rust-lang.org/tools/install">install Rust</a> to build the interpreter.</p>
<blockquote>
<p>If you just want to use the interpreter to run JavaScript programs, you can skip this section. Make sure you have installed <a href="https://www.rust-lang.org/tools/install">Rust</a> and <a href="dev/js/../../start/install.html">WasmEdge</a>.</p>
</blockquote>
<p>Fork or clone <a href="https://github.com/second-state/wasmedge-quickjs">the wasmedge-quickjs Github repository</a> to get started.</p>
<pre><code class="language-bash">git clone https://github.com/second-state/wasmedge-quickjs
</code></pre>
<p>Following the instructions from that repo, you will be able to build a JavaScript interpreter for WasmEdge.</p>
<pre><code class="language-bash"># Install GCC
sudo apt update
sudo apt install build-essential

# Install wasm32-wasi target for Rust
rustup target add wasm32-wasi

# Build the QuickJS JavaScript interpreter
cargo build --target wasm32-wasi --release
</code></pre>
<p>The WebAssembly-based JavaScript interpreter program is located in the build target directory. You can now try a simple &quot;hello world&quot; JavaScript program (<a href="https://github.com/second-state/wasmedge-quickjs/blob/main/example_js/hello.js">example_js/hello.js</a>), which prints out the command line arguments to the console.</p>
<pre><code class="language-javascript">import * as os from 'os';
import * as std from 'std';

args = args.slice(1);
print('Hello', ...args);
setTimeout(() =&gt; {
  print('timeout 2s');
}, 2000);
</code></pre>
<p>Run the <code>hello.js</code> file in WasmEdge’s QuickJS runtime as follows.</p>
<pre><code class="language-bash">$ cd example_js
$ wasmedge --dir .:. ../target/wasm32-wasi/release/wasmedge_quickjs.wasm hello.js WasmEdge Runtime
Hello WasmEdge Runtime
</code></pre>
<blockquote>
<p>Note: the <code>--dir .:.</code> on the command line is to give <code>wasmedge</code> permission to read the local directory in the file system for the <code>hello.js</code> file. We will use  <code>--dir .:.</code> in the following sections.</p>
</blockquote>
<h2 id="make-it-faster"><a class="header" href="#make-it-faster">Make it faster</a></h2>
<p>WasmEdge provides a <code>wasmedgec</code> utility to compile and add a native machine code section to the <code>wasm</code> file. You can use <code>wasmedge</code> to run the natively instrumented <code>wasm</code> file to get much faster performance.</p>
<pre><code class="language-bash">wasmedgec ../../target/wasm32-wasi/release/wasmedge_quickjs.wasm wasmedge_quickjs.wasm
wasmedge --dir .:. wasmedge_quickjs.wasm hello.js
</code></pre>
<p>Next, we will discuss more advanced use case for JavaScript in WasmEdge.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="async-networking-apps"><a class="header" href="#async-networking-apps">Async networking apps</a></h1>
<p>The QuickJS WasmEdge Runtime supports the WasmEdge <a href="https://github.com/second-state/wasmedge_wasi_socket">networking socket extension</a> so that the JavaScript programs can make HTTP connections to the Internet. This article will show you both <a href="https://github.com/second-state/wasmedge-quickjs/blob/main/example_js/wasi_http_client.js">HTTP Client</a> and <a href="https://github.com/second-state/wasmedge-quickjs/blob/main/example_js/wasi_http_echo.js">HTTP Server</a> examples.</p>
<blockquote>
<p>The networking API in WasmEdge is non-blocking and hence supports asynchronous I/O intensive applications. With this API, the JavaScript program can open multiple connections concurrently. It polls those connections, or registers async callback functions, to process data whenever data comes in, without waiting for any one connection to complete its data transfer. That allows the single-threaded application to handle multiple multiple concurrent requests.</p>
</blockquote>
<h2 id="a-javascript-networking-client-example"><a class="header" href="#a-javascript-networking-client-example">A JavaScript networking client example</a></h2>
<p>Below is an example of JavaScript running an async HTTP client. You could find the code in <a href="https://github.com/second-state/wasmedge-quickjs/blob/main/example_js/wasi_http_client.js">example_js/wasi_http_client.js</a>. The code below shows how to make an async HTTP GET request.</p>
<pre><code class="language-javascript">async function get_test() {
  try {
    let ss = await net.connect('152.136.235.225:80');
    let req = new http.WasiRequest();
    req.headers = { 'Host': '152.136.235.225' };
    req.uri = '/get?a=123';
    req.method = 'GET';
    ss.write(req.encode());
    print('wait get');
    await handle_response(ss);
    print('get end');

  } catch (e) {
    print('catch:', e);
  }
}
</code></pre>
<p>The program can open multiple requests while waiting for the servers to respond. Once a server responds, the <code>handle_response()</code> function is called asynchronously to process the response and to print out the content.</p>
<pre><code class="language-javascript">async function handle_response(s) {
  let buf = new http.Buffer();
  let resp = undefined;
  while (true) {
    buf.append(await s.read());
    if (resp == undefined) {
      resp = buf.parseResponse();
    }
    if (resp instanceof http.WasiResponse) {
      let resp_length = resp.bodyLength;
      if (typeof (resp_length) === &quot;number&quot;) {
        if (buf.length &gt;= resp.bodyLength) {
          print('resp.body');
          print(newStringFromUTF8(buf.buffer));
          break;
        }
      } else {
        throw new Error('no support');
      }
    }
  }
}
</code></pre>
<p>To run the JavaScript in the WasmEdge runtime, you can do this on the CLI.</p>
<pre><code class="language-bash">cd example_js
wasmedge --dir .:. ../target/wasm32-wasi/release/wasmedge_quickjs.wasm wasi_http_client.js
</code></pre>
<p>The results printed to the console are as follows.</p>
<pre><code class="language-json">{
  &quot;args&quot;: {
    &quot;a&quot;: &quot;123&quot;
  }, 
  &quot;data&quot;: &quot;hello&quot;, 
  &quot;files&quot;: {}, 
  &quot;form&quot;: {}, 
  &quot;headers&quot;: {
    &quot;Content-Length&quot;: &quot;5&quot;, 
    &quot;Host&quot;: &quot;152.136.235.225&quot;
  }, 
  &quot;json&quot;: null, 
  &quot;origin&quot;: &quot;20.124.39.106&quot;, 
  &quot;url&quot;: &quot;http://152.136.235.225/post?a=123&quot;
}
</code></pre>
<p>The demo app does two HTTP requests. One is <code>GET</code> and the other is <code>POST</code>. The app waits for the responses from those two requests asynchronously, and processes them as they come in. From the console log, you can see how the two request handlers are interweaved.</p>
<h2 id="a-javascript-networking-server-example"><a class="header" href="#a-javascript-networking-server-example">A JavaScript networking server example</a></h2>
<p>Below is an example of JavaScript running a TCP server listening at port 8000. The incoming requests are handled asynchronously. You could find the code in <a href="https://github.com/second-state/wasmedge-quickjs/blob/main/example_js/wasi_net_echo.js">example_js/wasi_net_echo.js</a>.</p>
<pre><code class="language-javascript">import * as net from 'wasi_net';

async function handle_client(cs) {
  try {
    while (true) {
      let d = await cs.read();
      if (d == undefined || d.byteLength &lt;= 0) {
        break;
      }
      let s = newStringFromUTF8(d);
      cs.write('echo:' + s);
    }
  } catch (e) {
    print(e);
  }
}

async function server_start() {
  print('listen 8000 ...');
  try {
    let s = new net.WasiTcpServer(8000);
    for (var i = 0; i &lt; 100; i++) {
      let cs = await s.accept();
      handle_client(cs);
    }
  } catch (e) {
    print(e)
  }
}

server_start();
</code></pre>
<p>The <code>server_start()</code> function starts the server at port 8000. When a request comes in, it accepts immediately and calls the <code>handle_client()</code> function to process it asynchronously when the request data is received later. While the <code>handle_client()</code> is waiting for the data to arrive from the network, the app could accept another request concurrently.</p>
<p>To run the JavaScript in the WasmEdge runtime, you can do this on the CLI. Since it is a server, you should run it in the background.</p>
<pre><code class="language-bash">cd example_js
nohup wasmedge --dir .:. ../target/wasm32-wasi/release/wasmedge_quickjs.wasm wasi_net_echo.js &amp;
</code></pre>
<p>Then you can test the server by querying it over the network.</p>
<pre><code class="language-bash">$ curl -d &quot;WasmEdge&quot; -X POST http://localhost:8000
echo:WasmEdge
</code></pre>
<p>The <code>wasi_net</code> package provides a flexible asynchronous networking stack for JavaScript applications in WasmEdge. We are wrap it in high-level APIs for more advanced use cases. In the next section, we will show you how to handle HTTP requests with ease. In the <a href="dev/js/ssr.html">React SSR article</a>, we will discuss how to create a React stream SSR server with the async networking API.</p>
<h2 id="a-javascript-http-server-example"><a class="header" href="#a-javascript-http-server-example">A JavaScript HTTP server example</a></h2>
<p>If you already knew the server's requests and responses are in the HTTP protocol, there are additional helper functions to help you handle these requests. You could find the code in <a href="https://github.com/second-state/wasmedge-quickjs/blob/main/example_js/wasi_http_echo.js">example_js/wasi_http_echo.js</a>.</p>
<pre><code class="language-javascript">import * as http from 'wasi_http';
import * as net from 'wasi_net';

async function handle_client(cs, handler_req) {
  let buffer = new http.Buffer();

  while (true) {
    try {
      let d = await cs.read();
      if (d.byteLength &lt;= 0) {
        return;
      }
      buffer.append(d);
      let req = buffer.parseRequest();
      if (req instanceof http.WasiRequest) {
        handler_req(cs, req);
        break;
      }
    } catch (e) {
      print(e);
    }
  }
}

function handler_req(cs, req) {
  print(&quot;version=&quot;, req.version);
  print(&quot;uri=&quot;, req.uri);
  print(&quot;method=&quot;, req.method);
  print(&quot;headers=&quot;, Object.keys(req.headers));
  print(&quot;body=&quot;, newStringFromUTF8(req.body));

  let resp = new http.WasiResponse();
  let body = 'echo:' + newStringFromUTF8(req.body);
  let r = resp.encode(body);
  cs.write(r);
}

async function server_start() {
  try {
    let s = new net.WasiTcpServer(8000);
    for (var i = 0; i &lt; 100; i++) {
      let cs = await s.accept();
      try {
        handle_client(cs, handler_req);
      } catch (e) {
        print(e);
      }
    }
  } catch (e) {
    print(e);
  }
}

server_start();
</code></pre>
<p>The <code>server_start()</code> function starts the server at port 8000. When a request comes in, it accepts immediately and calls the <code>handle_client()</code> async function to process the request data when the data is received later. Once the request is validated as an HTTP request, the handler function in turn calls <code>handle_req()</code> to parse the fields in the HTTP request, compose a HTTP reponse, and then send the response back. While the program is waiting for the request data to arrive from the network, it can accept another request concurrently.</p>
<p>To run the JavaScript in the WasmEdge runtime, you can do this on the CLI. Since it is a server, you should run it in the background.</p>
<pre><code class="language-bash">cd example_js
nohup wasmedge --dir .:. ../target/wasm32-wasi/release/wasmedge_quickjs.wasm wasi_http_echo.js &amp;
</code></pre>
<p>Then you can test the server by querying it over the network.</p>
<pre><code class="language-bash">$ curl -d &quot;WasmEdge&quot; -X POST http://localhost:8000
echo:WasmEdge
</code></pre>
<p>With async HTTP networking, developers can create I/O intensive applications, such as database-driven microservices, in JavaScript and run them safely and efficiently in WasmEdge.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-fetch-api"><a class="header" href="#the-fetch-api">The <code>fetch</code> API</a></h1>
<p>The <code>fetch</code> API is widely used in browser and node-based JavaScript applications to fetch content over the network. Building on top of its non-blocking aysnc network socket API, the WasmEdge QuickJS runtime supports the <code>fetch</code> API. That makes a lot of JS APIs and modules reusable out of the box.</p>
<p>The <a href="https://github.com/second-state/wasmedge-quickjs/blob/main/example_js/wasi_http_fetch.js">example_js/wasi_http_fetch.js</a> example demonstrates how to use the <code>fetch</code> API in WasmEdge. The code snippet below shows an async HTTP GET. While the program waits for and processes the GET content, it can start another request.</p>
<pre><code class="language-javascript">import { fetch } from 'http'

async function test_fetch() {
  try {
    let r = await fetch(&quot;http://152.136.235.225/get?id=1&quot;)
    print('test_fetch\n', await r.text())
  } catch (e) {
    print(e)
  }
}
test_fetch()
</code></pre>
<p>The code snippet below shows how to do an sync HTTP POST to a remote server.</p>
<pre><code class="language-javascript">async function test_fetch_post() {
  try {
    let r = await fetch(&quot;http://152.136.235.225/post&quot;, { method: 'post', 'body': 'post_body' })
    print('test_fetch_post\n', await r.text())
  } catch (e) {
    print(e)
  }
}
test_fetch_post()
</code></pre>
<p>An async HTTP PUT request is as follows.</p>
<pre><code class="language-javascript">async function test_fetch_put() {
  try {
    let r = await fetch(&quot;http://152.136.235.225/put&quot;,
      {
        method: &quot;put&quot;,
        body: JSON.stringify({ a: 1 }),
        headers: { 'Context-type': 'application/json' }
      })
    print('test_fetch_put\n', await r.text())
  } catch (e) {
    print(e)
  }
}
test_fetch_put()
</code></pre>
<p>To run those examples, use the following WasmEdge CLI command.</p>
<pre><code class="language-bash">cd example_js
wasmedge --dir .:. ../target/wasm32-wasi/release/wasmedge_quickjs.wasm wasi_http_fetch.js
</code></pre>
<p>You can see the HTTP responses printed to the console.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tensorflow-1"><a class="header" href="#tensorflow-1">TensorFlow</a></h1>
<p>The interpreter supports the WasmEdge TensorFlow lite inference extension so that your JavaScript can run an ImageNet model for image classification. This article will show you how to use the TensorFlow Rust SDK for WasmEdge from your javascript program.</p>
<p>Here is an example of JavaScript. You could find the full code from <a href="https://github.com/second-state/wasmedge-quickjs/tree/main/example_js/tensorflow_lite_demo">example_js/tensorflow_lite_demo/</a>.</p>
<pre><code class="language-javascript">import {Image} from 'image';
import * as std from 'std';
import {TensorflowLiteSession} from 'tensorflow_lite';

let img = new Image('food.jpg');
let img_rgb = img.to_rgb().resize(192, 192);
let rgb_pix = img_rgb.pixels();

let session = new TensorflowLiteSession(
    'lite-model_aiy_vision_classifier_food_V1_1.tflite');
session.add_input('input', rgb_pix);
session.run();
let output = session.get_output('MobilenetV1/Predictions/Softmax');
let output_view = new Uint8Array(output);
let max = 0;
let max_idx = 0;
for (var i in output_view) {
  let v = output_view[i];
  if (v &gt; max) {
    max = v;
    max_idx = i;
  }
}
let label_file = std.open('aiy_food_V1_labelmap.txt', 'r');
let label = '';
for (var i = 0; i &lt;= max_idx; i++) {
  label = label_file.getline();
}
label_file.close();

print('label:');
print(label);
print('confidence:');
print(max / 255);
</code></pre>
<p>To run the JavaScript in the WasmEdge runtime, you can do the following on the CLI to re-build the QuickJS engine with TensorFlow and then run the JavaScript program with TensorFlow API.</p>
<pre><code class="language-bash">$ cargo build --target wasm32-wasi --release --features=tensorflow
... ...
$ cd example_js/tensorflow_lite_demo
$ wasmedge-tensorflow-lite --dir .:. ../../target/wasm32-wasi/release/wasmedge_quickjs.wasm main.js
label:
Hot dog
confidence:
0.8941176470588236
</code></pre>
<blockquote>
<p>Note: the <code>--dir .:.</code> on the command line is to give wasmedge permission to read the local directory in the file system for the <code>main.js</code> file.</p>
</blockquote>
<h2 id="note"><a class="header" href="#note">Note</a></h2>
<ul>
<li>The <code>--features=tensorflow</code> compiler flag builds a version of the QuickJS engine with WasmEdge TensorFlow extensions.</li>
<li>The <code>wasmedge-tensorflow-lite</code> program is part of the WasmEdge package. It is the WasmEdge runtime with the Tensorflow extension built in.</li>
</ul>
<p>You should now see the name of the food item recognized by the TensorFlow lite ImageNet model.</p>
<h2 id="make-it-faster-1"><a class="header" href="#make-it-faster-1">Make it faster</a></h2>
<p>The above Tensorflow inference example takes 1–2 seconds to run. It is acceptable in web application scenarios but could be improved. Recall that WasmEdge is the fastest WebAssembly runtime today due to its AOT (Ahead-of-time compiler) optimization. WasmEdge provides a <code>wasmedgec</code> utility to compile and add a native machine code section to the <code>wasm</code> file for much faster performance.</p>
<p>The following example uses the extended versions to <code>wasmedge</code> and <code>wasmedgec</code> to support the WasmEdge Tensorflow extension.</p>
<pre><code class="language-bash">$ cd example_js/tensorflow_lite_demo
$ wasmedgec-tensorflow ../../target/wasm32-wasi/release/wasmedge_quickjs.wasm wasmedge_quickjs.wasm
$ wasmedge-tensorflow-lite --dir .:. wasmedge_quickjs.wasm main.js
label:
Hot dog
confidence:
0.8941176470588236
</code></pre>
<p>You can see that the image classification task can be completed within 0.1s. It is at least 10x improvement!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="react-ssr"><a class="header" href="#react-ssr">React SSR</a></h1>
<p><a href="https://reactjs.org/">React</a> is very popular JavaScript web UI framework. A React application is &quot;compiled&quot; into an HTML and JavaScript static web site. The web UI is rendered through the generated JavaScript code. However, it is often too slow and resource consuming to execute the complex generated JavaScript entirely in the browser to build the interactive HTML DOM objects. <a href="https://medium.com/jspoint/a-beginners-guide-to-react-server-side-rendering-ssr-bf3853841d55">React Server Side Rendering (SSR)</a> delegates the JavaScript UI rendering to a server, and have the server stream rendered HTML DOM objects to the browser. The WasmEdge JavaScript runtime provides a lightweight and high performance container to run React SSR functions on edge servers.</p>
<blockquote>
<p>Server-side rendering (SSR) is a popular technique for rendering a client-side single page application (SPA) on the server and then sending a fully rendered page to the client. This allows for dynamic components to be served as static HTML markup. This approach can be useful for search engine optimization (SEO) when indexing does not handle JavaScript properly. It may also be beneficial in situations where downloading a large JavaScript bundle is impaired by a slow network. -- <a href="https://www.digitalocean.com/community/tutorials/react-server-side-rendering">from Digital Ocean</a>.</p>
</blockquote>
<p>In this article, we will show you how to use the WasmEdge QuickJS runtime to implement a React SSR function.
Compared with the Docker + Linux + nodejs + v8 approach, WasmEdge is much lighter (1% of the footprint) and safer, provides better resource isolation and management, and has similar non-JIT (<a href="https://www.zdnet.com/article/edge-super-duper-secure-mode-turns-off-the-javascript-jit-compiler-for-extra-security/">safe</a>) performance.</p>
<p>We will start from a complete tutorial to create and deploy a simple React SSR web application from the standard template. Then, we will discuss two modes of SSR: static and streaming rendering. Static rendering is easy to understand and implement. Streaming rendering, on the other hand, provides better user experience since the user can see partial results while waiting in front of the browser. We will walk through the key code snippets for both static and streaming rendering.</p>
<ul>
<li><a href="dev/js/ssr.html#getting-started">Getting started</a></li>
<li><a href="dev/js/ssr.html#static-rendering">Static rendering code example</a> [<a href="https://github.com/second-state/wasmedge-quickjs/blob/main/.github/workflows/examples.yml#L86-L93">GitHub Action</a> | <a href="https://github.com/second-state/wasmedge-quickjs/runs/5543260023?check_suite_focus=true#step:13:1">Log</a>]</li>
<li><a href="dev/js/ssr.html#streaming-rendering">Streaming rendering code example</a> [<a href="https://github.com/second-state/wasmedge-quickjs/blob/main/.github/workflows/examples.yml#L95-L105">GitHub Action</a> | <a href="https://github.com/second-state/wasmedge-quickjs/runs/5543260023?check_suite_focus=true#step:14:1">Log</a>]</li>
<li><a href="dev/js/ssr.html#react-18-ssr">A complete React 18 example</a> [<a href="https://github.com/second-state/wasmedge-quickjs/blob/main/.github/workflows/examples.yml#L107-L117">GitHub Action</a> | <a href="https://github.com/second-state/wasmedge-quickjs/runs/5543260023?check_suite_focus=true#step:15:1">Log</a>]</li>
</ul>
<h2 id="getting-started-1"><a class="header" href="#getting-started-1">Getting started</a></h2>
<h3 id="step-1--create-the-react-app"><a class="header" href="#step-1--create-the-react-app">Step 1 — Create the React App</a></h3>
<p>First, use <code>npx</code> to create a new React app. Let’s name the app <code>react-ssr-example</code>.</p>
<pre><code class="language-bash">npx create-react-app react-ssr-example
</code></pre>
<p>Then, <code>cd</code> into the directory for the newly created app.</p>
<pre><code class="language-bash">cd react-ssr-example
</code></pre>
<p>Start the new app in order to verify the installation.</p>
<pre><code class="language-bash">npm start
</code></pre>
<p>You should see the example React app displayed in your browser window. At this stage, the app is rendered in the browser. The browser runs the generated React JavaScript to build the HTML DOM UI.</p>
<p>Now in order to prepare for SSR, you will need to make some changes to the app's <code>index.js</code> file. Change ReactDOM's <code>render</code> method to <code>hydrate</code> to indicate to the DOM renderer that you intend to rehydrate the app after it is rendered on the server.
Replace the contents of the <code>index.js</code> file with the following.</p>
<pre><code class="language-javascript">import React from 'react';
import ReactDOM from 'react-dom';
import App from './App';
ReactDOM.hydrate(
  &lt;React.StrictMode&gt;
    &lt;App /&gt;
  &lt;/React.StrictMode&gt;,
  document.getElementById('root')
);
</code></pre>
<p>Note: you should import <code>React</code> redundantly in the <code>src/App.js</code>, so the server will recognize it.</p>
<pre><code class="language-js">import React from 'react';
//...
</code></pre>
<p>That concludes setting up the application, you can move on to setting up the server-side rendering functions.</p>
<h3 id="step-2--create-an-wasmedge-quickjs-server-and-render-the-app-component"><a class="header" href="#step-2--create-an-wasmedge-quickjs-server-and-render-the-app-component">Step 2 — Create an WasmEdge QuickJS Server and Render the App Component</a></h3>
<p>Now that you have the app in place, let’s set up a server that will render the HTML DOM by running the React JavaScript and then send the rendered elements to the browser. We will use WasmEdge as a secure, high-performance and lightweight container to run React JavaScript.</p>
<p>Create a new <code>server</code> directory in the project's root directory.</p>
<pre><code class="language-bash">mkdir server
</code></pre>
<p>Then, inside the <code>server</code> directory, create a new <code>index.js</code> file with the server code.</p>
<pre><code class="language-javascript">import * as React from 'react';
import ReactDOMServer from 'react-dom/server';
import * as std from 'std';
import * as http from 'wasi_http';
import * as net from 'wasi_net';

import App from '../src/App.js';

async function handle_client(cs) {
  print('open:', cs.peer());
  let buffer = new http.Buffer();

  while (true) {
    try {
      let d = await cs.read();
      if (d == undefined || d.byteLength &lt;= 0) {
        return;
      }
      buffer.append(d);
      let req = buffer.parseRequest();
      if (req instanceof http.WasiRequest) {
        handle_req(cs, req);
        break;
      }
    } catch (e) {
      print(e);
    }
  }
  print('end:', cs.peer());
}

function enlargeArray(oldArr, newLength) {
  let newArr = new Uint8Array(newLength);
  oldArr &amp;&amp; newArr.set(oldArr, 0);
  return newArr;
}

async function handle_req(s, req) {
  print('uri:', req.uri)

  let resp = new http.WasiResponse();
  let content = '';
  if (req.uri == '/') {
    const app = ReactDOMServer.renderToString(&lt;App /&gt;);
    content = std.loadFile('./build/index.html');
    content = content.replace('&lt;div id=&quot;root&quot;&gt;&lt;/div&gt;', `&lt;div id=&quot;root&quot;&gt;${app}&lt;/div&gt;`);
  } else {
    let chunk = 1000; // Chunk size of each reading
    let length = 0; // The whole length of the file
    let byteArray = null; // File content as Uint8Array
    
    // Read file into byteArray by chunk
    let file = std.open('./build' + req.uri, 'r');
    while (true) {
      byteArray = enlargeArray(byteArray, length + chunk);
      let readLen = file.read(byteArray.buffer, length, chunk);
      length += readLen;
      if (readLen &lt; chunk) {
        break;
      }
    }
    content = byteArray.slice(0, length).buffer;
    file.close();
  }
  let contentType = 'text/html; charset=utf-8';
  if (req.uri.endsWith('.css')) {
    contentType = 'text/css; charset=utf-8';
  } else if (req.uri.endsWith('.js')) {
    contentType = 'text/javascript; charset=utf-8';
  } else if (req.uri.endsWith('.json')) {
    contentType = 'text/json; charset=utf-8';
  } else if (req.uri.endsWith('.ico')) {
    contentType = 'image/vnd.microsoft.icon';
  } else if (req.uri.endsWith('.png')) {
    contentType = 'image/png';
  }
  resp.headers = {
    'Content-Type': contentType
  };

  let r = resp.encode(content);
  s.write(r);
}

async function server_start() {
  print('listen 8002...');
  try {
    let s = new net.WasiTcpServer(8002);
    for (var i = 0; ; i++) {
      let cs = await s.accept();
      handle_client(cs);
    }
  } catch (e) {
    print(e);
  }
}

server_start();
</code></pre>
<p>The server renders the <code>&lt;App&gt;</code> component, and then sends the rendered HTML string back to the browser. Three important things are taking place here.</p>
<ul>
<li>ReactDOMServer's <code>renderToString</code> is used to render the <code>&lt;App/&gt;</code> to an HTML string.</li>
<li>The <code>index.html</code> file from the app's <code>build</code> output directory is loaded as a template. The app's content is injected into the <code>&lt;div&gt;</code> element with an id of <code>&quot;root&quot;</code>. It is then sent back as HTTP response.</li>
<li>Other files from the <code>build</code> directory are read and served as needed at the requests of the browser.</li>
</ul>
<h3 id="step-3--build-and-deploy"><a class="header" href="#step-3--build-and-deploy">Step 3 — Build and deploy</a></h3>
<p>For the server code to work, you will need to bundle and transpile it. In this section, we will show you how to use webpack and Babel. In this next section, we will demonstrate an alternative (and potentially easier) approach using rollup.js.</p>
<p>Create a new Babel configuration file named <code>.babelrc.json</code> in the project's root directory and add the <code>env</code> and <code>react-app</code> presets.</p>
<pre><code class="language-json">{
  &quot;presets&quot;: [
    &quot;@babel/preset-env&quot;,
    &quot;@babel/preset-react&quot;
  ]
}
</code></pre>
<p>Create a webpack config for the server that uses Babel Loader to transpile the code. Start by creating the <code>webpack.server.js</code> file in the project's root directory.</p>
<pre><code class="language-js">const path = require('path');
module.exports = {
  entry: './server/index.js',
  externals: [
    {&quot;wasi_http&quot;: &quot;wasi_http&quot;},
    {&quot;wasi_net&quot;: &quot;wasi_net&quot;},
    {&quot;std&quot;: &quot;std&quot;}
  ],
  output: {
    path: path.resolve('server-build'),
    filename: 'index.js',
    chunkFormat: &quot;module&quot;,
    library: {
      type: &quot;module&quot;
    },
  },
  experiments: {
    outputModule: true
  },
  module: {
    rules: [
      {
        test: /\.js$/,
        use: 'babel-loader'
      },
      {
        test: /\.css$/,
        use: [&quot;css-loader&quot;]
      },
      {
        test: /\.svg$/,
        use: [&quot;svg-url-loader&quot;]
      }
    ]
  }
};
</code></pre>
<p>With this configuration, the transpiled server bundle will be output to the <code>server-build</code> folder in a file called <code>index.js</code>.</p>
<p>Next, add the <code>svg-url-loader</code> package by entering the following commands in your terminal.</p>
<pre><code class="language-bash">npm install svg-url-loader --save-dev
</code></pre>
<p>This completes the dependency installation and webpack and Babel configuration.</p>
<p>Now, revisit <code>package.json</code> and add helper npm scripts. Add <code>dev:build-server</code>, <code>dev:start-server</code> scripts to the <code>package.json</code> file to build and serve the SSR application.</p>
<pre><code class="language-json">&quot;scripts&quot;: {
  &quot;dev:build-server&quot;: &quot;NODE_ENV=development webpack --config webpack.server.js --mode=development&quot;,
  &quot;dev:start-server&quot;: &quot;wasmedge --dir .:. wasmedge_quickjs.wasm ./server-build/index.js&quot;,
  // ...
},
</code></pre>
<ul>
<li>The <code>dev:build-server</code> script sets the environment to <code>&quot;development&quot;</code> and invokes webpack with the configuration file you created earlier.</li>
<li>The <code>dev:start-server</code> script runs the WasmEdge server from the <code>wasmedge</code> CLI tool to serve the built output. The <code>wasmedge_quickjs.wasm</code> program contains the QuickJS runtime. <a href="dev/js/quickstart.html">Learn more</a></li>
</ul>
<p>Now you can run the following commands to build the client-side app, bundle and transpile the server code, and start up the server on <code>:8002</code>.</p>
<pre><code class="language-bash">npm run build
npm run dev:build-server
npm run dev:start-server
</code></pre>
<p>Open <code>http://localhost:8002/</code> in your web browser and observe your server-side rendered app.</p>
<p>Previously, the HTML source in the browser is simply the template with SSR placeholders.</p>
<pre><code class="language-html">Output
&lt;div id=&quot;root&quot;&gt;&lt;/div&gt;
</code></pre>
<p>Now, with the SSR function running on the server, the HTML source in the browser is as follows.</p>
<pre><code class="language-html">Output
&lt;div id=&quot;root&quot;&gt;&lt;div class=&quot;App&quot; data-reactroot=&quot;&quot;&gt;...&lt;/div&gt;&lt;/div&gt;
</code></pre>
<h3 id="step-4-alternative----build-and-deploy-with-rollupjs"><a class="header" href="#step-4-alternative----build-and-deploy-with-rollupjs">Step 4 (alternative) -- build and deploy with rollup.js</a></h3>
<p>Alternatively, you could use the <a href="https://rollupjs.org/guide/en/">rollup.js</a> tool to <a href="dev/js/npm.html">package all application components and library modules</a> into a single file for WasmEdge to execute.</p>
<p>Create a rollup config for the server that uses Babel Loader to transpile the code. Start by creating the <code>rollup.config.js</code> file in the project's root directory.</p>
<pre><code class="language-js">const {babel} = require('@rollup/plugin-babel');
const nodeResolve = require('@rollup/plugin-node-resolve');
const commonjs = require('@rollup/plugin-commonjs');
const replace = require('@rollup/plugin-replace');

const globals = require('rollup-plugin-node-globals');
const builtins = require('rollup-plugin-node-builtins');
const plugin_async = require('rollup-plugin-async');
const css = require(&quot;rollup-plugin-import-css&quot;);
const svg = require('rollup-plugin-svg');

const babelOptions = {
  babelrc: false,
  presets: [
    '@babel/preset-react'
  ],
  babelHelpers: 'bundled'
};

module.exports = [
  {
    input: './server/index.js',
    output: {
      file: 'server-build/index.js',
      format: 'esm',
    },
    external: [ 'std', 'wasi_net','wasi_http'],
    plugins: [
      plugin_async(),
      babel(babelOptions),
      nodeResolve({preferBuiltins: true}),
      commonjs({ignoreDynamicRequires: false}),
      css(),
      svg({base64: true}),
      globals(),
      builtins(),
      replace({
        preventAssignment: true,  
        'process.env.NODE_ENV': JSON.stringify('production'),
        'process.env.NODE_DEBUG': JSON.stringify(''),
      }),
    ],
  },
];
</code></pre>
<p>With this configuration, the transpiled server bundle will be output to the <code>server-build</code> folder in a file called <code>index.js</code>.</p>
<p>Next, add the dependent packages to the <code>package.json</code> then install with <code>npm</code>.</p>
<pre><code class="language-json">  &quot;devDependencies&quot;: {
    //...
    &quot;@rollup/plugin-babel&quot;: &quot;^5.3.0&quot;,
    &quot;@rollup/plugin-commonjs&quot;: &quot;^21.0.1&quot;,
    &quot;@rollup/plugin-node-resolve&quot;: &quot;^7.1.3&quot;,
    &quot;@rollup/plugin-replace&quot;: &quot;^3.0.0&quot;,
    &quot;rollup&quot;: &quot;^2.60.1&quot;,
    &quot;rollup-plugin-async&quot;: &quot;^1.2.0&quot;,
    &quot;rollup-plugin-import-css&quot;: &quot;^3.0.3&quot;,
    &quot;rollup-plugin-node-builtins&quot;: &quot;^2.1.2&quot;,
    &quot;rollup-plugin-node-globals&quot;: &quot;^1.4.0&quot;,
    &quot;rollup-plugin-svg&quot;: &quot;^2.0.0&quot;
  }
</code></pre>
<pre><code class="language-bash">npm install
</code></pre>
<p>This completes the dependency installation and rollup configuration.</p>
<p>Now, revisit <code>package.json</code> and add helper npm scripts. Add <code>dev:build-server</code>, <code>dev:start-server</code> scripts to the <code>package.json</code> file to build and serve the SSR application.</p>
<pre><code class="language-json">&quot;scripts&quot;: {
  &quot;dev:build-server&quot;: &quot;rollup -c rollup.config.js&quot;,
  &quot;dev:start-server&quot;: &quot;wasmedge --dir .:. wasmedge_quickjs.wasm ./server-build/index.js&quot;,
  // ...
},
</code></pre>
<ul>
<li>The <code>dev:build-server</code> script sets the environment to <code>&quot;development&quot;</code> and invokes webpack with the configuration file you created earlier.</li>
<li>The <code>dev:start-server</code> script runs the WasmEdge server from the <code>wasmedge</code> CLI tool to serve the built output. The <code>wasmedge_quickjs.wasm</code> program contains the QuickJS runtime. <a href="dev/js/quickstart.html">Learn more</a></li>
</ul>
<p>Now you can run the following commands to build the client-side app, bundle and transpile the server code, and start up the server on <code>:8002</code>.</p>
<pre><code class="language-bash">npm run build
npm run dev:build-server
npm run dev:start-server
</code></pre>
<p>Open <code>http://localhost:8002/</code> in your web browser and observe your server-side rendered app.</p>
<p>Previously, the HTML source in the browser is simply the template with SSR placeholders.</p>
<pre><code class="language-html">Output
&lt;div id=&quot;root&quot;&gt;&lt;/div&gt;
</code></pre>
<p>Now, with the SSR function running on the server, the HTML source in the browser is as follows.</p>
<pre><code class="language-html">Output
&lt;div id=&quot;root&quot;&gt;&lt;div class=&quot;App&quot; data-reactroot=&quot;&quot;&gt;...&lt;/div&gt;&lt;/div&gt;
</code></pre>
<p>In the next two sections, we will dive deeper into the source code for two ready-made sample applications for static and streaming rendering of SSR.</p>
<h2 id="static-rendering"><a class="header" href="#static-rendering">Static rendering</a></h2>
<p>The <a href="https://github.com/second-state/wasmedge-quickjs/tree/main/example_js/react_ssr">example_js/react_ssr</a> folder in the GitHub repo contains the example's source code. It showcases how to compose HTML templates and render them into an HTML string in a JavaScript app running in WasmEdge.</p>
<p>The <a href="https://github.com/second-state/wasmedge-quickjs/blob/main/example_js/react_ssr/component/Home.jsx">component/Home.jsx</a> file is the main page template in React.</p>
<pre><code class="language-javascript">import React from 'react';
import Page from './Page.jsx';
class Home extends React.Component {
  render() {
    const { dataList = [] } = this.props;
    return (
      &lt;div&gt;
        &lt;div&gt;This is home&lt;/div&gt;
        &lt;Page&gt;&lt;/Page&gt;
      &lt;/div&gt;
    );
  }
};

export default Home;
</code></pre>
<p>The <code>Home.jpx</code> template includes a <a href="https://github.com/second-state/wasmedge-quickjs/blob/main/example_js/react_ssr/component/Page.jsx">Page.jpx</a> template for part of the page.</p>
<pre><code class="language-javascript">import React from 'react';

class Page extends React.Component {
  render() {
    const { dataList = [] } = this.props;
    return (
      &lt;div&gt;
        &lt;div&gt;This is page&lt;/div&gt;
      &lt;/div&gt;
    );
  }
};

export default Page;
</code></pre>
<p>The <a href="https://github.com/second-state/wasmedge-quickjs/blob/main/example_js/react_ssr/main.js">main.js</a> file calls React to render the templates into HTML.</p>
<pre><code class="language-javascript">import React from 'react';
import {renderToString} from 'react-dom/server';

import Home from './component/Home.jsx';

const content = renderToString(React.createElement(Home));
console.log(content);
</code></pre>
<p>The <a href="https://github.com/second-state/wasmedge-quickjs/blob/main/example_js/react_ssr/rollup.config.js">rollup.config.js</a> and <a href="https://github.com/second-state/wasmedge-quickjs/blob/main/example_js/react_ssr/package.json">package.json</a> files are to build the React SSR dependencies and components into a bundled JavaScript file for WasmEdge. You should use the <code>npm</code> command to build it.
The output is in the <code>dist/main.js</code> file.</p>
<pre><code class="language-bash">npm install
npm run build
</code></pre>
<p>To run the example, do the following on the CLI. You can see that the templates are successfully composed into an HTML string.</p>
<pre><code class="language-bash">$ cd example_js/react_ssr
$ wasmedge --dir .:. ../../target/wasm32-wasi/release/wasmedge_quickjs.wasm dist/main.js
&lt;div data-reactroot=&quot;&quot;&gt;&lt;div&gt;This is home&lt;/div&gt;&lt;div&gt;&lt;div&gt;This is page&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;
</code></pre>
<blockquote>
<p>Note: the <code>--dir .:.</code> on the command line is to give wasmedge permission to read the local directory in the file system for the <code>dist/main.js</code> file.</p>
</blockquote>
<h2 id="streaming-rendering"><a class="header" href="#streaming-rendering">Streaming rendering</a></h2>
<p>The <a href="https://github.com/second-state/wasmedge-quickjs/tree/main/example_js/react_ssr_stream">example_js/react_ssr_stream</a> folder in the GitHub repo contains the example's source code. It showcases how to streaming render an HTML string from templates in a JavaScript app running in WasmEdge.</p>
<p>The <a href="https://github.com/second-state/wasmedge-quickjs/blob/main/example_js/react_ssr_stream/component/LazyHome.jsx">component/LazyHome.jsx</a> file is the main page template in React. It &quot;lazy&quot; loads the inner page template after a 2s delay once the outer HTML is rendered and returned to the user.</p>
<pre><code class="language-javascript">import React, { Suspense } from 'react';
import * as LazyPage from './LazyPage.jsx';

async function sleep(ms) {
  return new Promise((r, _) =&gt; {
    setTimeout(() =&gt; r(), ms)
  });
}

async function loadLazyPage() {
  await sleep(2000);
  return LazyPage
}

class LazyHome extends React.Component {
  render() {
    let LazyPage1 = React.lazy(() =&gt; loadLazyPage());
    return (
      &lt;html lang=&quot;en&quot;&gt;
        &lt;head&gt;
          &lt;meta charSet=&quot;utf-8&quot; /&gt;
          &lt;title&gt;Title&lt;/title&gt;
        &lt;/head&gt;
        &lt;body&gt;
          &lt;div&gt;
            &lt;div&gt; This is LazyHome &lt;/div&gt;
            &lt;Suspense fallback={&lt;div&gt; loading... &lt;/div&gt;}&gt;
              &lt;LazyPage1 /&gt;
            &lt;/Suspense&gt;
          &lt;/div&gt;
        &lt;/body&gt;
      &lt;/html&gt;
    );
  }
}

export default LazyHome;
</code></pre>
<p>The <a href="https://github.com/second-state/wasmedge-quickjs/blob/main/example_js/react_ssr_stream/component/LazyPage.jsx">LazyPage.jsx</a> is the inner page template. It is rendered 2s after the outer page is already returned to the user.</p>
<pre><code class="language-javascript">import React from 'react';

class LazyPage extends React.Component {
  render() {
    return (
      &lt;div&gt;
        &lt;div&gt;
          This is lazy page
        &lt;/div&gt;
      &lt;/div&gt;
    );
  }
}

export default LazyPage;
</code></pre>
<p>The <a href="https://github.com/second-state/wasmedge-quickjs/blob/main/example_js/react_ssr_stream/main.mjs">main.mjs</a>
file starts a non-blocking HTTP server, and then renders the HTML page in multiple chuncks to the response. When a HTTP request comes in, the <code>handle_client()</code> function is called to render the HTML and to send back the results through the stream.</p>
<pre><code class="language-javascript">import * as React from 'react';
import { renderToPipeableStream } from 'react-dom/server';
import * as http from 'wasi_http';
import * as net from 'wasi_net';

import LazyHome from './component/LazyHome.jsx';

async function handle_client(s) {
  let resp = new http.WasiResponse();
  resp.headers = {
    &quot;Content-Type&quot;: &quot;text/html; charset=utf-8&quot;
  }
  renderToPipeableStream(&lt;LazyHome /&gt;).pipe(resp.chunk(s));
}

async function server_start() {
  print('listen 8001...');
  let s = new net.WasiTcpServer(8001);
  for (var i = 0; i &lt; 100; i++) {
    let cs = await s.accept();
    handle_client(cs);
  }
}

server_start();
</code></pre>
<p>The <a href="https://github.com/second-state/wasmedge-quickjs/blob/main/example_js/react_ssr_stream/rollup.config.js">rollup.config.js</a> and <a href="https://github.com/second-state/wasmedge-quickjs/blob/main/example_js/react_ssr_stream/package.json">package.json</a> files are to build the React SSR dependencies and components into a bundled JavaScript file for WasmEdge. You should use the <code>npm</code> command to build it.
The output is in the <code>dist/main.mjs</code> file.</p>
<pre><code class="language-bash">npm install
npm run build
</code></pre>
<p>To run the example, do the following on the CLI to start the server.</p>
<pre><code class="language-bash">cd example_js/react_ssr_stream
nohup wasmedge --dir .:. ../../target/wasm32-wasi/release/wasmedge_quickjs.wasm dist/main.mjs &amp;
</code></pre>
<p>Send the server a HTTP request via <code>curl</code> or the browser.</p>
<pre><code class="language-bash">curl http://localhost:8001
</code></pre>
<p>The results are as follows. The service first returns an HTML page with an empty inner section (i.e., the <code>loading</code> section), and then 2s later, the HTML content for the inner section and the JavaScript to display it.</p>
<pre><code class="language-bash">  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current
                                 Dload  Upload   Total   Spent    Left  Speed

  0     0    0     0    0     0      0      0 --:--:-- --:--:-- --:--:--     0
100   211    0   211    0     0   1029      0 --:--:-- --:--:-- --:--:--  1024
100   275    0   275    0     0    221      0 --:--:--  0:00:01 --:--:--   220
100   547    0   547    0     0    245      0 --:--:--  0:00:02 --:--:--   245
100  1020    0  1020    0     0    413      0 --:--:--  0:00:02 --:--:--   413

&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;&lt;meta charSet=&quot;utf-8&quot;/&gt;&lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div&gt;&lt;div&gt; This is LazyHome &lt;/div&gt;&lt;!--$?--&gt;&lt;template id=&quot;B:0&quot;&gt;&lt;/template&gt;&lt;div&gt; loading... &lt;/div&gt;&lt;!--/$--&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;&lt;div hidden id=&quot;S:0&quot;&gt;&lt;template id=&quot;P:1&quot;&gt;&lt;/template&gt;&lt;/div&gt;&lt;div hidden id=&quot;S:1&quot;&gt;&lt;div&gt;&lt;div&gt;This is lazy page&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;script&gt;function $RS(a,b){a=document.getElementById(a);b=document.getElementById(b);for(a.parentNode.removeChild(a);a.firstChild;)b.parentNode.insertBefore(a.firstChild,b);b.parentNode.removeChild(b)};$RS(&quot;S:1&quot;,&quot;P:1&quot;)&lt;/script&gt;&lt;script&gt;function $RC(a,b){a=document.getElementById(a);b=document.getElementById(b);b.parentNode.removeChild(b);if(a){a=a.previousSibling;var f=a.parentNode,c=a.nextSibling,e=0;do{if(c&amp;&amp;8===c.nodeType){var d=c.data;if(&quot;/$&quot;===d)if(0===e)break;else e--;else&quot;$&quot;!==d&amp;&amp;&quot;$?&quot;!==d&amp;&amp;&quot;$!&quot;!==d||e++}d=c.nextSibling;f.removeChild(c);c=d}while(c);for(;b.firstChild;)f.insertBefore(b.firstChild,c);a.data=&quot;$&quot;;a._reactRetry&amp;&amp;a._reactRetry()}};$RC(&quot;B:0&quot;,&quot;S:0&quot;)&lt;/script&gt;
</code></pre>
<h2 id="react-18-ssr"><a class="header" href="#react-18-ssr">React 18 SSR</a></h2>
<p>In this section, we will demonstrate a complete React 18 SSR application. It renders the web UI through streaming SSR. The <a href="https://github.com/second-state/wasmedge-quickjs/tree/main/example_js/react18_ssr">example_js/react18_ssr</a> folder in the GitHub repo contains the example's source code. The <a href="https://github.com/second-state/wasmedge-quickjs/tree/main/example_js/react18_ssr/component">component</a> folder contains the entire React 18 application's source code, and the <a href="https://github.com/second-state/wasmedge-quickjs/tree/main/example_js/react18_ssr/public">public</a> folder contains the public resources (CSS and images) for the web application.</p>
<p>The <a href="https://github.com/second-state/wasmedge-quickjs/blob/main/example_js/react18_ssr/main.mjs">main.mjs</a>
file starts a non-blocking HTTP server, maps the <code>main.css</code> and <code>main.js</code> files in the <code>public</code> folder to web URLs, and then renders the HTML page for each request in <code>renderToPipeableStream()</code>.</p>
<pre><code class="language-javascript">import * as React from 'react';
import { renderToPipeableStream } from 'react-dom/server';
import * as http from 'wasi_http';
import * as net from 'wasi_net';
import * as std from 'std';

import App from './component/App.js';
import { DataProvider } from './component/data.js'

let assets = {
  'main.js': '/main.js',
  'main.css': '/main.css',
};

const css = std.loadFile('./public/main.css')

function createServerData() {
  let done = false;
  let promise = null;
  return {
    read() {
      if (done) {
        return;
      }
      if (promise) {
        throw promise;
      }
      promise = new Promise(resolve =&gt; {
        setTimeout(() =&gt; {
          done = true;
          promise = null;
          resolve();
        }, 2000);
      });
      throw promise;
    },
  };
}

async function handle_client(cs) {
  print('open:', cs.peer());
  let buffer = new http.Buffer();

  while (true) {
    try {
      let d = await cs.read();
      if (d == undefined || d.byteLength &lt;= 0) {
        return;
      }
      buffer.append(d);
      let req = buffer.parseRequest();
      if (req instanceof http.WasiRequest) {
        handle_req(cs, req);
        break;
      }
    } catch (e) {
      print(e);
    }
  }
  print('end:', cs.peer());
}

async function handle_req(s, req) {
  print('uri:', req.uri)
  let resp = new http.WasiResponse();
  if (req.uri == '/main.css') {
    resp.headers = {
      &quot;Content-Type&quot;: &quot;text/css; charset=utf-8&quot;
    }
    let r = resp.encode(css);
    s.write(r);
  } else {
    resp.headers = {
      &quot;Content-Type&quot;: &quot;text/html; charset=utf-8&quot;
    }
    let data = createServerData()
    renderToPipeableStream(
      &lt;DataProvider data={data}&gt;
        &lt;App assets={assets} /&gt;
      &lt;/DataProvider&gt;
    ).pipe(resp.chunk(s));
  }
}

async function server_start() {
  print('listen 8002...');
  try {
    let s = new net.WasiTcpServer(8002);
    for (var i = 0; ; i++) {
      let cs = await s.accept();
      handle_client(cs);
    }
  } catch (e) {
    print(e)
  }
}

server_start();
</code></pre>
<p>The <a href="https://github.com/second-state/wasmedge-quickjs/blob/main/example_js/react18_ssr/rollup.config.js">rollup.config.js</a> and <a href="https://github.com/second-state/wasmedge-quickjs/blob/main/example_js/react18_ssr/package.json">package.json</a> files are to build the React 18 SSR dependencies and components into a bundled JavaScript file for WasmEdge. You should use the <code>npm</code> command to build it.
The output is in the <code>dist/main.mjs</code> file.</p>
<pre><code class="language-bash">npm install
npm run build
</code></pre>
<p>To run the example, do the following on the CLI to start the server.</p>
<pre><code class="language-bash">cd example_js/react_ssr_stream
nohup wasmedge --dir .:. ../../target/wasm32-wasi/release/wasmedge_quickjs.wasm dist/main.mjs &amp;
</code></pre>
<p>Send the server a HTTP request via <code>curl</code> or the browser.</p>
<pre><code class="language-bash">curl http://localhost:8002
</code></pre>
<p>The results are as follows. The service first returns an HTML page with an empty inner section (i.e., the <code>loading</code> section), and then 2s later, the HTML content for the inner section and the JavaScript to display it.</p>
<pre><code class="language-bash">  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current
                                 Dload  Upload   Total   Spent    Left  Speed

  0     0    0     0    0     0      0      0 --:--:-- --:--:-- --:--:--     0
100   439    0   439    0     0   1202      0 --:--:-- --:--:-- --:--:--  1199
100  2556    0  2556    0     0   1150      0 --:--:--  0:00:02 --:--:--  1150
100  2556    0  2556    0     0    926      0 --:--:--  0:00:02 --:--:--   926
100  2806    0  2806    0     0    984      0 --:--:--  0:00:02 --:--:--   984
&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;&lt;meta charSet=&quot;utf-8&quot;/&gt;&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;/&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;/main.css&quot;/&gt;&lt;title&gt;Hello&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;noscript&gt;&lt;b&gt;Enable JavaScript to run this app.&lt;/b&gt;&lt;/noscript&gt;&lt;!--$--&gt;&lt;main&gt;&lt;nav&gt;&lt;a href=&quot;/&quot;&gt;Home&lt;/a&gt;&lt;/nav&gt;&lt;aside class=&quot;sidebar&quot;&gt;&lt;!--$?--&gt;&lt;template id=&quot;B:0&quot;&gt;&lt;/template&gt;&lt;div class=&quot;spinner spinner--active&quot; role=&quot;progressbar&quot; aria-busy=&quot;true&quot;&gt;&lt;/div&gt;&lt;!--/$--&gt;&lt;/aside&gt;&lt;article class=&quot;post&quot;&gt;&lt;!--$?--&gt;&lt;template id=&quot;B:1&quot;&gt;&lt;/template&gt;&lt;div class=&quot;spinner spinner--active&quot; role=&quot;progressbar&quot; aria-busy=&quot;true&quot;&gt;&lt;/div&gt;&lt;!--/$--&gt;&lt;section class=&quot;comments&quot;&gt;&lt;h2&gt;Comments&lt;/h2&gt;&lt;!--$?--&gt;&lt;template id=&quot;B:2&quot;&gt;&lt;/template&gt;&lt;div class=&quot;spinner spinner--active&quot; role=&quot;progressbar&quot; aria-busy=&quot;true&quot;&gt;&lt;/div&gt;&lt;!--/$--&gt;&lt;/section&gt;&lt;h2&gt;Thanks for reading!&lt;/h2&gt;&lt;/article&gt;&lt;/main&gt;&lt;!--/$--&gt;&lt;script&gt;assetManifest = {&quot;main.js&quot;:&quot;/main.js&quot;,&quot;main.css&quot;:&quot;/main.css&quot;};&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;&lt;div hidden id=&quot;S:0&quot;&gt;&lt;template id=&quot;P:3&quot;&gt;&lt;/template&gt;&lt;/div&gt;&lt;div hidden id=&quot;S:1&quot;&gt;&lt;template id=&quot;P:4&quot;&gt;&lt;/template&gt;&lt;/div&gt;&lt;div hidden id=&quot;S:2&quot;&gt;&lt;template id=&quot;P:5&quot;&gt;&lt;/template&gt;&lt;/div&gt;&lt;div hidden id=&quot;S:3&quot;&gt;&lt;h1&gt;Archive&lt;/h1&gt;&lt;ul&gt;&lt;li&gt;May 2021&lt;/li&gt;&lt;li&gt;April 2021&lt;/li&gt;&lt;li&gt;March 2021&lt;/li&gt;&lt;li&gt;February 2021&lt;/li&gt;&lt;li&gt;January 2021&lt;/li&gt;&lt;li&gt;December 2020&lt;/li&gt;&lt;li&gt;November 2020&lt;/li&gt;&lt;li&gt;October 2020&lt;/li&gt;&lt;li&gt;September 2020&lt;/li&gt;&lt;/ul&gt;&lt;/div&gt;&lt;script&gt;function $RS(a,b){a=document.getElementById(a);b=document.getElementById(b);for(a.parentNode.removeChild(a);a.firstChild;)b.parentNode.insertBefore(a.firstChild,b);b.parentNode.removeChild(b)};$RS(&quot;S:3&quot;,&quot;P:3&quot;)&lt;/script&gt;&lt;script&gt;function $RC(a,b){a=document.getElementById(a);b=document.getElementById(b);b.parentNode.removeChild(b);if(a){a=a.previousSibling;var f=a.parentNode,c=a.nextSibling,e=0;do{if(c&amp;&amp;8===c.nodeType){var d=c.data;if(&quot;/$&quot;===d)if(0===e)break;else e--;else&quot;$&quot;!==d&amp;&amp;&quot;$?&quot;!==d&amp;&amp;&quot;$!&quot;!==d||e++}d=c.nextSibling;f.removeChild(c);c=d}while(c);for(;b.firstChild;)f.insertBefore(b.firstChild,c);a.data=&quot;$&quot;;a._reactRetry&amp;&amp;a._reactRetry()}};$RC(&quot;B:0&quot;,&quot;S:0&quot;)&lt;/script&gt;&lt;div hidden id=&quot;S:4&quot;&gt;&lt;h1&gt;Hello world&lt;/h1&gt;&lt;p&gt;This demo is &lt;!-- --&gt;&lt;b&gt;artificially slowed down&lt;/b&gt;. Open&lt;!-- --&gt; &lt;!-- --&gt;&lt;code&gt;server/delays.js&lt;/code&gt; to adjust how much different things are slowed down.&lt;!-- --&gt;&lt;/p&gt;&lt;p&gt;Notice how HTML for comments &amp;quot;streams in&amp;quot; before the JS (or React) has loaded on the page.&lt;/p&gt;&lt;p&gt;Also notice that the JS for comments and sidebar has been code-split, but HTML for it is still included in the server output.&lt;/p&gt;&lt;/div&gt;&lt;script&gt;$RS(&quot;S:4&quot;,&quot;P:4&quot;)&lt;/script&gt;&lt;script&gt;$RC(&quot;B:1&quot;,&quot;S:1&quot;)&lt;/script&gt;&lt;div hidden id=&quot;S:5&quot;&gt;&lt;p class=&quot;comment&quot;&gt;Wait, it doesn&amp;#x27;t wait for React to load?&lt;/p&gt;&lt;p class=&quot;comment&quot;&gt;How does this even work?&lt;/p&gt;&lt;p class=&quot;comment&quot;&gt;I like marshmallows&lt;/p&gt;&lt;/div&gt;&lt;script&gt;$RS(&quot;S:5&quot;,&quot;P:5&quot;)&lt;/script&gt;&lt;script&gt;$RC(&quot;B:2&quot;,&quot;S:2&quot;)&lt;/script&gt;
</code></pre>
<p>The streaming SSR examples make use of WasmEdge's unique asynchronous networking capabilities and ES6 module support (i.e., the rollup bundled JS file contains ES6 modules). You can learn more about <a href="dev/js/networking.html">async networking</a> and <a href="dev/js/es6.html">ES6</a> in this book.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="es6-module-support"><a class="header" href="#es6-module-support">ES6 module support</a></h1>
<p>The WasmEdge QuickJS runtime supports ES6 modules. In fact, the rollup commands we used in the <a href="dev/js/ssr.html">React SSR</a> examples convert and bundle CommonJS and NPM modules into ES6 modules so that they can be executed in WasmEdge QuickJS. This article will show you how to use ES6 module in WasmEdge.</p>
<p>We will take the example in <a href="https://github.com/second-state/wasmedge-quickjs/tree/main/example_js/es6_module_demo">example_js/es6_module_demo</a> folder as an example. The <a href="https://github.com/second-state/wasmedge-quickjs/blob/main/example_js/es6_module_demo/module_def.js">module_def.js</a> file defines and exports a simple JS function.</p>
<pre><code class="language-javascript">function hello(){
  console.log('hello from module_def.js');
}

export {hello};
</code></pre>
<p>The <a href="https://github.com/second-state/wasmedge-quickjs/blob/main/example_js/es6_module_demo/module_def_async.js">module_def_async.js</a> file defines and exports an aysnc function and a variable.</p>
<pre><code class="language-javascript">export async function hello() {
  console.log('hello from module_def_async.js');
  return 'module_def_async.js : return value';
}

export var something = 'async thing';
</code></pre>
<p>The <a href="https://github.com/second-state/wasmedge-quickjs/blob/main/example_js/es6_module_demo/demo.js">demo.js</a> file imports functions and variables from those modules and executes them.</p>
<pre><code class="language-javascript">import {hello as module_def_hello} from './module_def.js';

module_def_hello();

var f = async () =&gt; {
  let {hello, something} = await import('./module_def_async.js');
  await hello();
  console.log('./module_def_async.js `something` is ', something);
};

f();
</code></pre>
<p>To run the example, you can do the following on the CLI.</p>
<pre><code class="language-javascript">$ cd example_js/es6_module_demo
$ wasmedge --dir .:. ../../target/wasm32-wasi/release/wasmedge_quickjs.wasm demo.js
hello from module_def.js
hello from module_def_async.js
./module_def_async.js `something` is  async thing
</code></pre>
<blockquote>
<p>Note: the <code>--dir .:.</code> on the command line is to give wasmedge permission to read the local directory in the file system for the <code>demo.js</code> file.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="nodejs-and-npm-module"><a class="header" href="#nodejs-and-npm-module">NodeJS and NPM module</a></h1>
<p>With <a href="https://rollupjs.org/guide/en/">rollup.js</a>, we can run CommonJS (CJS) and NodeJS (NPM) modules in WasmEdge too. The <a href="https://github.com/second-state/wasmedge-quickjs/blob/main/example_js/simple_common_js_demo/npm_main.js">simple_common_js_demo/npm_main.js</a> demo shows how it works. It utilizes the third-party <code>md5</code> and <code>mathjs</code> modules.</p>
<pre><code class="language-javascript">const md5 = require('md5');
console.log('md5(message)=', md5('message'));

const {sqrt} = require('mathjs');
console.log('sqrt(-4)=', sqrt(-4).toString());
</code></pre>
<p>In order to run it, we must first use the <a href="https://rollupjs.org/guide/en/">rollup.js</a> tool to build all dependencies into a single file. In the process, <code>rollup.js</code> converts CommonJS modules into <a href="dev/js/es6.html">WasmEdge-compatible ES6 modules</a>. The build script is <a href="https://github.com/second-state/wasmedge-quickjs/blob/main/example_js/simple_common_js_demo/rollup.config.js">rollup.config.js</a>.</p>
<pre><code class="language-javascript">const {babel} = require('@rollup/plugin-babel');
const nodeResolve = require('@rollup/plugin-node-resolve');
const commonjs = require('@rollup/plugin-commonjs');
const replace = require('@rollup/plugin-replace');

const globals = require('rollup-plugin-node-globals');
const builtins = require('rollup-plugin-node-builtins');
const plugin_async = require('rollup-plugin-async');

const babelOptions = {
  'presets': ['@babel/preset-react']
};

module.exports = [
  {
    input: './npm_main.js',
    output: {
      inlineDynamicImports: true,
      file: 'dist/npm_main.mjs',
      format: 'esm',
    },
    external: ['process', 'wasi_net','std'],
    plugins: [
      plugin_async(),
      nodeResolve(),
      commonjs({ignoreDynamicRequires: false}),
      babel(babelOptions),
      globals(),
      builtins(),
      replace({
        'process.env.NODE_ENV': JSON.stringify('production'),
        'process.env.NODE_DEBUG': JSON.stringify(''),
      }),
    ],
  },
];
</code></pre>
<p>The <a href="https://github.com/second-state/wasmedge-quickjs/blob/main/example_js/simple_common_js_demo/package.json">package.json</a> file specifies the <code>rollup.js</code> dependencies and the command to build the <a href="https://github.com/second-state/wasmedge-quickjs/blob/main/example_js/simple_common_js_demo/npm_main.js">npm_main.js</a> demo program into a single bundle.</p>
<pre><code class="language-json">{
  &quot;dependencies&quot;: {
    &quot;mathjs&quot;: &quot;^9.5.1&quot;,
    &quot;md5&quot;: &quot;^2.3.0&quot;
  },
  &quot;devDependencies&quot;: {
    &quot;@babel/core&quot;: &quot;^7.16.5&quot;,
    &quot;@babel/preset-env&quot;: &quot;^7.16.5&quot;,
    &quot;@babel/preset-react&quot;: &quot;^7.16.5&quot;,
    &quot;@rollup/plugin-babel&quot;: &quot;^5.3.0&quot;,
    &quot;@rollup/plugin-commonjs&quot;: &quot;^21.0.1&quot;,
    &quot;@rollup/plugin-node-resolve&quot;: &quot;^7.1.3&quot;,
    &quot;@rollup/plugin-replace&quot;: &quot;^3.0.0&quot;,
    &quot;rollup&quot;: &quot;^2.60.1&quot;,
    &quot;rollup-plugin-babel&quot;: &quot;^4.4.0&quot;,
    &quot;rollup-plugin-node-builtins&quot;: &quot;^2.1.2&quot;,
    &quot;rollup-plugin-node-globals&quot;: &quot;^1.4.0&quot;,
    &quot;rollup-plugin-async&quot;: &quot;^1.2.0&quot;
  },
  &quot;scripts&quot;: {
    &quot;build&quot;: &quot;rollup -c rollup.config.js&quot;
  }
}
</code></pre>
<p>Run the following NPM commands to build <a href="https://github.com/second-state/wasmedge-quickjs/blob/main/example_js/simple_common_js_demo/npm_main.js">npm_main.js</a> demo program into <code>dist/npm_main.mjs</code>.</p>
<pre><code class="language-bash">npm install
npm run build
</code></pre>
<p>Run the result JS file in WasmEdge CLI as follows.</p>
<pre><code class="language-bash">$ wasmedge --dir .:. ../../target/wasm32-wasi/release/wasmedge_quickjs.wasm dist/npm_main.mjs
md5(message)= 78e731027d8fd50ed642340b7c9a63b3
sqrt(-4)= 2i
</code></pre>
<p>You can import and run any pure-JS NPM packages in WasmEdge this way.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="use-rust-to-implement-js-api"><a class="header" href="#use-rust-to-implement-js-api">Use Rust to implement JS API</a></h1>
<p>For JavaScript developers, incorporating Rust functions into JavaScript APIs is useful. That enables developers to write programs in &quot;pure JavaScript&quot; and yet still take advantage of the high performance Rust functions. With the <a href="https://github.com/WasmEdge/WasmEdge">WasmEdge Runtime</a>, you can do exactly that.</p>
<p>Check out the <a href="https://github.com/second-state/wasmedge-quickjs/">wasmedge-quickjs</a> Github repo and change to the <code>examples/embed_js</code> folder to follow along.</p>
<pre><code class="language-bash">git clone https://github.com/second-state/wasmedge-quickjs
cd examples/embed_js
</code></pre>
<blockquote>
<p>You must have <a href="https://www.rust-lang.org/tools/install">Rust</a> and <a href="dev/js/../../start/install.html">WasmEdge</a> installed to build and run the examples we show you.</p>
</blockquote>
<p>The <code>embed_js</code> demo showcases several different examples on how to embed JavaScript inside Rust. You can build and run all the examples as follows.</p>
<pre><code class="language-bash">cargo build --target wasm32-wasi --release
wasmedge --dir .:. target/wasm32-wasi/release/embed_js.wasm
</code></pre>
<blockquote>
<p>Note: The <code>--dir .:.</code> on the command line is to give wasmedge permission to read the local directory in the file system.</p>
</blockquote>
<h2 id="create-a-javascript-function-api"><a class="header" href="#create-a-javascript-function-api">Create a JavaScript function API</a></h2>
<p>The following code snippet defines a Rust function that can be incorporate into the JavaScript interpreter as an API.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn run_rust_function(ctx: &amp;mut Context) {

  struct HelloFn;
  impl JsFn for HelloFn {
    fn call(_ctx: &amp;mut Context, _this_val: JsValue, argv: &amp;[JsValue]) -&gt; JsValue {
      println!(&quot;hello from rust&quot;);
      println!(&quot;argv={:?}&quot;, argv);
      JsValue::UnDefined
    }
  }
  
  ...
}
<span class="boring">}
</span></code></pre></pre>
<p>The following code snippet shows how to add this Rust function into the JavaScript interpreter, give a name <code>hi()</code> as its JavaScript API, and then call it from JavaScript code.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn run_rust_function(ctx: &amp;mut Context) {
  ...
  
  let f = ctx.new_function::&lt;HelloFn&gt;(&quot;hello&quot;);
  ctx.get_global().set(&quot;hi&quot;, f.into());
  let code = r#&quot;hi(1,2,3)&quot;#;
  let r = ctx.eval_global_str(code);
  println!(&quot;return value:{:?}&quot;, r);
}
<span class="boring">}
</span></code></pre></pre>
<p>The execution result is as follows.</p>
<pre><code class="language-bash">hello from rust
argv=[Int(1), Int(2), Int(3)]
return value:UnDefined
</code></pre>
<p>Using this approach, you can create a JavaScript interpreter with customized API functions. The interpreter runs inside WasmEdge, and can execute JavaScript code, which calls such API functions, from CLI or the network.</p>
<h2 id="create-a-javascript-object-api"><a class="header" href="#create-a-javascript-object-api">Create a JavaScript object API</a></h2>
<p>In the JavaScript API design, we sometimes need to provide an object that encapsulates both data and function. In the following example, we define a Rust function for the JavaScript API.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn rust_new_object_and_js_call(ctx: &amp;mut Context) {
  struct ObjectFn;
  impl JsFn for ObjectFn {
    fn call(_ctx: &amp;mut Context, this_val: JsValue, argv: &amp;[JsValue]) -&gt; JsValue {
      println!(&quot;hello from rust&quot;);
      println!(&quot;argv={:?}&quot;, argv);
      if let JsValue::Object(obj) = this_val {
        let obj_map = obj.to_map();
        println!(&quot;this={:#?}&quot;, obj_map);
      }
      JsValue::UnDefined
    }
  }

  ...
}
<span class="boring">}
</span></code></pre></pre>
<p>We then create an &quot;object&quot; on the Rust side, set its data fields, and then register the Rust function as a JavaScript function associated with the objects.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut obj = ctx.new_object();
obj.set(&quot;a&quot;, 1.into());
obj.set(&quot;b&quot;, ctx.new_string(&quot;abc&quot;).into());

let f = ctx.new_function::&lt;ObjectFn&gt;(&quot;anything&quot;);
obj.set(&quot;f&quot;, f.into());
<span class="boring">}
</span></code></pre></pre>
<p>Next, we make the Rust &quot;object&quot; available as JavaScript object <code>test_obj</code> in the JavaScript interpreter.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>ctx.get_global().set(&quot;test_obj&quot;, obj.into());
<span class="boring">}
</span></code></pre></pre>
<p>In the JavaScript code, you can now directly use <code>test_obj</code> as part of the API.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let code = r#&quot;
  print('test_obj keys=',Object.keys(test_obj))
  print('test_obj.a=',test_obj.a)
  print('test_obj.b=',test_obj.b)
  test_obj.f(1,2,3,&quot;hi&quot;)
&quot;#;

ctx.eval_global_str(code);
<span class="boring">}
</span></code></pre></pre>
<p>The execution result is as follows.</p>
<pre><code class="language-bash">test_obj keys= a,b,f
test_obj.a= 1
test_obj.b= abc
hello from rust
argv=[Int(1), Int(2), Int(3), String(JsString(hi))]
this=Ok(
  {
    &quot;a&quot;: Int(
      1,
    ),
    &quot;b&quot;: String(
      JsString(
        abc,
      ),
    ),
    &quot;f&quot;: Function(
      JsFunction(
        function anything() {
          [native code]
        },
      ),
    ),
  },
)
</code></pre>
<h2 id="a-complete-javascript-object-api"><a class="header" href="#a-complete-javascript-object-api">A complete JavaScript object API</a></h2>
<p>In the previous example, we demonstrated simple examples to create JavaScript APIs from Rust. In this example, we will create a complete Rust module and make it available as a JavaScript object API. The project is in the <a href="https://github.com/second-state/wasmedge-quickjs/tree/main/examples/embed_rust_module">examples/embed_rust_module</a> folder. You can build and run it as a standard Rust application in WasmEdge.</p>
<pre><code class="language-bash">cargo build --target wasm32-wasi --release
wasmedge --dir .:. target/wasm32-wasi/release/embed_rust_module.wasm
</code></pre>
<p>The Rust implementation of the object is a module as follows. It has data fields, constructor, getters and setters, and functions.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>mod point {
  use wasmedge_quickjs::*;

  #[derive(Debug)]
  struct Point(i32, i32);

  struct PointDef;

  impl JsClassDef&lt;Point&gt; for PointDef {
    const CLASS_NAME: &amp;'static str = &quot;Point\0&quot;;
    const CONSTRUCTOR_ARGC: u8 = 2;

    fn constructor(_: &amp;mut Context, argv: &amp;[JsValue]) -&gt; Option&lt;Point&gt; {
      println!(&quot;rust-&gt; new Point {:?}&quot;, argv);
      let x = argv.get(0);
      let y = argv.get(1);
      if let ((Some(JsValue::Int(ref x)), Some(JsValue::Int(ref y)))) = (x, y) {
        Some(Point(*x, *y))
      } else {
        None
      }
    }

    fn proto_init(p: &amp;mut JsClassProto&lt;Point, PointDef&gt;) {
      struct X;
      impl JsClassGetterSetter&lt;Point&gt; for X {
        const NAME: &amp;'static str = &quot;x\0&quot;;

        fn getter(_: &amp;mut Context, this_val: &amp;mut Point) -&gt; JsValue {
          println!(&quot;rust-&gt; get x&quot;);
          this_val.0.into()
        }

        fn setter(_: &amp;mut Context, this_val: &amp;mut Point, val: JsValue) {
          println!(&quot;rust-&gt; set x:{:?}&quot;, val);
          if let JsValue::Int(x) = val {
            this_val.0 = x
          }
        }
      }

      struct Y;
      impl JsClassGetterSetter&lt;Point&gt; for Y {
        const NAME: &amp;'static str = &quot;y\0&quot;;

        fn getter(_: &amp;mut Context, this_val: &amp;mut Point) -&gt; JsValue {
          println!(&quot;rust-&gt; get y&quot;);
          this_val.1.into()
        }

        fn setter(_: &amp;mut Context, this_val: &amp;mut Point, val: JsValue) {
          println!(&quot;rust-&gt; set y:{:?}&quot;, val);
          if let JsValue::Int(y) = val {
            this_val.1 = y
          }
        }
      }

      struct FnPrint;
      impl JsMethod&lt;Point&gt; for FnPrint {
        const NAME: &amp;'static str = &quot;pprint\0&quot;;
        const LEN: u8 = 0;

        fn call(_: &amp;mut Context, this_val: &amp;mut Point, _argv: &amp;[JsValue]) -&gt; JsValue {
          println!(&quot;rust-&gt; pprint: {:?}&quot;, this_val);
          JsValue::Int(1)
        }
      }

      p.add_getter_setter(X);
      p.add_getter_setter(Y);
      p.add_function(FnPrint);
    }
  }

  struct PointModule;
  impl ModuleInit for PointModule {
    fn init_module(ctx: &amp;mut Context, m: &amp;mut JsModuleDef) {
      m.add_export(&quot;Point\0&quot;, PointDef::class_value(ctx));
    }
  }

  pub fn init_point_module(ctx: &amp;mut Context) {
    ctx.register_class(PointDef);
    ctx.register_module(&quot;point\0&quot;, PointModule, &amp;[&quot;Point\0&quot;]);
  }
}
<span class="boring">}
</span></code></pre></pre>
<p>In the interpreter implementation, we call <code>point::init_point_module</code> first to register the Rust module with the JavaScript context, and then we can run a JavaScript program that simply use the <code>point</code> object.</p>
<pre><pre class="playground"><code class="language-rust">use wasmedge_quickjs::*;
fn main() {
  let mut ctx = Context::new();
  point::init_point_module(&amp;mut ctx);

  let code = r#&quot;
    import('point').then((point)=&gt;{
    let p0 = new point.Point(1,2)
    print(&quot;js-&gt;&quot;,p0.x,p0.y)
    p0.pprint()
    try{
      let p = new point.Point()
      print(&quot;js-&gt; p:&quot;,p)
      print(&quot;js-&gt;&quot;,p.x,p.y)
      p.x=2
      p.pprint()
    } catch(e) {
      print(&quot;An error has been caught&quot;);
      print(e)
    }  
    })
  &quot;#;

  ctx.eval_global_str(code);
  ctx.promise_loop_poll();
}
</code></pre></pre>
<p>The execution result from the above application is as follows.</p>
<pre><code class="language-bash">rust-&gt; new Point [Int(1), Int(2)]
rust-&gt; get x
rust-&gt; get y
js-&gt; 1 2
rust-&gt; pprint: Point(1, 2)
rust-&gt; new Point []
js-&gt; p: undefined
An error has been caught
TypeError: cannot read property 'x' of undefined
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="go"><a class="header" href="#go">Go</a></h1>
<p>The best way to run Go programs in WasmEdge is to compile Go source code to WebAssembly using <a href="https://tinygo.org/">TinyGo</a>. In this article, we will show you how.</p>
<h2 id="install-tinygo"><a class="header" href="#install-tinygo">Install TinyGo</a></h2>
<p>You must have <a href="https://go.dev/doc/install">Go already installed</a> on your machine before installing TinyGo. Go v1.17 or above is recommended.
For Ubuntu or other Debian-based Linux systems on x86 processors, you could use the following command line to install TinyGo. For other platforms, please refer to <a href="https://tinygo.org/getting-started/install/">TinyGo docs</a>.</p>
<pre><code class="language-bash">wget https://github.com/tinygo-org/tinygo/releases/download/v0.21.0/tinygo_0.21.0_amd64.deb
sudo dpkg -i tinygo_0.21.0_amd64.deb`
</code></pre>
<p>Next, run the following command line to check out if the installation is successful.</p>
<pre><code class="language-bash">$ tinygo version
tinygo version 0.21.0 linux/amd64 (using go version go1.16.7 and LLVM version 11.0.0)
</code></pre>
<h2 id="hello-world-2"><a class="header" href="#hello-world-2">Hello world</a></h2>
<p>The simple Go app has a <code>main()</code> function to print a message to the console.
The source code in <code>main.go</code> file is as follows.</p>
<pre><code class="language-go">package main

func main() {
  println(&quot;Hello TinyGo from WasmEdge!&quot;)
}
</code></pre>
<blockquote>
<p>Inside the <code>main()</code> function, you can use Go standard API to read / write files, and access command line arguments and <code>env</code> variables.</p>
</blockquote>
<h3 id="hello-world-compile-and-build"><a class="header" href="#hello-world-compile-and-build">Hello world: Compile and build</a></h3>
<p>Next, compile the <code>main.go</code> program to WebAssembly using TinyGo.</p>
<pre><code class="language-bash">tinygo build -o hello.wasm -target wasi main.go
</code></pre>
<p>You will see a file named <code>hello.wasm</code> in the same directory. This is a WebAssembly bytecode file.</p>
<h3 id="hello-world-run"><a class="header" href="#hello-world-run">Hello world: Run</a></h3>
<p>You can run it with the <a href="dev/../start/cli.html">WasmEdge CLI</a>.</p>
<pre><code class="language-bash">$ wasmedge hello.wasm
Hello TinyGo from WasmEdge!
</code></pre>
<h2 id="a-simple-function-1"><a class="header" href="#a-simple-function-1">A simple function</a></h2>
<p>The second example is a Go function that takes a call parameter to compute a fibonacci number. However, in order for the Go application to set up proper access to the OS (e.g., to access the command line arguments), you must include an empty <code>main()</code> function in the source code.</p>
<pre><code class="language-go">package main

func main(){
}

//export fibArray
func fibArray(n int32) int32{
  arr := make([]int32, n)
  for i := int32(0); i &lt; n; i++ {
    switch {
    case i &lt; 2:
      arr[i] = i
    default:
      arr[i] = arr[i-1] + arr[i-2]
    }
  }
  return arr[n-1]
}
</code></pre>
<h3 id="a-simple-function-compile-and-build"><a class="header" href="#a-simple-function-compile-and-build">A simple function: Compile and build</a></h3>
<p>Next, compile the <code>main.go</code> program to WebAssembly using TinyGo.</p>
<pre><code class="language-bash">tinygo build -o fib.wasm -target wasi main.go
</code></pre>
<p>You will see a file named <code>fib.wasm</code> in the same directory. This is a WebAssembly bytecode file.</p>
<h3 id="a-simple-function-run"><a class="header" href="#a-simple-function-run">A simple function: Run</a></h3>
<p>You can run it with the <a href="dev/../start/cli.html">WasmEdge CLI</a> in its <code>--reactor</code> mode.
The command line arguments that follow the <code>wasm</code> file are the function name
and its call parameters.</p>
<pre><code class="language-bash">$ wasmedge --reactor fib.wasm fibArray 10
34
</code></pre>
<h2 id="improve-performance-1"><a class="header" href="#improve-performance-1">Improve performance</a></h2>
<p>To achieve native Go performance for those applications, you could use the <code>wasmedgec</code> command to AOT compile the <code>wasm</code> program, and then run it with the <code>wasmedge</code> command.</p>
<pre><code class="language-bash">$ wasmedgec hello.wasm hello.wasm

$ wasmedge hello.wasm
Hello TinyGo from WasmEdge!
</code></pre>
<p>For the <code>--reactor</code> mode,</p>
<pre><code class="language-bash">$ wasmedgec fib.wasm fib.wasm

$ wasmedge --reactor fib.wasm fibArray 10
34
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="swift"><a class="header" href="#swift">Swift</a></h1>
<p>The <a href="https://swiftwasm.org/">swiftwasm</a> project compiles Swift source code to WebAssembly.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="assemblyscript"><a class="header" href="#assemblyscript">AssemblyScript</a></h1>
<p><a href="https://www.assemblyscript.org/">AssemblyScript</a> is a TypeScript-like language designed for WebAssembly. AssemblyScript programs can be easily compiled into WebAssembly.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="kotlin"><a class="header" href="#kotlin">Kotlin</a></h1>
<p>Check out how to <a href="https://blog.jdriven.com/2021/04/running-kotlin-in-the-browser-with-wasm/">compile Kotlin programs to WebAssembly</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="grain"><a class="header" href="#grain">Grain</a></h1>
<p><a href="https://grain-lang.org/">Grain</a> is a strongly typed languages designed for WebAssembly. Checkout its <a href="https://grain-lang.org/docs/guide/hello_world">Hello world</a> example.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="python"><a class="header" href="#python">Python</a></h1>
<p>There are already several different language implementations of the Python runtime, and some of them support WebAssembly. This document will describe how to run <a href="https://github.com/RustPython/RustPython">RustPython</a> on WasmEdge to execute Python programs.</p>
<h2 id="compile-rustpython"><a class="header" href="#compile-rustpython">Compile RustPython</a></h2>
<p>To compile RustPython, you should have the Rust toolchain installed on your machine. And <code>wasm32-wasi</code> platform support should be enabled.</p>
<pre><code class="language-bash">rustup target add wasm32-wasi
</code></pre>
<p>Then you could use the following command to clone and compile RustPython:</p>
<pre><code class="language-bash">git clone https://github.com/RustPython/RustPython.git
cd RustPython
cargo build --release --target wasm32-wasi --features=&quot;freeze-stdlib&quot;
</code></pre>
<p><code>freeze-stdlib</code> feature is enabled for including Python standard library inside the binary file. The output file should be able at <code>target/wasm32-wasi/release/rustpython.wasm</code>.</p>
<h2 id="aot-compile"><a class="header" href="#aot-compile">AOT Compile</a></h2>
<p>WasmEdge supports compiling WebAssembly bytecode programs into native machine code for better performance. It is highly recommended to compile the RustPython to native machine code before running.</p>
<pre><code class="language-bash">wasmedgec ./target/wasm32-wasi/release/rustpython.wasm ./target/wasm32-wasi/release/rustpython.wasm
</code></pre>
<p>Since WasmEdge 0.9.0, the <a href="https://wasmedge.org/book/en/start/universal.html">universal Wasm binary format</a> has been introduced. So you could use the <code>.wasm</code> extension for generating cross-runtime compatible format, or use <code>.so</code> for Linux shared library format.</p>
<h2 id="run-1"><a class="header" href="#run-1">Run</a></h2>
<pre><code class="language-bash">wasmedge ./target/wasm32-wasi/release/rustpython.wasm
</code></pre>
<p>Then you could get a Python shell in WebAssembly!</p>
<h2 id="grant-file-system-access"><a class="header" href="#grant-file-system-access">Grant file system access</a></h2>
<p>You can pre-open directories to let WASI programs have permission to read and write files stored on the real machine. The following command mounted the current working directory to the WASI virtual file system.</p>
<pre><code class="language-bash">wasmedge --dir .:. ./target/wasm32-wasi/release/rustpython.wasm
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="embed-wasmedge-functions"><a class="header" href="#embed-wasmedge-functions">Embed WasmEdge functions</a></h1>
<p>A common use case for WasmEdge is to embed it in your own applications (called a host application). It allows you to support 3rd party plug-ins and extensions for your applications. Those plug-ins and extensions could be written in any of the languages WasmEdge supports, and by anyone as they are safely and securely executed in the WasmEdge sandbox.</p>
<p>In this chapter, we will discuss how to use WasmEdge SDKs to embed WasmEdge programs into C, Rust, Go, and Python host applications.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="wasmedge-c-sdk"><a class="header" href="#wasmedge-c-sdk">WasmEdge C SDK</a></h1>
<p>The WasmEdge C API denotes an interface to embed the WasmEdge runtime into a C program. The followings are the quick start guides to working with the C APIs of WasmEdge. For the details of the WasmEdge C API, please refer to the <a href="embed/c/ref.html">full documentation</a>.</p>
<p>The WasmEdge C API also the fundamental API for other languages' SDK.</p>
<h2 id="quick-start-guide-for-the-wasmedge-runner"><a class="header" href="#quick-start-guide-for-the-wasmedge-runner">Quick Start Guide for the WasmEdge runner</a></h2>
<p>The following is an example for running a WASM file.
Assume that the WASM file <a href="https://github.com/WasmEdge/WasmEdge/raw/master/tools/wasmedge/examples/fibonacci.wasm">fibonacci.wasm</a> is copied into the current directory, and the C file <code>test_wasmedge.c</code> is as following:</p>
<pre><code class="language-c">#include &lt;wasmedge/wasmedge.h&gt;
#include &lt;stdio.h&gt;
int main(int Argc, const char* Argv[]) {
  /* Create the configure context and add the WASI support. */
  /* This step is not necessary unless you need WASI support. */
  WasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();
  WasmEdge_ConfigureAddHostRegistration(ConfCxt, WasmEdge_HostRegistration_Wasi);
  /* The configure and store context to the VM creation can be NULL. */
  WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(ConfCxt, NULL);

  /* The parameters and returns arrays. */
  WasmEdge_Value Params[1] = { WasmEdge_ValueGenI32(32) };
  WasmEdge_Value Returns[1];
  /* Function name. */
  WasmEdge_String FuncName = WasmEdge_StringCreateByCString(&quot;fib&quot;);
  /* Run the WASM function from file. */
  WasmEdge_Result Res = WasmEdge_VMRunWasmFromFile(VMCxt, Argv[1], FuncName, Params, 1, Returns, 1);

  if (WasmEdge_ResultOK(Res)) {
    printf(&quot;Get result: %d\n&quot;, WasmEdge_ValueGetI32(Returns[0]));
  } else {
    printf(&quot;Error message: %s\n&quot;, WasmEdge_ResultGetMessage(Res));
  }

  /* Resources deallocations. */
  WasmEdge_VMDelete(VMCxt);
  WasmEdge_ConfigureDelete(ConfCxt);
  WasmEdge_StringDelete(FuncName);
  return 0;
}
</code></pre>
<p>Then you can compile and run: (the 32th fibonacci number is 3524578 in 0-based index)</p>
<pre><code class="language-bash">$ gcc test_wasmedge.c -lwasmedge_c -o test_wasmedge
$ ./test_wasmedge fibonacci.wasm
Get result: 3524578
</code></pre>
<h2 id="quick-start-guide-for-the-wasmedge-aot-compiler"><a class="header" href="#quick-start-guide-for-the-wasmedge-aot-compiler">Quick Start Guide for the WasmEdge AOT compiler</a></h2>
<p>Assume that the WASM file <a href="https://github.com/WasmEdge/WasmEdge/raw/master/tools/wasmedge/examples/fibonacci.wasm">fibonacci.wasm</a> is copied into the current directory, and the C file <code>test_wasmedge_compiler.c</code> is as following:</p>
<pre><code class="language-c">#include &lt;wasmedge/wasmedge.h&gt;
#include &lt;stdio.h&gt;
int main(int Argc, const char* Argv[]) {
  /* Create the configure context. */
  WasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();
  /* ... Adjust settings in the configure context. */
  /* Result. */
  WasmEdge_Result Res;

  /* Create the compiler context. The configure context can be NULL. */
  WasmEdge_CompilerContext *CompilerCxt = WasmEdge_CompilerCreate(ConfCxt);
  /* Compile the WASM file with input and output paths. */
  Res = WasmEdge_CompilerCompile(CompilerCxt, Argv[1], Argv[2]);
  if (!WasmEdge_ResultOK(Res)) {
    printf(&quot;Compilation failed: %s\n&quot;, WasmEdge_ResultGetMessage(Res));
    return 1;
  }

  WasmEdge_CompilerDelete(CompilerCxt);
  WasmEdge_ConfigureDelete(ConfCxt);
  return 0;
}
</code></pre>
<p>Then you can compile and run (the output file is <code>fibonacci.wasm.so</code>):</p>
<pre><code class="language-bash">$ gcc test_wasmedge_compiler.c -lwasmedge_c -o test_wasmedge_compiler
$ ./test_wasmedge_compiler fibonacci.wasm fibonacci.wasm.so
[2021-07-02 11:08:08.651] [info] compile start
[2021-07-02 11:08:08.653] [info] verify start
[2021-07-02 11:08:08.653] [info] optimize start
[2021-07-02 11:08:08.670] [info] codegen start
[2021-07-02 11:08:08.706] [info] compile done
</code></pre>
<p>The compiled-WASM file can be used as a WASM input for the WasmEdge runner.
The following is the comparison of the interpreter mode and the AOT mode:</p>
<pre><code class="language-bash">$ time ./test_wasmedge fibonacci.wasm
Get result: 5702887

real 0m2.715s
user 0m2.700s
sys 0m0.008s

$ time ./test_wasmedge fibonacci.wasm.so
Get result: 5702887

real 0m0.036s
user 0m0.022s
sys 0m0.011s
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="wasmedge-c-0100-unreleased-api-documentation"><a class="header" href="#wasmedge-c-0100-unreleased-api-documentation">WasmEdge C 0.10.0 (unreleased) API Documentation</a></h1>
<p><a href="https://github.com/WasmEdge/WasmEdge/blob/master/include/api/wasmedge/wasmedge.h">WasmEdge C API</a> denotes an interface to access the WasmEdge runtime. The followings are the guides to working with the C APIs of WasmEdge.</p>
<p><strong>This document is for the <code>master</code> branch. For the stable <code>0.9.1</code> version, please refer to the <a href="embed/c/0.9.1/ref.html">document here</a>.</strong></p>
<p><strong>Developers can refer <a href="embed/c/0.9.1/upgrade_to_0.10.0.html">here to upgrade to 0.10.0</a>.</strong></p>
<h2 id="table-of-contents-1"><a class="header" href="#table-of-contents-1">Table of Contents</a></h2>
<ul>
<li><a href="embed/c/ref.html#wasmedge-installation">WasmEdge Installation</a>
<ul>
<li><a href="embed/c/ref.html#download-and-install">Download And Install</a></li>
<li><a href="embed/c/ref.html#compile-sources">Compile Sources</a></li>
</ul>
</li>
<li><a href="embed/c/ref.html#wasmedge-basics">WasmEdge Basics</a>
<ul>
<li><a href="embed/c/ref.html#version">Version</a></li>
<li><a href="embed/c/ref.html#logging-settings">Logging Settings</a></li>
<li><a href="embed/c/ref.html#value-types">Value Types</a></li>
<li><a href="embed/c/ref.html#strings">Strings</a></li>
<li><a href="embed/c/ref.html#results">Results</a></li>
<li><a href="embed/c/ref.html#contexts">Contexts</a></li>
<li><a href="embed/c/ref.html#wasm-data-structures">WASM data structures</a></li>
<li><a href="embed/c/ref.html#async">Async</a></li>
<li><a href="embed/c/ref.html#configurations">Configurations</a></li>
<li><a href="embed/c/ref.html#statistics">Statistics</a></li>
</ul>
</li>
<li><a href="embed/c/ref.html#wasmedge-vm">WasmEdge VM</a>
<ul>
<li><a href="embed/c/ref.html#wasm-execution-example-with-vm-context">WASM Execution Example With VM Context</a></li>
<li><a href="embed/c/ref.html#vm-creations">VM Creations</a></li>
<li><a href="embed/c/ref.html#preregistrations">Preregistrations</a></li>
<li><a href="embed/c/ref.html#host-module-registrations">Host Module Registrations</a></li>
<li><a href="embed/c/ref.html#wasm-registrations-and-executions">WASM Registrations And Executions</a></li>
<li><a href="embed/c/ref.html#asynchronous-execution">Asynchronous execution</a></li>
<li><a href="embed/c/ref.html#instance-tracing">Instance Tracing</a></li>
</ul>
</li>
<li><a href="embed/c/ref.html#wasmedge-runtime">WasmEdge Runtime</a>
<ul>
<li><a href="embed/c/ref.html#wasm-execution-example-step-by-step">WASM Execution Example Step-By-Step</a></li>
<li><a href="embed/c/ref.html#loader">Loader</a></li>
<li><a href="embed/c/ref.html#validator">Validator</a></li>
<li><a href="embed/c/ref.html#executor">Executor</a></li>
<li><a href="embed/c/ref.html#ast-module">AST Module</a></li>
<li><a href="embed/c/ref.html#store">Store</a></li>
<li><a href="embed/c/ref.html#instances">Instances</a></li>
<li><a href="embed/c/ref.html#host-functions">Host Functions</a></li>
</ul>
</li>
<li><a href="embed/c/ref.html#wasmEdge-aot-compiler">WasmEdge AOT Compiler</a>
<ul>
<li><a href="embed/c/ref.html#compilation-example">Compilation Example</a></li>
<li><a href="embed/c/ref.html#compiler-options">Compiler Options</a></li>
</ul>
</li>
</ul>
<h2 id="wasmedge-installation"><a class="header" href="#wasmedge-installation">WasmEdge Installation</a></h2>
<h3 id="download-and-install"><a class="header" href="#download-and-install">Download And Install</a></h3>
<p><strong>This is for the installation of the stable <code>0.9.1</code> version. For the C APIs in this document, please <a href="embed/c/../../extend/build.html">build WasmEdge from source with the <code>master</code> branch</a>.</strong></p>
<p>The easiest way to install WasmEdge is to run the following command. Your system should have <code>git</code> and <code>wget</code> as prerequisites.</p>
<pre><code class="language-bash">curl -sSf https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/utils/install.sh | bash -s -- -v 0.9.1
</code></pre>
<p>For more details, please refer to the <a href="embed/c//start/install.html">Installation Guide</a> for the WasmEdge installation.</p>
<h3 id="compile-sources"><a class="header" href="#compile-sources">Compile Sources</a></h3>
<p>After the installation of WasmEdge, the following guide can help you to test for the availability of the WasmEdge C API.</p>
<ol>
<li>
<p>Prepare the test C file (and assumed saved as <code>test.c</code>):</p>
<pre><code class="language-c">#include &lt;wasmedge/wasmedge.h&gt;
#include &lt;stdio.h&gt;
int main() {
  printf(&quot;WasmEdge version: %s\n&quot;, WasmEdge_VersionGet());
  return 0;
}
</code></pre>
</li>
<li>
<p>Compile the file with <code>gcc</code> or <code>clang</code>.</p>
<pre><code class="language-bash">gcc test.c -lwasmedge_c
</code></pre>
</li>
<li>
<p>Run and get the expected output.</p>
<pre><code class="language-bash">$ ./a.out
WasmEdge version: 0.9.1
</code></pre>
</li>
</ol>
<h2 id="wasmedge-basics"><a class="header" href="#wasmedge-basics">WasmEdge Basics</a></h2>
<p>In this part, we will introduce the utilities and concepts of WasmEdge shared library.</p>
<h3 id="version"><a class="header" href="#version">Version</a></h3>
<p>The <code>Version</code> related APIs provide developers to check for the WasmEdge shared library version.</p>
<pre><code class="language-c">#include &lt;wasmedge/wasmedge.h&gt;
printf(&quot;WasmEdge version: %s\n&quot;, WasmEdge_VersionGet());
printf(&quot;WasmEdge version major: %u\n&quot;, WasmEdge_VersionGetMajor());
printf(&quot;WasmEdge version minor: %u\n&quot;, WasmEdge_VersionGetMinor());
printf(&quot;WasmEdge version patch: %u\n&quot;, WasmEdge_VersionGetPatch());
</code></pre>
<h3 id="logging-settings"><a class="header" href="#logging-settings">Logging Settings</a></h3>
<p>The <code>WasmEdge_LogSetErrorLevel()</code> and <code>WasmEdge_LogSetDebugLevel()</code> APIs can set the logging system to debug level or error level. By default, the error level is set, and the debug info is hidden.</p>
<h3 id="value-types"><a class="header" href="#value-types">Value Types</a></h3>
<p>In WasmEdge, developers should convert the values to <code>WasmEdge_Value</code> objects through APIs for matching to the WASM value types.</p>
<ol>
<li>
<p>Number types: <code>i32</code>, <code>i64</code>, <code>f32</code>, <code>f64</code>, and <code>v128</code> for the <code>SIMD</code> proposal</p>
<pre><code class="language-c">WasmEdge_Value Val;
Val = WasmEdge_ValueGenI32(123456);
printf(&quot;%d\n&quot;, WasmEdge_ValueGetI32(Val));
/* Will print &quot;123456&quot; */
Val = WasmEdge_ValueGenI64(1234567890123LL);
printf(&quot;%ld\n&quot;, WasmEdge_ValueGetI64(Val));
/* Will print &quot;1234567890123&quot; */
Val = WasmEdge_ValueGenF32(123.456f);
printf(&quot;%f\n&quot;, WasmEdge_ValueGetF32(Val));
/* Will print &quot;123.456001&quot; */
Val = WasmEdge_ValueGenF64(123456.123456789);
printf(&quot;%.10f\n&quot;, WasmEdge_ValueGetF64(Val));
/* Will print &quot;123456.1234567890&quot; */
</code></pre>
</li>
<li>
<p>Reference types: <code>funcref</code> and <code>externref</code> for the <code>Reference-Types</code> proposal</p>
<pre><code class="language-c">WasmEdge_Value Val;
void *Ptr;
bool IsNull;
uint32_t Num = 10;
/* Genreate a externref to NULL. */
Val = WasmEdge_ValueGenNullRef(WasmEdge_RefType_ExternRef);
IsNull = WasmEdge_ValueIsNullRef(Val);
/* The `IsNull` will be `TRUE`. */
Ptr = WasmEdge_ValueGetExternRef(Val);
/* The `Ptr` will be `NULL`. */

/* Genreate a funcref with function index 20. */
Val = WasmEdge_ValueGenFuncRef(20);
uint32_t FuncIdx = WasmEdge_ValueGetFuncIdx(Val);
/* The `FuncIdx` will be 20. */

/* Genreate a externref to `Num`. */
Val = WasmEdge_ValueGenExternRef(&amp;Num);
Ptr = WasmEdge_ValueGetExternRef(Val);
/* The `Ptr` will be `&amp;Num`. */
printf(&quot;%u\n&quot;, *(uint32_t *)Ptr);
/* Will print &quot;10&quot; */
Num += 55;
printf(&quot;%u\n&quot;, *(uint32_t *)Ptr);
/* Will print &quot;65&quot; */
</code></pre>
</li>
</ol>
<h3 id="strings"><a class="header" href="#strings">Strings</a></h3>
<p>The <code>WasmEdge_String</code> object is for the instance names when invoking a WASM function or finding the contexts of instances.</p>
<ol>
<li>
<p>Create a <code>WasmEdge_String</code> from a C string (<code>const char *</code> with NULL termination) or a buffer with length.</p>
<p>The content of the C string or buffer will be copied into the <code>WasmEdge_String</code> object.</p>
<pre><code class="language-c">char Buf[4] = {50, 55, 60, 65};
WasmEdge_String Str1 = WasmEdge_StringCreateByCString(&quot;test&quot;);
WasmEdge_String Str2 = WasmEdge_StringCreateByBuffer(Buf, 4);
/* The objects should be deleted by `WasmEdge_StringDelete()`. */
WasmEdge_StringDelete(Str1);
WasmEdge_StringDelete(Str2);
</code></pre>
</li>
<li>
<p>Wrap a <code>WasmEdge_String</code> to a buffer with length.</p>
<p>The content will not be copied, and the caller should guarantee the life cycle of the input buffer.</p>
<pre><code class="language-c">const char CStr[] = &quot;test&quot;;
WasmEdge_String Str = WasmEdge_StringWrap(CStr, 4);
/* The object should __NOT__ be deleted by `WasmEdge_StringDelete()`. */
</code></pre>
</li>
<li>
<p>String comparison</p>
<pre><code class="language-c">const char CStr[] = &quot;abcd&quot;;
char Buf[4] = {0x61, 0x62, 0x63, 0x64};
WasmEdge_String Str1 = WasmEdge_StringWrap(CStr, 4);
WasmEdge_String Str2 = WasmEdge_StringCreateByBuffer(Buf, 4);
bool IsEq = WasmEdge_StringIsEqual(Str1, Str2);
/* The `IsEq` will be `TRUE`. */
WasmEdge_StringDelete(Str2);
</code></pre>
</li>
<li>
<p>Convert to C string</p>
<pre><code class="language-c">char Buf[256];
WasmEdge_String Str = WasmEdge_StringCreateByCString(&quot;test_wasmedge_string&quot;);
uint32_t StrLength = WasmEdge_StringCopy(Str, Buf, sizeof(Buf));
/* StrLength will be 20 */
printf(&quot;String: %s\n&quot;, Buf);
/* Will print &quot;test_wasmedge_string&quot;. */
</code></pre>
</li>
</ol>
<h3 id="results"><a class="header" href="#results">Results</a></h3>
<p>The <code>WasmEdge_Result</code> object specifies the execution status.
APIs about WASM execution will return the <code>WasmEdge_Result</code> to denote the status.</p>
<pre><code class="language-c">WasmEdge_Result Res = WasmEdge_Result_Success;
bool IsSucceeded = WasmEdge_ResultOK(Res);
/* The `IsSucceeded` will be `TRUE`. */
uint32_t Code = WasmEdge_ResultGetCode(Res);
/* The `Code` will be 0. */
const char *Msg = WasmEdge_ResultGetMessage(Res);
/* The `Msg` will be &quot;success&quot;. */
</code></pre>
<h3 id="contexts"><a class="header" href="#contexts">Contexts</a></h3>
<p>The objects, such as <code>VM</code>, <code>Store</code>, and <code>Function</code>, are composed of <code>Context</code>s.
All of the contexts can be created by calling the corresponding creation APIs and should be destroyed by calling the corresponding deletion APIs. Developers have responsibilities to manage the contexts for memory management.</p>
<pre><code class="language-c">/* Create the configure context. */
WasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();
/* Delete the configure context. */
WasmEdge_ConfigureDelete(ConfCxt);
</code></pre>
<p>The details of other contexts will be introduced later.</p>
<h3 id="wasm-data-structures"><a class="header" href="#wasm-data-structures">WASM Data Structures</a></h3>
<p>The WASM data structures are used for creating instances or can be queried from instance contexts.
The details of instances creation will be introduced in the <a href="embed/c/ref.html#instances">Instances</a>.</p>
<ol>
<li>
<p>Limit</p>
<p>The <code>WasmEdge_Limit</code> struct is defined in the header:</p>
<pre><code class="language-c">/// Struct of WASM limit.
typedef struct WasmEdge_Limit {
  /// Boolean to describe has max value or not.
  bool HasMax;
  /// Minimum value.
  uint32_t Min;
  /// Maximum value. Will be ignored if the `HasMax` is false.
  uint32_t Max;
} WasmEdge_Limit;
</code></pre>
<p>Developers can initialize the struct by assigning it's value, and the <code>Max</code> value is needed to be larger or equal to the <code>Min</code> value.
The API <code>WasmEdge_LimitIsEqual()</code> is provided to compare with 2 <code>WasmEdge_Limit</code> structs.</p>
</li>
<li>
<p>Function type context</p>
<p>The <code>Function Type</code> context is used for the <code>Function</code> creation, checking the value types of a <code>Function</code> instance, or getting the function type with function name from VM. Developers can use the <code>Function Type</code> context APIs to get the parameter or return value types information.</p>
<pre><code class="language-c">enum WasmEdge_ValType ParamList[2] = { WasmEdge_ValType_I32, WasmEdge_ValType_I64 };
enum WasmEdge_ValType ReturnList[1] = { WasmEdge_ValType_FuncRef };
WasmEdge_FunctionTypeContext *FuncTypeCxt = WasmEdge_FunctionTypeCreate(ParamList, 2, ReturnList, 1);

enum WasmEdge_ValType Buf[16];
uint32_t ParamLen = WasmEdge_FunctionTypeGetParametersLength(FuncTypeCxt);
/* `ParamLen` will be 2. */
uint32_t GotParamLen = WasmEdge_FunctionTypeGetParameters(FuncTypeCxt, Buf, 16);
/* `GotParamLen` will be 2, and `Buf[0]` and `Buf[1]` will be the same as `ParamList`. */
uint32_t ReturnLen = WasmEdge_FunctionTypeGetReturnsLength(FuncTypeCxt);
/* `ReturnLen` will be 1. */
uint32_t GotReturnLen = WasmEdge_FunctionTypeGetReturns(FuncTypeCxt, Buf, 16);
/* `GotReturnLen` will be 1, and `Buf[0]` will be the same as `ReturnList`. */

WasmEdge_FunctionTypeDelete(FuncTypeCxt);
</code></pre>
</li>
<li>
<p>Table type context</p>
<p>The <code>Table Type</code> context is used for <code>Table</code> instance creation or getting information from <code>Table</code> instances.</p>
<pre><code class="language-c">WasmEdge_Limit TabLim = {.HasMax = true, .Min = 10, .Max = 20};
WasmEdge_TableTypeContext *TabTypeCxt = WasmEdge_TableTypeCreate(WasmEdge_RefType_ExternRef, TabLim);

enum WasmEdge_RefType GotRefType = WasmEdge_TableTypeGetRefType(TabTypeCxt);
/* `GotRefType` will be WasmEdge_RefType_ExternRef. */
WasmEdge_Limit GotTabLim = WasmEdge_TableTypeGetLimit(TabTypeCxt);
/* `GotTabLim` will be the same value as `TabLim`. */

WasmEdge_TableTypeDelete(TabTypeCxt);
</code></pre>
</li>
<li>
<p>Memory type context</p>
<p>The <code>Memory Type</code> context is used for <code>Memory</code> instance creation or getting information from <code>Memory</code> instances.</p>
<pre><code class="language-c">WasmEdge_Limit MemLim = {.HasMax = true, .Min = 10, .Max = 20};
WasmEdge_MemoryTypeContext *MemTypeCxt = WasmEdge_MemoryTypeCreate(MemLim);

WasmEdge_Limit GotMemLim = WasmEdge_MemoryTypeGetLimit(MemTypeCxt);
/* `GotMemLim` will be the same value as `MemLim`. */

WasmEdge_MemoryTypeDelete(MemTypeCxt)
</code></pre>
</li>
<li>
<p>Global type context</p>
<p>The <code>Global Type</code> context is used for <code>Global</code> instance creation or getting information from <code>Global</code> instances.</p>
<pre><code class="language-c">WasmEdge_GlobalTypeContext *GlobTypeCxt = WasmEdge_GlobalTypeCreate(WasmEdge_ValType_F64, WasmEdge_Mutability_Var);

WasmEdge_ValType GotValType = WasmEdge_GlobalTypeGetValType(GlobTypeCxt);
/* `GotValType` will be WasmEdge_ValType_F64. */
WasmEdge_Mutability GotValMut = WasmEdge_GlobalTypeGetMutability(GlobTypeCxt);
/* `GotValMut` will be WasmEdge_Mutability_Var. */

WasmEdge_GlobalTypeDelete(GlobTypeCxt);
</code></pre>
</li>
<li>
<p>Import type context</p>
<p>The <code>Import Type</code> context is used for getting the imports information from a <a href="embed/c/ref.html#ast-module">AST Module</a>.
Developers can get the external type (<code>function</code>, <code>table</code>, <code>memory</code>, or <code>global</code>), import module name, and external name from an <code>Import Type</code> context.
The details about querying <code>Import Type</code> contexts will be introduced in the <a href="embed/c/ref.html#ast-module">AST Module</a>.</p>
<pre><code class="language-c">WasmEdge_ASTModuleContext *ASTCxt = ...;
/* Assume that `ASTCxt` is returned by the `WasmEdge_LoaderContext` for the result of loading a WASM file. */
const WasmEdge_ImportTypeContext *ImpType = ...;
/* Assume that `ImpType` is queried from the `ASTCxt` for the import. */

enum WasmEdge_ExternalType ExtType = WasmEdge_ImportTypeGetExternalType(ImpType);
/*
 * The `ExtType` can be one of `WasmEdge_ExternalType_Function`, `WasmEdge_ExternalType_Table`,
 * `WasmEdge_ExternalType_Memory`, or `WasmEdge_ExternalType_Global`.
 */
WasmEdge_String ModName = WasmEdge_ImportTypeGetModuleName(ImpType);
WasmEdge_String ExtName = WasmEdge_ImportTypeGetExternalName(ImpType);
/* The `ModName` and `ExtName` should not be destroyed and the string buffers are binded into the `ASTCxt`. */
const WasmEdge_FunctionTypeContext *FuncTypeCxt = WasmEdge_ImportTypeGetFunctionType(ASTCxt, ImpType);
/* If the `ExtType` is not `WasmEdge_ExternalType_Function`, the `FuncTypeCxt` will be NULL. */
const WasmEdge_TableTypeContext *TabTypeCxt = WasmEdge_ImportTypeGetTableType(ASTCxt, ImpType);
/* If the `ExtType` is not `WasmEdge_ExternalType_Table`, the `TabTypeCxt` will be NULL. */
const WasmEdge_MemoryTypeContext *MemTypeCxt = WasmEdge_ImportTypeGetMemoryType(ASTCxt, ImpType);
/* If the `ExtType` is not `WasmEdge_ExternalType_Memory`, the `MemTypeCxt` will be NULL. */
const WasmEdge_GlobalTypeContext *GlobTypeCxt = WasmEdge_ImportTypeGetGlobalType(ASTCxt, ImpType);
/* If the `ExtType` is not `WasmEdge_ExternalType_Global`, the `GlobTypeCxt` will be NULL. */
</code></pre>
</li>
<li>
<p>Export type context</p>
<p>The <code>Export Type</code> context is used for getting the exports information from a <a href="embed/c/ref.html#ast-module">AST Module</a>.
Developers can get the external type (<code>function</code>, <code>table</code>, <code>memory</code>, or <code>global</code>) and external name from an <code>Export Type</code> context.
The details about querying <code>Export Type</code> contexts will be introduced in the <a href="embed/c/ref.html#ast-module">AST Module</a>.</p>
<pre><code class="language-c">WasmEdge_ASTModuleContext *ASTCxt = ...;
/* Assume that `ASTCxt` is returned by the `WasmEdge_LoaderContext` for the result of loading a WASM file. */
const WasmEdge_ExportTypeContext *ExpType = ...;
/* Assume that `ExpType` is queried from the `ASTCxt` for the export. */

enum WasmEdge_ExternalType ExtType = WasmEdge_ExportTypeGetExternalType(ExpType);
/*
 * The `ExtType` can be one of `WasmEdge_ExternalType_Function`, `WasmEdge_ExternalType_Table`,
 * `WasmEdge_ExternalType_Memory`, or `WasmEdge_ExternalType_Global`.
 */
WasmEdge_String ExtName = WasmEdge_ExportTypeGetExternalName(ExpType);
/* The `ExtName` should not be destroyed and the string buffer is binded into the `ASTCxt`. */
const WasmEdge_FunctionTypeContext *FuncTypeCxt = WasmEdge_ExportTypeGetFunctionType(ASTCxt, ExpType);
/* If the `ExtType` is not `WasmEdge_ExternalType_Function`, the `FuncTypeCxt` will be NULL. */
const WasmEdge_TableTypeContext *TabTypeCxt = WasmEdge_ExportTypeGetTableType(ASTCxt, ExpType);
/* If the `ExtType` is not `WasmEdge_ExternalType_Table`, the `TabTypeCxt` will be NULL. */
const WasmEdge_MemoryTypeContext *MemTypeCxt = WasmEdge_ExportTypeGetMemoryType(ASTCxt, ExpType);
/* If the `ExtType` is not `WasmEdge_ExternalType_Memory`, the `MemTypeCxt` will be NULL. */
const WasmEdge_GlobalTypeContext *GlobTypeCxt = WasmEdge_ExportTypeGetGlobalType(ASTCxt, ExpType);
/* If the `ExtType` is not `WasmEdge_ExternalType_Global`, the `GlobTypeCxt` will be NULL. */
</code></pre>
</li>
</ol>
<h3 id="async"><a class="header" href="#async">Async</a></h3>
<p>After calling the <a href="embed/c/ref.html#asynchronous-execution">asynchronous execution APIs</a>, developers will get the <code>WasmEdge_Async</code> object.
Developers own the object and should call the <code>WasmEdge_AsyncDelete()</code> API to destroy it.</p>
<ol>
<li>
<p>Wait for the asynchronous execution</p>
<p>Developers can wait the execution until finished:</p>
<pre><code class="language-c">WasmEdge_Async *Async = ...; /* Ignored. Asynchronous execute a function. */
/* Blocking and waiting for the execution. */
WasmEdge_AsyncWait(Async);
WasmEdge_AsyncDelete(Async);
</code></pre>
<p>Or developers can wait for a time limit.
If the time limit exceeded, developers can choose to cancel the execution.
For the interruptible execution in AOT mode, developers should set <code>TRUE</code> thourgh the <code>WasmEdge_ConfigureCompilerSetInterruptible()</code> API into the configure context for the AOT compiler.</p>
<pre><code class="language-c">WasmEdge_Async *Async = ...; /* Ignored. Asynchronous execute a function. */
/* Blocking and waiting for the execution for 1 second. */
bool IsEnd = WasmEdge_AsyncWaitFor(Async, 1000);
if (IsEnd) {
  /* The execution finished. Developers can get the result. */
  WasmEdge_Result Res = WasmEdge_AsyncGet(/* ... Ignored */);
} else {
  /* The time limit exceeded. Developers can keep waiting or cancel the execution. */
  WasmEdge_AsyncCancel(Async);
  WasmEdge_Result Res = WasmEdge_AsyncGet(Async, 0, NULL);
  /* The result error code will be `WasmEdge_ErrCode_Interrupted`. */
}
WasmEdge_AsyncDelete(Async);
</code></pre>
</li>
<li>
<p>Get the execution result of the asynchronous execution</p>
<p>Developers can use the <code>WasmEdge_AsyncGetReturnsLength()</code> API to get the return value list length.
This function will block and wait for the execution. If the execution has finished, this function will return the length immediately. If the execution failed, this function will return <code>0</code>.
This function can help the developers to create the buffer to get the return values. If developers have already known the buffer length, they can skip this function and use the <code>WasmEdge_AsyncGet()</code> API to get the result.</p>
<pre><code class="language-c">WasmEdge_Async *Async = ...; /* Ignored. Asynchronous execute a function. */
/* Blocking and waiting for the execution and get the return value list length. */
uint32_t Arity = WasmEdge_AsyncGetReturnsLength(Async);
WasmEdge_AsyncDelete(Async);
</code></pre>
<p>The <code>WasmEdge_AsyncGet()</code> API will block and wait for the execution. If the execution has finished, this function will fill the return values into the buffer and return the execution result immediately.</p>
<pre><code class="language-c">WasmEdge_Async *Async = ...; /* Ignored. Asynchronous execute a function. */
/* Blocking and waiting for the execution and get the return values. */
const uint32_t BUF_LEN = 256;
WasmEdge_Value Buf[BUF_LEN];
WasmEdge_Result Res = WasmEdge_AsyncGet(Async, Buf, BUF_LEN);
WasmEdge_AsyncDelete(Async);
</code></pre>
</li>
</ol>
<h3 id="configurations"><a class="header" href="#configurations">Configurations</a></h3>
<p>The configuration context, <code>WasmEdge_ConfigureContext</code>, manages the configurations for <code>Loader</code>, <code>Validator</code>, <code>Executor</code>, <code>VM</code>, and <code>Compiler</code>.
Developers can adjust the settings about the proposals, VM host pre-registrations (such as <code>WASI</code>), and AOT compiler options, and then apply the <code>Configure</code> context to create other runtime contexts.</p>
<ol>
<li>
<p>Proposals</p>
<p>WasmEdge supports turning on or off the WebAssembly proposals.
This configuration is effective in any contexts created with the <code>Configure</code> context.</p>
<pre><code class="language-c">enum WasmEdge_Proposal {
  WasmEdge_Proposal_ImportExportMutGlobals = 0,
  WasmEdge_Proposal_NonTrapFloatToIntConversions,
  WasmEdge_Proposal_SignExtensionOperators,
  WasmEdge_Proposal_MultiValue,
  WasmEdge_Proposal_BulkMemoryOperations,
  WasmEdge_Proposal_ReferenceTypes,
  WasmEdge_Proposal_SIMD,
  WasmEdge_Proposal_TailCall,
  WasmEdge_Proposal_MultiMemories,
  WasmEdge_Proposal_Annotations,
  WasmEdge_Proposal_Memory64,
  WasmEdge_Proposal_ExceptionHandling,
  WasmEdge_Proposal_Threads,
  WasmEdge_Proposal_FunctionReferences
};
</code></pre>
<p>Developers can add or remove the proposals into the <code>Configure</code> context.</p>
<pre><code class="language-c">/* 
 * By default, the following proposals have turned on initially:
 * * Import/Export of mutable globals
 * * Non-trapping float-to-int conversions
 * * Sign-extension operators
 * * Multi-value returns
 * * Bulk memory operations
 * * Reference types
 * * Fixed-width SIMD
 *
 * For the current WasmEdge version, the following proposals are supported
 * (turned of by default) additionally:
 * * Tail-call
 * * Multiple memories
 */
WasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();
WasmEdge_ConfigureAddProposal(ConfCxt, WasmEdge_Proposal_MultiMemories);
WasmEdge_ConfigureRemoveProposal(ConfCxt, WasmEdge_Proposal_ReferenceTypes);
bool IsBulkMem = WasmEdge_ConfigureHasProposal(ConfCxt, WasmEdge_Proposal_BulkMemoryOperations);
/* The `IsBulkMem` will be `TRUE`. */
WasmEdge_ConfigureDelete(ConfCxt);
</code></pre>
</li>
<li>
<p>Host registrations</p>
<p>This configuration is used for the <code>VM</code> context to turn on the <code>WASI</code> or <code>wasmedge_process</code> supports and only effective in <code>VM</code> contexts.</p>
<pre><code class="language-c">enum WasmEdge_HostRegistration {
  WasmEdge_HostRegistration_Wasi = 0,
  WasmEdge_HostRegistration_WasmEdge_Process
};
</code></pre>
<p>The details will be introduced in the <a href="embed/c/ref.html#preregistrations">preregistrations of VM context</a>.</p>
<pre><code class="language-c">WasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();
bool IsHostWasi = WasmEdge_ConfigureHasHostRegistration(ConfCxt, WasmEdge_HostRegistration_Wasi);
/* The `IsHostWasi` will be `FALSE`. */
WasmEdge_ConfigureAddHostRegistration(ConfCxt, WasmEdge_HostRegistration_Wasi);
IsHostWasi = WasmEdge_ConfigureHasHostRegistration(ConfCxt, WasmEdge_HostRegistration_Wasi);
/* The `IsHostWasi` will be `TRUE`. */
WasmEdge_ConfigureDelete(ConfCxt);
</code></pre>
</li>
<li>
<p>Maximum memory pages</p>
<p>Developers can limit the page size of memory instances by this configuration.
When growing the page size of memory instances in WASM execution and exceeding the limited size, the page growing will fail.
This configuration is only effective in the <code>Executor</code> and <code>VM</code> contexts.</p>
<pre><code class="language-c">WasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();
uint32_t PageSize = WasmEdge_ConfigureGetMaxMemoryPage(ConfCxt);
/* By default, the maximum memory page size is 65536. */
WasmEdge_ConfigureSetMaxMemoryPage(ConfCxt, 1024);
/* Limit the memory size of each memory instance with not larger than 1024 pages (64 MiB). */
PageSize = WasmEdge_ConfigureGetMaxMemoryPage(ConfCxt);
/* The `PageSize` will be 1024. */
WasmEdge_ConfigureDelete(ConfCxt);
</code></pre>
</li>
<li>
<p>AOT compiler options</p>
<p>The AOT compiler options configure the behavior about optimization level, output format, dump IR, and generic binary.</p>
<pre><code class="language-c">enum WasmEdge_CompilerOptimizationLevel {
  // Disable as many optimizations as possible.
  WasmEdge_CompilerOptimizationLevel_O0 = 0,
  // Optimize quickly without destroying debuggability.
  WasmEdge_CompilerOptimizationLevel_O1,
  // Optimize for fast execution as much as possible without triggering
  // significant incremental compile time or code size growth.
  WasmEdge_CompilerOptimizationLevel_O2,
  // Optimize for fast execution as much as possible.
  WasmEdge_CompilerOptimizationLevel_O3,
  // Optimize for small code size as much as possible without triggering
  // significant incremental compile time or execution time slowdowns.
  WasmEdge_CompilerOptimizationLevel_Os,
  // Optimize for small code size as much as possible.
  WasmEdge_CompilerOptimizationLevel_Oz
};

enum WasmEdge_CompilerOutputFormat {
  // Native dynamic library format.
  WasmEdge_CompilerOutputFormat_Native = 0,
  // WebAssembly with AOT compiled codes in custom section.
  WasmEdge_CompilerOutputFormat_Wasm
};
</code></pre>
<p>These configurations are only effective in <code>Compiler</code> contexts.</p>
<pre><code class="language-c">WasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();
/* By default, the optimization level is O3. */
WasmEdge_ConfigureCompilerSetOptimizationLevel(ConfCxt, WasmEdge_CompilerOptimizationLevel_O2);
/* By default, the output format is universal WASM. */
WasmEdge_ConfigureCompilerSetOutputFormat(ConfCxt, WasmEdge_CompilerOutputFormat_Native);
/* By default, the dump IR is `FALSE`. */
WasmEdge_ConfigureCompilerSetDumpIR(ConfCxt, TRUE);
/* By default, the generic binary is `FALSE`. */
WasmEdge_ConfigureCompilerSetGenericBinary(ConfCxt, TRUE);
/* By default, the interruptible is `FALSE`.
/* Set this option to `TRUE` to support the interruptible execution in AOT mode. */
WasmEdge_ConfigureCompilerSetInterruptible(ConfCxt, TRUE);
WasmEdge_ConfigureDelete(ConfCxt);
</code></pre>
</li>
<li>
<p>Statistics options</p>
<p>The statistics options configure the behavior about instruction counting, cost measuring, and time measuring in both runtime and AOT compiler.
These configurations are effective in <code>Compiler</code>, <code>VM</code>, and <code>Executor</code> contexts.</p>
<pre><code class="language-c">WasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();
/* By default, the intruction counting is `FALSE` when running a compiled-WASM or a pure-WASM. */
WasmEdge_ConfigureStatisticsSetInstructionCounting(ConfCxt, TRUE);
/* By default, the cost measurement is `FALSE` when running a compiled-WASM or a pure-WASM. */
WasmEdge_ConfigureStatisticsSetCostMeasuring(ConfCxt, TRUE);
/* By default, the time measurement is `FALSE` when running a compiled-WASM or a pure-WASM. */
WasmEdge_ConfigureStatisticsSetTimeMeasuring(ConfCxt, TRUE);
WasmEdge_ConfigureDelete(ConfCxt);
</code></pre>
</li>
</ol>
<h3 id="statistics"><a class="header" href="#statistics">Statistics</a></h3>
<p>The statistics context, <code>WasmEdge_StatisticsContext</code>, provides the instruction counter, cost summation, and cost limitation at runtime.</p>
<p>Before using statistics, the statistics configuration must be set. Otherwise, the return values of calling statistics are undefined behaviour.</p>
<ol>
<li>
<p>Instruction counter</p>
<p>The instruction counter can help developers to profile the performance of WASM running.
Developers can retrieve the <code>Statistics</code> context from the <code>VM</code> context, or create a new one for the <code>Executor</code> creation.
The details will be introduced in the next partitions.</p>
<pre><code class="language-c">WasmEdge_StatisticsContext *StatCxt = WasmEdge_StatisticsCreate();
/*
 * ...
 * After running the WASM functions with the `Statistics` context
 */
uint32_t Count = WasmEdge_StatisticsGetInstrCount(StatCxt);
double IPS = WasmEdge_StatisticsGetInstrPerSecond(StatCxt);
WasmEdge_StatisticsDelete(StatCxt);
</code></pre>
</li>
<li>
<p>Cost table</p>
<p>The cost table is to accumulate the cost of instructions with their weights.
Developers can set the cost table array (the indices are the byte code value of instructions, and the values are the cost of instructions) into the <code>Statistics</code> context.
If the cost limit value is set, the execution will return the <code>cost limit exceeded</code> error immediately when exceeds the cost limit in runtime.</p>
<pre><code class="language-c">WasmEdge_StatisticsContext *StatCxt = WasmEdge_StatisticsCreate();
uint64_t CostTable[16] = {
  0, 0,
  10, /* 0x02: Block */
  11, /* 0x03: Loop */
  12, /* 0x04: If */
  12, /* 0x05: Else */
  0, 0, 0, 0, 0, 0, 
  20, /* 0x0C: Br */
  21, /* 0x0D: Br_if */
  22, /* 0x0E: Br_table */
  0
};
/* Developers can set the costs of each instruction. The value not covered will be 0. */
WasmEdge_StatisticsSetCostTable(StatCxt, CostTable, 16);
WasmEdge_StatisticsSetCostLimit(StatCxt, 5000000);
/*
 * ...
 * After running the WASM functions with the `Statistics` context
 */
uint64_t Cost = WasmEdge_StatisticsGetTotalCost(StatCxt);
WasmEdge_StatisticsDelete(StatCxt);
</code></pre>
</li>
</ol>
<h2 id="wasmedge-vm"><a class="header" href="#wasmedge-vm">WasmEdge VM</a></h2>
<p>In this partition, we will introduce the functions of <code>WasmEdge_VMContext</code> object and show examples of executing WASM functions.</p>
<h3 id="wasm-execution-example-with-vm-context"><a class="header" href="#wasm-execution-example-with-vm-context">WASM Execution Example With VM Context</a></h3>
<p>The following shows the example of running the WASM for getting the Fibonacci.
This example uses the <a href="https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/tools/wasmedge/examples/fibonacci.wasm">fibonacci.wasm</a>, and the corresponding WAT file is at <a href="https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/tools/wasmedge/examples/fibonacci.wat">fibonacci.wat</a>.</p>
<pre><code class="language-wasm">(module
  (export &quot;fib&quot; (func $fib))
  (func $fib (param $n i32) (result i32)
    (if
      (i32.lt_s (get_local $n)(i32.const 2))
      (return (i32.const 1))
    )
    (return
      (i32.add
        (call $fib (i32.sub (get_local $n)(i32.const 2)))
        (call $fib (i32.sub (get_local $n)(i32.const 1)))
      )
    )
  )
)
</code></pre>
<ol>
<li>
<p>Run WASM functions rapidly</p>
<p>Assume that the WASM file <a href="https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/tools/wasmedge/examples/fibonacci.wasm"><code>fibonacci.wasm</code></a> is copied into the current directory, and the C file <code>test.c</code> is as following:</p>
<pre><code class="language-c">#include &lt;wasmedge/wasmedge.h&gt;
#include &lt;stdio.h&gt;
int main() {
  /* Create the configure context and add the WASI support. */
  /* This step is not necessary unless you need WASI support. */
  WasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();
  WasmEdge_ConfigureAddHostRegistration(ConfCxt, WasmEdge_HostRegistration_Wasi);
  /* The configure and store context to the VM creation can be NULL. */
  WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(ConfCxt, NULL);

  /* The parameters and returns arrays. */
  WasmEdge_Value Params[1] = { WasmEdge_ValueGenI32(5) };
  WasmEdge_Value Returns[1];
  /* Function name. */
  WasmEdge_String FuncName = WasmEdge_StringCreateByCString(&quot;fib&quot;);
  /* Run the WASM function from file. */
  WasmEdge_Result Res = WasmEdge_VMRunWasmFromFile(VMCxt, &quot;fibonacci.wasm&quot;, FuncName, Params, 1, Returns, 1);
  /* 
   * Developers can run the WASM binary from buffer with the `WasmEdge_VMRunWasmFromBuffer()` API,
   * or from `WasmEdge_ASTModuleContext` object with the `WasmEdge_VMRunWasmFromASTModule()` API.
   */

  if (WasmEdge_ResultOK(Res)) {
    printf(&quot;Get the result: %d\n&quot;, WasmEdge_ValueGetI32(Returns[0]));
  } else {
    printf(&quot;Error message: %s\n&quot;, WasmEdge_ResultGetMessage(Res));
  }

  /* Resources deallocations. */
  WasmEdge_VMDelete(VMCxt);
  WasmEdge_ConfigureDelete(ConfCxt);
  WasmEdge_StringDelete(FuncName);
  return 0;
}
</code></pre>
<p>Then you can compile and run: (the 5th Fibonacci number is 8 in 0-based index)</p>
<pre><code class="language-bash">$ gcc test.c -lwasmedge_c
$ ./a.out
Get the result: 8
</code></pre>
</li>
<li>
<p>Instantiate and run WASM functions manually</p>
<p>Besides the above example, developers can run the WASM functions step-by-step with <code>VM</code> context APIs:</p>
<pre><code class="language-c">#include &lt;wasmedge/wasmedge.h&gt;
#include &lt;stdio.h&gt;
int main() {
  /* Create the configure context and add the WASI support. */
  /* This step is not necessary unless you need the WASI support. */
  WasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();
  WasmEdge_ConfigureAddHostRegistration(ConfCxt, WasmEdge_HostRegistration_Wasi);
  /* The configure and store context to the VM creation can be NULL. */
  WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(ConfCxt, NULL);

  /* The parameters and returns arrays. */
  WasmEdge_Value Params[1] = { WasmEdge_ValueGenI32(10) };
  WasmEdge_Value Returns[1];
  /* Function name. */
  WasmEdge_String FuncName = WasmEdge_StringCreateByCString(&quot;fib&quot;);
  /* Result. */
  WasmEdge_Result Res;
  
  /* Step 1: Load WASM file. */
  Res = WasmEdge_VMLoadWasmFromFile(VMCxt, &quot;fibonacci.wasm&quot;);
  /* 
   * Developers can load the WASM binary from buffer with the `WasmEdge_VMLoadWasmFromBuffer()` API,
   * or from `WasmEdge_ASTModuleContext` object with the `WasmEdge_VMLoadWasmFromASTModule()` API.
   */
  if (!WasmEdge_ResultOK(Res)) {
    printf(&quot;Loading phase failed: %s\n&quot;, WasmEdge_ResultGetMessage(Res));
    return 1;
  }
  /* Step 2: Validate the WASM module. */
  Res = WasmEdge_VMValidate(VMCxt);
  if (!WasmEdge_ResultOK(Res)) {
    printf(&quot;Validation phase failed: %s\n&quot;, WasmEdge_ResultGetMessage(Res));
    return 1;
  }
  /* Step 3: Instantiate the WASM module. */
  Res = WasmEdge_VMInstantiate(VMCxt);
  /* 
   * Developers can load, validate, and instantiate another WASM module to replace the
   * instantiated one. In this case, the old module will be cleared, but the registered
   * modules are still kept.
   */
  if (!WasmEdge_ResultOK(Res)) {
    printf(&quot;Instantiation phase failed: %s\n&quot;, WasmEdge_ResultGetMessage(Res));
    return 1;
  }
  /* Step 4: Execute WASM functions. You can execute functions repeatedly after instantiation. */
  Res = WasmEdge_VMExecute(VMCxt, FuncName, Params, 1, Returns, 1);
  if (WasmEdge_ResultOK(Res)) {
    printf(&quot;Get the result: %d\n&quot;, WasmEdge_ValueGetI32(Returns[0]));
  } else {
    printf(&quot;Execution phase failed: %s\n&quot;, WasmEdge_ResultGetMessage(Res));
  }

  /* Resources deallocations. */
  WasmEdge_VMDelete(VMCxt);
  WasmEdge_ConfigureDelete(ConfCxt);
  WasmEdge_StringDelete(FuncName);
  return 0;
}
</code></pre>
<p>Then you can compile and run: (the 10th Fibonacci number is 89 in 0-based index)</p>
<pre><code class="language-bash">$ gcc test.c -lwasmedge_c
$ ./a.out
Get the result: 89
</code></pre>
<p>The following graph explains the status of the <code>VM</code> context.</p>
<pre><code class="language-text">                       |========================|
              |-------&gt;|      VM: Initiated     |
              |        |========================|
              |                    |
              |                 LoadWasm
              |                    |
              |                    v
              |        |========================|
              |--------|       VM: Loaded       |&lt;-------|
              |        |========================|        |
              |              |            ^              |
              |         Validate          |              |
          Cleanup            |          LoadWasm         |
              |              v            |            LoadWasm
              |        |========================|        |
              |--------|      VM: Validated     |        |
              |        |========================|        |
              |              |            ^              |
              |      Instantiate          |              |
              |              |          RegisterModule   |
              |              v            |              |
              |        |========================|        |
              |--------|    VM: Instantiated    |--------|
                       |========================|
                             |            ^
                             |            |
                             --------------
                Instantiate, Execute, ExecuteRegistered
</code></pre>
<p>The status of the <code>VM</code> context would be <code>Inited</code> when created.
After loading WASM successfully, the status will be <code>Loaded</code>.
After validating WASM successfully, the status will be <code>Validated</code>.
After instantiating WASM successfully, the status will be <code>Instantiated</code>, and developers can invoke functions.
Developers can register WASM or module instances in any status, but they should instantiate WASM again.
Developers can also load WASM in any status, and they should validate and instantiate the WASM module before function invocation.
When in the <code>Instantiated</code> status, developers can instantiate the WASM module again to reset the old WASM runtime structures.</p>
</li>
</ol>
<h3 id="vm-creations"><a class="header" href="#vm-creations">VM Creations</a></h3>
<p>The <code>VM</code> creation API accepts the <code>Configure</code> context and the <code>Store</code> context.
If developers only need the default settings, just pass <code>NULL</code> to the creation API.
The details of the <code>Store</code> context will be introduced in <a href="embed/c/ref.html#store">Store</a>.</p>
<pre><code class="language-c">WasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();
WasmEdge_StoreContext *StoreCxt = WasmEdge_StoreCreate();
WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(ConfCxt, StoreCxt);
/* The caller should guarantee the life cycle if the store context. */
WasmEdge_StatisticsContext *StatCxt = WasmEdge_VMGetStatisticsContext(VMCxt);
/* The VM context already contains the statistics context and can be retrieved by this API. */
/* 
 * Note that the retrieved store and statistics contexts from the VM contexts by VM APIs
 * should __NOT__ be destroyed and owned by the VM contexts.
 */
WasmEdge_VMDelete(VMCxt);
WasmEdge_StoreDelete(StoreCxt);
WasmEdge_ConfigureDelete(ConfCxt);
</code></pre>
<h3 id="preregistrations"><a class="header" href="#preregistrations">Preregistrations</a></h3>
<p>WasmEdge provides the following built-in pre-registrations.</p>
<ol>
<li>
<p><a href="https://github.com/WebAssembly/WASI">WASI (WebAssembly System Interface)</a></p>
<p>Developers can turn on the WASI support for VM in the <code>Configure</code> context.</p>
<pre><code class="language-c">WasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();
WasmEdge_ConfigureAddHostRegistration(ConfCxt, WasmEdge_HostRegistration_Wasi);
WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(ConfCxt, NULL);
/* The following API can retrieve the pre-registration module instances from the VM context. */
/* This API will return `NULL` if the corresponding pre-registration is not set into the configuration. */
WasmEdge_ModuleInstanceContext *WasiModule =
  WasmEdge_VMGetImportModuleContext(VMCxt, WasmEdge_HostRegistration_Wasi);
/* Initialize the WASI. */
WasmEdge_ModuleInstanceInitWASI(WasiModule, /* ... ignored */ );
WasmEdge_VMDelete(VMCxt);
WasmEdge_ConfigureDelete(ConfCxt);
</code></pre>
<p>And also can create the WASI module instance from API. The details will be introduced in the <a href="embed/c/ref.html#host-functions">Host Functions</a> and the <a href="embed/c/ref.html#host-module-registrations">Host Module Registrations</a>.</p>
</li>
<li>
<p><a href="https://crates.io/crates/wasmedge_process_interface">WasmEdge_Process</a></p>
<p>This pre-registration is for the process interface for WasmEdge on <code>Rust</code> sources.
After turning on this pre-registration, the VM will support the <code>wasmedge_process</code> host functions.</p>
<pre><code class="language-c">WasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();
WasmEdge_ConfigureAddHostRegistration(ConfCxt, WasmEdge_HostRegistration_WasmEdge_Process);
WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(ConfCxt, NULL);
/* The following API can retrieve the pre-registration module instances from the VM context. */
/* This API will return `NULL` if the corresponding pre-registration is not set into the configuration. */
WasmEdge_ModuleInstanceContext *ProcModule =
  WasmEdge_VMGetImportModuleContext(VMCxt, WasmEdge_HostRegistration_WasmEdge_Process);
/* Initialize the WasmEdge_Process. */
WasmEdge_ModuleInstanceInitWasmEdgeProcess(ProcModule, /* ... ignored */ );
WasmEdge_VMDelete(VMCxt);
WasmEdge_ConfigureDelete(ConfCxt);
</code></pre>
<p>And also can create the WasmEdge_Process module instance from API. The details will be introduced in the <a href="embed/c/ref.html#host-functions">Host Functions</a> and the <a href="embed/c/ref.html#host-module-registrations">Host Module Registrations</a>.</p>
</li>
</ol>
<h3 id="host-module-registrations"><a class="header" href="#host-module-registrations">Host Module Registrations</a></h3>
<p><a href="https://webassembly.github.io/spec/core/exec/runtime.html#syntax-hostfunc">Host functions</a> are functions outside WebAssembly and passed to WASM modules as imports.
In WasmEdge, the host functions are composed into host modules as <code>WasmEdge_ModuleInstanceContext</code> objects with module names.
Please refer to the <a href="embed/c/ref.html#host-functions">Host Functions in WasmEdge Runtime</a> for the details.
In this chapter, we show the example for registering the host modules into a <code>VM</code> context.</p>
<pre><code class="language-c">WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(NULL, NULL);
WasmEdge_ModuleInstanceContext *WasiModule =
  WasmEdge_ModuleInstanceCreateWASI( /* ... ignored ... */ );
/* You can also create and register the WASI host modules by this API. */
WasmEdge_Result Res = WasmEdge_VMRegisterModuleFromImport(VMCxt, WasiModule);
/* The result status should be checked. */

/* ... */

WasmEdge_ModuleInstanceDelete(WasiModule);
/* The created module instances should be deleted by the developers when the VM deallocation. */
WasmEdge_VMDelete(VMCxt);
</code></pre>
<h3 id="wasm-registrations-and-executions"><a class="header" href="#wasm-registrations-and-executions">WASM Registrations And Executions</a></h3>
<p>In WebAssembly, the instances in WASM modules can be exported and can be imported by other WASM modules.
WasmEdge VM provides APIs for developers to register and export any WASM modules, and execute the functions or host functions in the registered WASM modules.</p>
<ol>
<li>
<p>Register the WASM modules with exported module names</p>
<p>Unless the module instances have already contained the module names, every WASM module should be named uniquely when registering.
Assume that the WASM file <a href="https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/tools/wasmedge/examples/fibonacci.wasm"><code>fibonacci.wasm</code></a> is copied into the current directory.</p>
<pre><code class="language-c">WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(NULL, NULL);
WasmEdge_String ModName = WasmEdge_StringCreateByCString(&quot;mod&quot;);
WasmEdge_Result Res = WasmEdge_VMRegisterModuleFromFile(VMCxt, ModName, &quot;fibonacci.wasm&quot;);
/* 
 * Developers can register the WASM module from buffer with the `WasmEdge_VMRegisterModuleFromBuffer()` API,
 * or from `WasmEdge_ASTModuleContext` object with the `WasmEdge_VMRegisterModuleFromASTModule()` API.
 */
/* 
 * The result status should be checked.
 * The error will occur if the WASM module instantiation failed or the module name conflicts.
 */
WasmEdge_StringDelete(ModName);
WasmEdge_VMDelete(VMCxt);
</code></pre>
</li>
<li>
<p>Execute the functions in registered WASM modules</p>
<p>Assume that the C file <code>test.c</code> is as follows:</p>
<pre><code class="language-c">#include &lt;wasmedge/wasmedge.h&gt;
#include &lt;stdio.h&gt;
int main() {
  WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(NULL, NULL);

  /* The parameters and returns arrays. */
  WasmEdge_Value Params[1] = { WasmEdge_ValueGenI32(20) };
  WasmEdge_Value Returns[1];
  /* Names. */
  WasmEdge_String ModName = WasmEdge_StringCreateByCString(&quot;mod&quot;);
  WasmEdge_String FuncName = WasmEdge_StringCreateByCString(&quot;fib&quot;);
  /* Result. */
  WasmEdge_Result Res;

  /* Register the WASM module into VM. */
  Res = WasmEdge_VMRegisterModuleFromFile(VMCxt, ModName, &quot;fibonacci.wasm&quot;);
  /* 
  * Developers can register the WASM module from buffer with the `WasmEdge_VMRegisterModuleFromBuffer()` API,
  * or from `WasmEdge_ASTModuleContext` object with the `WasmEdge_VMRegisterModuleFromASTModule()` API.
  */
  if (!WasmEdge_ResultOK(Res)) {
    printf(&quot;WASM registration failed: %s\n&quot;, WasmEdge_ResultGetMessage(Res));
    return 1;
  }
  /* 
  * The function &quot;fib&quot; in the &quot;fibonacci.wasm&quot; was exported with the module name &quot;mod&quot;.
  * As the same as host functions, other modules can import the function `&quot;mod&quot; &quot;fib&quot;`.
  */

  /* 
  * Execute WASM functions in registered modules.
  * Unlike the execution of functions, the registered functions can be invoked without
  * `WasmEdge_VMInstantiate()` because the WASM module was instantiated when registering.
  * Developers can also invoke the host functions directly with this API.
  */
  Res = WasmEdge_VMExecuteRegistered(VMCxt, ModName, FuncName, Params, 1, Returns, 1);
  if (WasmEdge_ResultOK(Res)) {
    printf(&quot;Get the result: %d\n&quot;, WasmEdge_ValueGetI32(Returns[0]));
  } else {
    printf(&quot;Execution phase failed: %s\n&quot;, WasmEdge_ResultGetMessage(Res));
  }
  WasmEdge_StringDelete(ModName);
  WasmEdge_StringDelete(FuncName);
  WasmEdge_VMDelete(VMCxt);
  return 0;
}
</code></pre>
<p>Then you can compile and run: (the 20th Fibonacci number is 89 in 0-based index)</p>
<pre><code class="language-bash">$ gcc test.c -lwasmedge_c
$ ./a.out
Get the result: 10946
</code></pre>
</li>
</ol>
<h3 id="asynchronous-execution"><a class="header" href="#asynchronous-execution">Asynchronous Execution</a></h3>
<ol>
<li>
<p>Asynchronously run WASM functions rapidly</p>
<p>Assume that the WASM file <a href="https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/tools/wasmedge/examples/fibonacci.wasm"><code>fibonacci.wasm</code></a> is copied into the current directory, and the C file <code>test.c</code> is as following:</p>
<pre><code class="language-c">#include &lt;wasmedge/wasmedge.h&gt;
#include &lt;stdio.h&gt;
int main() {
  /* Create the VM context. */
  WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(NULL, NULL);

  /* The parameters and returns arrays. */
  WasmEdge_Value Params[1] = { WasmEdge_ValueGenI32(20) };
  WasmEdge_Value Returns[1];
  /* Function name. */
  WasmEdge_String FuncName = WasmEdge_StringCreateByCString(&quot;fib&quot;);
  /* Asynchronously run the WASM function from file and get the `WasmEdge_Async` object. */
  WasmEdge_Async *Async = WasmEdge_VMAsyncRunWasmFromFile(VMCxt, &quot;fibonacci.wasm&quot;, FuncName, Params, 1);
  /* 
   * Developers can run the WASM binary from buffer with the `WasmEdge_VMAsyncRunWasmFromBuffer()` API,
   * or from `WasmEdge_ASTModuleContext` object with the `WasmEdge_VMAsyncRunWasmFromASTModule()` API.
   */

  /* Wait for the execution. */
  WasmEdge_AsyncWait(Async);
  /*
   * Developers can also use the `WasmEdge_AsyncGetReturnsLength()` or `WasmEdge_AsyncGet()` APIs
   * to wait for the asynchronous execution. These APIs will wait until the execution finished.
   */

  /* Check the return values length. */
  uint32_t Arity = WasmEdge_AsyncGetReturnsLength(Async);
  /* The `Arity` should be 1. Developers can skip this step if they have known the return arity. */

  /* Get the result. */
  WasmEdge_Result Res = WasmEdge_AsyncGet(Async, Returns, Arity);

  if (WasmEdge_ResultOK(Res)) {
    printf(&quot;Get the result: %d\n&quot;, WasmEdge_ValueGetI32(Returns[0]));
  } else {
    printf(&quot;Error message: %s\n&quot;, WasmEdge_ResultGetMessage(Res));
  }

  /* Resources deallocations. */
  WasmEdge_AsyncDelete(Async);
  WasmEdge_VMDelete(VMCxt);
  WasmEdge_StringDelete(FuncName);
  return 0;
}
</code></pre>
<p>Then you can compile and run: (the 20th Fibonacci number is 10946 in 0-based index)</p>
<pre><code class="language-bash">$ gcc test.c -lwasmedge_c
$ ./a.out
Get the result: 10946
</code></pre>
</li>
<li>
<p>Instantiate and asynchronously run WASM functions manually</p>
<p>Besides the above example, developers can run the WASM functions step-by-step with <code>VM</code> context APIs:</p>
<pre><code class="language-c">#include &lt;wasmedge/wasmedge.h&gt;
#include &lt;stdio.h&gt;
int main() {
  /* Create the VM context. */
  WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(NULL, NULL);

  /* The parameters and returns arrays. */
  WasmEdge_Value Params[1] = { WasmEdge_ValueGenI32(25) };
  WasmEdge_Value Returns[1];
  /* Function name. */
  WasmEdge_String FuncName = WasmEdge_StringCreateByCString(&quot;fib&quot;);
  /* Result. */
  WasmEdge_Result Res;
  
  /* Step 1: Load WASM file. */
  Res = WasmEdge_VMLoadWasmFromFile(VMCxt, &quot;fibonacci.wasm&quot;);
  /* 
   * Developers can load the WASM binary from buffer with the `WasmEdge_VMLoadWasmFromBuffer()` API,
   * or from `WasmEdge_ASTModuleContext` object with the `WasmEdge_VMLoadWasmFromASTModule()` API.
   */
  if (!WasmEdge_ResultOK(Res)) {
    printf(&quot;Loading phase failed: %s\n&quot;, WasmEdge_ResultGetMessage(Res));
    return 1;
  }
  /* Step 2: Validate the WASM module. */
  Res = WasmEdge_VMValidate(VMCxt);
  if (!WasmEdge_ResultOK(Res)) {
    printf(&quot;Validation phase failed: %s\n&quot;, WasmEdge_ResultGetMessage(Res));
    return 1;
  }
  /* Step 3: Instantiate the WASM module. */
  Res = WasmEdge_VMInstantiate(VMCxt);
  /* 
   * Developers can load, validate, and instantiate another WASM module to replace the
   * instantiated one. In this case, the old module will be cleared, but the registered
   * modules are still kept.
   */
  if (!WasmEdge_ResultOK(Res)) {
    printf(&quot;Instantiation phase failed: %s\n&quot;, WasmEdge_ResultGetMessage(Res));
    return 1;
  }
  /* Step 4: Asynchronously execute the WASM function and get the `WasmEdge_Async` object. */
  WasmEdge_Async *Async = WasmEdge_VMAsyncExecute(VMCxt, FuncName, Params, 1);
  /* 
   * Developers can execute functions repeatedly after instantiation.
   * For invoking the registered functions, you can use the `WasmEdge_VMAsyncExecuteRegistered()` API.
   */

  /* Wait and check the return values length. */
  uint32_t Arity = WasmEdge_AsyncGetReturnsLength(Async);
  /* The `Arity` should be 1. Developers can skip this step if they have known the return arity. */

  /* Get the result. */
  Res = WasmEdge_AsyncGet(Async, Returns, Arity);
  if (WasmEdge_ResultOK(Res)) {
    printf(&quot;Get the result: %d\n&quot;, WasmEdge_ValueGetI32(Returns[0]));
  } else {
    printf(&quot;Execution phase failed: %s\n&quot;, WasmEdge_ResultGetMessage(Res));
  }

  /* Resources deallocations. */
  WasmEdge_AsyncDelete(Async);
  WasmEdge_VMDelete(VMCxt);
  WasmEdge_StringDelete(FuncName);
}
</code></pre>
<p>Then you can compile and run: (the 25th Fibonacci number is 121393 in 0-based index)</p>
<pre><code class="language-bash">$ gcc test.c -lwasmedge_c
$ ./a.out
Get the result: 121393
</code></pre>
</li>
</ol>
<h3 id="instance-tracing"><a class="header" href="#instance-tracing">Instance Tracing</a></h3>
<p>Sometimes the developers may have requirements to get the instances of the WASM runtime.
The <code>VM</code> context supplies the APIs to retrieve the instances.</p>
<ol>
<li>
<p>Store</p>
<p>If the <code>VM</code> context is created without assigning a <code>Store</code> context, the <code>VM</code> context will allocate and own a <code>Store</code> context.</p>
<pre><code class="language-c">WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(NULL, NULL);
WasmEdge_StoreContext *StoreCxt = WasmEdge_VMGetStoreContext(VMCxt);
/* The object should __NOT__ be deleted by `WasmEdge_StoreDelete()`. */
WasmEdge_VMDelete(VMCxt);
</code></pre>
<p>Developers can also create the <code>VM</code> context with a <code>Store</code> context.
In this case, developers should guarantee the life cycle of the <code>Store</code> context.
Please refer to the <a href="embed/c/ref.html#store">Store Contexts</a> for the details about the <code>Store</code> context APIs.</p>
<pre><code class="language-c">WasmEdge_StoreContext *StoreCxt = WasmEdge_StoreCreate();
WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(NULL, StoreCxt);
WasmEdge_StoreContext *StoreCxtMock = WasmEdge_VMGetStoreContext(VMCxt);
/* The `StoreCxt` and the `StoreCxtMock` are the same. */
WasmEdge_VMDelete(VMCxt);
WasmEdge_StoreDelete(StoreCxt);
</code></pre>
</li>
<li>
<p>List exported functions</p>
<p>After the WASM module instantiation, developers can use the <code>WasmEdge_VMExecute()</code> API to invoke the exported WASM functions. For this purpose, developers may need information about the exported WASM function list.
Please refer to the <a href="embed/c/ref.html#instances">Instances in runtime</a> for the details about the function types.
Assume that the WASM file <a href="https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/tools/wasmedge/examples/fibonacci.wasm"><code>fibonacci.wasm</code></a> is copied into the current directory, and the C file <code>test.c</code> is as following:</p>
<pre><code class="language-c">#include &lt;wasmedge/wasmedge.h&gt;
#include &lt;stdio.h&gt;
int main() {
  WasmEdge_StoreContext *StoreCxt = WasmEdge_StoreCreate();
  WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(NULL, StoreCxt);

  WasmEdge_VMLoadWasmFromFile(VMCxt, &quot;fibonacci.wasm&quot;);
  WasmEdge_VMValidate(VMCxt);
  WasmEdge_VMInstantiate(VMCxt);

  /* List the exported functions. */
  /* Get the number of exported functions. */
  uint32_t FuncNum = WasmEdge_VMGetFunctionListLength(VMCxt);
  /* Create the name buffers and the function type buffers. */
  const uint32_t BUF_LEN = 256;
  WasmEdge_String FuncNames[BUF_LEN];
  WasmEdge_FunctionTypeContext *FuncTypes[BUF_LEN];
  /* 
   * Get the export function list.
   * If the function list length is larger than the buffer length, the overflowed data will be discarded.
   * The `FuncNames` and `FuncTypes` can be NULL if developers don't need them.
   */
  uint32_t RealFuncNum = WasmEdge_VMGetFunctionList(VMCxt, FuncNames, FuncTypes, BUF_LEN);

  for (uint32_t I = 0; I &lt; RealFuncNum &amp;&amp; I &lt; BUF_LEN; I++) {
    char Buf[BUF_LEN];
    uint32_t Size = WasmEdge_StringCopy(FuncNames[I], Buf, sizeof(Buf));
    printf(&quot;Get exported function string length: %u, name: %s\n&quot;, Size, Buf);
    /* 
     * The function names should be __NOT__ destroyed.
     * The returned function type contexts should __NOT__ be destroyed.
     */
  }
  return 0;
}
</code></pre>
<p>Then you can compile and run: (the only exported function in <code>fibonacci.wasm</code> is <code>fib</code>)</p>
<pre><code class="language-bash">$ gcc test.c -lwasmedge_c
$ ./a.out
Get exported function string length: 3, name: fib
</code></pre>
<p>If developers want to get the exported function names in the registered WASM modules, please retrieve the <code>Store</code> context from the <code>VM</code> context and refer to the APIs of <a href="embed/c/ref.html#store">Store Contexts</a> to list the registered functions by the module name.</p>
</li>
<li>
<p>Get function types</p>
<p>The <code>VM</code> context provides APIs to find the function type by function name.
Please refer to the <a href="embed/c/ref.html#instances">Instances in runtime</a> for the details about the function types.</p>
<pre><code class="language-c">/* 
 * ...
 * Assume that a WASM module is instantiated in `VMCxt`.
 */
WasmEdge_String FuncName = WasmEdge_StringCreateByCString(&quot;fib&quot;);
const WasmEdge_FunctionTypeContext *FuncType = WasmEdge_VMGetFunctionType(VMCxt, FuncName);
/* 
 * Developers can get the function types of functions in the registered modules
 * via the `WasmEdge_VMGetFunctionTypeRegistered()` API with the module name.
 * If the function is not found, these APIs will return `NULL`.
 * The returned function type contexts should __NOT__ be destroyed.
 */
WasmEdge_StringDelete(FuncName);
</code></pre>
</li>
<li>
<p>Get the active module</p>
<p>After the WASM module instantiation, an anonymous module is instantiated and owned by the <code>VM</code> context.
Developers may need to retrieve it to get the instances beyond the module.
Then developers can use the <code>WasmEdge_VMGetActiveModule()</code> API to get that anonymous module instance.
Please refer to the <a href="embed/c/ref.html#instances">Module instance</a> for the details about the module instance APIs.</p>
<pre><code class="language-c">/* 
 * ...
 * Assume that a WASM module is instantiated in `VMCxt`.
 */
const WasmEdge_ModuleInstanceContext *ModCxt = WasmEdge_VMGetActiveModule(VMCxt);
/* 
 * If there's no WASM module instantiated, this API will return `NULL`.
 * The returned module instance context should __NOT__ be destroyed.
 */
</code></pre>
</li>
</ol>
<h2 id="wasmedge-runtime"><a class="header" href="#wasmedge-runtime">WasmEdge Runtime</a></h2>
<p>In this partition, we will introduce the objects of WasmEdge runtime manually.</p>
<h3 id="wasm-execution-example-step-by-step"><a class="header" href="#wasm-execution-example-step-by-step">WASM Execution Example Step-By-Step</a></h3>
<p>Besides the WASM execution through the <a href="embed/c/ref.html#wasmedge-vm"><code>VM</code> context</a>, developers can execute the WASM functions or instantiate WASM modules step-by-step with the <code>Loader</code>, <code>Validator</code>, <code>Executor</code>, and <code>Store</code> contexts.
Assume that the WASM file <a href="https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/tools/wasmedge/examples/fibonacci.wasm"><code>fibonacci.wasm</code></a> is copied into the current directory, and the C file <code>test.c</code> is as following:</p>
<pre><code class="language-c">#include &lt;wasmedge/wasmedge.h&gt;
#include &lt;stdio.h&gt;
int main() {
  /* Create the configure context. This step is not necessary because we didn't adjust any setting. */
  WasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();
  /* Create the statistics context. This step is not necessary if the statistics in runtime is not needed. */
  WasmEdge_StatisticsContext *StatCxt = WasmEdge_StatisticsCreate();
  /* Create the store context. The store context is the object to link the modules for imports and exports. */
  WasmEdge_StoreContext *StoreCxt = WasmEdge_StoreCreate();
  /* Result. */
  WasmEdge_Result Res;

  /* Create the loader context. The configure context can be NULL. */
  WasmEdge_LoaderContext *LoadCxt = WasmEdge_LoaderCreate(ConfCxt);
  /* Create the validator context. The configure context can be NULL. */
  WasmEdge_ValidatorContext *ValidCxt = WasmEdge_ValidatorCreate(ConfCxt);
  /* Create the executor context. The configure context and the statistics context can be NULL. */
  WasmEdge_ExecutorContext *ExecCxt = WasmEdge_ExecutorCreate(ConfCxt, StatCxt);

  /* Load the WASM file or the compiled-WASM file and convert into the AST module context. */
  WasmEdge_ASTModuleContext *ASTCxt = NULL;
  Res = WasmEdge_LoaderParseFromFile(LoadCxt, &amp;ASTCxt, &quot;fibonacci.wasm&quot;);
  if (!WasmEdge_ResultOK(Res)) {
    printf(&quot;Loading phase failed: %s\n&quot;, WasmEdge_ResultGetMessage(Res));
    return 1;
  }
  /* Validate the WASM module. */
  Res = WasmEdge_ValidatorValidate(ValidCxt, ASTCxt);
  if (!WasmEdge_ResultOK(Res)) {
    printf(&quot;Validation phase failed: %s\n&quot;, WasmEdge_ResultGetMessage(Res));
    return 1;
  }
  /* Instantiate the WASM module into store context. */
  WasmEdge_ModuleInstanceContext *ModCxt = NULL;
  Res = WasmEdge_ExecutorInstantiate(ExecCxt, &amp;ModCxt, StoreCxt, ASTCxt);
  if (!WasmEdge_ResultOK(Res)) {
    printf(&quot;Instantiation phase failed: %s\n&quot;, WasmEdge_ResultGetMessage(Res));
    return 1;
  }

  /* Try to list the exported functions of the instantiated WASM module. */
  uint32_t FuncNum = WasmEdge_ModuleInstanceListFunctionLength(ModCxt);
  /* Create the name buffers. */
  const uint32_t BUF_LEN = 256;
  WasmEdge_String FuncNames[BUF_LEN];
  /* If the list length is larger than the buffer length, the overflowed data will be discarded. */
  uint32_t RealFuncNum = WasmEdge_ModuleInstanceListFunction(ModCxt, FuncNames, BUF_LEN);
  for (uint32_t I = 0; I &lt; RealFuncNum &amp;&amp; I &lt; BUF_LEN; I++) {
    char Buf[BUF_LEN];
    uint32_t Size = WasmEdge_StringCopy(FuncNames[I], Buf, sizeof(Buf));
    printf(&quot;Get exported function string length: %u, name: %s\n&quot;, Size, Buf);
    /* The function names should __NOT__ be destroyed. */
  }

  /* The parameters and returns arrays. */
  WasmEdge_Value Params[1] = { WasmEdge_ValueGenI32(18) };
  WasmEdge_Value Returns[1];
  /* Function name. */
  WasmEdge_String FuncName = WasmEdge_StringCreateByCString(&quot;fib&quot;);
  /* Find the exported function by function name. */
  WasmEdge_FunctionInstanceContext *FuncCxt = WasmEdge_ModuleInstanceFindFunction(ModCxt, FuncName);
  if (FuncCxt == NULL) {
    printf(&quot;Function `fib` not found.\n&quot;);
    return 1;
  }
  /* Invoke the WASM fnction. */
  Res = WasmEdge_ExecutorInvoke(ExecCxt, FuncCxt, Params, 1, Returns, 1);
  if (WasmEdge_ResultOK(Res)) {
    printf(&quot;Get the result: %d\n&quot;, WasmEdge_ValueGetI32(Returns[0]));
  } else {
    printf(&quot;Execution phase failed: %s\n&quot;, WasmEdge_ResultGetMessage(Res));
  }

  /* Resources deallocations. */
  WasmEdge_StringDelete(FuncName);
  WasmEdge_ASTModuleDelete(ASTCxt);
  WasmEdge_ModuleInstanceDelete(ModCxt);
  WasmEdge_LoaderDelete(LoadCxt);
  WasmEdge_ValidatorDelete(ValidCxt);
  WasmEdge_ExecutorDelete(ExecCxt);
  WasmEdge_ConfigureDelete(ConfCxt);
  WasmEdge_StoreDelete(StoreCxt);
  WasmEdge_StatisticsDelete(StatCxt);
  return 0;
}
</code></pre>
<p>Then you can compile and run: (the 18th Fibonacci number is 4181 in 0-based index)</p>
<pre><code class="language-bash">$ gcc test.c -lwasmedge_c
$ ./a.out
Get exported function string length: 3, name: fib
Get the result: 4181
</code></pre>
<h3 id="loader"><a class="header" href="#loader">Loader</a></h3>
<p>The <code>Loader</code> context loads the WASM binary from files or buffers.
Both the WASM and the compiled-WASM from the <a href="embed/c/ref.html#wasmedge-aot-compiler">WasmEdge AOT Compiler</a> are supported.</p>
<pre><code class="language-c">uint32_t Buf[4096];
/* ... Read the WASM code to the buffer. */
uint32_t FileSize = ...;
/* The `FileSize` is the length of the WASM code. */

/* Developers can adjust settings in the configure context. */
WasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();
/* Create the loader context. The configure context can be NULL. */
WasmEdge_LoaderContext *LoadCxt = WasmEdge_LoaderCreate(ConfCxt);

WasmEdge_ASTModuleContext *ASTCxt = NULL;
WasmEdge_Result Res;

/* Load WASM or compiled-WASM from the file. */
Res = WasmEdge_LoaderParseFromFile(LoadCxt, &amp;ASTCxt, &quot;fibonacci.wasm&quot;);
if (!WasmEdge_ResultOK(Res)) {
  printf(&quot;Loading phase failed: %s\n&quot;, WasmEdge_ResultGetMessage(Res));
}
/* The output AST module context should be destroyed. */
WasmEdge_ASTModuleDelete(ASTCxt);

/* Load WASM or compiled-WASM from the buffer. */
Res = WasmEdge_LoaderParseFromBuffer(LoadCxt, &amp;ASTCxt, Buf, FileSize);
if (!WasmEdge_ResultOK(Res)) {
  printf(&quot;Loading phase failed: %s\n&quot;, WasmEdge_ResultGetMessage(Res));
}
/* The output AST module context should be destroyed. */
WasmEdge_ASTModuleDelete(ASTCxt);

WasmEdge_LoaderDelete(LoadCxt);
WasmEdge_ConfigureDelete(ConfCxt);
</code></pre>
<h3 id="validator"><a class="header" href="#validator">Validator</a></h3>
<p>The <code>Validator</code> context can validate the WASM module.
Every WASM module should be validated before instantiation.</p>
<pre><code class="language-c">/* 
 * ...
 * Assume that the `ASTCxt` is the output AST module context from the loader context.
 * Assume that the `ConfCxt` is the configure context.
 */
/* Create the validator context. The configure context can be NULL. */
WasmEdge_ValidatorContext *ValidCxt = WasmEdge_ValidatorCreate(ConfCxt);
WasmEdge_Result Res = WasmEdge_ValidatorValidate(ValidCxt, ASTCxt);
if (!WasmEdge_ResultOK(Res)) {
  printf(&quot;Validation phase failed: %s\n&quot;, WasmEdge_ResultGetMessage(Res));
}
WasmEdge_ValidatorDelete(ValidCxt);
</code></pre>
<h3 id="executor"><a class="header" href="#executor">Executor</a></h3>
<p>The <code>Executor</code> context is the executor for both WASM and compiled-WASM.
This object should work base on the <code>Store</code> context. For the details of the <code>Store</code> context, please refer to the <a href="embed/c/ref.html#store">next chapter</a>.</p>
<ol>
<li>
<p>Instantiate and register an <code>AST module</code> as a named <code>Module</code> instance</p>
<p>As the same of <a href="embed/c/ref.html#host-module-registrations">registering host modules</a> or <a href="embed/c/ref.html#wasm-registrations-and-executions">importing WASM modules</a> in <code>VM</code> contexts, developers can instantiate and register an <code>AST module</code> contexts into the <code>Store</code> context as a named <code>Module</code> instance by the <code>Executor</code> APIs.
After the registration, the result <code>Module</code> instance is exported with the given module name and can be linked when instantiating another module.
For the details about the <code>Module</code> instances APIs, please refer to the <a href="embed/c/ref.html#instances">Instances</a>.</p>
<pre><code class="language-c">/* 
* ...
* Assume that the `ASTCxt` is the output AST module context from the loader context
* and has passed the validation.
* Assume that the `ConfCxt` is the configure context.
*/
/* Create the statistics context. This step is not necessary. */
WasmEdge_StatisticsContext *StatCxt = WasmEdge_StatisticsCreate();
/* Create the executor context. The configure and the statistics contexts can be NULL. */
WasmEdge_ExecutorContext *ExecCxt = WasmEdge_ExecutorCreate(ConfCxt, StatCxt);
/* Create the store context. The store context is the object to link the modules for imports and exports. */
WasmEdge_StoreContext *StoreCxt = WasmEdge_StoreCreate();
/* Result. */
WasmEdge_Result Res;

WasmEdge_String ModName = WasmEdge_StringCreateByCString(&quot;mod&quot;);
/* The output module instance. */
WasmEdge_ModuleInstanceContext *ModCxt = NULL;
/* Register the WASM module into the store with the export module name &quot;mod&quot;. */
Res = WasmEdge_ExecutorRegister(ExecCxt, &amp;ModCxt, StoreCxt, ASTCxt, ModName);
if (!WasmEdge_ResultOK(Res)) {
  printf(&quot;WASM registration failed: %s\n&quot;, WasmEdge_ResultGetMessage(Res));
  return -1;
}
WasmEdge_StringDelete(ModName);

/* ... */

/* After the execution, the resources should be released. */
WasmEdge_ExecutorDelete(ExecCxt);
WasmEdge_StatisticsDelete(StatCxt);
WasmEdge_StoreDelete(StoreCxt);
WasmEdge_ModuleInstanceDelete(ModCxt);
</code></pre>
</li>
<li>
<p>Register an existing <code>Module</code> instance and export the module name</p>
<p>Besides instantiating and registering an <code>AST module</code> contexts, developers can register an existing <code>Module</code> instance into the store with exporting the module name (which is in the <code>Module</code> instance already).
This case occurs when developers create a <code>Module</code> instance for the host functions and want to register it for linking.
For the details about the construction of host functions in <code>Module</code> instances, please refer to the <a href="embed/c/ref.html#host-functions">Host Functions</a>.</p>
<pre><code class="language-c">/* 
* ...
* Assume that the `ASTCxt` is the output AST module context from the loader context
* and has passed the validation.
* Assume that the `ConfCxt` is the configure context.
*/
/* Create the statistics context. This step is not necessary. */
WasmEdge_StatisticsContext *StatCxt = WasmEdge_StatisticsCreate();
/* Create the executor context. The configure and the statistics contexts can be NULL. */
WasmEdge_ExecutorContext *ExecCxt = WasmEdge_ExecutorCreate(ConfCxt, StatCxt);
/* Create the store context. The store context is the object to link the modules for imports and exports. */
WasmEdge_StoreContext *StoreCxt = WasmEdge_StoreCreate();
/* Result. */
WasmEdge_Result Res;

/* Create a module instance for host functions. */
WasmEdge_String ModName = WasmEdge_StringCreateByCString(&quot;host-module&quot;);
WasmEdge_ModuleInstanceContext *HostModCxt = WasmEdge_ModuleInstanceCreate(ModName);
WasmEdge_StringDelete(ModName);
/*
 * ...
 * Create and add the host functions, tables, memories, and globals into the module instance.
 */

/* Register the module instance into store with the export module. */
/* The export module name is in the module instance already. */
Res = WasmEdge_ExecutorRegisterImport(ExecCxt, StoreCxt, HostModCxt);
if (!WasmEdge_ResultOK(Res)) {
  printf(&quot;WASM registration failed: %s\n&quot;, WasmEdge_ResultGetMessage(Res));
  return -1;
}

/* ... */

/* After the execution, the resources should be released. */
WasmEdge_ExecutorDelete(ExecCxt);
WasmEdge_StatisticsDelete(StatCxt);
WasmEdge_StoreDelete(StoreCxt);
WasmEdge_ModuleInstanceDelete(ModCxt);
</code></pre>
</li>
<li>
<p>Instantiate an <code>AST module</code> to an anonymous <code>Module</code> instance</p>
<p>WASM or compiled-WASM modules should be instantiated before the function invocation.
Before instantiating a WASM module, please check the <a href="https://webassembly.github.io/spec/core/syntax/modules.html#syntax-import">import section</a> for ensuring the imports are registered into the <code>Store</code> context for linking.</p>
<pre><code class="language-c">/* 
* ...
* Assume that the `ASTCxt` is the output AST module context from the loader context
* and has passed the validation.
* Assume that the `ConfCxt` is the configure context.
*/
/* Create the statistics context. This step is not necessary. */
WasmEdge_StatisticsContext *StatCxt = WasmEdge_StatisticsCreate();
/* Create the executor context. The configure and the statistics contexts can be NULL. */
WasmEdge_ExecutorContext *ExecCxt = WasmEdge_ExecutorCreate(ConfCxt, StatCxt);
/* Create the store context. The store context is the object to link the modules for imports and exports. */
WasmEdge_StoreContext *StoreCxt = WasmEdge_StoreCreate();

/* The output module instance. */
WasmEdge_ModuleInstanceContext *ModCxt = NULL;
/* Instantiate the WASM module. */
WasmEdge_Result Res = WasmEdge_ExecutorInstantiate(ExecCxt, &amp;ModCxt, StoreCxt, ASTCxt);
if (!WasmEdge_ResultOK(Res)) {
  printf(&quot;WASM instantiation failed: %s\n&quot;, WasmEdge_ResultGetMessage(Res));
  return -1;
}

/* ... */

/* After the execution, the resources should be released. */
WasmEdge_ExecutorDelete(ExecCxt);
WasmEdge_StatisticsDelete(StatCxt);
WasmEdge_StoreDelete(StoreCxt);
WasmEdge_ModuleInstanceDelete(ModCxt);
</code></pre>
</li>
<li>
<p>Invoke functions</p>
<p>After registering or instantiating and get the result <code>Module</code> instance, developers can retrieve the exported <code>Function</code> instances from the <code>Module</code> instance for invocation.
For the details about the <code>Module</code> instances APIs, please refer to the <a href="embed/c/ref.html#instances">Instances</a>.
Please refer to the <a href="embed/c/ref.html#wasm-execution-example-step-by-step">example above</a> for the <code>Function</code> instance invocation with the <code>WasmEdge_ExecutorInvoke()</code> API.</p>
</li>
</ol>
<h3 id="ast-module"><a class="header" href="#ast-module">AST Module</a></h3>
<p>The <code>AST Module</code> context presents the loaded structure from a WASM file or buffer. Developer will get this object after loading a WASM file or buffer from <a href="embed/c/ref.html#loader">Loader</a>.
Before instantiation, developers can also query the imports and exports of an <code>AST Module</code> context.</p>
<pre><code class="language-c">WasmEdge_ASTModuleContext *ASTCxt = ...;
/* Assume that a WASM is loaded into an AST module context. */

/* Create the import type context buffers. */
const uint32_t BUF_LEN = 256;
const WasmEdge_ImportTypeContext *ImpTypes[BUF_LEN];
uint32_t ImportNum = WasmEdge_ASTModuleListImportsLength(ASTCxt);
/* If the list length is larger than the buffer length, the overflowed data will be discarded. */
uint32_t RealImportNum = WasmEdge_ASTModuleListImports(ASTCxt, ImpTypes, BUF_LEN);
for (uint32_t I = 0; I &lt; RealImportNum &amp;&amp; I &lt; BUF_LEN; I++) {
  /* Working with the import type `ImpTypes[I]` ... */
}

/* Create the export type context buffers. */
const WasmEdge_ExportTypeContext *ExpTypes[BUF_LEN];
uint32_t ExportNum = WasmEdge_ASTModuleListExportsLength(ASTCxt);
/* If the list length is larger than the buffer length, the overflowed data will be discarded. */
uint32_t RealExportNum = WasmEdge_ASTModuleListExports(ASTCxt, ExpTypes, BUF_LEN);
for (uint32_t I = 0; I &lt; RealExportNum &amp;&amp; I &lt; BUF_LEN; I++) {
  /* Working with the export type `ExpTypes[I]` ... */
}

WasmEdge_ASTModuleDelete(ASTCxt);
/* After deletion of `ASTCxt`, all data queried from the `ASTCxt` should not be accessed. */
</code></pre>
<h3 id="store"><a class="header" href="#store">Store</a></h3>
<p><a href="https://webassembly.github.io/spec/core/exec/runtime.html#store">Store</a> is the runtime structure for the representation of all global state that can be manipulated by WebAssembly programs.
The <code>Store</code> context in WasmEdge is an object to provide the instance exporting and importing when instantiating WASM modules.
Developers can retrieve the named modules from the <code>Store</code> context.</p>
<pre><code class="language-c">WasmEdge_StoreContext *StoreCxt = WasmEdge_StoreCreate();

/*
 * ...
 * Register a WASM module via the executor context.
 */

/* Try to list the registered WASM modules. */
uint32_t ModNum = WasmEdge_StoreListModuleLength(StoreCxt);
/* Create the name buffers. */
const uint32_t BUF_LEN = 256;
WasmEdge_String ModNames[BUF_LEN];
/* If the list length is larger than the buffer length, the overflowed data will be discarded. */
uint32_t RealModNum = WasmEdge_StoreListModule(StoreCxt, ModNames, BUF_LEN);
for (uint32_t I = 0; I &lt; RealModNum &amp;&amp; I &lt; BUF_LEN; I++) {
  /* Working with the module name `ModNames[I]` ... */
  /* The module names should __NOT__ be destroyed. */
}

/* Find named module by name. */
WasmEdge_String ModName = WasmEdge_StringCreateByCString(&quot;module&quot;);
const WasmEdge_ModuleInstanceContext *ModCxt = WasmEdge_StoreFindModule(StoreCxt, ModName);
/* If the module with name not found, the `ModCxt` will be NULL. */
WasmEdge_StringDelete(ModName);
</code></pre>
<h3 id="instances"><a class="header" href="#instances">Instances</a></h3>
<p>The instances are the runtime structures of WASM. Developers can retrieve the <code>Module</code> instances from the <code>Store</code> contexts, and retrieve the other instances from the <code>Module</code> instances.
A single instance can be allocated by its creation function. Developers can construct instances into an <code>Module</code> instance for registration. Please refer to the <a href="embed/c/ref.html#host-functions">Host Functions</a> for details.
The instances created by their creation functions should be destroyed by developers, EXCEPT they are added into an <code>Module</code> instance.</p>
<ol>
<li>
<p>Module instance</p>
<p>After instantiating or registering an <code>AST module</code> context, developers will get a <code>Module</code> instance as the result, and have the responsibility to destroy it when not in use.
A <code>Module</code> instance can also be created for the host module. Please refer to the <a href="embed/c/ref.html#host-functions">host function</a> for the details.
<code>Module</code> instance provides APIs to list and find the exported instances in the module.</p>
<pre><code class="language-c">/*
* ...
* Instantiate a WASM module via the executor context and get the `ModCxt` as the output module instance.
*/

/* Try to list the exported instance of the instantiated WASM module. */
/* Take the function instances for example here. */
uint32_t FuncNum = WasmEdge_ModuleInstanceListFunctionLength(ModCxt);
/* Create the name buffers. */
const uint32_t BUF_LEN = 256;
WasmEdge_String FuncNames[BUF_LEN];
/* If the list length is larger than the buffer length, the overflowed data will be discarded. */
uint32_t RealFuncNum = WasmEdge_ModuleInstanceListFunction(ModCxt, FuncNames, BUF_LEN);
for (uint32_t I = 0; I &lt; RealFuncNum &amp;&amp; I &lt; BUF_LEN; I++) {
  /* Working with the function name `FuncNames[I]` ... */
  /* The function names should __NOT__ be destroyed. */
}

/* Try to find the exported instance of the instantiated WASM module. */
/* Take the function instances for example here. */
/* Function name. */
WasmEdge_String FuncName = WasmEdge_StringCreateByCString(&quot;fib&quot;);
WasmEdge_FunctionInstanceContext *FuncCxt = WasmEdge_ModuleInstanceFindFunction(ModCxt, FuncName);
/* `FuncCxt` will be `NULL` if the function not found. */
/* The returned instance is owned by the module instance context and should __NOT__ be destroyed. */
WasmEdge_StringDelete(FuncName);
</code></pre>
</li>
<li>
<p>Function instance</p>
<p><a href="https://webassembly.github.io/spec/core/exec/runtime.html#syntax-hostfunc">Host functions</a> are functions outside WebAssembly and passed to WASM modules as imports.
In WasmEdge, developers can create the <code>Function</code> contexts for host functions and add them into an <code>Import Object</code> context for registering into a <code>VM</code> or a <code>Store</code>.
For both host functions and the functions get from <code>Store</code>, developers can retrieve the <code>Function Type</code> from the <code>Function</code> contexts.
For the details of the <code>Host Function</code> guide, please refer to the <a href="embed/c/ref.html#host-functions">next chapter</a>.</p>
<pre><code class="language-c">/* Retrieve the function instance from the store context. */
WasmEdge_FunctionInstanceContext *FuncCxt = ...;
WasmEdge_FunctionTypeContext *FuncTypeCxt = WasmEdge_FunctionInstanceGetFunctionType(FuncCxt);
/* The `FuncTypeCxt` is owned by the `FuncCxt` and should __NOT__ be destroyed. */
</code></pre>
</li>
<li>
<p>Table instance</p>
<p>In WasmEdge, developers can create the <code>Table</code> contexts and add them into an <code>Import Object</code> context for registering into a <code>VM</code> or a <code>Store</code>.
The <code>Table</code> contexts supply APIs to control the data in table instances.</p>
<pre><code class="language-c">WasmEdge_Limit TabLimit = {.HasMax = true, .Min = 10, .Max = 20};
/* Create the table type with limit and the `FuncRef` element type. */
WasmEdge_TableTypeContext *TabTypeCxt = WasmEdge_TableTypeCreate(WasmEdge_RefType_FuncRef, TabLimit);
/* Create the table instance with table type. */
WasmEdge_TableInstanceContext *HostTable = WasmEdge_TableInstanceCreate(TabTypeCxt);
/* Delete the table type. */
WasmEdge_TableTypeDelete(TabTypeCxt);
WasmEdge_Result Res;
WasmEdge_Value Data;

TabTypeCxt = WasmEdge_TableInstanceGetTableType(HostTable);
/* The `TabTypeCxt` got from table instance is owned by the `HostTable` and should __NOT__ be destroyed. */
enum WasmEdge_RefType RefType = WasmEdge_TableTypeGetRefType(TabTypeCxt);
/* `RefType` will be `WasmEdge_RefType_FuncRef`. */
Data = WasmEdge_ValueGenFuncRef(5);
Res = WasmEdge_TableInstanceSetData(HostTable, Data, 3);
/* Set the function index 5 to the table[3]. */
/*
 * This will get an &quot;out of bounds table access&quot; error
 * because the position (13) is out of the table size (10):
 *   Res = WasmEdge_TableInstanceSetData(HostTable, Data, 13);
 */
Res = WasmEdge_TableInstanceGetData(HostTable, &amp;Data, 3);
/* Get the FuncRef value of the table[3]. */
/*
 * This will get an &quot;out of bounds table access&quot; error
 * because the position (13) is out of the table size (10):
 *   Res = WasmEdge_TableInstanceGetData(HostTable, &amp;Data, 13);
 */

uint32_t Size = WasmEdge_TableInstanceGetSize(HostTable);
/* `Size` will be 10. */
Res = WasmEdge_TableInstanceGrow(HostTable, 6);
/* Grow the table size of 6, the table size will be 16. */
/*
 * This will get an &quot;out of bounds table access&quot; error because
 * the size (16 + 6) will reach the table limit(20):
 *   Res = WasmEdge_TableInstanceGrow(HostTable, 6);
 */

WasmEdge_TableInstanceDelete(HostTable);
</code></pre>
</li>
<li>
<p>Memory instance</p>
<p>In WasmEdge, developers can create the <code>Memory</code> contexts and add them into an <code>Import Object</code> context for registering into a <code>VM</code> or a <code>Store</code>.
The <code>Memory</code> contexts supply APIs to control the data in memory instances.</p>
<pre><code class="language-c">WasmEdge_Limit MemLimit = {.HasMax = true, .Min = 1, .Max = 5};
/* Create the memory type with limit. The memory page size is 64KiB. */
WasmEdge_MemoryTypeContext *MemTypeCxt = WasmEdge_MemoryTypeCreate(MemLimit);
/* Create the memory instance with memory type. */
WasmEdge_MemoryInstanceContext *HostMemory = WasmEdge_MemoryInstanceCreate(MemTypeCxt);
/* Delete the memory type. */
WasmEdge_MemoryTypeDelete(MemTypeCxt);
WasmEdge_Result Res;
uint8_t Buf[256];

Buf[0] = 0xAA;
Buf[1] = 0xBB;
Buf[2] = 0xCC;
Res = WasmEdge_MemoryInstanceSetData(HostMemory, Buf, 0x1000, 3);
/* Set the data[0:2] to the memory[4096:4098]. */
/*
 * This will get an &quot;out of bounds memory access&quot; error
 * because [65535:65537] is out of 1 page size (65536):
 *   Res = WasmEdge_MemoryInstanceSetData(HostMemory, Buf, 0xFFFF, 3);
 */
Buf[0] = 0;
Buf[1] = 0;
Buf[2] = 0;
Res = WasmEdge_MemoryInstanceGetData(HostMemory, Buf, 0x1000, 3);
/* Get the memory[4096:4098]. Buf[0:2] will be `{0xAA, 0xBB, 0xCC}`. */
/*
 * This will get an &quot;out of bounds memory access&quot; error
 * because [65535:65537] is out of 1 page size (65536):
 *   Res = WasmEdge_MemoryInstanceSetData(HostMemory, Buf, 0xFFFF, 3);
 */

uint32_t PageSize = WasmEdge_MemoryInstanceGetPageSize(HostMemory);
/* `PageSize` will be 1. */
Res = WasmEdge_MemoryInstanceGrowPage(HostMemory, 2);
/* Grow the page size of 2, the page size of the memory instance will be 3. */
/*
 * This will get an &quot;out of bounds memory access&quot; error because
 * the page size (3 + 3) will reach the memory limit(5):
 *   Res = WasmEdge_MemoryInstanceGrowPage(HostMemory, 3);
 */

WasmEdge_MemoryInstanceDelete(HostMemory);
</code></pre>
</li>
<li>
<p>Global instance</p>
<p>In WasmEdge, developers can create the <code>Global</code> contexts and add them into an <code>Import Object</code> context for registering into a <code>VM</code> or a <code>Store</code>.
The <code>Global</code> contexts supply APIs to control the value in global instances.</p>
<pre><code class="language-c">WasmEdge_Value Val = WasmEdge_ValueGenI64(1000);
/* Create the global type with value type and mutation. */
WasmEdge_GlobalTypeContext *GlobTypeCxt = WasmEdge_GlobalTypeCreate(WasmEdge_ValType_I64, WasmEdge_Mutability_Var);
/* Create the global instance with value and global type. */
WasmEdge_GlobalInstanceContext *HostGlobal = WasmEdge_GlobalInstanceCreate(GlobTypeCxt, Val);
/* Delete the global type. */
WasmEdge_GlobalTypeDelete(GlobTypeCxt);
WasmEdge_Result Res;

GlobTypeCxt = WasmEdge_GlobalInstanceGetGlobalType(HostGlobal);
/* The `GlobTypeCxt` got from global instance is owned by the `HostGlobal` and should __NOT__ be destroyed. */
enum WasmEdge_ValType ValType = WasmEdge_GlobalTypeGetValType(GlobTypeCxt);
/* `ValType` will be `WasmEdge_ValType_I64`. */
enum WasmEdge_Mutability ValMut = WasmEdge_GlobalTypeGetMutability(GlobTypeCxt);
/* `ValMut` will be `WasmEdge_Mutability_Var`. */

WasmEdge_GlobalInstanceSetValue(HostGlobal, WasmEdge_ValueGenI64(888));
/* 
 * Set the value u64(888) to the global.
 * This function will do nothing if the value type mismatched or
 * the global mutability is `WasmEdge_Mutability_Const`.
 */
WasmEdge_Value GlobVal = WasmEdge_GlobalInstanceGetValue(HostGlobal);
/* Get the value (888 now) of the global context. */

WasmEdge_GlobalInstanceDelete(HostGlobal);
</code></pre>
</li>
</ol>
<h3 id="host-functions"><a class="header" href="#host-functions">Host Functions</a></h3>
<p><a href="https://webassembly.github.io/spec/core/exec/runtime.html#syntax-hostfunc">Host functions</a> are functions outside WebAssembly and passed to WASM modules as imports.
In WasmEdge, developers can create the <code>Function</code>, <code>Memory</code>, <code>Table</code>, and <code>Global</code> contexts and add them into an <code>Module</code> instance context for registering into a <code>VM</code> or a <code>Store</code>.</p>
<ol>
<li>
<p>Host function allocation</p>
<p>Developers can define C functions with the following function signature as the host function body:</p>
<pre><code class="language-c">typedef WasmEdge_Result (*WasmEdge_HostFunc_t)(
  void *Data,
  WasmEdge_MemoryInstanceContext *MemCxt,
  const WasmEdge_Value *Params,
  WasmEdge_Value *Returns);
</code></pre>
<p>The example of an <code>add</code> host function to add 2 <code>i32</code> values:</p>
<pre><code class="language-c">WasmEdge_Result Add(void *, WasmEdge_MemoryInstanceContext *,
                    const WasmEdge_Value *In, WasmEdge_Value *Out) {
  /*
  * Params: {i32, i32}
  * Returns: {i32}
  * Developers should take care about the function type.
  */ 
  /* Retrieve the value 1. */
  int32_t Val1 = WasmEdge_ValueGetI32(In[0]);
  /* Retrieve the value 2. */
  int32_t Val2 = WasmEdge_ValueGetI32(In[1]);
  /* Output value 1 is Val1 + Val2. */
  Out[0] = WasmEdge_ValueGenI32(Val1 + Val2);
  /* Return the status of success. */
  return WasmEdge_Result_Success;
}
</code></pre>
<p>Then developers can create <code>Function</code> context with the host function body and the function type:</p>
<pre><code class="language-c">enum WasmEdge_ValType ParamList[2] = { WasmEdge_ValType_I32, WasmEdge_ValType_I32 };
enum WasmEdge_ValType ReturnList[1] = { WasmEdge_ValType_I32 };
/* Create a function type: {i32, i32} -&gt; {i32}. */
HostFType = WasmEdge_FunctionTypeCreate(ParamList, 2, ReturnList, 1);
/* 
 * Create a function context with the function type and host function body.
 * The `Cost` parameter can be 0 if developers do not need the cost measuring.
 */
WasmEdge_FunctionInstanceContext *HostFunc = WasmEdge_FunctionInstanceCreate(HostFType, Add, NULL, 0);
/*
 * The third parameter is the pointer to the additional data.
 * Developers should guarantee the life cycle of the data, and it can be
 * `NULL` if the external data is not needed.
 */

/* If the function instance is not added into a module instance context, it should be deleted. */
WasmEdge_FunctionInstanceDelete(HostFunc);
</code></pre>
</li>
<li>
<p>Construct a module instance with host instances</p>
<p>Besides creating a <code>Module</code> instance by registering or instantiating a WASM module, developers can create a <code>Module</code> instance with a module name and add the <code>Function</code>, <code>Memory</code>, <code>Table</code>, and <code>Global</code> instances into it with their exporting names.</p>
<pre><code class="language-c">/* Host function body definition. */
WasmEdge_Result Add(void *Data, WasmEdge_MemoryInstanceContext *MemCxt,
                    const WasmEdge_Value *In, WasmEdge_Value *Out) {
  int32_t Val1 = WasmEdge_ValueGetI32(In[0]);
  int32_t Val2 = WasmEdge_ValueGetI32(In[1]);
  Out[0] = WasmEdge_ValueGenI32(Val1 + Val2);
  return WasmEdge_Result_Success;
}

/* Create a module instance. */
WasmEdge_String ExportName = WasmEdge_StringCreateByCString(&quot;module&quot;);
WasmEdge_ModuleInstanceContext *HostModCxt = WasmEdge_ModuleInstanceCreate(ExportName);
WasmEdge_StringDelete(ExportName);

/* Create and add a function instance into the module instance. */
enum WasmEdge_ValType ParamList[2] = { WasmEdge_ValType_I32, WasmEdge_ValType_I32 };
enum WasmEdge_ValType ReturnList[1] = { WasmEdge_ValType_I32 };
WasmEdge_FunctionTypeContext *HostFType = 
  WasmEdge_FunctionTypeCreate(ParamList, 2, ReturnList, 1);
WasmEdge_FunctionInstanceContext *HostFunc =
  WasmEdge_FunctionInstanceCreate(HostFType, Add, NULL, 0);
/*
 * The third parameter is the pointer to the additional data object.
 * Developers should guarantee the life cycle of the data, and it can be
 * `NULL` if the external data is not needed.
 */
WasmEdge_FunctionTypeDelete(HostFType);
WasmEdge_String FuncName = WasmEdge_StringCreateByCString(&quot;add&quot;);
WasmEdge_ModuleInstanceAddFunction(HostModCxt, FuncName, HostFunc);
WasmEdge_StringDelete(FuncName);

/* Create and add a table instance into the module instance. */
WasmEdge_Limit TableLimit = {.HasMax = true, .Min = 10, .Max = 20};
WasmEdge_TableTypeContext *HostTType = 
  WasmEdge_TableTypeCreate(WasmEdge_RefType_FuncRef, TableLimit);
WasmEdge_TableInstanceContext *HostTable = WasmEdge_TableInstanceCreate(HostTType);
WasmEdge_TableTypeDelete(HostTType);
WasmEdge_String TableName = WasmEdge_StringCreateByCString(&quot;table&quot;);
WasmEdge_ModuleInstanceAddTable(HostModCxt, TableName, HostTable);
WasmEdge_StringDelete(TableName);

/* Create and add a memory instance into the module instance. */
WasmEdge_Limit MemoryLimit = {.HasMax = true, .Min = 1, .Max = 2};
WasmEdge_MemoryTypeContext *HostMType = WasmEdge_MemoryTypeCreate(MemoryLimit);
WasmEdge_MemoryInstanceContext *HostMemory = WasmEdge_MemoryInstanceCreate(HostMType);
WasmEdge_MemoryTypeDelete(HostMType);
WasmEdge_String MemoryName = WasmEdge_StringCreateByCString(&quot;memory&quot;);
WasmEdge_ModuleInstanceAddMemory(HostModCxt, MemoryName, HostMemory);
WasmEdge_StringDelete(MemoryName);

/* Create and add a global instance into the module instance. */
WasmEdge_GlobalTypeContext *HostGType =
  WasmEdge_GlobalTypeCreate(WasmEdge_ValType_I32, WasmEdge_Mutability_Var);
WasmEdge_GlobalInstanceContext *HostGlobal =
  WasmEdge_GlobalInstanceCreate(HostGType, WasmEdge_ValueGenI32(666));
WasmEdge_GlobalTypeDelete(HostGType);
WasmEdge_String GlobalName = WasmEdge_StringCreateByCString(&quot;global&quot;);
WasmEdge_ModuleInstanceAddGlobal(HostModCxt, GlobalName, HostGlobal);
WasmEdge_StringDelete(GlobalName);

/*
 * The module instance should be deleted.
 * Developers should __NOT__ destroy the instances added into the module instance contexts.
 */
WasmEdge_ModuleInstanceDelete(HostModCxt);
</code></pre>
</li>
<li>
<p>Specified module instance</p>
<p><code>WasmEdge_ModuleInstanceCreateWASI()</code> API can create and initialize the <code>WASI</code> module instance.
<code>WasmEdge_ModuleInstanceCreateWasmEdgeProcess()</code> API can create and initialize the <code>wasmedge_process</code> module instance.
Developers can create these module instance contexts and register them into the <code>Store</code> or <code>VM</code> contexts rather than adjust the settings in the <code>Configure</code> contexts.</p>
<pre><code class="language-c">WasmEdge_ModuleInstanceContext *WasiModCxt = WasmEdge_ModuleInstanceCreateWASI( /* ... ignored */ );
WasmEdge_ModuleInstanceContext *ProcModCxt = WasmEdge_ModuleInstanceCreateWasmEdgeProcess( /* ... ignored */ );
WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(NULL, NULL);
/* Register the WASI and WasmEdge_Process into the VM context. */
WasmEdge_VMRegisterModuleFromImport(VMCxt, WasiModCxt);
WasmEdge_VMRegisterModuleFromImport(VMCxt, ProcModCxt);
/* Get the WASI exit code. */
uint32_t ExitCode = WasmEdge_ModuleInstanceWASIGetExitCode(WasiModCxt);
/*
 * The `ExitCode` will be EXIT_SUCCESS if the execution has no error.
 * Otherwise, it will return with the related exit code.
 */
WasmEdge_VMDelete(VMCxt);
/* The module instances should be deleted. */
WasmEdge_ModuleInstanceDelete(WasiModCxt);
WasmEdge_ModuleInstanceDelete(ProcModCxt);
</code></pre>
</li>
<li>
<p>Example</p>
<p>Assume that a simple WASM from the WAT as following:</p>
<pre><code class="language-wasm">(module
  (type $t0 (func (param i32 i32) (result i32)))
  (import &quot;extern&quot; &quot;func-add&quot; (func $f-add (type $t0)))
  (func (export &quot;addTwo&quot;) (param i32 i32) (result i32)
    local.get 0
    local.get 1
    call $f-add)
)
</code></pre>
<p>And the <code>test.c</code> as following:</p>
<pre><code class="language-c">#include &lt;wasmedge/wasmedge.h&gt;
#include &lt;stdio.h&gt;

/* Host function body definition. */
WasmEdge_Result Add(void *Data, WasmEdge_MemoryInstanceContext *MemCxt,
                    const WasmEdge_Value *In, WasmEdge_Value *Out) {
  int32_t Val1 = WasmEdge_ValueGetI32(In[0]);
  int32_t Val2 = WasmEdge_ValueGetI32(In[1]);
  printf(&quot;Host function \&quot;Add\&quot;: %d + %d\n&quot;, Val1, Val2);
  Out[0] = WasmEdge_ValueGenI32(Val1 + Val2);
  return WasmEdge_Result_Success;
}

int main() {
  /* Create the VM context. */
  WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(NULL, NULL);

  /* The WASM module buffer. */
  uint8_t WASM[] = {
    /* WASM header */
    0x00, 0x61, 0x73, 0x6D, 0x01, 0x00, 0x00, 0x00,
    /* Type section */
    0x01, 0x07, 0x01,
    /* function type {i32, i32} -&gt; {i32} */
    0x60, 0x02, 0x7F, 0x7F, 0x01, 0x7F,
    /* Import section */
    0x02, 0x13, 0x01,
    /* module name: &quot;extern&quot; */
    0x06, 0x65, 0x78, 0x74, 0x65, 0x72, 0x6E,
    /* extern name: &quot;func-add&quot; */
    0x08, 0x66, 0x75, 0x6E, 0x63, 0x2D, 0x61, 0x64, 0x64,
    /* import desc: func 0 */
    0x00, 0x00,
    /* Function section */
    0x03, 0x02, 0x01, 0x00,
    /* Export section */
    0x07, 0x0A, 0x01,
    /* export name: &quot;addTwo&quot; */
    0x06, 0x61, 0x64, 0x64, 0x54, 0x77, 0x6F,
    /* export desc: func 0 */
    0x00, 0x01,
    /* Code section */
    0x0A, 0x0A, 0x01,
    /* code body */
    0x08, 0x00, 0x20, 0x00, 0x20, 0x01, 0x10, 0x00, 0x0B
  };

  /* Create the module instance. */
  WasmEdge_String ExportName = WasmEdge_StringCreateByCString(&quot;extern&quot;);
  WasmEdge_ModuleInstanceContext *HostModCxt = WasmEdge_ModuleInstanceCreate(ExportName);
  enum WasmEdge_ValType ParamList[2] = { WasmEdge_ValType_I32, WasmEdge_ValType_I32 };
  enum WasmEdge_ValType ReturnList[1] = { WasmEdge_ValType_I32 };
  WasmEdge_FunctionTypeContext *HostFType = WasmEdge_FunctionTypeCreate(ParamList, 2, ReturnList, 1);
  WasmEdge_FunctionInstanceContext *HostFunc = WasmEdge_FunctionInstanceCreate(HostFType, Add, NULL, 0);
  WasmEdge_FunctionTypeDelete(HostFType);
  WasmEdge_String HostFuncName = WasmEdge_StringCreateByCString(&quot;func-add&quot;);
  WasmEdge_ModuleInstanceAddFunction(HostModCxt, HostFuncName, HostFunc);
  WasmEdge_StringDelete(HostFuncName);

  WasmEdge_VMRegisterModuleFromImport(VMCxt, HostModCxt);

  /* The parameters and returns arrays. */
  WasmEdge_Value Params[2] = { WasmEdge_ValueGenI32(1234), WasmEdge_ValueGenI32(5678) };
  WasmEdge_Value Returns[1];
  /* Function name. */
  WasmEdge_String FuncName = WasmEdge_StringCreateByCString(&quot;addTwo&quot;);
  /* Run the WASM function from file. */
  WasmEdge_Result Res = WasmEdge_VMRunWasmFromBuffer(
    VMCxt, WASM, sizeof(WASM), FuncName, Params, 2, Returns, 1);

  if (WasmEdge_ResultOK(Res)) {
    printf(&quot;Get the result: %d\n&quot;, WasmEdge_ValueGetI32(Returns[0]));
  } else {
    printf(&quot;Error message: %s\n&quot;, WasmEdge_ResultGetMessage(Res));
  }

  /* Resources deallocations. */
  WasmEdge_VMDelete(VMCxt);
  WasmEdge_StringDelete(FuncName);
  WasmEdge_ModuleInstanceDelete(HostModCxt);
  return 0;
}
</code></pre>
<p>Then you can compile and run: (the result of 1234 + 5678 is 6912)</p>
<pre><code class="language-bash">$ gcc test.c -lwasmedge_c
$ ./a.out
Host function &quot;Add&quot;: 1234 + 5678
Get the result: 6912
</code></pre>
</li>
<li>
<p>Host Data Example</p>
<p>Developers can set a external data object to the <code>Function</code> context, and access to the object in the function body.
Assume that a simple WASM from the WAT as following:</p>
<pre><code class="language-wasm">(module
  (type $t0 (func (param i32 i32) (result i32)))
  (import &quot;extern&quot; &quot;func-add&quot; (func $f-add (type $t0)))
  (func (export &quot;addTwo&quot;) (param i32 i32) (result i32)
    local.get 0
    local.get 1
    call $f-add)
)
</code></pre>
<p>And the <code>test.c</code> as following:</p>
<pre><code class="language-c">#include &lt;wasmedge/wasmedge.h&gt;
#include &lt;stdio.h&gt;

/* Host function body definition. */
WasmEdge_Result Add(void *Data, WasmEdge_MemoryInstanceContext *MemCxt,
                    const WasmEdge_Value *In, WasmEdge_Value *Out) {
  int32_t Val1 = WasmEdge_ValueGetI32(In[0]);
  int32_t Val2 = WasmEdge_ValueGetI32(In[1]);
  printf(&quot;Host function \&quot;Add\&quot;: %d + %d\n&quot;, Val1, Val2);
  Out[0] = WasmEdge_ValueGenI32(Val1 + Val2);
  /* Also set the result to the data. */
  int32_t *DataPtr = (int32_t *)Data;
  *DataPtr = Val1 + Val2;
  return WasmEdge_Result_Success;
}

int main() {
  /* Create the VM context. */
  WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(NULL, NULL);

  /* The WASM module buffer. */
  uint8_t WASM[] = {
    /* WASM header */
    0x00, 0x61, 0x73, 0x6D, 0x01, 0x00, 0x00, 0x00,
    /* Type section */
    0x01, 0x07, 0x01,
    /* function type {i32, i32} -&gt; {i32} */
    0x60, 0x02, 0x7F, 0x7F, 0x01, 0x7F,
    /* Import section */
    0x02, 0x13, 0x01,
    /* module name: &quot;extern&quot; */
    0x06, 0x65, 0x78, 0x74, 0x65, 0x72, 0x6E,
    /* extern name: &quot;func-add&quot; */
    0x08, 0x66, 0x75, 0x6E, 0x63, 0x2D, 0x61, 0x64, 0x64,
    /* import desc: func 0 */
    0x00, 0x00,
    /* Function section */
    0x03, 0x02, 0x01, 0x00,
    /* Export section */
    0x07, 0x0A, 0x01,
    /* export name: &quot;addTwo&quot; */
    0x06, 0x61, 0x64, 0x64, 0x54, 0x77, 0x6F,
    /* export desc: func 0 */
    0x00, 0x01,
    /* Code section */
    0x0A, 0x0A, 0x01,
    /* code body */
    0x08, 0x00, 0x20, 0x00, 0x20, 0x01, 0x10, 0x00, 0x0B
  };

  /* The external data object: an integer. */
  int32_t Data;

  /* Create the module instance. */
  WasmEdge_String ExportName = WasmEdge_StringCreateByCString(&quot;extern&quot;);
  WasmEdge_ModuleInstanceContext *HostModCxt = WasmEdge_ModuleInstanceCreate(ExportName);
  enum WasmEdge_ValType ParamList[2] = { WasmEdge_ValType_I32, WasmEdge_ValType_I32 };
  enum WasmEdge_ValType ReturnList[1] = { WasmEdge_ValType_I32 };
  WasmEdge_FunctionTypeContext *HostFType = WasmEdge_FunctionTypeCreate(ParamList, 2, ReturnList, 1);
  WasmEdge_FunctionInstanceContext *HostFunc = WasmEdge_FunctionInstanceCreate(HostFType, Add, &amp;Data, 0);
  WasmEdge_FunctionTypeDelete(HostFType);
  WasmEdge_String HostFuncName = WasmEdge_StringCreateByCString(&quot;func-add&quot;);
  WasmEdge_ModuleInstanceAddFunction(HostModCxt, HostFuncName, HostFunc);
  WasmEdge_StringDelete(HostFuncName);

  WasmEdge_VMRegisterModuleFromImport(VMCxt, HostModCxt);

  /* The parameters and returns arrays. */
  WasmEdge_Value Params[2] = { WasmEdge_ValueGenI32(1234), WasmEdge_ValueGenI32(5678) };
  WasmEdge_Value Returns[1];
  /* Function name. */
  WasmEdge_String FuncName = WasmEdge_StringCreateByCString(&quot;addTwo&quot;);
  /* Run the WASM function from file. */
  WasmEdge_Result Res = WasmEdge_VMRunWasmFromBuffer(
    VMCxt, WASM, sizeof(WASM), FuncName, Params, 2, Returns, 1);

  if (WasmEdge_ResultOK(Res)) {
    printf(&quot;Get the result: %d\n&quot;, WasmEdge_ValueGetI32(Returns[0]));
  } else {
    printf(&quot;Error message: %s\n&quot;, WasmEdge_ResultGetMessage(Res));
  }
  printf(&quot;Data value: %d\n&quot;, Data);

  /* Resources deallocations. */
  WasmEdge_VMDelete(VMCxt);
  WasmEdge_StringDelete(FuncName);
  WasmEdge_ModuleInstanceDelete(HostModCxt);
  return 0;
}
</code></pre>
<p>Then you can compile and run: (the result of 1234 + 5678 is 6912)</p>
<pre><code class="language-bash">$ gcc test.c -lwasmedge_c
$ ./a.out
Host function &quot;Add&quot;: 1234 + 5678
Get the result: 6912
Data value: 6912
</code></pre>
</li>
</ol>
<h2 id="wasmedge-aot-compiler"><a class="header" href="#wasmedge-aot-compiler">WasmEdge AOT Compiler</a></h2>
<p>In this partition, we will introduce the WasmEdge AOT compiler and the options.</p>
<p>WasmEdge runs the WASM files in interpreter mode, and WasmEdge also supports the AOT (ahead-of-time) mode running without modifying any code.
The WasmEdge AOT (ahead-of-time) compiler compiles the WASM files for running in AOT mode which is much faster than interpreter mode. Developers can compile the WASM files into the compiled-WASM files in shared library format for universal WASM format for the AOT mode execution.</p>
<h3 id="compilation-example"><a class="header" href="#compilation-example">Compilation Example</a></h3>
<p>Assume that the WASM file <a href="https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/tools/wasmedge/examples/fibonacci.wasm"><code>fibonacci.wasm</code></a> is copied into the current directory, and the C file <code>test.c</code> is as following:</p>
<pre><code class="language-c">#include &lt;wasmedge/wasmedge.h&gt;
#include &lt;stdio.h&gt;
int main() {
  /* Create the configure context. */
  WasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();
  /* ... Adjust settings in the configure context. */
  /* Result. */
  WasmEdge_Result Res;

  /* Create the compiler context. The configure context can be NULL. */
  WasmEdge_CompilerContext *CompilerCxt = WasmEdge_CompilerCreate(ConfCxt);
  /* Compile the WASM file with input and output paths. */
  Res = WasmEdge_CompilerCompile(CompilerCxt, &quot;fibonacci.wasm&quot;, &quot;fibonacci.wasm.so&quot;);
  if (!WasmEdge_ResultOK(Res)) {
      printf(&quot;Compilation failed: %s\n&quot;, WasmEdge_ResultGetMessage(Res));
      return 1;
  }

  WasmEdge_CompilerDelete(CompilerCxt);
  WasmEdge_ConfigureDelete(ConfCxt);
  return 0;
}
</code></pre>
<p>Then you can compile and run (the output file is &quot;fibonacci.wasm.so&quot;):</p>
<pre><code class="language-bash">$ gcc test.c -lwasmedge_c
$ ./a.out
[2021-07-02 11:08:08.651] [info] compile start
[2021-07-02 11:08:08.653] [info] verify start
[2021-07-02 11:08:08.653] [info] optimize start
[2021-07-02 11:08:08.670] [info] codegen start
[2021-07-02 11:08:08.706] [info] compile done
</code></pre>
<h3 id="compiler-options"><a class="header" href="#compiler-options">Compiler Options</a></h3>
<p>Developers can set options for AOT compilers such as optimization level and output format:</p>
<pre><code class="language-c">/// AOT compiler optimization level enumeration.
enum WasmEdge_CompilerOptimizationLevel {
  /// Disable as many optimizations as possible.
  WasmEdge_CompilerOptimizationLevel_O0 = 0,
  /// Optimize quickly without destroying debuggability.
  WasmEdge_CompilerOptimizationLevel_O1,
  /// Optimize for fast execution as much as possible without triggering
  /// significant incremental compile time or code size growth.
  WasmEdge_CompilerOptimizationLevel_O2,
  /// Optimize for fast execution as much as possible.
  WasmEdge_CompilerOptimizationLevel_O3,
  /// Optimize for small code size as much as possible without triggering
  /// significant incremental compile time or execution time slowdowns.
  WasmEdge_CompilerOptimizationLevel_Os,
  /// Optimize for small code size as much as possible.
  WasmEdge_CompilerOptimizationLevel_Oz
};

/// AOT compiler output binary format enumeration.
enum WasmEdge_CompilerOutputFormat {
  /// Native dynamic library format.
  WasmEdge_CompilerOutputFormat_Native = 0,
  /// WebAssembly with AOT compiled codes in custom sections.
  WasmEdge_CompilerOutputFormat_Wasm
};
</code></pre>
<p>Please refer to the <a href="embed/c/ref.html#configurations">AOT compiler options configuration</a> for details.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="wasmedge-go-sdk"><a class="header" href="#wasmedge-go-sdk">WasmEdge Go SDK</a></h1>
<p>The followings are the guides to working with the WasmEdge Go API. You can embed the WasmEdge into your go application through the WasmEdge Go API.</p>
<h2 id="getting-started-2"><a class="header" href="#getting-started-2">Getting Started</a></h2>
<p>The WasmEdge-go requires golang version &gt;= 1.15. Please check your golang version before installation. You can <a href="https://golang.org/dl/">download golang here</a>.</p>
<pre><code class="language-bash">$ go version
go version go1.16.5 linux/amd64
</code></pre>
<p>Meantime, please make sure you have installed <a href="embed/../start/install.html">the WasmEdge shared library</a> with the same <code>WasmEdge-go</code> release version.</p>
<pre><code class="language-bash">wget -qO- https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/utils/install.sh | bash -s -- -v 0.9.1
</code></pre>
<p>If you need the <code>TensorFlow</code> or <code>Image</code> extension for <code>WasmEdge-go</code>, please install the <code>WasmEdge</code> with extensions:</p>
<pre><code class="language-bash">wget -qO- https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/utils/install.sh | bash -s -- -v 0.9.1 -e tensorflow,image
</code></pre>
<p>Noticed that the <code>TensorFlow</code> and <code>Image</code> extensions are only for the <code>Linux</code> platforms.</p>
<p>Install the <code>WasmEdge-go</code> package and build in your Go project directory:</p>
<pre><code class="language-bash">go get github.com/second-state/WasmEdge-go/wasmedge@v0.9.1
go build
</code></pre>
<h2 id="wasmedge-go-extensions"><a class="header" href="#wasmedge-go-extensions">WasmEdge-go Extensions</a></h2>
<p>By default, the <code>WasmEdge-go</code> only turns on the basic runtime.</p>
<p><code>WasmEdge-go</code> has the following extensions:</p>
<ul>
<li>
<p>TensorFlow</p>
<ul>
<li>
<p>This extension supports the host functions in <a href="https://github.com/second-state/WasmEdge-tensorflow">WasmEdge-tensorflow</a>.</p>
</li>
<li>
<p>To install the <code>tensorflow</code> extension, please use the <code>-e tensorflow</code> flag in the WasmEdge installer command.</p>
</li>
<li>
<p>For using this extension, the tag <code>tensorflow</code> when building is required:</p>
<pre><code class="language-bash">go build -tags tensorflow
</code></pre>
</li>
</ul>
</li>
<li>
<p>Image</p>
<ul>
<li>
<p>This extension supports the host functions in <a href="https://github.com/second-state/WasmEdge-image">WasmEdge-image</a>.</p>
</li>
<li>
<p>To install the <code>image</code> extension, please use the <code>-e image</code> flag in the WasmEdge installer command.</p>
</li>
<li>
<p>For using this extension, the tag <code>image</code> when building is required:</p>
<pre><code class="language-bash">go build -tags image
</code></pre>
</li>
</ul>
</li>
</ul>
<p>You can also turn on the multiple extensions when building:</p>
<pre><code class="language-bash">go build -tags image,tensorflow
</code></pre>
<p>For examples, please refer to the <a href="https://github.com/second-state/WasmEdge-go-examples/">example repository</a>.</p>
<h3 id="wasmedge-aot-compiler-in-go"><a class="header" href="#wasmedge-aot-compiler-in-go">WasmEdge AOT Compiler in Go</a></h3>
<p>The <a href="https://github.com/second-state/WasmEdge-go-examples/tree/master/go_WasmAOT">go_WasmAOT example</a> demonstrates how to compile a WASM file into a native binary (AOT compile) from within a Go application.</p>
<h2 id="examples-1"><a class="header" href="#examples-1">Examples</a></h2>
<ul>
<li><a href="embed/go/app.html">Embed a standalone Wasm app</a></li>
<li><a href="embed/go/function.html">Embed a Wasm function</a></li>
<li><a href="embed/go/memory.html">Pass complex parameters to Wasm functions</a></li>
<li><a href="embed/go/tensorflow.html">Embed a Tensorflow inference function</a></li>
<li><a href="embed/go/bindgen.html">Embed a bindgen function</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="embed-a-standalone-wasm-app"><a class="header" href="#embed-a-standalone-wasm-app">Embed a standalone WASM app</a></h1>
<p>The WasmEdge Go SDK can <a href="https://github.com/second-state/WasmEdge-go-examples/tree/master/go_ReadFile">embed standalone WebAssembly applications</a> — ie a Rust application with a <code>main()</code> function compiled into WebAssembly.</p>
<p>Our <a href="https://github.com/second-state/WasmEdge-go-examples/tree/master/go_ReadFile/rust_readfile">demo Rust application</a> reads from a file. Note that the WebAssembly program's input and output data are now passed by the STDIN and STDOUT.</p>
<pre><pre class="playground"><code class="language-rust">use std::env;
use std::fs::File;
use std::io::{self, BufRead};

fn main() {
  // Get the argv.
  let args: Vec&lt;String&gt; = env::args().collect();
  if args.len() &lt;= 1 {
    println!(&quot;Rust: ERROR - No input file name.&quot;);
    return;
  }

  // Open the file.
  println!(&quot;Rust: Opening input file \&quot;{}\&quot;...&quot;, args[1]);
  let file = match File::open(&amp;args[1]) {
    Err(why) =&gt; {
      println!(&quot;Rust: ERROR - Open file \&quot;{}\&quot; failed: {}&quot;, args[1], why);
      return;
    },
    Ok(file) =&gt; file,
  };

  // Read lines.
  let reader = io::BufReader::new(file);
  let mut texts:Vec&lt;String&gt; = Vec::new();
  for line in reader.lines() {
    if let Ok(text) = line {
      texts.push(text);
    }
  }
  println!(&quot;Rust: Read input file \&quot;{}\&quot; succeeded.&quot;, args[1]);

  // Get stdin to print lines.
  println!(&quot;Rust: Please input the line number to print the line of file.&quot;);
  let stdin = io::stdin();
  for line in stdin.lock().lines() {
    let input = line.unwrap();
    match input.parse::&lt;usize&gt;() {
      Ok(n) =&gt; if n &gt; 0 &amp;&amp; n &lt;= texts.len() {
        println!(&quot;{}&quot;, texts[n - 1]);
      } else {
        println!(&quot;Rust: ERROR - Line \&quot;{}\&quot; is out of range.&quot;, n);
      },
      Err(e) =&gt; println!(&quot;Rust: ERROR - Input \&quot;{}\&quot; is not an integer: {}&quot;, input, e),
    }
  }
  println!(&quot;Rust: Process end.&quot;);
}
</code></pre></pre>
<p>Compile the application into WebAssembly.</p>
<pre><code class="language-bash">$ cd rust_readfile
$ cargo build --target wasm32-wasi
# The output file will be target/wasm32-wasi/debug/rust_readfile.wasm
</code></pre>
<p>The Go source code to run the WebAssembly function in WasmEdge is as follows.</p>
<pre><code class="language-go">package main

import (
  &quot;os&quot;
  &quot;github.com/second-state/WasmEdge-go/wasmedge&quot;
)

func main() {
  wasmedge.SetLogErrorLevel()

  var conf = wasmedge.NewConfigure(wasmedge.REFERENCE_TYPES)
  conf.AddConfig(wasmedge.WASI)
  var vm = wasmedge.NewVMWithConfig(conf)
  var wasi = vm.GetImportObject(wasmedge.WASI)
  wasi.InitWasi(
    os.Args[1:],     // The args
    os.Environ(),    // The envs
    []string{&quot;.:.&quot;}, // The mapping directories
  )

  // Instantiate wasm. _start refers to the main() function
  vm.RunWasmFile(os.Args[1], &quot;_start&quot;)

  vm.Release()
  conf.Release()
}
</code></pre>
<p>Next, let's build the Go application with the WasmEdge Go SDK.</p>
<pre><code class="language-bash">go get github.com/second-state/WasmEdge-go/wasmedge@v0.9.1
go build
</code></pre>
<p>Run the Golang application.</p>
<pre><code class="language-bash">$ ./read_file rust_readfile/target/wasm32-wasi/debug/rust_readfile.wasm file.txt
Rust: Opening input file &quot;file.txt&quot;...
Rust: Read input file &quot;file.txt&quot; succeeded.
Rust: Please input the line number to print the line of file.
# Input &quot;5&quot; and press Enter.
5
# The output will be the 5th line of `file.txt`:
abcDEF___!@#$%^
# To terminate the program, send the EOF (Ctrl + D).
^D
# The output will print the terminate message:
Rust: Process end.
</code></pre>
<p>More examples can be found at <a href="https://github.com/second-state/WasmEdge-go-examples">the WasmEdge-go-examples GitHub repo.</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="embed-a-wasm-function"><a class="header" href="#embed-a-wasm-function">Embed a Wasm function</a></h1>
<p>The WasmEdge Go SDK allows WebAssembly functions to be embedded into a Go host app. You can use the Go SDK API to pass call parameters to the embedded WebAssembly functions, and then capture the return values.
However, the WebAssembly spec only supports a few simple data types out of the box. It <a href="https://medium.com/wasm/strings-in-webassembly-wasm-57a05c1ea333">does not support</a> types such as string and array. In order to pass rich types in Go to WebAssembly, we could hand-code memory pointers (<a href="embed/go/memory.html">see here</a>), or use an automated tool to manage the data exchange.</p>
<p>The <a href="https://github.com/second-state/wasmedge-bindgen">wasmedge-bindgen</a> project provides Rust macros for functions to accept and return complex data types, and then for Go functions to call such Rust functions running in WasmEdge.
The full source code for the demo in this chapter is <a href="https://github.com/second-state/WasmEdge-go-examples/tree/master/wasmedge-bindgen/go_BindgenFuncs">available here</a>.</p>
<h2 id="rust-function-compiled-into-webassembly"><a class="header" href="#rust-function-compiled-into-webassembly">Rust function compiled into WebAssembly</a></h2>
<p>In the <a href="https://github.com/second-state/WasmEdge-go-examples/tree/master/wasmedge-bindgen/go_BindgenFuncs/rust_bindgen_funcs">Rust project</a>, all you need is to annotate <a href="https://github.com/second-state/WasmEdge-go-examples/blob/master/wasmedge-bindgen/go_BindgenFuncs/rust_bindgen_funcs/src/lib.rs">your functions</a> with a <code>[wasmedge_bindgen]</code> macro.
Those annotated functions will be automatically instrumented by the Rust compiler and turned into WebAssembly functions that can be called from the <code>wasmedge-bindgen</code> GO SDK.
In the example below, we have several Rust functions that take complex call parameters and return complex values.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use wasmedge_bindgen::*;
use wasmedge_bindgen_macro::*;
use num_integer::lcm;
use sha3::{Digest, Sha3_256, Keccak256};
use serde::{Serialize, Deserialize};

#[derive(Serialize, Deserialize, Debug)]
struct Point {
  x: f32,
  y: f32
}

#[derive(Serialize, Deserialize, Debug)]
struct Line {
  points: Vec&lt;Point&gt;,
  valid: bool,
  length: f32,
  desc: String
}

#[wasmedge_bindgen]
pub fn create_line(p1: String, p2: String, desc: String) -&gt; Result&lt;Vec&lt;u8&gt;, String&gt; {
  let point1: Point = serde_json::from_str(p1.as_str()).unwrap();
  let point2: Point = serde_json::from_str(p2.as_str()).unwrap();
  let length = ((point1.x - point2.x) * (point1.x - point2.x) + (point1.y - point2.y) * (point1.y - point2.y)).sqrt();

  let valid = if length == 0.0 { false } else { true };

  let line = Line { points: vec![point1, point2], valid: valid, length: length, desc: desc };

  return Ok(serde_json::to_vec(&amp;line).unwrap());
}

#[wasmedge_bindgen]
pub fn say(s: String) -&gt; Result&lt;Vec&lt;u8&gt;, String&gt; {
  let r = String::from(&quot;hello &quot;);
  return Ok((r + s.as_str()).as_bytes().to_vec());
}

#[wasmedge_bindgen]
pub fn obfusticate(s: String) -&gt; Result&lt;Vec&lt;u8&gt;, String&gt; {
  let r: String = (&amp;s).chars().map(|c| {
    match c {
      'A' ..= 'M' | 'a' ..= 'm' =&gt; ((c as u8) + 13) as char,
      'N' ..= 'Z' | 'n' ..= 'z' =&gt; ((c as u8) - 13) as char,
      _ =&gt; c
    }
  }).collect();
  Ok(r.as_bytes().to_vec())
}

#[wasmedge_bindgen]
pub fn lowest_common_multiple(a: i32, b: i32) -&gt; Result&lt;Vec&lt;u8&gt;, String&gt; {
  let r = lcm(a, b);
  return Ok(r.to_string().as_bytes().to_vec());
}

#[wasmedge_bindgen]
pub fn sha3_digest(v: Vec&lt;u8&gt;) -&gt; Result&lt;Vec&lt;u8&gt;, String&gt; {
  return Ok(Sha3_256::digest(&amp;v).as_slice().to_vec());
}

#[wasmedge_bindgen]
pub fn keccak_digest(s: Vec&lt;u8&gt;) -&gt; Result&lt;Vec&lt;u8&gt;, String&gt; {
  return Ok(Keccak256::digest(&amp;s).as_slice().to_vec());
}
<span class="boring">}
</span></code></pre></pre>
<p>You can build the WebAssembly bytecode file using standard <code>Cargo</code> commands.</p>
<pre><code class="language-bash">cd rust_bindgen_funcs
cargo build --target wasm32-wasi --release
# The output WASM will be target/wasm32-wasi/release/rust_bindgen_funcs_lib.wasm.
cp target/wasm32-wasi/release/rust_bindgen_funcs_lib.wasm ../
cd ../
</code></pre>
<h2 id="go-host-application"><a class="header" href="#go-host-application">Go host application</a></h2>
<p>In the <a href="https://github.com/second-state/WasmEdge-go-examples/blob/master/wasmedge-bindgen/go_BindgenFuncs/bindgen_funcs.go">Go host application</a>, you can create and set up the WasmEdge VM using the WasmEdge Go SDK.
However, instead of calling <code>vm.Instantiate()</code>, you should now call <code>bindgen.Instantiate(vm)</code> to instantiate the VM and return a <code>bindgen</code> object.</p>
<pre><code class="language-go">func main() {
  // Expected Args[0]: program name (./bindgen_funcs)
  // Expected Args[1]: wasm file (rust_bindgen_funcs_lib.wasm))

  wasmedge.SetLogErrorLevel()
  var conf = wasmedge.NewConfigure(wasmedge.WASI)
  var vm = wasmedge.NewVMWithConfig(conf)
  var wasi = vm.GetImportObject(wasmedge.WASI)
  wasi.InitWasi(
    os.Args[1:],     // The args
    os.Environ(),    // The envs
    []string{&quot;.:.&quot;}, // The mapping preopens
  )
  vm.LoadWasmFile(os.Args[1])
  vm.Validate()

  // Instantiate the bindgen and vm
  bg := bindgen.Instantiate(vm)
</code></pre>
<p>Next, you can call any <code>[wasmedge_bindgen]</code> annotated functions in the VM via the <code>bindgen</code> object.</p>
<pre><code class="language-go">  // create_line: string, string, string -&gt; string (inputs are JSON stringified) 
  res, err := bg.Execute(&quot;create_line&quot;, &quot;{\&quot;x\&quot;:2.5,\&quot;y\&quot;:7.8}&quot;, &quot;{\&quot;x\&quot;:2.5,\&quot;y\&quot;:5.8}&quot;, &quot;A thin red line&quot;)
  if err == nil {
    fmt.Println(&quot;Run bindgen -- create_line:&quot;, string(res))
  } else {
    fmt.Println(&quot;Run bindgen -- create_line FAILED&quot;, err)
  }

  // say: string -&gt; string
  res, err = bg.Execute(&quot;say&quot;, &quot;bindgen funcs test&quot;)
  if err == nil {
    fmt.Println(&quot;Run bindgen -- say:&quot;, string(res))
  } else {
    fmt.Println(&quot;Run bindgen -- say FAILED&quot;)
  }

  // obfusticate: string -&gt; string
  res, err = bg.Execute(&quot;obfusticate&quot;, &quot;A quick brown fox jumps over the lazy dog&quot;)
  if err == nil {
    fmt.Println(&quot;Run bindgen -- obfusticate:&quot;, string(res))
  } else {
    fmt.Println(&quot;Run bindgen -- obfusticate FAILED&quot;)
  }

  // lowest_common_multiple: i32, i32 -&gt; i32
  res, err = bg.Execute(&quot;lowest_common_multiple&quot;, int32(123), int32(2))
  if err == nil {
    num, _ := strconv.ParseInt(string(res), 10, 32)
    fmt.Println(&quot;Run bindgen -- lowest_common_multiple:&quot;, num)
  } else {
    fmt.Println(&quot;Run bindgen -- lowest_common_multiple FAILED&quot;)
  }

  // sha3_digest: array -&gt; array
  res, err = bg.Execute(&quot;sha3_digest&quot;, []byte(&quot;This is an important message&quot;))
  if err == nil {
    fmt.Println(&quot;Run bindgen -- sha3_digest:&quot;, res)
  } else {
    fmt.Println(&quot;Run bindgen -- sha3_digest FAILED&quot;)
  }

  // keccak_digest: array -&gt; array
  res, err = bg.Execute(&quot;keccak_digest&quot;, []byte(&quot;This is an important message&quot;))
  if err == nil {
    fmt.Println(&quot;Run bindgen -- keccak_digest:&quot;, res)
  } else {
    fmt.Println(&quot;Run bindgen -- keccak_digest FAILED&quot;)
  }

  bg.Release()
  vm.Release()
  conf.Release()
}
</code></pre>
<p>Finally, you can build and run the Go host application.</p>
<pre><code class="language-bash">go build
./bindgen_funcs rust_bindgen_funcs_lib.wasm
</code></pre>
<p>The standard output of this example will be the following.</p>
<pre><code class="language-bash">Run bindgen -- create_line: {&quot;points&quot;:[{&quot;x&quot;:1.5,&quot;y&quot;:3.8},{&quot;x&quot;:2.5,&quot;y&quot;:5.8}],&quot;valid&quot;:true,&quot;length&quot;:2.2360682,&quot;desc&quot;:&quot;A thin red line&quot;}
Run bindgen -- say: hello bindgen funcs test
Run bindgen -- obfusticate: N dhvpx oebja sbk whzcf bire gur ynml qbt
Run bindgen -- lowest_common_multiple: 246
Run bindgen -- sha3_digest: [87 27 231 209 189 105 251 49 159 10 211 250 15 159 154 181 43 218 26 141 56 199 25 45 60 10 20 163 54 211 195 203]
Run bindgen -- keccak_digest: [126 194 241 200 151 116 227 33 216 99 159 22 107 3 177 169 216 191 114 156 174 193 32 159 246 228 245 133 52 75 55 27]
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pass-complex-parameters-to-wasm-functions"><a class="header" href="#pass-complex-parameters-to-wasm-functions">Pass complex parameters to Wasm functions</a></h1>
<p>An issue with the WebAssembly spec is that it only supports a very limited number of data types. If you want to embed a WebAssembly function with complex call parameters or return values, you will need to manage memory pointers both on Go SDK and WebAssembly function sides.
Such complex call parameters and return values include dynamic memory structures such as strings and byte arrays.
In this section, we will discuss several examples.</p>
<ul>
<li><a href="embed/go/memory.html#pass-strings-to-rust-functions">Pass strings to Rust functions</a></li>
<li><a href="embed/go/memory.html#pass-strings-to-tinygo-functions">Pass strings to TinyGo functions</a></li>
<li><a href="embed/go/memory.html#pass-bytes-to-rust-functions">Pass bytes to Rust functions</a></li>
<li><a href="embed/go/memory.html#pass-bytes-to-tinygo-functions">Pass bytes to TinyGo functions</a></li>
</ul>
<h2 id="pass-strings-to-rust-functions"><a class="header" href="#pass-strings-to-rust-functions">Pass strings to Rust functions</a></h2>
<p>In <a href="https://github.com/second-state/WasmEdge-go-examples/tree/master/go_MemoryGreet">this example</a>, we will demonstrate how to call <a href="https://github.com/second-state/WasmEdge-go-examples/blob/master/go_MemoryGreet/rust_memory_greet/src/lib.rs">a Rust-based WebAssembly function</a> from a Go app.
Specially, we will discuss how to pass string data.</p>
<blockquote>
<p>An alternative approach to pass and return complex values to Rust functions in WebAssembly is to use the <code>wasm-bindgen</code> compiler tool. You can <a href="embed/go/bindgen.html">learn more here</a>.</p>
</blockquote>
<p>The Rust function takes a memory pointer for the string, and constructs the Rust string itself.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::ffi::{CStr, CString};
use std::mem;
use std::os::raw::{c_char, c_void};

#[no_mangle]
pub extern fn allocate(size: usize) -&gt; *mut c_void {
  let mut buffer = Vec::with_capacity(size);
  let pointer = buffer.as_mut_ptr();
  mem::forget(buffer);

  pointer as *mut c_void
}

#[no_mangle]
pub extern fn deallocate(pointer: *mut c_void, capacity: usize) {
  unsafe {
    let _ = Vec::from_raw_parts(pointer, 0, capacity);
  }
}

#[no_mangle]
pub extern fn greet(subject: *mut c_char) -&gt; *mut c_char {
  let subject = unsafe { CStr::from_ptr(subject).to_bytes().to_vec() };
  let mut output = b&quot;Hello, &quot;.to_vec();
  output.extend(&amp;subject);
  output.extend(&amp;[b'!']);

  unsafe { CString::from_vec_unchecked(output) }.into_raw()
}
<span class="boring">}
</span></code></pre></pre>
<p>Use standard Rust compiler tools to compile the Rust source code into a WebAssembly bytecode application.</p>
<pre><code class="language-bash">cd rust_memory_greet
cargo build --target wasm32-wasi
# The output WASM will be `target/wasm32-wasi/debug/rust_memory_greet_lib.wasm`.
</code></pre>
<p>The <a href="https://github.com/second-state/WasmEdge-go-examples/blob/master/go_MemoryGreet/greet_memory.go">Go SDK application</a> must call <code>allocate</code> from the WasmEdge VM to get a pointer to the string parameter.
It will then call the <code>greet</code> function in Rust with the pointer.
After the function returns, the Go application will call <code>deallocate</code> to free the memory space.</p>
<pre><code class="language-go">package main

import (
  &quot;fmt&quot;
  &quot;os&quot;
  &quot;strings&quot;

  &quot;github.com/second-state/WasmEdge-go/wasmedge&quot;
)

func main() {
  wasmedge.SetLogErrorLevel()
  conf := wasmedge.NewConfigure(wasmedge.WASI)
  store := wasmedge.NewStore()
  vm := wasmedge.NewVMWithConfigAndStore(conf, store)

  wasi := vm.GetImportObject(wasmedge.WASI)
  wasi.InitWasi(
    os.Args[1:],
    os.Environ(),
    []string{&quot;.:.&quot;},
  )

  err := vm.LoadWasmFile(os.Args[1])
  if err != nil {
    fmt.Println(&quot;failed to load wasm&quot;)
  }
  vm.Validate()
  vm.Instantiate()

  subject := &quot;WasmEdge&quot;
  lengthOfSubject := len(subject)

  // Allocate memory for the subject, and get a pointer to it.
  // Include a byte for the NULL terminator we add below.
  allocateResult, _ := vm.Execute(&quot;allocate&quot;, int32(lengthOfSubject+1))
  inputPointer := allocateResult[0].(int32)

  // Write the subject into the memory.
  mem := store.FindMemory(&quot;memory&quot;)
  memData, _ := mem.GetData(uint(inputPointer), uint(lengthOfSubject+1))
  copy(memData, subject)

  // C-string terminates by NULL.
  memData[lengthOfSubject] = 0

  // Run the `greet` function. Given the pointer to the subject.
  greetResult, _ := vm.Execute(&quot;greet&quot;, inputPointer)
  outputPointer := greetResult[0].(int32)

  pageSize := mem.GetPageSize()
  // Read the result of the `greet` function.
  memData, _ = mem.GetData(uint(0), uint(pageSize * 65536))
  nth := 0
  var output strings.Builder

  for {
    if memData[int(outputPointer) + nth] == 0 {
      break
    }

    output.WriteByte(memData[int(outputPointer) + nth])
    nth++
  }

  lengthOfOutput := nth

  fmt.Println(output.String())

  // Deallocate the subject, and the output.
  vm.Execute(&quot;deallocate&quot;, inputPointer, int32(lengthOfSubject+1))
  vm.Execute(&quot;deallocate&quot;, outputPointer, int32(lengthOfOutput+1))

  vm.Release()
  store.Release()
  conf.Release()
}
</code></pre>
<p>To build the Go SDK example, run the following commands.</p>
<pre><code class="language-bash">go get github.com/second-state/WasmEdge-go/wasmedge@v0.9.1
go build greet_memory.go
</code></pre>
<p>Now you can use the Go application to run the WebAssembly plug-in compiled from Rust.</p>
<pre><code class="language-bash">$ ./greet_memory rust_memory_greet_lib.wasm
Hello, WasmEdge!
</code></pre>
<h2 id="pass-strings-to-tinygo-functions"><a class="header" href="#pass-strings-to-tinygo-functions">Pass strings to TinyGo functions</a></h2>
<p>In <a href="https://github.com/second-state/WasmEdge-go-examples/tree/master/go_MemoryGreetTinyGo">this example</a>, we will demonstrate how to call <a href="https://github.com/second-state/WasmEdge-go-examples/blob/master/go_MemoryGreetTinyGo/greet.go">a TinyGo-based WebAssembly function</a> from a Go app.</p>
<p>The TinyGo function takes a memory pointer for the string, and constructs the TinyGo string itself.</p>
<blockquote>
<p>The empty <code>main()</code> is needed to the compiled WebAssembly program to set up WASI properly.</p>
</blockquote>
<pre><code class="language-go">package main

import (
  &quot;strings&quot;
  &quot;unsafe&quot;
)

func main() {}

// export greet
func greet(subject *int32) *byte {
  nth := 0
  var subjectStr strings.Builder
  pointer := uintptr(unsafe.Pointer(subject))
  for {
    s := *(*int32)(unsafe.Pointer(pointer + uintptr(nth)))
    if s == 0 {
      break;
    }

    subjectStr.WriteByte(byte(s))
    nth++
  }

  output := subjectStr.String()
  output = &quot;Hello, &quot; + output + &quot;!&quot;

  return &amp;(([]byte)(output)[0])
}
</code></pre>
<p>Use the TinyGo compiler tools to compile the Go source code into a WebAssembly bytecode application.</p>
<pre><code class="language-bash">tinygo build -o greet.wasm -target wasi greet.go
</code></pre>
<p>The <a href="https://github.com/second-state/WasmEdge-go-examples/blob/master/go_MemoryGreetTinyGo/greet_memory.go">Go SDK application</a> must call <code>malloc</code> from the WasmEdge VM to get a pointer to the string parameter.
It will then call the <code>greet</code> function in TinyGo with the pointer.
After the function returns, the Go application will call <code>free</code> to free the memory space.</p>
<pre><code class="language-go">package main

import (
  &quot;fmt&quot;
  &quot;os&quot;
  &quot;strings&quot;

  &quot;github.com/second-state/WasmEdge-go/wasmedge&quot;
)

func main() {
  wasmedge.SetLogErrorLevel()
  conf := wasmedge.NewConfigure(wasmedge.WASI)
  store := wasmedge.NewStore()
  vm := wasmedge.NewVMWithConfigAndStore(conf, store)

  wasi := vm.GetImportObject(wasmedge.WASI)
  wasi.InitWasi(
    os.Args[1:],
    os.Environ(),
    []string{&quot;.:.&quot;},
  )

  err := vm.LoadWasmFile(os.Args[1])
  if err != nil {
    fmt.Println(&quot;failed to load wasm&quot;)
  }
  vm.Validate()
  vm.Instantiate()

  subject := &quot;WasmEdge&quot;
  lengthOfSubject := len(subject)

  // Allocate memory for the subject, and get a pointer to it.
  // Include a byte for the NULL terminator we add below.
  allocateResult, _ := vm.Execute(&quot;malloc&quot;, int32(lengthOfSubject+1))
  inputPointer := allocateResult[0].(int32)

  // Write the subject into the memory.
  mem := store.FindMemory(&quot;memory&quot;)
  memData, _ := mem.GetData(uint(inputPointer), uint(lengthOfSubject+1))
  copy(memData, subject)

  // C-string terminates by NULL.
  memData[lengthOfSubject] = 0

  // Run the `greet` function. Given the pointer to the subject.
  greetResult, _ := vm.Execute(&quot;greet&quot;, inputPointer)
  outputPointer := greetResult[0].(int32)

  pageSize := mem.GetPageSize()
  // Read the result of the `greet` function.
  memData, _ = mem.GetData(uint(0), uint(pageSize * 65536))
  nth := 0
  var output strings.Builder

  for {
    if memData[int(outputPointer) + nth] == 0 {
      break
    }

    output.WriteByte(memData[int(outputPointer) + nth])
    nth++
  }

  fmt.Println(output.String())

  // Deallocate the subject, and the output.
  vm.Execute(&quot;free&quot;, inputPointer)
  vm.Execute(&quot;free&quot;, outputPointer)

  vm.Release()
  store.Release()
  conf.Release()
}
</code></pre>
<p>To build the Go SDK example, run the following commands.</p>
<pre><code class="language-bash">go get github.com/second-state/WasmEdge-go/wasmedge@v0.9.1
go build greet_memory.go
</code></pre>
<p>Now you can use the Go application to run the WebAssembly plug-in compiled from TinyGo.</p>
<pre><code class="language-bash">$ ./greet_memory greet.wasm
Hello, WasmEdge!
</code></pre>
<h2 id="pass-bytes-to-rust-functions"><a class="header" href="#pass-bytes-to-rust-functions">Pass bytes to Rust functions</a></h2>
<p>In <a href="https://github.com/second-state/WasmEdge-go-examples/tree/master/go_AccessMemory">this example</a>, we will demonstrate how to call <a href="https://github.com/second-state/WasmEdge-go-examples/blob/master/go_AccessMemory/rust_access_memory/src/lib.rs">Rust-based WebAssembly functions</a> and pass arrays to and from a Go app.</p>
<blockquote>
<p>An alternative approach to pass and return complex values to Rust functions in WebAssembly is to use the <code>wasm-bindgen</code> compiler tool. You can <a href="embed/go/bindgen.html">learn more here</a>.</p>
</blockquote>
<p>The <code>fib_array()</code> function takes a array as a call parameter and fill it with a fibonacci sequence of numbers. Alternatively, the <code>fib_array_return_memory()</code> function returns a array of fibonacci sequence of numbers.</p>
<p>For the array in the call parameter, the Rust function <code>fib_array()</code> takes a memory pointer and constructs the Rust <code>Vec</code> using <code>from_raw_parts</code>. For the array return value, the Rust function <code>fib_array_return_memory()</code> simply returns the pointer.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::mem;
use std::os::raw::{c_void, c_int};

#[no_mangle]
pub extern fn allocate(size: usize) -&gt; *mut c_void {
  let mut buffer = Vec::with_capacity(size);
  let pointer = buffer.as_mut_ptr();
  mem::forget(buffer);

  pointer as *mut c_void
}

#[no_mangle]
pub extern fn deallocate(pointer: *mut c_void, capacity: usize) {
  unsafe {
    let _ = Vec::from_raw_parts(pointer, 0, capacity);
  }
}

#[no_mangle]
pub extern fn fib_array(n: i32, p: *mut c_int) -&gt; i32 {
  unsafe {
    let mut arr = Vec::&lt;i32&gt;::from_raw_parts(p, 0, (4*n) as usize);
    for i in 0..n {
      if i &lt; 2 {
        arr.push(i);
      } else {
        arr.push(arr[(i - 1) as usize] + arr[(i - 2) as usize]);
      }
    }
    let r = arr[(n - 1) as usize];
    mem::forget(arr);
    r
  }
}

#[no_mangle]
pub extern fn fib_array_return_memory(n: i32) -&gt; *mut c_int {
  let mut arr = Vec::with_capacity((4 * n) as usize);
  let pointer = arr.as_mut_ptr();
  for i in 0..n {
    if i &lt; 2 {
      arr.push(i);
    } else {
      arr.push(arr[(i - 1) as usize] + arr[(i - 2) as usize]);
    }
  }
  mem::forget(arr);
  pointer
}
<span class="boring">}
</span></code></pre></pre>
<p>Use standard Rust compiler tools to compile the Rust source code into a WebAssembly bytecode application.</p>
<pre><code class="language-bash">cd rust_access_memory
cargo build --target wasm32-wasi
# The output WASM will be target/wasm32-wasi/debug/rust_access_memory_lib.wasm.
</code></pre>
<p>The <a href="https://github.com/second-state/WasmEdge-go-examples/blob/master/go_AccessMemory/run.go">Go SDK application</a> must call <code>allocate</code> from the WasmEdge VM to get a pointer to the array.
It will then call the <code>fib_array()</code> function in Rust and pass in the pointer.
After the functions return, the Go application will use the WasmEdge <code>store</code> API to construct an array from the pointer in the call parameter (<code>fib_array()</code>) or in the return value (<code>fib_array_return_memory()</code>).
The Go app will eventually call <code>deallocate</code> to free the memory space.</p>
<pre><code class="language-go">package main

import (
  &quot;fmt&quot;
  &quot;os&quot;
  &quot;unsafe&quot;

  &quot;github.com/second-state/WasmEdge-go/wasmedge&quot;
)

func main() {
  wasmedge.SetLogErrorLevel()
  conf := wasmedge.NewConfigure(wasmedge.WASI)
  store := wasmedge.NewStore()
  vm := wasmedge.NewVMWithConfigAndStore(conf, store)

  wasi := vm.GetImportObject(wasmedge.WASI)
  wasi.InitWasi(
    os.Args[1:],
    os.Environ(),
    []string{&quot;.:.&quot;},
  )

  err := vm.LoadWasmFile(os.Args[1])
  if err != nil {
    fmt.Println(&quot;failed to load wasm&quot;)
  }
  vm.Validate()
  vm.Instantiate()

  n := int32(10)

  p, err := vm.Execute(&quot;allocate&quot;, 4 * n)
  if err != nil {
    fmt.Println(&quot;allocate failed:&quot;, err)
  }

  fib, err := vm.Execute(&quot;fib_array&quot;, n, p[0])
  if err != nil {
    fmt.Println(&quot;fib_rray failed:&quot;, err)
  } else {
    fmt.Println(&quot;fib_array() returned:&quot;, fib[0])
    fmt.Printf(&quot;fib_array memory at: %p\n&quot;, unsafe.Pointer((uintptr)(p[0].(int32))))
    mem := store.FindMemory(&quot;memory&quot;)
    if mem != nil {
      // int32 occupies 4 bytes
      fibArray, err := mem.GetData(uint(p[0].(int32)), uint(n * 4))
      if err == nil &amp;&amp; fibArray != nil {
        fmt.Println(&quot;fibArray:&quot;, fibArray)
      }
    }
  }

  fibP, err := vm.Execute(&quot;fib_array_return_memory&quot;, n)
  if err != nil {
    fmt.Println(&quot;fib_array_return_memory failed:&quot;, err)
  } else {
    fmt.Printf(&quot;fib_array_return_memory memory at: %p\n&quot;, unsafe.Pointer((uintptr)(fibP[0].(int32))))
    mem := store.FindMemory(&quot;memory&quot;)
    if mem != nil {
      // int32 occupies 4 bytes
      fibArrayReturnMemory, err := mem.GetData(uint(fibP[0].(int32)), uint(n * 4))
      if err == nil &amp;&amp; fibArrayReturnMemory != nil {
        fmt.Println(&quot;fibArrayReturnMemory:&quot;, fibArrayReturnMemory)
      }
    }
  }

  _, err = vm.Execute(&quot;deallocate&quot;, p[0].(int32), 4 * n)
  if err != nil {
    fmt.Println(&quot;free failed:&quot;, err)
  }


  exitcode := wasi.WasiGetExitCode()
  if exitcode != 0 {
    fmt.Println(&quot;Go: Running wasm failed, exit code:&quot;, exitcode)
  }

  vm.Release()
  store.Release()
  conf.Release()
}
</code></pre>
<p>To build the Go SDK example, run the following commands.</p>
<pre><code class="language-bash">go get github.com/second-state/WasmEdge-go/wasmedge@v0.9.1
go build run.go
</code></pre>
<p>Now you can use the Go application to run the WebAssembly plug-in compiled from Rust.</p>
<pre><code class="language-bash">$ ./run rust_access_memory_lib.wasm
fib_array() returned: 34
fib_array memory at: 0x102d80
fibArray: [0 0 0 0 1 0 0 0 1 0 0 0 2 0 0 0 3 0 0 0 5 0 0 0 8 0 0 0 13 0 0 0 21 0 0 0 34 0 0 0]
fib_array_return_memory memory at: 0x105430
fibArrayReturnMemory: [0 0 0 0 1 0 0 0 1 0 0 0 2 0 0 0 3 0 0 0 5 0 0 0 8 0 0 0 13 0 0 0 21 0 0 0 34 0 0 0]
</code></pre>
<h2 id="pass-bytes-to-tinygo-functions"><a class="header" href="#pass-bytes-to-tinygo-functions">Pass bytes to TinyGo functions</a></h2>
<p>In <a href="https://github.com/second-state/WasmEdge-go-examples/tree/master/go_AccessMemoryTinyGo">this example</a>, we will demonstrate how to call <a href="https://github.com/second-state/WasmEdge-go-examples/blob/master/go_AccessMemoryTinyGo/fib.go">TinyGo-based WebAssembly functions</a> and pass arrays to and from a Go app.</p>
<p>The <code>fibArray</code> function takes a array as a call parameter and fill it with
a fibonacci sequence of numbers. Alternatively, the <code>fibArrayReturnMemory</code> function returns
a array of fibonacci sequence of numbers.</p>
<pre><code class="language-go">package main

import (
  &quot;fmt&quot;
  &quot;unsafe&quot;
)

func main() {
  println(&quot;in main&quot;)
  n := int32(10)
  arr := make([]int32, n)
  arrP := &amp;arr[0]
  fmt.Printf(&quot;call fibArray(%d, %p) = %d\n&quot;, n, arrP, fibArray(n, arrP))
  fmt.Printf(&quot;call fibArrayReturnMemory(%d) return %p\n&quot;, n, fibArrayReturnMemory(n))
}

// export fibArray
func fibArray(n int32, p *int32) int32 {
  arr := unsafe.Slice(p, n)
  for i := int32(0); i &lt; n; i++ {
    switch {
    case i &lt; 2:
      arr[i] = i
    default:
      arr[i] = arr[i-1] + arr[i-2]
    }
  }
  return arr[n-1]
}

// export fibArrayReturnMemory
func fibArrayReturnMemory(n int32) *int32 {
  arr := make([]int32, n)
  for i := int32(0); i &lt; n; i++ {
    switch {
    case i &lt; 2:
      arr[i] = i
    default:
      arr[i] = arr[i-1] + arr[i-2]
    }
  }
  return &amp;arr[0]
}
</code></pre>
<p>Use the TinyGo compiler tools to compile the Go source code into a WebAssembly bytecode application.</p>
<pre><code class="language-bash">tinygo build -o fib.wasm -target wasi fib.go
</code></pre>
<p>The <a href="https://github.com/second-state/WasmEdge-go-examples/blob/master/go_AccessMemoryTinyGo/run.go">Go SDK application</a> must call <code>malloc</code> from the WasmEdge VM to get a pointer to the array.
It will then call the <code>fibArray()</code> function in TinyGo with the pointer.
After the functions return, the Go app uses the WasmEdge SDK's <code>store</code> API to construct an array from the pointer in the call parameter (<code>fibArray()</code>) or in the return value (<code>fibArrayReturnMemory()</code>).
The Go application will eventually call <code>free</code> to free the memory space.</p>
<pre><code class="language-go">package main

import (
  &quot;fmt&quot;
  &quot;os&quot;
  &quot;unsafe&quot;

  &quot;github.com/second-state/WasmEdge-go/wasmedge&quot;
)

func main() {
  wasmedge.SetLogErrorLevel()
  conf := wasmedge.NewConfigure(wasmedge.WASI)
  store := wasmedge.NewStore()
  vm := wasmedge.NewVMWithConfigAndStore(conf, store)

  wasi := vm.GetImportObject(wasmedge.WASI)
  wasi.InitWasi(
    os.Args[1:],
    os.Environ(),
    []string{&quot;.:.&quot;},
  )

  err := vm.LoadWasmFile(os.Args[1])
  if err != nil {
    fmt.Println(&quot;failed to load wasm&quot;)
  }
  vm.Validate()
  vm.Instantiate()

  n := int32(10)

  p, err := vm.Execute(&quot;malloc&quot;, n)
  if err != nil {
    fmt.Println(&quot;malloc failed:&quot;, err)
  }

  fib, err := vm.Execute(&quot;fibArray&quot;, n, p[0])
  if err != nil {
    fmt.Println(&quot;fibArray failed:&quot;, err)
  } else {
    fmt.Println(&quot;fibArray() returned:&quot;, fib[0])
    fmt.Printf(&quot;fibArray memory at: %p\n&quot;, unsafe.Pointer((uintptr)(p[0].(int32))))
    mem := store.FindMemory(&quot;memory&quot;)
    if mem != nil {
      // int32 occupies 4 bytes
      fibArray, err := mem.GetData(uint(p[0].(int32)), uint(n * 4))
      if err == nil &amp;&amp; fibArray != nil {
        fmt.Println(&quot;fibArray:&quot;, fibArray)
      }
    }
  }

  fibP, err := vm.Execute(&quot;fibArrayReturnMemory&quot;, n)
  if err != nil {
    fmt.Println(&quot;fibArrayReturnMemory failed:&quot;, err)
  } else {
    fmt.Printf(&quot;fibArrayReturnMemory memory at: %p\n&quot;, unsafe.Pointer((uintptr)(fibP[0].(int32))))
    mem := store.FindMemory(&quot;memory&quot;)
    if mem != nil {
      // int32 occupies 4 bytes
      fibArrayReturnMemory, err := mem.GetData(uint(fibP[0].(int32)), uint(n * 4))
      if err == nil &amp;&amp; fibArrayReturnMemory != nil {
        fmt.Println(&quot;fibArrayReturnMemory:&quot;, fibArrayReturnMemory)
      }
    }
  }

  _, err = vm.Execute(&quot;free&quot;, p...)
  if err != nil {
    fmt.Println(&quot;free failed:&quot;, err)
  }

  exitcode := wasi.WasiGetExitCode()
  if exitcode != 0 {
    fmt.Println(&quot;Go: Running wasm failed, exit code:&quot;, exitcode)
  }

  vm.Release()
  store.Release()
  conf.Release()
}
</code></pre>
<p>To build the Go SDK example, run the following commands.</p>
<pre><code class="language-bash">go get github.com/second-state/WasmEdge-go/wasmedge@v0.9.1
go build run.go
</code></pre>
<p>Now you can use the Go application to run the WebAssembly plug-in compiled from TinyGo.</p>
<pre><code class="language-bash">$ ./run fib.wasm
fibArray() returned: 34
fibArray memory at: 0x14d3c
fibArray: [0 0 0 0 1 0 0 0 1 0 0 0 2 0 0 0 3 0 0 0 5 0 0 0 8 0 0 0 13 0 0 0 21 0 0 0 34 0 0 0]
fibArrayReturnMemory memory at: 0x14d4c
fibArrayReturnMemory: [0 0 0 0 1 0 0 0 1 0 0 0 2 0 0 0 3 0 0 0 5 0 0 0 8 0 0 0 13 0 0 0 21 0 0 0 34 0 0 0]
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tensorflow-2"><a class="header" href="#tensorflow-2">Tensorflow</a></h1>
<p>In this section, we will show you how to create a Tensorflow inference function in Rust for image classification, and then embed it into a Go application. The project source code is <a href="https://github.com/second-state/WasmEdge-go-examples/tree/master/wasmedge-bindgen/go_TfliteFood">available here</a>.</p>
<h2 id="rust-function-compiled-into-webassembly-1"><a class="header" href="#rust-function-compiled-into-webassembly-1">Rust function compiled into WebAssembly</a></h2>
<p>The Rust function for image classification is <a href="https://github.com/second-state/WasmEdge-go-examples/blob/master/wasmedge-bindgen/go_TfliteFood/rust_tflite_food/src/lib.rs">available here</a>.
It utilizes the <a href="embed/go/../../dev/rust/tensorflow.html">WasmEdge Tensorflow extension API</a> as well as the <a href="embed/go/function.html">wasmedge_bindgen</a> for passing call parameters.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[wasmedge_bindgen]
fn infer(image_data: Vec&lt;u8&gt;) -&gt; Result&lt;Vec&lt;u8&gt;, String&gt; {
  ... ...
  let flat_img = image::imageops::thumbnail(&amp;img, 192, 192);

  let model_data: &amp;[u8] = include_bytes!(&quot;lite-model_aiy_vision_classifier_food_V1_1.tflite&quot;);
  let labels = include_str!(&quot;aiy_food_V1_labelmap.txt&quot;);

  let mut session = wasmedge_tensorflow_interface::Session::new(
    model_data,
    wasmedge_tensorflow_interface::ModelType::TensorFlowLite,
  );
  session
    .add_input(&quot;input&quot;, &amp;flat_img, &amp;[1, 192, 192, 3])
    .run();
  let res_vec: Vec&lt;u8&gt; = session.get_output(&quot;MobilenetV1/Predictions/Softmax&quot;);
  ... ...
}
<span class="boring">}
</span></code></pre></pre>
<p>You can use the standard <code>Cargo</code> command to build it into a WebAssembly function.</p>
<pre><code class="language-bash">cd rust_tflite_food
cargo build --target wasm32-wasi --release
cp target/wasm32-wasi/release/rust_tflite_food_lib.wasm ../
cd ../
</code></pre>
<p>You can use our AOT compiler <code>wasmedgec</code> to instrument the WebAssembly file to make it run much faster. <a href="embed/go/../../start/universal.html">Learn more</a>.</p>
<pre><code class="language-bash">wasmedgec rust_tflite_food_lib.wasm rust_tflite_food_lib.wasm
</code></pre>
<h2 id="go-host-app"><a class="header" href="#go-host-app">Go host app</a></h2>
<p>The <a href="https://github.com/second-state/WasmEdge-go-examples/blob/master/wasmedge-bindgen/go_TfliteFood/tflite_food.go">Go host app</a> source code shows how to instantiate a WasmEdge runtime with the Tensorflow extension, and how to pass the image data to the Rust function in WasmEdge to run the inference.</p>
<pre><code class="language-go">func main() {
  // Expected Args[0]: program name (./tflite_food)
  // Expected Args[1]: wasm file (rust_tflite_food_lib.wasm)
  // Expected Args[2]: input image name (food.jpg)

  wasmedge.SetLogErrorLevel()

  // Set Tensorflow not to print debug info
  os.Setenv(&quot;TF_CPP_MIN_LOG_LEVEL&quot;, &quot;3&quot;)
  os.Setenv(&quot;TF_CPP_MIN_VLOG_LEVEL&quot;, &quot;3&quot;)

  var conf = wasmedge.NewConfigure(wasmedge.WASI)
  var vm = wasmedge.NewVMWithConfig(conf)
  var wasi = vm.GetImportObject(wasmedge.WASI)
  wasi.InitWasi(
    os.Args[1:],     // The args
    os.Environ(),    // The envs
    []string{&quot;.:.&quot;}, // The mapping preopens
  )

  // Register WasmEdge-tensorflow
  var tfobj = wasmedge.NewTensorflowImportObject()
  var tfliteobj = wasmedge.NewTensorflowLiteImportObject()
  vm.RegisterImport(tfobj)
  vm.RegisterImport(tfliteobj)

  // Load and validate the wasm
  vm.LoadWasmFile(os.Args[1])
  vm.Validate()

  // Instantiate the bindgen and vm
  bg := bindgen.Instantiate(vm)

  img, _ := ioutil.ReadFile(os.Args[2])
  if res, err := bg.Execute(&quot;infer&quot;, img); err != nil {
    fmt.Println(err)
  } else {
    fmt.Println(string(res))
  }

  bg.Release()
  vm.Release()
  conf.Release()
  tfobj.Release()
  tfliteobj.Release()
}
</code></pre>
<h2 id="build-and-run"><a class="header" href="#build-and-run">Build and run</a></h2>
<blockquote>
<p>You must have WasmEdge with its tensorflow extension installed on your machine. <a href="embed/go/../../start/install.html">Checkout the install guide</a> for details.</p>
</blockquote>
<p>The following command builds the Go host application with the WasmEdge Go SDK and its tensorflow extension.</p>
<pre><code class="language-bash">go build -tags tensorflow
</code></pre>
<p>Now you can run the Go application. It calls the WebAssembly function in WasmEdge to run inference on the input image.</p>
<pre><code class="language-bash">./tflite_food rust_tflite_food_lib.wasm food.jpg
</code></pre>
<p>The results are as follows.</p>
<pre><code class="language-bash">Go: Args: [./tflite_food rust_tflite_food_lib.wasm food.jpg]
It is very likely a Hot dog in the picture
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="embed-a-bindgen-function"><a class="header" href="#embed-a-bindgen-function">Embed a bindgen function</a></h1>
<blockquote>
<p>The <code>wasm_bindgen</code> approach discussed in this chapter is deprecated. We encourage you to check out the <a href="embed/go/function.html">wasmedge_bindgen</a> approach or to <a href="embed/go/memory.html">pass memory pointers directly</a> instead.</p>
</blockquote>
<p>In <a href="https://github.com/second-state/WasmEdge-go-examples/tree/master/go_BindgenFuncs">this example</a>, we will demonstrate how to call a few simple WebAssembly functions from a Go app. The <a href="https://github.com/second-state/WasmEdge-go-examples/blob/master/go_BindgenFuncs/rust_bindgen_funcs/src/lib.rs">functions</a> are written in Rust, and require complex call parameters and return values. The <code>#[wasm_bindgen]</code> macro is needed for the compiler tools to auto-generate the correct code to pass call parameters from Go to WebAssembly.</p>
<p>The WebAssembly spec only supports a few simple data types out of the box. It <a href="https://medium.com/wasm/strings-in-webassembly-wasm-57a05c1ea333">does not support</a> types such as string and array. In order to pass rich types in Go to WebAssembly, the compiler needs to convert them to simple integers. For example, it converts a string into an integer memory address and an integer length. The <code>wasm_bindgen</code> tool, embedded in <a href="embed/go/../../dev/rust/bindgen.html">rustwasmc</a>, does this conversion automatically.</p>
<blockquote>
<p>At this time, we require Rust compiler version 1.50 or less in order for WebAssembly functions to work with WasmEdge's Go API. We will <a href="https://github.com/WasmEdge/WasmEdge/issues/264">catch up to the latest Rust</a> compiler version once the Interface Types spec is finalized and supported.</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use wasm_bindgen::prelude::*;
use num_integer::lcm;
use sha3::{Digest, Sha3_256, Keccak256};

#[wasm_bindgen]
pub fn say(s: &amp;str) -&gt; String {
  let r = String::from(&quot;hello &quot;);
  return r + s;
}

#[wasm_bindgen]
pub fn obfusticate(s: String) -&gt; String {
  (&amp;s).chars().map(|c| {
    match c {
      'A' ..= 'M' | 'a' ..= 'm' =&gt; ((c as u8) + 13) as char,
      'N' ..= 'Z' | 'n' ..= 'z' =&gt; ((c as u8) - 13) as char,
      _ =&gt; c
    }
  }).collect()
}

#[wasm_bindgen]
pub fn lowest_common_multiple(a: i32, b: i32) -&gt; i32 {
  let r = lcm(a, b);
  return r;
}

#[wasm_bindgen]
pub fn sha3_digest(v: Vec&lt;u8&gt;) -&gt; Vec&lt;u8&gt; {
  return Sha3_256::digest(&amp;v).as_slice().to_vec();
}

#[wasm_bindgen]
pub fn keccak_digest(s: &amp;[u8]) -&gt; Vec&lt;u8&gt; {
  return Keccak256::digest(s).as_slice().to_vec();
}
<span class="boring">}
</span></code></pre></pre>
<p>First, we use the <a href="embed/go/../../dev/rust/bindgen.html">rustwasmc</a> tool to compile the Rust source code into WebAssembly bytecode functions using Rust 1.50 or less.</p>
<pre><code class="language-bash">$ rustup default 1.50.0
$ cd rust_bindgen_funcs
$ rustwasmc build
# The output WASM will be pkg/rust_bindgen_funcs_lib_bg.wasm
</code></pre>
<p>The <a href="https://github.com/second-state/WasmEdge-go-examples/blob/master/go_BindgenFuncs/bindgen_funcs.go">Go source code</a> to run the WebAssembly function in WasmEdge is as follows. The <code>ExecuteBindgen()</code> function calls the WebAssembly function and passes the call parameters using the <code>#[wasm_bindgen]</code> convention.</p>
<pre><code class="language-go">package main

import (
  &quot;fmt&quot;
  &quot;os&quot;
  &quot;github.com/second-state/WasmEdge-go/wasmedge&quot;
)

func main() {
  // Expected Args[0]: program name (./bindgen_funcs)
  // Expected Args[1]: wasm or wasm-so file (rust_bindgen_funcs_lib_bg.wasm))

  wasmedge.SetLogErrorLevel()

  var conf = wasmedge.NewConfigure(wasmedge.WASI)
  var vm = wasmedge.NewVMWithConfig(conf)
  var wasi = vm.GetImportObject(wasmedge.WASI)
  wasi.InitWasi(
    os.Args[1:],     // The args
    os.Environ(),    // The envs
    []string{&quot;.:.&quot;}, // The mapping directories
  )

  // Instantiate wasm
  vm.LoadWasmFile(os.Args[1])
  vm.Validate()
  vm.Instantiate()

  // Run bindgen functions
  var res interface{}
  var err error
  
  res, err = vm.ExecuteBindgen(&quot;say&quot;, wasmedge.Bindgen_return_array, []byte(&quot;bindgen funcs test&quot;))
  if err == nil {
    fmt.Println(&quot;Run bindgen -- say:&quot;, string(res.([]byte)))
  } 
  res, err = vm.ExecuteBindgen(&quot;obfusticate&quot;, wasmedge.Bindgen_return_array, []byte(&quot;A quick brown fox jumps over the lazy dog&quot;))
  if err == nil {
    fmt.Println(&quot;Run bindgen -- obfusticate:&quot;, string(res.([]byte)))
  } 
  res, err = vm.ExecuteBindgen(&quot;lowest_common_multiple&quot;, wasmedge.Bindgen_return_i32, int32(123), int32(2))
  if err == nil {
    fmt.Println(&quot;Run bindgen -- lowest_common_multiple:&quot;, res.(int32))
  } 
  res, err = vm.ExecuteBindgen(&quot;sha3_digest&quot;, wasmedge.Bindgen_return_array, []byte(&quot;This is an important message&quot;))
  if err == nil {
    fmt.Println(&quot;Run bindgen -- sha3_digest:&quot;, res.([]byte))
  } 
  res, err = vm.ExecuteBindgen(&quot;keccak_digest&quot;, wasmedge.Bindgen_return_array, []byte(&quot;This is an important message&quot;))
  if err == nil {
    fmt.Println(&quot;Run bindgen -- keccak_digest:&quot;, res.([]byte))
  } 

  vm.Release()
  conf.Release()
}
</code></pre>
<p>Next, let's build the Go application with the WasmEdge Go SDK.</p>
<pre><code class="language-bash">go get github.com/second-state/WasmEdge-go/wasmedge@v0.9.1
go build
</code></pre>
<p>Run the Go application and it will run the WebAssembly functions embedded in the WasmEdge runtime.</p>
<pre><code class="language-bash">$ ./bindgen_funcs rust_bindgen_funcs/pkg/rust_bindgen_funcs_lib_bg.wasm
Run bindgen -- say: hello bindgen funcs test
Run bindgen -- obfusticate: N dhvpx oebja sbk whzcf bire gur ynml qbt
Run bindgen -- lowest_common_multiple: 246
Run bindgen -- sha3_digest: [87 27 231 209 189 105 251 49 159 10 211 250 15 159 154 181 43 218 26 141 56 199 25 45 60 10 20 163 54 211 195 203]
Run bindgen -- keccak_digest: [126 194 241 200 151 116 227 33 216 99 159 22 107 3 177 169 216 191 114 156 174 193 32 159 246 228 245 133 52 75 55 27]
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="wasmedge-go-api-references"><a class="header" href="#wasmedge-go-api-references">WasmEdge Go API references</a></h1>
<p>The followings are the guides to working with the WasmEdge-Go SDK.</p>
<h2 id="table-of-contents-2"><a class="header" href="#table-of-contents-2">Table of Contents</a></h2>
<ul>
<li><a href="embed/go/ref.html#getting-started">Getting Started</a>
<ul>
<li><a href="embed/go/ref.html#wasmedge-installation">WasmEdge Installation</a></li>
<li><a href="embed/go/ref.html#get-wasmedge-go">Get WasmEdge-go</a></li>
<li><a href="embed/go/ref.html#wasmedge-go-extensions">WasmEdge-go Extensions</a></li>
<li><a href="embed/go/ref.html#example-of-embedding-a-function-with-wasmedge-bindgen">Example of Embedding A Function with wasmedge-bindgen</a></li>
<li><a href="embed/go/ref.html#example-of-embedding-a-full-wasi-program">Example of Embedding A Full WASI Program</a></li>
</ul>
</li>
<li><a href="embed/go/ref.html#wasmedge-go-basics">WasmEdge-go Basics</a>
<ul>
<li><a href="embed/go/ref.html#version">Version</a></li>
<li><a href="embed/go/ref.html#logging-settings">Logging Settings</a></li>
<li><a href="embed/go/ref.html#value-types">Value Types</a></li>
<li><a href="embed/go/ref.html#results">Results</a></li>
<li><a href="embed/go/ref.html#contexts-and-their-life-cycles">Contexts And Their Life Cycles</a></li>
<li><a href="embed/go/ref.html#wasm-data-structures">WASM data structures</a></li>
<li><a href="embed/go/ref.html#configurations">Configurations</a></li>
</ul>
</li>
<li><a href="embed/go/ref.html#wasmedge-vm">WasmEdge VM</a>
<ul>
<li><a href="embed/go/ref.html#wasm-execution-example-with-vm-object">WASM Execution Example With VM Object</a></li>
<li><a href="embed/go/ref.html#vm-creations">VM Creations</a></li>
<li><a href="embed/go/ref.html#preregistrations">Preregistrations</a></li>
<li><a href="embed/go/ref.html#host-module-registrations">Host Module Registrations</a></li>
<li><a href="embed/go/ref.html#wasm-registrations-and-executions">WASM Registrations And Executions</a></li>
<li><a href="embed/go/ref.html#instance-tracing">Instance Tracing</a></li>
</ul>
</li>
<li><a href="embed/go/ref.html#wasmedge-runtime">WasmEdge Runtime</a>
<ul>
<li><a href="embed/go/ref.html#wasm-execution-example-step-by-step">WASM Execution Example Step-By-Step</a></li>
<li><a href="embed/go/ref.html#loader">Loader</a></li>
<li><a href="embed/go/ref.html#validator">Validator</a></li>
<li><a href="embed/go/ref.html#executor">Executor</a></li>
<li><a href="embed/go/ref.html#ast-module">AST Module</a></li>
<li><a href="embed/go/ref.html#store">Store</a></li>
<li><a href="embed/go/ref.html#instances">Instances</a></li>
<li><a href="embed/go/ref.html#host-functions">Host Functions</a></li>
</ul>
</li>
<li><a href="embed/go/ref.html#wasmedge-aot-compiler">WasmEdge AOT Compiler</a>
<ul>
<li><a href="embed/go/ref.html#compilation-example">Compilation Example</a></li>
<li><a href="embed/go/ref.html#compiler-options">Compiler Options</a></li>
</ul>
</li>
</ul>
<h2 id="getting-started-3"><a class="header" href="#getting-started-3">Getting Started</a></h2>
<p>The WasmEdge-go requires golang version &gt;= 1.15. Please check your golang version before installation. Developers can <a href="https://golang.org/dl/">download golang here</a>.</p>
<pre><code class="language-bash">$ go version
go version go1.16.5 linux/amd64
</code></pre>
<h3 id="wasmedge-installation-1"><a class="header" href="#wasmedge-installation-1">WasmEdge Installation</a></h3>
<p>Developers must <a href="embed/go/start/install.html">install the WasmEdge shared library</a> with the same <code>WasmEdge-go</code> release or pre-release version.</p>
<pre><code class="language-bash">curl -sSf https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/utils/install.sh | bash -s -- -v 0.9.1
</code></pre>
<p>For the developers need the <code>TensorFlow</code> or <code>Image</code> extension for <code>WasmEdge-go</code>, please install the <code>WasmEdge</code> with extensions:</p>
<pre><code class="language-bash">curl -sSf https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/utils/install.sh | bash -s -- -e tf,image -v 0.9.1
</code></pre>
<p>Noticed that the <code>TensorFlow</code> and <code>Image</code> extensions are only for the <code>Linux</code> platforms.
After installation, developers can use the <code>source</code> command to update the include and linking searching path.</p>
<h3 id="get-wasmedge-go"><a class="header" href="#get-wasmedge-go">Get WasmEdge-go</a></h3>
<p>After the WasmEdge installation, developers can get the <code>WasmEdge-go</code> package and build it in your Go project directory.</p>
<pre><code class="language-bash">go get github.com/second-state/WasmEdge-go/wasmedge@v0.9.1
go build
</code></pre>
<h3 id="wasmedge-go-extensions-1"><a class="header" href="#wasmedge-go-extensions-1">WasmEdge-go Extensions</a></h3>
<p>By default, the <code>WasmEdge-go</code> only turns on the basic runtime.</p>
<p><code>WasmEdge-go</code> has the following extensions (on the Linux platforms only):</p>
<ul>
<li>
<p>Tensorflow</p>
<ul>
<li>
<p>This extension supports the host functions in <a href="https://github.com/second-state/WasmEdge-tensorflow">WasmEdge-tensorflow</a>.</p>
</li>
<li>
<p>The <code>TensorFlow</code> extension when installing <code>WasmEdge</code> is required. Please install <code>WasmEdge</code> with the <code>-e tensorflow</code> command.</p>
</li>
<li>
<p>For using this extension, the tag <code>tensorflow</code> when building is required:</p>
<pre><code class="language-bash">go build -tags tensorflow
</code></pre>
</li>
</ul>
</li>
<li>
<p>Image</p>
<ul>
<li>
<p>This extension supports the host functions in <a href="https://github.com/second-state/WasmEdge-image">WasmEdge-image</a>.</p>
</li>
<li>
<p>The <code>Image</code> extension when installing <code>WasmEdge</code> is required. Please install <code>WasmEdge</code> with the <code>-e image</code> command.</p>
</li>
<li>
<p>For using this extension, the tag <code>image</code> when building is required:</p>
<pre><code class="language-bash">go build -tags image
</code></pre>
</li>
</ul>
</li>
</ul>
<p>Users can also turn on the multiple extensions when building:</p>
<pre><code class="language-bash">go build -tags image,tensorflow
</code></pre>
<h3 id="example-of-embedding-a-function-with-wasmedge-bindgen"><a class="header" href="#example-of-embedding-a-function-with-wasmedge-bindgen">Example of Embedding A Function with wasmedge-bindgen</a></h3>
<p>In <a href="https://github.com/second-state/WasmEdge-go-examples/tree/master/wasmedge-bindgen/go_BindgenFuncs">this example</a>, we will demonstrate how to call a few simple WebAssembly functions with wasmedge-bindgen from a Golang app. The <a href="https://github.com/second-state/WasmEdge-go-examples/blob/master/wasmedge-bindgen/go_BindgenFuncs/rust_bindgen_funcs/src/lib.rs">functions</a> are written in Rust, and require complex call parameters and return values.</p>
<p>While the WebAssembly only supports a few simple data types out of the box. It <a href="https://medium.com/wasm/strings-in-webassembly-wasm-57a05c1ea333">does not support</a> types such as string and array. In order to pass rich types in Golang to WebAssembly, the compiler needs to convert them to simple integers. For example, it converts a string into an integer memory address and an integer length. The <code>#[wasmedge_bindgen]</code> macro does this conversion automatically, combining it with Golang's <code>wasmedge-bindgen</code> package to auto-generate the correct code to pass call parameters from Golang to WebAssembly.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use wasmedge_bindgen::*;
use wasmedge_bindgen_macro::*;
use num_integer::lcm;
use sha3::{Digest, Sha3_256, Keccak256};
use serde::{Serialize, Deserialize};

#[derive(Serialize, Deserialize, Debug)]
struct Point {
  x: f32,
  y: f32
}

#[derive(Serialize, Deserialize, Debug)]
struct Line {
  points: Vec&lt;Point&gt;,
  valid: bool,
  length: f32,
  desc: String
}

#[wasmedge_bindgen]
pub fn create_line(p1: String, p2: String, desc: String) -&gt; String {
  let point1: Point = serde_json::from_str(p1.as_str()).unwrap();
  let point2: Point = serde_json::from_str(p2.as_str()).unwrap();
  let length = ((point1.x - point2.x) * (point1.x - point2.x) + (point1.y - point2.y) * (point1.y - point2.y)).sqrt();

  let valid = if length == 0.0 { false } else { true };

  let line = Line { points: vec![point1, point2], valid: valid, length: length, desc: desc };

  return serde_json::to_string(&amp;line).unwrap();
}

#[wasmedge_bindgen]
pub fn say(s: String) -&gt; String {
  let r = String::from(&quot;hello &quot;);
  return r + s.as_str();
}

#[wasmedge_bindgen]
pub fn obfusticate(s: String) -&gt; String {
  (&amp;s).chars().map(|c| {
    match c {
      'A' ..= 'M' | 'a' ..= 'm' =&gt; ((c as u8) + 13) as char,
      'N' ..= 'Z' | 'n' ..= 'z' =&gt; ((c as u8) - 13) as char,
      _ =&gt; c
    }
  }).collect()
}

#[wasmedge_bindgen]
pub fn lowest_common_multiple(a: i32, b: i32) -&gt; i32 {
  return lcm(a, b);
}

#[wasmedge_bindgen]
pub fn sha3_digest(v: Vec&lt;u8&gt;) -&gt; Vec&lt;u8&gt; {
  return Sha3_256::digest(&amp;v).as_slice().to_vec();
}

#[wasmedge_bindgen]
pub fn keccak_digest(s: Vec&lt;u8&gt;) -&gt; Vec&lt;u8&gt; {
  return Keccak256::digest(&amp;s).as_slice().to_vec();
}
<span class="boring">}
</span></code></pre></pre>
<p>First, compile the Rust source code into WebAssembly bytecode functions.</p>
<pre><code class="language-bash">rustup target add wasm32-wasi
cd rust_bindgen_funcs
cargo build --target wasm32-wasi --release
# The output WASM will be target/wasm32-wasi/release/rust_bindgen_funcs_lib.wasm
</code></pre>
<p>The <a href="https://github.com/second-state/WasmEdge-go-examples/blob/master/wasmedge-bindgen/go_BindgenFuncs/bindgen_funcs.go">Golang source code</a> to run the WebAssembly function in WasmEdge is as follows. The <code>bg.Execute()</code> function calls the WebAssembly function and passes the parameters with the <code>wasmedge-bindgen</code> supporting.</p>
<pre><code class="language-go">package main

import (
  &quot;fmt&quot;
  &quot;os&quot;

  &quot;github.com/second-state/WasmEdge-go/wasmedge&quot;
  bindgen &quot;github.com/second-state/wasmedge-bindgen/host/go&quot;
)

func main() {
  // Expected Args[0]: program name (./bindgen_funcs)
  // Expected Args[1]: wasm file (rust_bindgen_funcs_lib.wasm))
  
  // Set not to print debug info
  wasmedge.SetLogErrorLevel()

  // Create configure
  var conf = wasmedge.NewConfigure(wasmedge.WASI)

  // Create VM with configure
  var vm = wasmedge.NewVMWithConfig(conf)

  // Init WASI
  var wasi = vm.GetImportObject(wasmedge.WASI)
  wasi.InitWasi(
    os.Args[1:],     // The args
    os.Environ(),    // The envs
    []string{&quot;.:.&quot;}, // The mapping preopens
  )

  // Load and validate the wasm
  vm.LoadWasmFile(os.Args[1])
  vm.Validate()

  // Instantiate the bindgen and vm
  bg := bindgen.Instantiate(vm)

  // create_line: string, string, string -&gt; string (inputs are JSON stringified)  
  res, err := bg.Execute(&quot;create_line&quot;, &quot;{\&quot;x\&quot;:2.5,\&quot;y\&quot;:7.8}&quot;, &quot;{\&quot;x\&quot;:2.5,\&quot;y\&quot;:5.8}&quot;, &quot;A thin red line&quot;)
  if err == nil {
    fmt.Println(&quot;Run bindgen -- create_line:&quot;, res[0].(string))
  } else {
    fmt.Println(&quot;Run bindgen -- create_line FAILED&quot;, err)
  }

  // say: string -&gt; string
  res, err = bg.Execute(&quot;say&quot;, &quot;bindgen funcs test&quot;)
  if err == nil {
    fmt.Println(&quot;Run bindgen -- say:&quot;, res[0].(string))
  } else {
    fmt.Println(&quot;Run bindgen -- say FAILED&quot;)
  }

  // obfusticate: string -&gt; string
  res, err = bg.Execute(&quot;obfusticate&quot;, &quot;A quick brown fox jumps over the lazy dog&quot;)
  if err == nil {
    fmt.Println(&quot;Run bindgen -- obfusticate:&quot;, res[0].(string))
  } else {
    fmt.Println(&quot;Run bindgen -- obfusticate FAILED&quot;)
  }

  // lowest_common_multiple: i32, i32 -&gt; i32
  res, err = bg.Execute(&quot;lowest_common_multiple&quot;, int32(123), int32(2))
  if err == nil {
    fmt.Println(&quot;Run bindgen -- lowest_common_multiple:&quot;, res[0].(int32))
  } else {
    fmt.Println(&quot;Run bindgen -- lowest_common_multiple FAILED&quot;)
  }

  // sha3_digest: array -&gt; array
  res, err = bg.Execute(&quot;sha3_digest&quot;, []byte(&quot;This is an important message&quot;))
  if err == nil {
    fmt.Println(&quot;Run bindgen -- sha3_digest:&quot;, res[0].([]byte))
  } else {
    fmt.Println(&quot;Run bindgen -- sha3_digest FAILED&quot;)
  }

  // keccak_digest: array -&gt; array
  res, err = bg.Execute(&quot;keccak_digest&quot;, []byte(&quot;This is an important message&quot;))
  if err == nil {
    fmt.Println(&quot;Run bindgen -- keccak_digest:&quot;, res[0].([]byte))
  } else {
    fmt.Println(&quot;Run bindgen -- keccak_digest FAILED&quot;)
  }

  bg.Release()
  vm.Release()
  conf.Release()
}
</code></pre>
<p>Next, build the Golang application with the WasmEdge Golang SDK.</p>
<pre><code class="language-bash">go get github.com/second-state/WasmEdge-go/wasmedge@v0.9.1
go get github.com/second-state/wasmedge-bindgen@v0.1.12
go build
</code></pre>
<p>Run the Golang application and it will run the WebAssembly functions embedded in the WasmEdge runtime.</p>
<pre><code class="language-bash">$ ./bindgen_funcs rust_bindgen_funcs/target/wasm32-wasi/release/rust_bindgen_funcs_lib.wasm
Run bindgen -- create_line: {&quot;points&quot;:[{&quot;x&quot;:2.5,&quot;y&quot;:7.8},{&quot;x&quot;:2.5,&quot;y&quot;:5.8}],&quot;valid&quot;:true,&quot;length&quot;:2.0,&quot;desc&quot;:&quot;A thin red line&quot;}
Run bindgen -- say: hello bindgen funcs test
Run bindgen -- obfusticate: N dhvpx oebja sbk whzcf bire gur ynml qbt
Run bindgen -- lowest_common_multiple: 246
Run bindgen -- sha3_digest: [87 27 231 209 189 105 251 49 159 10 211 250 15 159 154 181 43 218 26 141 56 199 25 45 60 10 20 163 54 211 195 203]
Run bindgen -- keccak_digest: [126 194 241 200 151 116 227 33 216 99 159 22 107 3 177 169 216 191 114 156 174 193 32 159 246 228 245 133 52 75 55 27]
</code></pre>
<h3 id="example-of-embedding-a-full-wasi-program"><a class="header" href="#example-of-embedding-a-full-wasi-program">Example of Embedding A Full WASI Program</a></h3>
<p>Note: You can use the latest Rust compiler to create a standalone WasmEdge application with a <code>main.rs</code> functions and then embed it into a Golang application.</p>
<p>Besides functions, the WasmEdge Golang SDK can also <a href="https://github.com/second-state/WasmEdge-go-examples/tree/master/go_ReadFile">embed standalone WebAssembly applications</a> — i.e. a Rust application with a <code>main()</code> function compiled into WebAssembly.</p>
<p>Our <a href="https://github.com/second-state/WasmEdge-go-examples/tree/master/go_ReadFile/rust_readfile">demo Rust application</a> reads from a file.</p>
<pre><pre class="playground"><code class="language-rust">use std::env;
use std::fs::File;
use std::io::{self, BufRead};

fn main() {
  // Get the argv.
  let args: Vec&lt;String&gt; = env::args().collect();
  if args.len() &lt;= 1 {
    println!(&quot;Rust: ERROR - No input file name.&quot;);
    return;
  }

  // Open the file.
  println!(&quot;Rust: Opening input file \&quot;{}\&quot;...&quot;, args[1]);
  let file = match File::open(&amp;args[1]) {
    Err(why) =&gt; {
      println!(&quot;Rust: ERROR - Open file \&quot;{}\&quot; failed: {}&quot;, args[1], why);
      return;
    },
    Ok(file) =&gt; file,
  };

  // Read lines.
  let reader = io::BufReader::new(file);
  let mut texts:Vec&lt;String&gt; = Vec::new();
  for line in reader.lines() {
    if let Ok(text) = line {
      texts.push(text);
    }
  }
  println!(&quot;Rust: Read input file \&quot;{}\&quot; succeeded.&quot;, args[1]);

  // Get stdin to print lines.
  println!(&quot;Rust: Please input the line number to print the line of file.&quot;);
  let stdin = io::stdin();
  for line in stdin.lock().lines() {
    let input = line.unwrap();
    match input.parse::&lt;usize&gt;() {
      Ok(n) =&gt; if n &gt; 0 &amp;&amp; n &lt;= texts.len() {
        println!(&quot;{}&quot;, texts[n - 1]);
      } else {
        println!(&quot;Rust: ERROR - Line \&quot;{}\&quot; is out of range.&quot;, n);
      },
      Err(e) =&gt; println!(&quot;Rust: ERROR - Input \&quot;{}\&quot; is not an integer: {}&quot;, input, e),
    }
  }
  println!(&quot;Rust: Process end.&quot;);
}
</code></pre></pre>
<p>Use the <code>rustwasmc</code> tool to compile the application into WebAssembly.</p>
<pre><code class="language-bash">cd rust_readfile
rustwasmc build
# The output file will be at `pkg/rust_readfile.wasm`.
</code></pre>
<p>Or you can compile the application into WebAssembly directly by <code>cargo</code>:</p>
<pre><code class="language-bash">cd rust_readfile
# Need to add the `wasm32-wasi` target.
rustup target add wasm32-wasi
cargo build --release --target=wasm32-wasi
# The output wasm will be at `target/wasm32-wasi/release/rust_readfile.wasm`.
</code></pre>
<p>The Golang source code to run the WebAssembly function in WasmEdge is as follows.</p>
<pre><code class="language-go">package main

import (
  &quot;os&quot;

  &quot;github.com/second-state/WasmEdge-go/wasmedge&quot;
)

func main() {
  wasmedge.SetLogErrorLevel()

  var conf = wasmedge.NewConfigure(wasmedge.REFERENCE_TYPES)
  conf.AddConfig(wasmedge.WASI)
  var vm = wasmedge.NewVMWithConfig(conf)
  var wasi = vm.GetImportObject(wasmedge.WASI)
  wasi.InitWasi(
    os.Args[1:],     // The args
    os.Environ(),    // The envs
    []string{&quot;.:.&quot;}, // The mapping directories
  )

  // Instantiate and run WASM &quot;_start&quot; function, which refers to the main() function
  vm.RunWasmFile(os.Args[1], &quot;_start&quot;)

  vm.Release()
  conf.Release()
}
</code></pre>
<p>Next, build the Golang application with the WasmEdge Golang SDK.</p>
<pre><code class="language-bash">go get github.com/second-state/WasmEdge-go/wasmedge@v0.9.1
go build
</code></pre>
<p>Run the Golang application.</p>
<pre><code class="language-bash">$ ./read_file rust_readfile/pkg/rust_readfile.wasm file.txt
Rust: Opening input file &quot;file.txt&quot;...
Rust: Read input file &quot;file.txt&quot; succeeded.
Rust: Please input the line number to print the line of file.
# Input &quot;5&quot; and press Enter.
5
# The output will be the 5th line of `file.txt`:
abcDEF___!@#$%^
# To terminate the program, send the EOF (Ctrl + D).
^D
# The output will print the terminate message:
Rust: Process end.
</code></pre>
<p>For more examples, please refer to the <a href="https://github.com/second-state/WasmEdge-go-examples/">example repository</a>.</p>
<h2 id="wasmedge-go-basics"><a class="header" href="#wasmedge-go-basics">WasmEdge-go Basics</a></h2>
<p>In this partition, we will introduce the utilities and concepts of WasmEdge-go APIs and data structures.</p>
<h3 id="version-1"><a class="header" href="#version-1">Version</a></h3>
<p>The <code>Version</code> related APIs provide developers to check for the installed WasmEdge shared library version.</p>
<pre><code class="language-go">import &quot;github.com/second-state/WasmEdge-go/wasmedge&quot;

verstr := wasmedge.GetVersion() // Will be `string` of WasmEdge version.
vermajor := wasmedge.GetVersionMajor() // Will be `uint` of WasmEdge major version number.
verminor := wasmedge.GetVersionMinor() // Will be `uint` of WasmEdge minor version number.
verpatch := wasmedge.GetVersionPatch() // Will be `uint` of WasmEdge patch version number.
</code></pre>
<h3 id="logging-settings-1"><a class="header" href="#logging-settings-1">Logging Settings</a></h3>
<p>The <code>wasmedge.SetLogErrorLevel()</code> and <code>wasmedge.SetLogDebugLevel()</code> APIs can set the logging system to debug level or error level. By default, the error level is set, and the debug info is hidden.</p>
<h3 id="value-types-1"><a class="header" href="#value-types-1">Value Types</a></h3>
<p>In WasmEdge-go, the APIs will automatically do the conversion for the built-in types, and implement the data structure for the reference types.</p>
<ol>
<li>
<p>Number types: <code>i32</code>, <code>i64</code>, <code>f32</code>, and <code>f64</code></p>
<ul>
<li>Convert the <code>uint32</code> and <code>int32</code> to <code>i32</code> automatically when passing a value into WASM.</li>
<li>Convert the <code>uint64</code> and <code>int64</code> to <code>i64</code> automatically when passing a value into WASM.</li>
<li>Convert the <code>uint</code> and <code>int</code> to <code>i32</code> automatically when passing a value into WASM in 32-bit system.</li>
<li>Convert the <code>uint</code> and <code>int</code> to <code>i64</code> automatically when passing a value into WASM in 64-bit system.</li>
<li>Convert the <code>float32</code> to <code>f32</code> automatically when passing a value into WASM.</li>
<li>Convert the <code>float64</code> to <code>f64</code> automatically when passing a value into WASM.</li>
<li>Convert the <code>i32</code> from WASM to <code>int32</code> when getting a result.</li>
<li>Convert the <code>i64</code> from WASM to <code>int64</code> when getting a result.</li>
<li>Convert the <code>f32</code> from WASM to <code>float32</code> when getting a result.</li>
<li>Convert the <code>f64</code> from WASM to <code>float64</code> when getting a result.</li>
</ul>
</li>
<li>
<p>Number type: <code>v128</code> for the <code>SIMD</code> proposal</p>
<p>Developers should use the <code>wasmedge.NewV128()</code> to generate a <code>v128</code> value, and use the <code>wasmedge.GetV128()</code> to get the value.</p>
<pre><code class="language-go">val := wasmedge.NewV128(uint64(1234), uint64(5678))
high, low := val.GetVal()
// `high` will be uint64(1234), `low` will be uint64(5678)
</code></pre>
</li>
<li>
<p>Reference types: <code>FuncRef</code> and <code>ExternRef</code> for the <code>Reference-Types</code> proposal</p>
<pre><code class="language-go">funcref := wasmedge.NewFuncRef(10)
// Create a `FuncRef` with function index 10.

num := 1234
// `num` is a `int`.
externref := wasmedge.NewExternRef(&amp;num)
// Create an `ExternRef` which reference to the `num`.
num = 5678
// Modify the `num` to 5678.
numref := externref.GetRef().(*int)
// Get the original reference from the `ExternRef`.
fmt.Println(*numref)
// Will print `5678`.
numref.Release()
// Should call the `Release` method.
</code></pre>
</li>
</ol>
<h3 id="results-1"><a class="header" href="#results-1">Results</a></h3>
<p>The <code>Result</code> object specifies the execution status. Developers can use the <code>Error()</code> function to get the error message.</p>
<pre><code class="language-go">// Assume that `vm` is a `wasmedge.VM` object.
res, err = vm.Execute(...) // Ignore the detail of parameters.
// Assume that `res, err` are the return values for executing a function with `vm`.
if err != nil {
  fmt.Println(&quot;Error message:&quot;, err.Error())
}
</code></pre>
<h3 id="contexts-and-their-life-cycles"><a class="header" href="#contexts-and-their-life-cycles">Contexts And Their Life Cycles</a></h3>
<p>The objects, such as <code>VM</code>, <code>Store</code>, and <code>Function</code>, etc., are composed of <code>Context</code>s in the WasmEdge shared library.
All of the contexts can be created by calling the corresponding <code>New</code> APIs, developers should also call the corresponding <code>Release</code> functions of the contexts to release the resources.
Noticed that it's not necessary to call the <code>Release</code> functions for the contexts which are retrieved from other contexts but not created from the <code>New</code> APIs.</p>
<pre><code class="language-go">// Create a Configure.
conf := wasmedge.NewConfigure()
// Release the `conf` immediately.
conf.Release()
</code></pre>
<p>The details of other contexts will be introduced later.</p>
<h3 id="wasm-data-structures-1"><a class="header" href="#wasm-data-structures-1">WASM Data Structures</a></h3>
<p>The WASM data structures are used for creating instances or can be queried from instance contexts.
The details of instances creation will be introduced in the <a href="embed/go/ref.html#Instances">Instances</a>.</p>
<ol>
<li>
<p>Limit</p>
<p>The <code>Limit</code> struct presents the minimum and maximum value data structure.</p>
<pre><code class="language-go">lim1 := wasmedge.NewLimit(12)
fmt.Println(lim1.HasMax())
// Will print `false`.
fmt.Println(lim1.GetMin())
// Will print `12`.

lim2 := wasmedge.NewLimitWithMax(15, 50)
fmt.Println(lim2.HasMax())
// Will print `true`.
fmt.Println(lim2.GetMin())
// Will print `15`.
fmt.Println(lim2.GetMax())
// Will print `50`.
</code></pre>
</li>
<li>
<p>Function type context</p>
<p>The <code>FunctionType</code> is an object holds the function type context and used for the <code>Function</code> creation, checking the value types of a <code>Function</code> instance, or getting the function type with function name from VM.
Developers can use the <code>FunctionType</code> APIs to get the parameter or return value types information.</p>
<pre><code class="language-go">functype := wasmedge.NewFunctionType(
  []wasmedge.ValType{
    wasmedge.ValType_ExternRef,
    wasmedge.ValType_I32,
    wasmedge.ValType_I64,
  }, []wasmedge.ValType{
    wasmedge.ValType_F32,
    wasmedge.ValType_F64,
  })

plen := functype.GetParametersLength()
// `plen` will be 3.
rlen := functype.GetReturnsLength()
// `rlen` will be 2.
plist := functype.GetParameters()
// `plist` will be `[]wasmedge.ValType{wasmedge.ValType_ExternRef, wasmedge.ValType_I32, wasmedge.ValType_I64}`.
rlist := functype.GetReturns()
// `rlist` will be `[]wasmedge.ValType{wasmedge.ValType_F32, wasmedge.ValType_F64}`.

functype.Release()
</code></pre>
</li>
<li>
<p>Table type context</p>
<p>The <code>TableType</code> is an object holds the table type context and used for <code>Table</code> instance creation or getting information from <code>Table</code> instances.</p>
<pre><code class="language-go">lim := wasmedge.NewLimit(12)
tabtype := wasmedge.NewTableType(wasmedge.RefType_ExternRef, lim)

rtype := tabtype.GetRefType()
// `rtype` will be `wasmedge.RefType_ExternRef`.
getlim := tabtype.GetLimit()
// `getlim` will be the same value as `lim`.

tabtype.Release()
</code></pre>
</li>
<li>
<p>Memory type context</p>
<p>The <code>MemoryType</code> is an object holds the memory type context and used for <code>Memory</code> instance creation or getting information from <code>Memory</code> instances.</p>
<pre><code class="language-go">lim := wasmedge.NewLimit(1)
memtype := wasmedge.NewMemoryType(lim)

getlim := memtype.GetLimit()
// `getlim` will be the same value as `lim`.

memtype.Release()
</code></pre>
</li>
<li>
<p>Global type context</p>
<p>The <code>GlobalType</code> is an object holds the global type context and used for <code>Global</code> instance creation or getting information from <code>Global</code> instances.</p>
<pre><code class="language-go">globtype := wasmedge.NewGlobalType(wasmedge.ValType_F64, wasmedge.ValMut_Var)

vtype := globtype.GetValType()
// `vtype` will be `wasmedge.ValType_F64`.
vmut := globtype.GetMutability()
// `vmut` will be `wasmedge.ValMut_Var`.

globtype.Release()
</code></pre>
</li>
<li>
<p>Import type context</p>
<p>The <code>ImportType</code> is an object holds the import type context and used for getting the imports information from a <a href="embed/go/ref.html#AST-Module">AST Module</a>.
Developers can get the external type (<code>function</code>, <code>table</code>, <code>memory</code>, or <code>global</code>), import module name, and external name from an <code>ImportType</code> object.
The details about querying <code>ImportType</code> objects will be introduced in the <a href="embed/go/ref.html#AST-Module">AST Module</a>.</p>
<pre><code class="language-go">var ast *wasmedge.AST = ...
// Assume that `ast` is returned by the `Loader` for the result of loading a WASM file.
imptypelist := ast.ListImports()
// Assume that `imptypelist` is an array listed from the `ast` for the imports.

for i, imptype := range imptypelist {
  exttype := imptype.GetExternalType()
  // The `exttype` must be one of `wasmedge.ExternType_Function`, `wasmedge.ExternType_Table`,
  // wasmedge.ExternType_Memory`, or `wasmedge.ExternType_Global`.

  modname := imptype.GetModuleName()
  extname := imptype.GetExternalName()
  // Get the module name and external name of the imports.

  extval := imptype.GetExternalValue()
  // The `extval` is the type of `interface{}` which indicates one of `*wasmedge.FunctionType`,
  // `*wasmedge.TableType`, `*wasmedge.MemoryType`, or `*wasmedge.GlobalType`.
}
</code></pre>
</li>
<li>
<p>Export type context</p>
<p>The <code>ExportType</code> is an object holds the export type context is used for getting the exports information from a <a href="embed/go/ref.html#AST-Module">AST Module</a>.
Developers can get the external type (<code>function</code>, <code>table</code>, <code>memory</code>, or <code>global</code>) and external name from an <code>Export Type</code> context.
The details about querying <code>ExportType</code> objects will be introduced in the <a href="embed/go/ref.html#AST-Module">AST Module</a>.</p>
<pre><code class="language-go">var ast *wasmedge.AST = ...
// Assume that `ast` is returned by the `Loader` for the result of loading a WASM file.
exptypelist := ast.ListExports()
// Assume that `exptypelist` is an array listed from the `ast` for the exports.

for i, exptype := range exptypelist {
  exttype := exptype.GetExternalType()
  // The `exttype` must be one of `wasmedge.ExternType_Function`, `wasmedge.ExternType_Table`,
  // wasmedge.ExternType_Memory`, or `wasmedge.ExternType_Global`.

  extname := exptype.GetExternalName()
  // Get the external name of the exports.

  extval := exptype.GetExternalValue()
  // The `extval` is the type of `interface{}` which indicates one of `*wasmedge.FunctionType`,
  // `*wasmedge.TableType`, `*wasmedge.MemoryType`, or `*wasmedge.GlobalType`.
}
</code></pre>
</li>
</ol>
<h3 id="configurations-1"><a class="header" href="#configurations-1">Configurations</a></h3>
<p>The configuration object, <code>wasmedge.Configure</code>, manages the configurations for <code>Loader</code>, <code>Validator</code>, <code>Executor</code>, <code>VM</code>, and <code>Compiler</code>.
Developers can adjust the settings about the proposals, VM host pre-registrations (such as <code>WASI</code>), and AOT compiler options, and then apply the <code>Configure</code> object to create other runtime objects.</p>
<ol>
<li>
<p>Proposals</p>
<p>WasmEdge supports turning on or off the WebAssembly proposals.
This configuration is effective in any contexts created with the <code>Configure</code> object.</p>
<pre><code class="language-go">const (
  IMPORT_EXPORT_MUT_GLOBALS         = Proposal(C.WasmEdge_Proposal_ImportExportMutGlobals)
  NON_TRAP_FLOAT_TO_INT_CONVERSIONS = Proposal(C.WasmEdge_Proposal_NonTrapFloatToIntConversions)
  SIGN_EXTENSION_OPERATORS          = Proposal(C.WasmEdge_Proposal_SignExtensionOperators)
  MULTI_VALUE                       = Proposal(C.WasmEdge_Proposal_MultiValue)
  BULK_MEMORY_OPERATIONS            = Proposal(C.WasmEdge_Proposal_BulkMemoryOperations)
  REFERENCE_TYPES                   = Proposal(C.WasmEdge_Proposal_ReferenceTypes)
  SIMD                              = Proposal(C.WasmEdge_Proposal_SIMD)
  TAIL_CALL                         = Proposal(C.WasmEdge_Proposal_TailCall)
  ANNOTATIONS                       = Proposal(C.WasmEdge_Proposal_Annotations)
  MEMORY64                          = Proposal(C.WasmEdge_Proposal_Memory64)
  THREADS                           = Proposal(C.WasmEdge_Proposal_Threads)
  EXCEPTION_HANDLING                = Proposal(C.WasmEdge_Proposal_ExceptionHandling)
  FUNCTION_REFERENCES               = Proposal(C.WasmEdge_Proposal_FunctionReferences)
)
</code></pre>
<p>Developers can add or remove the proposals into the <code>Configure</code> object.</p>
<pre><code class="language-go">// By default, the following proposals have turned on initially:
// * IMPORT_EXPORT_MUT_GLOBALS
// * NON_TRAP_FLOAT_TO_INT_CONVERSIONS
// * SIGN_EXTENSION_OPERATORS
// * MULTI_VALUE
// * BULK_MEMORY_OPERATIONS
// * REFERENCE_TYPES
// * SIMD
conf := wasmedge.NewConfigure()
// Developers can also pass the proposals as parameters:
// conf := wasmedge.NewConfigure(wasmedge.SIMD, wasmedge.BULK_MEMORY_OPERATIONS)
conf.AddConfig(wasmedge.SIMD)
conf.RemoveConfig(wasmedge.REFERENCE_TYPES)
is_bulkmem := conf.HasConfig(wasmedge.BULK_MEMORY_OPERATIONS)
// The `is_bulkmem` will be `true`.
conf.Release()
</code></pre>
</li>
<li>
<p>Host registrations</p>
<p>This configuration is used for the <code>VM</code> context to turn on the <code>WASI</code> or <code>wasmedge_process</code> supports and only effective in <code>VM</code> objects.</p>
<pre><code class="language-go">const (
  WASI             = HostRegistration(C.WasmEdge_HostRegistration_Wasi)
  WasmEdge_PROCESS = HostRegistration(C.WasmEdge_HostRegistration_WasmEdge_Process)
)
</code></pre>
<p>The details will be introduced in the <a href="embed/go/ref.html###Preregistrations">preregistrations of VM context</a>.</p>
<pre><code class="language-go">conf := wasmedge.NewConfigure()
// Developers can also pass the proposals as parameters:
// conf := wasmedge.NewConfigure(wasmedge.WASI)
conf.AddConfig(wasmedge.WASI)
conf.Release()
</code></pre>
</li>
<li>
<p>Maximum memory pages</p>
<p>Developers can limit the page size of memory instances by this configuration.
When growing the page size of memory instances in WASM execution and exceeding the limited size, the page growing will fail.
This configuration is only effective in the <code>Executor</code> and <code>VM</code> objects.</p>
<pre><code class="language-go">conf := wasmedge.NewConfigure()

pagesize := conf.GetMaxMemoryPage()
// By default, the maximum memory page size in each memory instances is 65536.
conf.SetMaxMemoryPage(1234)
pagesize := conf.GetMaxMemoryPage()
// `pagesize` will be 1234.

conf.Release()
</code></pre>
</li>
<li>
<p>AOT compiler options</p>
<p>The AOT compiler options configure the behavior about optimization level, output format, dump IR, and generic binary.</p>
<pre><code class="language-go">const (
  // Disable as many optimizations as possible.
  CompilerOptLevel_O0 = CompilerOptimizationLevel(C.WasmEdge_CompilerOptimizationLevel_O0)
  // Optimize quickly without destroying debuggability.
  CompilerOptLevel_O1 = CompilerOptimizationLevel(C.WasmEdge_CompilerOptimizationLevel_O1)
  // Optimize for fast execution as much as possible without triggering significant incremental compile time or code size growth.
  CompilerOptLevel_O2 = CompilerOptimizationLevel(C.WasmEdge_CompilerOptimizationLevel_O2)
  // Optimize for fast execution as much as possible.
  CompilerOptLevel_O3 = CompilerOptimizationLevel(C.WasmEdge_CompilerOptimizationLevel_O3)
  // Optimize for small code size as much as possible without triggering significant incremental compile time or execution time slowdowns.
  CompilerOptLevel_Os = CompilerOptimizationLevel(C.WasmEdge_CompilerOptimizationLevel_Os)
  // Optimize for small code size as much as possible.
  CompilerOptLevel_Oz = CompilerOptimizationLevel(C.WasmEdge_CompilerOptimizationLevel_Oz)
)

const (
  // Native dynamic library format.
  CompilerOutputFormat_Native = CompilerOutputFormat(C.WasmEdge_CompilerOutputFormat_Native)
  // WebAssembly with AOT compiled codes in custom section.
  CompilerOutputFormat_Wasm = CompilerOutputFormat(C.WasmEdge_CompilerOutputFormat_Wasm)
)
</code></pre>
<p>These configurations are only effective in <code>Compiler</code> contexts.</p>
<pre><code class="language-go">conf := wasmedge.NewConfigure()

// By default, the optimization level is O3.
conf.SetCompilerOptimizationLevel(wasmedge.CompilerOptLevel_O2)
// By default, the output format is universal WASM.
conf.SetCompilerOutputFormat(wasmedge.CompilerOutputFormat_Native)
// By default, the dump IR is `false`.
conf.SetCompilerDumpIR(true)
// By default, the generic binary is `false`.
conf.SetCompilerGenericBinary(true)

conf.Release()
</code></pre>
</li>
<li>
<p>Statistics options</p>
<p>The statistics options configure the behavior about instruction counting, cost measuring, and time measuring in both runtime and AOT compiler.
These configurations are effective in <code>Compiler</code>, <code>VM</code>, and <code>Executor</code> objects.</p>
<pre><code class="language-go">conf := wasmedge.NewConfigure()

// By default, the intruction counting is `false` when running a compiled-WASM or a pure-WASM.
conf.SetStatisticsInstructionCounting(true)
// By default, the cost measurement is `false` when running a compiled-WASM or a pure-WASM.
conf.SetStatisticsTimeMeasuring(true)
// By default, the time measurement is `false` when running a compiled-WASM or a pure-WASM.
conf.SetStatisticsCostMeasuring(true)

conf.Release()
</code></pre>
</li>
</ol>
<h2 id="wasmedge-vm-1"><a class="header" href="#wasmedge-vm-1">WasmEdge VM</a></h2>
<p>In this partition, we will introduce the functions of <code>wasmedge.VM</code> object and show examples of executing WASM functions.</p>
<h3 id="wasm-execution-example-with-vm-object"><a class="header" href="#wasm-execution-example-with-vm-object">WASM Execution Example With VM Object</a></h3>
<p>The following shows the example of running the WASM for getting the Fibonacci.
This example uses the <a href="https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/tools/wasmedge/examples/fibonacci.wasm">fibonacci.wasm</a>, and the corresponding WAT file is at <a href="https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/tools/wasmedge/examples/fibonacci.wat">fibonacci.wat</a>.</p>
<pre><code class="language-wasm">(module
 (export &quot;fib&quot; (func $fib))
 (func $fib (param $n i32) (result i32)
  (if
   (i32.lt_s (get_local $n)(i32.const 2))
   (return (i32.const 1))
  )
  (return
   (i32.add
    (call $fib (i32.sub (get_local $n)(i32.const 2)))
    (call $fib (i32.sub (get_local $n)(i32.const 1)))
   )
  )
 )
)
</code></pre>
<ol>
<li>
<p>Run WASM functions rapidly</p>
<p>Create a new Go project first:</p>
<pre><code class="language-bash">mkdir wasmedge_test &amp;&amp; cd wasmedge_test
go mod init wasmedge_test
</code></pre>
<p>Assume that the WASM file <a href="https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/tools/wasmedge/examples/fibonacci.wasm"><code>fibonacci.wasm</code></a> is copied into the current <code>wasmedge_test</code> directory, and create and edit the Go file <code>main.go</code> as following:</p>
<pre><code class="language-go">package main

import (
  &quot;fmt&quot;

  &quot;github.com/second-state/WasmEdge-go/wasmedge&quot;
)

func main() {
  // Set the logging level.
  wasmedge.SetLogErrorLevel()

  // Create the configure context and add the WASI support.
  // This step is not necessary unless you need WASI support.
  conf := wasmedge.NewConfigure(wasmedge.WASI)
  // Create VM with the configure.
  vm := wasmedge.NewVMWithConfig(conf)

  res, err := vm.RunWasmFile(&quot;fibonacci.wasm&quot;, &quot;fib&quot;, uint32(21))
  if err == nil {
    fmt.Println(&quot;Get fibonacci[21]:&quot;, res[0].(int32))
  } else {
    fmt.Println(&quot;Run failed:&quot;, err.Error())
  }

  vm.Release()
  conf.Release()
}
</code></pre>
<p>Then you can build and run the Golang application with the WasmEdge Golang SDK: (the 21 Fibonacci number is 17711 in 0-based index)</p>
<pre><code class="language-bash">$ go get github.com/second-state/WasmEdge-go/wasmedge@v0.9.1
$ go build
$ ./wasmedge_test
Get fibonacci[21]: 17711
</code></pre>
</li>
<li>
<p>Instantiate and run WASM functions manually</p>
<p>Besides the above example, developers can run the WASM functions step-by-step with <code>VM</code> object APIs:</p>
<pre><code class="language-go">package main

import (
  &quot;fmt&quot;

  &quot;github.com/second-state/WasmEdge-go/wasmedge&quot;
)

func main() {
  // Set the logging level.
  wasmedge.SetLogErrorLevel()

  // Create VM.
  vm := wasmedge.NewVM()
  var err error
  var res []interface{}

  // Step 1: Load WASM file.
  err = vm.LoadWasmFile(&quot;fibonacci.wasm&quot;)
  if err != nil {
    fmt.Println(&quot;Load WASM from file FAILED:&quot;, err.Error())
    return
  }

  // Step 2: Validate the WASM module.
  err = vm.Validate()
  if err != nil {
    fmt.Println(&quot;Validation FAILED:&quot;, err.Error())
    return
  }

  // Step 3: Instantiate the WASM module.
  err = vm.Instantiate()
  // Developers can load, validate, and instantiate another WASM module
  // to replace the instantiated one. In this case, the old module will
  // be cleared, but the registered modules are still kept.
  if err != nil {
    fmt.Println(&quot;Instantiation FAILED:&quot;, err.Error())
    return
  }

  // Step 4: Execute WASM functions. Parameters: (funcname, args...)
  res, err = vm.Execute(&quot;fib&quot;, uint32(25))
  // Developers can execute functions repeatedly after instantiation.
  if err == nil {
    fmt.Println(&quot;Get fibonacci[25]:&quot;, res[0].(int32))
  } else {
    fmt.Println(&quot;Run failed:&quot;, err.Error())
  }

  vm.Release()
}
</code></pre>
<p>Then you can build and run: (the 25th Fibonacci number is 121393 in 0-based index)</p>
<pre><code class="language-bash">$ go build
$ ./wasmedge_test
Get fibonacci[25]: 121393
</code></pre>
<p>The following graph explains the status of the <code>VM</code> object.</p>
<pre><code class="language-text">                       |========================|
              |-------&gt;|      VM: Initiated     |
              |        |========================|
              |                    |
              |                 LoadWasm
              |                    |
              |                    v
              |        |========================|
              |--------|       VM: Loaded       |&lt;-------|
              |        |========================|        |
              |              |            ^              |
              |         Validate          |              |
          Cleanup            |          LoadWasm         |
              |              v            |            LoadWasm
              |        |========================|        |
              |--------|      VM: Validated     |        |
              |        |========================|        |
              |              |            ^              |
              |      Instantiate          |              |
              |              |          RegisterModule   |
              |              v            |              |
              |        |========================|        |
              |--------|    VM: Instantiated    |--------|
                       |========================|
                             |            ^
                             |            |
                             --------------
                Instantiate, Execute, ExecuteRegistered,
                ExecuteBindgen, ExecuteBindgenRegistered
</code></pre>
<p>The status of the <code>VM</code> context would be <code>Inited</code> when created.
After loading WASM successfully, the status will be <code>Loaded</code>.
After validating WASM successfully, the status will be <code>Validated</code>.
After instantiating WASM successfully, the status will be <code>Instantiated</code>, and developers can invoke functions.
Developers can register WASM or import objects in any status, but they should instantiate WASM again.
Developers can also load WASM in any status, and they should validate and instantiate the WASM module before function invocation.
When in the <code>Instantiated</code> status, developers can instantiate the WASM module again to reset the old WASM runtime structures.</p>
</li>
</ol>
<h3 id="vm-creations-1"><a class="header" href="#vm-creations-1">VM Creations</a></h3>
<p>The <code>VM</code> creation APIs accepts the <code>Configure</code> object and the <code>Store</code> object.
Noticed that if the <code>VM</code> created with the outside <code>Store</code> object, the <code>VM</code> will execute WASM on that <code>Store</code> object. If the <code>Store</code> object is set into multiple <code>VM</code> objects, it may causes data conflict when in execution.
The details of the <code>Store</code> object will be introduced in <a href="embed/go/ref.html#Store">Store</a>.</p>
<pre><code class="language-go">conf := wasmedge.NewConfigure()
store := wasmedge.NewStore()

// Create a VM with default configure and store.
vm := wasmedge.NewVM()
vm.Release()

// Create a VM with the specified configure and default store.
vm = wasmedge.NewVMWithConfig(conf)
vm.Release()

// Create a VM with the default configure and specified store.
vm = wasmedge.NewVMWithStore(store)
vm.Release()

// Create a VM with the specified configure and store.
vm = wasmedge.NewVMWithConfigAndStore(conf, store)
vm.Release()

conf.Release()
store.Release()
</code></pre>
<h3 id="preregistrations-1"><a class="header" href="#preregistrations-1">Preregistrations</a></h3>
<p>WasmEdge provides the following built-in pre-registrations.</p>
<ol>
<li>
<p><a href="https://github.com/WebAssembly/WASI">WASI (WebAssembly System Interface)</a></p>
<p>Developers can turn on the WASI support for VM in the <code>Configure</code> object.</p>
<pre><code class="language-go">conf := wasmedge.NewConfigure(wasmedge.WASI)
// Or you can set the `wasmedge.WASI` into the configure object through `(*Configure).AddConfig`.
vm := wasmedge.NewVMWithConfig(conf)
vm.Release()

// The following API can retrieve the pre-registration import objects from the VM object.
// This API will return `nil` if the corresponding pre-registration is not set into the configuration.
wasiconf := conf.GetImportObject(wasmedge.WASI)
// Initialize the WASI.
wasiconf.InitWasi(/* ... ignored */)

conf.Release()
</code></pre>
<p>And also can create the WASI import object from API. The details will be introduced in the <a href="embed/go/ref.html#Host-Functions">Host Functions</a> and the <a href="embed/go/ref.html#Host-Module-Registrations">Host Module Registrations</a>.</p>
</li>
<li>
<p><a href="https://crates.io/crates/wasmedge_process_interface">WasmEdge_Process</a></p>
<p>This pre-registration is for the process interface for WasmEdge on <code>Rust</code> sources.
After turning on this pre-registration, the VM will support the <code>wasmedge_process</code> host functions.</p>
<pre><code class="language-go">conf := wasmedge.NewConfigure(wasmedge.WasmEdge_PROCESS)
vm := wasmedge.NewVMWithConfig(conf)
vm.Release()

// The following API can retrieve the pre-registration import objects from the VM object.
// This API will return `nil` if the corresponding pre-registration is not set into the configuration.
procconf := conf.GetImportObject(wasmedge.WasmEdge_PROCESS)
// Initialize the WasmEdge_Process.
procconf.InitWasmEdgeProcess(/* ... ignored */)

conf.Release()
</code></pre>
<p>And also can create the WasmEdge_Process import object from API. The details will be introduced in the <a href="embed/go/ref.html#Host-Functions">Host Functions</a> and the <a href="embed/go/ref.html#Host-Module-Registrations">Host Module Registrations</a>.</p>
</li>
</ol>
<h3 id="host-module-registrations-1"><a class="header" href="#host-module-registrations-1">Host Module Registrations</a></h3>
<p><a href="https://webassembly.github.io/spec/core/exec/runtime.html#syntax-hostfunc">Host functions</a> are functions outside WebAssembly and passed to WASM modules as imports.
In WasmEdge-go, the host functions are composed into host modules as <code>ImportObject</code> objects with module names.
Please refer to the <a href="embed/go/ref.html#Host-Functions">Host Functions in WasmEdge Runtime</a> for the details.
In this chapter, we show the example for registering the host modules into a <code>VM</code> object.</p>
<pre><code class="language-go">vm := wasmedge.NewVM()
// You can also create and register the WASI host modules by this API.
wasiobj := wasmedge.NewWasiImportObject(/* ... ignored ... */)

res := vm.RegisterImport(wasiobj)
// The result status should be checked.

vm.Release()
// The created import objects should be released.
wasiobj.Release()
</code></pre>
<h3 id="wasm-registrations-and-executions-1"><a class="header" href="#wasm-registrations-and-executions-1">WASM Registrations And Executions</a></h3>
<p>In WebAssembly, the instances in WASM modules can be exported and can be imported by other WASM modules.
WasmEdge VM provides APIs for developers to register and export any WASM modules, and execute the functions or host functions in the registered WASM modules.</p>
<ol>
<li>
<p>Register the WASM modules with exported module names</p>
<p>Unless the import objects have already contained the module names, every WASM module should be named uniquely when registering. The following shows the example.</p>
<p>Create a new Go project first:</p>
<pre><code class="language-bash">mkdir wasmedge_test &amp;&amp; cd wasmedge_test
go mod init wasmedge_test
</code></pre>
<p>Assume that the WASM file <a href="https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/tools/wasmedge/examples/fibonacci.wasm"><code>fibonacci.wasm</code></a> is copied into the current directory.
Then create and edit the Go file <code>main.go</code> as following:</p>
<pre><code class="language-go">package main

import &quot;github.com/second-state/WasmEdge-go/wasmedge&quot;

func main() {
  // Create VM.
  vm := wasmedge.NewVM()

  var err error
  err = vm.RegisterWasmFile(&quot;module_name&quot;, &quot;fibonacci.wasm&quot;)
  // Developers can register the WASM module from `[]byte` with the
  // `(*VM).RegisterWasmBuffer` function, or from `AST` object with
  // the `(*VM).RegisterAST` function.
  // The result status should be checked. The error will occur if the
  // WASM module instantiation failed or the module name conflicts.

  vm.Release()
}
</code></pre>
</li>
<li>
<p>Execute the functions in registered WASM modules</p>
<p>Edit the Go file <code>main.go</code> as following:</p>
<pre><code class="language-go">package main

import (
  &quot;fmt&quot;

  &quot;github.com/second-state/WasmEdge-go/wasmedge&quot;
)

func main() {
  // Create VM.
  vm := wasmedge.NewVM()

  var res []interface{}
  var err error
  // Register the WASM module from file into VM with the module name &quot;mod&quot;.
  err = vm.RegisterWasmFile(&quot;mod&quot;, &quot;fibonacci.wasm&quot;)
  // Developers can register the WASM module from `[]byte` with the
  // `(*VM).RegisterWasmBuffer` function, or from `AST` object with
  // the `(*VM).RegisterAST` function.
  if err != nil {
    fmt.Println(&quot;WASM registration failed:&quot;, err.Error())
    return
  }
  // The function &quot;fib&quot; in the &quot;fibonacci.wasm&quot; was exported with the module
  // name &quot;mod&quot;. As the same as host functions, other modules can import the
  // function `&quot;mod&quot; &quot;fib&quot;`.

  // Execute WASM functions in registered modules.
  // Unlike the execution of functions, the registered functions can be
  // invoked without `(*VM).Instantiate` because the WASM module was
  // instantiated when registering.
  // Developers can also invoke the host functions directly with this API.
  res, err = vm.ExecuteRegistered(&quot;mod&quot;, &quot;fib&quot;, int32(25))
  if err == nil {
    fmt.Println(&quot;Get fibonacci[25]:&quot;, res[0].(int32))
  } else {
    fmt.Println(&quot;Run failed:&quot;, err.Error())
  }

  vm.Release()
}
</code></pre>
<p>Then you can build and run: (the 25th Fibonacci number is 121393 in 0-based index)</p>
<pre><code class="language-bash">$ go get github.com/second-state/WasmEdge-go/wasmedge@v0.9.1
$ go build
$ ./wasmedge_test
Get fibonacci[25]: 121393
</code></pre>
</li>
</ol>
<h3 id="instance-tracing-1"><a class="header" href="#instance-tracing-1">Instance Tracing</a></h3>
<p>Sometimes the developers may have requirements to get the instances of the WASM runtime.
The <code>VM</code> object supplies the APIs to retrieve the instances.</p>
<ol>
<li>
<p>Store</p>
<p>If the <code>VM</code> object is created without assigning a <code>Store</code> object, the <code>VM</code> context will allocate and own a <code>Store</code>.</p>
<pre><code class="language-go">vm := wasmedge.NewVM()
store := vm.GetStore()
// The object should __NOT__ be deleted by calling `(*Store).Release`.
vm.Release()
</code></pre>
<p>Developers can also create the <code>VM</code> object with a <code>Store</code> object.
In this case, developers should guarantee that the <code>Store</code> object cannot be released before the <code>VM</code> object.
Please refer to the <a href="embed/go/ref.html#Store">Store Objects</a> for the details about the <code>Store</code> APIs.</p>
<pre><code class="language-go">store := wasmedge.NewStore()
vm := wasmedge.NewVMWithStore(store)

storemock := vm.GetStore()
// The internal store context of the `store` and the `storemock` are the same.

vm.Release()
store.Release()
</code></pre>
</li>
<li>
<p>List exported functions</p>
<p>After the WASM module instantiation, developers can use the <code>(*VM).Execute</code> function to invoke the exported WASM functions. For this purpose, developers may need information about the exported WASM function list.
Please refer to the <a href="embed/go/ref.html#Instances">Instances in runtime</a> for the details about the function types.</p>
<p>Assume that a new Go project is created as following:</p>
<pre><code class="language-bash">mkdir wasmedge_test &amp;&amp; cd wasmedge_test
go mod init wasmedge_test
</code></pre>
<p>Then assume that the WASM file <a href="https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/tools/wasmedge/examples/fibonacci.wasm"><code>fibonacci.wasm</code></a> is copied into the current directory, and create and edit a Go file <code>main.go</code>:</p>
<pre><code class="language-go">package main

import (
  &quot;fmt&quot;

  &quot;github.com/second-state/WasmEdge-go/wasmedge&quot;
)

func main() {
  // Create VM.
  vm := wasmedge.NewVM()

  // Step 1: Load WASM file.
  err := vm.LoadWasmFile(&quot;fibonacci.wasm&quot;)
  if err != nil {
    fmt.Println(&quot;Load WASM from file FAILED:&quot;, err.Error())
    return
  }

  // Step 2: Validate the WASM module.
  err = vm.Validate()
  if err != nil {
    fmt.Println(&quot;Validation FAILED:&quot;, err.Error())
    return
  }

  // Step 3: Instantiate the WASM module.
  err = vm.Instantiate()
  if err != nil {
    fmt.Println(&quot;Instantiation FAILED:&quot;, err.Error())
    return
  }

  // List the exported functions for the names and function types.
  funcnames, functypes := vm.GetFunctionList()
  for _, fname := range funcnames {
    fmt.Println(&quot;Exported function name:&quot;, fname)
  }
  for _, ftype := range functypes {
    // `ftype` is the `FunctionType` object of the same index in the `funcnames` array.
    // Developers should __NOT__ call the `ftype.Release()`.
  }

  vm.Release()
}
</code></pre>
<p>Then you can build and run: (the only exported function in <code>fibonacci.wasm</code> is <code>fib</code>)</p>
<pre><code class="language-bash">$ go get github.com/second-state/WasmEdge-go/wasmedge@v0.9.1
$ go build
$ ./wasmedge_test
Exported function name: fib
</code></pre>
<p>If developers want to get the exported function names in the registered WASM modules, please retrieve the <code>Store</code> object from the <code>VM</code> object and refer to the APIs of <a href="embed/go/ref.html#Store">Store Contexts</a> to list the registered functions by the module name.</p>
</li>
<li>
<p>Get function types</p>
<p>The <code>VM</code> object provides APIs to find the function type by function name.
Please refer to the <a href="embed/go/ref.html#Instances">Instances in runtime</a> for the details about the function types.</p>
<pre><code class="language-go">// Assume that a WASM module is instantiated in `vm` which is a `wasmedge.VM` object.
functype := vm.GetFunctionType(&quot;fib&quot;)
// Developers can get the function types of functions in the registered modules via the 
// `(*VM).GetFunctionTypeRegistered` API with the functon name and the module name.
// If the function is not found, these APIs will return `nil`.
// Developers should __NOT__ call the `(*FunctionType).Release` function of the returned object.
</code></pre>
</li>
</ol>
<h2 id="wasmedge-runtime-1"><a class="header" href="#wasmedge-runtime-1">WasmEdge Runtime</a></h2>
<p>In this partition, we will introduce the objects of WasmEdge runtime manually.</p>
<h3 id="wasm-execution-example-step-by-step-1"><a class="header" href="#wasm-execution-example-step-by-step-1">WASM Execution Example Step-By-Step</a></h3>
<p>Besides the WASM execution through the <a href="embed/go/ref.html#WasmEdge-VM"><code>VM</code> object</a> rapidly, developers can execute the WASM functions or instantiate WASM modules step-by-step with the <code>Loader</code>, <code>Validator</code>, <code>Executor</code>, and <code>Store</code> objects.</p>
<p>Assume that a new Go project is created as following:</p>
<pre><code class="language-bash">mkdir wasmedge_test &amp;&amp; cd wasmedge_test
go mod init wasmedge_test
</code></pre>
<p>Then assume that the WASM file <a href="https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/tools/wasmedge/examples/fibonacci.wasm"><code>fibonacci.wasm</code></a> is copied into the current directory, and create and edit a Go file <code>main.go</code>:</p>
<pre><code class="language-go">package main

import (
  &quot;fmt&quot;

  &quot;github.com/second-state/WasmEdge-go/wasmedge&quot;
)

func main() {
  // Set the logging level to debug to print the statistics info.
  wasmedge.SetLogDebugLevel()
  // Create the configure object. This is not necessary if developers use the default configuration.
  conf := wasmedge.NewConfigure()
  // Turn on the runtime instruction counting and time measuring.
  conf.SetStatisticsInstructionCounting(true)
  conf.SetStatisticsTimeMeasuring(true)
  // Create the statistics object. This is not necessary if the statistics in runtime is not needed.
  stat := wasmedge.NewStatistics()
  // Create the store object. The store object is the WASM runtime structure core.
  store := wasmedge.NewStore()

  var err error
  var res []interface{}
  var ast *wasmedge.AST

  // Create the loader object.
  // For loader creation with default configuration, you can use `wasmedge.NewLoader()` instead.
  loader := wasmedge.NewLoaderWithConfig(conf)
  // Create the validator object.
  // For validator creation with default configuration, you can use `wasmedge.NewValidator()` instead.
  validator := wasmedge.NewValidatorWithConfig(conf)
  // Create the executor object.
  // For executor creation with default configuration and without statistics, you can use `wasmedge.NewExecutor()` instead.
  executor := wasmedge.NewExecutorWithConfigAndStatistics(conf, stat)

  // Load the WASM file or the compiled-WASM file and convert into the AST module object.
  ast, err = loader.LoadFile(&quot;fibonacci.wasm&quot;)
  if err != nil {
    fmt.Println(&quot;Load WASM from file FAILED:&quot;, err.Error())
    return
  }
  // Validate the WASM module.
  err = validator.Validate(ast)
  if err != nil {
    fmt.Println(&quot;Validation FAILED:&quot;, err.Error())
    return
  }
  // Instantiate the WASM module into the Store object.
  err = executor.Instantiate(store, ast)
  if err != nil {
    fmt.Println(&quot;Instantiation FAILED:&quot;, err.Error())
    return
  }

  // Try to list the exported functions of the instantiated WASM module.
  funcnames := store.ListFunction()
  for _, fname := range funcnames {
    fmt.Println(&quot;Exported function name:&quot;, fname)
  }

  // Invoke the WASM function.
  res, err = executor.Invoke(store, &quot;fib&quot;, int32(30))
  if err == nil {
    fmt.Println(&quot;Get fibonacci[30]:&quot;, res[0].(int32))
  } else {
    fmt.Println(&quot;Run failed:&quot;, err.Error())
  }

  // Resources deallocations.
  conf.Release()
  stat.Release()
  ast.Release()
  loader.Release()
  validator.Release()
  executor.Release()
  store.Release()
}
</code></pre>
<p>Then you can build and run: (the 18th Fibonacci number is 1346269 in 30-based index)</p>
<pre><code class="language-bash">$ go get github.com/second-state/WasmEdge-go/wasmedge@v0.9.1
$ go build
$ ./wasmedge_test
Exported function name: fib
[2021-11-24 18:53:01.451] [debug]  Execution succeeded.
[2021-11-24 18:53:01.452] [debug]
 ====================  Statistics  ====================
 Total execution time: 556372295 ns
 Wasm instructions execution time: 556372295 ns
 Host functions execution time: 0 ns
 Executed wasm instructions count: 28271634
 Gas costs: 0
 Instructions per second: 50814237
Get fibonacci[30]: 1346269
</code></pre>
<h3 id="loader-1"><a class="header" href="#loader-1">Loader</a></h3>
<p>The <code>Loader</code> object loads the WASM binary from files or buffers.
Both the WASM and the compiled-WASM from the <a href="embed/go/ref.html#WasmEdge-AOT-Compiler">WasmEdge AOT Compiler</a> are supported.</p>
<pre><code class="language-go">var buf []byte
// ... Read the WASM code to the `buf`.

// Developers can adjust settings in the configure object.
conf := wasmedge.NewConfigure()
// Create the loader object.
// For loader creation with default configuration, you can use `wasmedge.NewLoader()` instead.
loader := wasmedge.NewLoaderWithConfig(conf)
conf.Release()

// Load WASM or compiled-WASM from the file.
ast, err := loader.LoadFile(&quot;fibonacci.wasm&quot;)
if err != nil {
  fmt.Println(&quot;Load WASM from file FAILED:&quot;, err.Error())
} else {
  // The output AST object should be released.
  ast.Release()
}

// Load WASM or compiled-WASM from the buffer
ast, err = loader.LoadBuffer(buf)
if err != nil {
  fmt.Println(&quot;Load WASM from buffer FAILED:&quot;, err.Error())
} else {
  // The output AST object should be released.
  ast.Release()   
}

loader.Release()
</code></pre>
<h3 id="validator-1"><a class="header" href="#validator-1">Validator</a></h3>
<p>The <code>Validator</code> object can validate the WASM module.
Every WASM module should be validated before instantiation.</p>
<pre><code class="language-go">// ...
// Assume that the `ast` is the output `*wasmedge.AST` object from the loader context.
// Assume that the `conf` is the `*wasmedge.Configure` object.

// Create the validator context.
// For validator creation with default configuration, you can use `wasmedge.NewValidator()` instead.
validator := wasmedge.NewValidatorWithConfig(conf)

err := validator.Validate(ast)
if err != nil {
  fmt.Println(&quot;Validation FAILED:&quot;, err.Error())
}

validator.Release()
</code></pre>
<h3 id="executor-1"><a class="header" href="#executor-1">Executor</a></h3>
<p>The <code>Executor</code> object is the executor for both WASM and compiled-WASM.
This object should work base on the <code>Store</code> object. For the details of the <code>Store</code> object, please refer to the <a href="embed/go/ref.html#Store">next chapter</a>.</p>
<ol>
<li>
<p>Register modules</p>
<p>As the same of <a href="embed/go/ref.html#Host-Module-Registrations">registering host modules</a> or <a href="embed/go/ref.html#WASM-Registrations-And-Executions">importing WASM modules</a> in <code>VM</code> objects, developers can register <code>ImportObject</code> or <code>AST</code> objects into the <code>Store</code> object by the <code>Executor</code> APIs.
For the details of import objects, please refer to the <a href="embed/go/ref.html#Host-Functions">Host Functions</a>.</p>
<pre><code class="language-go">// ...
// Assume that the `ast` is the output `*wasmedge.AST` object from the loader
// and has passed the validation.
// Assume that the `conf` is the `*wasmedge.Configure` object.

// Create the statistics object. This step is not necessary if the statistics
// is not needed.
stat := wasmedge.NewStatistics()
// Create the executor object.
// For executor creation with default configuration and without statistics,
// you can use `wasmedge.NewExecutor()` instead.
executor := wasmedge.NewExecutorWithConfigAndStatistics(conf, stat)
// Create the store object. The store is the WASM runtime structure core.
store := wasmedge.NewStore()

// Register the loaded WASM `ast` into store with the export module name &quot;mod&quot;.
res := executor.RegisterModule(store, ast, &quot;mod&quot;)
if err != nil {
  fmt.Println(&quot;WASM registration FAILED:&quot;, err.Error())
  return
}

// Assume that the `impobj` is the `*wasmedge.ImportObject` for host functions.
impobj := ...
err = executor.RegisterImport(store, impobj)
if err != nil {
  fmt.Println(&quot;Import object registration FAILED:&quot;, err.Error())
  return
}

executor.Release()
stat.Release()
store.Release()
impobj.Release()
</code></pre>
</li>
<li>
<p>Instantiate modules</p>
<p>WASM or compiled-WASM modules should be instantiated before the function invocation.
Note that developers can only instantiate one module into the <code>Store</code> object, and in that case, the old instantiated module will be cleaned.
Before instantiating a WASM module, please check the <a href="https://webassembly.github.io/spec/core/syntax/modules.html#syntax-import">import section</a> for ensuring the imports are registered into the <code>Store</code> object.</p>
<pre><code class="language-go">// ...
// Assume that the `ast` is the output `*wasmedge.AST` object from the loader
// and has passed the validation.
// Assume that the `conf` is the `*wasmedge.Configure` object.

// Create the statistics object. This step is not necessary if the statistics
// is not needed.
stat := wasmedge.NewStatistics()
// Create the executor object.
// For executor creation with default configuration and without statistics,
// you can use `wasmedge.NewExecutor()` instead.
executor := wasmedge.NewExecutorWithConfigAndStatistics(conf, stat)
// Create the store object. The store is the WASM runtime structure core.
store := wasmedge.NewStore()

// Instantiate the WASM module.
err := executor.Instantiate(stpre, ast)
if err != nil {
  fmt.Println(&quot;WASM instantiation FAILED:&quot;, err.Error())
  return
}

executor.Release()
stat.Release()
store.Release()
</code></pre>
</li>
<li>
<p>Invoke functions</p>
<p>As the same as function invocation via the <code>VM</code> object, developers can invoke the functions of the instantiated or registered modules.
The APIs, <code>(*Executor).Invoke</code> and <code>(*Executor).InvokeRegistered</code>, are similar as the APIs of the <code>VM</code> object.
Please refer to the <a href="embed/go/ref.html#WASM-Execution-Example-With-VM-Object">VM context workflows</a> for details.</p>
</li>
</ol>
<h3 id="ast-module-1"><a class="header" href="#ast-module-1">AST Module</a></h3>
<p>The <code>AST</code> object presents the loaded structure from a WASM file or buffer. Developer will get this object after loading a WASM file or buffer from <a href="embed/go/ref.html#Loader">Loader</a>.
Before instantiation, developers can also query the imports and exports of an <code>AST</code> object.</p>
<pre><code class="language-go">ast := ...
// Assume that a WASM is loaded into an `*wasmedge.AST` object from loader.

// List the imports.
imports := ast.ListImports()
for _, import := range imports {
  fmt.Println(&quot;Import:&quot;, import.GetModuleName(), import.GetExternalName())
}

// List the exports.
exports := ast.ListExports()
for _, export := range exports {
  fmt.Println(&quot;Export:&quot;, export.GetExternalName())
}

ast.Release()
</code></pre>
<h3 id="store-1"><a class="header" href="#store-1">Store</a></h3>
<p><a href="https://webassembly.github.io/spec/core/exec/runtime.html#store">Store</a> is the runtime structure for the representation of all instances of <code>Function</code>s, <code>Table</code>s, <code>Memory</code>s, and <code>Global</code>s that have been allocated during the lifetime of the abstract machine.
The <code>Store</code> object in WasmEdge-go provides APIs to list the exported instances with their names or find the instances by exported names. For adding instances into <code>Store</code> objects, please instantiate or register WASM modules or <code>ImportObject</code> objects via the <code>Executor</code> APIs.</p>
<ol>
<li>
<p>List instances</p>
<pre><code class="language-go">store := wasmedge.NewStore()
// ...
// Instantiate a WASM module via the `*wasmedge.Executor` object.
// ...

// Try to list the exported functions of the instantiated WASM module.
// Take the function instances for example here.
funcnames := store.ListFunction()
for _, name := range funcnames {
  fmt.Println(&quot;Exported function name:&quot;, name)
}

store.Release()
</code></pre>
<p>Developers can list the function instance exported names of the registered modules via the <code>(*Store).ListFunctionRegistered()</code> API with the module name.</p>
</li>
<li>
<p>Find instances</p>
<pre><code class="language-go">store := wasmedge.NewStore()
// ...
// Instantiate a WASM module via the `*wasmedge.Executor` object.
// ...

// Try to find the exported functions of the instantiated WASM module.
// Take the function instances for example here.
funcobj := store.FindFunction(&quot;fib&quot;)
// `funcobj` will be `nil` if the function not found.

store.Release()
</code></pre>
<p>Developers can retrieve the exported function instances of the registered modules via the <code>(*Store).FindFunctionRegistered</code> API with the module name.</p>
</li>
<li>
<p>List registered modules</p>
<p>With the module names, developers can list the exported instances of the registered modules with their names.</p>
<pre><code class="language-go">store := wasmedge.NewStore()
// ...
// Instantiate a WASM module via the `*wasmedge.Executor` object.
// ...

// Try to list the registered WASM modules.
modnames := store.ListModule()
for _, name := range modnames {
  fmt.Println(&quot;Registered module names:&quot;, name)
}

store.Release()
</code></pre>
</li>
</ol>
<h3 id="instances-1"><a class="header" href="#instances-1">Instances</a></h3>
<p>The instances are the runtime structures of WASM. Developers can retrieve the instances from the <code>Store</code> objects.
The <code>Store</code> objects will allocate instances when a WASM module or an <code>ImportObject</code> is registered or instantiated through the <code>Executor</code>.
A single instance can be allocated by its creation function. Developers can construct instances into an <code>ImportObject</code> for registration. Please refer to the <a href="embed/go/ref.html#Host-Functions">Host Functions</a> for details.
The instances created by their creation functions should be destroyed, EXCEPT they are added into an <code>ImportObject</code> object.</p>
<ol>
<li>
<p>Function instance</p>
<p><a href="https://webassembly.github.io/spec/core/exec/runtime.html#syntax-hostfunc">Host functions</a> are functions outside WebAssembly and passed to WASM modules as imports.
In WasmEdge, developers can create the <code>Function</code> objects for host functions and add them into an <code>ImportObject</code> object for registering into a <code>VM</code> or a <code>Store</code>.
For both host functions and the functions get from <code>Store</code>, developers can retrieve the <code>FunctionType</code> from the <code>Function</code> objects.
For the details of the <code>Host Function</code> guide, please refer to the <a href="embed/go/ref.html#Host-Functions">next chapter</a>.</p>
<pre><code class="language-go">funcinst := ...
// `funcobj` is the `*wasmedge.Function` retrieved from the store object.
functype := funcobj.GetFunctionType()
// The `funcobj` retrieved from the store object should __NOT__ be released.
// The `functype` retrieved from the `funcobj` should __NOT__ be released.
</code></pre>
</li>
<li>
<p>Table instance</p>
<p>In WasmEdge, developers can create the <code>Table</code> objects and add them into an <code>ImportObject</code> object for registering into a <code>VM</code> or a <code>Store</code>.
The <code>Table</code> objects supply APIs to control the data in table instances.</p>
<pre><code class="language-go">lim := wasmedge.NewLimitWithMax(10, 20)
// Create the table type with limit and the `FuncRef` element type.
tabtype := wasmedge.NewTableType(wasmedge.RefType_FuncRef, lim)
// Create the table instance with table type.
tabinst := wasmedge.NewTable(tabtype)
// Delete the table type.
tabtype.Release()

gottabtype := tabinst.GetTableType()
// The `gottabtype` got from table instance is owned by the `tabinst`
// and should __NOT__ be released.
reftype := gottabtype.GetRefType()
// The `reftype` will be `wasmedge.RefType_FuncRef`.

var gotdata interface{}
data := wasmedge.NewFuncRef(5)
err := tabinst.SetData(data, 3)
// Set the function index 5 to the table[3].

// The following line will get an &quot;out of bounds table access&quot; error
// because the position (13) is out of the table size (10):
//   err = tabinst.SetData(data, 13)

gotdata, err = tabinst.GetData(3)
// Get the FuncRef value of the table[3].

// The following line will get an &quot;out of bounds table access&quot; error
// because the position (13) is out of the table size (10):
//   gotdata, err = tabinst.GetData(13)

tabsize := tabinst.GetSize()
// `tabsize` will be 10.
err = tabinst.Grow(6)
// Grow the table size of 6, the table size will be 16.

// The following line will get an &quot;out of bounds table access&quot; error
// because the size (16 + 6) will reach the table limit (20):
//   err = tabinst.Grow(6)

tabinst.Release()
</code></pre>
</li>
<li>
<p>Memory instance</p>
<p>In WasmEdge, developers can create the <code>Memory</code> objects and add them into an <code>ImportObject</code> object for registering into a <code>VM</code> or a <code>Store</code>.
The <code>Memory</code> objects supply APIs to control the data in memory instances.</p>
<pre><code class="language-go">lim := wasmedge.NewLimitWithMax(1, 5)
// Create the memory type with limit. The memory page size is 64KiB.
memtype := wasmedge.NewMemoryType(lim)
// Create the memory instance with memory type.
meminst := wasmedge.NewMemory(memtype)
// Delete the memory type.
memtype.Release()

data := []byte(&quot;A quick brown fox jumps over the lazy dog&quot;)
err := meminst.SetData(data, 0x1000, 10)
// Set the data[0:9] to the memory[4096:4105].

// The following line will get an &quot;out of bounds memory access&quot; error
// because [65535:65544] is out of 1 page size (65536):
//   err = meminst.SetData(data, 0xFFFF, 10)

var gotdata []byte
gotdata, err = meminst.GetData(0x1000, 10)
// Get the memory[4096:4105]. The `gotdata` will be `[]byte(&quot;A quick br&quot;).
// The following line will get an &quot;out of bounds memory access&quot; error
// because [65535:65544] is out of 1 page size (65536):
//   gotdata, err = meminst.Getdata(0xFFFF, 10)

pagesize := meminst.GetPageSize()
// `pagesize` will be 1.
err = meminst.GrowPage(2)
// Grow the page size of 2, the page size of the memory instance will be 3.

// The following line will get an &quot;out of bounds memory access&quot; error
// because the size (3 + 3) will reach the memory limit (5):
//   err = meminst.GetPageSize(3)

meminst.Release()
</code></pre>
</li>
<li>
<p>Global instance</p>
<p>In WasmEdge, developers can create the <code>Global</code> objects and add them into an <code>ImportObject</code> object for registering into a <code>VM</code> or a <code>Store</code>.
The <code>Global</code> objects supply APIs to control the value in global instances.</p>
<pre><code class="language-go">// Create the global type with value type and mutation.
globtype := wasmedge.NewGlobalType(wasmedge.ValType_I64, wasmedge.ValMut_Var)
// Create the global instance with value and global type.
globinst := wasmedge.NewGlobal(globtype, uint64(1000))
// Delete the global type.
globtype.Release()

gotglobtype := globinst.GetGlobalType()
// The `gotglobtype` got from global instance is owned by the `globinst`
// and should __NOT__ be released.
valtype := gotglobtype.GetValType()
// The `valtype` will be `wasmedge.ValType_I64`.
valmut := gotglobtype.GetMutability()
// The `valmut` will be `wasmedge.ValMut_Var`.

globinst.SetValue(uint64(888))
// Set the value u64(888) to the global.
// This function will do nothing if the value type mismatched or the
// global mutability is `wasmedge.ValMut_Const`.
gotval := globinst.GetValue()
// The `gotbal` will be `interface{}` which the type is `uint64` and
// the value is 888.

globinst.Release()
</code></pre>
</li>
</ol>
<h3 id="host-functions-1"><a class="header" href="#host-functions-1">Host Functions</a></h3>
<p><a href="https://webassembly.github.io/spec/core/exec/runtime.html#syntax-hostfunc">Host functions</a> are functions outside WebAssembly and passed to WASM modules as imports.
In WasmEdge-go, developers can create the <code>Function</code>, <code>Memory</code>, <code>Table</code>, and <code>Global</code> objects and add them into an <code>ImportObject</code> object for registering into a <code>VM</code> or a <code>Store</code>.</p>
<ol>
<li>
<p>Host function allocation</p>
<p>Developers can define Go functions with the following function signature as the host function body:</p>
<pre><code class="language-go">type hostFunctionSignature func(
    data interface{}, mem *Memory, params []interface{}) ([]interface{}, Result)
</code></pre>
<p>The example of an <code>add</code> host function to add 2 <code>i32</code> values:</p>
<pre><code class="language-go">func host_add(data interface{}, mem *wasmedge.Memory, params []interface{}) ([]interface{}, wasmedge.Result) {
  // add: i32, i32 -&gt; i32
  res := params[0].(int32) + params[1].(int32)

  // Set the returns
  returns := make([]interface{}, 1)
  returns[0] = res

  // Return
  return returns, wasmedge.Result_Success
}
</code></pre>
<p>Then developers can create <code>Function</code> object with the host function body and function type:</p>
<pre><code class="language-go">// Create a function type: {i32, i32} -&gt; {i32}.
functype := wasmedge.NewFunctionType(
  []wasmedge.ValType{wasmedge.ValType_I32, wasmedge.ValType_I32},
  []wasmedge.ValType{wasmedge.ValType_I32},
)

// Create a function context with the function type and host function body.
// The third parameter is the pointer to the additional data.
// Developers should guarantee the life cycle of the data, and it can be
// `nil` if the external data is not needed.
// The last parameter can be 0 if developers do not need the cost measuring.
func_add := wasmedge.NewFunction(functype, host_add, nil, 0)

// If the function object is not added into an import object object, it should be released.
func_add.Release()
functype.Release()
</code></pre>
</li>
<li>
<p>Import object object</p>
<p>The <code>ImportObject</code> object holds an exporting module name and the instances. Developers can add the <code>Function</code>, <code>Memory</code>, <code>Table</code>, and <code>Global</code> instances with their exporting names.</p>
<pre><code class="language-go">// Host function body definition.
func host_add(data interface{}, mem *wasmedge.Memory, params []interface{}) ([]interface{}, wasmedge.Result) {
  // add: i32, i32 -&gt; i32
  res := params[0].(int32) + params[1].(int32)

  // Set the returns
  returns := make([]interface{}, 1)
  returns[0] = res

  // Return
  return returns, wasmedge.Result_Success
}

// Create the import object with the module name &quot;module&quot;.
impobj := wasmedge.NewImportObject(&quot;module&quot;)

// Create and add a function instance into the import object with export name &quot;add&quot;.
functype := wasmedge.NewFunctionType(
  []wasmedge.ValType{wasmedge.ValType_I32, wasmedge.ValType_I32},
  []wasmedge.ValType{wasmedge.ValType_I32},
)
hostfunc := wasmedge.NewFunction(functype, host_add, nil, 0)
functype.Release()
impobj.AddFunction(&quot;add&quot;, hostfunc)

// Create and add a table instance into the import object with export name &quot;table&quot;.
tabtype := wasmedge.NewTableType(wasmedge.RefType_FuncRef ,wasmedge.NewLimitWithMax(10, 20))
hosttab := wasmedge.NewTable(tabtype)
tabtype.Release()
impobj.AddTable(&quot;table&quot;, hosttab)

// Create and add a memory instance into the import object with export name &quot;memory&quot;.
memtype := wasmedge.NewMemoryType(wasmedge.NewLimitWithMax(1, 2))
hostmem := wasmedge.NewMemory(memtype)
memtype.Release()
impobj.AddMemory(&quot;memory&quot;, hostmem)

// Create and add a global instance into the import object with export name &quot;global&quot;.
globtype := wasmedge.NewGlobalType(wasmedge.ValType_I32, wasmedge.ValMut_Var)
hostglob := wasmedge.NewGlobal(globtype, uint32(666))
globtype.Release()
impobj.AddGlobal(&quot;global&quot;, hostglob)

// The import objects should be released.
// Developers should __NOT__ release the instances added into the import object objects.
impobj.Release()
</code></pre>
</li>
<li>
<p>Specified import object</p>
<p><code>wasmedge.NewWasiImportObject()</code> API can create and initialize the <code>WASI</code> import object.
<code>wasmedge.NewWasmEdgeProcessImportObject()</code> API can create and initialize the <code>wasmedge_process</code> import object.
Developers can create these import object objects and register them into the <code>Store</code> or <code>VM</code> objects rather than adjust the settings in the <code>Configure</code> objects.</p>
<pre><code class="language-go">wasiobj := wasmedge.NewWasiImportObject(
  os.Args[1:],     // The args
  os.Environ(),    // The envs
  []string{&quot;.:.&quot;}, // The mapping preopens
)
procobj := wasmedge.NewWasmEdgeProcessImportObject(
  []string{&quot;ls&quot;, &quot;echo&quot;}, // The allowed commands
  false,                  // Not to allow all commands
)

// Register the WASI and WasmEdge_Process into the VM object.
vm := wasmedge.NewVM()
vm.RegisterImport(wasiobj)
vm.RegisterImport(procobj)

// ... Execute some WASM functions.

// Get the WASI exit code.
exitcode := wasiobj.WasiGetExitCode()
// The `exitcode` will be 0 if the WASI function &quot;_start&quot; execution has no error.
// Otherwise, it will return with the related exit code.

vm.Release()
// The import objects should be deleted.
wasiobj.Release()
procobj.Release()
</code></pre>
</li>
<li>
<p>Example</p>
<p>Create a new Go project first:</p>
<pre><code class="language-bash">mkdir wasmedge_test &amp;&amp; cd wasmedge_test
go mod init wasmedge_test
</code></pre>
<p>Assume that there is a simple WASM from the WAT as following:</p>
<pre><code class="language-wasm">(module
  (type $t0 (func (param i32 i32) (result i32)))
  (import &quot;extern&quot; &quot;func-add&quot; (func $f-add (type $t0)))
  (func (export &quot;addTwo&quot;) (param i32 i32) (result i32)
    local.get 0
    local.get 1
    call $f-add)
)
</code></pre>
<p>Create and edit the Go file <code>main.go</code> as following:</p>
<pre><code class="language-go">package main

import (
  &quot;fmt&quot;

  &quot;github.com/second-state/WasmEdge-go/wasmedge&quot;
)

// Host function body definition.
func host_add(data interface{}, mem *wasmedge.Memory, params []interface{}) ([]interface{}, wasmedge.Result) {
  // add: i32, i32 -&gt; i32
  res := params[0].(int32) + params[1].(int32)

  // Set the returns
  returns := make([]interface{}, 1)
  returns[0] = res

  // Return
  return returns, wasmedge.Result_Success
}

func main() {
  // Create the VM object.
  vm := wasmedge.NewVM()

  // The WASM module buffer.
  wasmbuf := []byte{
    /* WASM header */
    0x00, 0x61, 0x73, 0x6D, 0x01, 0x00, 0x00, 0x00,
    /* Type section */
    0x01, 0x07, 0x01,
    /* function type {i32, i32} -&gt; {i32} */
    0x60, 0x02, 0x7F, 0x7F, 0x01, 0x7F,
    /* Import section */
    0x02, 0x13, 0x01,
    /* module name: &quot;extern&quot; */
    0x06, 0x65, 0x78, 0x74, 0x65, 0x72, 0x6E,
    /* extern name: &quot;func-add&quot; */
    0x08, 0x66, 0x75, 0x6E, 0x63, 0x2D, 0x61, 0x64, 0x64,
    /* import desc: func 0 */
    0x00, 0x00,
    /* Function section */
    0x03, 0x02, 0x01, 0x00,
    /* Export section */
    0x07, 0x0A, 0x01,
    /* export name: &quot;addTwo&quot; */
    0x06, 0x61, 0x64, 0x64, 0x54, 0x77, 0x6F,
    /* export desc: func 0 */
    0x00, 0x01,
    /* Code section */
    0x0A, 0x0A, 0x01,
    /* code body */
    0x08, 0x00, 0x20, 0x00, 0x20, 0x01, 0x10, 0x00, 0x0B,
  }

  // Create the import object with the module name &quot;extern&quot;.
  impobj := wasmedge.NewImportObject(&quot;extern&quot;)

  // Create and add a function instance into the import object with export name &quot;func-add&quot;.
  functype := wasmedge.NewFunctionType(
    []wasmedge.ValType{wasmedge.ValType_I32, wasmedge.ValType_I32},
    []wasmedge.ValType{wasmedge.ValType_I32},
  )
  hostfunc := wasmedge.NewFunction(functype, host_add, nil, 0)
  functype.Release()
  impobj.AddFunction(&quot;func-add&quot;, hostfunc)

  // Register the import object into VM.
  vm.RegisterImport(impobj)

  res, err := vm.RunWasmBuffer(wasmbuf, &quot;addTwo&quot;, uint32(1234), uint32(5678))
  if err == nil {
    fmt.Println(&quot;Get the result:&quot;, res[0].(int32))
  } else {
    fmt.Println(&quot;Error message:&quot;, err.Error())
  }

  impobj.Release()
  vm.Release()
}
</code></pre>
<p>Then you can build and run the Golang application with the WasmEdge Golang SDK:</p>
<pre><code class="language-bash">$ go get github.com/second-state/WasmEdge-go/wasmedge@v0.9.1
$ go build
$ ./wasmedge_test
Get the result: 6912
</code></pre>
</li>
<li>
<p>Host Data Example</p>
<p>Developers can set a external data object to the function object, and access to the object in the function body.
Assume that edit the Go file <code>main.go</code> above:</p>
<pre><code class="language-go">package main

import (
  &quot;fmt&quot;

  &quot;github.com/second-state/WasmEdge-go/wasmedge&quot;
)

// Host function body definition.
func host_add(data interface{}, mem *wasmedge.Memory, params []interface{}) ([]interface{}, wasmedge.Result) {
  // add: i32, i32 -&gt; i32
  res := params[0].(int32) + params[1].(int32)

  // Set the returns
  returns := make([]interface{}, 1)
  returns[0] = res

  // Also set the result to the data.
  *data.(*int32) = res

  // Return
  return returns, wasmedge.Result_Success
}

func main() {
  // Create the VM object.
  vm := wasmedge.NewVM()

  // The WASM module buffer.
  wasmbuf := []byte{
    /* WASM header */
    0x00, 0x61, 0x73, 0x6D, 0x01, 0x00, 0x00, 0x00,
    /* Type section */
    0x01, 0x07, 0x01,
    /* function type {i32, i32} -&gt; {i32} */
    0x60, 0x02, 0x7F, 0x7F, 0x01, 0x7F,
    /* Import section */
    0x02, 0x13, 0x01,
    /* module name: &quot;extern&quot; */
    0x06, 0x65, 0x78, 0x74, 0x65, 0x72, 0x6E,
    /* extern name: &quot;func-add&quot; */
    0x08, 0x66, 0x75, 0x6E, 0x63, 0x2D, 0x61, 0x64, 0x64,
    /* import desc: func 0 */
    0x00, 0x00,
    /* Function section */
    0x03, 0x02, 0x01, 0x00,
    /* Export section */
    0x07, 0x0A, 0x01,
    /* export name: &quot;addTwo&quot; */
    0x06, 0x61, 0x64, 0x64, 0x54, 0x77, 0x6F,
    /* export desc: func 0 */
    0x00, 0x01,
    /* Code section */
    0x0A, 0x0A, 0x01,
    /* code body */
    0x08, 0x00, 0x20, 0x00, 0x20, 0x01, 0x10, 0x00, 0x0B,
  }

  // The additional data to set into the host function.
  var data int32 = 0

  // Create the import object with the module name &quot;extern&quot;.
  impobj := wasmedge.NewImportObject(&quot;extern&quot;)

  // Create and add a function instance into the import object with export name &quot;func-add&quot;.
  functype := wasmedge.NewFunctionType(
    []wasmedge.ValType{wasmedge.ValType_I32, wasmedge.ValType_I32},
    []wasmedge.ValType{wasmedge.ValType_I32},
  )
  hostfunc := wasmedge.NewFunction(functype, host_add, &amp;data, 0)
  functype.Release()
  impobj.AddFunction(&quot;func-add&quot;, hostfunc)

  // Register the import object into VM.
  vm.RegisterImport(impobj)

  res, err := vm.RunWasmBuffer(wasmbuf, &quot;addTwo&quot;, uint32(1234), uint32(5678))
  if err == nil {
    fmt.Println(&quot;Get the result:&quot;, res[0].(int32))
  } else {
    fmt.Println(&quot;Error message:&quot;, err.Error())
  }
  fmt.Println(&quot;Data value:&quot;, data)

  impobj.Release()
  vm.Release()
}
</code></pre>
<p>Then you can build and run the Golang application with the WasmEdge Golang SDK:</p>
<pre><code class="language-bash">$ go get github.com/second-state/WasmEdge-go/wasmedge@v0.9.1
$ go build
$ ./wasmedge_test
Get the result: 6912
Data value: 6912
</code></pre>
</li>
</ol>
<h2 id="wasmedge-aot-compiler-1"><a class="header" href="#wasmedge-aot-compiler-1">WasmEdge AOT Compiler</a></h2>
<p>In this partition, we will introduce the WasmEdge AOT compiler and the options in Go.
WasmEdge runs the WASM files in interpreter mode, and WasmEdge also supports the AOT (ahead-of-time) mode running without modifying any code.
The WasmEdge AOT (ahead-of-time) compiler compiles the WASM files for running in AOT mode which is much faster than interpreter mode. Developers can compile the WASM files into the compiled-WASM files in shared library format for universal WASM format for the AOT mode execution.</p>
<h3 id="compilation-example-1"><a class="header" href="#compilation-example-1">Compilation Example</a></h3>
<p>The <a href="https://github.com/second-state/WasmEdge-go-examples/tree/master/go_WasmAOT">go_WasmAOT example</a> provide a tool for compiling a WASM file.</p>
<h3 id="compiler-options-1"><a class="header" href="#compiler-options-1">Compiler Options</a></h3>
<p>Developers can set options for AOT compilers such as optimization level and output format:</p>
<pre><code class="language-go">const (
  // Disable as many optimizations as possible.
  CompilerOptLevel_O0 = CompilerOptimizationLevel(C.WasmEdge_CompilerOptimizationLevel_O0)
  // Optimize quickly without destroying debuggability.
  CompilerOptLevel_O1 = CompilerOptimizationLevel(C.WasmEdge_CompilerOptimizationLevel_O1)
  // Optimize for fast execution as much as possible without triggering significant incremental compile time or code size growth.
  CompilerOptLevel_O2 = CompilerOptimizationLevel(C.WasmEdge_CompilerOptimizationLevel_O2)
  // Optimize for fast execution as much as possible.
  CompilerOptLevel_O3 = CompilerOptimizationLevel(C.WasmEdge_CompilerOptimizationLevel_O3)
  // Optimize for small code size as much as possible without triggering significant incremental compile time or execution time slowdowns.
  CompilerOptLevel_Os = CompilerOptimizationLevel(C.WasmEdge_CompilerOptimizationLevel_Os)
  // Optimize for small code size as much as possible.
  CompilerOptLevel_Oz = CompilerOptimizationLevel(C.WasmEdge_CompilerOptimizationLevel_Oz)
)

const (
  // Native dynamic library format.
  CompilerOutputFormat_Native = CompilerOutputFormat(C.WasmEdge_CompilerOutputFormat_Native)
  // WebAssembly with AOT compiled codes in custom section.
  CompilerOutputFormat_Wasm = CompilerOutputFormat(C.WasmEdge_CompilerOutputFormat_Wasm)
)
</code></pre>
<p>Please refer to the <a href="embed/go/ref.html#Configurations">AOT compiler options configuration</a> for details.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="nodejs-sdk"><a class="header" href="#nodejs-sdk">Node.js SDK</a></h1>
<p>In this tutorial, I will show you how to incorporate WebAssembly functions, written in Rust, into Node.js applications on the server via the WasmEdge Node.js SDK. This approach combines Rust's <strong>performance</strong>, WebAssembly's <strong>security and portability</strong>, and JavaScript's <strong>ease-of-use</strong>. A typical application works like this.</p>
<ul>
<li>The host application is a Node.js web application written in JavaScript. It makes WebAssembly function calls.</li>
<li>The WebAssembly bytecode program is written in Rust. It runs inside the WasmEdge Runtime, and is called from the Node.js web application.</li>
</ul>
<blockquote>
<p><a href="https://github.com/second-state/wasmedge-nodejs-starter/fork">Fork this Github repository</a> to start coding!</p>
</blockquote>
<h2 id="prerequisites-1"><a class="header" href="#prerequisites-1">Prerequisites</a></h2>
<p>To set up a high-performance Node.js environment with Rust and WebAssembly, you will need the following:</p>
<ul>
<li>A modern Linux distribution, such as Ubuntu Server 20.04 LTS</li>
<li><a href="https://www.rust-lang.org/tools/install">Rust language</a></li>
<li><a href="https://nodejs.org/en/download/package-manager/">Node.js</a></li>
<li><a href="embed/../start/install.html#install-wasmedge-for-node.js">The WasmEdge Runtime</a> for Node.js</li>
<li><a href="embed//articles/rustwasmc">The rustwasmc compiler toolchain</a></li>
</ul>
<h3 id="docker"><a class="header" href="#docker">Docker</a></h3>
<p>The easiest way to get started is to use Docker to build a dev environment. Just <a href="https://github.com/second-state/wasmedge-nodejs-starter/">clone this template project</a> to your computer and run the following Docker commands.</p>
<pre><code class="language-bash"># Get the code
git clone https://github.com/second-state/wasmedge-nodejs-starter
cd wasmedge-nodejs-starter

# Run Docker container
docker pull wasmedge/appdev_x86_64:0.8.2
docker run -p 3000:3000 --rm -it -v $(pwd):/app wasmedge/appdev_x86_64:0.8.2

# In docker
cd /app
</code></pre>
<p>That's it! You are now ready to compile and run the code.</p>
<h3 id="manual-setup-without-docker"><a class="header" href="#manual-setup-without-docker">Manual setup without Docker</a></h3>
<p>The commands are as follows.</p>
<pre><code class="language-bash"># Install Rust
curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh
source $HOME/.cargo/env
rustup override set 1.50.0

# Install Node.js and npm
curl -sL https://deb.nodesource.com/setup_14.x |  bash
sudo apt-get install -y nodejs npm

# Install rustwasmc toolchain
npm install -g rustwasmc # Append --unsafe-perm if permission denied

# OS dependencies for WasmEdge
sudo apt-get update
sudo apt-get -y upgrade
sudo apt install -y build-essential curl wget git vim libboost-all-dev llvm-dev liblld-10-dev

# Install the nodejs addon for WasmEdge
npm install wasmedge-core
npm install wasmedge-extensions
</code></pre>
<blockquote>
<p>The WasmEdge Runtime depends on the latest version of <code>libstdc++</code>. Ubuntu 20.04 LTS already has the latest libraries. If you are running an older Linux distribution, you have <a href="embed//articles/ubuntu-req-ssvm-20200715/">several options to upgrade</a>.</p>
</blockquote>
<p>Next, clone the example source code repository.</p>
<pre><code class="language-bash">git clone https://github.com/second-state/wasmedge-nodejs-starter
cd wasmedge-nodejs-starter
</code></pre>
<h2 id="hello-world-3"><a class="header" href="#hello-world-3">Hello World</a></h2>
<p>The first example is a hello world to show you how various parts of the application fit together.</p>
<h3 id="webassembly-program-in-rust"><a class="header" href="#webassembly-program-in-rust">WebAssembly program in Rust</a></h3>
<p>In this example, our Rust program appends the input string after “hello”. Below is the content of the Rust program <code>src/lib.rs</code>. You can define multiple external functions in this library file, and all of them will be available to the host JavaScript app via WebAssembly. Just remember to annotate each function with <code>#[wasm_bindgen]</code> so that <a href="https://github.com/second-state/rustwasmc">rustwasmc</a> knows to generate the correct JavaScript to Rust interface for it when you build it.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use wasm_bindgen::prelude::*;

#[wasm_bindgen]
pub fn say(s: String) -&gt; String {
  let r = String::from(&quot;hello &quot;);
  return r + &amp;s;
}
<span class="boring">}
</span></code></pre></pre>
<p>Next, you can compile the Rust source code into WebAssembly bytecode and generate the accompanying JavaScript module for the Node.js host environment.</p>
<pre><code class="language-bash">rustwasmc build
</code></pre>
<p>The result are files in the <code>pkg/</code> directory. the <code>.wasm</code> file is the WebAssembly bytecode program, and the <code>.js</code> files are for the JavaScript module.</p>
<h3 id="the-nodejs-host-application"><a class="header" href="#the-nodejs-host-application">The Node.js host application</a></h3>
<p>Next, go to the <code>node</code> folder and examine the JavaScript program <code>app.js</code>. With the generated <code>wasmedge_nodejs_starter_lib.js</code> module, it is very easy to write JavaScript to call WebAssembly functions. Below is the node application <code>app.js</code>. It simply imports the <code>say()</code> function from the generated module. The node application takes the <code>name</code> parameter from incoming an HTTP GET request, and responds with “hello <code>name</code>”.</p>
<pre><code class="language-javascript">const { say } = require('../pkg/wasmedge_nodejs_starter_lib.js');

const http = require('http');
const url = require('url');
const hostname = '127.0.0.1';
const port = 3000;

const server = http.createServer((req, res) =&gt; {
  const queryObject = url.parse(req.url,true).query;
  res.statusCode = 200;
  res.setHeader('Content-Type', 'text/plain');
  res.end(say(queryObject['name']));
});

server.listen(port, hostname, () =&gt; {
  console.log(`Server running at http://${hostname}:${port}/`);
});
</code></pre>
<p>Start the Node.js application server as follows.</p>
<pre><code class="language-bash">$ node node/app.js
Server running at http://127.0.0.1:3000/
</code></pre>
<p>Then, you can test it from another terminal window.</p>
<pre><code class="language-bash">$ curl http://127.0.0.1:3000/?name=Wasm
hello Wasm
</code></pre>
<h2 id="a-complete-web-application"><a class="header" href="#a-complete-web-application">A complete web application</a></h2>
<p>The next example shows a web application that computes the roots for quadratic equations. Please checkout the <a href="https://github.com/second-state/wasm-learning/tree/master/nodejs/quadratic">full source code here</a>.</p>
<p>The user enters the values for <code>a</code>, <code>b</code>, <code>c</code> on the web form, and the web application calls the web service at <code>/solve</code> to compute the roots for the quadratic equation.</p>
<pre><code class="language-src">a*X^2 + b*X + c = 0
</code></pre>
<p>The roots for <code>X</code> are displayed in the area below the input form.</p>
<p><img src="https://www.secondstate.io/articles/getting-started-with-rust-function-01.png" alt="getting-started-with-rust-function" /></p>
<p>The <a href="https://github.com/second-state/wasm-learning/blob/master/nodejs/quadratic/node/public/index.html">HTML file</a> contains the client side JavaScript to submit the web form to <code>/solve</code>, and put result into the <code>#roots</code> HTML element on the page.</p>
<pre><code class="language-javascript">$(function() {
  var options = {
    target: '#roots',
    url: &quot;/solve&quot;,
    type: &quot;post&quot;
  };
  $('#solve').ajaxForm(options);
});
</code></pre>
<p>The <a href="https://github.com/second-state/wasm-learning/blob/master/nodejs/quadratic/node/server.js">Node.js application</a> behind the <code>/solve</code> URL endpoint is as follows. It reads the data from the input form, passes them into the <code>solve</code> function as an array, and puts the return value in the HTTP response.</p>
<pre><code class="language-javascript">app.post('/solve', function (req, res) {
  var a = parseFloat(req.body.a);
  var b = parseFloat(req.body.b);
  var c = parseFloat(req.body.c);
  res.send(solve([a, b, c]))
})
</code></pre>
<p>The <a href="https://github.com/second-state/wasm-learning/blob/master/nodejs/quadratic/src/lib.rs"><code>solve</code> function is written in Rust</a> and runs inside the WasmEdge Runtime. While the call arguments in the JavaScript side is an array of values, the Rust function receives a JSON object that encapsulates the array. In the Rust code, we first decode the JSON, perform the computation, and return the result values in a JSON string.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[wasm_bindgen]
pub fn solve(params: &amp;str) -&gt; String {
  let ps: (f32, f32, f32) = serde_json::from_str(&amp;params).unwrap();
  let discriminant: f32 = (ps.1 * ps.1) - (4. * ps.0 * ps.2);
  let mut solution: (f32, f32) = (0., 0.);
  if discriminant &gt;= 0. {
    solution.0 = (((-1.) * ps.1) + discriminant.sqrt()) / (2. * ps.0);
    solution.1 = (((-1.) * ps.1) - discriminant.sqrt()) / (2. * ps.0);
    return serde_json::to_string(&amp;solution).unwrap();
  } else {
    return String::from(&quot;not real numbers&quot;);
  }
}
<span class="boring">}
</span></code></pre></pre>
<p>Let's try it.</p>
<pre><code class="language-bash">rustwasmc build
npm install express # The application requires the Express framework in Node.js

node node/server.js
</code></pre>
<p>From the web browser, go to <code>http://ip-addr:8080/</code> to access this application. Note: If you are using Docker, make sure that the Docker container port 8080 is mapped to the host port 8080.</p>
<p>That’s it for the quadratic equation example.</p>
<h2 id="more-examples"><a class="header" href="#more-examples">More examples</a></h2>
<p>Besides passing string values between Rust and JavaScript, the <code>rustwasmc</code> tool supports the following data types.</p>
<ul>
<li>Rust call parameters can be any combo of <code>i32</code>, <code>String</code>, <code>&amp;str</code>, <code>Vec&lt;u8&gt;</code>, and <code>&amp;[u8]</code></li>
<li>Return value can be <code>i32</code> or <code>String</code> or <code>Vec&lt;u8&gt;</code> or void</li>
<li>For complex data types, such as structs, you could use JSON strings to pass data.</li>
</ul>
<blockquote>
<p>With JSON support, you can call Rust functions with any number of input parameters and return any number of return values of any type.</p>
</blockquote>
<p>The Rust program <code>src/lib.rs</code> in the <a href="https://github.com/second-state/wasm-learning/tree/master/nodejs/functions">functions example</a> demonstrates  how to pass in call arguments in various supported types, and return values.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[wasm_bindgen]
pub fn obfusticate(s: String) -&gt; String {
  (&amp;s).chars().map(|c| {
    match c {
      'A' ..= 'M' | 'a' ..= 'm' =&gt; ((c as u8) + 13) as char,
      'N' ..= 'Z' | 'n' ..= 'z' =&gt; ((c as u8) - 13) as char,
      _ =&gt; c
    }
  }).collect()
}

#[wasm_bindgen]
pub fn lowest_common_denominator(a: i32, b: i32) -&gt; i32 {
  let r = lcm(a, b);
  return r;
}

#[wasm_bindgen]
pub fn sha3_digest(v: Vec&lt;u8&gt;) -&gt; Vec&lt;u8&gt; {
  return Sha3_256::digest(&amp;v).as_slice().to_vec();
}

#[wasm_bindgen]
pub fn keccak_digest(s: &amp;[u8]) -&gt; Vec&lt;u8&gt; {
  return Keccak256::digest(s).as_slice().to_vec();
}
<span class="boring">}
</span></code></pre></pre>
<p>Perhaps the most interesting is the <code>create_line()</code> function. It takes two JSON strings, each representing a <code>Point</code> struct, and returns a JSON string representing a <code>Line</code> struct. Notice that both the <code>Point</code> and <code>Line</code> structs are annotated with <code>Serialize</code> and <code>Deserialize</code> so that the Rust compiler automatically generates necessary code to support their conversion to and from JSON strings.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use wasm_bindgen::prelude::*;
use serde::{Serialize, Deserialize};

#[derive(Serialize, Deserialize, Debug)]
struct Point {
  x: f32, 
  y: f32
}

#[derive(Serialize, Deserialize, Debug)]
struct Line {
  points: Vec&lt;Point&gt;,
  valid: bool,
  length: f32,
  desc: String
}

#[wasm_bindgen]
pub fn create_line (p1: &amp;str, p2: &amp;str, desc: &amp;str) -&gt; String {
  let point1: Point = serde_json::from_str(p1).unwrap();
  let point2: Point = serde_json::from_str(p2).unwrap();
  let length = ((point1.x - point2.x) * (point1.x - point2.x) + (point1.y - point2.y) * (point1.y - point2.y)).sqrt();

  let valid = if length == 0.0 { false } else { true };
  let line = Line { points: vec![point1, point2], valid: valid, length: length, desc: desc.to_string() };
  return serde_json::to_string(&amp;line).unwrap();
}

#[wasm_bindgen]
pub fn say(s: &amp;str) -&gt; String {
  let r = String::from(&quot;hello &quot;);
  return r + s;
}
<span class="boring">}
</span></code></pre></pre>
<p>Next, let's examine the JavaScript program <a href="https://github.com/second-state/wasm-learning/blob/master/nodejs/functions/node/app.js"><code>app.js</code></a>. It shows how to call the Rust functions. As you can see <code>String</code> and <code>&amp;str</code> are simply strings in JavaScript, <code>i32</code> are numbers, and <code>Vec&lt;u8&gt;</code> or <code>&amp;[8]</code> are JavaScript <code>Uint8Array</code>. JavaScript objects need to go through <code>JSON.stringify()</code> or <code>JSON.parse()</code> before being passed into or returned from Rust functions.</p>
<pre><code class="language-javascript">const { say, obfusticate, lowest_common_denominator, sha3_digest, keccak_digest, create_line } = require('./functions_lib.js');

var util = require('util');
const encoder = new util.TextEncoder();
console.hex = (d) =&gt; console.log((Object(d).buffer instanceof ArrayBuffer ? new Uint8Array(d.buffer) : typeof d === 'string' ? (new util.TextEncoder('utf-8')).encode(d) : new Uint8ClampedArray(d)).reduce((p, c, i, a) =&gt; p + (i % 16 === 0 ? i.toString(16).padStart(6, 0) + '  ' : ' ') + c.toString(16).padStart(2, 0) + (i === a.length - 1 || i % 16 === 15 ?  ' '.repeat((15 - i % 16) * 3) + Array.from(a).splice(i - i % 16, 16).reduce((r, v) =&gt; r + (v &gt; 31 &amp;&amp; v &lt; 127 || v &gt; 159 ? String.fromCharCode(v) : '.'), '  ') + '\n' : ''), ''));

console.log( say(&quot;WasmEdge&quot;) );
console.log( obfusticate(&quot;A quick brown fox jumps over the lazy dog&quot;) );
console.log( lowest_common_denominator(123, 2) );
console.hex( sha3_digest(encoder.encode(&quot;This is an important message&quot;)) );
console.hex( keccak_digest(encoder.encode(&quot;This is an important message&quot;)) );

var p1 = {x:1.5, y:3.8};
var p2 = {x:2.5, y:5.8};
var line = JSON.parse(create_line(JSON.stringify(p1), JSON.stringify(p2), &quot;A thin red line&quot;));
console.log( line );
</code></pre>
<p>After running <code>rustwasmc</code> to build the Rust library, running <code>app.js</code> in Node.js environment produces the following output.</p>
<pre><code class="language-bash">$ rustwasmc build
... Building the wasm file and JS shim file in pkg/ ...

$ node node/app.js
hello WasmEdge
N dhvpx oebja sbk whzcf bire gur ynml qbt
246
000000  57 1b e7 d1 bd 69 fb 31 9f 0a d3 fa 0f 9f 9a b5  W.çÑ½iû1..Óú...µ
000010  2b da 1a 8d 38 c7 19 2d 3c 0a 14 a3 36 d3 c3 cb  +Ú..8Ç.-&lt;..£6ÓÃË

000000  7e c2 f1 c8 97 74 e3 21 d8 63 9f 16 6b 03 b1 a9  ~ÂñÈ.tã!Øc..k.±©
000010  d8 bf 72 9c ae c1 20 9f f6 e4 f5 85 34 4b 37 1b  Ø¿r.®Á .öäõ.4K7.

{ points: [ { x: 1.5, y: 3.8 }, { x: 2.5, y: 5.8 } ],
  valid: true,
  length: 2.2360682,
  desc: 'A thin red line' }  
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rust-sdk"><a class="header" href="#rust-sdk">Rust SDK</a></h1>
<p>You can also embed WasmEdge into your Rust application via the WasmEdge Rust SDK.</p>
<p>The definitions of WasmEdge Rust SDK involve two Rust crates, <a href="https://crates.io/crates/wasmedge-sys">wasmedge-sys</a> and <a href="https://crates.io/crates/wasmedge-sdk">wasmedge-rs</a>. They are designed based on different principles and for different purposes. The wasmedge-sys crate defines a group of low-level Rust APIs, which simply wrap WasmEdge C APIs and provide the safe counterpart, while the wasmedge-rs crate provides more elegant and ergonomic APIs, which are more suitable for application development.</p>
<ul>
<li>
<p>The <a href="https://crates.io/crates/wasmedge-sys">wasmedge-sys</a> crate defines a group of low-level Rust APIs, which simply wrap WasmEdge C APIs and provide the safe counterparts. The APIs in <a href="https://crates.io/crates/wasmedge-sys">wasmedge-sys</a> should be used to construct high-level libraries. For the details of the APIs, please visit <a href="https://wasmedge.github.io/WasmEdge/wasmedge_sys/">wasmedge-sys API documentation</a>.</p>
</li>
<li>
<p>The <a href="https://crates.io/crates/wasmedge-sdk">wasmedge-rs</a> crate is based on the wasmedge-sys crate and provides a more elegant and idiomatic Rust APIs. These APIs are more suitable for business-oriented design and development. The wasmedge-rs crate is still under active development and coming soon.</p>
</li>
</ul>
<h2 id="build-wasmedge-sys-crate"><a class="header" href="#build-wasmedge-sys-crate">Build <code>wasmedge-sys</code> crate</a></h2>
<p><code>wasmedge-sys</code> depends on the dynamic library and the header files of <code>WasmEdge</code>. To <code>cargo build</code> <code>wasmedge-sys</code> there are several choices to specify the dependencies:</p>
<ul>
<li>
<p>By specifying <code>WASMEDGE_INCLUDE_DIR</code> and <code>WASMEDGE_LIB_DIR</code></p>
<ul>
<li>
<p>Suppose that you have already downloaded the <code>Wasmedge-0.9.1</code> binary package from <a href="https://github.com/WasmEdge/WasmEdge/releases">WasmEdge Releases</a> and put it in the <code>~/workspace/me/</code> directory. The directory structure of the released package is shown below.</p>
<pre><code class="language-bash">root@0a877562f39e:~/workspace/me/WasmEdge-0.9.1-Linux# pwd
/root/workspace/me/WasmEdge-0.9.1-Linux

root@0a877562f39e:~/workspace/me/WasmEdge-0.9.1-Linux# tree .
.
|-- bin
|   |-- wasmedge
|   `-- wasmedgec
|-- include
|   `-- wasmedge
|       |-- enum_configure.h
|       |-- enum_errcode.h
|       |-- enum_types.h
|       |-- int128.h
|       |-- version.h
|       `-- wasmedge.h
`-- lib64
    `-- libwasmedge_c.so

4 directories, 9 files
</code></pre>
</li>
<li>
<p>Set <code>WASMEDGE_INCLUDE_DIR</code> and <code>WASMEDGE_LIB_DIR</code> environment variables to specify the <code>include</code> and <code>lib</code> (or <code>lib64</code>) directories. After that, go to the <code>wasmedge-sys</code> directory and <code>cargo build</code> the crate.</p>
<pre><code class="language-bash">root@0a877562f39e:~/workspace/me/WasmEdge/bindings/rust/wasmedge-sys# export WASMEDGE_INCLUDE_DIR=/root/workspace/me/WasmEdge-0.9.1-Linux/include/wasmedge

root@0a877562f39e:~/workspace/me/WasmEdge/bindings/rust/wasmedge-sys# export WASMEDGE_LIB_DIR=/root/workspace/me/WasmEdge-0.9.1-Linux/lib64
</code></pre>
</li>
</ul>
</li>
<li>
<p>By specifying <code>WASMEDGE_BUILD_DIR</code></p>
<ul>
<li>
<p>Suppose that you <code>git clone</code> WasmEdge repo in <code>~/workspace/me/WasmEdge</code>, and follow the <a href="https://wasmedge.org/book/en/extend/build.html">instructions</a> to build WasmEdge native library. The generated <code>include</code> and <code>lib</code> directories should be in <code>~/workspace/me/WasmEdge/build</code>.</p>
</li>
<li>
<p>Then, set <code>WASMEDGE_BUILD_DIR</code> environment variable to specify the <code>build</code> directory. After that, go to the <code>wasmedge-sys</code> directory and <code>cargo build</code> the crate.</p>
<pre><code class="language-bash">root@0a877562f39e:~/workspace/me/WasmEdge# export WASMEDGE_BUILD_DIR=/root/workspace/me/WasmEdge/build
</code></pre>
</li>
</ul>
</li>
<li>
<p>By the <code>standalone</code> mode</p>
<p>Besides the two methods mentioned above, the <code>standalone</code> mode enables building <code>WasmEdge</code> native library directly before building the crate itself.</p>
<ul>
<li>
<p>Suppose that you <code>git clone</code> WasmEdge repo in <code>~/workspace/me/WasmEdge</code>. Go to the <code>wasmedge-sys</code> directory, and follow the instructions shown below:</p>
<pre><code class="language-bash">// set WASMEDGE_DIR
root@0a877562f39e:~/workspace/me/WasmEdge/bindings/rust/wasmedge-sys# export WASMEDGE_DIR=/root/workspace/me/WasmEdge

// cargo build with standalone feature
root@0a877562f39e:~/workspace/me/WasmEdge/bindings/rust/wasmedge-sys# cargo build --features standalone
</code></pre>
</li>
</ul>
</li>
<li>
<p>By WasmEdge docker image</p>
<p>If you choose WasmEdge docker image to build your own container for development, the pre-built WasmEdge binary package is located in <code>$HOME/.wasmedge</code> directory by default. The build script (<code>build.rs</code>) of <code>wasmedge-sys</code> crate can detect the package and build the crate automatically.</p>
</li>
</ul>
<h2 id="examples-2"><a class="header" href="#examples-2">Examples</a></h2>
<ul>
<li>
<p><a href="embed/rust/sys_run_host_func.html">[wasmedge-sys] Run a WebAssembly function with WasmEdge low-level APIs</a></p>
</li>
<li>
<p><a href="embed/rust/concurrent_fib.html">[wasmedge-sys] Compute Fibonacci numbers concurrently</a></p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="run-a-webassembly-function-with-wasmedge-low-level-rust-apis"><a class="header" href="#run-a-webassembly-function-with-wasmedge-low-level-rust-apis">Run a WebAssembly function with WasmEdge low-level Rust APIs</a></h1>
<p>This section demonstrates how to use the Rust APIs of the <code>wasmedge-sys</code> crate to run a host function.</p>
<p>As you may know, several mainstream programming languages, such as C/C++, Rust, Go, and Python, support compiling their programs into WebAssembly binary. In this demo, we'll introduce how to use WasmEdge Rust APIs to call a WebAssembly function which could be coded in any programming language mentioned above.</p>
<p>We use <code>fibonacci.wasm</code> in this demo, and the contents of the WebAssembly file are presented below. The statement, <code>(export &quot;fib&quot; (func $fib))</code>, declares an exported function named <code>fib</code>. This function computes a Fibonacci number with a given <code>i32</code> number as input. We'll use the function name later to achieve the goal of computing a Fibonacci number.</p>
<pre><code class="language-wasm">(module
  (export &quot;fib&quot; (func $fib))
  (func $fib (param $n i32) (result i32)
    (if
      (i32.lt_s
        (get_local $n)
        (i32.const 2)
      )
      (return
        (i32.const 1)
      )
    )
    (return
      (i32.add
        (call $fib
          (i32.sub
            (get_local $n)
            (i32.const 2)
          )
        )
        (call $fib
          (i32.sub
            (get_local $n)
            (i32.const 1)
          )
        )
      )
    )
  )
)
</code></pre>
<h2 id="step-1-create-a-wasmedge-ast-module"><a class="header" href="#step-1-create-a-wasmedge-ast-module">Step 1: Create a WasmEdge AST Module</a></h2>
<p>In this step,  we'll create a WasmEdge <code>AST Module</code> instance from a WebAssembly file.</p>
<ul>
<li>
<p>First, create a <code>Loader</code> context;</p>
</li>
<li>
<p>Then, load a specified WebAssebly file (&quot;fibonacci.wasm&quot;) via the <code>from_file</code> method of the <code>Loader</code> context. If the process is successful, then a WasmEdge <code>AST Module</code> instance is returned.</p>
</li>
</ul>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use wasmedge_sys::Loader;
use std::path::PathBuf;

// create a Loader context
let loader = Loader::create(None).expect(&quot;fail to create a Loader context&quot;);

// load a wasm module from a specified wasm file, and return a WasmEdge AST Module instance
let path = PathBuf::from(&quot;fibonacci.wasm&quot;);
let module = loader.from_file(path).expect(&quot;fail to load the WebAssembly file&quot;);
<span class="boring">}
</span></code></pre></pre>
<h2 id="step-2-create-a-wasmedge-vm-context"><a class="header" href="#step-2-create-a-wasmedge-vm-context">Step 2: Create a WasmEdge <code>Vm</code> context</a></h2>
<p>In WasmEdge, a <code>Vm</code> defines a running environment, in which all varieties of instances and contexts are stored and maintained. In the demo code below, we explicitly create a WasmEdge <code>Store</code> context, and then use it as one of the inputs in the creation of a <code>Vm</code> context. If not specify a <code>Store</code> context explicitly, then <code>Vm</code> will create a store by itself.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use wasmedge_sys::{Config, Store, Vm};

// create a Config context
let config = Config::create().expect(&quot;fail to create a Config context&quot;);

// create a Store context
let mut store = Store::create().expect(&quot;fail to create a Store context&quot;);

// create a Vm context with the given Config and Store
let mut vm = Vm::create(Some(config), Some(&amp;mut store)).expect(&quot;fail to create a Vm context&quot;);
<span class="boring">}
</span></code></pre></pre>
<h2 id="step-3-invoke-the-fib-function"><a class="header" href="#step-3-invoke-the-fib-function">Step 3: Invoke the <code>fib</code> function</a></h2>
<p>In Step 1, we got a module that hosts the target <code>fib</code> function defined in the WebAssembly. Now, we can call the function via the <code>run_wasm_from_module</code> method of the <code>Vm</code> context by passing the exported function name, <code>fib</code>.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use wasmedge_sys::Value;

// run a function
let returns = vm.run_wasm_from_module(module, &quot;fib&quot;, [Value::from_i32(5)]).expect(&quot;fail to run the target function in the module&quot;);

println!(&quot;The result of fib(5) is {}&quot;, returns[0].to_i32());
<span class="boring">}
</span></code></pre></pre>
<p>This is the final result printing on the screen:</p>
<pre><code class="language-bash">The result of fib(5) is 8
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="compute-fibonacci-numbers-concurrently"><a class="header" href="#compute-fibonacci-numbers-concurrently">Compute Fibonacci numbers concurrently</a></h1>
<p>In this example, we will demonstrate how to use the objects and the APIs defined in <code>wasmedge-sys</code> to compute Fibonacci numbers concurrently.</p>
<p>In the following code, we creates two child threads, <code>thread_a</code> and <code>thread_b</code>, which are responsbile for compute <code>Fib(4)</code> and <code>Fib(5)</code> by calling the host function <code>fib</code>, respectively. After that, the main thread computes <code>Fib(6)</code> by adding the numbers returned by <code>thread_a</code> and <code>thread_b</code>.</p>
<ul>
<li>
<p>Step 1: create a Vm context and register the WebAssembly module.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// create a Config context
let mut config = Config::create()?;
config.bulk_memory_operations(true);

// create a Store context
let mut store = Store::create()?;

// create a Vm context with the given Config and Store
let mut vm = Vm::create(Some(config), Some(&amp;mut store))?;

// register a wasm module from a wasm file
let file = std::path::PathBuf::from(env!(&quot;WASMEDGE_DIR&quot;))
    .join(&quot;bindings/rust/wasmedge-sys/tests/data/fibonacci.wasm&quot;);
vm.register_wasm_from_file(&quot;extern&quot;, file)?;
<span class="boring">}
</span></code></pre></pre>
</li>
<li>
<p>Step 2: create two child threads to compute <code>Fib(4)</code> and <code>Fib(5)</code> respectively.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let vm = Arc::new(Mutex::new(vm));

// compute fib(4) by a child thread
let vm_cloned = Arc::clone(&amp;vm);
let handle_a = thread::spawn(move || {
  let vm_child_thread = vm_cloned.lock().expect(&quot;fail to lock vm&quot;);
  let returns = vm_child_thread
    .run_registered_function(&quot;extern&quot;, &quot;fib&quot;, [Value::from_i32(4)])
    .expect(&quot;fail to compute fib(4)&quot;);

  let fib4 = returns[0].to_i32();
  println!(&quot;fib(4) by child thread: {}&quot;, fib4);

  fib4
});

// compute fib(5) by a child thread
let vm_cloned = Arc::clone(&amp;vm);
let handle_b = thread::spawn(move || {
  let vm_child_thread = vm_cloned.lock().expect(&quot;fail to lock vm&quot;);
  let returns = vm_child_thread
    .run_registered_function(&quot;extern&quot;, &quot;fib&quot;, [Value::from_i32(5)])
    .expect(&quot;fail to compute fib(5)&quot;);

  let fib5 = returns[0].to_i32();
  println!(&quot;fib(5) by child thread: {}&quot;, fib5);

  fib5
});

<span class="boring">}
</span></code></pre></pre>
</li>
<li>
<p>Step3: Get the returns from the two child threads, and compute <code>Fib(6)</code>.</p>
<pre><code class="language-Rust">let fib4 = handle_a.join().unwrap();
let fib5 = handle_b.join().unwrap();

// compute fib(6)
println!(&quot;fib(6) = fib(5) + fib(1) = {}&quot;, fib5 + fib4);
</code></pre>
</li>
</ul>
<p>The final result of the code above should be printed on the screen like below:</p>
<pre><code class="language-bash">fib(4) by child thread: 5
fib(5) by child thread: 8
fib(6) = fib(5) + fib(1) = 13
</code></pre>
<p>The complete code in this demo can be found on <a href="https://github.com/WasmEdge/WasmEdge/blob/master/bindings/rust/wasmedge-sys/examples/threads.rs">WasmEdge Github</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="python-sdk"><a class="header" href="#python-sdk">Python SDK</a></h1>
<p>Coming soon, or you can <a href="https://github.com/WasmEdge/WasmEdge/pull/633">help out</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="wasmedge-in-kubernetes"><a class="header" href="#wasmedge-in-kubernetes">WasmEdge in Kubernetes</a></h1>
<p>Developers can leverage container tools such as Kubernetes, Docker and CRI-O to deploy, manage, and run lightweight WebAssembly applications. In this chapter, we will demonstrate how Kubernetes ecosystem tools work with <a href="https://github.com/WasmEdge/WasmEdge">WasmEdge</a> WebAssembly applications.</p>
<p>Compared with Linux containers, <a href="https://www.infoq.com/articles/arm-vs-x86-cloud-performance/">WebAssembly could be 100x faster at startup</a>, have a much smaller memory and disk footprint, and have a better-defined safety sandbox. However, the trade-off is that WebAssembly requires its own language SDKs, and compiler toolchains, making it a more constrained developer environment than Linux containers. WebAssembly is increasingly used in Edge Computing scenarios where it is difficult to deploy Linux containers or when the application performance is vital.</p>
<p>One of the great advantages of Linux application containers is the rich ecosystem of tools. The good news is that you can use the exact same tools to manage WebAssembly applications, enabling Linux containers and WebAssembly apps to run side-by-side in the same system.</p>
<p><img src="kubernetes.png" alt="kubernetes" /></p>
<p>The contents of this chapter are organized as follows.</p>
<ul>
<li><a href="kubernetes/quickstart.html">Quick start</a> provides simple and scripted tutorials to run WasmEdge-based applications as container images in Kubernetes.</li>
<li><a href="kubernetes/demo.html">Demo apps</a> discusses the two demo WasmEdge applications we will run in Kubernetes clusters. Those applications are compiled from Rust source code, packaged as OCI images, and uploaded to Docker Hub.</li>
<li><a href="kubernetes/container.html">Container runtimes</a> covers how to configure low level container runtimes, such as crun, to load and run WebAssembly OCI images.</li>
<li><a href="kubernetes/cri.html">CRI runtimes</a> covers how to configure and use high level container runtimes, such as CRI-O and containerd, to load and run WebAssembly OCI images on top of low level container runtimes.</li>
<li><a href="kubernetes/kubernetes.html">Kubernetes</a> covers how to configure and use Kubernetes and Kubernetes variations, such as KubeEdge and SuperEdge, to load and run WebAssembly OCI images on top of CRI runtimes.</li>
</ul>
<p>The goal is to load and run WebAssembly OCI images side by side with Linux OCI images (e.g., today's Docker containers) across the entire Kubernetes stack.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="quick-start"><a class="header" href="#quick-start">Quick start</a></h1>
<p>We have created Ubuntu-based scripts for you to quickly get started with the following combination of runtimes in a standard Kubernetes setup.</p>
<table><thead><tr><th>CRI (high level) runtime</th><th>OCI (low level) runtime</th><th></th></tr></thead><tbody>
<tr><td>CRI-O</td><td>crun + WasmEdge</td><td><a href="https://github.com/second-state/wasmedge-containers-examples/blob/main/.github/workflows/kubernetes-crio.yml">Script</a></td></tr>
<tr><td>containerd</td><td>crun + WasmEdge</td><td><a href="https://github.com/second-state/wasmedge-containers-examples/blob/main/.github/workflows/kubernetes-containerd.yml">Script</a></td></tr>
</tbody></table>
<h2 id="cri-o-and-crun"><a class="header" href="#cri-o-and-crun">CRI-O and crun</a></h2>
<p>You can use the CRI-O <a href="https://github.com/second-state/wasmedge-containers-examples/blob/main/crio/install.sh">install.sh</a> script to install CRI-O and <code>crun</code> on Ubuntu 20.04.</p>
<pre><code class="language-bash">wget -qO- https://raw.githubusercontent.com/second-state/wasmedge-containers-examples/main/crio/install.sh | bash
</code></pre>
<p>Next, install Kubernetes using the <a href="https://github.com/second-state/wasmedge-containers-examples/blob/main/kubernetes_crio/install.sh">following script</a>.</p>
<pre><code class="language-bash">wget -qO- https://raw.githubusercontent.com/second-state/wasmedge-containers-examples/main/kubernetes_crio/install.sh | bash
</code></pre>
<p>The <a href="https://github.com/second-state/wasmedge-containers-examples/blob/main/kubernetes_crio/simple_wasi_application.sh">simple_wasi_application.sh</a> script shows how to pull <a href="kubernetes/demo/wasi.html">a WebAssembly application</a> from Docker Hub, and then run it as a containerized application in Kubernetes.</p>
<pre><code class="language-bash">wget -qO- https://raw.githubusercontent.com/second-state/wasmedge-containers-examples/main/kubernetes_crio/simple_wasi_application.sh | bash
</code></pre>
<p>You should see results from the WebAssembly program printed in the console log. <a href="https://github.com/second-state/wasmedge-containers-examples/runs/4186005677?check_suite_focus=true#step:6:3007">Here is an example</a>.</p>
<h2 id="containerd-and-crun"><a class="header" href="#containerd-and-crun">containerd and crun</a></h2>
<p>You can use the containerd <a href="https://github.com/second-state/wasmedge-containers-examples/blob/main/containerd/install.sh">install.sh</a> script to install <code>containerd</code> and <code>crun</code> on Ubuntu 20.04.</p>
<pre><code class="language-bash">wget -qO- https://raw.githubusercontent.com/second-state/wasmedge-containers-examples/main/containerd/install.sh | bash
</code></pre>
<p>Next, install Kubernetes using the <a href="https://github.com/second-state/wasmedge-containers-examples/blob/main/kubernetes_containerd/install.sh">following script</a>.</p>
<pre><code class="language-bash">wget -qO- https://raw.githubusercontent.com/second-state/wasmedge-containers-examples/main/kubernetes_containerd/install.sh | bash
</code></pre>
<p>The <a href="https://github.com/second-state/wasmedge-containers-examples/blob/main/kubernetes_containerd/simple_wasi_application.sh">simple_wasi_application.sh</a> script shows how to pull <a href="kubernetes/demo/wasi.html">a WebAssembly application</a> from Docker Hub, and then run it as a containerized application in Kubernetes.</p>
<pre><code class="language-bash">wget -qO- https://raw.githubusercontent.com/second-state/wasmedge-containers-examples/main/kubernetes_containerd/simple_wasi_application.sh | bash
</code></pre>
<p>You should see results from the WebAssembly program printed in the console log. <a href="https://github.com/second-state/wasmedge-containers-examples/runs/4577789181?check_suite_focus=true#step:6:3010">Here is an example</a>.</p>
<p>Read on to the rest of this chapter to learn how exactly those runtimes are configured.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="demo-apps"><a class="header" href="#demo-apps">Demo apps</a></h1>
<p>In this chapter, we will cover two demo apps. We will build them from Rust source code, build OCI images around them, and then publish the images to Docker Hub.</p>
<p>If you have not done so, please</p>
<ul>
<li><a href="https://www.rust-lang.org/tools/install">Install Rust</a></li>
<li><a href="https://hub.docker.com/">Register for Docker Hub</a></li>
</ul>
<p>Next, explore the examples</p>
<ul>
<li><a href="kubernetes/demo/wasi.html">A simple WASI example</a></li>
<li><a href="kubernetes/demo/server.html">A HTTP server example</a></li>
</ul>
<p>Since we have already built and published those demo apps on Docker Hub, you could also just go straight to the container runtime sections to use these images.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="a-simple-webassembly-example"><a class="header" href="#a-simple-webassembly-example">A simple WebAssembly example</a></h1>
<p>In this article, I will show you how to build a container image for a WebAssembly application. It can then be started and managed by Kubernetes ecosystem tools, such as CRI-O, Docker, crun, and Kubernetes.</p>
<h2 id="prerequisites-2"><a class="header" href="#prerequisites-2">Prerequisites</a></h2>
<blockquote>
<p>If you simply want a wasm bytecode file to test as a container image, you can skip the building process and just <a href="https://github.com/second-state/wasm-learning/blob/master/cli/wasi/wasi_example_main.wasm">download the wasm file here</a>.</p>
</blockquote>
<p>If you have not done so already, follow these simple instructions to <a href="https://www.rust-lang.org/tools/install">install Rust</a>.</p>
<h2 id="download-example-code"><a class="header" href="#download-example-code">Download example code</a></h2>
<pre><code class="language-bash">git clone https://github.com/second-state/wasm-learning
cd wasm-learning/cli/wasi
</code></pre>
<h2 id="build-the-wasm-bytecode"><a class="header" href="#build-the-wasm-bytecode">Build the WASM bytecode</a></h2>
<pre><code class="language-bash">rustup target add wasm32-wasi
cargo build --target wasm32-wasi --release
</code></pre>
<p>The wasm bytecode application is in the <code>target/wasm32-wasi/release/wasi_example_main.wasm</code> file. You can now publish and use it as a container image.</p>
<h2 id="apply-executable-permission-on-the-wasm-bytecode"><a class="header" href="#apply-executable-permission-on-the-wasm-bytecode">Apply executable permission on the Wasm bytecode</a></h2>
<pre><code class="language-bash">chmod +x target/wasm32-wasi/release/wasi_example_main.wasm
</code></pre>
<h2 id="create-dockerfile"><a class="header" href="#create-dockerfile">Create Dockerfile</a></h2>
<p>Create a file called <code>Dockerfile</code> in the <code>target/wasm32-wasi/release/</code> folder with the following content:</p>
<pre><code class="language-dockerfile">FROM scratch
ADD wasi_example_main.wasm /
CMD [&quot;/wasi_example_main.wasm&quot;]
</code></pre>
<h2 id="create-container-image-with-annotations"><a class="header" href="#create-container-image-with-annotations">Create container image with annotations</a></h2>
<blockquote>
<p>Please note that adding self-defined annotation is still a new feature in buildah.</p>
</blockquote>
<p>The <code>crun</code> container runtime can start the above WebAssembly-based container image. But it requires the <code>module.wasm.image/variant=compat</code> annotation on the container image to indicate that it is a WebAssembly application without a guest OS. You can find the details in <a href="https://github.com/containers/crun/blob/main/docs/wasm-wasi-example.md">Official crun repo</a>.</p>
<p>To add <code>module.wasm.image/variant=compat</code> annotation in the container image, you will need the latest <a href="https://buildah.io/">buildah</a>. Currently, Docker does not support this feature. Please follow <a href="https://github.com/containers/buildah/blob/main/install.md">the install instructions of buildah</a> to build the latest buildah binary.</p>
<h3 id="build-and-install-the-latest-buildah-on-ubuntu"><a class="header" href="#build-and-install-the-latest-buildah-on-ubuntu">Build and install the latest buildah on Ubuntu</a></h3>
<p>On Ubuntu zesty and xenial, use these commands to prepare for buildah.</p>
<pre><code class="language-bash">sudo apt-get -y install software-properties-common

export OS=&quot;xUbuntu_20.04&quot;
sudo bash -c &quot;echo \&quot;deb https://download.opensuse.org/repositories/devel:/kubic:/libcontainers:/stable/$OS/ /\&quot; &gt; /etc/apt/sources.list.d/devel:kubic:libcontainers:stable.list&quot;
sudo bash -c &quot;curl -L https://download.opensuse.org/repositories/devel:/kubic:/libcontainers:/stable/$OS/Release.key | apt-key add -&quot;

sudo add-apt-repository -y ppa:alexlarsson/flatpak
sudo apt-get -y -qq update
sudo apt-get -y install bats git libapparmor-dev libdevmapper-dev libglib2.0-dev libgpgme-dev libseccomp-dev libselinux1-dev skopeo-containers go-md2man containers-common
sudo apt-get -y install golang-1.16 make
</code></pre>
<p>Then, follow these steps to build and install buildah on Ubuntu.</p>
<pre><code class="language-bash">mkdir -p ~/buildah
cd ~/buildah
export GOPATH=`pwd`
git clone https://github.com/containers/buildah ./src/github.com/containers/buildah
cd ./src/github.com/containers/buildah
PATH=/usr/lib/go-1.16/bin:$PATH make
cp bin/buildah /usr/bin/buildah
buildah --help
</code></pre>
<h3 id="create-and-publish-a-container-image-with-buildah"><a class="header" href="#create-and-publish-a-container-image-with-buildah">Create and publish a container image with buildah</a></h3>
<p>In the <code>target/wasm32-wasi/release/</code> folder, do the following.</p>
<pre><code class="language-bash">$ sudo buildah build --annotation &quot;module.wasm.image/variant=compat&quot; -t wasm-wasi-example .
# make sure docker is install and running
# systemctl status docker
# to make sure regular user can use docker
# sudo usermod -aG docker $USER
# newgrp docker

# You may need to use docker login to create the `~/.docker/config.json` for auth.
$ sudo buildah push --authfile ~/.docker/config.json wasm-wasi-example docker://docker.io/hydai/wasm-wasi-example:with-wasm-annotation
</code></pre>
<p>That's it! Now you can try to run it in <a href="kubernetes/demo/../cri/crio.html#run-a-simple-webassembly-app">CRI-O</a> or <a href="kubernetes/demo/../kubernetes/kubernetes.html#run-a-simple-webassembly-app">Kubernetes</a>!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="http-server-example"><a class="header" href="#http-server-example">HTTP server example</a></h1>
<p>Let's build a container image for a WebAssembly HTTP service.
The HTTP service application is developed in Rust using the <a href="https://github.com/second-state/wasmedge_wasi_socket">WasmEdge networking socket API</a>.
Kubernetes could manage the wasm application lifecycle with CRI-O, Docker and Containerd.</p>
<h2 id="prerequisites-3"><a class="header" href="#prerequisites-3">Prerequisites</a></h2>
<p>This is a Rust example, which require you to install <a href="https://www.rust-lang.org/tools/install">Rust</a> and <a href="kubernetes/demo/../../start/install.html">WasmEdge</a> before you can Compile and Run the http service.</p>
<h2 id="download-example-code-1"><a class="header" href="#download-example-code-1">Download example code</a></h2>
<pre><code class="language-bash">mkdir http_server
cd http_server
wget -q https://raw.githubusercontent.com/second-state/wasmedge_wasi_socket/main/examples/http_server/Cargo.toml
mkdir src
cd src
wget -q https://raw.githubusercontent.com/second-state/wasmedge_wasi_socket/main/examples/http_server/src/main.rs
cd ../
</code></pre>
<h2 id="build-the-wasm-bytecode-1"><a class="header" href="#build-the-wasm-bytecode-1">Build the WASM bytecode</a></h2>
<pre><code class="language-bash">rustup target add wasm32-wasi
cargo build --target wasm32-wasi --release
</code></pre>
<p>The wasm bytecode application is now should be located in the <code>./target/wasm32-wasi/release/http_server.wasm</code>
You can now test run it with wasmedge and then publish it as a container image.</p>
<h2 id="apply-executable-permission-on-the-wasm-bytecode-1"><a class="header" href="#apply-executable-permission-on-the-wasm-bytecode-1">Apply executable permission on the Wasm bytecode</a></h2>
<pre><code class="language-bash">chmod +x ./target/wasm32-wasi/release/http_server.wasm
</code></pre>
<h2 id="running-the-http_server-application-bytecode-with-wasmedge"><a class="header" href="#running-the-http_server-application-bytecode-with-wasmedge">Running the http_server application bytecode with wasmedge</a></h2>
<p>When you run the bytecode with wasmedge and see the result as the following, you are ready to package the bytecode into the container.</p>
<pre><code class="language-bash">$ wasmedge ./target/wasm32-wasi/release/http_server.wasm
new connection at 1234
</code></pre>
<p>You can test the server from another terminal window.</p>
<pre><code class="language-bash">$ curl -X POST http://127.0.0.1:1234 -d 'name=WasmEdge'
echo: name=WasmEdge
</code></pre>
<h2 id="create-dockerfile-1"><a class="header" href="#create-dockerfile-1">Create Dockerfile</a></h2>
<p>Create a file called <code>Dockerfile</code> in the <code>target/wasm32-wasi/release/</code> folder with the following content:</p>
<pre><code class="language-dockerfile">FROM scratch
ADD http_server.wasm /
CMD [&quot;/http_server.wasm&quot;]
</code></pre>
<h2 id="create-container-image-with-annotations-1"><a class="header" href="#create-container-image-with-annotations-1">Create container image with annotations</a></h2>
<blockquote>
<p>Please note that adding self-defined annotation is still a new feature in buildah.</p>
</blockquote>
<p>The <code>crun</code> container runtime can start the above WebAssembly-based container image. But it requires the <code>module.wasm.image/variant=compat</code> annotation on the container image to indicate that it is a WebAssembly application without a guest OS. You can find the details in <a href="https://github.com/containers/crun/blob/main/docs/wasm-wasi-example.md">Official crun repo</a>.</p>
<p>To add <code>module.wasm.image/variant=compat</code> annotation in the container image, you will need the latest <a href="https://buildah.io/">buildah</a>. Currently, Docker does not support this feature. Please follow <a href="https://github.com/containers/buildah/blob/main/install.md">the install instructions of buildah</a> to build the latest buildah binary.</p>
<h3 id="build-and-install-the-latest-buildah-on-ubuntu-1"><a class="header" href="#build-and-install-the-latest-buildah-on-ubuntu-1">Build and install the latest buildah on Ubuntu</a></h3>
<p>On Ubuntu zesty and xenial, use these commands to prepare for buildah.</p>
<pre><code class="language-bash">sudo apt-get -y install software-properties-common

export OS=&quot;xUbuntu_20.04&quot;
sudo bash -c &quot;echo \&quot;deb https://download.opensuse.org/repositories/devel:/kubic:/libcontainers:/stable/$OS/ /\&quot; &gt; /etc/apt/sources.list.d/devel:kubic:libcontainers:stable.list&quot;
sudo bash -c &quot;curl -L https://download.opensuse.org/repositories/devel:/kubic:/libcontainers:/stable/$OS/Release.key | apt-key add -&quot;

sudo add-apt-repository -y ppa:alexlarsson/flatpak
sudo apt-get -y -qq update

sudo apt-get -y install bats git libapparmor-dev libdevmapper-dev libglib2.0-dev libgpgme-dev libseccomp-dev libselinux1-dev skopeo-containers go-md2man containers-common
sudo apt-get -y install golang-1.16 make
</code></pre>
<p>Then, follow these steps to build and install buildah on Ubuntu.</p>
<pre><code class="language-bash">mkdir -p ~/buildah
cd ~/buildah
export GOPATH=`pwd`
git clone https://github.com/containers/buildah ./src/github.com/containers/buildah
cd ./src/github.com/containers/buildah
PATH=/usr/lib/go-1.16/bin:$PATH make
cp bin/buildah /usr/bin/buildah
buildah --help
</code></pre>
<h3 id="create-and-publish-a-container-image-with-buildah-1"><a class="header" href="#create-and-publish-a-container-image-with-buildah-1">Create and publish a container image with buildah</a></h3>
<p>In the <code>target/wasm32-wasi/release/</code> folder, do the following.</p>
<pre><code class="language-bash">sudo buildah build --annotation &quot;module.wasm.image/variant=compat&quot; -t http_server .

#
# make sure docker is install and running
# systemctl status docker
# to make sure regular user can use docker
# sudo usermod -aG docker $USER#
# newgrp docker

# You may need to use docker login to create the `~/.docker/config.json` for auth.
#
# docker login

sudo buildah push --authfile ~/.docker/config.json http_server docker://docker.io/avengermojo/http_server:with-wasm-annotation
</code></pre>
<p>That's it! Now you can try to run it in <a href="kubernetes/demo/../cri/crio.html#run-a-http-server-app">CRI-O</a> or <a href="kubernetes/demo/../kubernetes/kubernetes.html#run-a-http-server-app">Kubernetes</a>!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="container-runtimes"><a class="header" href="#container-runtimes">Container runtimes</a></h1>
<p>The container image can be started by any OCI-compliant container runtime, such as</p>
<ul>
<li><a href="kubernetes/container/crun.html">crun</a>: a high performance and lightweight container runtime written in C</li>
<li><a href="kubernetes/container/runc.html">runc</a>: a widely used container runtime written in Go</li>
<li><a href="kubernetes/container/youki.html">youki</a>: a OCI-compatible container runtime implementation written in Rust</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="crun"><a class="header" href="#crun">crun</a></h1>
<p>The <a href="https://github.com/containers/crun">crun project</a> has WasmEdge support baked in.
For now, the easiest approach is just built it yourself from source. First, let's make sure that <code>crun</code> dependencies are installed on your Ubuntu 20.04.
For other Linux distributions, please <a href="https://github.com/containers/crun#readme">see here</a>.</p>
<pre><code class="language-bash">sudo apt update
sudo apt install -y make git gcc build-essential pkgconf libtool \
    libsystemd-dev libprotobuf-c-dev libcap-dev libseccomp-dev libyajl-dev \
    go-md2man libtool autoconf python3 automake
</code></pre>
<p>Next, configure, build, and install a <code>crun</code> binary with WasmEdge support.</p>
<pre><code class="language-bash">git clone https://github.com/containers/crun
cd crun
./autogen.sh
./configure --with-wasmedge
make
sudo make install
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="runc"><a class="header" href="#runc">runc</a></h1>
<p>Coming soon, or you can <a href="https://github.com/WasmEdge/WasmEdge/issues/639">help out</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="youki"><a class="header" href="#youki">youki</a></h1>
<p>Coming soon, or you can <a href="https://github.com/WasmEdge/WasmEdge/issues/664">help out</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cri-runtimes"><a class="header" href="#cri-runtimes">CRI runtimes</a></h1>
<p>The high-level container runtime, such as <a href="https://cri-o.io/">CRI-O</a> and <a href="https://containerd.io/">containerd</a>, pulls container images from registries (e.g., Docker Hub), manages them on disk, and launches a lower-level runtime to run container processes.
From this chapter, you can check out specific tutorials for CRI-O and containerd.</p>
<ul>
<li><a href="kubernetes/cri/crio.html">CRI-O</a></li>
<li><a href="kubernetes/cri/containerd.html">containerd</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cri-o"><a class="header" href="#cri-o">CRI-O</a></h1>
<h2 id="quick-start-1"><a class="header" href="#quick-start-1">Quick start</a></h2>
<p>The <a href="https://github.com/second-state/wasmedge-containers-examples/">GitHub repo</a> contains scripts and Github Actions for running our example
apps on CRI-O.</p>
<ul>
<li>Simple WebAssembly example <a href="https://github.com/second-state/wasmedge-containers-examples/blob/main/crio/README.md">Quick start</a> | <a href="https://github.com/second-state/wasmedge-containers-examples/blob/main/.github/workflows/crio.yml">Github Actions</a> | <a href="https://github.com/second-state/wasmedge-containers-examples/runs/4317457300?check_suite_focus=true#step:4:37">Successful run</a></li>
<li>HTTP service example <a href="https://github.com/second-state/wasmedge-containers-examples/blob/main/crio/http_server/README.md">Quick start</a> | <a href="https://github.com/second-state/wasmedge-containers-examples/blob/main/.github/workflows/crio-server.yml">Github Actions</a> | <a href="https://github.com/second-state/wasmedge-containers-examples/runs/4317457313?check_suite_focus=true#step:4:54">Successful run</a></li>
</ul>
<p>In the sections below, we will explain the steps in the quick start scripts.</p>
<ul>
<li><a href="kubernetes/cri/crio.html#install-cri-o">Install CRI-O</a></li>
<li><a href="kubernetes/cri/crio.html#configure-cri-o-to-use-crun">Configure CRI-O and crun</a></li>
<li><a href="kubernetes/cri/crio.html#run-a-simple-webassembly-app">Example 1: Simple WebAssembly</a></li>
<li><a href="kubernetes/cri/crio.html#run-a-http-server-app">Example 2: HTTP server in WebAssembly</a></li>
</ul>
<h2 id="install-cri-o"><a class="header" href="#install-cri-o">Install CRI-O</a></h2>
<p>Use the following commands to install CRI-O on your system.</p>
<pre><code class="language-bash">export OS=&quot;xUbuntu_20.04&quot;
export VERSION=&quot;1.21&quot;
apt update
apt install -y libseccomp2 || sudo apt update -y libseccomp2
echo &quot;deb https://download.opensuse.org/repositories/devel:/kubic:/libcontainers:/stable/$OS/ /&quot; &gt; /etc/apt/sources.list.d/devel:kubic:libcontainers:stable.list
echo &quot;deb https://download.opensuse.org/repositories/devel:/kubic:/libcontainers:/stable:/cri-o:/$VERSION/$OS/ /&quot; &gt; /etc/apt/sources.list.d/devel:kubic:libcontainers:stable:cri-o:$VERSION.list

curl -L https://download.opensuse.org/repositories/devel:kubic:libcontainers:stable:cri-o:$VERSION/$OS/Release.key | apt-key add -
curl -L https://download.opensuse.org/repositories/devel:/kubic:/libcontainers:/stable/$OS/Release.key | apt-key add -

apt-get update
apt-get install criu libyajl2
apt-get install cri-o cri-o-runc cri-tools containernetworking-plugins
systemctl start crio
</code></pre>
<h2 id="configure-cri-o-to-use-crun"><a class="header" href="#configure-cri-o-to-use-crun">Configure CRI-O to use crun</a></h2>
<p>CRI-O uses the <code>runc</code> runtime by default and we need to configure it to use <code>crun</code> instead.
That is done by adding to two configuration files.</p>
<blockquote>
<p>Make sure that you have <a href="kubernetes/cri/../container/crun.html">built and installed the <code>crun</code> binary with WasmEdge support</a> before starting the following steps.</p>
</blockquote>
<p>First, create a <code>/etc/crio/crio.conf</code> file and add the following lines as its content. It tells CRI-O to use <code>crun</code> by default.</p>
<pre><code class="language-conf">[crio.runtime]
default_runtime = &quot;crun&quot;
</code></pre>
<p>The <code>crun</code> runtime is in turn defined in the <code>/etc/crio/crio.conf.d/01-crio-runc.conf</code> file.</p>
<pre><code class="language-conf">[crio.runtime.runtimes.runc]
runtime_path = &quot;/usr/lib/cri-o-runc/sbin/runc&quot;
runtime_type = &quot;oci&quot;
runtime_root = &quot;/run/runc&quot;
# The above is the original content

# Add our crunw runtime here
[crio.runtime.runtimes.crun]
runtime_path = &quot;/usr/bin/crun&quot;
runtime_type = &quot;oci&quot;
runtime_root = &quot;/run/crun&quot;
</code></pre>
<p>Next, restart CRI-O to apply the configuration changes.</p>
<pre><code class="language-bash">systemctl restart crio
</code></pre>
<h2 id="run-a-simple-webassembly-app"><a class="header" href="#run-a-simple-webassembly-app">Run a simple WebAssembly app</a></h2>
<p>Now, we can run a simple WebAssembly program using CRI-O.
<a href="kubernetes/cri/../demo/wasi.html">A separate article</a> explains how to compile, package, and publish the WebAssembly
program as a container image to Docker hub.
In this section, we will start off pulling this WebAssembly-based container
image from Docker hub using CRI-O tools.</p>
<pre><code class="language-bash">sudo crictl pull docker.io/hydai/wasm-wasi-example:with-wasm-annotation
</code></pre>
<p>Next, we need to create two simple configuration files that specifies how
CRI-O should run this WebAssembly image in a sandbox. We already have those
two files <a href="https://github.com/second-state/wasmedge-containers-examples/blob/main/crio/container_wasi.json">container_wasi.json</a> and <a href="https://github.com/second-state/wasmedge-containers-examples/blob/main/crio/sandbox_config.json">sandbox_config.json</a>.
You can just download them to your local directory as follows.</p>
<pre><code class="language-bash">wget https://raw.githubusercontent.com/second-state/wasmedge-containers-examples/main/crio/sandbox_config.json
wget https://raw.githubusercontent.com/second-state/wasmedge-containers-examples/main/crio/container_wasi.json
</code></pre>
<p>Now you can use CRI-O to create a pod and a container using the specified configurations.</p>
<pre><code class="language-bash"># Create the POD. Output will be different from example.
$ sudo crictl runp sandbox_config.json
7992e75df00cc1cf4bff8bff660718139e3ad973c7180baceb9c84d074b516a4
# Set a helper variable for later use.
$ POD_ID=7992e75df00cc1cf4bff8bff660718139e3ad973c7180baceb9c84d074b516a4

# Create the container instance. Output will be different from example.
$ sudo crictl create $POD_ID container_wasi.json sandbox_config.json
# Set a helper variable for later use.
CONTAINER_ID=1d056e4a8a168f0c76af122d42c98510670255b16242e81f8e8bce8bd3a4476f
</code></pre>
<p>Starting the container would execute the WebAssembly program. You can see the output in the console.</p>
<pre><code class="language-bash"># List the container, the state should be `Created`
$ sudo crictl ps -a
CONTAINER           IMAGE                                          CREATED              STATE               NAME                     ATTEMPT             POD ID
1d056e4a8a168       hydai/wasm-wasi-example:with-wasm-annotation   About a minute ago   Created             podsandbox1-wasm-wasi   0                   7992e75df00cc

# Start the container
$ sudo crictl start $CONTAINER_ID

# Check the container status again.
# If the container is not finishing its job, you will see the Running state
# Because this example is very tiny. You may see Exited at this moment.
$ sudo crictl ps -a
CONTAINER           IMAGE                                          CREATED              STATE               NAME                     ATTEMPT             POD ID
1d056e4a8a168       hydai/wasm-wasi-example:with-wasm-annotation   About a minute ago   Running             podsandbox1-wasm-wasi   0                   7992e75df00cc

# When the container is finished. You can see the state becomes Exited.
$ sudo crictl ps -a
CONTAINER           IMAGE                                          CREATED              STATE               NAME                     ATTEMPT             POD ID
1d056e4a8a168       hydai/wasm-wasi-example:with-wasm-annotation   About a minute ago   Exited              podsandbox1-wasm-wasi   0                   7992e75df00cc

# Check the container's logs. It should show outputs from the WebAssembly programs
$ sudo crictl logs $CONTAINER_ID

Test 1: Print Random Number
Random number: 960251471

Test 2: Print Random Bytes
Random bytes: [50, 222, 62, 128, 120, 26, 64, 42, 210, 137, 176, 90, 60, 24, 183, 56, 150, 35, 209, 211, 141, 146, 2, 61, 215, 167, 194, 1, 15, 44, 156, 27, 179, 23, 241, 138, 71, 32, 173, 159, 180, 21, 198, 197, 247, 80, 35, 75, 245, 31, 6, 246, 23, 54, 9, 192, 3, 103, 72, 186, 39, 182, 248, 80, 146, 70, 244, 28, 166, 197, 17, 42, 109, 245, 83, 35, 106, 130, 233, 143, 90, 78, 155, 29, 230, 34, 58, 49, 234, 230, 145, 119, 83, 44, 111, 57, 164, 82, 120, 183, 194, 201, 133, 106, 3, 73, 164, 155, 224, 218, 73, 31, 54, 28, 124, 2, 38, 253, 114, 222, 217, 202, 59, 138, 155, 71, 178, 113]

Test 3: Call an echo function
Printed from wasi: This is from a main function
This is from a main function

Test 4: Print Environment Variables
The env vars are as follows.
PATH: /usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
TERM: xterm
HOSTNAME: crictl_host
PATH: /usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
The args are as follows.
/var/lib/containers/storage/overlay/006e7cf16e82dc7052994232c436991f429109edea14a8437e74f601b5ee1e83/merged/wasi_example_main.wasm
50000000

Test 5: Create a file `/tmp.txt` with content `This is in a file`

Test 6: Read the content from the previous file
File content is This is in a file

Test 7: Delete the previous file
</code></pre>
<p>Next, you can try to run the app in <a href="kubernetes/cri/../kubernetes/kubernetes-crio.html">Kubernetes</a>!</p>
<h2 id="run-a-http-server-app"><a class="header" href="#run-a-http-server-app">Run a HTTP server app</a></h2>
<p>Finally, we can run a simple WebAssembly-based HTTP micro-service in CRI-O.
<a href="kubernetes/cri/../demo/server.html">A separate article</a> explains how to compile, package, and publish the WebAssembly
program as a container image to Docker hub.
In this section, we will start off pulling this WebAssembly-based container
image from Docker hub using CRI-O tools.</p>
<pre><code class="language-bash">sudo crictl pull docker.io/avengermojo/http_server:with-wasm-annotation
</code></pre>
<p>Next, we need to create two simple configuration files that specifies how
CRI-O should run this WebAssembly image in a sandbox. We already have those
two files <a href="https://raw.githubusercontent.com/second-state/wasmedge-containers-examples/main/crio/http_server/container_http_server.json">container_http_server.json</a> and <a href="https://github.com/second-state/wasmedge-containers-examples/blob/main/crio/sandbox_config.json">sandbox_config.json</a>.
You can just download them to your local directory as follows.</p>
<blockquote>
<p>The <code>sandbox_config.json</code> file is the same for the simple WASI example and the HTTP server example. The other <code>container_*.json</code> file is application specific as it contains the application's Docker Hub URL.</p>
</blockquote>
<pre><code class="language-bash">wget https://raw.githubusercontent.com/second-state/wasmedge-containers-examples/main/crio/sandbox_config.json
wget https://raw.githubusercontent.com/second-state/wasmedge-containers-examples/main/crio/http_server/container_http_server.json
</code></pre>
<p>Now you can use CRI-O to create a pod and a container using the specified configurations.</p>
<pre><code class="language-bash"># Create the POD. Output will be different from example.
$ sudo crictl runp sandbox_config.json
7992e75df00cc1cf4bff8bff660718139e3ad973c7180baceb9c84d074b516a4
# Set a helper variable for later use.
$ POD_ID=7992e75df00cc1cf4bff8bff660718139e3ad973c7180baceb9c84d074b516a4

# Create the container instance. Output will be different from example.
$ sudo crictl create $POD_ID container_http_server.json sandbox_config.json
# Set a helper variable for later use.
CONTAINER_ID=1d056e4a8a168f0c76af122d42c98510670255b16242e81f8e8bce8bd3a4476f
</code></pre>
<p>Starting the container would execute the WebAssembly program. You can see the output in the console.</p>
<pre><code class="language-bash"># Start the container
$ sudo crictl start $CONTAINER_ID

# Check the container status. It should be Running. 
# If not, wait a few seconds and check again
$ sudo crictl ps -a
CONTAINER           IMAGE                                          CREATED                  STATE               NAME                ATTEMPT             POD ID
4eeddf8613691       avengermojo/http_server:with-wasm-annotation   Less than a second ago   Running             http_server         0                   1d84f30e7012e

# Check the container's logs to see the HTTP server is listening at port 1234
$ sudo crictl logs $CONTAINER_ID
new connection at 1234

# Get the IP address assigned to the container
$ sudo crictl inspect $CONTAINER_ID | grep IP.0 | cut -d: -f 2 | cut -d'&quot;' -f 2
10.85.0.2

# Test the HTTP service at that IP address
$ curl -d &quot;name=WasmEdge&quot; -X POST http://10.85.0.2:1234
echo: name=WasmEdge
</code></pre>
<p>Next, you can try to run it in <a href="kubernetes/cri/../kubernetes/kubernetes-crio.html">Kubernetes</a>!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="containerd"><a class="header" href="#containerd">containerd</a></h1>
<h2 id="quick-start-2"><a class="header" href="#quick-start-2">Quick start</a></h2>
<p>The <a href="https://github.com/second-state/wasmedge-containers-examples/">GitHub repo</a> contains scripts and Github Actions for running our example
apps on containerd.</p>
<ul>
<li>Simple WebAssembly example <a href="https://github.com/second-state/wasmedge-containers-examples/blob/main/containerd/README.md">Quick start</a> | <a href="https://github.com/second-state/wasmedge-containers-examples/blob/main/.github/workflows/containerd.yml">Github Actions</a> | <a href="https://github.com/second-state/wasmedge-containers-examples/runs/4328930139?check_suite_focus=true#step:4:25">Successful run</a></li>
<li>HTTP service example <a href="https://github.com/second-state/wasmedge-containers-examples/blob/main/containerd/http_server/README.md">Quick start</a> | <a href="https://github.com/second-state/wasmedge-containers-examples/blob/main/.github/workflows/containerd-server.yml">Github Actions</a> | <a href="https://github.com/second-state/wasmedge-containers-examples/runs/4328930141?check_suite_focus=true#step:4:44">Successful run</a></li>
</ul>
<p>In the sections below, we will explain the steps in the quick start scripts.</p>
<ul>
<li><a href="kubernetes/cri/containerd.html#install-containerd">Install containerd</a></li>
<li><a href="kubernetes/cri/containerd.html#run-a-simple-webassembly-app">Example 1: Simple WebAssembly</a></li>
<li><a href="kubernetes/cri/containerd.html#run-a-http-server-app">Example 2: HTTP server in WebAssembly</a></li>
</ul>
<h2 id="install-containerd"><a class="header" href="#install-containerd">Install containerd</a></h2>
<p>Use the following commands to install containerd on your system.</p>
<pre><code class="language-bash">export VERSION=&quot;1.5.7&quot;
echo -e &quot;Version: $VERSION&quot;
echo -e &quot;Installing libseccomp2 ...&quot;
sudo apt install -y libseccomp2
echo -e &quot;Installing wget&quot;
sudo apt install -y wget

wget https://github.com/containerd/containerd/releases/download/v${VERSION}/cri-containerd-cni-${VERSION}-linux-amd64.tar.gz
wget https://github.com/containerd/containerd/releases/download/v${VERSION}/cri-containerd-cni-${VERSION}-linux-amd64.tar.gz.sha256sum
sha256sum --check cri-containerd-cni-${VERSION}-linux-amd64.tar.gz.sha256sum

sudo tar --no-overwrite-dir -C / -xzf cri-containerd-cni-${VERSION}-linux-amd64.tar.gz
sudo systemctl daemon-reload
</code></pre>
<p>Configure containerd to use <code>crun</code> as the underlying OCI runtime.
It makes changes to the <code>/etc/containerd/config.toml</code> file.</p>
<pre><code class="language-bash">sudo mkdir -p /etc/containerd/
sudo bash -c &quot;containerd config default &gt; /etc/containerd/config.toml&quot;
wget https://raw.githubusercontent.com/second-state/wasmedge-containers-examples/main/containerd/containerd_config.diff
sudo patch -d/ -p0 &lt; containerd_config.diff
</code></pre>
<p>Start the containerd service.</p>
<pre><code class="language-bash">sudo systemctl start containerd
</code></pre>
<p>Next, make sure that you have <a href="kubernetes/cri/../container/crun.html">built and installed the <code>crun</code> binary with WasmEdge support</a> before running the following examples.</p>
<h2 id="run-a-simple-webassembly-app-1"><a class="header" href="#run-a-simple-webassembly-app-1">Run a simple WebAssembly app</a></h2>
<p>Now, we can run a simple WebAssembly program using containerd.
<a href="kubernetes/cri/../demo/wasi.html">A separate article</a> explains how to compile, package, and publish the WebAssembly
program as a container image to Docker hub.
In this section, we will start off pulling this WebAssembly-based container
image from Docker hub using containerd tools.</p>
<pre><code class="language-bash">sudo ctr i pull docker.io/hydai/wasm-wasi-example:with-wasm-annotation
</code></pre>
<p>Now, you can run the example in just one line with ctr (the containerd cli).</p>
<pre><code class="language-bash">sudo ctr run --rm --runc-binary crun --runtime io.containerd.runc.v2 --label module.wasm.image/variant=compat docker.io/hydai/wasm-wasi-example:with-wasm-annotation wasm-example /wasi_example_main.wasm 50000000
</code></pre>
<p>Starting the container would execute the WebAssembly program. You can see the output in the console.</p>
<pre><code class="language-bash">Creating POD ...
Random number: -1678124602
Random bytes: [12, 222, 246, 184, 139, 182, 97, 3, 74, 155, 107, 243, 20, 164, 175, 250, 60, 9, 98, 25, 244, 92, 224, 233, 221, 196, 112, 97, 151, 155, 19, 204, 54, 136, 171, 93, 204, 129, 177, 163, 187, 52, 33, 32, 63, 104, 128, 20, 204, 60, 40, 183, 236, 220, 130, 41, 74, 181, 103, 178, 43, 231, 92, 211, 219, 47, 223, 137, 70, 70, 132, 96, 208, 126, 142, 0, 133, 166, 112, 63, 126, 164, 122, 49, 94, 80, 26, 110, 124, 114, 108, 90, 62, 250, 195, 19, 189, 203, 175, 189, 236, 112, 203, 230, 104, 130, 150, 39, 113, 240, 17, 252, 115, 42, 12, 185, 62, 145, 161, 3, 37, 161, 195, 138, 232, 39, 235, 222]
Printed from wasi: This is from a main function
This is from a main function
The env vars are as follows.
The args are as follows.
/wasi_example_main.wasm
50000000
File content is This is in a file
</code></pre>
<p>Next, you can try to run it in <a href="kubernetes/cri/../kubernetes/kubernetes.html#run-a-simple-webassembly-app">Kubernetes</a>!</p>
<h2 id="run-a-http-server-app-1"><a class="header" href="#run-a-http-server-app-1">Run a HTTP server app</a></h2>
<p>Finally, we can run a simple WebAssembly-based HTTP micro-service in containerd.
<a href="kubernetes/cri/../demo/server.html">A separate article</a> explains how to compile, package, and publish the WebAssembly
program as a container image to Docker hub.
In this section, we will start off pulling this WebAssembly-based container
image from Docker hub using containerd tools.</p>
<pre><code class="language-bash">sudo ctr i pull docker.io/avengermojo/http_server:with-wasm-annotation
</code></pre>
<p>Now, you can run the example in just one line with ctr (the containerd cli). Notice that we are running the container with <code>--net-host</code> so that the HTTP server inside the WasmEdge container is accessible from the outside shell.</p>
<pre><code class="language-bash">sudo ctr run --rm --net-host --runc-binary crun --runtime io.containerd.runc.v2 --label module.wasm.image/variant=compat docker.io/avengermojo/http_server:with-wasm-annotation http-server-example /http_server.wasm
</code></pre>
<p>Starting the container would execute the WebAssembly program. You can see the output in the console.</p>
<pre><code class="language-bash">new connection at 1234

# Test the HTTP service at that IP address
curl -d &quot;name=WasmEdge&quot; -X POST http://127.0.0.1:1234
echo: name=WasmEdge
</code></pre>
<p>Next, you can try to run it in <a href="kubernetes/cri/../kubernetes/kubernetes.html#run-a-http-server-app">Kubernetes</a>!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="kubernetes"><a class="header" href="#kubernetes">Kubernetes</a></h1>
<p>Most high-level container runtimes implement Kubernetes' CRI (Container Runtime Interface) spec so that they can be managed by Kubernetes tools. That means you can use Kubernetes tools to manage the WebAssembly app image in pods and namespaces.
Check out specific instructions for different flavors of Kubernetes setup in this chapter.</p>
<ul>
<li><a href="kubernetes/kubernetes/kubernetes-crio.html">Kubernetes + CRI-O</a></li>
<li><a href="kubernetes/kubernetes/kubernetes-containerd.html">Kubernetes + containerd</a></li>
<li><a href="kubernetes/kubernetes/kubeedge.html">KubeEdge</a></li>
<li><a href="kubernetes/kubernetes/superedge.html">SuperEdge</a></li>
<li><a href="kubernetes/kubernetes/openyurt.html">OpenYurt</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="kubernetes--cri-o"><a class="header" href="#kubernetes--cri-o">Kubernetes + CRI-O</a></h1>
<h2 id="quick-start-3"><a class="header" href="#quick-start-3">Quick start</a></h2>
<p>The <a href="https://github.com/second-state/wasmedge-containers-examples/">GitHub repo</a> contains scripts and Github Actions for running our example apps on Kubernetes + CRI-O.</p>
<ul>
<li>Simple WebAssembly example <a href="https://github.com/second-state/wasmedge-containers-examples/blob/main/kubernetes_crio/README.md">Quick start</a> | <a href="https://github.com/second-state/wasmedge-containers-examples/blob/main/.github/workflows/kubernetes-crio.yml">Github Actions</a> | <a href="https://github.com/second-state/wasmedge-containers-examples/runs/4328930134?check_suite_focus=true#step:6:3007">Successful run</a></li>
<li>WebAssembly-based HTTP service <a href="https://github.com/second-state/wasmedge-containers-examples/blob/main/kubernetes_crio/http_server/README.md">Quick start</a> | <a href="https://github.com/second-state/wasmedge-containers-examples/blob/main/.github/workflows/kubernetes-crio-server.yml">Github Actions</a> | <a href="https://github.com/second-state/wasmedge-containers-examples/runs/4577789182?check_suite_focus=true#step:6:3030">Successful run</a></li>
</ul>
<p>In the rest of this section, we will explain the steps in detail.
We will assume that you have already <a href="kubernetes/kubernetes/../cri/crio.html">installed and configured CRI-O</a> to work with WasmEdge container images.</p>
<h2 id="install-and-start-kubernetes"><a class="header" href="#install-and-start-kubernetes">Install and start Kubernetes</a></h2>
<p>Run the following commands from a terminal window.
It sets up Kubernetes for local development.</p>
<pre><code class="language-bash"># Install go
$ wget https://golang.org/dl/go1.17.1.linux-amd64.tar.gz
$ sudo rm -rf /usr/local/go
sudo tar -C /usr/local -xzf go1.17.1.linux-amd64.tar.gz
source /home/${USER}/.profile

# Clone k8s
git clone https://github.com/kubernetes/kubernetes.git
cd kubernetes
git checkout v1.22.2

# Install etcd with hack script in k8s
sudo CGROUP_DRIVER=systemd CONTAINER_RUNTIME=remote CONTAINER_RUNTIME_ENDPOINT='unix:///var/run/crio/crio.sock' ./hack/install-etcd.sh
export PATH=&quot;/home/${USER}/kubernetes/third_party/etcd:${PATH}&quot;
sudo cp third_party/etcd/etcd* /usr/local/bin/

# After run the above command, you can find the following files: /usr/local/bin/etcd  /usr/local/bin/etcdctl  /usr/local/bin/etcdutl

# Build and run k8s with CRI-O
sudo apt-get install -y build-essential
sudo CGROUP_DRIVER=systemd CONTAINER_RUNTIME=remote CONTAINER_RUNTIME_ENDPOINT='unix:///var/run/crio/crio.sock' ./hack/local-up-cluster.sh

... ...
Local Kubernetes cluster is running. Press Ctrl-C to shut it down.
</code></pre>
<p>Do NOT close your terminal window. Kubernetes is running!</p>
<h2 id="run-webassembly-container-images-in-kubernetes"><a class="header" href="#run-webassembly-container-images-in-kubernetes">Run WebAssembly container images in Kubernetes</a></h2>
<p>Finally, we can run WebAssembly programs in Kubernetes as containers in pods.
In this section, we will start from <strong>another terminal window</strong> and start using the cluster.</p>
<pre><code class="language-bash">export KUBERNETES_PROVIDER=local

sudo cluster/kubectl.sh config set-cluster local --server=https://localhost:6443 --certificate-authority=/var/run/kubernetes/server-ca.crt
sudo cluster/kubectl.sh config set-credentials myself --client-key=/var/run/kubernetes/client-admin.key --client-certificate=/var/run/kubernetes/client-admin.crt
sudo cluster/kubectl.sh config set-context local --cluster=local --user=myself
sudo cluster/kubectl.sh config use-context local
sudo cluster/kubectl.sh
</code></pre>
<p>Let's check the status to make sure that the cluster is running.</p>
<pre><code class="language-bash">$ sudo cluster/kubectl.sh cluster-info

# Expected output
Cluster &quot;local&quot; set.
User &quot;myself&quot; set.
Context &quot;local&quot; created.
Switched to context &quot;local&quot;.
Kubernetes control plane is running at https://localhost:6443
CoreDNS is running at https://localhost:6443/api/v1/namespaces/kube-system/services/kube-dns:dns/proxy

To further debug and diagnose cluster problems, use 'kubectl cluster-info dump'.
</code></pre>
<h3 id="a-simple-webassembly-app"><a class="header" href="#a-simple-webassembly-app">A simple WebAssembly app</a></h3>
<p><a href="kubernetes/kubernetes/../demo/wasi.html">A separate article</a> explains how to compile, package, and publish a simple WebAssembly WASI program as a container image to Docker hub.
Run the WebAssembly-based image from Docker Hub in the Kubernetes cluster as follows.</p>
<pre><code class="language-bash">sudo cluster/kubectl.sh run -it --rm --restart=Never wasi-demo --image=hydai/wasm-wasi-example:with-wasm-annotation --annotations=&quot;module.wasm.image/variant=compat&quot; /wasi_example_main.wasm 50000000
</code></pre>
<p>The output from the containerized application is printed into the console.</p>
<pre><code class="language-bash">Random number: 401583443
Random bytes: [192, 226, 162, 92, 129, 17, 186, 164, 239, 84, 98, 255, 209, 79, 51, 227, 103, 83, 253, 31, 78, 239, 33, 218, 68, 208, 91, 56, 37, 200, 32, 12, 106, 101, 241, 78, 161, 16, 240, 158, 42, 24, 29, 121, 78, 19, 157, 185, 32, 162, 95, 214, 175, 46, 170, 100, 212, 33, 27, 190, 139, 121, 121, 222, 230, 125, 251, 21, 210, 246, 215, 127, 176, 224, 38, 184, 201, 74, 76, 133, 233, 129, 48, 239, 106, 164, 190, 29, 118, 71, 79, 203, 92, 71, 68, 96, 33, 240, 228, 62, 45, 196, 149, 21, 23, 143, 169, 163, 136, 206, 214, 244, 26, 194, 25, 101, 8, 236, 247, 5, 164, 117, 40, 220, 52, 217, 92, 179]
Printed from wasi: This is from a main function
This is from a main function
The env vars are as follows.
The args are as follows.
/wasi_example_main.wasm
50000000
File content is This is in a file
pod &quot;wasi-demo-2&quot; deleted
</code></pre>
<h3 id="a-webassembly-based-http-service"><a class="header" href="#a-webassembly-based-http-service">A WebAssembly-based HTTP service</a></h3>
<p><a href="kubernetes/kubernetes/../demo/server.html">A separate article</a> explains how to compile, package, and publish a simple WebAssembly HTTP service application as a container image to Docker hub.
Since the HTTP service container requires networking support provided by Kubernetes, we will use a <a href="https://github.com/second-state/wasmedge-containers-examples/blob/main/kubernetes_crio/http_server/k8s-http_server.yaml">k8s-http_server.yaml</a> file to specify its exact configuration.</p>
<pre><code class="language-yaml">apiVersion: v1
kind: Pod
metadata:
  name: http-server
  namespace: default
  annotations:
    module.wasm.image/variant: compat
spec:
  hostNetwork: true
  containers:
  - name: http-server
    image: avengermojo/http_server:with-wasm-annotation
    command: [ &quot;/http_server.wasm&quot; ]
    ports:
    - containerPort: 1234
      protocol: TCP
    livenessProbe:
      tcpSocket:
        port: 1234
      initialDelaySeconds: 3
      periodSeconds: 30
</code></pre>
<p>Run the WebAssembly-based image from Docker Hub using the above <code>k8s-http_server.yaml</code> file in the Kubernetes cluster as follows.</p>
<pre><code class="language-bash">sudo ./kubernetes/cluster/kubectl.sh apply -f k8s-http_server.yaml
</code></pre>
<p>Use the following command to see the running container applications and their IP addresses.
Since we are using <code>hostNetwork</code> in the yaml configuration, the HTTP server image is running on the local network with IP address <code>127.0.0.1</code>.</p>
<pre><code class="language-bash">$ sudo cluster/kubectl.sh get pod --all-namespaces -o wide

NAMESPACE     NAME                       READY   STATUS             RESTARTS      AGE   IP          NODE        NOMINATED NODE   READINESS GATES
default       http-server                1/1     Running            1 (26s ago)     60s     127.0.0.1   127.0.0.1   &lt;none&gt;           &lt;none&gt;
</code></pre>
<p>Now, you can use the <code>curl</code> command to access the HTTP service.</p>
<pre><code class="language-bash">$ curl -d &quot;name=WasmEdge&quot; -X POST http://127.0.0.1:1234
echo: name=WasmEdge
</code></pre>
<p>That's it!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="kubernetes--containerd"><a class="header" href="#kubernetes--containerd">Kubernetes + containerd</a></h1>
<h2 id="quick-start-4"><a class="header" href="#quick-start-4">Quick start</a></h2>
<p>The <a href="https://github.com/second-state/wasmedge-containers-examples/">GitHub repo</a> contains scripts and Github Actions for running our example apps on Kubernetes + containerd.</p>
<ul>
<li>Simple WebAssembly example <a href="https://github.com/second-state/wasmedge-containers-examples/blob/main/kubernetes_containerd/README.md">Quick start</a> | <a href="https://github.com/second-state/wasmedge-containers-examples/blob/main/.github/workflows/kubernetes-containerd.yml">Github Actions</a> | <a href="https://github.com/second-state/wasmedge-containers-examples/runs/4577789181?check_suite_focus=true#step:6:3010">Successful run</a></li>
<li>WebAssembly-based HTTP service <a href="https://github.com/second-state/wasmedge-containers-examples/blob/main/kubernetes_containerd/http_server/README.md">Quick start</a> | <a href="https://github.com/second-state/wasmedge-containers-examples/blob/main/.github/workflows/kubernetes-containerd-server.yml">Github Actions</a> | <a href="https://github.com/second-state/wasmedge-containers-examples/runs/4577789184?check_suite_focus=true#step:6:3016">Successful run</a></li>
</ul>
<p>In the rest of this section, we will explain the steps in detail.
We will assume that you have already <a href="kubernetes/kubernetes/../cri/containerd.html">installed and configured containerd</a> to work with WasmEdge container images.</p>
<h2 id="install-and-start-kubernetes-1"><a class="header" href="#install-and-start-kubernetes-1">Install and start Kubernetes</a></h2>
<p>Run the following commands from a terminal window.
It sets up Kubernetes for local development.</p>
<pre><code class="language-bash"># Install go
$ wget https://golang.org/dl/go1.17.1.linux-amd64.tar.gz
$ sudo rm -rf /usr/local/go
$ sudo tar -C /usr/local -xzf go1.17.1.linux-amd64.tar.gz
$ source /home/${USER}/.profile

# Clone k8s
$ git clone https://github.com/kubernetes/kubernetes.git
$ cd kubernetes
$ git checkout v1.22.2

# Install etcd with hack script in k8s
$ sudo CGROUP_DRIVER=systemd CONTAINER_RUNTIME=remote CONTAINER_RUNTIME_ENDPOINT='unix:///var/run/crio/crio.sock' ./hack/install-etcd.sh
$ export PATH=&quot;/home/${USER}/kubernetes/third_party/etcd:${PATH}&quot;
$ sudo cp third_party/etcd/etcd* /usr/local/bin/

# After run the above command, you can find the following files: /usr/local/bin/etcd  /usr/local/bin/etcdctl  /usr/local/bin/etcdutl

# Build and run k8s with containerd
$ sudo apt-get install -y build-essential
$ sudo CGROUP_DRIVER=systemd CONTAINER_RUNTIME=remote CONTAINER_RUNTIME_ENDPOINT='unix:///var/run/crio/crio.sock' ./hack/local-up-cluster.sh

... ...
Local Kubernetes cluster is running. Press Ctrl-C to shut it down.
</code></pre>
<p>Do NOT close your terminal window. Kubernetes is running!</p>
<h2 id="run-webassembly-container-images-in-kubernetes-1"><a class="header" href="#run-webassembly-container-images-in-kubernetes-1">Run WebAssembly container images in Kubernetes</a></h2>
<p>Finally, we can run WebAssembly programs in Kubernetes as containers in pods.
In this section, we will start from <strong>another terminal window</strong> and start using the cluster.</p>
<pre><code class="language-bash">export KUBERNETES_PROVIDER=local

sudo cluster/kubectl.sh config set-cluster local --server=https://localhost:6443 --certificate-authority=/var/run/kubernetes/server-ca.crt
sudo cluster/kubectl.sh config set-credentials myself --client-key=/var/run/kubernetes/client-admin.key --client-certificate=/var/run/kubernetes/client-admin.crt
sudo cluster/kubectl.sh config set-context local --cluster=local --user=myself
sudo cluster/kubectl.sh config use-context local
sudo cluster/kubectl.sh
</code></pre>
<p>Let's check the status to make sure that the cluster is running.</p>
<pre><code class="language-bash">$ sudo cluster/kubectl.sh cluster-info

# Expected output
Cluster &quot;local&quot; set.
User &quot;myself&quot; set.
Context &quot;local&quot; created.
Switched to context &quot;local&quot;.
Kubernetes control plane is running at https://localhost:6443
CoreDNS is running at https://localhost:6443/api/v1/namespaces/kube-system/services/kube-dns:dns/proxy

To further debug and diagnose cluster problems, use 'kubectl cluster-info dump'.
</code></pre>
<h3 id="a-simple-webassembly-app-1"><a class="header" href="#a-simple-webassembly-app-1">A simple WebAssembly app</a></h3>
<p><a href="kubernetes/kubernetes/../demo/wasi.html">A separate article</a> explains how to compile, package, and publish a simple WebAssembly WASI program as a container image to Docker hub.
Run the WebAssembly-based image from Docker Hub in the Kubernetes cluster as follows.</p>
<pre><code class="language-bash">sudo cluster/kubectl.sh run -it --rm --restart=Never wasi-demo --image=hydai/wasm-wasi-example:with-wasm-annotation --annotations=&quot;module.wasm.image/variant=compat&quot; --overrides='{&quot;kind&quot;:&quot;Pod&quot;, &quot;apiVersion&quot;:&quot;v1&quot;, &quot;spec&quot;: {&quot;hostNetwork&quot;: true}}' /wasi_example_main.wasm 50000000
</code></pre>
<p>The output from the containerized application is printed into the console.</p>
<pre><code class="language-bash">Random number: 401583443
Random bytes: [192, 226, 162, 92, 129, 17, 186, 164, 239, 84, 98, 255, 209, 79, 51, 227, 103, 83, 253, 31, 78, 239, 33, 218, 68, 208, 91, 56, 37, 200, 32, 12, 106, 101, 241, 78, 161, 16, 240, 158, 42, 24, 29, 121, 78, 19, 157, 185, 32, 162, 95, 214, 175, 46, 170, 100, 212, 33, 27, 190, 139, 121, 121, 222, 230, 125, 251, 21, 210, 246, 215, 127, 176, 224, 38, 184, 201, 74, 76, 133, 233, 129, 48, 239, 106, 164, 190, 29, 118, 71, 79, 203, 92, 71, 68, 96, 33, 240, 228, 62, 45, 196, 149, 21, 23, 143, 169, 163, 136, 206, 214, 244, 26, 194, 25, 101, 8, 236, 247, 5, 164, 117, 40, 220, 52, 217, 92, 179]
Printed from wasi: This is from a main function
This is from a main function
The env vars are as follows.
The args are as follows.
/wasi_example_main.wasm
50000000
File content is This is in a file
pod &quot;wasi-demo-2&quot; deleted
</code></pre>
<h3 id="a-webassembly-based-http-service-1"><a class="header" href="#a-webassembly-based-http-service-1">A WebAssembly-based HTTP service</a></h3>
<p><a href="kubernetes/kubernetes/../demo/server.html">A separate article</a> explains how to compile, package, and publish a simple WebAssembly HTTP service application as a container image to Docker hub.
Run the WebAssembly-based image from Docker Hub in the Kubernetes cluster as follows.</p>
<pre><code class="language-bash">sudo cluster/kubectl.sh run --restart=Never http-server --image=avengermojo/http_server:with-wasm-annotation --annotations=&quot;module.wasm.image/variant=compat&quot; --overrides='{&quot;kind&quot;:&quot;Pod&quot;, &quot;apiVersion&quot;:&quot;v1&quot;, &quot;spec&quot;: {&quot;hostNetwork&quot;: true}}'
</code></pre>
<p>Since we are using <code>hostNetwork</code> in the <code>kubectl run</code> command, the HTTP server image is running on the local network with IP address <code>127.0.0.1</code>.
Now, you can use the <code>curl</code> command to access the HTTP service.</p>
<pre><code class="language-bash">$ curl -d &quot;name=WasmEdge&quot; -X POST http://127.0.0.1:1234
echo: name=WasmEdge
</code></pre>
<p>That's it!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="kubernetes-in-docker-kind"><a class="header" href="#kubernetes-in-docker-kind">Kubernetes in Docker (KinD)</a></h1>
<p>KinD is a Kubernetes distribution that runs inside Docker and is well suited for local development or integration testing. It runs containerd as CRI and runc as OCI Runtime.</p>
<h2 id="quick-start-5"><a class="header" href="#quick-start-5">Quick start</a></h2>
<p>As prerequisite we need to install KinD first. To do that the <a href="https://kind.sigs.k8s.io/docs/user/quick-start/#installing-from-release-binaries">quick start guide</a> and the <a href="https://github.com/kubernetes-sigs/kind/releases">release page</a> can be used to install the latest version of the KinD CLI.</p>
<p>If KinD is installed we can directly start with the example from <a href="https://github.com/Liquid-Reply/kind-crun-wasm">here</a>:</p>
<pre><code class="language-bash"># Create a &quot;WASM in KinD&quot; Cluster
kind create cluster --image ghcr.io/liquid-reply/kind-crun-wasm:v1.23.0
# Run the example
kubectl run -it --rm --restart=Never wasi-demo --image=hydai/wasm-wasi-example:with-wasm-annotation --annotations=&quot;module.wasm.image/variant=compat&quot; /wasi_example_main.wasm 50000000
</code></pre>
<p>In the rest of this section, we will explain how to create a KinD node image with wasmedge support.</p>
<h2 id="build-crun"><a class="header" href="#build-crun">Build crun</a></h2>
<p>KinD uses the kindest/node image for the control plane and worker nodes. The image contains containerd as CRI and runc as OCI Runtime. To enable WasmEdge support we replace runc with crun.</p>
<p>For the node image we only need the crun binary and not the entire build toolchain. Therefore we use a multistage dockerfile where we create crun in the first step and only copy the crun binary to the node image.</p>
<pre><code class="language-Dockerfile">FROM ubuntu:21.10 AS builder
WORKDIR /data
RUN DEBIAN_FRONTEND=noninteractive apt update \
    &amp;&amp; DEBIAN_FRONTEND=noninteractive apt install -y curl make git gcc build-essential pkgconf libtool libsystemd-dev libprotobuf-c-dev libcap-dev libseccomp-dev libyajl-dev go-md2man libtool autoconf python3 automake \
    &amp;&amp; curl https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/utils/install.sh | bash -s -- -p /usr/local \
    &amp;&amp; git clone --single-branch --branch feat/handler_per_container https://github.com/liquid-reply/crun \
    &amp;&amp; cd crun \
    &amp;&amp; ./autogen.sh \
    &amp;&amp; ./configure --with-wasmedge --enable-embedded-yajl\
    &amp;&amp; make 

...
</code></pre>
<p>Now we have a fresh <code>crun</code> binary with wasmedge enabled under <code>/data/crun/crun</code> that we can copy from this container in the next step.</p>
<h2 id="replace-crun-and-configure-containerd"><a class="header" href="#replace-crun-and-configure-containerd">Replace crun and configure containerd</a></h2>
<p>Both runc and crun implement the OCI runtime spec and they have the same CLI parametes. Therefore we can just replace the runc binary with our crun-wasmedge binary we created before.</p>
<p>Since crun is using some shared libraries we need to install libyajl, wasmedge and criu to make our crun work.</p>
<p>Now we already have a KinD that uses crun instead of runc. Now we just need two config changes. The first one in the <code>/etc/containerd/config.toml</code> where we add the <code>pod_annotations</code>that can be passed to the runtime:</p>
<pre><code class="language-toml">[plugins.&quot;io.containerd.grpc.v1.cri&quot;.containerd.runtimes.runc]
  pod_annotations = [&quot;*.wasm.*&quot;, &quot;wasm.*&quot;, &quot;module.wasm.image/*&quot;, &quot;*.module.wasm.image&quot;, &quot;module.wasm.image/variant.*&quot;]
</code></pre>
<p>And the second one to the <code>/etc/containerd/cri-base.json</code> where we remove a hook that causes some issues.</p>
<p>The resulting dockerfile looks as follows:</p>
<pre><code class="language-Dockerfile">...

FROM kindest/node:v1.23.0

COPY config.toml /etc/containerd/config.toml
COPY --from=builder /data/crun/crun /usr/local/sbin/runc
COPY --from=builder /usr/local/lib/libwasmedge_c.so /usr/local/lib/libwasmedge_c.so

RUN echo &quot;Installing Packages ...&quot; \
    &amp;&amp; bash -c 'cat &lt;&lt;&lt; $(jq &quot;del(.hooks.createContainer)&quot; /etc/containerd/cri-base.json) &gt; /etc/containerd/cri-base.json' \
    &amp;&amp; ldconfig
</code></pre>
<h2 id="build-and-test"><a class="header" href="#build-and-test">Build and test</a></h2>
<p>Finally we can build a new <code>node-wasmedge</code> image. To test it, we create a kind cluster from that image and run the simple app example.</p>
<pre><code class="language-bash">docker build -t node-wasmedge .
kind create cluster --image node-wasmedge
# Now you can run the example to validate your cluster
kubectl run -it --rm --restart=Never wasi-demo --image=hydai/wasm-wasi-example:with-wasm-annotation --annotations=&quot;module.wasm.image/variant=compat&quot; /wasi_example_main.wasm 50000000
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="create-a-crun-demo-for-kubeedge"><a class="header" href="#create-a-crun-demo-for-kubeedge">Create a crun demo for KubeEdge</a></h1>
<h2 id="1-setup-cloud-side-kubeedge-master-node"><a class="header" href="#1-setup-cloud-side-kubeedge-master-node">1. Setup Cloud Side (KubeEdge Master Node)</a></h2>
<h3 id="install-go"><a class="header" href="#install-go">Install Go</a></h3>
<pre><code class="language-bash">$ wget https://golang.org/dl/go1.17.3.linux-amd64.tar.gz
$ tar xzvf go1.17.3.linux-amd64.tar.gz

$ export PATH=/home/${user}/go/bin:$PATH
$ go version
go version go1.17.3 linux/amd64
</code></pre>
<h3 id="install-cri-o-1"><a class="header" href="#install-cri-o-1">Install CRI-O</a></h3>
<p>Please see <a href="https://github.com/cri-o/cri-o/blob/main/install.md#install-packaged-versions-of-cri-o">CRI-O Installation Instructions</a>.</p>
<pre><code class="language-bash"># Create the .conf file to load the modules at bootup
cat &lt;&lt;EOF | sudo tee /etc/modules-load.d/crio.conf
overlay
br_netfilter
EOF

sudo modprobe overlay
sudo modprobe br_netfilter

# Set up required sysctl params, these persist across reboots.
cat &lt;&lt;EOF | sudo tee /etc/sysctl.d/99-kubernetes-cri.conf
net.bridge.bridge-nf-call-iptables  = 1
net.ipv4.ip_forward                 = 1
net.bridge.bridge-nf-call-ip6tables = 1
EOF

sudo sysctl --system
export OS=&quot;xUbuntu_20.04&quot;
export VERSION=&quot;1.21&quot;
cat &lt;&lt;EOF | sudo tee /etc/apt/sources.list.d/devel:kubic:libcontainers:stable.list
deb https://download.opensuse.org/repositories/devel:/kubic:/libcontainers:/stable/$OS/ /
EOF
cat &lt;&lt;EOF | sudo tee /etc/apt/sources.list.d/devel:kubic:libcontainers:stable:cri-o:$VERSION.list
deb http://download.opensuse.org/repositories/devel:/kubic:/libcontainers:/stable:/cri-o:/$VERSION/$OS/ /
EOF

curl -L https://download.opensuse.org/repositories/devel:/kubic:/libcontainers:/stable/$OS/Release.key | sudo apt-key --keyring /etc/apt/trusted.gpg.d/libcontainers.gpg add -
curl -L https://download.opensuse.org/repositories/devel:kubic:libcontainers:stable:cri-o:$VERSION/$OS/Release.key | sudo apt-key --keyring /etc/apt/trusted.gpg.d/libcontainers-cri-o.gpg add -

sudo apt-get update
sudo apt-get install cri-o cri-o-runc

sudo systemctl daemon-reload
sudo systemctl enable crio --now
sudo systemctl status cri-o
</code></pre>
<p>output:</p>
<pre><code class="language-bash">$ sudo systemctl status cri-o
● crio.service - Container Runtime Interface for OCI (CRI-O)
     Loaded: loaded (/lib/systemd/system/crio.service; enabled; vendor preset: enabled)
     Active: active (running) since Mon 2021-12-06 13:46:29 UTC; 16h ago
       Docs: https://github.com/cri-o/cri-o
   Main PID: 6868 (crio)
      Tasks: 14
     Memory: 133.2M
     CGroup: /system.slice/crio.service
             └─6868 /usr/bin/crio

Dec 07 06:04:13 master crio[6868]: time=&quot;2021-12-07 06:04:13.694226800Z&quot; level=info msg=&quot;Checking image status: k8s.gcr.io/pause:3.4.1&quot; id=1dbb722e-f031-410c-9f45-5d4b5760163e name=/runtime.v1alpha2.ImageServic&gt;
Dec 07 06:04:13 master crio[6868]: time=&quot;2021-12-07 06:04:13.695739507Z&quot; level=info msg=&quot;Image status: &amp;{0xc00047fdc0 map[]}&quot; id=1dbb722e-f031-410c-9f45-5d4b5760163e name=/runtime.v1alpha2.ImageService/ImageSta&gt;
Dec 07 06:09:13 master crio[6868]: time=&quot;2021-12-07 06:09:13.698823984Z&quot; level=info msg=&quot;Checking image status: k8s.gcr.io/pause:3.4.1&quot; id=661b754b-48a4-401b-a03f-7f7a553c7eb6 name=/runtime.v1alpha2.ImageServic&gt;
Dec 07 06:09:13 master crio[6868]: time=&quot;2021-12-07 06:09:13.703259157Z&quot; level=info msg=&quot;Image status: &amp;{0xc0004d98f0 map[]}&quot; id=661b754b-48a4-401b-a03f-7f7a553c7eb6 name=/runtime.v1alpha2.ImageService/ImageSta&gt;
Dec 07 06:14:13 master crio[6868]: time=&quot;2021-12-07 06:14:13.707778419Z&quot; level=info msg=&quot;Checking image status: k8s.gcr.io/pause:3.4.1&quot; id=8c7e4d36-871a-452e-ab55-707053604077 name=/runtime.v1alpha2.ImageServic&gt;
Dec 07 06:14:13 master crio[6868]: time=&quot;2021-12-07 06:14:13.709379469Z&quot; level=info msg=&quot;Image status: &amp;{0xc000035030 map[]}&quot; id=8c7e4d36-871a-452e-ab55-707053604077 name=/runtime.v1alpha2.ImageService/ImageSta&gt;
Dec 07 06:19:13 master crio[6868]: time=&quot;2021-12-07 06:19:13.713158978Z&quot; level=info msg=&quot;Checking image status: k8s.gcr.io/pause:3.4.1&quot; id=827b6315-f145-4f76-b8da-31653d5892a2 name=/runtime.v1alpha2.ImageServic&gt;
Dec 07 06:19:13 master crio[6868]: time=&quot;2021-12-07 06:19:13.714030148Z&quot; level=info msg=&quot;Image status: &amp;{0xc000162bd0 map[]}&quot; id=827b6315-f145-4f76-b8da-31653d5892a2 name=/runtime.v1alpha2.ImageService/ImageSta&gt;
Dec 07 06:24:13 master crio[6868]: time=&quot;2021-12-07 06:24:13.716746612Z&quot; level=info msg=&quot;Checking image status: k8s.gcr.io/pause:3.4.1&quot; id=1d53a917-4d98-4723-9ea8-a2951a472cff name=/runtime.v1alpha2.ImageServic&gt;
Dec 07 06:24:13 master crio[6868]: time=&quot;2021-12-07 06:24:13.717381882Z&quot; level=info msg=&quot;Image status: &amp;{0xc00042ce00 map[]}&quot; id=1d53a917-4d98-4723-9ea8-a2951a472cff name=/runtime.v1alpha2.ImageService/ImageSta&gt;
</code></pre>
<h3 id="install-and-creating-a-cluster-with-kubeadm-for-k8s"><a class="header" href="#install-and-creating-a-cluster-with-kubeadm-for-k8s">Install and Creating a cluster with kubeadm for K8s</a></h3>
<p>Please see <a href="https://kubernetes.io/docs/setup/production-environment/tools/kubeadm/create-cluster-kubeadm/">Creating a cluster with kubeadm</a>.</p>
<h4 id="install-k8s"><a class="header" href="#install-k8s">Install K8s</a></h4>
<pre><code class="language-bash">sudo apt-get update
sudo apt-get install -y apt-transport-https curl
echo &quot;deb [signed-by=/usr/share/keyrings/kubernetes-archive-keyring.gpg] https://apt.kubernetes.io/ kubernetes-xenial main&quot; | sudo tee /etc/apt/sources.list.d/kubernetes.list

sudo apt update
K_VER=&quot;1.21.0-00&quot;
sudo apt install -y kubelet=${K_VER} kubectl=${K_VER} kubeadm=${K_VER}
sudo apt-mark hold kubelet kubeadm kubectl
</code></pre>
<h4 id="create-a-cluster-with-kubeadm"><a class="header" href="#create-a-cluster-with-kubeadm">Create a cluster with kubeadm</a></h4>
<pre><code class="language-bash">#kubernetes scheduler requires this setting to be done.
$ sudo swapoff -a
$ sudo vim /etc/fstab
mark contain swapfile of row

$ cat /etc/cni/net.d/100-crio-bridge.conf
{
    &quot;cniVersion&quot;: &quot;0.3.1&quot;,
    &quot;name&quot;: &quot;crio&quot;,
    &quot;type&quot;: &quot;bridge&quot;,
    &quot;bridge&quot;: &quot;cni0&quot;,
    &quot;isGateway&quot;: true,
    &quot;ipMasq&quot;: true,
    &quot;hairpinMode&quot;: true,
    &quot;ipam&quot;: {
        &quot;type&quot;: &quot;host-local&quot;,
        &quot;routes&quot;: [
            { &quot;dst&quot;: &quot;0.0.0.0/0&quot; },
            { &quot;dst&quot;: &quot;1100:200::1/24&quot; }
        ],
        &quot;ranges&quot;: [
            [{ &quot;subnet&quot;: &quot;10.85.0.0/16&quot; }],
            [{ &quot;subnet&quot;: &quot;1100:200::/24&quot; }]
        ]
    }
}
$ export CIDR=10.85.0.0/16
$ sudo kubeadm init --apiserver-advertise-address=192.168.122.160 --pod-network-cidr=$CIDR --cri-socket=/var/run/crio/crio.sock

$ mkdir -p $HOME/.kube
$ sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config
$ sudo chown $(id -u):$(id -g) $HOME/.kube/config
</code></pre>
<p>output:</p>
<pre><code class="language-bash">Your Kubernetes control-plane has initialized successfully!

To start using your cluster, you need to run the following as a regular user:

  mkdir -p $HOME/.kube
  sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config
  sudo chown $(id -u):$(id -g) $HOME/.kube/config

You should now deploy a Pod network to the cluster.
Run &quot;kubectl apply -f [podnetwork].yaml&quot; with one of the options listed at:
  /docs/concepts/cluster-administration/addons/

You can now join any number of machines by running the following on each node
as root:

  kubeadm join &lt;control-plane-host&gt;:&lt;control-plane-port&gt; --token &lt;token&gt; --discovery-token-ca-cert-hash sha256:&lt;hash&gt;
</code></pre>
<p>To make kubectl work for your non-root user, run these commands, which are also part of the kubeadm init output:</p>
<pre><code class="language-bash">mkdir -p $HOME/.kube
sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config
sudo chown $(id -u):$(id -g) $HOME/.kube/config
</code></pre>
<h3 id="setup-kubeedge-master-node"><a class="header" href="#setup-kubeedge-master-node">Setup KubeEdge Master Node</a></h3>
<p>Please see <a href="https://kubeedge.io/en/docs/setup/keadm/">Deploying using Keadm</a>.</p>
<p>IMPORTANT NOTE:</p>
<ol>
<li>At least one of kubeconfig or master must be configured correctly, so that it can be used to verify the version and other info of the k8s cluster.</li>
<li>Please make sure edge node can connect cloud node using local IP of cloud node, or you need to specify public IP of cloud node with --advertise-address flag.</li>
<li>--advertise-address(only work since 1.3 release) is the address exposed by the cloud side (will be added to the SANs of the CloudCore certificate), the default value is the local IP.</li>
</ol>
<pre><code class="language-bash">wget https://github.com/kubeedge/kubeedge/releases/download/v1.8.0/keadm-v1.8.0-linux-amd64.tar.gz
tar xzvf keadm-v1.8.0-linux-amd64.tar.gz
cd keadm-v1.8.0-linux-amd64/keadm/
sudo ./keadm init --advertise-address=192.168.122.160 --kube-config=/home/${user}/.kube/config
</code></pre>
<p>output:</p>
<pre><code class="language-bash">Kubernetes version verification passed, KubeEdge installation will start...
...
KubeEdge cloudcore is running, For logs visit:  /var/log/kubeedge/cloudcore.log
</code></pre>
<h2 id="2-setup-edge-side-kubeedge-worker-node"><a class="header" href="#2-setup-edge-side-kubeedge-worker-node">2. Setup Edge Side (KubeEdge Worker Node)</a></h2>
<p>You can use the CRI-O <a href="kubernetes/kubernetes/../crio/install.sh">install.sh</a> script to install CRI-O and <code>crun</code> on Ubuntu 20.04.</p>
<pre><code class="language-bash">wget -qO- https://raw.githubusercontent.com/second-state/wasmedge-containers-examples/main/crio/install.sh | bash
</code></pre>
<h3 id="install-go-on-edge-side"><a class="header" href="#install-go-on-edge-side">Install Go on Edge Side</a></h3>
<pre><code class="language-bash">$ wget https://golang.org/dl/go1.17.3.linux-amd64.tar.gz
$ tar xzvf go1.17.3.linux-amd64.tar.gz

$ export PATH=/home/${user}/go/bin:$PATH
$ go version
go version go1.17.3 linux/amd64
</code></pre>
<h3 id="get-token-from-cloud-side"><a class="header" href="#get-token-from-cloud-side">Get Token From Cloud Side</a></h3>
<p>Run keadm gettoken in cloud side will return the token, which will be used when joining edge nodes.</p>
<pre><code class="language-bash">$ sudo ./keadm gettoken --kube-config=/home/${user}/.kube/config
27a37ef16159f7d3be8fae95d588b79b3adaaf92727b72659eb89758c66ffda2.eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJleHAiOjE1OTAyMTYwNzd9.JBj8LLYWXwbbvHKffJBpPd5CyxqapRQYDIXtFZErgYE
</code></pre>
<h3 id="download-kubeedge-and-join-edge-nodes"><a class="header" href="#download-kubeedge-and-join-edge-nodes">Download Kubeedge and join edge nodes</a></h3>
<p>Please see <a href="https://kubeedge.io/en/docs/advanced/cri/#cri-o">Setting different container runtime with CRI</a> and <a href="https://kubeedge.io/en/docs/setup/keadm/">Deploying using Keadm</a>.</p>
<pre><code class="language-bash">$ wget https://github.com/kubeedge/kubeedge/releases/download/v1.8.0/keadm-v1.8.0-linux-amd64.tar.gz
$ tar xzvf keadm-v1.8.0-linux-amd64.tar.gz
$ cd keadm-v1.8.0-linux-amd64/keadm/

$ sudo ./keadm join \
--cloudcore-ipport=192.168.122.160:10000 \
--edgenode-name=edge \
--token=b4550d45b773c0480446277eed1358dcd8a02a0c214646a8082d775f9c447d81.eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJleHAiOjE2Mzg4ODUzNzd9.A9WOYJFrgL2swVGnydpb4gMojyvyoNPCXaA4rXGowqU \
--remote-runtime-endpoint=unix:///var/run/crio/crio.sock \
--runtimetype=remote \
--cgroupdriver=systemd
</code></pre>
<p>Output:</p>
<pre><code class="language-bash">Host has mosquit+ already installed and running. Hence skipping the installation steps !!!
...
KubeEdge edgecore is running, For logs visit:  /var/log/kubeedge/edgecore.log
</code></pre>
<h3 id="get-edge-node-status-from-cloud-side"><a class="header" href="#get-edge-node-status-from-cloud-side">Get Edge Node Status From Cloud Side</a></h3>
<p>Output:</p>
<pre><code class="language-bash">kubectl get node
NAME       STATUS    ROLES                  AGE   VERSION
edge       Ready     agent,edge             10s   v1.19.3-kubeedge-v1.8.2
master     Ready     control-plane,master   68m   v1.21.0
</code></pre>
<h2 id="3-enable-kubectl-logs-feature"><a class="header" href="#3-enable-kubectl-logs-feature">3. Enable kubectl logs Feature</a></h2>
<p>Before metrics-server deployed, kubectl logs feature must be activated, please <a href="https://kubeedge.io/en/docs/setup/keadm/#enable-kubectl-logs-feature">see here</a>.</p>
<h2 id="4-run-a-simple-webassembly-app"><a class="header" href="#4-run-a-simple-webassembly-app">4. Run a simple WebAssembly app</a></h2>
<p>We can run the WebAssembly-based image from Docker Hub in the Kubernetes cluster.</p>
<h3 id="cloud-side"><a class="header" href="#cloud-side">Cloud Side</a></h3>
<pre><code class="language-bash">$ kubectl run -it --restart=Never wasi-demo --image=hydai/wasm-wasi-example:with-wasm-annotation --annotations=&quot;module.wasm.image/variant=compat&quot; /wasi_example_main.wasm 50000000

Random number: -1694733782
Random bytes: [6, 226, 176, 126, 136, 114, 90, 2, 216, 17, 241, 217, 143, 189, 123, 197, 17, 60, 49, 37, 71, 69, 67, 108, 66, 39, 105, 9, 6, 72, 232, 238, 102, 5, 148, 243, 249, 183, 52, 228, 54, 176, 63, 249, 216, 217, 46, 74, 88, 204, 130, 191, 182, 19, 118, 193, 77, 35, 189, 6, 139, 68, 163, 214, 231, 100, 138, 246, 185, 47, 37, 49, 3, 7, 176, 97, 68, 124, 20, 235, 145, 166, 142, 159, 114, 163, 186, 46, 161, 144, 191, 211, 69, 19, 179, 241, 8, 207, 8, 112, 80, 170, 33, 51, 251, 33, 105, 0, 178, 175, 129, 225, 112, 126, 102, 219, 106, 77, 242, 104, 198, 238, 193, 247, 23, 47, 22, 29]
Printed from wasi: This is from a main function
This is from a main function
The env vars are as follows.
The args are as follows.
/wasi_example_main.wasm
50000000
File content is This is in a file
</code></pre>
<p>The WebAssembly app of pod successfully deploy to edge node.</p>
<pre><code class="language-bash">$ kubectl describe pod wasi-demo

Name:         wasi-demo
Namespace:    default
Priority:     0
Node:         edge/192.168.122.229
Start Time:   Mon, 06 Dec 2021 15:45:34 +0000
Labels:       run=wasi-demo
Annotations:  module.wasm.image/variant: compat
Status:       Succeeded
IP:           
IPs:          &lt;none&gt;
Containers:
  wasi-demo:
    Container ID:  cri-o://1ae4d0d7f671050331a17e9b61b5436bf97ad35ad0358bef043ab820aed81069
    Image:         hydai/wasm-wasi-example:with-wasm-annotation
    Image ID:      docker.io/hydai/wasm-wasi-example@sha256:525aab8d6ae8a317fd3e83cdac14b7883b92321c7bec72a545edf276bb2100d6
    Port:          &lt;none&gt;
    Host Port:     &lt;none&gt;
    Args:
      /wasi_example_main.wasm
      50000000
    State:          Terminated
      Reason:       Completed
      Exit Code:    0
      Started:      Mon, 06 Dec 2021 15:45:33 +0000
      Finished:     Mon, 06 Dec 2021 15:45:33 +0000
    Ready:          False
    Restart Count:  0
    Environment:    &lt;none&gt;
    Mounts:
      /var/run/secrets/kubernetes.io/serviceaccount from kube-api-access-bhszr (ro)
Conditions:
  Type           Status
  Initialized    True 
  Ready          False 
  PodScheduled   True 
Volumes:
  kube-api-access-bhszr:
    Type:                    Projected (a volume that contains injected data from multiple sources)
    TokenExpirationSeconds:  3607
    ConfigMapName:           kube-root-ca.crt
    ConfigMapOptional:       &lt;nil&gt;
    DownwardAPI:             true
QoS Class:                   BestEffort
Node-Selectors:              &lt;none&gt;
Tolerations:                 node.kubernetes.io/not-ready:NoExecute op=Exists for 300s
                             node.kubernetes.io/unreachable:NoExecute op=Exists for 300s
Events:
  Type    Reason     Age   From               Message
  ----    ------     ----  ----               -------
</code></pre>
<h3 id="edge-side"><a class="header" href="#edge-side">Edge Side</a></h3>
<pre><code class="language-bash">$ sudo crictl ps -a
CONTAINER           IMAGE                                                                                           CREATED             STATE               NAME                ATTEMPT             POD ID
1ae4d0d7f6710       0423b8eb71e312b8aaa09a0f0b6976381ff567d5b1e5729bf9b9aa87bff1c9f3                                16 minutes ago      Exited              wasi-demo           0                   2bc2ac0c32eda
1e6c7cb6bc731       k8s.gcr.io/kube-proxy@sha256:2a25285ff19f9b4025c8e54dac42bb3cd9aceadc361f2570489b8d723cb77135   18 minutes ago      Running             kube-proxy          0                   8b7e7388ad866
</code></pre>
<p>That's it.</p>
<h2 id="5-demo-run-screen-recording"><a class="header" href="#5-demo-run-screen-recording">5. Demo Run Screen Recording</a></h2>
<p><a href="https://asciinema.org/a/wkLOu6xnAOSAQdmYayumwrAvh"><img src="https://asciinema.org/a/wkLOu6xnAOSAQdmYayumwrAvh.svg" alt="asciicast" /></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="superedge"><a class="header" href="#superedge">SuperEdge</a></h1>
<h2 id="install-superedge"><a class="header" href="#install-superedge">Install Superedge</a></h2>
<p><a href="kubernetes/kubernetes/../docs/installation/install_edge_kubernetes.html">One-click install of edge Kubernetes cluster</a></p>
<ul>
<li>Download the installation package</li>
</ul>
<blockquote>
<p>Choose installation package according to your installation node CPU architecture [amd64, arm64]</p>
</blockquote>
<pre><code class="language-bash">arch=amd64 version=v0.6.0 &amp;&amp; rm -rf edgeadm-linux-* &amp;&amp; wget https://superedge-1253687700.cos.ap-guangzhou.myqcloud.com/$version/$arch/edgeadm-linux-containerd-$arch-$version.tgz &amp;&amp; tar -xzvf edgeadm-linux-* &amp;&amp; cd edgeadm-linux-$arch-$version &amp;&amp; ./edgeadm
</code></pre>
<ul>
<li>Install edge Kubernetes master node with containerd runtime</li>
</ul>
<pre><code class="language-bash">./edgeadm init --kubernetes-version=1.18.2 --image-repository superedge.tencentcloudcr.com/superedge --service-cidr=10.96.0.0/12 --pod-network-cidr=192.168.0.0/16 --install-pkg-path ./kube-linux-*.tar.gz --apiserver-cert-extra-sans=&lt;Master Public IP&gt; --apiserver-advertise-address=&lt;Master Intranet IP&gt; --enable-edge=true --runtime=containerd
</code></pre>
<ul>
<li>Join edge node with containerd runtime</li>
</ul>
<pre><code class="language-bash">./edgeadm join &lt;Master Public/Intranet IP Or Domain&gt;:Port --token xxxx --discovery-token-ca-cert-hash sha256:xxxxxxxxxx --install-pkg-path &lt;edgeadm kube-* install package address path&gt; --enable-edge=true --runtime=containerd
</code></pre>
<p>See the detailed process<a href="kubernetes/kubernetes/../docs/installation/install_edge_kubernetes.html">One-click install of edge Kubernetes cluster</a></p>
<p>Other installation, deployment, and administration, see our <a href="kubernetes/kubernetes/../docs/tutorial.html"><strong>Tutorial</strong></a>.</p>
<h2 id="install-wasmedge"><a class="header" href="#install-wasmedge">Install WasmEdge</a></h2>
<p>Use the simple install script to install WasmEdge on your edge node.</p>
<pre><code class="language-bash">curl -sSf https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/utils/install.sh | bash
</code></pre>
<h2 id="build-and-install-crun-with-wasmedge"><a class="header" href="#build-and-install-crun-with-wasmedge">Build And install Crun with WasmEdge</a></h2>
<p>The <a href="https://github.com/containers/crun">crun</a> project has WasmEdge support baked in. For now, the easiest approach is just to build it yourself from source. First, let's make sure that crun dependencies are installed on your Ubuntu 20.04. For other Linux distributions, please see <a href="https://github.com/containers/crun#readme">here</a>.</p>
<pre><code class="language-bash">sudo apt update
sudo apt install -y make git gcc build-essential pkgconf libtool \
    libsystemd-dev libprotobuf-c-dev libcap-dev libseccomp-dev libyajl-dev \
    go-md2man libtool autoconf python3 automake
</code></pre>
<p>Next, configure, build, and install a crun binary with WasmEdge support.</p>
<pre><code class="language-bash">git clone https://github.com/containers/crun
cd crun
./autogen.sh
./configure --with-wasmedge
make
sudo make install
</code></pre>
<h2 id="reconfigure-containerd-with-crun-runtime"><a class="header" href="#reconfigure-containerd-with-crun-runtime">Reconfigure containerd with crun runtime</a></h2>
<p>Superedge containerd node has default config, we should modify the configuration file(/etc/containerd/config.toml) according to the following steps.</p>
<p>Firstly, we generate <code>config.toml.diff</code> diff file and patch it.</p>
<pre><code class="language-bash">cat &gt; config.toml.diff &lt;&lt; EOF
--- /etc/containerd/config.toml 2022-02-14 15:05:40.061562127 +0800
+++ /etc/containerd/config.toml.crun    2022-02-14 15:03:35.846052853 +0800
@@ -24,17 +24,23 @@
   max_concurrent_downloads = 10

   [plugins.cri.containerd]
-        default_runtime_name = &quot;runc&quot;
-    [plugins.cri.containerd.runtimes.runc]
+        default_runtime_name = &quot;crun&quot;
+    [plugins.cri.containerd.runtimes.crun]
       runtime_type = &quot;io.containerd.runc.v2&quot;
-      pod_annotations = []
+      pod_annotations = [&quot;*.wasm.*&quot;, &quot;wasm.*&quot;, &quot;module.wasm.image/*&quot;, &quot;*.module.wasm.image&quot;, &quot;module.wasm.image/variant.*&quot;]
       container_annotations = []
       privileged_without_host_devices = false
-      [plugins.cri.containerd.runtimes.runc.options]
-        BinaryName = &quot;runc&quot;
+      [plugins.cri.containerd.runtimes.crun.options]
+        BinaryName = &quot;crun&quot;
   # cni
   [plugins.cri.cni]
     bin_dir = &quot;/opt/cni/bin&quot;
     conf_dir = &quot;/etc/cni/net.d&quot;
     conf_template = &quot;&quot;

+  [plugins.&quot;io.containerd.runtime.v1.linux&quot;]
+    no_shim = false
+    runtime = &quot;crun&quot;
+    runtime_root = &quot;&quot;
+    shim = &quot;containerd-shim&quot;
+    shim_debug = false
EOF
</code></pre>
<pre><code class="language-bash">sudo patch -d/ -p0 &lt; config.toml.diff
sudo systemctl restart containerd
</code></pre>
<h2 id="create-wasmedge-application-in-superedge"><a class="header" href="#create-wasmedge-application-in-superedge">Create Wasmedge application in Superedge</a></h2>
<p>We can run a wasm image which has been pushed to <a href="https://hub.docker.com/r/hydai/wasm-wasi-example">dockerhub</a>. If you want to learn how to compile, package, and publish the WebAssembly program as a container image to Docker hub, please refer to <a href="https://wasmedge.org/book/en/kubernetes/demo/wasi.html">WasmEdge Book</a>.</p>
<pre><code class="language-bash">cat &gt; wasmedge-app.yaml &lt;&lt; EOF
apiVersion: v1
kind: Pod
metadata:
  annotations:
    module.wasm.image/variant: compat
  labels:
    run: wasi-demo
  name: wasi-demo
spec:
  containers:
  - args:
    - /wasi_example_main.wasm
    - &quot;50000000&quot;
    image: hydai/wasm-wasi-example:with-wasm-annotation
    imagePullPolicy: IfNotPresent
    name: wasi-demo
  hostNetwork: true
  restartPolicy: Never
EOF

kubectl create -f wasmedge-app.yaml
</code></pre>
<p>The output will show by executing <code>kubectl logs wasi-demo</code> command.</p>
<pre><code class="language-bash">Random number: -1643170076
Random bytes: [15, 223, 242, 238, 69, 114, 217, 106, 80, 214, 44, 225, 20, 182, 2, 189, 226, 184, 97, 40, 154, 6, 56, 202, 45, 89, 184, 80, 5, 89, 73, 222, 143, 132, 17, 79, 145, 64, 33, 17, 250, 102, 91, 94, 26, 200, 28, 161, 46, 93, 123, 36, 100, 167, 43, 159, 82, 112, 255, 165, 37, 232, 17, 139, 97, 14, 28, 169, 225, 156, 147, 22, 174, 148, 209, 57, 82, 213, 19, 215, 11, 18, 32, 217, 188, 142, 54, 127, 237, 237, 230, 137, 86, 162, 185, 66, 88, 95, 226, 53, 174, 76, 226, 25, 151, 186, 156, 16, 62, 63, 230, 148, 133, 102, 33, 138, 20, 83, 31, 60, 246, 90, 167, 189, 103, 238, 106, 51]
Printed from wasi: This is from a main function
This is from a main function
The env vars are as follows.
The args are as follows.
/wasi_example_main.wasm
50000000
File content is This is in a file
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="openyurt--containerd--crun"><a class="header" href="#openyurt--containerd--crun">OpenYurt + containerd + crun</a></h1>
<p>In this article, we will introduce how to run a WasmEdge simple demo app with Containerd over <a href="https://github.com/openyurtio/openyurt">OpenYurt</a>.</p>
<h2 id="set-up-an-openyurt-cluster"><a class="header" href="#set-up-an-openyurt-cluster">Set up an OpenYurt Cluster</a></h2>
<p>Here, we introduce two ways to set up an OpenYurt Cluster.
The first one is to set up an OpenYurt Cluster from scratch, use <code>yurtctl convert</code> to realize a K8s Cluster conversion to an OpenYurt Cluster.
The second one is to use the ability of OpenYurt Experience Center, which is easy to achieve an OpenYurt Cluster.</p>
<h3 id="prerequisite-1"><a class="header" href="#prerequisite-1">Prerequisite</a></h3>
<table><thead><tr><th></th><th>OS/kernel</th><th>Private IP/Public IP</th></tr></thead><tbody>
<tr><td>Master</td><td>Ubuntu  20.04.3 LTS/5.4.0-91-generic</td><td>192.168.3.169/120.55.126.18</td></tr>
<tr><td>Node</td><td>Ubuntu  20.04.3 LTS/5.4.0-91-generic</td><td>192.168.3.170/121.43.113.152</td></tr>
</tbody></table>
<p>It should be noted that some steps may differ slightly depending on the operating system differences.
Please refer to the installation of <a href="https://github.com/openyurtio/openyurt">OpenYurt</a> and <a href="https://github.com/containers/crun">crun</a>.</p>
<p>We use <code>yurtctl convert</code> to convert a K8s Cluster to OpenYurt Cluster, so we should set up a K8s Cluster.
If you use <code>yurtctl init/join</code> to set up an OpenYurt Cluster, you can skip this step which introduces the process of installing K8s.</p>
<p>Find the difference between <code>yurtctl convert/revert</code> and <code>yurtctl init/join</code>, you can refer to the following two articles.</p>
<p><a href="https://openyurt.io/docs/installation/yurtctl-init-join">how use <code>Yurtctl init/join</code></a></p>
<p><a href="https://openyurt.io/docs/installation/yurtctl-convert-revert">Conversion between OpenYurt and Kubernetes:<code>yurtctl convert/revert</code></a></p>
<ul>
<li>Close the swap space of the master and node firstly.</li>
</ul>
<pre><code class="language-bash">sudo swapoff -a
//verify
free -m
</code></pre>
<ul>
<li>Configure the file /etc/hosts of two nodes as the following.</li>
</ul>
<pre><code class="language-bash">192.168.3.169  oy-master 
120.55.126.18  oy-master
92.168.3.170   oy-node
121.43.113.152 oy-node
</code></pre>
<ul>
<li>Load the br_netfilter Kernel module and modify the Kernel parameter.</li>
</ul>
<pre><code class="language-bash">//load the module
sudo modprobe br_netfilter
//verify   
lsmod | grep br_netfilter
// create k8s.conf
cat &lt;&lt;EOF | sudo tee /etc/sysctl.d/k8s.conf
net.bridge.bridge-nf-call-ip6tables = 1
net.bridge.bridge-nf-call-iptables = 1
EOF
sudo sysctl --system 
</code></pre>
<ul>
<li>Setup the value of rp-filter (adjusting the value of two parameters in /etc/sysctl.d/10-network-security.conf from 2 to 1 and setting up the value of /proc/sys/net/ipv4/ip_forward to 1)</li>
</ul>
<pre><code class="language-bash">sudo vi /etc/sysctl.d/10-network-security.conf
echo 1 &gt; /proc/sys/net/ipv4/ip_forward
sudo sysctl --system
</code></pre>
<h4 id="install-containerd-and-modify-the-default-configure-of-containerd"><a class="header" href="#install-containerd-and-modify-the-default-configure-of-containerd">Install containerd and modify the default configure of containerd</a></h4>
<p>Use the following commands to install containerd on your edge node which will run a WasmEdge simple demo.</p>
<pre><code class="language-bash">export VERSION=&quot;1.5.7&quot;
echo -e &quot;Version: $VERSION&quot;
echo -e &quot;Installing libseccomp2 ...&quot;
sudo apt install -y libseccomp2
echo -e &quot;Installing wget&quot;
sudo apt install -y wget

wget https://github.com/containerd/containerd/releases/download/v${VERSION}/cri-containerd-cni-${VERSION}-linux-amd64.tar.gz
wget https://github.com/containerd/containerd/releases/download/v${VERSION}/cri-containerd-cni-${VERSION}-linux-amd64.tar.gz.sha256sum
sha256sum --check cri-containerd-cni-${VERSION}-linux-amd64.tar.gz.sha256sum

sudo tar --no-overwrite-dir -C / -xzf cri-containerd-cni-${VERSION}-linux-amd64.tar.gz
sudo systemctl daemon-reload
</code></pre>
<p>As the crun project support WasmEdge as default, we just need to configure the containerd configuration for runc. So we need to modify the runc parameters in /etc/containerd/config.toml to curn and add pod_annotation.</p>
<pre><code class="language-bash">sudo mkdir -p /etc/containerd/
sudo bash -c &quot;containerd config default &gt; /etc/containerd/config.toml&quot;
wget https://raw.githubusercontent.com/second-state/wasmedge-containers-examples/main/containerd/containerd_config.diff
sudo patch -d/ -p0 &lt; containerd_config.diff
</code></pre>
<p>After that, restart containerd to make the configuration take effect.</p>
<pre><code class="language-bash">systemctl start containerd
</code></pre>
<h4 id="install-wasmedge-1"><a class="header" href="#install-wasmedge-1">Install WasmEdge</a></h4>
<p>Use the <a href="https://wasmedge.org/book/en/start/install.html">simple install script</a> to install WasmEdge on your edge node.</p>
<pre><code class="language-bash">curl -sSf https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/utils/install.sh | bash
</code></pre>
<h4 id="build-and-install-crun"><a class="header" href="#build-and-install-crun">Build and install crun</a></h4>
<p>We need a crun binary that supports WasmEdge on the edge node. For now, the most straightforward approach is to build it yourself from the source. First, let's ensure that crun dependencies are installed on your Ubuntu 20.04. For other Linux distributions, please see <a href="https://github.com/containers/crun#readme">here</a>.</p>
<ul>
<li>Dependencies are required for the build</li>
</ul>
<pre><code class="language-bash">sudo apt update
sudo apt install -y make git gcc build-essential pkgconf libtool \
  libsystemd-dev libprotobuf-c-dev libcap-dev libseccomp-dev libyajl-dev \
  go-md2man libtool autoconf python3 automake
</code></pre>
<ul>
<li>Configure, build, and install a crun binary with WasmEdge support.</li>
</ul>
<pre><code class="language-bash">git clone https://github.com/containers/crun
cd crun
./autogen.sh
./configure --with-wasmedge
make
sudo make install
</code></pre>
<h3 id="from-scratch-set-up-an-openyurt-cluster"><a class="header" href="#from-scratch-set-up-an-openyurt-cluster">From scratch set up an OpenYurt Cluster</a></h3>
<p>In this demo, we will use two machines to set up an OpenYurt Cluster. One simulated cloud node is called Master, the other one simulated edge node is called Node. These two nodes form the simplest
OpenYurt Cluster, where OpenYurt components run on.</p>
<h4 id="set-up-a-k8s-cluster"><a class="header" href="#set-up-a-k8s-cluster">Set up a K8s Cluster</a></h4>
<p>Kubernetes version 1.18.9</p>
<pre><code class="language-bash">$ sudo apt-get update &amp;&amp; sudo apt-get install -y ca-certificates curl software-properties-common apt-transport-https
// add K8s source
$ curl -s https://mirrors.aliyun.com/kubernetes/apt/doc/apt-key.gpg | sudo apt-key add -
$ sudo tee /etc/apt/sources.list.d/kubernetes.list &lt;&lt;EOF
$ deb https://mirrors.aliyun.com/kubernetes/apt/ kubernetes-xenial main
// install K8s components 1.18.9
$ sudo apt-get update &amp;&amp; sudo apt-get install -y kubelet=1.18.9-00 kubeadm=1.18.9-00 kubectl=1.18.9-00 
// Initialize the master node
$ sudo kubeadm init --pod-network-cidr 172.16.0.0/16 \
--apiserver-advertise-address=192.168.3.167 \
--image-repository registry.cn-hangzhou.aliyuncs.com/google_containers
// join the work node
$ kubeadm join 192.168.3.167:6443 --token 3zefbt.99e6denc1cxpk9fg \
   --discovery-token-ca-cert-hash sha256:8077d4e7dd6eee64a999d56866ae4336073ed5ffc3f23281d757276b08b9b195
</code></pre>
<h4 id="install-yurtctl"><a class="header" href="#install-yurtctl">Install yurtctl</a></h4>
<p>Use the following command line to install yurtctl. The yurtctl CLI tool helps install/uninstall OpenYurt and also convert a standard Kubernetes cluster to an OpenYurt cluster.</p>
<pre><code class="language-bash">git clone https://github.com/openyurtio/openyurt.git
cd openyurt
make build WHAT=cmd/yurtctl
</code></pre>
<h4 id="install-openyurt-components"><a class="header" href="#install-openyurt-components">Install OpenYurt components</a></h4>
<p>OpenYurt includes several components. YurtHub is the traffic proxy between the components on the node and Kube-apiserver. The YurtHub on the edge will cache the data returned from the cloud. Yurt controller supplements the upstream node controller to support edge computing requirements. TunnelServer connects with the TunnelAgent daemon running in each edge node via a reverse proxy to establish secure network access between the cloud site control plane and the edge nodes that are connected to the intranet. For more detailed information, you could refer to the <a href="https://github.com/openyurtio/openyurt">OpenYurt docs</a>.</p>
<pre><code class="language-bash">yurtctl convert --deploy-yurttunnel --cloud-nodes oy-master --provider kubeadm\
--yurt-controller-manager-image=&quot;openyurt/yurt-controller-manager:v0.5.0&quot;\
--yurt-tunnel-agent-image=&quot;openyurt/yurt-tunnel-agent:v0.5.0&quot;\
--yurt-tunnel-server-image=&quot;openyurt/yurt-tunnel-server:v0.5.0&quot;\
--node-servant-image=&quot;openyurt/node-servant:latest&quot;\
--yurthub-image=&quot;openyurt/yurthub:v0.5.0&quot;
</code></pre>
<p>We need to change the openyurt/node-server-version to latest here: --node-servant-image=&quot;openyurt/node-servant:latest&quot;</p>
<p>Actually, OpenYurt components 0.6.0 version is recommended to be installed and proved to be a success to run a WasmEdge demo.
How to install OpenYurt:0.6.0, you can see <a href="https://github.com/openyurtio/openyurt/releases/tag/v0.6.0">this</a></p>
<h3 id="use-openyurt-experience-center-to-quickly-set-up-an-openyurt-cluster"><a class="header" href="#use-openyurt-experience-center-to-quickly-set-up-an-openyurt-cluster">Use OpenYurt Experience Center to quickly set up an OpenYurt Cluster</a></h3>
<p>An easier way to set up an OpenYurt Cluster is to use the OpenYurt Experience Center. All you need to do is to sign up for an account for testing, and then you will get an OpenYurt cluster. Next, you could just use <code>yurtctl join</code> command line to join an edge node. See more OpenYurt Experience Center details <a href="https://openyurt.io/docs/installation/openyurt-experience-center/overview/">here</a>.</p>
<h2 id="run-a-simple-webassembly-app-2"><a class="header" href="#run-a-simple-webassembly-app-2">Run a simple WebAssembly app</a></h2>
<p>Next, let's run a WebAssembly program through the OpenYurt cluster as a container in the pod. This section will start off pulling this WebAssembly-based container image from Docker hub. If you want to learn how to compile, package, and publish the WebAssembly program as a container image to Docker hub, please refer to <a href="https://wasmedge.org/book/en/kubernetes/demo/wasi.html">WasmEdge Book</a>.</p>
<p>One thing is to note that because the kubectl run (version 1.18.9 ) missed annotations parameters, we need to adjust the command line here. If you are using OpenYurt Experience Center with OpenYurt 0.6.0 and Kubernetes 1.20.11 by default, please refer to <a href="https://wasmedge.org/book/en/kubernetes/kubernetes.html">the Kubernetes sections</a> in the WasmEdge book to run the wasm app.</p>
<pre><code class="language-bash">// kubectl 1.18.9
$ sudo kubectl run -it --rm --restart=Never wasi-demo --image=hydai/wasm-wasi-example:with-wasm-annotation  --overrides='{&quot;kind&quot;:&quot;Pod&quot;,&quot;metadata&quot;:{&quot;annotations&quot;:{&quot;module.wasm.image/variant&quot;:&quot;compat&quot;}} , &quot;apiVersion&quot;:&quot;v1&quot;, &quot;spec&quot;: {&quot;hostNetwork&quot;: true}}' /wasi_example_main.wasm 50000000

// kubectl 1.20.11
$ sudo kubectl run -it --rm --restart=Never wasi-demo --image=hydai/wasm-wasi-example:with-wasm-annotation --annotations=&quot;module.wasm.image/variant=compat&quot; --overrides='{&quot;kind&quot;:&quot;Pod&quot;, &quot;apiVersion&quot;:&quot;v1&quot;, &quot;spec&quot;: {&quot;hostNetwork&quot;: true}}' /wasi_example_main.wasm 50000000

</code></pre>
<p>The output from the containerized application is printed into the console. It is the same for all Kubernetes versions.</p>
<pre><code class="language-bash">Random number: 1123434661
Random bytes: [25, 169, 202, 211, 22, 29, 128, 133, 168, 185, 114, 161, 48, 154, 56, 54, 99, 5, 229, 161, 225, 47, 85, 133, 90, 61, 156, 86, 3, 14, 10, 69, 185, 225, 226, 181, 141, 67, 44, 121, 157, 98, 247, 148, 201, 248, 236, 190, 217, 245, 131, 68, 124, 28, 193, 143, 215, 32, 184, 50, 71, 92, 148, 35, 180, 112, 125, 12, 152, 111, 32, 30, 86, 15, 107, 225, 39, 30, 178, 215, 182, 113, 216, 137, 98, 189, 72, 68, 107, 246, 108, 210, 148, 191, 28, 40, 233, 200, 222, 132, 247, 207, 239, 32, 79, 238, 18, 62, 67, 114, 186, 6, 212, 215, 31, 13, 53, 138, 97, 169, 28, 183, 235, 221, 218, 81, 84, 235]
Printed from wasi: This is from a main function
This is from a main function
The env vars are as follows.
The args are as follows.
/wasi_example_main.wasm
50000000
File content is This is in a file
pod &quot;wasi-demo&quot; deleted
</code></pre>
<p>You can now check out the pod status through the Kubernetes command line.</p>
<pre><code class="language-bash">crictl ps -a
</code></pre>
<p>You can see the events from scheduling to running the WebAssembly workload in the log.</p>
<pre><code class="language-bash">CONTAINER           IMAGE               CREATED             STATE               NAME                 ATTEMPT             POD ID
0c176ed65599a       0423b8eb71e31       8 seconds ago       Exited              wasi-demo  
</code></pre>
<ul>
<li>WasmEdge GitHub repo: <a href="https://github.com/WasmEdge/WasmEdge">https://github.com/WasmEdge/WasmEdge</a></li>
<li>OpenYurt GitHub repo: <a href="https://github.com/openyurtio/openyurt">https://github.com/openyurtio/openyurt</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="app-frameworks-and-platforms"><a class="header" href="#app-frameworks-and-platforms">App frameworks and platforms</a></h1>
<p>WasmEdge applications can be plugged into existing application frameworks or platforms. WasmEdge provides a safe and efficient extension mechanism for those frameworks.</p>
<p>In this chapter, we will cover several such framework and platforms.</p>
<ul>
<li><a href="frameworks/mesh.html">Service mesh and frameworks</a> support WasmEdge to run as containers for microservices. We will cover distributed application framework <a href="frameworks/mesh/dapr.html">Dapr</a>, service mesh <a href="frameworks/mesh/mosn.html">MOSN</a>, and event mesh <a href="frameworks/mesh/eventmesh.html">Apache EventMesh</a>.</li>
<li><a href="frameworks/app.html">Application frameworks</a> support WasmEdge as an embedded function or plug-in runtime. We will cover streaming data framework <a href="frameworks/app/yomo.html">YoMo</a> and Go function schedulder / framework <a href="frameworks/app/reactr.html">Reactr</a>.</li>
<li><a href="frameworks/serverless.html">Serverless platforms</a> allows WasmEdge programs to run as serverless functions in their infrastructure. We will cover <a href="frameworks/serverless/aws.html">AWS Lambda</a>, <a href="frameworks/serverless/tencent.html">Tencent Serverless Cloud Functions</a>, <a href="frameworks/serverless/vercel.html">Vercel Serverless Functions</a>, <a href="frameworks/serverless/netlify.html">Netlify Functions</a>, and <a href="frameworks/serverless/secondstate.html">Second State Functions</a>.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="service-mesh-and-distributed-runtimes"><a class="header" href="#service-mesh-and-distributed-runtimes">Service mesh and distributed runtimes</a></h1>
<p>WasmEdge could be a lightweight runtime for sidecar microservices and the API proxy as the Docker alternative.</p>
<h2 id="sidecar-microservices"><a class="header" href="#sidecar-microservices">Sidecar microservices</a></h2>
<p>For sidecar frameworks that support multiple application runtimes, we could simply embed WasmEdge applications into the sidecar through its C, Go, Rust, or Node.js SDKs. In addition, WasmEdge applications could be managed directly by container tools and act as sidecar microservices.</p>
<ul>
<li><a href="frameworks/mesh/dapr.html">Dapr</a> showcases how to run WasmEdge microservices as Dapr sidecars.</li>
<li><a href="frameworks/mesh/evenmesh.html">Apache EventMesh</a> showcases how to run WasmEdge microservices as Apache EventMesh sidecars</li>
</ul>
<h2 id="extension-for-the-api-proxy"><a class="header" href="#extension-for-the-api-proxy">Extension for the API proxy</a></h2>
<p>The API proxy is another crucial component in the service mesh. It manages and directs API requests to sidecars in a manner that keeps the system scalable. Developers need to script those proxies to route traffic according to changing infrastructure and ops requirements. Seeing widespread demand for using WebAssembly instead of the LUA scripting language, the community came together and created the proxy-wasm spec. It defines the host interface that WebAssembly runtimes must support to plug into the proxy. WasmEdge supports proxy-wasm now.</p>
<ul>
<li><a href="frameworks/mesh/mosn.html">MOSN</a> shows how to use WasmEdge as extensions for MOSN.</li>
</ul>
<p>If you have some great ideas on WasmEdge and microservices, feel free to create an issue or PR on the <a href="https://github.com/WasmEdge/WasmEdge">WasmEdge</a> GitHub repo!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="dapr"><a class="header" href="#dapr">Dapr</a></h1>
<p>In this article, I will demonstrate how to use WasmEdge as a sidecar application runtime for Dapr. We use a simple NaCl written in Rust or Go to listen for API requests to the microservice. It passes the request data to a WebAssembly runtime for processing. The business logic of the microservice is a WebAssembly function created and deployed by an application developer. You can also watch <a href="https://www.youtube.com/watch?v=t_sQP6Qpf7U">a walk-through video</a>.</p>
<blockquote>
<p>For more insights on WasmEdge on Dapr, please refer to the article <a href="https://www.secondstate.io/articles/dapr-wasmedge-webassembly/">A Lightweight, Safe, Portable, and High-performance Runtime for Dapr</a></p>
</blockquote>
<h2 id="quick-start-6"><a class="header" href="#quick-start-6">Quick start</a></h2>
<p>First you need to install <a href="https://golang.org/doc/install">Go</a>, <a href="https://www.rust-lang.org/tools/install">Rust</a>, <a href="https://docs.dapr.io/getting-started/install-dapr-cli">Dapr</a>, <a href="frameworks/mesh/../../start/install.html">WasmEdge</a>, and the <a href="frameworks/mesh/../../dev/rust/bindgen.html">rustwasmc</a> compiler tool.</p>
<p>Next, fork or clone the demo application from Github. You can use this repo as your own application template.</p>
<pre><code class="language-bash">git clone https://github.com/second-state/dapr-wasm
</code></pre>
<p>The demo has 3 Dapr sidecar applications.</p>
<ul>
<li>The <a href="https://github.com/second-state/dapr-wasm/tree/main/web-port">web-port</a> project provides a public web service for a static HTML page. This is the application’s UI.</li>
<li>The <a href="https://github.com/second-state/dapr-wasm/tree/main/image-api-rs">image-api-rs</a> project provides a WasmEdge microservice to turn an input image into a grayscale image using the <a href="https://github.com/second-state/dapr-wasm/tree/main/functions/grayscale&amp;sa=D&amp;source=editors&amp;ust=1634144162467000&amp;usg=AOvVaw1uNZEDmOfXXXzLHHZWVFyD">grayscale</a> function.
It demonstrates the use of Rust SDKs for Dapr and WasmEdge.</li>
<li>The <a href="https://github.com/second-state/dapr-wasm/tree/main/image-api-go&amp;sa=D&amp;source=editors&amp;ust=1634144162467000&amp;usg=AOvVaw3pG0m0DQap9XTUAfBMyi1s">image-api-go</a> project provides a WasmEdge microservice to recognize and classify the object on an input image using the <a href="https://github.com/second-state/dapr-wasm/tree/main/functions/classify&amp;sa=D&amp;source=editors&amp;ust=1634144162468000&amp;usg=AOvVaw0zYdNzIz6MiDkZCAvm_D9q">classify</a> function.
It demonstrates the use of Go SDKs for Dapr and WasmEdge.</li>
</ul>
<p><img src="frameworks/mesh/dapr-wasmedge.png" alt="dapr-wasmedge" /></p>
<p>Dapr sidecar microservices in the demo application.</p>
<p>You can follow the instructions in the <a href="https://github.com/second-state/dapr-wasm/blob/main/README.md">README</a> to start the sidecar services. Here are commands to build the WebAssembly functions and start the 3 sidecar services.</p>
<pre><code class="language-bash"># Build the classify and grayscale WebAssembly functions, and deploy them to the sidecar projects
cd functions/grayscale
./build.sh
cd ../../
cd functions/classify
./build.sh
cd ../../

# Build and start the web service for the application UI
cd web-port
go build
./run_web.sh
cd ../

# Build and start the microservice for image processing (grayscale)
cd image-api-rs
cargo build
./run_api_rs.sh
cd ../

# Build and start the microservice for tensorflow-based image classification
cd image-api-go
go build --tags &quot;tensorflow image&quot;
./run_api_go.sh
cd ../
</code></pre>
<p>Finally, you should be able to see the web UI in your browser.</p>
<p><img src="frameworks/mesh/dapr-wasmedge-in-action.png" alt="dapr-wasmedge" /></p>
<p>The demo application in action.</p>
<h2 id="the-two-webassembly-functions"><a class="header" href="#the-two-webassembly-functions">The two WebAssembly functions</a></h2>
<p>We have two functions written in Rust and compiled into WebAssembly. They are deployed in the sidecar microservices to perform the actual work of image processing and classification.</p>
<p>While our example WebAssembly functions are written in Rust, you can compile functions written in C/C++, Swift, Kotlin, and AssemblyScript to WebAssembly. WasmEdge also provides support for functions written in
JavaScript and DSLs.</p>
<p>The <a href="https://github.com/second-state/dapr-wasm/tree/main/functions/grayscale">grayscale</a> function is a Rust program that reads image data from <code>STDIN</code> and writes the grayscale image into <code>STDOUT</code>.</p>
<pre><pre class="playground"><code class="language-rust">use image::{ImageFormat, ImageOutputFormat};
use std::io::{self, Read, Write};

fn main() {
  let mut buf = Vec::new();
  io::stdin().read_to_end(&amp;mut buf).unwrap();

  let image_format_detected: ImageFormat = image::guess_format(&amp;buf).unwrap();
  let img = image::load_from_memory(&amp;buf).unwrap();
  let filtered = img.grayscale();
  let mut buf = vec![];
  match image_format_detected {
    ImageFormat::Gif =&gt; {
      filtered.write_to(&amp;mut buf, ImageOutputFormat::Gif).unwrap();
    }
    _ =&gt; {
      filtered.write_to(&amp;mut buf, ImageOutputFormat::Png).unwrap();
    }
  };
  io::stdout().write_all(&amp;buf).unwrap();
  io::stdout().flush().unwrap();
}
</code></pre></pre>
<p>We use <a href="https://www.secondstate.io/articles/rustwasmc/">rustwasmc</a> to build it and then copy it to the
<a href="https://github.com/second-state/dapr-wasm/tree/main/image-api-rs">image-api-rs</a> sidecar.</p>
<pre><code class="language-bash">cd functions/grayscale
rustup override set 1.50.0
rustwasmc  build --enable-ext
cp ./pkg/grayscale.wasm ../../image-api-rs/lib
</code></pre>
<p>The <a href="https://github.com/second-state/dapr-wasm/tree/main/functions/classify">classify</a> function
is a Rust function that takes a byte array for image data as input and returns a string for the classification. It uses the <a href="https://www.secondstate.io/articles/wasi-tensorflow/">WasmEdge
TensorFlow API</a>.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use wasmedge_tensorflow_interface;

pub fn infer_internal(image_data: &amp;[u8]) -&gt; String {
  let model_data: &amp;[u8] = include_bytes!(&quot;models/mobilenet_v1_1.0_224/mobilenet_v1_1.0_224_quant.tflite&quot;);
  let labels = include_str!(&quot;models/mobilenet_v1_1.0_224/labels_mobilenet_quant_v1_224.txt&quot;);

  let flat_img = wasmedge_tensorflow_interface::load_jpg_image_to_rgb8(image_data, 224, 224);

  let mut session = wasmedge_tensorflow_interface::Session::new(
    &amp;model_data,
    wasmedge_tensorflow_interface::ModelType::TensorFlowLite,
  );
  session.add_input(&quot;input&quot;, &amp;flat_img, &amp;[1, 224, 224, 3])
         .run();
  let res_vec: Vec&lt;u8&gt; = session.get_output(&quot;MobilenetV1/Predictions/Reshape_1&quot;);

  // ... Map the probabilities in res_vec to text labels in the labels file ...

  if max_value &gt; 50 {
    format!(
      &quot;It {} a &lt;a href='https://www.google.com/search?q={}'&gt;{}&lt;/a&gt; in the picture&quot;,
      confidence.to_string(),
      class_name,
      class_name
    )
  } else {
    format!(&quot;It does not appears to be any food item in the picture.&quot;)
  }
}
<span class="boring">}
</span></code></pre></pre>
<p>We use <a href="https://www.secondstate.io/articles/rustwasmc/">rustwasmc</a> to build it and then copy it to the <a href="https://github.com/second-state/dapr-wasm/tree/main/image-api-go">image-api-go</a> sidecar.</p>
<pre><code class="language-bash">cd functions/classify
rustup override set 1.50.0
rustwasmc  build --enable-ext
cp ./pkg/classify_bg.wasm ../../image-api-go/lib/classify_bg.wasm
</code></pre>
<p>In the next three sections, we will look into those three sidecar services.</p>
<h2 id="the-image-processing-sidecar"><a class="header" href="#the-image-processing-sidecar">The image processing sidecar</a></h2>
<p>The <a href="https://github.com/second-state/dapr-wasm/tree/main/image-api-rs">image-api-rs</a> sidecar application is written in Rust. It should already have the WebAssembly function <code>lib/grayscale.wasm</code> installed from the previous step. Please refer to the <a href="https://github.com/second-state/dapr-wasm/blob/main/functions/bin/install.sh">functions/bin/install.sh</a> script to install the WasmEdge Runtime binary <code>lib/wasmedge-tensorflow-lite</code> and its dependencies.</p>
<p>The sidecar microservice runs a Tokio-based event loop that listens for incoming HTTP requests at the path <code>/api/image</code>.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[tokio::main]
pub async fn run_server(port: u16) {
  pretty_env_logger::init();

  let home = warp::get().map(warp::reply);

  let image = warp::post().and(warp::path(&quot;api&quot;))
                          .and(warp::path(&quot;image&quot;))
                          .and(warp::body::bytes())
                          .map(|bytes: bytes::Bytes| {
    let v: Vec&lt;u8&gt; = bytes.iter().map(|&amp;x| x).collect();
    let res = image_process(&amp;v);
    Ok(Box::new(res))
  });

  let routes = home.or(image);
  let routes = routes.with(warp::cors().allow_any_origin());

  let log = warp::log(&quot;dapr_wasm&quot;);
  let routes = routes.with(log);
  warp::serve(routes).run((Ipv4Addr::UNSPECIFIED, port)).await
}
<span class="boring">}
</span></code></pre></pre>
<p>Once it receives an image file in the HTTP POST request, it invokes a WebAssembly function in WasmEdge to perform the image processing task. It creates a WasmEdge instance to interact with the WebAssembly program.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn image_process(buf: &amp;Vec&lt;u8&gt;) -&gt; Vec&lt;u8&gt; {
  let mut child = Command::new(&quot;./lib/wasmedge-tensorflow-lite&quot;)
    .arg(&quot;./lib/grayscale.wasm&quot;)
    .stdin(Stdio::piped())
    .stdout(Stdio::piped())
    .spawn()
    .expect(&quot;failed to execute child&quot;);
  {
    // limited borrow of stdin
    let stdin = child.stdin.as_mut().expect(&quot;failed to get stdin&quot;);
    stdin.write_all(buf).expect(&quot;failed to write to stdin&quot;);
  }
  let output = child.wait_with_output().expect(&quot;failed to wait on child&quot;);
  output.stdout
}
<span class="boring">}
</span></code></pre></pre>
<p>The following Dapr CLI command starts the microservice in the Dapr runtime environment.</p>
<pre><code class="language-bash">cd image-api-rs
sudo dapr run --app-id image-api-rs \
    --app-protocol http \
    --app-port 9004 \
    --dapr-http-port 3502 \
    --components-path ../config \
    --log-level debug \
    ./target/debug/image-api-rs
cd ../
</code></pre>
<h2 id="the-tensorflow-sidecar"><a class="header" href="#the-tensorflow-sidecar">The Tensorflow sidecar</a></h2>
<p>The <a href="https://github.com/second-state/dapr-wasm/tree/main/image-api-go">image-api-go</a> sidecar application is written in Go. It should already have the WebAssembly function <code>lib/classify\_bg.wasm</code> installed from the previous step. Please refer to the <a href="https://github.com/second-state/dapr-wasm/blob/main/functions/bin/install.sh">functions/bin/install.sh</a> script to install the WasmEdge Runtime Go SDK.</p>
<p>The sidecar microservice runs an event loop that listens for incoming HTTP requests at the path <code>/api/image</code>.</p>
<pre><code class="language-go">func main() {
  s := daprd.NewService(&quot;:9003&quot;)

  if err := s.AddServiceInvocationHandler(&quot;/api/image&quot;, imageHandlerWASI); err != nil {
    log.Fatalf(&quot;error adding invocation handler: %v&quot;, err)
  }

  if err := s.Start(); err != nil &amp;&amp; err != http.ErrServerClosed {
    log.Fatalf(&quot;error listenning: %v&quot;, err)
  }
}
</code></pre>
<p>Once it receives an image file in the HTTP POST request, it invokes a WebAssembly function in WasmEdge to perform the Tensorflow-based image classification task. It utilizes the Go API for WasmEdge to interact with the WebAssembly program.</p>
<pre><code class="language-go">func imageHandlerWASI(_ context.Context, in *common.InvocationEvent) (out *common.Content, err error) {
  image := in.Data

  var conf = wasmedge.NewConfigure(wasmedge.REFERENCE_TYPES)
  conf.AddConfig(wasmedge.WASI)
  var vm = wasmedge.NewVMWithConfig(conf)

  var wasi = vm.GetImportObject(wasmedge.WASI)
  wasi.InitWasi(
    os.Args[1:],     // The args
    os.Environ(),    // The envs
    []string{&quot;.:.&quot;}, // The mapping directories
    []string{},      // The preopens will be empty
  )

  // Register WasmEdge-tensorflow and WasmEdge-image
  var tfobj = wasmedge.NewTensorflowImportObject()
  var tfliteobj = wasmedge.NewTensorflowLiteImportObject()
  vm.RegisterImport(tfobj)
  vm.RegisterImport(tfliteobj)
  var imgobj = wasmedge.NewImageImportObject()
  vm.RegisterImport(imgobj)

  vm.LoadWasmFile(&quot;./lib/classify_bg.wasm&quot;)
  vm.Validate()
  vm.Instantiate()

  res, err := vm.ExecuteBindgen(&quot;infer&quot;, wasmedge.Bindgen_return_array, image)
  ans := string(res.([]byte))
  
  vm.Delete()
  conf.Delete()

  out = &amp;common.Content{
    Data:    []byte(ans),
    ContentType: in.ContentType,
    DataTypeURL: in.DataTypeURL,
  }
  return out, nil
}
</code></pre>
<p>The following Dapr CLI command starts the microservice in the Dapr runtime environment.</p>
<pre><code class="language-bash">cd image-api-go
sudo dapr run --app-id image-api-go \
    --app-protocol http \
    --app-port 9003 \
    --dapr-http-port 3501 \
    --log-level debug \
    --components-path ../config \
    ./image-api-go
cd ../
</code></pre>
<h2 id="the-web-ui-sidecar"><a class="header" href="#the-web-ui-sidecar">The web UI sidecar</a></h2>
<p>The web UI service <a href="https://github.com/second-state/dapr-wasm/tree/main/web-port">web-port</a> is a simple web server written in Go. It serves static HTML and JavaScript files from the static folder and sends images uploaded to <code>/api/hello</code> to the <a href="https://github.com/second-state/dapr-wasm/tree/main/image-api-rs">grayscale</a> or <a href="https://github.com/second-state/dapr-wasm/tree/main/image-api-go">classify</a> sidecars’ <code>/api/image</code> endpoints.</p>
<pre><code class="language-go">func main() {
  http.HandleFunc(&quot;/static/&quot;, staticHandler)
  http.HandleFunc(&quot;/api/hello&quot;, imageHandler)
  println(&quot;listen to 8080 ...&quot;)
  log.Fatal(http.ListenAndServe(&quot;:8080&quot;, nil))
}

func staticHandler(w http.ResponseWriter, r *http.Request) {
  // ... read and return the contents of HTML CSS and JS files ...
}

func imageHandler(w http.ResponseWriter, r *http.Request) {
  // ... ...
  api := r.Header.Get(&quot;api&quot;)
  if api == &quot;go&quot; {
    daprClientSend(body, w)
  } else {
    httpClientSend(body, w)
  }
}

// Send to the image-api-go sidecar (classify) via the Dapr API
func daprClientSend(image []byte, w http.ResponseWriter) {
  // ... ...
  resp, err := client.InvokeMethodWithContent(ctx, &quot;image-api-go&quot;, &quot;/api/image&quot;, &quot;post&quot;, content)
  // ... ...
}

// Send to the image-api-rs sidecar (grayscale) via the HTTP API
func httpClientSend(image []byte, w http.ResponseWriter) {
  // ... ...
  req, err := http.NewRequest(&quot;POST&quot;, &quot;http://localhost:3502/v1.0/invoke/image-api-rs/method/api/image&quot;, bytes.NewBuffer(image))
  // ... ...
}
</code></pre>
<p>The JavaScript in <a href="https://github.com/second-state/dapr-wasm/blob/main/web-port/static/page.js">page.js</a> simply uploads images to the <a href="https://github.com/second-state/dapr-wasm/tree/main/web-port">web-port</a> sidecar’s <code>/api/hello</code> endpoint and the <a href="https://github.com/second-state/dapr-wasm/tree/main/web-port">web-port</a> will request the classify or grayscale microservice based on the request header api.</p>
<pre><code class="language-javascript">function runWasm(e) {
  const reader = new FileReader();
  reader.onload = function (e) {
    setLoading(true);
    var req = new XMLHttpRequest();
    req.open(&quot;POST&quot;, '/api/hello', true);
    req.setRequestHeader('api', getApi());
    req.onload = function () {
      // ...  display results ...
    };
    const blob = new Blob([e.target.result], {
      type: 'application/octet-stream'
    });
    req.send(blob);
  };
  console.log(image.file)
  reader.readAsArrayBuffer(image.file);
}
</code></pre>
<p>The following Dapr CLI command starts the web service for the static UI files.</p>
<pre><code class="language-bash">cd web-port
sudo dapr run --app-id go-web-port \
    --app-protocol http \
    --app-port 8080 \
    --dapr-http-port 3500 \
    --components-path ../config \
    --log-level debug \
    ./web-port
cd ../
</code></pre>
<p>That's it. You now have a three part distributed application written in two languages!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mosn"><a class="header" href="#mosn">MOSN</a></h1>
<p>Coming soon.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="apache-eventmesh"><a class="header" href="#apache-eventmesh">Apache EventMesh</a></h1>
<p>Coming soon, or you can <a href="https://github.com/WasmEdge/WasmEdge/issues/632">help out</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="app-frameworks"><a class="header" href="#app-frameworks">App frameworks</a></h1>
<p>WasmEdge provides a safe and efficient extension mechanism for applications.
Of course, application developers can always use <a href="frameworks/../embed.html">WasmEdge SDKs</a> to embed WebAssembly functions. But some applications and frameworks opt to build their own extension / embedding APIs on top of the WasmEdge SDK, which supports more ergonomic integration with the application's native use cases and programming models.</p>
<ul>
<li><a href="frameworks/app/yomo.html">YoMo</a> is a data stream processing framework. WasmEdge functions can be plugged into the framework to process data in-stream.</li>
<li><a href="frameworks/app/reactr.html">Reactr</a> is a Go language framework for managing and extending WebAssembly functions for the purpose of easy embedding into other Go applications.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="yomo"><a class="header" href="#yomo">YoMo</a></h1>
<p><a href="https://yomo.run/">YoMo</a> is a programming framework enabling developers to build a distributed cloud system (Geo-Distributed Cloud System). YoMo's communication layer is made on top of the QUIC protocol, which brings high-speed data transmission. In addition, it has a built-in Streaming Serverless &quot;streaming function&quot;, which significantly improves the development experience of distributed cloud systems. The distributed cloud system built by YoMo provides an ultra-high-speed communication mechanism between near-field computing power and terminals. It has a wide range of use cases in Metaverse, VR/AR, IoT, etc.</p>
<blockquote>
<p>YoMo is written in the Go language. For streaming Serverless, Golang plugins and shared libraries are used to load users' code dynamically, which also have certain limitations for developers. Coupled with Serverless architecture's rigid demand for isolation, this makes WebAssembly an excellent choice for running user-defined functions.</p>
</blockquote>
<p>For example, in the process of real-time AI inference in AR/VR devices or smart factories, the camera sends real-time unstructured data to the computing node in the near-field MEC (multi-access edge computing) device through YoMo.  YoMo sends the AI computing result to the end device in real-time when the AI inference is completed. Thus, the hosted AI inference function will be automatically executed.</p>
<p>However, a challenge for YoMo is to incorporate and manage handler functions written by multiple outside developers in an edge computing node. It requires runtime isolation for those functions without sacrificing performance. Traditional software container solutions, such as Docker, are not up to the task. They are too heavy and slow to handle real-time tasks.</p>
<p>WebAssembly provides a lightweight and high-performance software container. It is ideally suited as a runtime for YoMo’s data processing handler functions.</p>
<p>In this article, we will show you how to create a Rust function for Tensorflow-based image classification, compile it into WebAssembly, and then use YoMo to run it as a stream data handler. We use <a href="https://wasmedge.org/">WasmEdge</a> as our WebAssembly runtime because it offers the highest performance and flexibility compared with other WebAssembly runtimes. It is the only WebAssembly VM that reliably supports Tensorflow. YoMo manages WasmEdge VM instances and the contained WebAssembly bytecode apps through <a href="https://github.com/WasmEdge/WasmEdge/blob/master/docs/book/en/src/embed/go.md">WasmEdge’s Golang API</a>.</p>
<blockquote>
<p>Source code: <a href="https://github.com/yomorun/yomo-wasmedge-tensorflow">https://github.com/yomorun/yomo-wasmedge-tensorflow</a></p>
</blockquote>
<p>Checkout <a href="https://www.youtube.com/watch?v=E0ltsn6cLIU">the WasmEdge image classification function in action in YoMo</a></p>
<h2 id="prerequisite-2"><a class="header" href="#prerequisite-2">Prerequisite</a></h2>
<p>Obviously, you will need to have <a href="https://golang.org/doc/install">Golang installed</a>, but I will assume you already did.</p>
<blockquote>
<p>Golang version should be newer than 1.15 for our example to work.</p>
</blockquote>
<p>You also need to install the YoMo CLI application. It orchestrates and coordinates data streaming and handler function invocations.</p>
<pre><code class="language-bash">$ go install github.com/yomorun/cli/yomo@latest
$ yomo version
YoMo CLI version: v0.1.3
</code></pre>
<p>Next, please install the WasmEdge and its Tensorflow shared libraries. <a href="https://wasmedge.org/">WasmEdge</a> is a leading WebAssembly runtime hosted by the CNCF. We will use it to embed and run WebAssembly programs from YoMo.</p>
<pre><code class="language-bash">curl -sSf https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/utils/install.sh | bash
</code></pre>
<p>Finally, since our demo WebAssembly functions are written in Rust, you will also need a <a href="https://www.rust-lang.org/tools/install">Rust compiler</a>.</p>
<p>For the rest of the demo, fork and clone the <a href="https://github.com/yomorun/yomo-wasmedge-tensorflow">source code repository</a>.</p>
<pre><code class="language-bash">git clone https://github.com/yomorun/yomo-wasmedge-tensorflow.git
</code></pre>
<h2 id="the-image-classification-function"><a class="header" href="#the-image-classification-function">The image classification function</a></h2>
<p>The <a href="https://github.com/yomorun/yomo-wasmedge-tensorflow/tree/main/flow/rust_mobilenet_food">image classification function</a> to process the YoMo image stream is written in Rust. It utilizes the WasmEdge Tensorflow API to process an input image.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[wasmedge_bindgen]
pub fn infer(image_data: Vec&lt;u8&gt;) -&gt; Result&lt;Vec&lt;u8&gt;, String&gt; {
  let start = Instant::now();

  // Load the TFLite model and its meta data (the text label for each recognized object number)
  let model_data: &amp;[u8] = include_bytes!(&quot;lite-model_aiy_vision_classifier_food_V1_1.tflite&quot;);
  let labels = include_str!(&quot;aiy_food_V1_labelmap.txt&quot;);

  // Pre-process the image to a format that can be used by this model
  let flat_img = wasmedge_tensorflow_interface::load_jpg_image_to_rgb8(&amp;image_data[..], 192, 192);
  println!(&quot;RUST: Loaded image in ... {:?}&quot;, start.elapsed());

  // Run the TFLite model using the WasmEdge Tensorflow API
  let mut session = wasmedge_tensorflow_interface::Session::new(&amp;model_data, wasmedge_tensorflow_interface::ModelType::TensorFlowLite);
  session.add_input(&quot;input&quot;, &amp;flat_img, &amp;[1, 192, 192, 3])
         .run();
  let res_vec: Vec&lt;u8&gt; = session.get_output(&quot;MobilenetV1/Predictions/Softmax&quot;);

  // Find the object index in res_vec that has the greatest probability
  // Translate the probability into a confidence level
  // Translate the object index into a label from the model meta data food_name
  let mut i = 0;
  let mut max_index: i32 = -1;
  let mut max_value: u8 = 0;
  while i &lt; res_vec.len() {
    let cur = res_vec[i];
    if cur &gt; max_value {
      max_value = cur;
      max_index = i as i32;
    }
    i += 1;
  }
  println!(&quot;RUST: index {}, prob {}&quot;, max_index, max_value);

  let confidence: String;
  if max_value &gt; 200 {
    confidence = &quot;is very likely&quot;.to_string();
  } else if max_value &gt; 125 {
    confidence = &quot;is likely&quot;.to_string();
  } else {
    confidence = &quot;could be&quot;.to_string();
  }

  let ret_str: String;
  if max_value &gt; 50 {
    let mut label_lines = labels.lines();
    for _i in 0..max_index {
      label_lines.next();
    }
    let food_name = label_lines.next().unwrap().to_string();
    ret_str = format!(
      &quot;It {} a &lt;a href='https://www.google.com/search?q={}'&gt;{}&lt;/a&gt; in the picture&quot;,
      confidence, food_name, food_name
    );
  } else {
    ret_str = &quot;It does not appears to be a food item in the picture.&quot;.to_string();
  }

  println!(
    &quot;RUST: Finished post-processing in ... {:?}&quot;,
    start.elapsed()
  );
  return Ok(ret_str.as_bytes().to_vec());
}
<span class="boring">}
</span></code></pre></pre>
<p>You should add <code>wasm32-wasi</code> target to rust to compile this function into WebAssembly bytecode.</p>
<pre><code class="language-bash">rustup target add wasm32-wasi

cd flow/rust_mobilenet_food
cargo build --target wasm32-wasi --release
# The output WASM will be target/wasm32-wasi/release/rust_mobilenet_food_lib.wasm

# Copy the wasm bytecode file to the flow/ directory
cp target/wasm32-wasi/release/rust_mobilenet_food_lib.wasm ../
</code></pre>
<p>To release the best performance of WasmEdge, you should enable the AOT mode by compiling the <code>.wasm</code> file to the <code>.so</code>.</p>
<pre><code class="language-bash">wasmedgec rust_mobilenet_food_lib.wasm rust_mobilenet_food_lib.so
</code></pre>
<h2 id="integration-with-yomo"><a class="header" href="#integration-with-yomo">Integration with YoMo</a></h2>
<p>On the YoMo side, we use the WasmEdge Golang API to start and run WasmEdge VM for the image classification function. The <a href="https://github.com/yomorun/yomo-wasmedge-tensorflow/blob/main/flow/app.go">app.go</a> file in the source code project is as follows.</p>
<pre><code class="language-go">package main

import (
  &quot;crypto/sha1&quot;
  &quot;fmt&quot;
  &quot;log&quot;
  &quot;os&quot;
  &quot;sync/atomic&quot;

  &quot;github.com/second-state/WasmEdge-go/wasmedge&quot;
  bindgen &quot;github.com/second-state/wasmedge-bindgen/host/go&quot;
  &quot;github.com/yomorun/yomo&quot;
)

var (
  counter uint64
)

const ImageDataKey = 0x10

func main() {
  // Connect to Zipper service
  sfn := yomo.NewStreamFunction(&quot;image-recognition&quot;, yomo.WithZipperAddr(&quot;localhost:9900&quot;))
  defer sfn.Close()

  // set only monitoring data
  sfn.SetObserveDataID(ImageDataKey)

  // set handler
  sfn.SetHandler(Handler)

  // start
  err := sfn.Connect()
  if err != nil {
    log.Print(&quot;❌ Connect to zipper failure: &quot;, err)
    os.Exit(1)
  }

  select {}
}

// Handler process the data in the stream
func Handler(img []byte) (byte, []byte) {
  // Initialize WasmEdge's VM
  vmConf, vm := initVM()
  bg := bindgen.Instantiate(vm)
  defer bg.Release()
  defer vm.Release()
  defer vmConf.Release()

  // recognize the image
  res, err := bg.Execute(&quot;infer&quot;, img)
  if err == nil {
    fmt.Println(&quot;GO: Run bindgen -- infer:&quot;, string(res))
  } else {
    fmt.Println(&quot;GO: Run bindgen -- infer FAILED&quot;)
  }

  // print logs
  hash := genSha1(img)
  log.Printf(&quot;✅ received image-%d hash %v, img_size=%d \n&quot;, atomic.AddUint64(&amp;counter, 1), hash, len(img))

  return 0x11, nil
}

// genSha1 generate the hash value of the image
func genSha1(buf []byte) string {
  h := sha1.New()
  h.Write(buf)
  return fmt.Sprintf(&quot;%x&quot;, h.Sum(nil))
}

// initVM initialize WasmEdge's VM
func initVM() (*wasmedge.Configure, *wasmedge.VM) {
  wasmedge.SetLogErrorLevel()
  // Set Tensorflow not to print debug info
  os.Setenv(&quot;TF_CPP_MIN_LOG_LEVEL&quot;, &quot;3&quot;)
  os.Setenv(&quot;TF_CPP_MIN_VLOG_LEVEL&quot;, &quot;3&quot;)

  // Create configure
  vmConf := wasmedge.NewConfigure(wasmedge.WASI)

  // Create VM with configure
  vm := wasmedge.NewVMWithConfig(vmConf)

  // Init WASI
  var wasi = vm.GetImportObject(wasmedge.WASI)
  wasi.InitWasi(
    os.Args[1:],     // The args
    os.Environ(),    // The envs
    []string{&quot;.:.&quot;}, // The mapping directories
  )

  // Register WasmEdge-tensorflow and WasmEdge-image
  var tfobj = wasmedge.NewTensorflowImportObject()
  var tfliteobj = wasmedge.NewTensorflowLiteImportObject()
  vm.RegisterImport(tfobj)
  vm.RegisterImport(tfliteobj)
  var imgobj = wasmedge.NewImageImportObject()
  vm.RegisterImport(imgobj)

  // Instantiate wasm
  vm.LoadWasmFile(&quot;rust_mobilenet_food_lib.so&quot;)
  vm.Validate()

  return vmConf, vm
}
</code></pre>
<h2 id="in-action"><a class="header" href="#in-action">In action</a></h2>
<p>Finally, we can start YoMo and see the entire data processing pipeline in action. Start the YoMo CLI application from the project folder. The <a href="https://github.com/yomorun/yomo-wasmedge-tensorflow/blob/main/zipper/workflow.yaml">yaml file</a> defines port YoMo should listen on and the workflow handler to trigger for incoming data.  Note that the flow name <code>image-recognition</code> matches the name in the aforementioned data handler <a href="https://github.com/yomorun/yomo-wasmedge-tensorflow/blob/main/flow/app.go">app.go</a>.</p>
<pre><code class="language-bash">yomo serve -c ./zipper/workflow.yaml
</code></pre>
<p>Start the handler function by running the aforementioned <a href="https://github.com/yomorun/yomo-wasmedge-tensorflow/blob/main/flow/app.go">app.go</a> program.</p>
<pre><code class="language-bash">cd flow
go run --tags &quot;tensorflow image&quot; app.go
</code></pre>
<p><a href="https://github.com/yomorun/yomo-wasmedge-tensorflow/blob/main/source/main.go">Start a simulated data source</a> by sending a video to YoMo. The video is a series of image frames. The WasmEdge function in <a href="https://github.com/yomorun/yomo-wasmedge-tensorflow/blob/main/flow/app.go">app.go</a> will be invoked against every image frame in the video.</p>
<pre><code class="language-bash"># Download a video file
wget -P source 'https://github.com/yomorun/yomo-wasmedge-tensorflow/releases/download/v0.1.0/hot-dog.mp4'

# Stream the video to YoMo
go run ./source/main.go ./source/hot-dog.mp4
</code></pre>
<p>You can see the output from the WasmEdge handler function in the console. It prints the names of the objects detected in each image frame in the video.</p>
<h2 id="whats-next"><a class="header" href="#whats-next">What's next</a></h2>
<p>In this article, we have seen how to use the WasmEdge Tensorflow API and Golang SDK in YoMo framework to process an image stream in near real-time.</p>
<p>In collaboration with YoMo, we will soon deploy WasmEdge in production in smart factories for a variety of assembly line tasks. WasmEdge is the software runtime for edge computing!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="reactr"><a class="header" href="#reactr">Reactr</a></h1>
<p><a href="https://github.com/suborbital/reactr">Reactr</a> is a fast, performant function scheduling library written in Go. Reactr is designed to be flexible, with the ability to run embedded in your Go applications and first-class support for WebAssembly.
Taking advantage of Go's superior concurrency capabilities, Reactr can manage and execute hundreds of WebAssembly runtime instances all at once, making a great framework for server-side applications.</p>
<p>Reactr allows you to run WebAssembly functions in Go. But so does the <a href="frameworks/app/../../embed/go.html">WasmEdge Go SDK</a>.
The unique feature of Reactr is that it provides a rich set of host functions in Go, which support access to networks and databases etc. Reactr then provides Rust (and Swift / AssemblyScript) APIs to call those host functions from within the WebAssembly function.</p>
<p>In this article, we will show you how to use WasmEdge together with Reactr to take advantage of the best of both worlds. WasmEdge is the
<a href="frameworks/app/../../intro/features.html">fastest and most extensible WebAssembly runtime</a>.
It is also the fastest in <a href="https://github.com/suborbital/reactr/runs/4476074960?check_suite_focus=true">Reactr's official test suite</a>.
We will show you how to run Rust functions compiled to WebAssembly as well as JavaScript programs in WasmEdge and Reactr.</p>
<blockquote>
<p>WasmEdge provides <a href="frameworks/app/../../dev/js.html">advanced support for JavaScript</a> including <a href="frameworks/app/../../dev/js/rust.html">mixing Rust with JavaScript</a> for improved performance.</p>
</blockquote>
<ul>
<li><a href="frameworks/app/reactr.html#hello-world">Hello world</a></li>
<li><a href="frameworks/app/reactr.html#database-query">Database query</a></li>
<li><a href="frameworks/app/reactr.html#embed-javascript-in-go">Embed JavaScript in Go</a></li>
</ul>
<h2 id="prerequisites-4"><a class="header" href="#prerequisites-4">Prerequisites</a></h2>
<p>You need have <a href="https://www.rust-lang.org/tools/install">Rust</a>, <a href="https://go.dev/doc/install">Go</a>, and <a href="frameworks/app/../../start/install.html">WasmEdge</a> installed on your system.
The GCC compiler (installed via the <code>build-essential</code> package) is also needed for WasmEdge.</p>
<pre><code class="language-bash">sudo apt-get update
sudo apt-get -y upgrade
sudo apt install build-essential

curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh
source $HOME/.cargo/env
rustup target add wasm32-wasi

curl -OL https://golang.org/dl/go1.17.5.linux-amd64.tar.gz
sudo tar -C /usr/local -xvf go1.17.5.linux-amd64.tar.gz
export PATH=$PATH:/usr/local/go/bin

wget -qO- https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/utils/install.sh | bash
source $HOME/.wasmedge/env
</code></pre>
<h2 id="hello-world-4"><a class="header" href="#hello-world-4">Hello world</a></h2>
<p>A simple <code>hello world</code> example for Reactr is <a href="https://github.com/second-state/wasm-learning/tree/master/reactr/hello">available here</a>.</p>
<h3 id="hello-world-rust-function-compiled-to-webassembly"><a class="header" href="#hello-world-rust-function-compiled-to-webassembly">Hello world: Rust function compiled to WebAssembly</a></h3>
<p>Let's first create <a href="https://github.com/second-state/wasm-learning/blob/master/reactr/hello/hello-echo/src/lib.rs">a simple Rust function</a> to echo hello.
The Rust function <code>HelloEcho::run()</code> is as follows. It will be exposed to the Go host application through Reactr.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use suborbital::runnable::*;

struct HelloEcho{}

impl Runnable for HelloEcho {
  fn run(&amp;self, input: Vec&lt;u8&gt;) -&gt; Result&lt;Vec&lt;u8&gt;, RunErr&gt; {
    let in_string = String::from_utf8(input).unwrap();
    Ok(format!(&quot;hello {}&quot;, in_string).as_bytes().to_vec())
  }
}
<span class="boring">}
</span></code></pre></pre>
<p>Let's build the Rust function into a WebAssembly bytecode file.</p>
<pre><code class="language-bash">cd hello-echo
cargo build --target wasm32-wasi --release
cp target/wasm32-wasi/release/hello_echo.wasm ..
cd ..
</code></pre>
<h3 id="hello-world-go-host-application"><a class="header" href="#hello-world-go-host-application">Hello world: Go host application</a></h3>
<p>Next, lets look into the <a href="https://github.com/second-state/wasm-learning/blob/master/reactr/hello/main.go">Go host app</a> that executes the WebAssembly functions.
The <code>runBundle()</code> function executes the <code>run()</code> function in the <code>Runnable</code> struct once.</p>
<pre><code class="language-go">func runBundle() {
  r := rt.New()
  doWasm := r.Register(&quot;hello-echo&quot;, rwasm.NewRunner(&quot;./hello_echo.wasm&quot;))

  res, err := doWasm([]byte(&quot;wasmWorker!&quot;)).Then()
  if err != nil {
    fmt.Println(err)
    return
  }

  fmt.Println(string(res.([]byte)))
}
</code></pre>
<p>The <code>runGroup()</code> function executes the Rust-compiled WebAssembly <code>run()</code> function multiple times asynchronously in a group, and receives the results as they come in.</p>
<pre><code class="language-go">func runGroup() {
  r := rt.New()

  doWasm := r.Register(&quot;hello-echo&quot;, rwasm.NewRunner(&quot;./hello_echo.wasm&quot;))

  grp := rt.NewGroup()
  for i := 0; i &lt; 100000; i++ {
    grp.Add(doWasm([]byte(fmt.Sprintf(&quot;world %d&quot;, i))))
  }

  if err := grp.Wait(); err != nil {
    fmt.Println(err)
  }
}
</code></pre>
<p>Finally, let's run the Go host application and see the results printed to the console.</p>
<blockquote>
<p>You must use the <code>-tags wasmedge</code> flag to take advantage of the performance and extended WebAssembly APIs provided by WasmEdge.</p>
</blockquote>
<pre><code class="language-bash">go mod tidy
go run -tags wasmedge main.go
</code></pre>
<h2 id="database-query"><a class="header" href="#database-query">Database query</a></h2>
<p>In <a href="https://github.com/second-state/wasm-learning/tree/master/reactr/db">this example</a>, we will demonstrate how to use Reactr host functions and APIs to query a PostgreSQL database from your WebAssembly function.</p>
<h3 id="database-query-install-and-set-up-a-postgresql-database"><a class="header" href="#database-query-install-and-set-up-a-postgresql-database">Database query: Install and set up a PostgreSQL database</a></h3>
<p>We will start a PostgreSQL instance through Docker.</p>
<pre><code class="language-bash">docker pull postgres
docker run --name reactr-postgres -p 5432:5432 -e POSTGRES_PASSWORD=12345 -d postgres
</code></pre>
<p>Next, let's create a database and populate it with some sample data.</p>
<pre><code class="language-bash">$ docker run -it --rm --network host postgres psql -h 127.0.0.1 -U postgres
postgres=# CREATE DATABASE reactr;
postgres=# \c reactr;

# Create a table:
postgres=# CREATE TABLE users (
    uuid        varchar(100) CONSTRAINT firstkey PRIMARY KEY,
    email       varchar(50) NOT NULL,
    created_at  date,
    state       char(1),
    identifier  integer
);
</code></pre>
<p>Leave this running and start another terminal window to interact with this PostgreSQL server.</p>
<h3 id="database-query-rust-function-compiled-to-webassembly"><a class="header" href="#database-query-rust-function-compiled-to-webassembly">Database query: Rust function compiled to WebAssembly</a></h3>
<p>Let's create <a href="https://github.com/second-state/wasm-learning/blob/master/reactr/db/rs-db/src/lib.rs">a Rust function</a> to access the PostgreSQL database.
The Rust function <code>RsDbtest::run()</code> is as follows. It will be exposed to the Go host application through Reactr. It uses named queries such as <code>PGInsertUser</code> and <code>PGSelectUserWithUUID</code> to operate the database. Those queries are defined in the Go host application, and we will see them later.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use suborbital::runnable::*;
use suborbital::db;
use suborbital::util;
use suborbital::db::query;
use suborbital::log;
use uuid::Uuid;

struct RsDbtest{}

impl Runnable for RsDbtest {
  fn run(&amp;self, _: Vec&lt;u8&gt;) -&gt; Result&lt;Vec&lt;u8&gt;, RunErr&gt; {
    let uuid = Uuid::new_v4().to_string();

    let mut args: Vec&lt;query::QueryArg&gt; = Vec::new();
    args.push(query::QueryArg::new(&quot;uuid&quot;, uuid.as_str()));
    args.push(query::QueryArg::new(&quot;email&quot;, &quot;connor@suborbital.dev&quot;));

    match db::insert(&quot;PGInsertUser&quot;, args) {
      Ok(_) =&gt; log::info(&quot;insert successful&quot;),
      Err(e) =&gt; {
        return Err(RunErr::new(500, e.message.as_str()))
      }
    };

    let mut args2: Vec&lt;query::QueryArg&gt; = Vec::new();
    args2.push(query::QueryArg::new(&quot;uuid&quot;, uuid.as_str()));

    match db::update(&quot;PGUpdateUserWithUUID&quot;, args2.clone()) {
      Ok(rows) =&gt; log::info(format!(&quot;update: {}&quot;, util::to_string(rows).as_str()).as_str()),
      Err(e) =&gt; {
        return Err(RunErr::new(500, e.message.as_str()))
      }
    }

    match db::select(&quot;PGSelectUserWithUUID&quot;, args2.clone()) {
      Ok(result) =&gt; log::info(format!(&quot;select: {}&quot;, util::to_string(result).as_str()).as_str()),
      Err(e) =&gt; {
        return Err(RunErr::new(500, e.message.as_str()))
      }
    }

    match db::delete(&quot;PGDeleteUserWithUUID&quot;, args2.clone()) {
      Ok(rows) =&gt; log::info(format!(&quot;delete: {}&quot;, util::to_string(rows).as_str()).as_str()),
      Err(e) =&gt; {
        return Err(RunErr::new(500, e.message.as_str()))
      }
    }

    ... ...
  }
}
<span class="boring">}
</span></code></pre></pre>
<p>Let's build the Rust function into a WebAssembly bytecode file.</p>
<pre><code class="language-bash">cd rs-db
cargo build --target wasm32-wasi --release
cp target/wasm32-wasi/release/rs_db.wasm ..
cd ..
</code></pre>
<h3 id="database-query-go-host-application"><a class="header" href="#database-query-go-host-application">Database query: Go host application</a></h3>
<p>The <a href="https://github.com/second-state/wasm-learning/blob/master/reactr/db/main.go">Go host app</a> first defines the SQL queries and gives each of them a name.
We will then pass those queries to the Reactr runtime as a configuration.</p>
<pre><code class="language-go">func main() {
  dbConnString, exists := os.LookupEnv(&quot;REACTR_DB_CONN_STRING&quot;)
  if !exists {
    fmt.Println(&quot;skipping as conn string env var not set&quot;)
    return
  }

  q1 := rcap.Query{
    Type:     rcap.QueryTypeInsert,
    Name:     &quot;PGInsertUser&quot;,
    VarCount: 2,
    Query: `
    INSERT INTO users (uuid, email, created_at, state, identifier)
    VALUES ($1, $2, NOW(), 'A', 12345)`,
  }

  q2 := rcap.Query{
    Type:     rcap.QueryTypeSelect,
    Name:     &quot;PGSelectUserWithUUID&quot;,
    VarCount: 1,
    Query: `
    SELECT * FROM users
    WHERE uuid = $1`,
  }

  q3 := rcap.Query{
    Type:     rcap.QueryTypeUpdate,
    Name:     &quot;PGUpdateUserWithUUID&quot;,
    VarCount: 1,
    Query: `
    UPDATE users SET state='B' WHERE uuid = $1`,
  }

  q4 := rcap.Query{
    Type:     rcap.QueryTypeDelete,
    Name:     &quot;PGDeleteUserWithUUID&quot;,
    VarCount: 1,
    Query: `
    DELETE FROM users WHERE uuid = $1`,
  }

  config := rcap.DefaultConfigWithDB(vlog.Default(), rcap.DBTypePostgres, dbConnString, []rcap.Query{q1, q2, q3, q4})

  r, err := rt.NewWithConfig(config)
  if err != nil {
    fmt.Println(err)
    return
  }

  ... ...
}
</code></pre>
<p>Then, we can run the WebAssembly function from Reactr.</p>
<pre><code class="language-go">func main() {
  ... ...

  doWasm := r.Register(&quot;rs-db&quot;, rwasm.NewRunner(&quot;./rs_db.wasm&quot;))

  res, err := doWasm(nil).Then()
  if err != nil {
    fmt.Println(err)
    return
  }

  fmt.Println(string(res.([]byte)))
}
</code></pre>
<p>Finally, let's run the Go host application and see the results printed to the console.</p>
<blockquote>
<p>You must use the <code>-tags wasmedge</code> flag to take advantage of the performance and extended WebAssembly APIs provided by WasmEdge.</p>
</blockquote>
<pre><code class="language-bash">export REACTR_DB_CONN_STRING='postgresql://postgres:12345@127.0.0.1:5432/reactr'
go mod tidy
go run -tags wasmedge main.go
</code></pre>
<h2 id="embed-javascript-in-go"><a class="header" href="#embed-javascript-in-go">Embed JavaScript in Go</a></h2>
<p>As we mentioned, a key feature of the WasmEdge Runtime is its advanced <a href="frameworks/app/../../dev/js.html">JavaScript support</a>, which allows JavaScript programs to run in lightweight, high-performance, safe, multi-language, and <a href="frameworks/app/../../kubernetes.html">Kubernetes-managed WasmEdge containers</a>.
A simple example of embedded JavaScript function in Reactr is <a href="https://github.com/second-state/wasm-learning/tree/master/reactr/quickjs">available here</a>.</p>
<h3 id="javascript-example"><a class="header" href="#javascript-example">JavaScript example</a></h3>
<p>The <a href="https://github.com/second-state/wasm-learning/tree/master/reactr/quickjs/hello.js">JavaScript example function</a> is very simple. It just returns a string value.</p>
<pre><code class="language-javascript">let h = 'hello';
let w = 'wasmedge';
`${h} ${w}`;
</code></pre>
<h3 id="javascript-example-go-host-application"><a class="header" href="#javascript-example-go-host-application">JavaScript example: Go host application</a></h3>
<p>The <a href="https://github.com/second-state/wasm-learning/tree/master/reactr/quickjs/main.go">Go host app</a> uses the Reactr API to run WasmEdge's standard JavaScript interpreter <a href="https://github.com/second-state/wasm-learning/blob/master/reactr/quickjs/rs_embed_js.wasm">rs_embed_js.wasm</a>. You can build your own version of JavaScript interpreter by modifying <a href="https://github.com/second-state/wasm-learning/tree/master/reactr/quickjs/rs-embed-js">this Rust project</a>.</p>
<blockquote>
<p>Learn more about how to embed <a href="https://github.com/second-state/wasmedge-quickjs/tree/main/examples/embed_js">JavaScript code in Rust</a>, and how to <a href="frameworks/app/../../dev/js/rust.html">use Rust to implement JavaScript APIs</a> in WasmEdge.</p>
</blockquote>
<p>The Go host application just need to start the job for <code>rs_embed_js.wasm</code> and pass the JavaScript content to it. The Go application can then capture and print the return value from JavaScript.</p>
<pre><code class="language-go">func main() {
  r := rt.New()
  doWasm := r.Register(&quot;hello-quickjs&quot;, rwasm.NewRunner(&quot;./rs_embed_js.wasm&quot;))

  code, err := ioutil.ReadFile(os.Args[1])
  if err != nil {
    fmt.Print(err)
  }
  res, err := doWasm(code).Then()
  if err != nil {
    fmt.Println(err)
    return
  }

  fmt.Println(string(res.([]byte)))
}
</code></pre>
<p>Run the Go host application as follows.</p>
<pre><code class="language-bash">$ cd quickjs
$ go mod tidy
$ go run -tags wasmedge main.go hello.js
String(JsString(hello wasmedge))
</code></pre>
<p>The printed result shows the type information of the string in Rust and Go APIs. You can strip out this information by changing the Rust or Go applications.</p>
<h3 id="javascript-example-feature-examples"><a class="header" href="#javascript-example-feature-examples">JavaScript example: Feature examples</a></h3>
<p>WasmEdge supports many advanced JavaScript features. For the next step, you could try our <a href="https://github.com/second-state/wasmedge-quickjs/tree/main/example_js/react_ssr">React SSR example</a> to generate an HTML UI from a Reactr function!
You can just build the <code>dist/main.js</code> from the React SSR example, and copy it over to this example folder to see it in action!</p>
<pre><code class="language-bash">$ cd quickjs
# copy over the dist/main.js file from the react ssr example
$ go mod tidy
$ go run -tags wasmedge main.go main.js
&lt;div data-reactroot=&quot;&quot;&gt;&lt;div&gt;This is home&lt;/div&gt;&lt;div&gt;&lt;div&gt;This is page&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;
UnDefined
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="serverless-platforms"><a class="header" href="#serverless-platforms">Serverless platforms</a></h1>
<p>Our vision for the future is to run WebAssembly as an alternative lightweight runtime side-by-side with Docker and microVMs in cloud native infrastructure. WebAssembly offers much higher performance and consumes much less resources than Docker-like containers or microVMs. However, the public cloud only supports running WebAssembly inside a microVM. Nonetheless, running WebAssembly functions inside a microVM still offers many advantages over running containerized NaCl programs.</p>
<p>Running WebAssembly functions inside Docker-like containers offer advantages over running NaCl programs directly in Docker.</p>
<p>For starters, WebAssembly provides fine-grained runtime isolation for individual functions. A microservice could have multiple functions and support services running inside a Docker-like container. WebAssembly can make the microservice more secure and more stable.</p>
<p>Second, the WebAssembly bytecode is portable. Developers only need to build it once and do not need to worry about changes or updates to the underlying Vercel serverless container (OS and hardware). It also allows developers to reuse the same WebAssembly functions in other cloud environments.</p>
<p>Third, WebAssembly apps are easy to deploy and manage. They have much less platform dependencies and complexities compared with NaCl dynamic libraries and executables.</p>
<p>Finally, the <a href="https://www.secondstate.io/articles/wasi-tensorflow/">WasmEdge Tensorflow API</a> provides the most ergonomic way to execute Tensorflow models in the Rust programming language. WasmEdge installs the correct combination of Tensorflow dependency libraries, and provides a unified API for developers.</p>
<p>In this section, we will show you how to run WebAssembly serverless functions in public clouds. Each platform has its own code template and contains two examples in Rust, one is the normal image processing, The other one is TensorFlow inference using the WasmEdge TensorFlow SDK.</p>
<ul>
<li><a href="frameworks/serverless/vercel.html">Vercel</a> discuss how to leverage WasmEdge to accelerate the Jamstack application deployed on Vercel.</li>
<li><a href="frameworks/serverless/netlify.html">Netlify</a> discuss how to leverage WasmEdge to accelerate the Jamstack application deployed on Netlify.</li>
<li><a href="frameworks/serverless/aws.html">AWS Lambda</a> discuss how to leverage WasmEdge to accelerate the serverless functions deployed on AWS Lambda.</li>
<li><a href="frameworks/serverless/tencent.html">Tencent</a> discuss how to leverage WasmEdge to accelerate the serverless functions deployed on Tencent cloud.</li>
</ul>
<blockquote>
<p>If you would like to add more WasmEdge examples on public cloud platform,like Google Cloud Functions, feel free to create a PR for WasmEdge and let the community know what you did.</p>
</blockquote>
<p><img src="frameworks/serverless-wasmedge.png" alt="serverless-wasmedge.png" /></p>
<p>Running WasmEdge from Docker containers deployed on public cloud is an easy way to add high-performance functions to web applications. Going forward an even better approach is to use <a href="https://www.computer.org/csdl/magazine/so/5555/01/09214403/1nHNGfu2Ypi">WasmEdge as the container itself</a>. There will be no Docker and no Node.js to bootstrap WasmEdge. This way, we can reach much higher efficiency for running serverless functions.</p>
<ul>
<li><a href="frameworks/serverless/secondstate.html">Second State Functions</a> will discuss how to use WasmEdge ad the container itself, since Second State Functions is a serverless platform with pure WebAssembly/WasmEdge.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rust-and-webassembly-serverless-functions-in-vercel"><a class="header" href="#rust-and-webassembly-serverless-functions-in-vercel">Rust and WebAssembly Serverless functions in Vercel</a></h1>
<p>In this article, we will show you two serverless functions in Rust and WasmEdge deployed on Vercel. One is the image processing function, the other one is the TensorFlow inference function.</p>
<blockquote>
<p>For more insights on why WasmEdge on Vercel, please refer to the article <a href="https://www.secondstate.io/articles/vercel-wasmedge-webassembly-rust/">Rust and WebAssembly Serverless Functions in Vercel</a>.</p>
</blockquote>
<h2 id="prerequisite-3"><a class="header" href="#prerequisite-3">Prerequisite</a></h2>
<p>Since our demo WebAssembly functions are written in Rust, you will need a <a href="https://www.rust-lang.org/tools/install">Rust compiler</a>. Make sure that you install the <code>wasm32-wasi</code> compiler target as follows, in order to generate WebAssembly bytecode.</p>
<pre><code class="language-bash">rustup target add wasm32-wasi
</code></pre>
<p>The demo application front end is written in <a href="https://nextjs.org/">Next.js</a>, and deployed on Vercel. We will assume that you already have the basic knowledge of how to work with Vercel.</p>
<h2 id="example-1-image-processing"><a class="header" href="#example-1-image-processing">Example 1: Image processing</a></h2>
<p>Our first demo application allows users to upload an image and then invoke a serverless function to turn it into black and white. A <a href="https://vercel-wasm-runtime.vercel.app/">live demo</a> deployed on Vercel is available.</p>
<p>Fork the <a href="https://github.com/second-state/vercel-wasm-runtime">demo application’s GitHub repo</a> to get started. To deploy the application on Vercel, just <a href="https://vercel.com/docs/git#deploying-a-git-repository">import the Github repo</a> from <a href="https://vercel.com/docs/git/vercel-for-github">Vercel for Github</a> web page.</p>
<p>This repo is a standard Next.js application for the Vercel platform. The backend serverless function is in the <a href="https://github.com/second-state/vercel-wasm-runtime/tree/main/api/functions/image-grayscale"><code>api/functions/image_grayscale</code></a> folder. The <a href="https://github.com/second-state/vercel-wasm-runtime/blob/main/api/functions/image-grayscale/src/main.rs"><code>src/main.rs</code></a> file contains the Rust program’s source code. The Rust program reads image data from the <code>STDIN</code>, and then outputs the black-white image to the <code>STDOUT</code>.</p>
<pre><pre class="playground"><code class="language-rust">use hex;
use std::io::{self, Read};
use image::{ImageOutputFormat, ImageFormat};

fn main() {
  let mut buf = Vec::new();
  io::stdin().read_to_end(&amp;mut buf).unwrap();

  let image_format_detected: ImageFormat = image::guess_format(&amp;buf).unwrap();
  let img = image::load_from_memory(&amp;buf).unwrap();
  let filtered = img.grayscale();
  let mut buf = vec![];
  match image_format_detected {
    ImageFormat::Gif =&gt; {
      filtered.write_to(&amp;mut buf, ImageOutputFormat::Gif).unwrap();
    },
    _ =&gt; {
      filtered.write_to(&amp;mut buf, ImageOutputFormat::Png).unwrap();
    },
  };
  io::stdout().write_all(&amp;buf).unwrap();
  io::stdout().flush().unwrap();
}
</code></pre></pre>
<p>You can use Rust’s <code>cargo</code> tool to build the Rust program into WebAssembly bytecode or native code.</p>
<pre><code class="language-bash">cd api/functions/image-grayscale/
cargo build --release --target wasm32-wasi 
</code></pre>
<p>Copy the build artifacts to the <code>api</code> folder.</p>
<pre><code class="language-bash">cp target/wasm32-wasi/release/grayscale.wasm ../../
</code></pre>
<blockquote>
<p>Vercel runs <a href="https://github.com/second-state/vercel-wasm-runtime/blob/main/api/pre.sh"><code>api/pre.sh</code></a> upon setting up the serverless environment. It installs the WasmEdge runtime, and then compiles each WebAssembly bytecode program into a native <code>so</code> library for faster execution.</p>
</blockquote>
<p>The <a href="https://github.com/second-state/vercel-wasm-runtime/blob/main/api/hello.js"><code>api/hello.js</code></a> file conforms Vercel serverless specification. It loads the WasmEdge runtime, starts the compiled WebAssembly program in WasmEdge, and passes the uploaded image data via <code>STDIN</code>. Notice <a href="https://github.com/second-state/vercel-wasm-runtime/blob/main/api/hello.js"><code>api/hello.js</code></a> runs the compiled <code>grayscale.so</code> file generated by <a href="https://github.com/second-state/vercel-wasm-runtime/blob/main/api/pre.sh"><code>api/pre.sh</code></a> for better performance.</p>
<pre><code class="language-javascript">const fs = require('fs');
const { spawn } = require('child_process');
const path = require('path');

module.exports = (req, res) =&gt; {
  const wasmedge = spawn(
      path.join(__dirname, 'wasmedge'), 
      [path.join(__dirname, 'grayscale.so')]);

  let d = [];
  wasmedge.stdout.on('data', (data) =&gt; {
    d.push(data);
  });

  wasmedge.on('close', (code) =&gt; {
    let buf = Buffer.concat(d);

    res.setHeader('Content-Type', req.headers['image-type']);
    res.send(buf);
  });

  wasmedge.stdin.write(req.body);
  wasmedge.stdin.end('');
}
</code></pre>
<p>That's it. <a href="https://vercel.com/docs/git#deploying-a-git-repository">Deploy the repo to Vercel</a> and you now have a Vercel Jamstack app with a high-performance Rust and WebAssembly based serverless backend.</p>
<h2 id="example-2-ai-inference"><a class="header" href="#example-2-ai-inference">Example 2: AI inference</a></h2>
<p>The <a href="https://vercel-wasm-runtime-cozpr5z84-wangshishuo1.vercel.app/">second demo</a> application allows users to upload an image and then invoke a serverless function to classify the main subject on the image.</p>
<p>It is in <a href="https://github.com/second-state/vercel-wasm-runtime">the same GitHub repo</a> as the previous example but in the <code>tensorflow</code> branch. Note: when you <a href="https://vercel.com/docs/git#deploying-a-git-repository">import this GitHub repo</a> on the Vercel website, it will create a <a href="https://vercel.com/docs/platform/deployments#preview">preview URL</a> for each branch. The <code>tensorflow</code> branch would have its own deployment URL.</p>
<p>The backend serverless function for image classification is in the <a href="https://github.com/second-state/vercel-wasm-runtime/tree/tensorflow/api/functions/image-classification"><code>api/functions/image-classification</code></a> folder in the <code>tensorflow</code> branch.  The <a href="https://github.com/second-state/vercel-wasm-runtime/blob/tensorflow/api/functions/image-classification/src/main.rs"><code>src/main.rs</code></a> file contains the Rust program’s source code. The Rust program reads image data from the <code>STDIN</code>, and then outputs the text output to the <code>STDOUT</code>. It utilizes the WasmEdge Tensorflow API to run the AI inference.</p>
<pre><pre class="playground"><code class="language-rust">pub fn main() {
  // Step 1: Load the TFLite model
  let model_data: &amp;[u8] = include_bytes!(&quot;models/mobilenet_v1_1.0_224/mobilenet_v1_1.0_224_quant.tflite&quot;);
  let labels = include_str!(&quot;models/mobilenet_v1_1.0_224/labels_mobilenet_quant_v1_224.txt&quot;);

  // Step 2: Read image from STDIN
  let mut buf = Vec::new();
  io::stdin().read_to_end(&amp;mut buf).unwrap();

  // Step 3: Resize the input image for the tensorflow model
  let flat_img = wasmedge_tensorflow_interface::load_jpg_image_to_rgb8(&amp;buf, 224, 224);

  // Step 4: AI inference
  let mut session = wasmedge_tensorflow_interface::Session::new(&amp;model_data, wasmedge_tensorflow_interface::ModelType::TensorFlowLite);
  session.add_input(&quot;input&quot;, &amp;flat_img, &amp;[1, 224, 224, 3])
         .run();
  let res_vec: Vec&lt;u8&gt; = session.get_output(&quot;MobilenetV1/Predictions/Reshape_1&quot;);

  // Step 5: Find the food label that responds to the highest probability in res_vec
  // ... ...
  let mut label_lines = labels.lines();
  for _i in 0..max_index {
    label_lines.next();
  }

  // Step 6: Generate the output text
  let class_name = label_lines.next().unwrap().to_string();
  if max_value &gt; 50 {
    println!(&quot;It {} a &lt;a href='https://www.google.com/search?q={}'&gt;{}&lt;/a&gt; in the picture&quot;, confidence.to_string(), class_name, class_name);
  } else {
    println!(&quot;It does not appears to be any food item in the picture.&quot;);
  }
}
</code></pre></pre>
<p>You can use the <code>cargo</code> tool to build the Rust program into WebAssembly bytecode or native code.</p>
<pre><code class="language-bash">cd api/functions/image-classification/
cargo build --release --target wasm32-wasi
</code></pre>
<p>Copy the build artifacts to the <code>api</code> folder.</p>
<pre><code class="language-bash">cp target/wasm32-wasi/release/classify.wasm ../../
</code></pre>
<p>Again, the <a href="https://github.com/second-state/vercel-wasm-runtime/blob/tensorflow/api/pre.sh"><code>api/pre.sh</code></a> script installs WasmEdge runtime and its Tensorflow dependencies in this application. It also compiles the <code>classify.wasm</code> bytecode program to the <code>classify.so</code> native shared library at the time of deployment.</p>
<p>The <a href="https://github.com/second-state/vercel-wasm-runtime/blob/tensorflow/api/hello.js"><code>api/hello.js</code></a> file conforms Vercel serverless specification. It loads the WasmEdge runtime, starts the compiled WebAssembly program in WasmEdge, and passes the uploaded image data via <code>STDIN</code>. Notice <a href="https://github.com/second-state/vercel-wasm-runtime/blob/tensorflow/api/hello.js"><code>api/hello.js</code></a> runs the compiled <code>classify.so</code> file generated by <a href="https://github.com/second-state/vercel-wasm-runtime/blob/tensorflow/api/pre.sh"><code>api/pre.sh</code></a> for better performance.</p>
<pre><code class="language-javascript">const fs = require('fs');
const { spawn } = require('child_process');
const path = require('path');

module.exports = (req, res) =&gt; {
  const wasmedge = spawn(
    path.join(__dirname, 'wasmedge-tensorflow-lite'),
    [path.join(__dirname, 'classify.so')],
    {env: {'LD_LIBRARY_PATH': __dirname}}
  );

  let d = [];
  wasmedge.stdout.on('data', (data) =&gt; {
    d.push(data);
  });

  wasmedge.on('close', (code) =&gt; {
    res.setHeader('Content-Type', `text/plain`);
    res.send(d.join(''));
  });

  wasmedge.stdin.write(req.body);
  wasmedge.stdin.end('');
}
</code></pre>
<p>You can now <a href="https://vercel.com/docs/git#deploying-a-git-repository">deploy your forked repo to Vercel</a> and have a web app for subject classification.</p>
<p>Next, it's your turn to use <a href="https://github.com/second-state/vercel-wasm-runtime">the vercel-wasm-runtime repo</a> as a template to develop your own Rust serverless functions in Vercel. Looking forward to your great work.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="webassembly-serverless-functions-in-netlify"><a class="header" href="#webassembly-serverless-functions-in-netlify">WebAssembly Serverless Functions in Netlify</a></h1>
<p>In this article we will show you two serverless functions in Rust and WasmEdge deployed on Netlify. One is the image processing function, the other one is the TensorFlow inference function.</p>
<blockquote>
<p>For more insights on why WasmEdge on Netlify, please refer to the article <a href="https://www.secondstate.io/articles/netlify-wasmedge-webassembly-rust-serverless/">WebAssembly Serverless Functions in Netlify</a>.</p>
</blockquote>
<h2 id="prerequisite-4"><a class="header" href="#prerequisite-4">Prerequisite</a></h2>
<p>Since our demo WebAssembly functions are written in Rust, you will need a <a href="https://www.rust-lang.org/tools/install">Rust compiler</a>. Make sure that you install the <code>wasm32-wasi</code> compiler target as follows, in order to generate WebAssembly bytecode.</p>
<pre><code class="language-bash">rustup target add wasm32-wasi
</code></pre>
<p>The demo application front end is written in <a href="https://nextjs.org/">Next.js</a>, and deployed on Netlify. We will assume that you already have the basic knowledge of how to work with Next.js and Netlify.</p>
<h2 id="example-1-image-processing-1"><a class="header" href="#example-1-image-processing-1">Example 1: Image processing</a></h2>
<p>Our first demo application allows users to upload an image and then invoke a serverless function to turn it into black and white. A <a href="https://60fe22f9ff623f0007656040--reverent-hodgkin-dc1f51.netlify.app/">live demo</a> deployed on Netlify is available.</p>
<p>Fork the <a href="https://github.com/second-state/netlify-wasm-runtime">demo application’s GitHub repo</a> to get started. To deploy the application on Netlify, just <a href="https://www.netlify.com/blog/2016/09/29/a-step-by-step-guide-deploying-on-netlify/">add your github repo to Netlify</a>.</p>
<p>This repo is a standard Next.js application for the Netlify platform. The backend serverless function is in the <a href="https://github.com/second-state/netlify-wasm-runtime/tree/main/api/functions/image-grayscale"><code>api/functions/image_grayscale</code></a> folder. The <a href="https://github.com/second-state/netlify-wasm-runtime/blob/main/api/functions/image-grayscale/src/main.rs"><code>src/main.rs</code></a> file contains the Rust program’s source code. The Rust program reads image data from the <code>STDIN</code>, and then outputs the black-white image to the <code>STDOUT</code>.</p>
<pre><pre class="playground"><code class="language-rust">use hex;
use std::io::{self, Read};
use image::{ImageOutputFormat, ImageFormat};

fn main() {
  let mut buf = Vec::new();
  io::stdin().read_to_end(&amp;mut buf).unwrap();

  let image_format_detected: ImageFormat = image::guess_format(&amp;buf).unwrap();
  let img = image::load_from_memory(&amp;buf).unwrap();
  let filtered = img.grayscale();
  let mut buf = vec![];
  match image_format_detected {
    ImageFormat::Gif =&gt; {
      filtered.write_to(&amp;mut buf, ImageOutputFormat::Gif).unwrap();
    },
    _ =&gt; {
      filtered.write_to(&amp;mut buf, ImageOutputFormat::Png).unwrap();
    },
  };
  io::stdout().write_all(&amp;buf).unwrap();
  io::stdout().flush().unwrap();
}
</code></pre></pre>
<p>You can use Rust’s <code>cargo</code> tool to build the Rust program into WebAssembly bytecode or native code.</p>
<pre><code class="language-bash">cd api/functions/image-grayscale/
cargo build --release --target wasm32-wasi 
</code></pre>
<p>Copy the build artifacts to the <code>api</code> folder.</p>
<pre><code class="language-bash">cp target/wasm32-wasi/release/grayscale.wasm ../../
</code></pre>
<blockquote>
<p>The Netlify function runs <a href="https://github.com/second-state/netlify-wasm-runtime/blob/main/api/pre.sh"><code>api/pre.sh</code></a> upon setting up the serverless environment. It installs the WasmEdge runtime, and then compiles each WebAssembly bytecode program into a native <code>so</code> library for faster execution.</p>
</blockquote>
<p>The <a href="https://github.com/second-state/netlify-wasm-runtime/blob/main/api/hello.js"><code>api/hello.js</code></a> script loads the WasmEdge runtime, starts the compiled WebAssembly program in WasmEdge, and passes the uploaded image data via <code>STDIN</code>. Notice <a href="https://github.com/second-state/netlify-wasm-runtime/blob/main/api/hello.js"><code>api/hello.js</code></a> runs the compiled <code>grayscale.so</code> file generated by <a href="https://github.com/second-state/netlify-wasm-runtime/blob/main/api/pre.sh"><code>api/pre.sh</code></a> for better performance.</p>
<pre><code class="language-javascript">const fs = require('fs');
const { spawn } = require('child_process');
const path = require('path');

module.exports = (req, res) =&gt; {
  const wasmedge = spawn(
      path.join(__dirname, 'wasmedge'), 
      [path.join(__dirname, 'grayscale.so')]);

  let d = [];
  wasmedge.stdout.on('data', (data) =&gt; {
    d.push(data);
  });

  wasmedge.on('close', (code) =&gt; {
    let buf = Buffer.concat(d);

    res.setHeader('Content-Type', req.headers['image-type']);
    res.send(buf);
  });

  wasmedge.stdin.write(req.body);
  wasmedge.stdin.end('');
}
</code></pre>
<p>That's it. <a href="https://www.netlify.com/blog/2016/09/29/a-step-by-step-guide-deploying-on-netlify/">Deploy the repo to Netlify</a> and you now have a Netlify Jamstack app with a high-performance Rust and WebAssembly based serverless backend.</p>
<h2 id="example-2-ai-inference-1"><a class="header" href="#example-2-ai-inference-1">Example 2: AI inference</a></h2>
<p>The <a href="https://60ff7e2d10fe590008db70a9--reverent-hodgkin-dc1f51.netlify.app/">second demo</a> application allows users to upload an image and then invoke a serverless function to classify the main subject on the image.</p>
<p>It is in <a href="https://github.com/second-state/netlify-wasm-runtime/tree/tensorflow">the same GitHub repo</a> as the previous example but in the <code>tensorflow</code> branch. The backend serverless function for image classification is in the <a href="https://github.com/second-state/netlify-wasm-runtime/tree/tensorflow/api/functions/image-classification"><code>api/functions/image-classification</code></a> folder in the <code>tensorflow</code> branch.  The <a href="https://github.com/second-state/netlify-wasm-runtime/blob/tensorflow/api/functions/image-classification/src/main.rs"><code>src/main.rs</code></a> file contains the Rust program’s source code. The Rust program reads image data from the <code>STDIN</code>, and then outputs the text output to the <code>STDOUT</code>. It utilizes the WasmEdge Tensorflow API to run the AI inference.</p>
<pre><pre class="playground"><code class="language-rust">pub fn main() {
  // Step 1: Load the TFLite model
  let model_data: &amp;[u8] = include_bytes!(&quot;models/mobilenet_v1_1.0_224/mobilenet_v1_1.0_224_quant.tflite&quot;);
  let labels = include_str!(&quot;models/mobilenet_v1_1.0_224/labels_mobilenet_quant_v1_224.txt&quot;);

  // Step 2: Read image from STDIN
  let mut buf = Vec::new();
  io::stdin().read_to_end(&amp;mut buf).unwrap();

  // Step 3: Resize the input image for the tensorflow model
  let flat_img = wasmedge_tensorflow_interface::load_jpg_image_to_rgb8(&amp;buf, 224, 224);

  // Step 4: AI inference
  let mut session = wasmedge_tensorflow_interface::Session::new(&amp;model_data, wasmedge_tensorflow_interface::ModelType::TensorFlowLite);
  session.add_input(&quot;input&quot;, &amp;flat_img, &amp;[1, 224, 224, 3])
         .run();
  let res_vec: Vec&lt;u8&gt; = session.get_output(&quot;MobilenetV1/Predictions/Reshape_1&quot;);

  // Step 5: Find the food label that responds to the highest probability in res_vec
  // ... ...
  let mut label_lines = labels.lines();
  for _i in 0..max_index {
    label_lines.next();
  }

  // Step 6: Generate the output text
  let class_name = label_lines.next().unwrap().to_string();
  if max_value &gt; 50 {
    println!(&quot;It {} a &lt;a href='https://www.google.com/search?q={}'&gt;{}&lt;/a&gt; in the picture&quot;, confidence.to_string(), class_name, class_name);
  } else {
    println!(&quot;It does not appears to be any food item in the picture.&quot;);
  }
}
</code></pre></pre>
<p>You can use the <code>cargo</code> tool to build the Rust program into WebAssembly bytecode or native code.</p>
<pre><code class="language-bash">cd api/functions/image-classification/
cargo build --release --target wasm32-wasi
</code></pre>
<p>Copy the build artifacts to the <code>api</code> folder.</p>
<pre><code class="language-bash">cp target/wasm32-wasi/release/classify.wasm ../../
</code></pre>
<p>Again, the <a href="https://github.com/second-state/netlify-wasm-runtime/blob/tensorflow/api/pre.sh"><code>api/pre.sh</code></a> script installs WasmEdge runtime and its Tensorflow dependencies in this application. It also compiles the <code>classify.wasm</code> bytecode program to the <code>classify.so</code> native shared library at the time of deployment.</p>
<p>The <a href="https://github.com/second-state/netlify-wasm-runtime/blob/tensorflow/api/hello.js"><code>api/hello.js</code></a> script loads the WasmEdge runtime, starts the compiled WebAssembly program in WasmEdge, and passes the uploaded image data via <code>STDIN</code>. Notice <a href="https://github.com/second-state/netlify-wasm-runtime/blob/tensorflow/api/hello.js"><code>api/hello.js</code></a> runs the compiled <code>classify.so</code> file generated by <a href="https://github.com/second-state/netlify-wasm-runtime/blob/tensorflow/api/pre.sh"><code>api/pre.sh</code></a> for better performance.</p>
<pre><code class="language-javascript">const fs = require('fs');
const { spawn } = require('child_process');
const path = require('path');

module.exports = (req, res) =&gt; {
  const wasmedge = spawn(
    path.join(__dirname, 'wasmedge-tensorflow-lite'),
    [path.join(__dirname, 'classify.so')],
    {env: {'LD_LIBRARY_PATH': __dirname}}
  );

  let d = [];
  wasmedge.stdout.on('data', (data) =&gt; {
    d.push(data);
  });

  wasmedge.on('close', (code) =&gt; {
    res.setHeader('Content-Type', `text/plain`);
    res.send(d.join(''));
  });

  wasmedge.stdin.write(req.body);
  wasmedge.stdin.end('');
}
</code></pre>
<p>You can now <a href="https://www.netlify.com/blog/2016/09/29/a-step-by-step-guide-deploying-on-netlify/">deploy your forked repo to Netlify</a> and have a web app for subject classification.</p>
<p>Next, it's your turn to develop Rust serverless functions in Netlify using the <a href="https://github.com/second-state/netlify-wasm-runtime">netlify-wasm-runtime repo</a> as a template. Looking forward to your great work.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="webassembly-serverless-functions-in-aws-lambda"><a class="header" href="#webassembly-serverless-functions-in-aws-lambda">WebAssembly Serverless Functions in AWS Lambda</a></h1>
<p>In this article, we will show you two serverless functions in Rust and WasmEdge deployed on AWS Lambda. One is the image processing function, the other one is the TensorFlow inference function.</p>
<blockquote>
<p>For the insight on why WasmEdge on AWS Lambda, please refer to the article <a href="https://www.secondstate.io/articles/webassembly-serverless-functions-in-aws-lambda/">WebAssembly Serverless Functions in AWS Lambda</a></p>
</blockquote>
<h2 id="prerequisites-5"><a class="header" href="#prerequisites-5">Prerequisites</a></h2>
<p>Since our demo WebAssembly functions are written in Rust, you will need a <a href="https://www.rust-lang.org/tools/install">Rust compiler</a>. Make sure that you install the <code>wasm32-wasi</code> compiler target as follows, in order to generate WebAssembly bytecode.</p>
<pre><code class="language-bash">rustup target add wasm32-wasi
</code></pre>
<p>The demo application front end is written in <a href="https://nextjs.org/">Next.js</a>, and deployed on AWS Lambda. We will assume that you already have the basic knowledge of how to work with Next.js and Lambda.</p>
<h2 id="example-1-image-processing-2"><a class="header" href="#example-1-image-processing-2">Example 1: Image processing</a></h2>
<p>Our first demo application allows users to upload an image and then invoke a serverless function to turn it into black and white. A <a href="https://second-state.github.io/aws-lambda-wasm-runtime/">live demo</a> deployed through GitHub Pages is available.</p>
<p>Fork the <a href="https://github.com/second-state/aws-lambda-wasm-runtime">demo application’s GitHub repo</a> to get started. To deploy the application on AWS Lambda, follow the guide in the repository <a href="https://github.com/second-state/aws-lambda-wasm-runtime/blob/tensorflow/README.md">README</a>.</p>
<h3 id="create-the-function"><a class="header" href="#create-the-function">Create the function</a></h3>
<p>This repo is a standard Next.js application. The backend serverless function is in the <code>api/functions/image_grayscale</code> folder. The <code>src/main.rs</code> file contains the Rust program’s source code. The Rust program reads image data from the <code>STDIN</code>, and then outputs the black-white image to the <code>STDOUT</code>.</p>
<pre><pre class="playground"><code class="language-rust">use hex;
use std::io::{self, Read};
use image::{ImageOutputFormat, ImageFormat};

fn main() {
  let mut buf = Vec::new();
  io::stdin().read_to_end(&amp;mut buf).unwrap();

  let image_format_detected: ImageFormat = image::guess_format(&amp;buf).unwrap();
  let img = image::load_from_memory(&amp;buf).unwrap();
  let filtered = img.grayscale();
  let mut buf = vec![];
  match image_format_detected {
    ImageFormat::Gif =&gt; {
      filtered.write_to(&amp;mut buf, ImageOutputFormat::Gif).unwrap();
    },
    _ =&gt; {
      filtered.write_to(&amp;mut buf, ImageOutputFormat::Png).unwrap();
    },
  };
  io::stdout().write_all(&amp;buf).unwrap();
  io::stdout().flush().unwrap();
}
</code></pre></pre>
<p>You can use Rust’s <code>cargo</code> tool to build the Rust program into WebAssembly bytecode or native code.</p>
<pre><code class="language-bash">cd api/functions/image-grayscale/
cargo build --release --target wasm32-wasi 
</code></pre>
<p>Copy the build artifacts to the <code>api</code> folder.</p>
<pre><code class="language-bash">cp target/wasm32-wasi/release/grayscale.wasm ../../
</code></pre>
<blockquote>
<p>When we build the docker image, <code>api/pre.sh</code> is executed. <code>pre.sh</code> installs the WasmEdge runtime, and then compiles each WebAssembly bytecode program into a native <code>so</code> library for faster execution.</p>
</blockquote>
<h3 id="create-the-service-script-to-load-the-function"><a class="header" href="#create-the-service-script-to-load-the-function">Create the service script to load the function</a></h3>
<p>The <a href="https://github.com/second-state/aws-lambda-wasm-runtime/blob/main/api/hello.js"><code>api/hello.js</code></a> script loads the WasmEdge runtime, starts the compiled WebAssembly program in WasmEdge, and passes the uploaded image data via <code>STDIN</code>. Notice that <a href="https://github.com/second-state/aws-lambda-wasm-runtime/blob/main/api/hello.js"><code>api/hello.js</code></a> runs the compiled <code>grayscale.so</code> file generated by <a href="https://github.com/second-state/aws-lambda-wasm-runtime/blob/main/api/pre.sh"><code>api/pre.sh</code></a> for better performance.</p>
<pre><code class="language-javascript">const { spawn } = require('child_process');
const path = require('path');

function _runWasm(reqBody) {
  return new Promise(resolve =&gt; {
    const wasmedge = spawn(path.join(__dirname, 'wasmedge'), [path.join(__dirname, 'grayscale.so')]);

    let d = [];
    wasmedge.stdout.on('data', (data) =&gt; {
      d.push(data);
    });

    wasmedge.on('close', (code) =&gt; {
      let buf = Buffer.concat(d);
      resolve(buf);
    });

    wasmedge.stdin.write(reqBody);
    wasmedge.stdin.end('');
  });
}
</code></pre>
<p>The <code>exports.handler</code> part of <code>hello.js</code> exports an async function handler, used to handle different events every time the serverless function is called. In this example, we simply process the image by calling the function above and return the result, but more complicated event-handling behavior may be defined based on your need. We also need to return some <code>Access-Control-Allow</code> headers to avoid <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS">Cross-Origin Resource Sharing (CORS)</a> errors when calling the serverless function from a browser. You can read more about CORS errors <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS/Errors">here</a> if you encounter them when replicating our example.</p>
<pre><code class="language-javascript">exports.handler = async function(event, context) {
  var typedArray = new Uint8Array(event.body.match(/[\da-f]{2}/gi).map(function (h) {
    return parseInt(h, 16);
  }));
  let buf = await _runWasm(typedArray);
  return {
    statusCode: 200,
    headers: {
      &quot;Access-Control-Allow-Headers&quot; : &quot;Content-Type,X-Amz-Date,Authorization,X-Api-Key,X-Amz-Security-Token&quot;,
      &quot;Access-Control-Allow-Origin&quot;: &quot;*&quot;,
      &quot;Access-Control-Allow-Methods&quot;: &quot;DELETE, GET, HEAD, OPTIONS, PATCH, POST, PUT&quot;
    },
    body: buf.toString('hex')
  };
}
</code></pre>
<h3 id="build-the-docker-image-for-lambda-deployment"><a class="header" href="#build-the-docker-image-for-lambda-deployment">Build the Docker image for Lambda deployment</a></h3>
<p>Now we have the WebAssembly bytecode function and the script to load and connect to the web request. In order to deploy them as a function service on AWS Lambda, you still need to package the whole thing into a Docker image.</p>
<p>We are not going to cover in detail about how to build the Docker image and deploy on AWS Lambda, as there are detailed steps in the <a href="https://github.com/second-state/aws-lambda-wasm-runtime/blob/tensorflow/README.md#deploy">Deploy section of the repository README</a>. However, we will highlight some lines in the <a href="https://github.com/second-state/aws-lambda-wasm-runtime/blob/tensorflow/api/Dockerfile"><code>Dockerfile</code></a> for you to avoid some pitfalls.</p>
<pre><code class="language-dockerfile">FROM public.ecr.aws/lambda/nodejs:14

# Change directory to /var/task
WORKDIR /var/task

RUN yum update -y &amp;&amp; yum install -y curl tar gzip

# Bundle and pre-compile the wasm files
COPY *.wasm ./
COPY pre.sh ./
RUN chmod +x pre.sh
RUN ./pre.sh

# Bundle the JS files
COPY *.js ./

CMD [ &quot;hello.handler&quot; ]
</code></pre>
<p>First, we are building the image from <a href="https://hub.docker.com/r/amazon/aws-lambda-nodejs">AWS Lambda's Node.js base image</a>. The advantage of using AWS Lambda's base image is that it includes the <a href="https://github.com/aws/aws-lambda-nodejs-runtime-interface-client">Lambda Runtime Interface Client (RIC)</a>, which we need to implement in our Docker image as it is required by AWS Lambda. The Amazon Linux uses <code>yum</code> as the package manager.</p>
<blockquote>
<p>These base images contain the Amazon Linux Base operating system, the runtime for a given language, dependencies and the Lambda Runtime Interface Client (RIC), which implements the Lambda <a href="https://docs.aws.amazon.com/lambda/latest/dg/runtimes-api.html">Runtime API</a>. The Lambda Runtime Interface Client allows your runtime to receive requests from and send requests to the Lambda service.</p>
</blockquote>
<p>Second, we need to put our function and all its dependencies in the <code>/var/task</code> directory. Files in other folders will not be executed by AWS Lambda.</p>
<p>Third, we need to define the default command when we start our container. <code>CMD [ &quot;hello.handler&quot; ]</code> means that we will call the <code>handler</code> function in <code>hello.js</code> whenever our serverless function is called. Recall that we have defined and exported the handler function in the previous steps through <code>exports.handler = ...</code> in <code>hello.js</code>.</p>
<h3 id="optional-test-the-docker-image-locally"><a class="header" href="#optional-test-the-docker-image-locally">Optional: test the Docker image locally</a></h3>
<p>Docker images built from AWS Lambda's base images can be tested locally following <a href="https://docs.aws.amazon.com/lambda/latest/dg/images-test.html">this guide</a>. Local testing requires <a href="https://github.com/aws/aws-lambda-runtime-interface-emulator">AWS Lambda Runtime Interface Emulator (RIE)</a>, which is already installed in all of AWS Lambda's base images. To test your image, first, start the Docker container by running:</p>
<pre><code class="language-bash">docker run -p 9000:8080  myfunction:latest 
</code></pre>
<p>This command sets a function endpoint on your local machine at <code>http://localhost:9000/2015-03-31/functions/function/invocations</code>.</p>
<p>Then, from a separate terminal window, run:</p>
<pre><code class="language-bash">curl -XPOST &quot;http://localhost:9000/2015-03-31/functions/function/invocations&quot; -d '{}'
</code></pre>
<p>And you should get your expected output in the terminal.</p>
<p>If you don't want to use a base image from AWS Lambda, you can also use your own base image and install RIC and/or RIE while building your Docker image. Just follow <strong>Create an image from an alternative base image</strong> section from <a href="https://docs.aws.amazon.com/lambda/latest/dg/images-create.html">this guide</a>.</p>
<p>That's it! After building your Docker image, you can deploy it to AWS Lambda following steps outlined in the repository <a href="https://github.com/second-state/aws-lambda-wasm-runtime/blob/tensorflow/README.md#deploy">README</a>. Now your serverless function is ready to rock!</p>
<h2 id="example-2-ai-inference-2"><a class="header" href="#example-2-ai-inference-2">Example 2: AI inference</a></h2>
<p>The <a href="https://github.com/second-state/aws-lambda-wasm-runtime/tree/tensorflow">second demo</a> application allows users to upload an image and then invoke a serverless function to classify the main subject on the image.</p>
<p>It is in <a href="https://github.com/second-state/aws-lambda-wasm-runtime/tree/tensorflow">the same GitHub repo</a> as the previous example but in the <code>tensorflow</code> branch. The backend serverless function for image classification is in the <code>api/functions/image-classification</code> folder in the <code>tensorflow</code> branch. The <code>src/main.rs</code> file contains the Rust program’s source code. The Rust program reads image data from the <code>STDIN</code>, and then outputs the text output to the <code>STDOUT</code>. It utilizes the WasmEdge Tensorflow API to run the AI inference.</p>
<pre><pre class="playground"><code class="language-rust">pub fn main() {
  // Step 1: Load the TFLite model
  let model_data: &amp;[u8] = include_bytes!(&quot;models/mobilenet_v1_1.0_224/mobilenet_v1_1.0_224_quant.tflite&quot;);
  let labels = include_str!(&quot;models/mobilenet_v1_1.0_224/labels_mobilenet_quant_v1_224.txt&quot;);

  // Step 2: Read image from STDIN
  let mut buf = Vec::new();
  io::stdin().read_to_end(&amp;mut buf).unwrap();

  // Step 3: Resize the input image for the tensorflow model
  let flat_img = wasmedge_tensorflow_interface::load_jpg_image_to_rgb8(&amp;buf, 224, 224);

  // Step 4: AI inference
  let mut session = wasmedge_tensorflow_interface::Session::new(&amp;model_data, wasmedge_tensorflow_interface::ModelType::TensorFlowLite);
  session.add_input(&quot;input&quot;, &amp;flat_img, &amp;[1, 224, 224, 3])
         .run();
  let res_vec: Vec&lt;u8&gt; = session.get_output(&quot;MobilenetV1/Predictions/Reshape_1&quot;);

  // Step 5: Find the food label that responds to the highest probability in res_vec
  // ... ...
  let mut label_lines = labels.lines();
  for _i in 0..max_index {
    label_lines.next();
  }

  // Step 6: Generate the output text
  let class_name = label_lines.next().unwrap().to_string();
  if max_value &gt; 50 {
    println!(&quot;It {} a &lt;a href='https://www.google.com/search?q={}'&gt;{}&lt;/a&gt; in the picture&quot;, confidence.to_string(), class_name, class_name);
  } else {
    println!(&quot;It does not appears to be any food item in the picture.&quot;);
  }
}
</code></pre></pre>
<p>You can use the <code>cargo</code> tool to build the Rust program into WebAssembly bytecode or native code.</p>
<pre><code class="language-bash">cd api/functions/image-classification/
cargo build --release --target wasm32-wasi
</code></pre>
<p>Copy the build artifacts to the <code>api</code> folder.</p>
<pre><code class="language-bash">cp target/wasm32-wasi/release/classify.wasm ../../
</code></pre>
<p>Again, the <code>api/pre.sh</code> script installs WasmEdge runtime and its Tensorflow dependencies in this application. It also compiles the <code>classify.wasm</code> bytecode program to the <code>classify.so</code> native shared library at the time of deployment.</p>
<p>The <a href="https://github.com/second-state/aws-lambda-wasm-runtime/blob/tensorflow/api/hello.js"><code>api/hello.js</code></a> script loads the WasmEdge runtime, starts the compiled WebAssembly program in WasmEdge, and passes the uploaded image data via <code>STDIN</code>. Notice <a href="https://github.com/second-state/aws-lambda-wasm-runtime/blob/tensorflow/api/hello.js"><code>api/hello.js</code></a> runs the compiled <code>classify.so</code> file generated by <a href="https://github.com/second-state/aws-lambda-wasm-runtime/blob/tensorflow/api/pre.sh"><code>api/pre.sh</code></a> for better performance. The handler function is similar to our previous example, and is omitted here.</p>
<pre><code class="language-javascript">const { spawn } = require('child_process');
const path = require('path');

function _runWasm(reqBody) {
  return new Promise(resolve =&gt; {
    const wasmedge = spawn(
      path.join(__dirname, 'wasmedge-tensorflow-lite'),
      [path.join(__dirname, 'classify.so')],
      {env: {'LD_LIBRARY_PATH': __dirname}}
    );

    let d = [];
    wasmedge.stdout.on('data', (data) =&gt; {
      d.push(data);
    });

    wasmedge.on('close', (code) =&gt; {
      resolve(d.join(''));
    });

    wasmedge.stdin.write(reqBody);
    wasmedge.stdin.end('');
  });
}

exports.handler = ... // _runWasm(reqBody) is called in the handler
</code></pre>
<p>You can build your Docker image and deploy the function in the same way as outlined in the previous example. Now you have created a web app for subject classification!</p>
<p>Next, it's your turn to use the <a href="https://github.com/second-state/aws-lambda-wasm-runtime/tree/main">aws-lambda-wasm-runtime repo</a> as a template to develop Rust serverless function on AWS Lambda. Looking forward to your great work.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="webassembly-serverless-functions-on-tencent-cloud"><a class="header" href="#webassembly-serverless-functions-on-tencent-cloud">WebAssembly serverless functions on Tencent Cloud</a></h1>
<p>As the main users of Tencent Cloud are from China, so the tutorial is <a href="https://my.oschina.net/u/4532842/blog/5172639">written in Chinese</a>.</p>
<p>We also provide a code template for deploying serverless WebAssembly functions on Tencent Cloud, please check out <a href="https://github.com/second-state/tencent-scf-wasm-runtime">the tencent-scf-wasm-runtime repo</a>.</p>
<p>Fork the repo and start writing your own rust functions.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="second-state-functions"><a class="header" href="#second-state-functions">Second State Functions</a></h1>
<p>Second State Functions, powered by WasmEdge, supports the Rust language as a first class citizen.</p>
<p>It could</p>
<ul>
<li><a href="https://www.secondstate.io/articles/getting-started-with-function-as-a-service-in-rust/">Handle text-based input and output</a></li>
<li><a href="https://www.secondstate.io/articles/use-binary-data-as-function-input-and-output/">Use Binary data as function input and output</a></li>
<li><a href="https://www.secondstate.io/articles/use-binary-data-as-function-input-and-output/">Mix bytes and strings in function argument and return value</a></li>
<li><a href="https://www.secondstate.io/articles/internet-of-functions-webhooks/">Use webhooks as function input and output</a></li>
<li><a href="https://www.secondstate.io/articles/internet-of-functions-http-proxy/">Access internet resources via a <code>http_proxy</code> API</a></li>
<li><a href="https://www.secondstate.io/articles/wasi-tensorflow/">Running TensorFlow models at native speed via the WasmEdge TensorFlow API</a></li>
</ul>
<p>Check out the <a href="https://www.secondstate.io/faas/">Second State Functions</a> website for more tutorials.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="operating-systems"><a class="header" href="#operating-systems">Operating systems</a></h1>
<p>WasmEdge supports a wide range of operating systems and hardware platforms.
It allows WebAssembly bytecode applications to be truly portable
across platforms.
It runs not only on Linux-like systems, but also on microkernels such as the seL4 system.</p>
<p>WasmEdge now supports:</p>
<ul>
<li>Linux</li>
<li>Windows</li>
<li>macOS</li>
<li>seL4</li>
<li>OpenHarmony(ongoing)</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="linux"><a class="header" href="#linux">Linux</a></h1>
<p>WasmEdge supports a wide range of Linux distributions dated back to 2007. The official release contains statically linked binaries and libraries for older Linux systems.
The table below shows build targets in WasmEdge's official release packages.</p>
<table><thead><tr><th>tag name</th><th>arch</th><th>based operating system</th><th>LLVM version</th><th>ENVs</th><th>compatibility</th><th>comments</th></tr></thead><tbody>
<tr><td><code>latest</code></td><td>x86_64</td><td>Ubuntu 20.04 LTS</td><td>12.0.0</td><td>CC=clang, CXX=clang++</td><td>Ubuntu 20.04+</td><td>This is for CI, will always use the latest Ubuntu release</td></tr>
<tr><td><code>ubuntu-build-gcc</code></td><td>x86_64</td><td>Ubuntu 20.04 LTS</td><td>12.0.0</td><td>CC=gcc, CXX=g++</td><td>Ubuntu 20.04+</td><td>This is for CI, will always use the latest Ubuntu release</td></tr>
<tr><td><code>ubuntu-build-clang</code></td><td>x86_64</td><td>Ubuntu 20.04 LTS</td><td>12.0.0</td><td>CC=clang, CXX=clang++</td><td>Ubuntu 20.04+</td><td>This is for CI, will always use the latest Ubuntu release</td></tr>
<tr><td><code>ubuntu2004_x86_64</code></td><td>x86_64</td><td>Ubuntu 20.04 LTS</td><td>10.0.0</td><td>CC=gcc, CXX=g++</td><td>Ubuntu 20.04+</td><td>This is for developers who familiar with Ubuntu 20.04 LTS release</td></tr>
<tr><td><code>ubuntu2104_armv7l</code></td><td>armhf</td><td>Ubuntu 21.04</td><td>12.0.0</td><td>CC=gcc, CXX=g++</td><td>Ubuntu 21.04+</td><td>This is for armhf release</td></tr>
<tr><td><code>manylinux2014_x86_64</code></td><td>x86_64</td><td>CentOS 7, 7.9.2009</td><td>12.0.0</td><td>CC=gcc, CXX=g++</td><td>Ubuntu 16.04+, CentOS 7+</td><td>This is for developers who familiar with CentOS on x86_64 architecture</td></tr>
<tr><td><code>manylinux2014_aarch64</code></td><td>aarch64</td><td>CentOS 7, 7.9.2009</td><td>12.0.0</td><td>CC=gcc, CXX=g++</td><td>Ubuntu 16.04+, CentOS 7+</td><td>This is for developers who familiar with CentOS on aarch64 architecture</td></tr>
<tr><td><code>manylinux2010_x86_64</code></td><td>x86_64</td><td>CentOS 6, 6.10</td><td>12.0.0</td><td>CC=gcc, CXX=g++</td><td>Ubuntu 14.04+, CentOS 6+</td><td>This is for developers who familiar with legacy system on x86_64 architecture, EOL</td></tr>
<tr><td><code>manylinux1_x86_64</code></td><td>x86_64</td><td>CentOS 5, 5.11</td><td>12.0.0</td><td>CC=gcc, CXX=g++</td><td>Ubuntu 14.04+, CentOS 5+</td><td>This is for developers who familiar with legacy system on x86_64 architecture, EOL</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h1 id="windows"><a class="header" href="#windows">Windows</a></h1>
<p>WasmEdge provides a standard Windows PowerShell binary build as part of its official release package.
You can install it via our standard install script.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mac"><a class="header" href="#mac">Mac</a></h1>
<p>WasmEdge provides both x86 and m1 binary builds for Mac OS X.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="android"><a class="header" href="#android">Android</a></h1>
<p>The WasmEdge Runtime releases come with pre-built binaries for the Android OS. Why WasmEdge on Android?</p>
<ul>
<li>Native speed &amp; sandbox safety for Android apps</li>
<li>Support multiple dev languages — eg C, <a href="os/../dev/rust.html">Rust</a>, <a href="os/../dev/swift.html">Swift</a>, <a href="os/../dev/go.html">Go</a> &amp; <a href="os/../dev/js.html">JS</a></li>
<li><a href="os/../embed.html">Embed 3rd party functions</a> in your android app</li>
<li><a href="os/../kubernetes.html">Kubernetes managed</a> android apps</li>
</ul>
<p>However, the WasmEdge installer does not support Android. The user must download the release files to a computer, and then use the <code>adb</code> tool to transfer the files to an Android device or simulator. We will show you how to do that.</p>
<blockquote>
<p>If you prefer to build WasmEdge Runtime binary on Android for yourself, you can refer to the <a href="os/../extend/build_for_android.html">build WasmEdge for Android</a> document.</p>
</blockquote>
<ul>
<li><a href="os/android/cli.html">WasmEdge CLI tools for Android</a></li>
<li><a href="os/android/ndk.html">Call WasmEdge functions from an NDK native app</a></li>
<li><a href="os/android/studio.html">Call WasmEdge functions from an Android APK app</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="wasmedge-cli-tools-for-android"><a class="header" href="#wasmedge-cli-tools-for-android">WasmEdge CLI tools for Android</a></h1>
<p>In this section, we will show you how to use WasmEdge CLI tools on Android devices. We will showcase a full WasmEdge demo to perform image classification (Tensorflow-based AI inference) on an Android device.</p>
<h2 id="install-android-version-of-wasmedge-tensorflow-tools"><a class="header" href="#install-android-version-of-wasmedge-tensorflow-tools">Install Android version of WasmEdge-TensorFlow-Tools</a></h2>
<p>First, install WasmEdge-TensorFlow-Tools pre-release on your Android device. It works with the Android version of TensorFlow-Lite dynamic shared library.</p>
<h3 id="preparation"><a class="header" href="#preparation">Preparation</a></h3>
<h4 id="android-developer-options"><a class="header" href="#android-developer-options">Android developer options</a></h4>
<p>Currently, WasmEdge only supports the arm64-v8a architecture on Android devices. You need an arm64-v8a Android simulator or a physical device with <a href="https://developer.android.com/studio/debug/dev-options">developer options turned on</a>. WasmEdge requires Android 6.0 and above.</p>
<h4 id="android-development-cli"><a class="header" href="#android-development-cli">Android development CLI</a></h4>
<p>In Ubuntu Linux, you can use the <code>apt-get</code> command to install Android debugging and testing tool <code>adb</code>. Using the <code>adb shell</code> command on the Ubuntu dev machine, you can open a CLI shell to execute commands on the connected Android device.</p>
<pre><code class="language-bash">$ sudo apt-get install adb
$ adb devices
* daemon not running; starting now at tcp:5037
* daemon started successfully
List of devices attached
c657c643 device
$ adb shell
sirius:/ $
</code></pre>
<h3 id="install-wasmedge-tensorflow-tools-packages"><a class="header" href="#install-wasmedge-tensorflow-tools-packages">Install WasmEdge-TensorFlow-Tools packages</a></h3>
<p>Use the following commands on your Ubuntu dev machine to download the WasmEdge-TensorFlow-Tools pre-release packages.</p>
<pre><code class="language-bash">$ wget https://github.com/second-state/WasmEdge-tensorflow-tools/releases/download/0.9.1-beta.2/WasmEdge-tensorflow-tools-0.9.1-beta.2-android_aarch64.tar.gz
$ mkdir WasmEdge-tensorflow-tools &amp;&amp; tar zxvf WasmEdge-tensorflow-tools-0.9.1-beta.2-android_aarch64.tar.gz -C WasmEdge-tensorflow-tools
show-tflite-tensor
wasmedge-tensorflow-lite
</code></pre>
<h3 id="install-android-version-of-the-tensorflow-lite-shared-library"><a class="header" href="#install-android-version-of-the-tensorflow-lite-shared-library">Install Android version of the TensorFlow-Lite shared library</a></h3>
<p>We provide an Android compatible version of TensorFlow-Lite dynamic shared library in the WasmEdge-Tensorflow-deps package. Download the package to your Ubuntu dev machine as follows.</p>
<pre><code class="language-bash">$ wget https://github.com/second-state/WasmEdge-tensorflow-deps/releases/download/0.9.1-beta.2/WasmEdge-tensorflow-deps-TFLite-0.9.1-beta.2-android_aarch64.tar.gz
$ tar zxvf WasmEdge-tensorflow-deps-TFLite-0.9.1-beta.2-android_aarch64.tar.gz -C WasmEdge-tensorflow-tools
libtensorflowlite_c.so
</code></pre>
<p>Next use the <code>adb</code> tool to push the downloaded WasmEdge-TensorFlow packages onto a connected Android device.</p>
<pre><code class="language-bash">adb push WasmEdge-tensorflow-tools /data/local/tmp
</code></pre>
<h2 id="try-it-out"><a class="header" href="#try-it-out">Try it out</a></h2>
<h3 id="sample-application"><a class="header" href="#sample-application">Sample application</a></h3>
<p>In this example, we will demonstrate a standard <a href="https://github.com/second-state/wasm-learning/tree/master/rust/birds_v1">WasmEdge Tensorflow-Lite sample application</a>. It can recognize and classify the bird type from a JPG or PNG picture of a bird. The explanation of the source code can be <a href="https://wasmedge.org/book/en/dev/rust/tensorflow.html">found here</a>.</p>
<pre><code class="language-bash">git clone https://github.com/second-state/wasm-learning.git
cd wasm-learning/rust/birds_v1
</code></pre>
<p>Use the <code>cargo</code> command to build a Wasm bytecode file from the Rust source code. The Wasm file is located at <code>target/wasm32-wasi/release/birds_v1.wasm</code>.</p>
<pre><code class="language-bash">rustup target add wasm32-wasi
cargo build --release --target=wasm32-wasi
</code></pre>
<p>Push the Wasm bytecode file, tensorflow lite model file, and the test bird picture file onto the Android device using <code>adb</code>.</p>
<pre><code class="language-bash">adb push target/wasm32-wasi/release/birds_v1.wasm /data/local/tmp/WasmEdge-tensorflow-tools
adb push lite-model_aiy_vision_classifier_birds_V1_3.tflite /data/local/tmp/WasmEdge-tensorflow-tools
adb push bird.jpg /data/local/tmp/WasmEdge-tensorflow-tools
</code></pre>
<h3 id="run-the-wasmedge-tensorflow-tools"><a class="header" href="#run-the-wasmedge-tensorflow-tools">Run the WasmEdge-TensorFlow-Tools</a></h3>
<p>Type <code>adb shell</code> from the Ubuntu CLI to open a command shell for the connected Android device. Confirm that the tools, programs, and test image are all available on the Android device under the <code>/data/local/tmp/WasmEdge-tensorflow-tools</code> folder.</p>
<pre><code class="language-bash">$ adb shell
sirius:/ $ cd /data/local/tmp/WasmEdge-tensorflow-tools
sirius:/data/local/tmp/WasmEdge-tensorflow-tools $ ls
bird.jpg               lite-model_aiy_vision_classifier_birds_V1_3.tflite 
birds_v1.wasm          show-tflite-tensor                                 
libtensorflowlite_c.so wasmedge-tensorflow-lite
</code></pre>
<p>Load the TensorFlow-Lite dynamic shared library, and use the <code>show-tflite-tensor</code> CLI tool to examine the Tensorflow Lite model file.</p>
<pre><code class="language-bash">sirius:/data/local/tmp/WasmEdge-tensorflow-tools $ export LD_LIBRARY_PATH=.:$LD_LIBRARY_PATH
sirius:/data/local/tmp/WasmEdge-tensorflow-tools $ chmod 777 show-tflite-tensor
sirius:/data/local/tmp/WasmEdge-tensorflow-tools $ ./show-tflite-tensor lite-model_aiy_vision_classifier_birds_V1_3.tflite
INFO: Initialized TensorFlow Lite runtime.
Input tensor nums: 1
    Input tensor name: module/hub_input/images_uint8
        dimensions: [1 , 224 , 224 , 3]
        data type: UInt8
        tensor byte size: 150528
Output tensor nums: 1
    Output tensor name: module/prediction
        dimensions: [1 , 965]
        data type: UInt8
        tensor byte size: 965
</code></pre>
<p>Use the extended WasmEdge Runtime in <code>wasmedge-tensorflow-lite</code> to execute the compiled Wasm program on the Android device. It loads the Tensorflow Lite model and bird image, and outputs the bird classification and its confidence.</p>
<pre><code class="language-bash">sirius:/data/local/tmp/WasmEdge-tensorflow-tools $ chmod 777 wasmedge-tensorflow-lite
sirius:/data/local/tmp/WasmEdge-tensorflow-tools $ ./wasmedge-tensorflow-lite --dir .:. birds_v1.wasm lite-model_aiy_vision_classifier_birds_V1_3.tflite bird.jpg
INFO: Initialized TensorFlow Lite runtime.
166 : 0.84705883
</code></pre>
<p>The result shows that the bird type is in <a href="https://github.com/second-state/wasm-learning/blob/master/rust/birds_v1/aiy_birds_V1_labels.txt#L166">line 166 of the label file</a> (Sicalis flaveola) and the confidence level is 84.7%.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="call-wasmedge-functions-from-an-ndk-native-app"><a class="header" href="#call-wasmedge-functions-from-an-ndk-native-app">Call WasmEdge functions from an NDK native app</a></h1>
<p>In this section, we will demonstrate how to build an Android native application using C and the Android SDK. The native application uses the WasmEdge C SDK to embed the WasmEdge Runtime, and call WASM functions through WasmEdge.</p>
<h2 id="prerequisite-5"><a class="header" href="#prerequisite-5">Prerequisite</a></h2>
<h3 id="android-1"><a class="header" href="#android-1">Android</a></h3>
<p>Currently, WasmEdge only supports the arm64-v8a architecture on Android devices. You need an arm64-v8a Android simulator or a physical device with <a href="https://developer.android.com/studio/debug/dev-options">developer options turned on</a>. WasmEdge requires Android 6.0 and above.</p>
<h3 id="android-development-cli-1"><a class="header" href="#android-development-cli-1">Android development CLI</a></h3>
<p>In Ubuntu Linux, you can use the <code>apt-get</code> command to install Android debugging and testing tool <code>adb</code>. Using the <code>adb shell</code> command on the Ubuntu dev machine, you can open a CLI shell to execute commands on the connected Android device.</p>
<pre><code class="language-bash">sudo apt-get install adb
</code></pre>
<h3 id="android-ndk"><a class="header" href="#android-ndk">Android NDK</a></h3>
<p>To compile programs with the wasmedge-tensorflow c api, you need to install the <a href="https://developer.android.google.cn/ndk/downloads">Android NDK</a>. In this example, we use the latest LTS version (r23b).</p>
<h2 id="review-of-source-code"><a class="header" href="#review-of-source-code">Review of source code</a></h2>
<p>The <a href="https://github.com/second-state/wasm-learning/blob/master/android/test.c"><code>test.c</code></a> uses the wasmedge-tensorflow c api to run a WebAssembly function. The WebAssembly file <code>birds_v1.wasm</code> is compiled from Rust source code and <a href="os/android/../../dev/rust/tensorflow.html">explained here</a>.</p>
<pre><code class="language-c">#include &lt;wasmedge/wasmedge.h&gt;
#include &lt;wasmedge/wasmedge-image.h&gt;
#include &lt;wasmedge/wasmedge-tensorflowlite.h&gt;

#include &lt;stdio.h&gt;

int main(int argc, char *argv[]) {
  /*
   * argv[0]: ./a.out
   * argv[1]: WASM file
   * argv[2]: tflite model file
   * argv[3]: image file
   * Usage: ./a.out birds_v1.wasm lite-model_aiy_vision_classifier_birds_V1_3.tflite bird.jpg
   */

  /* Create the VM context. */
  WasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();
  WasmEdge_ConfigureAddHostRegistration(ConfCxt, WasmEdge_HostRegistration_Wasi);
  WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(ConfCxt, NULL);
  WasmEdge_ConfigureDelete(ConfCxt);
  
  /* Create the image and TFLite import objects. */
  WasmEdge_ImportObjectContext *ImageImpObj = WasmEdge_Image_ImportObjectCreate();
  WasmEdge_ImportObjectContext *TFLiteImpObj = WasmEdge_TensorflowLite_ImportObjectCreate();
  WasmEdge_ImportObjectContext *TFDummyImpObj = WasmEdge_Tensorflow_ImportObjectCreateDummy();

  /* Register into VM. */
  WasmEdge_VMRegisterModuleFromImport(VMCxt, ImageImpObj);
  WasmEdge_VMRegisterModuleFromImport(VMCxt, TFLiteImpObj);
  WasmEdge_VMRegisterModuleFromImport(VMCxt, TFDummyImpObj);

  /* Init WASI. */
  const char *Preopens[] = {&quot;.:.&quot;};
  const char *Args[] = {argv[1], argv[2], argv[3]};
  WasmEdge_ImportObjectContext *WASIImpObj = WasmEdge_VMGetImportModuleContext(VMCxt, WasmEdge_HostRegistration_Wasi);
  WasmEdge_ImportObjectInitWASI(WASIImpObj, Args, 3, NULL, 0, Preopens, 1);

  /* Run WASM file. */
  WasmEdge_String FuncName = WasmEdge_StringCreateByCString(&quot;_start&quot;);
  WasmEdge_Result Res = WasmEdge_VMRunWasmFromFile(VMCxt, argv[1], FuncName, NULL, 0, NULL, 0);
  WasmEdge_StringDelete(FuncName);

  /* Check the result. */
  if (!WasmEdge_ResultOK(Res)) {
    printf(&quot;Run WASM failed: %s\n&quot;, WasmEdge_ResultGetMessage(Res));
    return -1;
  }

  WasmEdge_ImportObjectDelete(ImageImpObj);
  WasmEdge_ImportObjectDelete(TFLiteImpObj);
  WasmEdge_ImportObjectDelete(TFDummyImpObj);
  WasmEdge_VMDelete(VMCxt);
  return 0;
}
</code></pre>
<h2 id="build-1"><a class="header" href="#build-1">Build</a></h2>
<h3 id="install-dependencies"><a class="header" href="#install-dependencies">Install dependencies</a></h3>
<p>Use the following commands to download WasmEdge for Android on your Ubuntu dev machine.</p>
<pre><code class="language-bash">wget https://github.com/WasmEdge/WasmEdge/releases/download/0.9.1-rc.1/WasmEdge-0.9.1-rc.1-android_aarch64.tar.gz
wget https://github.com/second-state/WasmEdge-image/releases/download/0.9.1-rc.1/WasmEdge-image-0.9.1-rc.1-android_aarch64.tar.gz
wget https://github.com/second-state/WasmEdge-tensorflow/releases/download/0.9.1-rc.1/WasmEdge-tensorflowlite-0.9.1-rc.1-android_aarch64.tar.gz
wget https://github.com/second-state/WasmEdge-tensorflow-deps/releases/download/0.9.1-rc.1/WasmEdge-tensorflow-deps-TFLite-0.9.1-rc.1-android_aarch64.tar.gz
tar -zxf WasmEdge-0.9.1-rc.1-android_aarch64.tar.gz
tar -zxf WasmEdge-image-0.9.1-rc.1-android_aarch64.tar.gz -C WasmEdge-0.9.1-rc.1-Android/
tar -zxf WasmEdge-tensorflowlite-0.9.1-rc.1-android_aarch64.tar.gz -C WasmEdge-0.9.1-rc.1-Android/
tar -zxf WasmEdge-tensorflow-deps-TFLite-0.9.1-rc.1-android_aarch64.tar.gz -C WasmEdge-0.9.1-rc.1-Android/lib/
</code></pre>
<h3 id="compile"><a class="header" href="#compile">Compile</a></h3>
<p>The following command compiles the C program to <code>a.out</code> on your Ubunu dev machine.</p>
<pre><code class="language-bash">(/path/to/ndk)/toolchains/llvm/prebuilt/(HostPlatform)/bin/aarch64-linux-(AndroidApiVersion)-clang test.c -I./WasmEdge-0.9.1-rc.1-Android/include -L./WasmEdge-0.9.1-rc.1-Android/lib -lwasmedge-image_c -lwasmedge-tensorflowlite_c -ltensorflowlite_c -lwasmedge_c
</code></pre>
<h2 id="run-2"><a class="header" href="#run-2">Run</a></h2>
<h3 id="push-files-onto-android"><a class="header" href="#push-files-onto-android">Push files onto Android</a></h3>
<p>Install the compiled program, Tensorflow Lite model file, test image file, as well as WasmEdge shared library files for Android, onto the Android device using <code>adb</code> from your Ubuntu dev machine.</p>
<pre><code class="language-bash">adb push a.out /data/local/tmp
adb push birds_v1.wasm /data/local/tmp
adb push lite-model_aiy_vision_classifier_birds_V1_3.tflite /data/local/tmp
adb push bird.jpg /data/local/tmp
adb push ./WasmEdge-0.9.1-rc.1-Android/lib /data/local/tmp
</code></pre>
<h3 id="run-the-example"><a class="header" href="#run-the-example">Run the example</a></h3>
<p>Now you can run the compiled C program on the Android device via a remote shell command. Run <code>adb shell</code> from your Ubuntu dev machine.</p>
<pre><code class="language-bash">$ adb shell
sirius:/ $ cd /data/local/tmp
sirius:/data/local/tmp $ export LD_LIBRARY_PATH=/data/local/tmp/lib:$LD_LIBRARY_PATH
sirius:/data/local/tmp $ ./a.out birds_v1.wasm lite-model_aiy_vision_classifier_birds_V1_3.tflite bird.jpg
INFO: Initialized TensorFlow Lite runtime.
166 : 0.84705883
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="call-wasmedge-functions-from-an-android-apk-app"><a class="header" href="#call-wasmedge-functions-from-an-android-apk-app">Call WasmEdge functions from an Android APK app</a></h1>
<p>In this section, we will show you how to build a &quot;regular&quot; Android app (i.e., an APK file that can be installed on an Android device). The APK app embeds a WasmEdge Runtime. It can call WebAssembly functions through the embedded WasmEdge. The benefit is that developers can safely embed high-performance functions written in several different languages (e.g., Rust, JS, Grain, TinyGo etc) into a Kotlin application.</p>
<h2 id="quickstart"><a class="header" href="#quickstart">Quickstart</a></h2>
<p>The demo project is <a href="https://github.com/WasmEdge/WasmEdge/tree/master/utils/android/app">available here</a>. You can build the project using the Gradle tool or using the Android Stuido IDE.</p>
<h3 id="building-project-with-gradle"><a class="header" href="#building-project-with-gradle">Building Project with Gradle</a></h3>
<ol>
<li>Setup environment variable <code>ANDROID_HOME=path/to/your/android/sdk</code></li>
<li>Run Command <code>./gradlew assembleRelease</code></li>
<li>Sign your APK file with <code>apksigner</code>. The apk file is at <code>./app/build/outputs/apk/release</code>. The <code>apksigner</code> utility is at <code>$ANDROID_HOME/build-tools/$VERSION/apksigner</code>.</li>
</ol>
<h3 id="building-project-with-android-studio"><a class="header" href="#building-project-with-android-studio">Building Project with Android Studio</a></h3>
<p>Open this folder with <a href="https://developer.android.com/studio">Android Studio</a> 2020.3.1 or later.</p>
<p>For Release APK, click <code>Menu -&gt; Build -&gt; Generate Signed Bundle/APK</code>, select APK, setup keystore configuration and wait for build finished.</p>
<h2 id="review-of-the-source-code"><a class="header" href="#review-of-the-source-code">Review of the source code</a></h2>
<p>The Android UI app is written in Kotlin, and it uses JNI (Java Native Interface) to load a C shared library, which in turn embeds WasmEdge.</p>
<h3 id="android-ui"><a class="header" href="#android-ui">Android UI</a></h3>
<p>The Android UI application is <a href="https://github.com/WasmEdge/WasmEdge/blob/master/utils/android/app/app/src/main/java/org/wasmedge/example_app/MainActivity.kt">located here</a>. It is written in Kotlin using the Android SDK.</p>
<pre><code class="language-java">class MainActivity : AppCompatActivity() {
  lateinit var lib: NativeLib

  override fun onCreate(savedInstanceState: Bundle?) {
    super.onCreate(savedInstanceState)
    setContentView(R.layout.activity_main)

    val tv = findViewById&lt;TextView&gt;(R.id.tv_text)

    lib = NativeLib(this)

    Thread {
      val lines = Vector&lt;String&gt;()
      val idxArr = arrayOf(20, 25, 28, 30, 32)
      for (idx: Int in idxArr) {
        lines.add(&quot;running fib(${idx}) ...&quot;)
        runOnUiThread {
          tv.text = lines.joinToString(&quot;\n&quot;)
        }
        val begin = System.currentTimeMillis()
        val retVal = lib.wasmFibonacci(idx)
        val end = System.currentTimeMillis()
        lines.removeLast()
        lines.add(&quot;fib(${idx}) -&gt; ${retVal}, ${end - begin}ms&quot;)
        runOnUiThread {
          tv.text = lines.joinToString(&quot;\n&quot;)
        }
      }
    }.start()
  }
}
</code></pre>
<h3 id="the-native-library"><a class="header" href="#the-native-library">The native library</a></h3>
<p>The Android UI app calls a <code>NativeLib</code> Kotlin object to access WasmEdge functions. The <code>NativeLib</code> source code is <a href="https://github.com/WasmEdge/WasmEdge/blob/master/utils/android/app/lib/src/main/java/org/wasmedge/native_lib/NativeLib.kt">available here</a>. It uses JNI (Java Native Interface) to load a C shared library called <code>wasmedge_lib</code>. It then calls the <code>nativeWasmFibonacci</code> function in <code>wasmedge_lib</code> to execute the <code>fibonacci.wasm</code> WebAssembly bytecode.</p>
<pre><code class="language-java">class NativeLib(ctx : Context) {
  private external fun nativeWasmFibonacci(imageBytes : ByteArray, idx : Int ) : Int

  companion object {
    init {
      System.loadLibrary(&quot;wasmedge_lib&quot;)
    }
  }

  private var fibonacciWasmImageBytes : ByteArray = ctx.assets.open(&quot;fibonacci.wasm&quot;).readBytes()

  fun wasmFibonacci(idx : Int) : Int{
    return nativeWasmFibonacci(fibonacciWasmImageBytes, idx)
  }
}
</code></pre>
<h3 id="the-c-shared-library"><a class="header" href="#the-c-shared-library">The C shared library</a></h3>
<p>The C shared library source code <code>wasmedge_lib.cpp</code> is <a href="https://github.com/WasmEdge/WasmEdge/blob/master/utils/android/app/lib/src/main/cpp/wasmedge_lib.cpp">available here</a>. It uses the WasmEdge C SDK to embed a WasmEdge VM and execute the WebAssembly function.</p>
<pre><code class="language-c">extern &quot;C&quot; JNIEXPORT jint JNICALL
Java_org_wasmedge_native_1lib_NativeLib_nativeWasmFibonacci(
    JNIEnv *env, jobject, jbyteArray image_bytes, jint idx) {
  jsize buffer_size = env-&gt;GetArrayLength(image_bytes);
  jbyte *buffer = env-&gt;GetByteArrayElements(image_bytes, nullptr);

  WasmEdge_ConfigureContext *conf = WasmEdge_ConfigureCreate();
  WasmEdge_ConfigureAddHostRegistration(conf, WasmEdge_HostRegistration_Wasi);

  WasmEdge_VMContext *vm_ctx = WasmEdge_VMCreate(conf, nullptr);

  const WasmEdge_String &amp;func_name = WasmEdge_StringCreateByCString(&quot;fib&quot;);
  std::array&lt;WasmEdge_Value, 1&gt; params{WasmEdge_ValueGenI32(idx)};
  std::array&lt;WasmEdge_Value, 1&gt; ret_val{};

  const WasmEdge_Result &amp;res = WasmEdge_VMRunWasmFromBuffer(
      vm_ctx, (uint8_t *)buffer, buffer_size, func_name, params.data(),
      params.size(), ret_val.data(), ret_val.size());

  WasmEdge_VMDelete(vm_ctx);
  WasmEdge_ConfigureDelete(conf);
  WasmEdge_StringDelete(func_name);

  env-&gt;ReleaseByteArrayElements(image_bytes, buffer, 0);
  if (!WasmEdge_ResultOK(res)) {
    return -1;
  }
  return WasmEdge_ValueGetI32(ret_val[0]);
}
</code></pre>
<h3 id="the-webassembly-function"><a class="header" href="#the-webassembly-function">The WebAssembly function</a></h3>
<p>The <code>factorial.wat</code> is a <a href="https://github.com/WasmEdge/WasmEdge/blob/master/tools/wasmedge/examples/fibonacci.wat">handwritten WebAssembly script</a> to compute factorial numbers. It is compiled into WebAssembly using the <a href="https://github.com/WebAssembly/wabt">WABT tool</a>.</p>
<h3 id="build-dependencies"><a class="header" href="#build-dependencies">Build dependencies</a></h3>
<p>Android Studio and Gradle use CMake to build the C shared library. The <a href="https://github.com/WasmEdge/WasmEdge/blob/master/utils/android/app/lib/src/main/cpp/CMakeLists.txt">CMakeLists.txt file</a> builds the WasmEdge source into Android shared library files and embeds them into the final APK application. In this case, there is no seperate step to install WasmEdge share libraries onto the Android device.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="wasmedge-on-sel4"><a class="header" href="#wasmedge-on-sel4">WasmEdge on seL4</a></h1>
<p><a href="https://youtu.be/2Qu-Trtkspk">Video demo</a> | <a href="https://github.com/second-state/wasmedge-seL4/runs/3982081148?check_suite_focus=true">Build logs</a> | <a href="https://github.com/second-state/wasmedge-seL4/actions/runs/1374510169">Build artifact</a></p>
<p>In this article, we demonstrate how to run WasmEdge on the seL4 RTOS, there are two parts:</p>
<ol>
<li>Guest Linux OS on seL4: This is the controller of WasmEdge runtime, which will send wasm program to WasmEdge runner that is a agent on seL4 to execute.</li>
<li>WasmEdge runner on seL4: This is the wasm program runtime, which will execute the given wasm program from Guest Linux OS.</li>
</ol>
<p>The figure below illustrates the architecture of the system.</p>
<p><img src="os/wasmedge-sel4.png" alt="wasmedge-sel4" /></p>
<p>This demo is based on the seL4 simulator on Linux.</p>
<h2 id="getting-started-4"><a class="header" href="#getting-started-4">Getting Started</a></h2>
<h3 id="system-requirements"><a class="header" href="#system-requirements">System requirements</a></h3>
<p>Hardware:</p>
<ul>
<li>at least 4GB of RAM</li>
<li>at least 20GB of disk storage (the wasmedge_sel4 directory will contain over 11 GB of data after the following installation completes)</li>
</ul>
<p>Software: Ubuntu 20.04 with dev tools packages (ep. Python) installed. We recommend the <a href="https://github.com/actions/virtual-environments/blob/main/images/linux/Ubuntu2004-README.md">GitHub Actions Ubuntu 20.04 VM</a> (See a list of <a href="https://github.com/actions/virtual-environments/blob/main/images/linux/Ubuntu2004-README.md#installed-apt-packages">installed apt packages</a>). Or, you could use our Docker image (see the <a href="https://github.com/second-state/wasmedge-seL4/blob/main/docs/Dockerfile.sel4_build">Dockerfile</a>).</p>
<pre><code class="language-bash">$ docker pull wasmedge/sel4_build
$ docker run --rm -v $(pwd):/app -it wasmedge/sel4_build
(docker) root#
</code></pre>
<blockquote>
<p>If you do not want to build the seL4 system simulator yourself, you can download the <a href="https://github.com/second-state/wasmedge-seL4/actions/runs/1374510169">build artifact</a> from our GitHub Actions, and skip directly to <a href="os/sel4.html#boot-wasmedge-sel4">Boot wasmedge-seL4</a></p>
</blockquote>
<h3 id="automatic-installation-all-in-one-script"><a class="header" href="#automatic-installation-all-in-one-script">Automatic installation: all-in-one script</a></h3>
<p>Use our all-in-one build script:</p>
<pre><code class="language-bash">wget -qO- https://raw.githubusercontent.com/second-state/wasmedge-seL4/main/build.sh | bash
</code></pre>
<p>And this will clone and build our wasmedge on seL4 to an image.</p>
<p>After finishing the build script, you will have a folder <code>sel4_wasmedge</code>.</p>
<p>If this automatic installation completed successfully, skip over the manual installation information and proceed to <a href="https://github.com/second-state/wasmedge-seL4#boot-wasmedge-sel4">boot wasmedge-sel4</a></p>
<h3 id="manual-installation-managing-memory-usage"><a class="header" href="#manual-installation-managing-memory-usage">Manual installation: managing memory usage</a></h3>
<p>The above all-in-one script will work in most cases. However, if your system resources were stressed and you encountered an error such as <code>ninja: build stopped: subcommand failed</code> please note that you can decrease the parallelization of the install by explicitly passing in a <code>-j</code> parameter to the <code>ninja</code> command (on the last line of the <code>build.sh</code> file). You see, Ninja runs the most amount of parallel processes by default and so the following procedure is a way to explicitly set/reduce parallelization.</p>
<p>Manually fetch the `wasmedge-sel4 repository.</p>
<pre><code class="language-bash">cd ~
git clone https://github.com/second-state/wasmedge-seL4.git
cd wasmedge-seL4
</code></pre>
<p>Manually edit the <code>build.sh</code> file.</p>
<pre><code class="language-bash">vi build.sh
</code></pre>
<p>Add the following <code>-j</code> parameter to the last line of the file i.e.</p>
<pre><code class="language-bash">ninja -j 2
</code></pre>
<p>Make the <code>build.sh</code> file executable.</p>
<pre><code class="language-bash">sudo chmod a+x build.sh
</code></pre>
<p>Run the edited `build.sh file.</p>
<pre><code class="language-bash">./build.sh
</code></pre>
<p>Once this manual installation is complete, follow along with the following steps; boot wasmedge-sel4</p>
<h3 id="boot-wasmedge-sel4"><a class="header" href="#boot-wasmedge-sel4">Boot wasmedge-seL4</a></h3>
<pre><code class="language-bash">cd sel4_wasmedge/build
./simulate
</code></pre>
<p>Expected output:</p>
<pre><code class="language-bash">$ ./simulate: qemu-system-aarch64 -machine virt,virtualization=on,highmem=off,secure=off -cpu cortex-a53 -nographic  -m size=2048  -kernel images/capdl-loader-image-arm-qemu-arm-virt
ELF-loader started on CPU: ARM Ltd. Cortex-A53 r0p4
  paddr=[6abd8000..750cf0af]
No DTB passed in from boot loader.
Looking for DTB in CPIO archive...found at 6ad18f58.
Loaded DTB from 6ad18f58.
   paddr=[60243000..60244fff]
ELF-loading image 'kernel' to 60000000
  paddr=[60000000..60242fff]
  vaddr=[ff8060000000..ff8060242fff]
  virt_entry=ff8060000000
ELF-loading image 'capdl-loader' to 60245000
  paddr=[60245000..6a7ddfff]
  vaddr=[400000..a998fff]
  virt_entry=408f38
Enabling hypervisor MMU and paging
Jumping to kernel-image entry point...

Bootstrapping kernel
Warning: Could not infer GIC interrupt target ID, assuming 0.
Booting all finished, dropped to user space
&lt;&lt;seL4(CPU 0) [decodeUntypedInvocation/205 T0xff80bf85d400 &quot;rootserver&quot; @4006f8]: Untyped Retype: Insufficient memory (1 * 2097152 bytes needed, 0 bytes available).&gt;&gt;
Loading Linux: 'linux' dtb: 'linux-dtb'

...(omitted)...

Starting syslogd: OK
Starting klogd: OK
Running sysctl: OK
Initializing random number generator... [    3.512482] random: dd: uninitialized urandom read (512 bytes read)
done.
Starting network: OK
[    4.086059] connection: loading out-of-tree module taints kernel.
[    4.114686] Event Bar (dev-0) initalised
[    4.123771] 2 Dataports (dev-0) initalised
[    4.130626] Event Bar (dev-1) initalised
[    4.136096] 2 Dataports (dev-1) initalised

Welcome to Buildroot
buildroot login:
</code></pre>
<h3 id="login-on-guest-linux"><a class="header" href="#login-on-guest-linux">Login on guest linux</a></h3>
<p>Enter <code>root</code> to login</p>
<pre><code class="language-bash">buildroot login: root
</code></pre>
<p>Expected output:</p>
<pre><code class="language-bash">buildroot login: root
#
</code></pre>
<h3 id="execute-wasm-examples"><a class="header" href="#execute-wasm-examples">Execute wasm examples</a></h3>
<h4 id="example-a-nbody-cwasm"><a class="header" href="#example-a-nbody-cwasm">Example A: nbody-c.wasm</a></h4>
<p>Run nbody simulation.</p>
<pre><code class="language-bash">wasmedge_emit /usr/bin/nbody-c.wasm 10
</code></pre>
<p>Expected output:</p>
<pre><code class="language-bash">[1900-01-00 00:00:00.000] [info] executing wasm file
-0.169075164
-0.169073022
[1900-01-00 00:00:00.000] [info] execution success, exit code:0
</code></pre>
<h4 id="example-b-hellowasm"><a class="header" href="#example-b-hellowasm">Example B: hello.wasm</a></h4>
<p>Run an easy application to print <code>hello, sel4</code> and a simple calculation.</p>
<pre><code class="language-bash">wasmedge_emit /usr/bin/hello.wasm
</code></pre>
<p>Expected output:</p>
<pre><code class="language-bash">[1900-01-00 00:00:00.000] [info] executing wasm file
hello, sel4
1+2-3*4 = -9
[1900-01-00 00:00:00.000] [info] execution success, exit code:0
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="open-harmony"><a class="header" href="#open-harmony">Open Harmony</a></h1>
<p>WIP. For Chinese speakers, please <a href="https://github.com/WasmEdge/WasmEdge/blob/master/utils/ohos/README-zh.md">check out this instruction</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="raspberry-pi-34"><a class="header" href="#raspberry-pi-34">Raspberry Pi 3/4</a></h1>
<p>Raspberry Pi uses 64-bit processors starting from the 3 Model B. So WasmEdge can be executed on Raspberry Pi as well. You can choose any 64-bit Linux distribution, such as Raspbian, Ubuntu or Manjaro for ARM. This document has been tested on the Manjaro for ARM distribution and the hardware is the Raspberry Pi 3 Model B.</p>
<p>The installation steps are no different from the <a href="https://wasmedge.org/book/en/start/install.html">installation document</a>, and the execution is the same. Here's a video about installing WasmEdge and running a simple WebAssembly module to add two numbers up.</p>
<p><a href="https://asciinema.org/a/458453"><img src="https://asciinema.org/a/458453.svg" alt="asciicast" /></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="contribute-to-wasmedge"><a class="header" href="#contribute-to-wasmedge">Contribute to WasmEdge</a></h1>
<p>One of the most important features of WasmEdge is its extensibility.
Through extensions, WasmEdge applications can use languages like Rust, C, and JavaScript to access features and functionalities provided by the operating systems or shared libraries.</p>
<p>In this chapter, we will cover how to build WasmEdge from source code for different operating systems and platforms.
We will then discuss the WasmEdge plug-in API, which allows developers to create extensions that can be distributed with official WasmEdge releases.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="build-wasmedge-from-source"><a class="header" href="#build-wasmedge-from-source">Build WasmEdge from source</a></h1>
<p>Please follow this guide to build and test WasmEdge from source code.</p>
<p>The following guide is based on Linux distributions. For MacOS, please refer to <a href="extend/build_on_mac.html">Build for macOS</a>. For Windows, please refer to <a href="extend/build_on_windows.html">Build for Windows</a>. For Android, please refer to <a href="extend/build_for_android.html">Build for Android</a>.</p>
<blockquote>
<p>If you just want the latest builds from the <code>HEAD</code> of the <code>master</code> branch, and do not want to build it yourself, you can download the release package directly from our Github Action's CI artifact. <a href="https://github.com/WasmEdge/WasmEdge/actions/runs/1521549504#artifacts">Here is an example</a>.</p>
</blockquote>
<h2 id="get-source-code"><a class="header" href="#get-source-code">Get Source Code</a></h2>
<pre><code class="language-bash">git clone https://github.com/WasmEdge/WasmEdge.git
cd WasmEdge
</code></pre>
<h2 id="check-dependencies"><a class="header" href="#check-dependencies">Check Dependencies</a></h2>
<p>WasmEdge will try to use the latest LLVM release to create our nightly build.
If you want to build from source, you may need to install these dependencies by yourself or using our docker images which provides several Linux distribution support.</p>
<ul>
<li>LLVM 12.0.0 (&gt;= 10.0.0)</li>
<li>GCC 11.1.0 (&gt;= 9.4.0)</li>
</ul>
<h2 id="prepare-the-environment"><a class="header" href="#prepare-the-environment">Prepare the Environment</a></h2>
<h3 id="docker-images"><a class="header" href="#docker-images">Docker Images</a></h3>
<p>Repository on dockerhub <code>wasmedge/wasmedge</code></p>
<p>You can use the following commands to get our latest docker image:</p>
<pre><code class="language-bash">docker pull wasmedge/wasmedge # Equals to wasmedge/wasmedge:latest
</code></pre>
<h4 id="available-tags"><a class="header" href="#available-tags">Available Tags</a></h4>
<table><thead><tr><th>tag name</th><th>arch</th><th>based operating system</th><th>LLVM version</th><th>ENVs</th><th>compatibility</th><th>comments</th></tr></thead><tbody>
<tr><td><code>latest</code></td><td>x86_64</td><td>Ubuntu 20.04 LTS</td><td>12.0.0</td><td>CC=clang, CXX=clang++</td><td>Ubuntu 20.04+</td><td>This is for CI, will always use the latest Ubuntu release</td></tr>
<tr><td><code>ubuntu-build-gcc</code></td><td>x86_64</td><td>Ubuntu 20.04 LTS</td><td>12.0.0</td><td>CC=gcc, CXX=g++</td><td>Ubuntu 20.04+</td><td>This is for CI, will always use the latest Ubuntu release</td></tr>
<tr><td><code>ubuntu-build-clang</code></td><td>x86_64</td><td>Ubuntu 20.04 LTS</td><td>12.0.0</td><td>CC=clang, CXX=clang++</td><td>Ubuntu 20.04+</td><td>This is for CI, will always use the latest Ubuntu release</td></tr>
<tr><td><code>ubuntu2004_x86_64</code></td><td>x86_64</td><td>Ubuntu 20.04 LTS</td><td>10.0.0</td><td>CC=gcc, CXX=g++</td><td>Ubuntu 20.04+</td><td>This is for developers who familiar with Ubuntu 20.04 LTS release</td></tr>
<tr><td><code>ubuntu2104_armv7l</code></td><td>armhf</td><td>Ubuntu 21.04</td><td>12.0.0</td><td>CC=gcc, CXX=g++</td><td>Ubuntu 21.04+</td><td>This is for armhf release</td></tr>
<tr><td><code>manylinux2014_x86_64</code></td><td>x86_64</td><td>CentOS 7, 7.9.2009</td><td>12.0.0</td><td>CC=gcc, CXX=g++</td><td>Ubuntu 16.04+, CentOS 7+</td><td>This is for developers who familiar with CentOS on x86_64 architecture</td></tr>
<tr><td><code>manylinux2014_aarch64</code></td><td>aarch64</td><td>CentOS 7, 7.9.2009</td><td>12.0.0</td><td>CC=gcc, CXX=g++</td><td>Ubuntu 16.04+, CentOS 7+</td><td>This is for developers who familiar with CentOS on aarch64 architecture</td></tr>
<tr><td><code>manylinux2010_x86_64</code></td><td>x86_64</td><td>CentOS 6, 6.10</td><td>12.0.0</td><td>CC=gcc, CXX=g++</td><td>Ubuntu 14.04+, CentOS 6+</td><td>This is for developers who familiar with legacy system on x86_64 architecture, EOL</td></tr>
<tr><td><code>manylinux1_x86_64</code></td><td>x86_64</td><td>CentOS 5, 5.11</td><td>12.0.0</td><td>CC=gcc, CXX=g++</td><td>Ubuntu 14.04+, CentOS 5+</td><td>This is for developers who familiar with legacy system on x86_64 architecture, EOL</td></tr>
</tbody></table>
<h3 id="install-dependencies-on-ubuntu-2004-manually"><a class="header" href="#install-dependencies-on-ubuntu-2004-manually">Install dependencies on Ubuntu 20.04 manually</a></h3>
<pre><code class="language-bash"># Tools and libraries
sudo apt install -y \
   software-properties-common \
   cmake \
   libboost-all-dev

# And you will need to install llvm for wasmedgec tool
sudo apt install -y \
   llvm-12-dev \
   liblld-12-dev

# WasmEdge supports both clang++ and g++ compilers
# You can choose one of them for building this project
# If you prefer GCC
sudo apt install -y gcc g++
# Else you can choose clang
sudo apt install -y clang-12
</code></pre>
<h3 id="support-for-legacy-operating-systems"><a class="header" href="#support-for-legacy-operating-systems">Support for legacy operating systems</a></h3>
<p>Our development environment requires <code>libLLVM-12</code> and <code>&gt;=GLIBCXX_3.4.33</code>.</p>
<p>If users are using the older operating system than Ubuntu 20.04, please use our special docker image to build WasmEdge.
If you are looking for the pre-built binaries for the older operating system, we also provide several pre-built binaries based on manylinux* distribution.</p>
<table><thead><tr><th>Portable Linux Built Distributions Tags</th><th>Base Image</th><th>Provided Requirements</th><th>Docker Image</th></tr></thead><tbody>
<tr><td><code>manylinux1</code></td><td>CentOS 5.11</td><td>GLIBC &lt;= 2.5</br>CXXABI &lt;= 3.4.8</br>GLIBCXX &lt;= 3.4.9</br>GCC &lt;= 4.2.0</td><td>wasmedge/wasmedge:manylinux1_x86_64</td></tr>
<tr><td><code>manylinux2010</code></td><td>CentOS 6.10</td><td>GLIBC &lt;= 2.12</br>CXXABI &lt;= 1.3.3</br>GLIBCXX &lt;= 3.4.13</br>GCC &lt;= 4.5.0</td><td>wasmedge/wasmedge:manylinux2010_x86_64</td></tr>
<tr><td><code>manylinux2014</code></td><td>CentOS 7.9</td><td>GLIBC &lt;= 2.17</br>CXXABI &lt;= 1.3.7</br>GLIBCXX &lt;= 3.4.19</br>GCC &lt;= 4.8.0</td><td>wasmedge/wasmedge:manylinux2014_x86_64</td></tr>
<tr><td><code>manylinux2014</code></td><td>CentOS 7.9</td><td>GLIBC &lt;= 2.17</br>CXXABI &lt;= 1.3.7</br>GLIBCXX &lt;= 3.4.19</br>GCC &lt;= 4.8.0</td><td>wasmedge/wasmedge:manylinux2014_aarch64</td></tr>
</tbody></table>
<h2 id="build-wasmedge"><a class="header" href="#build-wasmedge">Build WasmEdge</a></h2>
<p>WasmEdge provides various tools for enabling different runtime environments for optimal performance.
After the build is finished, you can find there are several wasmedge related tools:</p>
<ol>
<li><code>wasmedge</code> is for general wasm runtime.
<ul>
<li><code>wasmedge</code> executes a <code>WASM</code> file in interpreter mode or a compiled WASM <code>so</code> file in ahead-of-time compilation mode.</li>
<li>To disable building all tools, you can set the CMake option <code>WASMEDGE_BUILD_TOOLS</code> to <code>OFF</code>.</li>
</ul>
</li>
<li><code>wasmedgec</code> is for ahead-of-time <code>WASM</code> compiler.
<ul>
<li><code>wasmedgec</code> compiles a general <code>WASM</code> file into a <code>so</code> file.</li>
<li>To disable building the ahead-of-time compiler only, you can set the CMake option <code>WASMEDGE_BUILD_AOT_RUNTIME</code> to <code>OFF</code>.</li>
</ul>
</li>
<li><code>libwasmedge_c.so</code> is the WasmEdge C API shared library.
<ul>
<li><code>libwasmedge_c.so</code> provides C API for the ahead-of-time compiler and the WASM runtime.</li>
<li>The APIs about the ahead-of-time compiler will always return failed if the CMake option <code>WASMEDGE_BUILD_AOT_RUNTIME</code> is set as <code>OFF</code>.</li>
<li>To disable building the shared library only, you can set the CMake option <code>WASMEDGE_BUILD_SHARED_LIB</code> to <code>OFF</code>.</li>
</ul>
</li>
<li><code>ssvm-qitc</code> is for AI application, supporting ONNC runtime for AI model in ONNX format.
<ul>
<li>If you want to try <code>ssvm-qitc</code>, please refer to <a href="https://github.com/ONNC/onnc-wasm">ONNC-Wasm</a> project to set up the working environment and run several examples.</li>
<li>And here is our <a href="https://www.youtube.com/watch?v=cbiPuHMS-iQ">tutorial for ONNC-Wasm project(YouTube Video)</a>.</li>
</ul>
</li>
</ol>
<pre><code class="language-bash"># After pulling our wasmedge docker image
docker run -it --rm \
    -v &lt;path/to/your/wasmedge/source/folder&gt;:/root/wasmedge \
    wasmedge/wasmedge:latest
# In docker
cd /root/wasmedge
mkdir -p build &amp;&amp; cd build
cmake -DCMAKE_BUILD_TYPE=Release -DWASMEDGE_BUILD_TESTS=ON .. &amp;&amp; make -j
</code></pre>
<h3 id="if-you-dont-want-to-build-ahead-of-time-runtimecompiler"><a class="header" href="#if-you-dont-want-to-build-ahead-of-time-runtimecompiler">If you don't want to build Ahead-of-Time runtime/compiler</a></h3>
<p>If you don't need Ahead-of-Time runtime/compiler support, you can set the CMake option <code>WASMEDGE_BUILD_AOT_RUNTIME</code> to <code>OFF</code>.</p>
<pre><code class="language-bash">cmake -DCMAKE_BUILD_TYPE=Release -DWASMEDGE_BUILD_AOT_RUNTIME=OFF ..
</code></pre>
<h2 id="run-built-in-tests"><a class="header" href="#run-built-in-tests">Run built-in tests</a></h2>
<p>The following built-in tests are only available when the build flag <code>WASMEDGE_BUILD_TESTS</code> sets to <code>ON</code>.</p>
<p>Users can use these tests to verify the correctness of WasmEdge binaries.</p>
<pre><code class="language-bash"># In docker
cd &lt;path/to/wasmedge/build_folder&gt;
LD_LIBRARY_PATH=$(pwd)/lib/api ctest
</code></pre>
<h2 id="run-applications"><a class="header" href="#run-applications">Run applications</a></h2>
<p>Next, follow <a href="extend/../index.html">this guide</a> to run WebAssembly bytecode programs in <code>wasmedge</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="build-from-source-on-macos"><a class="header" href="#build-from-source-on-macos">Build from source on MacOS</a></h1>
<p>Currently, WasmEdge project on MacOS supports both Intel and M1 models. However, we only test and develop on Big Sur and Catalina.</p>
<ul>
<li>Model:
<ul>
<li>Intel</li>
<li>M1</li>
</ul>
</li>
<li>Operating System
<ul>
<li>Big Sur</li>
<li>Catalina</li>
</ul>
</li>
</ul>
<p>If you would like to develop WasmEdge on MacOS, please follow this guide to build and test from source code.</p>
<h2 id="get-source-code-1"><a class="header" href="#get-source-code-1">Get Source Code</a></h2>
<pre><code class="language-bash">git clone https://github.com/WasmEdge/WasmEdge.git
cd WasmEdge
</code></pre>
<h2 id="requirements-and-dependencies"><a class="header" href="#requirements-and-dependencies">Requirements and Dependencies</a></h2>
<p>WasmEdge will try to use the latest LLVM release to create our nightly build.
If you want to build from source, you may need to install these dependencies by yourself.</p>
<ul>
<li>LLVM 12.0.0 (&gt;= 10.0.0), installed via brew, please don't use the built-in one.</li>
<li>Because the default version of LLVM on the latest brew is 13. Please use <code>llvm@12</code> to fix the LLVM version.</li>
</ul>
<h3 id="prepare-the-environment-1"><a class="header" href="#prepare-the-environment-1">Prepare the environment</a></h3>
<pre><code class="language-bash"># Tools and libraries
brew install boost cmake ninja llvm@12
# Use brew version of llvm, not the built-in one.
export PATH=&quot;/usr/local/opt/llvm@12/bin:$PATH&quot;
export LDFLAGS=&quot;-L/usr/local/opt/llvm@12/lib -Wl,-rpath,/usr/local/opt/llvm@12/lib&quot;
export CPPFLAGS=&quot;-I/usr/local/opt/llvm@12/include&quot;
</code></pre>
<h3 id="if-you-dont-want-to-build-ahead-of-time-runtimecompiler-1"><a class="header" href="#if-you-dont-want-to-build-ahead-of-time-runtimecompiler-1">If you don't want to build Ahead-of-Time runtime/compiler</a></h3>
<p>If you don't need Ahead-of-Time runtime/compiler support, you can set the CMake option <code>WASMEDGE_BUILD_AOT_RUNTIME</code> to <code>OFF</code>.</p>
<pre><code class="language-bash">cmake -DCMAKE_BUILD_TYPE=Release -DWASMEDGE_BUILD_AOT_RUNTIME=OFF ..
</code></pre>
<h2 id="build-wasmedge-1"><a class="header" href="#build-wasmedge-1">Build WasmEdge</a></h2>
<p>WasmEdge provides various tools for enabling different runtime environments for optimal performance.
After the build is finished, you can find there are several wasmedge related tools:</p>
<ol>
<li><code>wasmedge</code> is for general wasm runtime.
<ul>
<li><code>wasmedge</code> executes a <code>WASM</code> file in interpreter mode or a compiled WASM <code>dyld</code> file in ahead-of-time compilation mode.</li>
<li>To disable building all tools, you can set the CMake option <code>WASMEDGE_BUILD_TOOLS</code> to <code>OFF</code>.</li>
</ul>
</li>
<li><code>wasmedgec</code> is for ahead-of-time <code>WASM</code> compiler.
<ul>
<li><code>wasmedgec</code> compiles a general <code>WASM</code> file into a <code>dyld</code> file.</li>
<li>To disable building the ahead-of-time compiler only, you can set the CMake option <code>WASMEDGE_BUILD_AOT_RUNTIME</code> to <code>OFF</code>.</li>
</ul>
</li>
<li><code>libwasmedge_c.dyld</code> is the WasmEdge C API shared library.
<ul>
<li><code>libwasmedge_c.dyld</code> provides C API for the ahead-of-time compiler and the WASM runtime.</li>
<li>The APIs about the ahead-of-time compiler will always return failed if the CMake option <code>WASMEDGE_BUILD_AOT_RUNTIME</code> is set as <code>OFF</code>.</li>
<li>To disable building the shared library only, you can set the CMake option <code>WASMEDGE_BUILD_SHARED_LIB</code> to <code>OFF</code>.</li>
</ul>
</li>
</ol>
<pre><code class="language-bash">cmake -Bbuild -GNinja -DWASMEDGE_BUILD_PACKAGE=&quot;TGZ&quot; -DWASMEDGE_BUILD_TESTS=ON .
cmake --build build
</code></pre>
<h2 id="run-built-in-tests-1"><a class="header" href="#run-built-in-tests-1">Run built-in tests</a></h2>
<p>The following built-in tests are only available when the build flag <code>WASMEDGE_BUILD_TESTS</code> sets to <code>ON</code>.</p>
<p>Users can use these tests to verify the correctness of WasmEdge binaries.</p>
<pre><code class="language-bash">export DYLD_LIBRARY_PATH=&quot;$(pwd)/build/lib/api:$DYLD_LIBRARY_PATH&quot;
cmake --build build --target test
</code></pre>
<h2 id="run-applications-1"><a class="header" href="#run-applications-1">Run applications</a></h2>
<p>Next, follow <a href="extend/../index.html">this guide</a> to run WebAssembly bytecode programs in <code>wasmedge</code>.</p>
<h2 id="known-issues"><a class="header" href="#known-issues">Known issues</a></h2>
<p>The following tests can not pass on macos, we are investigating these issues:</p>
<ul>
<li>wasmedgeAPIVMCoreTests</li>
<li>wasmedgeAPIStepsCoreTests</li>
<li>wasmedgeAPIAOTCoreTests</li>
<li>wasmedgeProcessTests</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="build-from-source-on-windows-10"><a class="header" href="#build-from-source-on-windows-10">Build from source on Windows 10</a></h1>
<p>WasmEdge supports Windows 10. Currently, we also provide pre-built binaries and libraries for Windows.</p>
<p>You can find the details <a href="https://github.com/WasmEdge/WasmEdge/blob/master/.github/workflows/build.yml#L266-L322">here</a></p>
<p>If you would like to develop WasmEdge on Windows 10, please follow this guide to build and test from source code.</p>
<h2 id="get-source-code-2"><a class="header" href="#get-source-code-2">Get Source Code</a></h2>
<pre><code class="language-bash">git clone https://github.com/WasmEdge/WasmEdge.git
cd WasmEdge
</code></pre>
<h2 id="requirements-and-dependencies-1"><a class="header" href="#requirements-and-dependencies-1">Requirements and Dependencies</a></h2>
<p>WasmEdge will try to use the latest LLVM release to create our nightly build.
If you want to build from source, you may need to install these dependencies by yourself.</p>
<ul>
<li>Chocolatey, we use it to install cmake, ninja, and vswhere</li>
<li>Windows SDK 19041</li>
<li>LLVM 13.0.0, you can find the pre-built files in the following section.</li>
</ul>
<h3 id="prepare-the-environment-2"><a class="header" href="#prepare-the-environment-2">Prepare the environment</a></h3>
<pre><code class="language-powershell"># Instal tools
choco install cmake ninja vswhere

$vsPath = (vswhere -latest -property installationPath)
Import-Module (Join-Path $vsPath &quot;Common7\Tools\Microsoft.VisualStudio.DevShell.dll&quot;)
Enter-VsDevShell -VsInstallPath $vsPath -SkipAutomaticLocation -DevCmdArguments &quot;-arch=x64 -host_arch=x64 -winsdk=10.0.19041.0&quot;

# Download our pre-built LLVM 13
$llvm = &quot;LLVM-13.0.0-win64.zip&quot;
curl -sLO https://github.com/WasmEdge/llvm-windows/releases/download/llvmorg-13.0.0/LLVM-13.0.0-win64.zip -o $llvm
Expand-Archive -Path $llvm

# Set LLVM environment
$llvm_dir = &quot;$pwd\\LLVM-13.0.0-win64\\LLVM-13.0.0-win64\\lib\\cmake\\llvm&quot;
$Env:CC = &quot;clang-cl&quot;
$Env:CXX = &quot;clang-cl&quot;
</code></pre>
<h3 id="if-you-dont-want-to-build-ahead-of-time-runtimecompiler-2"><a class="header" href="#if-you-dont-want-to-build-ahead-of-time-runtimecompiler-2">If you don't want to build Ahead-of-Time runtime/compiler</a></h3>
<p>If you don't need Ahead-of-Time runtime/compiler support, you can set the CMake option <code>WASMEDGE_BUILD_AOT_RUNTIME</code> to <code>OFF</code>.</p>
<pre><code class="language-bash">cmake -DCMAKE_BUILD_TYPE=Release -DWASMEDGE_BUILD_AOT_RUNTIME=OFF ..
</code></pre>
<h2 id="build-wasmedge-2"><a class="header" href="#build-wasmedge-2">Build WasmEdge</a></h2>
<p>WasmEdge provides various tools for enabling different runtime environments for optimal performance.
After the build is finished, you can find there are several wasmedge related tools:</p>
<ol>
<li><code>wasmedge</code> is for general wasm runtime.
<ul>
<li><code>wasmedge</code> executes a <code>WASM</code> file in interpreter mode or a compiled WASM <code>dll</code> file in ahead-of-time compilation mode.</li>
<li>To disable building all tools, you can set the CMake option <code>WASMEDGE_BUILD_TOOLS</code> to <code>OFF</code>.</li>
</ul>
</li>
<li><code>wasmedgec</code> is for ahead-of-time <code>WASM</code> compiler.
<ul>
<li><code>wasmedgec</code> compiles a general <code>WASM</code> file into a <code>dll</code> file.</li>
<li>To disable building the ahead-of-time compiler only, you can set the CMake option <code>WASMEDGE_BUILD_AOT_RUNTIME</code> to <code>OFF</code>.</li>
</ul>
</li>
<li><code>libwasmedge_c.dll</code> is the WasmEdge C API shared library.
<ul>
<li><code>libwasmedge_c.dll</code> provides C API for the ahead-of-time compiler and the WASM runtime.</li>
<li>The APIs about the ahead-of-time compiler will always return failed if the CMake option <code>WASMEDGE_BUILD_AOT_RUNTIME</code> is set as <code>OFF</code>.</li>
<li>To disable building the shared library only, you can set the CMake option <code>WASMEDGE_BUILD_SHARED_LIB</code> to <code>OFF</code>.</li>
</ul>
</li>
</ol>
<pre><code class="language-bash">$vsPath = (vswhere -latest -property installationPath)
Import-Module (Join-Path $vsPath &quot;Common7\Tools\Microsoft.VisualStudio.DevShell.dll&quot;)
Enter-VsDevShell -VsInstallPath $vsPath -SkipAutomaticLocation -DevCmdArguments &quot;-arch=x64 -host_arch=x64 -winsdk=10.0.19041.0&quot;

cmake -Bbuild -GNinja -DCMAKE_SYSTEM_VERSION=10.0.19041.0 -DCMAKE_MSVC_RUNTIME_LIBRARY=MultiThreadedDLL &quot;-DLLVM_DIR=$llvm_dir&quot; -DWASMEDGE_BUILD_TESTS=ON -DWASMEDGE_BUILD_PACKAGE=&quot;ZIP&quot; .
cmake --build build
</code></pre>
<h2 id="run-built-in-tests-2"><a class="header" href="#run-built-in-tests-2">Run built-in tests</a></h2>
<p>The following built-in tests are only available when the build flag <code>WASMEDGE_BUILD_TESTS</code> sets to <code>ON</code>.</p>
<p>Users can use these tests to verify the correctness of WasmEdge binaries.</p>
<pre><code class="language-bash">$vsPath = (vswhere -latest -property installationPath)
Import-Module (Join-Path $vsPath &quot;Common7\Tools\Microsoft.VisualStudio.DevShell.dll&quot;)
Enter-VsDevShell -VsInstallPath $vsPath -SkipAutomaticLocation -DevCmdArguments &quot;-arch=x64 -host_arch=x64 -winsdk=10.0.19041.0&quot;

$Env:PATH += &quot;;$pwd\\build\\lib\\api&quot;
cd build
ctest --output-on-failure
cd -
</code></pre>
<h2 id="run-applications-2"><a class="header" href="#run-applications-2">Run applications</a></h2>
<p>Next, follow <a href="extend/run.html">this guide</a> to run WebAssembly bytecode programs in <code>wasmedge</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="build-from-source-for-android-platforms"><a class="header" href="#build-from-source-for-android-platforms">Build from source for Android platforms</a></h1>
<p>Please follow this guide to build and test WasmEdge from source code with Android NDK.</p>
<blockquote>
<p>In current state, we only support the runtime for the interpreter mode.</p>
</blockquote>
<h2 id="prepare-the-environment-3"><a class="header" href="#prepare-the-environment-3">Prepare the Environment</a></h2>
<p>We recommand developers to <a href="extend/build.html##prepare-the-environment">use our Docker images</a> and follow the steps to prepare the building environment.</p>
<ul>
<li>Download and extract the <a href="https://developer.android.com/ndk/downloads">Android NDK 23b</a>.</li>
<li>Check the cmake for <a href="https://cmake.org/download/">CMake 3.21</a> or greater version.</li>
<li>Download and install the <a href="https://developer.android.com/studio/releases/platform-tools">ADB platform tools</a>.
<ul>
<li>If you use the debian or ubuntu Linux distributions, you can install the ADB platform tools via <code>apt</code>.</li>
</ul>
</li>
<li>An Android device which is <a href="https://developer.android.com/studio/debug/dev-options">enabled developer options and USB debugging</a> and with at least Android 6.0 or higher system version.</li>
</ul>
<h2 id="build-wasmedge-for-android-platforms"><a class="header" href="#build-wasmedge-for-android-platforms">Build WasmEdge for Android platforms</a></h2>
<p>Get the WasmEdge source code.</p>
<pre><code class="language-bash">git clone https://github.com/WasmEdge/WasmEdge.git
cd WasmEdge
</code></pre>
<p>Add the Android NDK path into the environment variable.</p>
<pre><code class="language-bash">export ANDROID_NDK_HOME=path/to/you/ndk/dir
</code></pre>
<p>Run the build script in WasmEdge source code. This script will automatically build the WasmEdge for Android, and the results are in the <code>build</code> folder.</p>
<pre><code class="language-bash">./utils/android/standalone/build_for_android.sh
</code></pre>
<h2 id="test-the-wasmedge-cli-on-android-platforms"><a class="header" href="#test-the-wasmedge-cli-on-android-platforms">Test the WasmEdge CLI on Android platforms</a></h2>
<h3 id="push-the-wasmedge-cli-and-related-test-data-onto-android-platforms"><a class="header" href="#push-the-wasmedge-cli-and-related-test-data-onto-android-platforms">Push the WasmEdge CLI and related test data onto Android platforms</a></h3>
<ol>
<li>
<p>Connect the device by using a USB cable or Wi-Fi. Then you can check the attached devices via the <code>adb devices</code> command.</p>
<pre><code class="language-bash">$ adb devices
List of devices attached
0a388e93      device
</code></pre>
</li>
<li>
<p>Use the <code>adb push</code> command to push the entire <code>build/tools/wasmedge</code> folder into the <code>/data/local/tmp</code> folder on your Android device.</p>
<pre><code class="language-bash">cd build
adb push ./tools/wasmedge /data/local/tmp  
</code></pre>
</li>
</ol>
<h3 id="run-wasmedge-cli-on-android-platforms"><a class="header" href="#run-wasmedge-cli-on-android-platforms">Run WasmEdge CLI on Android platforms</a></h3>
<ol>
<li>Please use the <code>adb shell</code> command to access into the Android device.</li>
<li>Follow the steps to test the WasmEdge CLI on the Android device.</li>
</ol>
<pre><code class="language-bash">$ cd /data/local/tmp/wasmedge/examples
$ ../wasmedge hello.wasm 1 2 3                                                           
hello
1
2
3

$ ../wasmedge --reactor add.wasm add 2 2
4

$ ../wasmedge --reactor fibonacci.wasm fib 8
34

$ ../wasmedge --reactor factorial.wasm fac 12
479001600

$ cd js
$ ./../wasmedge --dir .:. qjs.wasm hello.js 1 2 3
Hello 1 2 3
</code></pre>
<h2 id="notice"><a class="header" href="#notice">Notice</a></h2>
<ul>
<li>For the Android 10 or greater versions, SELinux will disallow the untrusted applications' <code>exec()</code> system call to execute the binaries in <code>home</code> or <code>/data/local/tmp</code> folder.</li>
<li>The Android SELinux policy will disallow the untrusted applications to access the <code>/data/local/tmp</code> folder.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="wasmedge-plug-in-api"><a class="header" href="#wasmedge-plug-in-api">WasmEdge plug-in API</a></h1>
<p>WasmEdge provides a C++ based API for registering extensions and host functions. While the WasmEdge language SDKs allow registering host functions from a host (wrapping) application, the plugin API allows such extensions to be incorporated into WasmEdge's own building and releasing process.</p>
<p>In fact, the WasmEdge extensions for Tensorflow, image processing, key-value storage etc are all implemented using the plugin API. The plugin API is how you could contribute new functions to the WasmEdge Runtime itself.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="host-functions-2"><a class="header" href="#host-functions-2">Host Functions</a></h1>
<p><a href="https://webassembly.github.io/spec/core/exec/runtime.html#syntax-hostfunc">Host functions</a> are functions outside WebAssembly and passed to WASM modules as imports. The following steps give an example of registering a <code>host module</code> into WasmEdge runtime.</p>
<p>This example is for the sources compile with the WasmEdge project in C++.
If developers want to implement the host functions in C/C++ with WasmEdge C API and without compiling with the WasmEdge project, please refer to the <a href="extend/plugin/../../embed/c/ref.html#host-functions">C API Documentation</a>.</p>
<h2 id="definitions-of-host-instances"><a class="header" href="#definitions-of-host-instances">Definitions of Host Instances</a></h2>
<p>WasmEdge supports registering <code>host function</code>, <code>memory</code>, <code>table</code>, and <code>global</code> instances as imports.
For more details, samples can be found in <code>include/host/wasi/</code> and <code>test/core/spectest.h</code>.</p>
<h3 id="functions-1"><a class="header" href="#functions-1">Functions</a></h3>
<p>A simple host function class can be declared as follows:</p>
<pre><code class="language-cpp">#include &quot;common/errcode.h&quot;
#include &quot;runtime/hostfunc.h&quot;
#include &quot;runtime/instance/memory.h&quot;

namespace WasmEdge {
namespace Host {

class TestHost : public Runtime::HostFunction&lt;TestHost&gt; {
public:
  Expect&lt;uint32_t&gt; body(Runtime::Instance::MemoryInstance *MemInst, uint32_t Param1, float Param2);
};

} // namespace Host
} // namespace WasmEdge
</code></pre>
<p>According to example, return type <code>Expect&lt;T&gt;</code> presents the expected return number type <code>T</code> of this host function. Types of <code>Param1</code> and <code>Param2</code> presents argument types of this <code>host function</code>. Only WASM built-in types (aka. <code>uint32_t</code>, <code>uint64_t</code>, <code>float</code>, and <code>double</code>) are supported in <code>host functions</code>. When instantiating, the function signature of <code>vec(valtype) -&gt; resulttype</code> is generated and can be imported by WASM modules.</p>
<p>Note: In the current state, only a single value returning is supported.</p>
<p>Another situation is passing environments or information which need to be accessed by <code>host function</code> body. The following sample shows how to implement host function clusters:</p>
<pre><code class="language-cpp">#include &quot;common/errcode.h&quot;
#include &quot;runtime/hostfunc.h&quot;
#include &quot;runtime/instance/memory.h&quot;
#include &lt;vector&gt;

namespace WasmEdge {
namespace Host {

template &lt;typename T&gt; class TestCluster : public Runtime::HostFunction&lt;T&gt; {
public:
  TestCluster(std::vector&lt;uint8_t&gt; &amp;Vec) : Data(Vec) {}

protected:
  std::vector&lt;uint8_t&gt; &amp;Data;
};

class TestHost1 : public TestCluster&lt;TestHost1&gt; {
public:
  TestHost1(std::vector&lt;uint8_t&gt; &amp;Vec) : TestCluster(Vec) {}
  Expect&lt;uint32_t&gt; body(Runtime::Instance::MemoryInstance *MemInst, uint32_t Param1, float Param2) {
    // Operations to `Data` ...
    return {};
  }
};

class TestHost2 : public TestCluster&lt;TestHost2&gt; {
public:
  TestHost2(std::vector&lt;uint8_t&gt; &amp;Vec) : TestCluster(Vec) {}
  Expect&lt;uint64_t&gt; body(Runtime::Instance::MemoryInstance *MemInst, uint64_t Param1, double Param2) {
    // Operations to `Data` ...
    return {};
  }
};

} // namespace Host
} // namespace WasmEdge
</code></pre>
<h3 id="tables-memories-and-globals"><a class="header" href="#tables-memories-and-globals">Tables, Memories, and Globals</a></h3>
<p>To create a <code>host table</code>, <code>memory</code>, and <code>global</code> instance, the only way is to create them with their constructor in the <code>host module</code>. The following chapter about the <code>host module</code> will provide examples.</p>
<h2 id="host-modules"><a class="header" href="#host-modules">Host Modules</a></h2>
<p><code>Host module</code> is an object which can be registered into WasmEdge runtime. <code>Host module</code> contains <code>host functions</code>, <code>tables</code>, <code>memories</code>, <code>globals</code>, and other user-customized data. WasmEdge provides API to register <code>host modules</code>. After registering, these host instances in the <code>host module</code> can be imported by WASM modules.</p>
<h3 id="declaration"><a class="header" href="#declaration">Declaration</a></h3>
<p><code>Host module</code> supplies exported module name and can contain customized data. A module name is needed when constructing <code>host modules</code>.</p>
<pre><code class="language-cpp">#include &quot;common/errcode.h&quot;
#include &quot;runtime/hostfunc.h&quot;
#include &quot;runtime/importobj.h&quot;

namespace WasmEdge {
namespace Host {

class TestModule : public Runtime::ImportObject {
public:
  TestModule() : ImportObject(&quot;test&quot;);
  virtual ~TestModule() = default;
};

} // namespace Host
} // namespace WasmEdge
</code></pre>
<h3 id="add-instances"><a class="header" href="#add-instances">Add Instances</a></h3>
<p><code>Host module</code> provides <code>addHostFunc()</code>, <code>addHostTable()</code>, <code>addHostMemory()</code>, and <code>addHostGlobal()</code> to insert instances with their unique names. Insertion can be done in constructor. The following example also shows how to create <code>host memories</code>, <code>tables</code>, and <code>globals</code>.</p>
<pre><code class="language-cpp">#include &quot;common/errcode.h&quot;
#include &quot;runtime/hostfunc.h&quot;
#include &quot;runtime/importobj.h&quot;
#include &lt;memory&gt;
#include &lt;vector&gt;

namespace WasmEdge {
namespace Host {

template &lt;typename T&gt; class TestCluster : public Runtime::HostFunction&lt;T&gt; {
public:
  TestCluster(std::vector&lt;uint8_t&gt; &amp;Vec) : Data(Vec) {}

protected:
  std::vector&lt;uint8_t&gt; &amp;Data;
};

class TestHost1 : public TestCluster&lt;TestHost1&gt; {
public:
  TestHost1(std::vector&lt;uint8_t&gt; &amp;Vec) : TestCluster(Vec) {}
  Expect&lt;uint32_t&gt; body(Runtime::Instance::MemoryInstance *MemInst, uint32_t Param1, float Param2) {
    // Operations to `Data` ...
    return {};
  }
};

class TestHost2 : public TestCluster&lt;TestHost2&gt; {
public:
  TestHost2(std::vector&lt;uint8_t&gt; &amp;Vec) : TestCluster(Vec) {}
  Expect&lt;uint64_t&gt; body(Runtime::Instance::MemoryInstance *MemInst, uint64_t Param1, double Param2) {
    // Operations to `Data` ...
    return {};
  }
};

class TestModule : public Runtime::ImportObject {
public:
  TestModule(std::vector&lt;uint8_t&gt; &amp;Vec) : ImportObject(&quot;test&quot;), Data(Vec) {
    // Add function instances with exporting name
    addHostFunc(&quot;test_func1&quot;, std::make_unique&lt;TestHost1&gt;(Data));
    addHostFunc(&quot;test_func2&quot;, std::make_unique&lt;TestHost2&gt;(Data));

    // Add table instance with exporting name
    addHostTable(&quot;table&quot;, std::make_unique&lt;Runtime::Instance::TableInstance&gt;(
                              TableType(RefType::FuncRef, 10, 20)));

    // Add memory instance with exporting name
    addHostMemory(&quot;memory&quot;, std::make_unique&lt;Runtime::Instance::MemoryInstance&gt;(
                                MemoryType(1, 2)));

    // Add global instance with exporting name
    addHostGlobal(&quot;global_i32&quot;,
                  std::make_unique&lt;Runtime::Instance::GlobalInstance&gt;(
                      GlobalType(ValType::I32, ValMut::Const), uint32_t(666)));
    addHostGlobal(&quot;global_i64&quot;,
                  std::make_unique&lt;Runtime::Instance::GlobalInstance&gt;(
                      GlobalType(ValType::I64, ValMut::Const), uint64_t(666)));
    addHostGlobal(&quot;global_f32&quot;,
                  std::make_unique&lt;Runtime::Instance::GlobalInstance&gt;(
                      GlobalType(ValType::F32, ValMut::Const), float(666)));
    addHostGlobal(&quot;global_f64&quot;,
                  std::make_unique&lt;Runtime::Instance::GlobalInstance&gt;(
                      GlobalType(ValType::F64, ValMut::Const), double(666)));
  }
  virtual ~TestModule() = default;

private:
  std::vector&lt;uint8_t&gt; &amp;Data;
};

} // namespace Host
} // namespace WasmEdge
</code></pre>
<p><code>Host module</code> supplies <code>getFuncs()</code>, <code>getTables()</code>, <code>getMems()</code>, and <code>getGlobals()</code> to search registered instances by unique exporting name. For more details, APIs can be found in <code>include/runtime/importobj.h</code>.</p>
<h3 id="register-host-modules-to-wasmedge"><a class="header" href="#register-host-modules-to-wasmedge">Register Host Modules to WasmEdge</a></h3>
<p>Users can register host modules via <code>WasmEdge::VM::registerModule()</code> API.</p>
<pre><code class="language-cpp">#include &quot;common/configure.h&quot;
#include &quot;vm/vm.h&quot;
#include &lt;vector&gt;

WasmEdge::Configure Conf;
WasmEdge::VM::VM VM(Conf);
std::vector&lt;uint8_t&gt; Data;
WasmEdge::Host::TestModule TestMod(Data);
VM.registerModule(TestMod);
</code></pre>
<h3 id="link-libraries-and-include-directories-in-cmakefile"><a class="header" href="#link-libraries-and-include-directories-in-cmakefile">Link Libraries And Include Directories in CMakeFile</a></h3>
<p>For finding headers from WasmEdge include directories and linking static libraries, some settings are necessary for CMakeFile:</p>
<pre><code class="language-cmake">add_library(wasmedgeHostModuleTest  # Static library name of host modules
  test.cpp  # Path to host modules cpp files
)

target_include_directories(wasmedgeHostModuleTest
  PUBLIC
  ${Boost_INCLUDE_DIRS}
  ${PROJECT_SOURCE_DIR}/include
)
</code></pre>
<h2 id="implementation-of-host-function-body"><a class="header" href="#implementation-of-host-function-body">Implementation of Host Function Body</a></h2>
<p>There are some tips about implementing host function bodies.</p>
<h3 id="checking-memory-instance-when-using"><a class="header" href="#checking-memory-instance-when-using">Checking Memory Instance When Using</a></h3>
<p>Host function can access WASM memory, which passed as <code>MemoryInstance *</code> argument. When a <a href="https://webassembly.github.io/spec/core/exec/instructions.html#function-calls">function call occurs</a>, a frame with module which the called function belonging to will be pushed onto the <code>stack</code>. In the <code>host function</code> case, the <code>memory</code> instance of the module of the top frame on the <code>stack</code> will be passed as the <code>host function</code> body's argument. But there can be no <code>memory</code> instance in a WASM module. Therefore, users should check if the memory instance pointer is a <code>nullptr</code> or not when accessing.</p>
<h3 id="returning-expectation"><a class="header" href="#returning-expectation">Returning Expectation</a></h3>
<p>From our mechanism, <code>Expect&lt;T&gt;</code> declared in <code>include/common/errcode.h</code> is used as the result type of function body. In <code>Expect&lt;void&gt;</code> case, <code>return {};</code> is needed for an expected situation. In other cases, <code>return Value;</code> is needed, where <code>Value</code> is a variable of type <code>T</code>. If an unexpected situation occurs, users can call <code>return Unexpect(Code);</code> to return an error, which <code>Code</code> is an element of enumeration <code>ErrCode</code>.</p>
<h3 id="forcing-termination"><a class="header" href="#forcing-termination">Forcing Termination</a></h3>
<p>WasmEdge provides a method for terminating WASM execution in host functions. Developers can return <code>ErrCode::Terminated</code> to trigger the forcing termination of the current execution and pass the <code>ErrCode::Terminated</code> to the caller of the host functions.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="customized-external-references"><a class="header" href="#customized-external-references">Customized External References</a></h1>
<p><a href="https://webassembly.github.io/reference-types/core/syntax/types.html#syntax-reftype">External References</a> denotes an opaque and unforgeable reference to a host object. A new <code>externref</code> type can be passed into a Wasm module or return from it. The Wasm module cannot reveal an <code>externref</code> value's bit pattern, nor create a fake host reference by an integer value.</p>
<h2 id="tutorial"><a class="header" href="#tutorial">Tutorial</a></h2>
<p>The following tutorial is the summary of the <code>externref</code> example in WasmEdge.</p>
<h3 id="prepare-your-wasm-file"><a class="header" href="#prepare-your-wasm-file">Prepare Your Wasm File</a></h3>
<p>The Wasm file should contain importing host functions that would take the <code>externref</code>.
Take <a href="extend/plugin/../test/externref/externrefTestData/funcs.wasm">the test WASM file</a> (<a href="extend/plugin/../test/externref/externrefTestData/funcs.wat">this WAT</a> is the corresponding text format) as an example:</p>
<pre><code class="language-wasm">(module
  (type $t0 (func (param externref i32) (result i32)))
  (type $t1 (func (param externref i32 i32) (result i32)))
  (type $t2 (func (param externref externref i32 i32) (result i32)))
  (import &quot;extern_module&quot; &quot;functor_square&quot; (func $functor_square (type $t0)))
  (import &quot;extern_module&quot; &quot;class_add&quot; (func $class_add (type $t1)))
  (import &quot;extern_module&quot; &quot;func_mul&quot; (func $func_mul (type $t1)))
  (func $call_add (export &quot;call_add&quot;) (type $t1) (param $p0 externref) (param $p1 i32) (param $p2 i32) (result i32)
    (call $class_add
      (local.get $p0)
      (local.get $p1)
      (local.get $p2)))
  (func $call_mul (export &quot;call_mul&quot;) (type $t1) (param $p0 externref) (param $p1 i32) (param $p2 i32) (result i32)
    (call $func_mul
      (local.get $p0)
      (local.get $p1)
      (local.get $p2)))
  (func $call_square (export &quot;call_square&quot;) (type $t0) (param $p0 externref) (param $p1 i32) (result i32)
    (call $functor_square
      (local.get $p0)
      (local.get $p1)))
  (func $call_add_square (export &quot;call_add_square&quot;) (type $t2) (param $p0 externref) (param $p1 externref) (param $p2 i32) (param $p3 i32) (result i32)
    (call $functor_square
      (local.get $p1)
      (call $class_add
        (local.get $p0)
        (local.get $p2)
        (local.get $p3))))
  (memory $memory (export &quot;memory&quot;) 1))
</code></pre>
<p>Users can convert <code>wat</code> to <code>wasm</code> through <a href="https://webassembly.github.io/wabt/demo/wat2wasm/">wat2wasm</a> live tool. Noted that <code>reference types</code> checkbox should be checked on this page.</p>
<h3 id="implement-host-module-and-register-into-wasmedge"><a class="header" href="#implement-host-module-and-register-into-wasmedge">Implement Host Module and Register into WasmEdge</a></h3>
<p>The host module should be implemented and registered into WasmEdge before executing Wasm. Assume that the following code is saved as <code>main.c</code>:</p>
<pre><code class="language-cpp">#include &lt;wasmedge/wasmedge.h&gt;

#include &lt;stdio.h&gt;

uint32_t SquareFunc(uint32_t A) { return A * A; }
uint32_t AddFunc(uint32_t A, uint32_t B) { return A + B; }
uint32_t MulFunc(uint32_t A, uint32_t B) { return A * B; }

// Host function to call `SquareFunc` by external reference
WasmEdge_Result ExternSquare(void *Data, WasmEdge_MemoryInstanceContext *MemCxt,
                             const WasmEdge_Value *In, WasmEdge_Value *Out) {
  // Function type: {externref, i32} -&gt; {i32}
  uint32_t (*Func)(uint32_t) = WasmEdge_ValueGetExternRef(In[0]);
  uint32_t C = Func(WasmEdge_ValueGetI32(In[1]));
  Out[0] = WasmEdge_ValueGenI32(C);
  return WasmEdge_Result_Success;
}

// Host function to call `AddFunc` by external reference
WasmEdge_Result ExternAdd(void *Data, WasmEdge_MemoryInstanceContext *MemCxt,
                          const WasmEdge_Value *In, WasmEdge_Value *Out) {
  // Function type: {externref, i32, i32} -&gt; {i32}
  uint32_t (*Func)(uint32_t, uint32_t) = WasmEdge_ValueGetExternRef(In[0]);
  uint32_t C = Func(WasmEdge_ValueGetI32(In[1]), WasmEdge_ValueGetI32(In[2]));
  Out[0] = WasmEdge_ValueGenI32(C);
  return WasmEdge_Result_Success;
}

// Host function to call `ExternMul` by external reference
WasmEdge_Result ExternMul(void *Data, WasmEdge_MemoryInstanceContext *MemCxt,
                          const WasmEdge_Value *In, WasmEdge_Value *Out) {
  // Function type: {externref, i32, i32} -&gt; {i32}
  uint32_t (*Func)(uint32_t, uint32_t) = WasmEdge_ValueGetExternRef(In[0]);
  uint32_t C = Func(WasmEdge_ValueGetI32(In[1]), WasmEdge_ValueGetI32(In[2]));
  Out[0] = WasmEdge_ValueGenI32(C);
  return WasmEdge_Result_Success;
}

// Helper function to create the &quot;extern_module&quot; import object.
WasmEdge_ImportObjectContext *CreateExternModule() {
  WasmEdge_String HostName;
  WasmEdge_FunctionTypeContext *HostFType = NULL;
  WasmEdge_FunctionInstanceContext *HostFunc = NULL;
  enum WasmEdge_ValType P[3], R[1];

  HostName = WasmEdge_StringCreateByCString(&quot;extern_module&quot;);
  WasmEdge_ImportObjectContext *ImpObj = WasmEdge_ImportObjectCreate(HostName);
  WasmEdge_StringDelete(HostName);

  // Add host function &quot;functor_square&quot;: {externref, i32} -&gt; {i32}
  P[0] = WasmEdge_ValType_ExternRef;
  P[1] = WasmEdge_ValType_I32;
  R[0] = WasmEdge_ValType_I32;
  HostFType = WasmEdge_FunctionTypeCreate(P, 2, R, 1);
  HostFunc = WasmEdge_FunctionInstanceCreate(HostFType, ExternSquare, NULL, 0);
  WasmEdge_FunctionTypeDelete(HostFType);
  HostName = WasmEdge_StringCreateByCString(&quot;functor_square&quot;);
  WasmEdge_ImportObjectAddFunction(ImpObj, HostName, HostFunc);
  WasmEdge_StringDelete(HostName);

  // Add host function &quot;class_add&quot;: {externref, i32, i32} -&gt; {i32}
  P[2] = WasmEdge_ValType_I32;
  HostFType = WasmEdge_FunctionTypeCreate(P, 3, R, 1);
  HostFunc = WasmEdge_FunctionInstanceCreate(HostFType, ExternAdd, NULL, 0);
  WasmEdge_FunctionTypeDelete(HostFType);
  HostName = WasmEdge_StringCreateByCString(&quot;class_add&quot;);
  WasmEdge_ImportObjectAddFunction(ImpObj, HostName, HostFunc);
  WasmEdge_StringDelete(HostName);

  // Add host function &quot;func_mul&quot;: {externref, i32, i32} -&gt; {i32}
  HostFType = WasmEdge_FunctionTypeCreate(P, 3, R, 1);
  HostFunc = WasmEdge_FunctionInstanceCreate(HostFType, ExternMul, NULL, 0);
  WasmEdge_FunctionTypeDelete(HostFType);
  HostName = WasmEdge_StringCreateByCString(&quot;func_mul&quot;);
  WasmEdge_ImportObjectAddFunction(ImpObj, HostName, HostFunc);
  WasmEdge_StringDelete(HostName);

  return ImpObj;
}

int main() {
  WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(NULL, NULL);
  WasmEdge_ImportObjectContext *ImpObj = CreateExternModule();
  WasmEdge_Value P[3], R[1];
  WasmEdge_String FuncName;
  WasmEdge_Result Res;

  Res = WasmEdge_VMRegisterModuleFromImport(VMCxt, ImpObj);
  if (!WasmEdge_ResultOK(Res)) {
    printf(&quot;Import object registration failed\n&quot;);
    return EXIT_FAILURE;
  }
  Res = WasmEdge_VMLoadWasmFromFile(VMCxt, &quot;funcs.wasm&quot;);
  if (!WasmEdge_ResultOK(Res)) {
    printf(&quot;WASM file loading failed\n&quot;);
    return EXIT_FAILURE;
  }
  Res = WasmEdge_VMValidate(VMCxt);
  if (!WasmEdge_ResultOK(Res)) {
    printf(&quot;WASM validation failed\n&quot;);
    return EXIT_FAILURE;
  }
  Res = WasmEdge_VMInstantiate(VMCxt);
  if (!WasmEdge_ResultOK(Res)) {
    printf(&quot;WASM instantiation failed\n&quot;);
    return EXIT_FAILURE;
  }

  // Test 1: call add -- 1234 + 5678
  P[0] = WasmEdge_ValueGenExternRef(AddFunc);
  P[1] = WasmEdge_ValueGenI32(1234);
  P[2] = WasmEdge_ValueGenI32(5678);
  FuncName = WasmEdge_StringCreateByCString(&quot;call_add&quot;);
  Res = WasmEdge_VMExecute(VMCxt, FuncName, P, 3, R, 1);
  WasmEdge_StringDelete(FuncName);
  if (WasmEdge_ResultOK(Res)) {
    printf(&quot;Test 1 -- `call_add` -- 1234 + 5678 = %d\n&quot;,
           WasmEdge_ValueGetI32(R[0]));
  } else {
    printf(&quot;Test 1 -- `call_add` -- 1234 + 5678 -- failed\n&quot;);
    return EXIT_FAILURE;
  }

  // Test 2: call mul -- 789 * 4321
  P[0] = WasmEdge_ValueGenExternRef(MulFunc);
  P[1] = WasmEdge_ValueGenI32(789);
  P[2] = WasmEdge_ValueGenI32(4321);
  FuncName = WasmEdge_StringCreateByCString(&quot;call_mul&quot;);
  Res = WasmEdge_VMExecute(VMCxt, FuncName, P, 3, R, 1);
  WasmEdge_StringDelete(FuncName);
  if (WasmEdge_ResultOK(Res)) {
    printf(&quot;Test 2 -- `call_mul` -- 789 * 4321 = %d\n&quot;,
           WasmEdge_ValueGetI32(R[0]));
  } else {
    printf(&quot;Test 2 -- `call_mul` -- 789 * 4321 -- failed\n&quot;);
    return EXIT_FAILURE;
  }

  // Test 3: call square -- 8256^2
  P[0] = WasmEdge_ValueGenExternRef(SquareFunc);
  P[1] = WasmEdge_ValueGenI32(8256);
  FuncName = WasmEdge_StringCreateByCString(&quot;call_square&quot;);
  Res = WasmEdge_VMExecute(VMCxt, FuncName, P, 2, R, 1);
  if (WasmEdge_ResultOK(Res)) {
    printf(&quot;Test 3 -- `call_mul` -- 8256 ^ 2 = %d\n&quot;,
           WasmEdge_ValueGetI32(R[0]));
  } else {
    printf(&quot;Test 3 -- `call_mul` -- 8256 ^ 2 -- failed\n&quot;);
    return EXIT_FAILURE;
  }

  return EXIT_SUCCESS;
}
</code></pre>
<h3 id="setup-the-environment-and-compile"><a class="header" href="#setup-the-environment-and-compile">Setup the Environment And Compile</a></h3>
<ol>
<li>
<p>Install the WasmEdge shared library.</p>
<p>Please refer to the <a href="extend/plugin/install.html">Installation</a> for details.</p>
</li>
<li>
<p>Prepare the WASM file and the <code>main.c</code> source file as above.</p>
</li>
<li>
<p>Compile</p>
<pre><code class="language-bash">gcc main.c -lwasmedge_c
# Or you can use g++ for the C++ case, or use the clang.
</code></pre>
</li>
<li>
<p>Run the Test</p>
<pre><code class="language-bash">$ ./a.out
Test 1 -- `call_add` -- 1234 + 5678 = 6912
Test 2 -- `call_mul` -- 789 * 4321 = 3409269
Test 3 -- `call_mul` -- 8256 ^ 2 = 68161536
</code></pre>
</li>
</ol>
<h2 id="wasm-module-with-external-references"><a class="header" href="#wasm-module-with-external-references">Wasm module with External References</a></h2>
<p>Take the following <code>wat</code> for example:</p>
<pre><code class="language-wasm">(module
  (type $t0 (func (param externref i32) (result i32)))
  ;; Import a host function which type is {externref i32} -&gt; {i32}
  (import &quot;extern_module&quot; &quot;functor_square&quot; (func $functor_square (type $t0)))
  ;; Wasm function which type is {externref i32} -&gt; {i32} and exported as &quot;call_square&quot;
  (func $call_square (export &quot;call_square&quot;) (type $t0) (param $p0 externref) (param $p1 i32) (result i32)
    (call $functor_square (local.get $p0) (local.get $p1))
  )
  (memory $memory (export &quot;memory&quot;) 1))
</code></pre>
<p>The Wasm function &quot;<code>call_square</code>&quot; takes an <code>externref</code> parameter, and calls the imported host function <code>functor_square</code> with that <code>externref</code>.
Therefore, the <code>functor_square</code> host function can get the object reference when users call &quot;<code>call_square</code>&quot; Wasm function and pass the object's reference.</p>
<h2 id="wasmedge-externref-example"><a class="header" href="#wasmedge-externref-example">WasmEdge ExternRef Example</a></h2>
<p>The following examples are how to use <code>externref</code> in Wasm with WasmEdge C API.</p>
<h3 id="wasm-code"><a class="header" href="#wasm-code">Wasm Code</a></h3>
<p>The Wasm code must pass the <code>externref</code> to host functions that want to access it.
Take the following <code>wat</code> for example, which is a part of <a href="extend/plugin/../test/externref/externrefTestData/funcs.wat">the test WASM file</a>:</p>
<pre><code class="language-wasm">(module
  (type $t0 (func (param externref i32 i32) (result i32)))
  (import &quot;extern_module&quot; &quot;func_mul&quot; (func $func_mul (type $t0)))
  (func $call_mul (export &quot;call_mul&quot;) (type $t0) (param $p0 externref) (param $p1 i32) (param $p2 i32) (result i32)
    (call $func_mul (local.get $p0) (local.get $p1) (local.get $p2))
  )
  (memory $memory (export &quot;memory&quot;) 1))
</code></pre>
<p>The host function &quot;<code>extern_module::func_mul</code>&quot; takes <code>externref</code> as a function pointer to multiply parameters 1 and 2 and then return the result. The exported Wasm function &quot;<code>call_mul</code>&quot; calls &quot;<code>func_mul</code>&quot; and pass the <code>externref</code> and 2 numbers as arguments.</p>
<h3 id="host-functions-3"><a class="header" href="#host-functions-3">Host Functions</a></h3>
<p>To instantiate the above example Wasm, the host functions must be registered into WasmEdge. See <a href="extend/plugin/../../embed/c/ref.html#host-functions">Host Functions</a> for more details.
The host functions which take <code>externref</code>s must know the original objects' types. We take the function pointer case for example.</p>
<pre><code class="language-c">/* Function to pass as function pointer. */
uint32_t MulFunc(uint32_t A, uint32_t B) { return A * B; }

/* Host function to call function by external reference as a function pointer */
WasmEdge_Result ExternMul(void *, WasmEdge_MemoryInstanceContext *,
                          const WasmEdge_Value *In, WasmEdge_Value *Out) {
  /* Function type: {externref, i32, i32} -&gt; {i32} */
  void *Ptr = WasmEdge_ValueGetExternRef(In[0]);
  uint32_t (*Obj)(uint32_t, uint32_t) = Ptr;
  /*
   * For C++, the `reinterpret_cast` is needed:
   * uint32_t (*Obj)(uint32_t, uint32_t) = 
   *   *reinterpret_cast&lt;uint32_t (*)(uint32_t, uint32_t)&gt;(Ptr);
   */
  uint32_t C = Obj(WasmEdge_ValueGetI32(In[1]), WasmEdge_ValueGetI32(In[2]));
  Out[0] = WasmEdge_ValueGenI32(C);
  return WasmEdge_Result_Success;
}
</code></pre>
<p>&quot;<code>MulFunc</code>&quot; is a function that will be passed into Wasm as <code>externref</code>. In the &quot;<code>func_mul</code>&quot; host function, users can use &quot;<code>WasmEdge_ValueGetExternRef</code>&quot; API to get the pointer from the <code>WasmEdge_Value</code> which contains a <code>externref</code>.</p>
<p>Developers can add the host functions with names into an import object.</p>
<pre><code class="language-c">/* Create an import object. */
WasmEdge_String HostName = WasmEdge_StringCreateByCString(&quot;extern_module&quot;);
WasmEdge_ImportObjectContext *ImpObj = WasmEdge_ImportObjectCreate(HostName);
WasmEdge_StringDelete(HostName);

/* Create a function instance and add into an import object. */
enum WasmEdge_ValType P[3], R[1];
P[0] = WasmEdge_ValType_ExternRef;
P[1] = WasmEdge_ValType_I32;
P[2] = WasmEdge_ValType_I32;
R[0] = WasmEdge_ValType_I32;
WasmEdge_FunctionTypeContext *HostFType = WasmEdge_FunctionTypeCreate(P, 3, R, 1);
WasmEdge_FunctionInstanceContext *HostFunc = WasmEdge_FunctionInstanceCreate(HostFType, ExternFuncMul, NULL, 0);
WasmEdge_FunctionTypeDelete(HostFType);
HostName = WasmEdge_StringCreateByCString(&quot;func_mul&quot;);
WasmEdge_ImportObjectAddFunction(ImpObj, HostName, HostFunc);
WasmEdge_StringDelete(HostName);

...
</code></pre>
<h3 id="execution"><a class="header" href="#execution">Execution</a></h3>
<p>Take <a href="extend/plugin/../test/externref/externrefTestData/funcs.wasm">the test WASM file</a> (<a href="extend/plugin/../test/externref/externrefTestData/funcs.wat">this WAT</a> is the corresponding text format) for example.
Assume that the <code>funcs.wasm</code> is copied into current directory.
The following is the example to execute WASM with <code>externref</code> through the WasmEdge C API.</p>
<pre><code class="language-c">/* Create the VM context. */
WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(NULL, NULL);
/* Create the import object context that contains the host functions. */
WasmEdge_ImportObjectContext *ImpObj = /* Ignored ... */;
/* Assume that the host functions are added into the import object above. */
WasmEdge_Value P[3], R[1];
WasmEdge_String FuncName;
WasmEdge_Result Res;

/* Register the import object into VM. */
Res = WasmEdge_VMRegisterModuleFromImport(VMCxt, ImpObj);
if (!WasmEdge_ResultOK(Res)) {
  printf(&quot;Import object registration failed\n&quot;);
  return EXIT_FAILURE;
}
/* Load WASM from file. */
Res = WasmEdge_VMLoadWasmFromFile(VMCxt, &quot;funcs.wasm&quot;);
if (!WasmEdge_ResultOK(Res)) {
  printf(&quot;WASM file loading failed\n&quot;);
  return EXIT_FAILURE;
}
/* Validate WASM. */
Res = WasmEdge_VMValidate(VMCxt);
if (!WasmEdge_ResultOK(Res)) {
  printf(&quot;WASM validation failed\n&quot;);
  return EXIT_FAILURE;
}
/* Instantiate the WASM module. */
Res = WasmEdge_VMInstantiate(VMCxt);
if (!WasmEdge_ResultOK(Res)) {
  printf(&quot;WASM instantiation failed\n&quot;);
  return EXIT_FAILURE;
}

/* Run a WASM function. */
P[0] = WasmEdge_ValueGenExternRef(AddFunc);
P[1] = WasmEdge_ValueGenI32(1234);
P[2] = WasmEdge_ValueGenI32(5678);
/* Run the `call_add` function. */
FuncName = WasmEdge_StringCreateByCString(&quot;call_add&quot;);
Res = WasmEdge_VMExecute(VMCxt, FuncName, P, 3, R, 1);
WasmEdge_StringDelete(FuncName);
if (WasmEdge_ResultOK(Res)) {
  printf(&quot;Run -- `call_add` -- 1234 + 5678 = %d\n&quot;,
          WasmEdge_ValueGetI32(R[0]));
} else {
  printf(&quot;Run -- `call_add` -- 1234 + 5678 -- failed\n&quot;);
  return EXIT_FAILURE;
}
</code></pre>
<h2 id="passing-objects"><a class="header" href="#passing-objects">Passing Objects</a></h2>
<p>The above example is passing a function reference as <code>externref</code>. The following examples are about how to pass an object reference into WASM as <code>externref</code> in C++.</p>
<h3 id="passing-a-class"><a class="header" href="#passing-a-class">Passing a Class</a></h3>
<p>To pass a class as <code>externref</code>, the object instance is needed.</p>
<pre><code class="language-cpp">class AddClass {
public:
  uint32_t add(uint32_t A, uint32_t B) const { return A + B; }
};

AddClass AC;
</code></pre>
<p>Then users can pass the object into WasmEdge by using <code>WasmEdge_ValueGenExternRef()</code> API.</p>
<pre><code class="language-cpp">WasmEdge_Value P[3], R[1];
P[0] = WasmEdge_ValueGenExternRef(&amp;AC);
P[1] = WasmEdge_ValueGenI32(1234);
P[2] = WasmEdge_ValueGenI32(5678);
WasmEdge_String FuncName = WasmEdge_StringCreateByCString(&quot;call_add&quot;);
WasmEdge_Result Res = WasmEdge_VMExecute(VMCxt, FuncName, P, 3, R, 1);
WasmEdge_StringDelete(FuncName);
if (WasmEdge_ResultOK(Res)) {
  std::cout &lt;&lt; &quot;Result : &quot; &lt;&lt; WasmEdge_ValueGetI32(R[0]) std::endl;
  // Will print `6912`.
} else {
  return EXIT_FAILURE;
}
</code></pre>
<p>In the host function which would access the object by reference, users can use the <code>WasmEdge_ValueGetExternRef()</code> API to retrieve the reference to the object.</p>
<pre><code class="language-cpp">// Modify the `ExternAdd` in the above tutorial.
WasmEdge_Result ExternAdd(void *, WasmEdge_MemoryInstanceContext *,
                          const WasmEdge_Value *In, WasmEdge_Value *Out) {
  // Function type: {externref, i32, i32} -&gt; {i32}
  void *Ptr = WasmEdge_ValueGetExternRef(In[0]);
  AddClass &amp;Obj = *reinterpret_cast&lt;AddClass *&gt;(Ptr);
  uint32_t C =
      Obj.add(WasmEdge_ValueGetI32(In[1]), WasmEdge_ValueGetI32(In[2]));
  Out[0] = WasmEdge_ValueGenI32(C);
  return WasmEdge_Result_Success;
}
</code></pre>
<h3 id="passing-an-object-as-functor"><a class="header" href="#passing-an-object-as-functor">Passing an Object As Functor</a></h3>
<p>As the same as passing a class instance, the functor object instance is needed.</p>
<pre><code class="language-cpp">struct SquareStruct {
  uint32_t operator()(uint32_t Val) const { return Val * Val; }
};

SquareStruct SS;
</code></pre>
<p>Then users can pass the object into WasmEdge by using the <code>WasmEdge_ValueGenExternRef()</code> API.</p>
<pre><code class="language-cpp">WasmEdge_Value P[2], R[1];
P[0] = WasmEdge_ValueGenExternRef(&amp;SS);
P[1] = WasmEdge_ValueGenI32(1024);
WasmEdge_String FuncName = WasmEdge_StringCreateByCString(&quot;call_square&quot;);
WasmEdge_Result Res = WasmEdge_VMExecute(VMCxt, FuncName, P, 2, R, 1);
WasmEdge_StringDelete(FuncName);
if (WasmEdge_ResultOK(Res)) {
  std::cout &lt;&lt; &quot;Result : &quot; &lt;&lt; WasmEdge_ValueGetI32(R[0]) std::endl;
  // Will print `1048576`.
} else {
  return EXIT_FAILURE;
}
</code></pre>
<p>In the host function which would access the object by reference, users can use the <code>WasmEdge_ValueGetExternRef</code> API to retrieve the reference to the object, and the reference is a functor.</p>
<pre><code class="language-cpp">// Modify the `ExternSquare` in the above tutorial.
WasmEdge_Result ExternSquare(void *, WasmEdge_MemoryInstanceContext *,
                          const WasmEdge_Value *In, WasmEdge_Value *Out) {
  // Function type: {externref, i32, i32} -&gt; {i32}
  void *Ptr = WasmEdge_ValueGetExternRef(In[0]);
  SquareStruct &amp;Obj = *reinterpret_cast&lt;SquareStruct *&gt;(Ptr);
  uint32_t C = Obj(WasmEdge_ValueGetI32(In[1]));
  Out[0] = WasmEdge_ValueGenI32(C);
  return WasmEdge_Result_Success;
}
</code></pre>
<h3 id="passing-stl-objects"><a class="header" href="#passing-stl-objects">Passing STL Objects</a></h3>
<p>The <a href="extend/plugin/../test/externref/externrefTestData/stl.wasm">example Wasm binary</a> (<a href="extend/plugin/../test/externref/externrefTestData/stl.wat">this WAT</a> is the corresponding text format) provides functions to interact with host functions which can access C++ STL objects.
Assume that the WASM file <code>stl.wasm</code> is copied into the current directory.</p>
<p>Take the <code>std::ostream</code> and <code>std::string</code> objects for example. Assume that there's a host function accesses to a <code>std::ostream</code> and a <code>std::string</code> through <code>externref</code>s:</p>
<pre><code class="language-cpp">// Host function to output std::string through std::ostream
WasmEdge_Result ExternSTLOStreamStr(void *, WasmEdge_MemoryInstanceContext *,
                                    const WasmEdge_Value *In,
                                    WasmEdge_Value *) {
  // Function type: {externref, externref} -&gt; {}
  void *Ptr0 = WasmEdge_ValueGetExternRef(In[0]);
  void *Ptr1 = WasmEdge_ValueGetExternRef(In[1]);
  std::ostream &amp;RefOS = *reinterpret_cast&lt;std::ostream *&gt;(Ptr0);
  std::string &amp;RefStr = *reinterpret_cast&lt;std::string *&gt;(Ptr1);
  RefOS &lt;&lt; RefStr;
  return WasmEdge_Result_Success;
}
</code></pre>
<p>Assume that the above host function is added into an import object <code>ImpObj</code>, and the <code>ImpObj</code> is register into a VM context <code>VMCxt</code>.
Then users can instantiate the Wasm module:</p>
<pre><code class="language-cpp">WasmEdge_Result Res = WasmEdge_VMLoadWasmFromFile(VMCxt, &quot;stl.wasm&quot;);
if (!WasmEdge_ResultOK(Res)) {
  printf(&quot;WASM file loading failed\n&quot;);
  return EXIT_FAILURE;
}
Res = WasmEdge_VMValidate(VMCxt);
if (!WasmEdge_ResultOK(Res)) {
  printf(&quot;WASM validation failed\n&quot;);
  return EXIT_FAILURE;
}
Res = WasmEdge_VMInstantiate(VMCxt);
if (!WasmEdge_ResultOK(Res)) {
  printf(&quot;WASM instantiation failed\n&quot;);
  return EXIT_FAILURE;
}
</code></pre>
<p>Last, pass the <code>std::cout</code> and a <code>std::string</code> object by external references.</p>
<pre><code class="language-cpp">std::string PrintStr(&quot;Hello world!&quot;);
WasmEdge_Value P[2], R[1];
P[0] = WasmEdge_ValueGenExternRef(&amp;std::cout);
P[1] = WasmEdge_ValueGenExternRef(&amp;PrintStr);
WasmEdge_String FuncName = WasmEdge_StringCreateByCString(&quot;call_ostream_str&quot;);
WasmEdge_Result Res = WasmEdge_VMExecute(VMCxt, FuncName, P, 2, R, 1);
// Will print &quot;Hello world!&quot; to stdout.
WasmEdge_StringDelete(FuncName);
if (!WasmEdge_ResultOK(Res)) {
  return EXIT_FAILURE;
}
</code></pre>
<p>For other C++ STL objects cases, such as <code>std::vector&lt;T&gt;</code>, <code>std::map&lt;T, U&gt;</code>, or <code>std::set&lt;T&gt;</code>, the object can be accessed correctly in host functions if the type in <code>reinterpret_cast</code> is correct.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
    </body>
</html>
