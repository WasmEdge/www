<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>WasmEdge Runtime</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-NGPCK7VF2L"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-NGPCK7VF2L');
</script>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item "><a href="index.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item "><a href="quick_start.html"><strong aria-hidden="true">2.</strong> Quick Start</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="quick_start/install.html"><strong aria-hidden="true">2.1.</strong> Installation And Uninstallation</a></li><li class="chapter-item "><a href="quick_start/use_docker.html"><strong aria-hidden="true">2.2.</strong> Using WasmEdge in Docker</a></li><li class="chapter-item "><a href="quick_start/run_cli.html"><strong aria-hidden="true">2.3.</strong> Running WASM with WasmEdge CLI</a></li><li class="chapter-item "><a href="quick_start/run_in_aot_mode.html"><strong aria-hidden="true">2.4.</strong> Execution in AOT Mode</a></li></ol></li><li class="chapter-item "><a href="features.html"><strong aria-hidden="true">3.</strong> WasmEdge Features</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="features/proposals.html"><strong aria-hidden="true">3.1.</strong> Supported WASM And WASI Proposals</a></li><li class="chapter-item "><a href="features/proprietary_extend.html"><strong aria-hidden="true">3.2.</strong> WasmEdge Proprietary extensions</a></li><li class="chapter-item "><a href="features/integrations.html"><strong aria-hidden="true">3.3.</strong> Integrations</a></li><li class="chapter-item "><a href="features/platforms.html"><strong aria-hidden="true">3.4.</strong> Supported Platforms</a></li><li class="chapter-item "><a href="features/comparison.html"><strong aria-hidden="true">3.5.</strong> Comparison</a></li></ol></li><li class="chapter-item "><a href="use_cases.html"><strong aria-hidden="true">4.</strong> WasmEdge Use Cases</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="use_cases/server_side_render.html"><strong aria-hidden="true">4.1.</strong> Server-Side Rendering Modern Web UI</a></li><li class="chapter-item "><a href="use_cases/microservice.html"><strong aria-hidden="true">4.2.</strong> Microservices</a></li><li class="chapter-item "><a href="use_cases/serverless_faas.html"><strong aria-hidden="true">4.3.</strong> Serverless Function-As-A-Service in Public Clouds</a></li><li class="chapter-item "><a href="use_cases/serverless_saas.html"><strong aria-hidden="true">4.4.</strong> Serverless Software-As-A-Service Functions</a></li><li class="chapter-item "><a href="use_cases/smart_device.html"><strong aria-hidden="true">4.5.</strong> Smart devices</a></li><li class="chapter-item "><a href="use_cases/js_or_dsl_runtime.html"><strong aria-hidden="true">4.6.</strong> JavaScript or Domain Specifc Language Runtime</a></li><li class="chapter-item "><a href="use_cases/kubernetes.html"><strong aria-hidden="true">4.7.</strong> WasmEdge in Kubernetes</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="use_cases/kubernetes/quickstart.html"><strong aria-hidden="true">4.7.1.</strong> Quick start</a></li><li class="chapter-item "><a href="use_cases/kubernetes/demo.html"><strong aria-hidden="true">4.7.2.</strong> Demo apps</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="use_cases/kubernetes/demo/wasi.html"><strong aria-hidden="true">4.7.2.1.</strong> Simple example</a></li><li class="chapter-item "><a href="use_cases/kubernetes/demo/server.html"><strong aria-hidden="true">4.7.2.2.</strong> HTTP service</a></li></ol></li><li class="chapter-item "><a href="use_cases/kubernetes/container.html"><strong aria-hidden="true">4.7.3.</strong> Container runtimes</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="use_cases/kubernetes/container/crun.html"><strong aria-hidden="true">4.7.3.1.</strong> crun</a></li><li class="chapter-item "><a href="use_cases/kubernetes/container/runc.html"><strong aria-hidden="true">4.7.3.2.</strong> runc</a></li><li class="chapter-item "><a href="use_cases/kubernetes/container/youki.html"><strong aria-hidden="true">4.7.3.3.</strong> youki</a></li></ol></li><li class="chapter-item "><a href="use_cases/kubernetes/cri.html"><strong aria-hidden="true">4.7.4.</strong> CRI runtimes</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="use_cases/kubernetes/cri/crio.html"><strong aria-hidden="true">4.7.4.1.</strong> CRI-O</a></li><li class="chapter-item "><a href="use_cases/kubernetes/cri/containerd.html"><strong aria-hidden="true">4.7.4.2.</strong> containerd</a></li></ol></li><li class="chapter-item "><a href="use_cases/kubernetes/kubernetes.html"><strong aria-hidden="true">4.7.5.</strong> Kubernetes</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="use_cases/kubernetes/kubernetes/kubernetes-crio.html"><strong aria-hidden="true">4.7.5.1.</strong> Kubernetes + CRI-O</a></li><li class="chapter-item "><a href="use_cases/kubernetes/kubernetes/kubernetes-containerd.html"><strong aria-hidden="true">4.7.5.2.</strong> Kubernetes + containerd</a></li><li class="chapter-item "><a href="use_cases/kubernetes/kubernetes/kind.html"><strong aria-hidden="true">4.7.5.3.</strong> KinD</a></li><li class="chapter-item "><a href="use_cases/kubernetes/kubernetes/kubeedge.html"><strong aria-hidden="true">4.7.5.4.</strong> KubeEdge</a></li><li class="chapter-item "><a href="use_cases/kubernetes/kubernetes/superedge.html"><strong aria-hidden="true">4.7.5.5.</strong> SuperEdge</a></li><li class="chapter-item "><a href="use_cases/kubernetes/kubernetes/openyurt.html"><strong aria-hidden="true">4.7.5.6.</strong> OpenYurt</a></li></ol></li><li class="chapter-item "><a href="use_cases/kubernetes/docker.html"><strong aria-hidden="true">4.7.6.</strong> Docker</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="use_cases/kubernetes/docker/lxc.html"><strong aria-hidden="true">4.7.6.1.</strong> Slim container</a></li><li class="chapter-item "><a href="use_cases/kubernetes/docker/containerd.html"><strong aria-hidden="true">4.7.6.2.</strong> containerd integration</a></li></ol></li></ol></li><li class="chapter-item "><a href="use_cases/frameworks.html"><strong aria-hidden="true">4.8.</strong> App Frameworks & Platforms</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="use_cases/frameworks/mesh.html"><strong aria-hidden="true">4.8.1.</strong> Service mesh & runtimes</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="use_cases/frameworks/mesh/dapr.html"><strong aria-hidden="true">4.8.1.1.</strong> Dapr</a></li><li class="chapter-item "><a href="use_cases/frameworks/mesh/mosn.html"><strong aria-hidden="true">4.8.1.2.</strong> MOSN</a></li><li class="chapter-item "><a href="use_cases/frameworks/mesh/wasm-nginx-module.html"><strong aria-hidden="true">4.8.1.3.</strong> Nginx</a></li><li class="chapter-item "><a href="use_cases/frameworks/mesh/eventmesh.html"><strong aria-hidden="true">4.8.1.4.</strong> Apache EventMesh</a></li></ol></li><li class="chapter-item "><a href="use_cases/frameworks/app.html"><strong aria-hidden="true">4.8.2.</strong> Application frameworks</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="use_cases/frameworks/app/yomo.html"><strong aria-hidden="true">4.8.2.1.</strong> YoMo</a></li><li class="chapter-item "><a href="use_cases/frameworks/app/reactr.html"><strong aria-hidden="true">4.8.2.2.</strong> Reactr</a></li></ol></li><li class="chapter-item "><a href="use_cases/frameworks/serverless.html"><strong aria-hidden="true">4.8.3.</strong> Serverless platforms</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="use_cases/frameworks/serverless/vercel.html"><strong aria-hidden="true">4.8.3.1.</strong> Vercel</a></li><li class="chapter-item "><a href="use_cases/frameworks/serverless/netlify.html"><strong aria-hidden="true">4.8.3.2.</strong> Netlify</a></li><li class="chapter-item "><a href="use_cases/frameworks/serverless/aws.html"><strong aria-hidden="true">4.8.3.3.</strong> AWS</a></li><li class="chapter-item "><a href="use_cases/frameworks/serverless/tencent.html"><strong aria-hidden="true">4.8.3.4.</strong> Tencent</a></li><li class="chapter-item "><a href="use_cases/frameworks/serverless/secondstate.html"><strong aria-hidden="true">4.8.3.5.</strong> Second State</a></li></ol></li></ol></li></ol></li><li class="chapter-item "><a href="write_wasm.html"><strong aria-hidden="true">5.</strong> Write a WebAssembly Application</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="write_wasm/c.html"><strong aria-hidden="true">5.1.</strong> C</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="write_wasm/c/simd.html"><strong aria-hidden="true">5.1.1.</strong> simd</a></li></ol></li><li class="chapter-item "><a href="write_wasm/rust.html"><strong aria-hidden="true">5.2.</strong> Rust</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="write_wasm/rust/bindgen.html"><strong aria-hidden="true">5.2.1.</strong> Bindgen of Rust Functions</a></li><li class="chapter-item "><a href="write_wasm/rust/wasi.html"><strong aria-hidden="true">5.2.2.</strong> Access OS Services</a></li><li class="chapter-item "><a href="write_wasm/rust/tensorflow.html"><strong aria-hidden="true">5.2.3.</strong> TensorFlow</a></li><li class="chapter-item "><a href="write_wasm/rust/wasinn.html"><strong aria-hidden="true">5.2.4.</strong> Neural Network for WASI</a></li><li class="chapter-item "><a href="write_wasm/rust/wasicrypto.html"><strong aria-hidden="true">5.2.5.</strong> Crypto for WASI</a></li><li class="chapter-item "><a href="write_wasm/rust/networking.html"><strong aria-hidden="true">5.2.6.</strong> Simple HTTP Client & Server</a></li><li class="chapter-item "><a href="write_wasm/rust/networking-https.html"><strong aria-hidden="true">5.2.7.</strong> Simple HTTPS Client & Server</a></li><li class="chapter-item "><a href="write_wasm/rust/networking-nonblocking.html"><strong aria-hidden="true">5.2.8.</strong> Non-Blocking Network Apps</a></li><li class="chapter-item "><a href="write_wasm/rust/ssr.html"><strong aria-hidden="true">5.2.9.</strong> Server-Side Rendering</a></li><li class="chapter-item "><a href="write_wasm/rust/command.html"><strong aria-hidden="true">5.2.10.</strong> Command Interface</a></li></ol></li><li class="chapter-item "><a href="write_wasm/js.html"><strong aria-hidden="true">5.3.</strong> JavaScript</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="write_wasm/js/quickstart.html"><strong aria-hidden="true">5.3.1.</strong> Getting Started</a></li><li class="chapter-item "><a href="write_wasm/js/nodejs.html"><strong aria-hidden="true">5.3.2.</strong> Node.js Compatibility</a></li><li class="chapter-item "><a href="write_wasm/js/networking.html"><strong aria-hidden="true">5.3.3.</strong> Networking Apps</a></li><li class="chapter-item "><a href="write_wasm/js/ssr.html"><strong aria-hidden="true">5.3.4.</strong> React SSR</a></li><li class="chapter-item "><a href="write_wasm/js/tensorflow.html"><strong aria-hidden="true">5.3.5.</strong> TensorFlow</a></li><li class="chapter-item "><a href="write_wasm/js/es6.html"><strong aria-hidden="true">5.3.6.</strong> ES6 Modules</a></li><li class="chapter-item "><a href="write_wasm/js/npm.html"><strong aria-hidden="true">5.3.7.</strong> Node.js & NPM Modules</a></li><li class="chapter-item "><a href="write_wasm/js/modules.html"><strong aria-hidden="true">5.3.8.</strong> Built-in Modules</a></li><li class="chapter-item "><a href="write_wasm/js/rust.html"><strong aria-hidden="true">5.3.9.</strong> Native JS API in Rust</a></li></ol></li><li class="chapter-item "><a href="write_wasm/go.html"><strong aria-hidden="true">5.4.</strong> Go</a></li><li class="chapter-item "><a href="write_wasm/swift.html"><strong aria-hidden="true">5.5.</strong> Swift</a></li><li class="chapter-item "><a href="write_wasm/as.html"><strong aria-hidden="true">5.6.</strong> AssemblyScript</a></li><li class="chapter-item "><a href="write_wasm/kotlin.html"><strong aria-hidden="true">5.7.</strong> Kotlin</a></li><li class="chapter-item "><a href="write_wasm/grain.html"><strong aria-hidden="true">5.8.</strong> Grain</a></li><li class="chapter-item "><a href="write_wasm/python.html"><strong aria-hidden="true">5.9.</strong> Python</a></li></ol></li><li class="chapter-item "><a href="sdk.html"><strong aria-hidden="true">6.</strong> Use WasmEdge Library</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="sdk/c.html"><strong aria-hidden="true">6.1.</strong> C SDK</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="sdk/c/hostfunction.html"><strong aria-hidden="true">6.1.1.</strong> Host Function Implementation</a></li><li class="chapter-item "><a href="sdk/c/externref.html"><strong aria-hidden="true">6.1.2.</strong> ExternRef Example</a></li><li class="chapter-item "><a href="sdk/c/ref.html"><strong aria-hidden="true">6.1.3.</strong> 0.11.1 API references</a></li><li class="chapter-item "><a href="sdk/c/0.10.1/ref.html"><strong aria-hidden="true">6.1.4.</strong> 0.10.1 API references</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="sdk/c/0.10.1/upgrade_to_0.11.0.html"><strong aria-hidden="true">6.1.4.1.</strong> Upgrade to 0.11.0</a></li></ol></li><li class="chapter-item "><a href="sdk/c/0.9.1/ref.html"><strong aria-hidden="true">6.1.5.</strong> 0.9.1 API references</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="sdk/c/0.9.1/upgrade_to_0.10.0.html"><strong aria-hidden="true">6.1.5.1.</strong> Upgrade to 0.10.0</a></li></ol></li></ol></li><li class="chapter-item "><a href="sdk/go.html"><strong aria-hidden="true">6.2.</strong> Go SDK</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="sdk/go/app.html"><strong aria-hidden="true">6.2.1.</strong> Embed WASM apps</a></li><li class="chapter-item "><a href="sdk/go/function.html"><strong aria-hidden="true">6.2.2.</strong> Embed WASM funcs</a></li><li class="chapter-item "><a href="sdk/go/memory.html"><strong aria-hidden="true">6.2.3.</strong> Pass complex data</a></li><li class="chapter-item "><a href="sdk/go/tensorflow.html"><strong aria-hidden="true">6.2.4.</strong> Tensorflow</a></li><li class="chapter-item "><a href="sdk/go/bindgen.html"><strong aria-hidden="true">6.2.5.</strong> Embed bindgen funcs</a></li><li class="chapter-item "><a href="sdk/go/ref.html"><strong aria-hidden="true">6.2.6.</strong> 0.10.0 API references</a></li><li class="chapter-item "><a href="sdk/go/0.9.1/ref.html"><strong aria-hidden="true">6.2.7.</strong> 0.9.1 API references</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="sdk/go/0.9.1/upgrade_to_0.10.0.html"><strong aria-hidden="true">6.2.7.1.</strong> Upgrade to 0.10.0</a></li></ol></li></ol></li><li class="chapter-item "><a href="sdk/node.html"><strong aria-hidden="true">6.3.</strong> Node.js SDK</a></li><li class="chapter-item "><a href="sdk/rust.html"><strong aria-hidden="true">6.4.</strong> Rust SDK</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="sdk/rust/say_hello.html"><strong aria-hidden="true">6.4.1.</strong> Hello World!</a></li><li class="chapter-item "><a href="sdk/rust/memory_manipulation.html"><strong aria-hidden="true">6.4.2.</strong> Memory Manipulation</a></li><li class="chapter-item "><a href="sdk/rust/table_and_funcref.html"><strong aria-hidden="true">6.4.3.</strong> Table and FuncRef</a></li><li class="chapter-item "><a href="sdk/rust/sys_run_host_func.html"><strong aria-hidden="true">6.4.4.</strong> Run a WebAssembly function with WasmEdge low-level APIs</a></li><li class="chapter-item "><a href="sdk/rust/concurrent_fib.html"><strong aria-hidden="true">6.4.5.</strong> Compute Fibonacci numbers concurrently</a></li><li class="chapter-item "><a href="sdk/rust/how_to_use_module_instance.html"><strong aria-hidden="true">6.4.6.</strong> Usage of WasmEdge module instances</a></li></ol></li><li class="chapter-item "><a href="sdk/python.html"><strong aria-hidden="true">6.5.</strong> Python SDK</a></li></ol></li><li class="chapter-item "><a href="cli.html"><strong aria-hidden="true">7.</strong> Use WasmEdge CLI</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="cli/wasmedge.html"><strong aria-hidden="true">7.1.</strong> wasmedge WASM Runner</a></li><li class="chapter-item "><a href="cli/wasmedgec.html"><strong aria-hidden="true">7.2.</strong> wasmedgec AOT Compiler</a></li></ol></li><li class="chapter-item "><a href="plugin.html"><strong aria-hidden="true">8.</strong> Develop WasmEdge Plug-in</a></li><li class="chapter-item "><a href="contribute.html"><strong aria-hidden="true">9.</strong> Contribute to WasmEdge</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="contribute/release_process.html"><strong aria-hidden="true">9.1.</strong> Release Process</a></li><li class="chapter-item "><a href="contribute/contribute.html"><strong aria-hidden="true">9.2.</strong> Contribute Steps</a></li><li class="chapter-item "><a href="contribute/build_from_src.html"><strong aria-hidden="true">9.3.</strong> Build WasmEdge from source</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="contribute/build_from_src/linux.html"><strong aria-hidden="true">9.3.1.</strong> Build on Linux</a></li><li class="chapter-item "><a href="contribute/build_from_src/macos.html"><strong aria-hidden="true">9.3.2.</strong> Build on MacOS</a></li><li class="chapter-item "><a href="contribute/build_from_src/windows.html"><strong aria-hidden="true">9.3.3.</strong> Build on Windows</a></li><li class="chapter-item "><a href="contribute/build_from_src/android.html"><strong aria-hidden="true">9.3.4.</strong> Build for Android</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="contribute/build_from_src/android/cli.html"><strong aria-hidden="true">9.3.4.1.</strong> CLI tools</a></li><li class="chapter-item "><a href="contribute/build_from_src/android/ndk.html"><strong aria-hidden="true">9.3.4.2.</strong> NDK native app</a></li><li class="chapter-item "><a href="contribute/build_from_src/android/apk.html"><strong aria-hidden="true">9.3.4.3.</strong> APK app</a></li></ol></li><li class="chapter-item "><a href="contribute/build_from_src/sel4.html"><strong aria-hidden="true">9.3.5.</strong> Build for seL4</a></li><li class="chapter-item "><a href="contribute/build_from_src/openharmony.html"><strong aria-hidden="true">9.3.6.</strong> Build for OpenHarmony</a></li><li class="chapter-item "><a href="contribute/build_from_src/raspberrypi.html"><strong aria-hidden="true">9.3.7.</strong> Build for Raspberry Pi</a></li><li class="chapter-item "><a href="contribute/build_from_src/plugin_wasi_nn.html"><strong aria-hidden="true">9.3.8.</strong> Build with WASI-NN Plug-in</a></li><li class="chapter-item "><a href="contribute/build_from_src/plugin_wasi_crypto.html"><strong aria-hidden="true">9.3.9.</strong> Build with WASI-Crypto Plug-in</a></li><li class="chapter-item "><a href="contribute/build_from_src/plugin_wasmedge_httpsreq.html"><strong aria-hidden="true">9.3.10.</strong> Build with WasmEdge-HttpsReq Plug-in</a></li></ol></li><li class="chapter-item "><a href="contribute/internal.html"><strong aria-hidden="true">9.4.</strong> WasmEdge Internal</a></li><li class="chapter-item "><a href="contribute/release_process.html"><strong aria-hidden="true">9.5.</strong> Release Process</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">WasmEdge Runtime</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/WasmEdge/WasmEdge" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p><a href="https://github.com/WasmEdge/WasmEdge">WasmEdge</a> is a lightweight, high-performance, and extensible <a href="https://webassembly.org/">WebAssembly</a> runtime for cloud native, edge, and decentralized applications. It powers serverless apps, embedded functions, microservices, smart contracts, and IoT devices. WasmEdge is currently a <a href="https://www.cncf.io/">CNCF (Cloud Native Computing Foundation)</a> <a href="https://www.cncf.io/sandbox-projects/">Sandbox project</a>.</p>
<p>The WasmEdge Runtime provides a well-defined execution sandbox for its contained WebAssembly bytecode program. The runtime offers isolation and protection for operating system resources (e.g., file system, sockets, environment variables, processes) and memory space. The most important use case for WasmEdge is to safely execute user-defined or community-contributed code as plug-ins in a software product (e.g., SaaS, software-defined vehicles, edge nodes, or even blockchain nodes). It enables third-party developers, vendors, suppliers, and community members to extend and customize the software product.</p>
<p>This book will guide the users and developers to work with WasmEdge and show the commonly use cases.</p>
<ul>
<li><a href="quick_start.html">WasmEdge Quick Start</a></li>
<li>Introduce the <a href="use_cases.html">WasmEdge use cases</a></li>
<li><a href="features.html">WasmEdge Features</a></li>
<li><a href="write_wasm.html">Create WebAssembly program</a> from your programming languages</li>
<li>How to use the <a href="sdk.html">WasmEdge Library</a> and the <a href="cli.html">WasmEdge command line tools (CLI)</a></li>
<li>How to <a href="plugin.html">develop a plug-in for WasmEdge</a></li>
</ul>
<p>If you find some issues or have any advisement, welcome to <a href="contribute.html">contribute to WasmEdge</a>!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="quick-start"><a class="header" href="#quick-start">Quick Start</a></h1>
<p>In this chapter, we introduce how to install and run the WASM quickly with WasmEdge runtime.</p>
<ul>
<li><a href="quick_start/install.html">Install and uninstall</a> WasmEdge on your platforms</li>
<li>How to <a href="quick_start/use_docker.html">use WasmEdge Docker images</a></li>
<li><a href="quick_start/run_cli.html">Execute WASM</a> with WasmEdge CLI</li>
<li>Run WASM <a href="quick_start/run_in_aot_mode.html">in Ahead-of-time (AOT) compiled mode</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="wasmedge-installation-and-uninstallation"><a class="header" href="#wasmedge-installation-and-uninstallation">WasmEdge Installation And Uninstallation</a></h1>
<h2 id="quick-install"><a class="header" href="#quick-install">Quick Install</a></h2>
<p>The easiest way to install WasmEdge is to run the following command. Your system should have <code>git</code> and <code>curl</code> as prerequisites.</p>
<pre><code class="language-bash">curl -sSf https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/utils/install.sh | bash
</code></pre>
<p>For <code>Windows 10</code>, you could use Windows Package Manager Client (aka <code>winget.exe</code>) to install WasmEdge with a single command in your terminal.</p>
<pre><code class="language-bash">winget install wasmedge
</code></pre>
<p>If you would like to install WasmEdge with its <a href="https://www.secondstate.io/articles/wasi-tensorflow/">Tensorflow and image processing extensions</a>, please run the following command. It will attempt to install WasmEdge with the <code>tensorflow</code> and <code>image</code> extensions on your system.</p>
<pre><code class="language-bash">curl -sSf https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/utils/install.sh | bash -s -- -e all
</code></pre>
<p>Run the following command to make the installed binary available in the current session.</p>
<pre><code class="language-bash">source $HOME/.wasmedge/env
</code></pre>
<p><strong>That's it!</strong> You can now <a href="quick_start/../cli.html">use WasmEdge from the CLI</a>, or launch it from an application. To update WasmEdge to a new release, just re-run the above command to write over the old files.</p>
<h3 id="trouble-shooting"><a class="header" href="#trouble-shooting">Trouble Shooting</a></h3>
<p>Some users, especially in China, reported that they had encountered the Connection refused error when trying to download the <code>install.sh</code> from the <code>githubusercontent.com</code>.</p>
<p>Please make sure your network connection can access the <code>github.com</code> and <code>githubusercontent.com</code> via VPN.</p>
<pre><code class="language-bash"># The error message
curl -sSf https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/utils/install.sh | bash
curl: (7) Failed to connect to raw.githubusercontent.com port 443: Connection refused
</code></pre>
<h2 id="install-for-all-users"><a class="header" href="#install-for-all-users">Install for All Users</a></h2>
<p>By default, WasmEdge is installed in the <code>$HOME/.wasmedge</code> directory. You can install it into a system directory, such as <code>/usr/local</code> to make it available to all users. To specify an install directory, you can run the <code>install.sh</code> script with the <code>-p</code> flag. You will need to run the following commands as the <code>root</code> user or <code>sudo</code> since they write into system directories.</p>
<pre><code class="language-bash">curl -sSf https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/utils/install.sh | bash -s -- -p /usr/local
</code></pre>
<p>Or, with all extensions:</p>
<pre><code class="language-bash">curl -sSf https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/utils/install.sh | bash -s -- -e all -p /usr/local
</code></pre>
<h2 id="install-the-specific-version-of-wasmedge"><a class="header" href="#install-the-specific-version-of-wasmedge">Install the Specific Version of WasmEdge</a></h2>
<p>The WasmEdge installer script will install the latest official release by default.
You could install the specific version of WasmEdge, including pre-releases or old releases by passing the <code>-v</code> argument to the installer script. Here is an example.</p>
<pre><code class="language-bash">curl -sSf https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/utils/install.sh | bash -s -- -e all -v 0.11.1
</code></pre>
<p>If you are interested in the latest builds from the <code>HEAD</code> of the <code>master</code> branch, which is basically WasmEdge's nightly builds, you can download the release package directly from our Github Action's CI artifact. <a href="https://github.com/WasmEdge/WasmEdge/actions/runs/2969775464#artifacts">Here is an example</a>.</p>
<h2 id="whats-installed"><a class="header" href="#whats-installed">What's Installed</a></h2>
<p>After installation, you have the following directories and files. Here we assume that you installed into the <code>$HOME/.wasmedge</code> directory. You could also change it to <code>/usr/local</code> if you did a system-wide install.
If you used <code>winget</code> to install WasmEdge, the files are located at <code>C:\Program Files\WasmEdge</code>.</p>
<ul>
<li>The <code>$HOME/.wasmedge/bin</code> directory contains the WasmEdge Runtime CLI executable files. You can copy and move them around on your file system.
<ul>
<li>The <code>wasmedge</code> tool is the standard WasmEdge runtime. You can use it from the CLI.
<ul>
<li>Execute a WASM file: <code>wasmedge --dir .:. app.wasm</code></li>
</ul>
</li>
<li>The <code>wasmedgec</code> tool is the ahead-of-time (AOT) compiler to compile a <code>.wasm</code> file into a native <code>.so</code> file (or <code>.dylib</code> on MacOS, <code>.dll</code> on Windows, or <code>.wasm</code> as the universal WASM format on all platforms). The <code>wasmedge</code> can then execute the output file.
<ul>
<li>Compile a WASM file into a AOT-compiled WASM: <code>wasmedgec app.wasm app.so</code></li>
<li>Execute the WASM in AOT mode: <code>wasmedge --dir .:. app.so</code></li>
</ul>
</li>
<li>The <code>wasmedge-tensorflow</code>, <code>wasmedge-tensorflow-lite</code> tools are runtimes that support the WasmEdge tensorflow extension.</li>
</ul>
</li>
<li>The <code>$HOME/.wasmedge/lib</code> directory contains WasmEdge shared libraries, as well as dependency libraries. They are useful for WasmEdge SDKs to launch WasmEdge programs and functions from host applications.</li>
<li>The <code>$HOME/.wasmedge/include</code> directory contains the WasmEdge header files. They are useful for WasmEdge SDKs.</li>
</ul>
<h2 id="uninstall"><a class="header" href="#uninstall">Uninstall</a></h2>
<p>To uninstall WasmEdge, you can run the following command.</p>
<pre><code class="language-bash">bash &lt;(curl -sSf https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/utils/uninstall.sh)
</code></pre>
<p>If the <code>wasmedge</code> binary is not in <code>PATH</code> and it wasn't installed in the default <code>$HOME/.wasmedge</code> folder, then you must provide the installation path.</p>
<pre><code class="language-bash">bash &lt;(curl -sSf https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/utils/uninstall.sh) -p /path/to/parent/folder
</code></pre>
<p>If you wish to uninstall uninteractively, you can pass in the <code>--quick</code> or <code>-q</code> flag.</p>
<pre><code class="language-bash">bash &lt;(curl -sSf https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/utils/uninstall.sh) -q
</code></pre>
<blockquote>
<p>If a parent folder of the <code>wasmedge</code> binary contains <code>.wasmedge</code>, the folder will be considered for removal. For example, the script removes the default <code>$HOME/.wasmedge</code> folder altogether.</p>
</blockquote>
<p>If you used <code>winget</code> to install WasmEdge, run the following command.</p>
<pre><code class="language-bash">`winget` uninstall wasmedge
</code></pre>
<h2 id="install-wasmedge-for-nodejs"><a class="header" href="#install-wasmedge-for-nodejs">Install WasmEdge for Node.js</a></h2>
<p>WasmEdge can run <a href="https://www.secondstate.io/articles/getting-started-with-rust-function/">WebAssembly functions emebedded in Node.js</a> applications. To install the WasmEdge module in your Node.js environment is easy. Just use the <code>npm</code> tool.</p>
<pre><code class="language-bash">npm install -g wasmedge-core # Append --unsafe-perm if permission denied
</code></pre>
<p>To install WasmEdge with <a href="https://www.secondstate.io/articles/wasi-tensorflow/">Tensorflow and other extensions</a>.</p>
<pre><code class="language-bash">npm install -g wasmedge-extensions # Append --unsafe-perm if permission denied
</code></pre>
<p>The <a href="https://www.secondstate.io/faas/">Second State Functions</a> is a WasmEdge-based FaaS service build on Node.js.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="using-wasmedge-in-docker"><a class="header" href="#using-wasmedge-in-docker">Using WasmEdge in Docker</a></h1>
<h2 id="wasmedge-dockerslim"><a class="header" href="#wasmedge-dockerslim">WasmEdge DockerSlim</a></h2>
<p>The <code>wasmedge/slim:{version}</code> Docker images provide a slim WasmEdge images built with <a href="https://dockersl.im">DockerSlim</a> every releases.</p>
<ul>
<li>Image <code>wasmedge/slim-runtime:{version}</code> includes only WasmEdge runtime with <code>wasmedge</code> command.</li>
<li>Image <code>wasmedge/slim:{version}</code> includes the following command line utilities:
<ul>
<li><code>wasmedge</code></li>
<li><code>wasmedgec</code></li>
</ul>
</li>
<li>Image <code>wasmedge/slim-tf:{version}</code> includes the following command line utilities:
<ul>
<li><code>wasmedge</code></li>
<li><code>wasmedgec</code></li>
<li><code>wasmedge-tensorflow-lite</code></li>
<li><code>wasmedge-tensorflow</code></li>
<li><code>show-tflite-tensor</code></li>
</ul>
</li>
<li>The working directory of the release docker image is <code>/app</code>.</li>
</ul>
<h3 id="examples"><a class="header" href="#examples">Examples</a></h3>
<p>Use <code>wasmedgec</code> and <code>wasmedge</code> (<a href="https://github.com/WasmEdge/WasmEdge/tree/master/examples/wasm">link</a>):</p>
<pre><code class="language-bash">$ docker pull wasmedge/slim:0.11.1

$ docker run -it --rm -v $PWD:/app wasmedge/slim:0.11.1 wasmedgec hello.wasm hello.aot.wasm
[2022-07-07 08:15:49.154] [info] compile start
[2022-07-07 08:15:49.163] [info] verify start
[2022-07-07 08:15:49.169] [info] optimize start
[2022-07-07 08:15:49.808] [info] codegen start
[2022-07-07 08:15:50.419] [info] output start
[2022-07-07 08:15:50.421] [info] compile done
[2022-07-07 08:15:50.422] [info] output start

$ docker run -it --rm -v $PWD:/app wasmedge/slim:0.11.1 wasmedge hello.aot.wasm world
hello
world
</code></pre>
<p>Use <code>wasmedge-tensorflow-lite</code> (<a href="https://github.com/WasmEdge/WasmEdge/tree/master/examples/js">link</a>):</p>
<pre><code class="language-bash">$ docker pull wasmedge/slim-tf:0.11.1
$ wget https://raw.githubusercontent.com/second-state/wasmedge-quickjs/main/example_js/tensorflow_lite_demo/aiy_food_V1_labelmap.txt
$ wget https://raw.githubusercontent.com/second-state/wasmedge-quickjs/main/example_js/tensorflow_lite_demo/food.jpg
$ wget https://raw.githubusercontent.com/second-state/wasmedge-quickjs/main/example_js/tensorflow_lite_demo/lite-model_aiy_vision_classifier_food_V1_1.tflite
$ wget https://raw.githubusercontent.com/second-state/wasmedge-quickjs/main/example_js/tensorflow_lite_demo/main.js

$ docker run -it --rm -v $PWD:/app wasmedge/slim-tf:0.11.1 wasmedge-tensorflow-lite --dir .:. qjs_tf.wasm main.js
label:
Hot dog
confidence:
0.8941176470588236
</code></pre>
<h2 id="docker-images-for-building-wasmedge"><a class="header" href="#docker-images-for-building-wasmedge">Docker Images for Building WasmEdge</a></h2>
<p>WasmEdge supports a wide range of Linux distributions dated back to 2014. The official release contains statically linked binaries and libraries for older Linux systems.
The table below shows build targets in WasmEdge's official release packages.</p>
<p>Developers can use the <code>docker pull wasmedge/wasmedge:{tag_name}</code> command to pull the docker image for WasmEdge building.</p>
<div class="table-wrapper"><table><thead><tr><th>tag name</th><th>arch</th><th>based operating system</th><th>LLVM version</th><th>ENVs</th><th>compatibility</th><th>comments</th></tr></thead><tbody>
<tr><td><code>latest</code></td><td>x86_64</td><td>Ubuntu 20.04 LTS</td><td>12.0.0</td><td>CC=clang, CXX=clang++</td><td>Ubuntu 20.04+</td><td>This is for CI, will always use the latest Ubuntu LTS release</td></tr>
<tr><td><code>ubuntu-build-gcc</code></td><td>x86_64</td><td>Ubuntu 20.04 LTS</td><td>12.0.0</td><td>CC=gcc, CXX=g++</td><td>Ubuntu 20.04+</td><td>This is for CI, will always use the latest Ubuntu LTS release</td></tr>
<tr><td><code>ubuntu-build-clang</code></td><td>x86_64</td><td>Ubuntu 20.04 LTS</td><td>12.0.0</td><td>CC=clang, CXX=clang++</td><td>Ubuntu 20.04+</td><td>This is for CI, will always use the latest Ubuntu LTS release</td></tr>
<tr><td><code>ubuntu2004_x86_64</code></td><td>x86_64</td><td>Ubuntu 20.04 LTS</td><td>10.0.0</td><td>CC=gcc, CXX=g++</td><td>Ubuntu 20.04+</td><td>This is for developers who familiar with Ubuntu 20.04 LTS release</td></tr>
<tr><td><code>ubuntu2104_armv7l</code></td><td>armhf</td><td>Ubuntu 21.04</td><td>12.0.0</td><td>CC=gcc, CXX=g++</td><td>Ubuntu 21.04+</td><td>This is for armhf release</td></tr>
<tr><td><code>manylinux2014_x86_64</code></td><td>x86_64</td><td>CentOS 7, 7.9.2009</td><td>12.0.0</td><td>CC=gcc, CXX=g++</td><td>Ubuntu 16.04+, CentOS 7+</td><td>This is for developers who familiar with CentOS on x86_64 architecture</td></tr>
<tr><td><code>manylinux2014_aarch64</code></td><td>aarch64</td><td>CentOS 7, 7.9.2009</td><td>12.0.0</td><td>CC=gcc, CXX=g++</td><td>Ubuntu 16.04+, CentOS 7+</td><td>This is for developers who familiar with CentOS on aarch64 architecture</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="running-wasm-with-wasmedge-cli"><a class="header" href="#running-wasm-with-wasmedge-cli">Running WASM with WasmEdge CLI</a></h1>
<p>After <a href="quick_start/install.html">installing WasmEdge</a> or starting the <a href="quick_start/use_docker.html">WasmEdge app dev Docker container</a>, there are several ways to run WebAssembly programs.</p>
<h2 id="wasmedge-cli"><a class="header" href="#wasmedge-cli"><code>wasmedge</code> CLI</a></h2>
<p>The <code>wasmedge</code> binary is a command line interface (CLI) program that runs WebAssembly programs.</p>
<ul>
<li>If the WebAssembly program contains a <code>main()</code> function, <code>wasmedge</code> would execute it as a standalone program in the command mode.</li>
<li>If the WebAssembly program contains one or more exported public functions, <code>wasmedge</code> could invoke individual functions in the reactor mode.</li>
</ul>
<p>By default, the <code>wasmedge</code> will execute WebAssembly programs in interpreter mode, and <a href="quick_start/run_in_aot_mode.html">execute the AOT-compiled <code>.so</code>, <code>.dylib</code>, <code>.dll</code>, or <code>.wasm</code> (universal output format) in AOT mode</a>. If you want to accelarate the WASM execution, we recommand to <a href="quick_start/run_cli.html#wasmedgec-cli">compile the WebAssembly with the AOT compiler</a> first.</p>
<p>Users can run the <code>wasmedge -h</code> for realizing the command line options quickly, or <a href="quick_start/../cli/wasmedge.html">refer to the detailed <code>wasmedge</code> CLI options here</a>.</p>
<h3 id="call-a-webassembly-function-written-in-wat"><a class="header" href="#call-a-webassembly-function-written-in-wat">Call A WebAssembly Function Written in WAT</a></h3>
<p>We created the hand-written <a href="https://github.com/WasmEdge/WasmEdge/raw/master/examples/wasm/fibonacci.wat">fibonacci.wat</a> and used the <a href="https://webassembly.github.io/wabt/demo/wat2wasm/">wat2wasm</a> tool to convert it into the <a href="https://github.com/WasmEdge/WasmEdge/raw/master/examples/wasm/fibonacci.wasm">fibonacci.wasm</a> WebAssembly program.
It exported a <code>fib()</code> function which takes a single <code>i32</code> integer as the input parameter. We can execute <code>wasmedge</code> in reactor mode to invoke the exported function.</p>
<p>You can run:</p>
<pre><code class="language-bash">wasmedge --reactor fibonacci.wasm fib 10
</code></pre>
<p>The output will be:</p>
<pre><code class="language-bash">89
</code></pre>
<h3 id="call-a-webassembly-function-compiled-from-rust"><a class="header" href="#call-a-webassembly-function-compiled-from-rust">Call A WebAssembly Function Compiled From Rust</a></h3>
<p>The <a href="https://github.com/WasmEdge/WasmEdge/raw/master/examples/wasm/add.wasm">add.wasm</a> WebAssembly program contains an exported <code>add()</code> function, which is compiled from Rust.
Checkout its <a href="https://github.com/second-state/wasm-learning/tree/master/cli/add">Rust source code project here</a>.
We can execute <code>wasmedge</code> in reactor mode to invoke the <code>add()</code> function with two <code>i32</code> integer input parameters.</p>
<p>You can run:</p>
<pre><code class="language-bash">wasmedge --reactor add.wasm add 2 2
</code></pre>
<p>The output will be:</p>
<pre><code class="language-bash">4
</code></pre>
<h3 id="execute-a-standalone-webassembly-program-hello-world"><a class="header" href="#execute-a-standalone-webassembly-program-hello-world">Execute A Standalone WebAssembly Program: Hello world</a></h3>
<p>The <a href="https://github.com/WasmEdge/WasmEdge/raw/master/examples/wasm/hello.wasm">hello.wasm</a> WebAssembly program contains a <code>main()</code> function.
Checkout its <a href="https://github.com/second-state/wasm-learning/tree/master/cli/hello">Rust source code project here</a>.
It prints out <code>hello</code> followed by the command line arguments.</p>
<p>You can run:</p>
<pre><code class="language-bash">wasmedge hello.wasm second state
</code></pre>
<p>The output will be:</p>
<pre><code class="language-bash">hello
second
state
</code></pre>
<h2 id="wasmedgec-cli"><a class="header" href="#wasmedgec-cli"><code>wasmedgec</code> CLI</a></h2>
<p>The <code>wasmedgec</code> binary is a CLI program to compile WebAssembly into native machine code (i.e., the AOT compiler). For the pure WebAssembly, the <code>wasmedge</code> tool will execute the WASM in interpreter mode. After compiling with the AOT compiler, the <code>wasmedge</code> tool can execute the WASM in AOT mode which is much faster.</p>
<p>The options and flags for the <code>wasmedgec</code> are as follows.</p>
<ol>
<li>Input Wasm file(<code>/path/to/input/wasm/file</code>).</li>
<li>Output file name(<code>/path/to/output/file</code>).
<ul>
<li>By default, it will generate the <a href="quick_start/run_in_aot_mode.html#output-format-universal-wasm">universal Wasm binary format</a>.</li>
<li>Users can still generate native binary only by specifying the <code>.so</code>, <code>.dylib</code>, or <code>.dll</code> extensions.</li>
</ul>
</li>
</ol>
<p>Users can run the <code>wasmedgec -h</code> for realizing the command line options quickly, or <a href="quick_start/../cli/wasmedgec.html">refer to the detailed <code>wasmedgec</code> CLI options here</a>.</p>
<pre><code class="language-bash"># This is slow in interpreter mode.
wasmedge app.wasm

# AOT compilation.
wasmedgec app.wasm app_aot.wasm

# This is now MUCH faster in AOT mode.
wasmedge app_aot.wasm
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="execution-in-aot-mode"><a class="header" href="#execution-in-aot-mode">Execution in AOT Mode</a></h1>
<p>The <code>wasmedge</code> command line tool will execute the original WASM files in interpreter mode. For the much better performance, we recommand users to compile the WASM with the <code>wasmedgec</code> AOT compiler to execute the WASM in AOT mode. There are 2 output formats of the AOT compiler:</p>
<h2 id="output-format-universal-wasm"><a class="header" href="#output-format-universal-wasm">Output Format: Universal WASM</a></h2>
<p>By default, the <code>wasmedgec</code> AOT compiler tool could wrap the AOT-compiled native binary into a custom section in the origin WASM file. We call this the universal WASM binary format.</p>
<p>This AOT-compiled WASM file is compatible with any WebAssembly runtime. However, when this WASM file is executed by the WasmEdge runtime, WasmEdge will extract the native binary from the custom section and execute it in AOT mode.</p>
<blockquote>
<p>Note: On MacOS platforms, the universal WASM format will <code>bus error</code> in execution. It's because the <code>wasmedgec</code> tool optimizes the WASM in <code>O2</code> level by default. We are trying to fix this issue. For working around, please use the shared library output format instead.</p>
</blockquote>
<pre><code class="language-bash">wasmedgec app.wasm app_aot.wasm
wasmedge app_aot.wasm
</code></pre>
<h2 id="output-format-shared-library"><a class="header" href="#output-format-shared-library">Output Format: Shared Library</a></h2>
<p>Users can assign the shared library extension for the output files (<code>.so</code> on Linux, <code>.dylib</code> on MacOS, and <code>.dll</code> on Windows) to generate the shared library output format output.</p>
<p>This AOT-compiled WASM file is only for WasmEdge use, and cannot be used by other WebAssembly runtimes.</p>
<pre><code class="language-bash">wasmedgec app.wasm app_aot.so
wasmedge app_aot.so
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="wasmedge-features"><a class="header" href="#wasmedge-features">WasmEdge Features</a></h1>
<p>WasmEdge is one of the fastest WebAssembly runtimes on the market (based on <code>LLVM AOT</code>).</p>
<ul>
<li><a href="https://arxiv.org/abs/2010.07115">A Lightweight Design for High-performance Serverless Computing</a>, published on IEEE Software, Jan 2021. <a href="https://arxiv.org/abs/2010.07115">https://arxiv.org/abs/2010.07115</a></li>
<li><a href="https://www.infoq.com/articles/arm-vs-x86-cloud-performance/">Performance Analysis for Arm vs. x86 CPUs in the Cloud</a>, published on infoQ.com, Jan 2021. <a href="https://www.infoq.com/articles/arm-vs-x86-cloud-performance/">https://www.infoq.com/articles/arm-vs-x86-cloud-performance/</a></li>
<li><a href="https://blog.suborbital.dev/suborbital-wasmedge">WasmEdge is the fastest WebAssembly Runtime in Suborbital Reactr test suite</a>, Dec 2021</li>
</ul>
<p>Besides, WasmEdge supports various <a href="https://github.com/WebAssembly/proposals">WebAssembly proposals</a> and <a href="https://github.com/WebAssembly/proposals">WASI proposals</a>, as well as several non-standard extensions, which indicates that WasmEdge is an extensionable WebAssembly runtime. In this chapter, we'll introduce the key features of WasmEdge.</p>
<ul>
<li>Supported <a href="features/proposals.html">WASM and WASI proposals</a></li>
<li>WasmEdge <a href="features/proprietary_extend.html">proprietary extensions</a></li>
<li>Running WasmEdge on <a href="features/platforms.html">various platforms</a></li>
<li><a href="features/integrations.html">Integrability of WasmEdge</a> on programming languages or frameworks</li>
<li><a href="features/comparison.html">Compare with other containers</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="supported-wasm-and-wasi-proposals"><a class="header" href="#supported-wasm-and-wasi-proposals">Supported WASM And WASI Proposals</a></h1>
<h2 id="webassembly-proposals"><a class="header" href="#webassembly-proposals">WebAssembly proposals</a></h2>
<p>WasmEdge supports the following <a href="https://github.com/WebAssembly/proposals">WebAssembly proposals</a>. Those proposals are likely to become official WebAssembly specifications in the future.</p>
<div class="table-wrapper"><table><thead><tr><th>Proposal</th><th>WasmEdge CLI flag</th><th>WasmEdge C API enumeration</th><th>Default turning on</th><th>Interpreter mode</th><th>AOT mode</th></tr></thead><tbody>
<tr><td><a href="https://github.com/WebAssembly/mutable-global">Import/Export of Mutable Globals</a></td><td><code>--disable-import-export-mut-globals</code></td><td><code>WasmEdge_Proposal_ImportExportMutGlobals</code></td><td>✓ (since <code>0.8.2</code>)</td><td>✓</td><td>✓</td></tr>
<tr><td><a href="https://github.com/WebAssembly/nontrapping-float-to-int-conversions">Non-trapping float-to-int conversions</a></td><td><code>--disable-non-trap-float-to-int</code></td><td><code>WasmEdge_Proposal_NonTrapFloatToIntConversions</code></td><td>✓ (since <code>0.8.2</code>)</td><td>✓</td><td>✓</td></tr>
<tr><td><a href="https://github.com/WebAssembly/sign-extension-ops">Sign-extension operators</a></td><td><code>--disable-sign-extension-operators</code></td><td><code>WasmEdge_Proposal_SignExtensionOperators</code></td><td>✓ (since <code>0.8.2</code>)</td><td>✓</td><td>✓</td></tr>
<tr><td><a href="https://github.com/WebAssembly/multi-value">Multi-value</a></td><td><code>--disable-multi-value</code></td><td><code>WasmEdge_Proposal_MultiValue</code></td><td>✓ (since <code>0.8.2</code>)</td><td>✓</td><td>✓</td></tr>
<tr><td><a href="https://github.com/WebAssembly/reference-types">Reference Types</a></td><td><code>--disable-reference-types</code></td><td><code>WasmEdge_Proposal_ReferenceTypes</code></td><td>✓ (since <code>0.8.2</code>)</td><td>✓</td><td>✓</td></tr>
<tr><td><a href="https://github.com/WebAssembly/bulk-memory-operations">Bulk memory operations</a></td><td><code>--disable-bulk-memory</code></td><td><code>WasmEdge_Proposal_BulkMemoryOperations</code></td><td>✓ (since <code>0.8.2</code>)</td><td>✓</td><td>✓</td></tr>
<tr><td><a href="https://github.com/webassembly/simd">Fixed-width SIMD</a></td><td><code>--disable-simd</code></td><td><code>WasmEdge_Proposal_SIMD</code></td><td>✓ (since <code>0.9.0</code>)</td><td>✓ (since <code>0.8.2</code>)</td><td>✓ (since <code>0.8.2</code>)</td></tr>
<tr><td><a href="https://github.com/WebAssembly/tail-call">Tail call</a></td><td><code>--enable-tail-call</code></td><td><code>WasmEdge_Proposal_TailCall</code></td><td></td><td>✓ (since <code>0.10.0</code>)</td><td>✓ (since <code>0.10.0</code>)</td></tr>
<tr><td><a href="https://github.com/WebAssembly/multi-memory">Multiple memories</a></td><td><code>--enable-multi-memory</code></td><td><code>WasmEdge_Proposal_MultiMemories</code></td><td></td><td>✓ (since <code>0.9.1</code>)</td><td>✓ (since <code>0.9.1</code>)</td></tr>
<tr><td><a href="https://github.com/WebAssembly/extended-const">Extended Constant Expressions</a></td><td><code>--enable-extended-const</code></td><td><code>WasmEdge_Proposal_ExtendedConst</code></td><td></td><td>✓ (since <code>0.10.0</code>)</td><td>✓ (since <code>0.10.0</code>)</td></tr>
<tr><td><a href="https://github.com/webassembly/threads">Threads</a></td><td><code>--enable-threads</code></td><td><code>WasmEdge_Proposal_Threads</code></td><td></td><td>✓ (since <code>0.10.1</code>)</td><td>✓ (since <code>0.10.1</code>)</td></tr>
</tbody></table>
</div>
<p>The following proposals is under development and may be supported in the future:</p>
<ul>
<li><a href="https://github.com/WebAssembly/component-model">Component Model</a></li>
<li><a href="https://github.com/WebAssembly/exception-handling">Exception handling</a></li>
<li><a href="https://github.com/WebAssembly/gc">Garbage collection</a></li>
<li><a href="https://github.com/WebAssembly/wasm-c-api">WebAssembly C and C++ API</a></li>
</ul>
<h2 id="wasi-proposals"><a class="header" href="#wasi-proposals">WASI proposals</a></h2>
<p>WasmEdge implements the following <a href="https://github.com/WebAssembly/WASI/blob/main/Proposals.md">WASI proposals</a>.</p>
<div class="table-wrapper"><table><thead><tr><th>Proposal</th><th>Platforms</th></tr></thead><tbody>
<tr><td><a href="https://github.com/WebAssembly/wasi-sockets">Sockets</a></td><td><code>x86_64 Linux</code>, <code>aarch64 Linux</code> (since <code>0.10.0</code>)</td></tr>
<tr><td><a href="https://github.com/WebAssembly/wasi-crypto">Crypto</a></td><td><code>x86_64 Linux</code>, <code>aarch64 Linux</code> (since <code>0.10.1</code>)</td></tr>
<tr><td><a href="https://github.com/WebAssembly/wasi-nn">Machine Learning (wasi-nn)</a></td><td><code>x86_64 Linux</code>, OpenVINO (since <code>0.10.1</code>) and PyTorch (since <code>0.11.1</code>) backends</td></tr>
<tr><td><a href="https://github.com/proxy-wasm/spec">proxy-wasm</a></td><td><code>x86_64 Linux (Interpreter only)</code> (since <code>0.8.2</code>)</td></tr>
</tbody></table>
</div>
<p>The following proposals is under development and may be supported in the future:</p>
<ul>
<li>TensorFlow backend of <code>WASI-NN</code></li>
<li>TensorFlow-Lite backend of <code>WASI-NN</code></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="wasmedge-proprietary-extensions"><a class="header" href="#wasmedge-proprietary-extensions">WasmEdge Proprietary Extensions</a></h1>
<p>A key differentiator of WasmEdge from other WebAssembly runtimes is its support for non-standard extensions. The <a href="https://github.com/WebAssembly/WASI">WebAssembly System Interface (WASI)</a> provides a mechanism for developers to extend WebAssembly efficiently and securely. The WasmEdge team created the following WASI-like extensions based on real-world customer demands.</p>
<ul>
<li><a href="https://github.com/second-state/wasmedge-tensorflow">Tensorflow</a>. Developers can <a href="https://www.secondstate.io/articles/wasi-tensorflow/">write Tensorflow inference functions</a> using <a href="https://github.com/second-state/wasmedge_tensorflow_interface">a simple Rust API</a>, and then run the function securely and at native speed inside WasmEdge.</li>
<li><a href="https://github.com/second-state/WasmEdge-image">Image processing</a>. WasmEdge uses native libraries to manipulate images for computer vision tasks.</li>
<li><a href="https://github.com/second-state/wasmedge-storage">KV Storage</a>. The WasmEdge <a href="https://github.com/second-state/rust_native_storage_library">storage interface</a> allows WebAssembly programs to read and write a key value store.</li>
<li><a href="https://github.com/second-state/wasmedge_wasi_socket">Network sockets</a>. WasmEdge applications can access the network sockets for <a href="https://github.com/second-state/wasmedge_wasi_socket/tree/main/examples">TCP and HTTP connections</a>.</li>
<li><a href="https://github.com/second-state/wasmedge_process_interface">Command interface</a>. WasmEdge enables webassembly functions execute native commands in the host operating system. It supports passing arguments, environment variables, <code>STDIN</code>/<code>STDOUT</code> pipes, and security policies for host access.</li>
<li><a href="https://github.com/second-state/wasmedge-evmc">Ethereum</a>. The WasmEdge Ewasm extension supports Ethereum smart contracts compiled to WebAssembly. It is a leading implementation for Ethereum flavored WebAssembly (Ewasm).</li>
<li><a href="https://github.com/second-state/substrate-ssvm-node">Substrate</a>. The <a href="https://github.com/second-state/pallet-ssvm">Pallet</a> allows WasmEdge to act as an Ethereum smart contract execution engine on any Substrate based blockchains.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="wasmedge-integrations"><a class="header" href="#wasmedge-integrations">WasmEdge Integrations</a></h1>
<p>WasmEdge is a &quot;serverless&quot; runtime for cloud native and edge computing applications. It allows developers safely embed third-party or &quot;native&quot; functions into a host application or a distributed computing framework.</p>
<h2 id="embed-wasmedge-into-a-host-application"><a class="header" href="#embed-wasmedge-into-a-host-application">Embed WasmEdge Into A Host Application</a></h2>
<p>A major use case of WasmEdge is to start a VM instance from a host application. Depending on your host application's programming language, you can use WasmEdge SDKs to start and invoke WasmEdge functions.</p>
<ul>
<li>Embed WasmEdge functions into a <code>C</code>-based application using the <a href="features/../sdk/c/ref.html">WasmEdge C API</a>. Checkout the <a href="features/../sdk/c.html">quick start guide</a>.</li>
<li>Embed WasmEdge functions into a <code>Go</code> application using the <a href="features/../sdk/go.html">WasmEdge Go API</a>. Here is a <a href="https://www.secondstate.io/articles/extend-golang-app-with-webassembly-rust/">tutorial</a> and are some <a href="https://github.com/second-state/WasmEdge-go-examples">examples</a>!</li>
<li>Embed WasmEdge functions into a <code>Rust</code> application using the <a href="https://crates.io/crates/wasmedge-sdk">WasmEdge Rust crate</a>.</li>
<li>Embed WasmEdge functions into a <code>Node.js</code> application using the <code>NAPI</code>. Here is a <a href="https://www.secondstate.io/articles/getting-started-with-rust-function/">tutorial</a>.</li>
<li>Embed WasmEdge functions into any application by spawning a new process. See examples for <a href="https://www.secondstate.io/articles/vercel-wasmedge-webassembly-rust/">Vercel Serverless Functions</a> and <a href="https://www.cncf.io/blog/2021/08/25/webassembly-serverless-functions-in-aws-lambda/">AWS Lambda</a>.</li>
</ul>
<p>However, the WebAssembly spec only supports very limited data types as input parameters and return values for the WebAssembly bytecode functions.
In order to pass complex data types, such as a string of an array, as call arguments into WebAssembly compiled from Rust, you should use the <code>bindgen</code> solution provided by the <a href="https://crates.io/crates/wasmedge-bindgen"><code>wasmedge-bindgen</code></a>.
We currently support the <code>wasmedge-bindgen</code> in the <a href="features/../write_wasm/rust/bindgen.html">Rust</a> and in <a href="features/../sdk/go/function.html">Go</a>.</p>
<h2 id="use-wasmedge-as-a-docker-like-container"><a class="header" href="#use-wasmedge-as-a-docker-like-container">Use WasmEdge As A Docker-Like Container</a></h2>
<p>WasmEdge provides an OCI compliant interface. You can use container tools, such as CRI-O, Docker Hub, and Kubernetes, to orchestrate and manage WasmEdge runtimes.</p>
<ul>
<li><a href="https://www.secondstate.io/articles/manage-webassembly-apps-in-wasmedge-using-docker-tools/">Manage WasmEdge with CRI-O and Docker Hub</a>.</li>
</ul>
<h2 id="call-native-host-functions-from-wasmedge"><a class="header" href="#call-native-host-functions-from-wasmedge">Call Native Host Functions From WasmEdge</a></h2>
<p>A key feature of WasmEdge is its extensibility. WasmEdge APIs allow developers to register &quot;host functions&quot; from the host programming languages into a WasmEdge instance, and then invoke these functions from the WebAssembly program.</p>
<ul>
<li>The WasmEdge C API supports the <a href="features/../sdk/c/ref.html#host-functions">C host functions</a>.</li>
<li>The WasmEdge Go API supports the <a href="features/../sdk/go/ref.html#host-functions">Go host functions</a>.</li>
<li>The WasmEdge Rust API supports the <a href="features/../sdk/rust/sys_run_host_func.html">Rust host functions</a>.</li>
</ul>
<p><a href="https://www.secondstate.io/articles/call-native-functions-from-javascript/">Here is an example</a> of a JavaScript program in WasmEdge calling a C-based host function in the underlying OS.</p>
<p>The host functions break the Wasm sandbox to access the underly OS or hardware. But the sandbox breaking is done with explicit permission from the system’s operator.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="supported-platforms"><a class="header" href="#supported-platforms">Supported Platforms</a></h1>
<p>WasmEdge supports a wide range of operating systems and hardware platforms.
It allows WebAssembly applications to be truly portable across platforms.
It runs not only on Linux-like systems, but also on microkernels such as the <code>seL4</code> real-time system.</p>
<p>WasmEdge now supports:</p>
<ul>
<li><a href="features/../contribute/build_from_src/linux.html">Linux</a> (<code>x86_64</code> and <code>aarch64</code>)</li>
<li><a href="features/../contribute/build_from_src/macos.html">MacOS</a> (<code>x86_64</code> and <code>M1</code>)</li>
<li><a href="features/../contribute/build_from_src/windows.html">Windows</a></li>
<li><a href="features/../contribute/build_from_src/android.html">Android</a></li>
<li><a href="features/../contribute/build_from_src/sel4.html">seL4</a></li>
<li><a href="features/../contribute/build_from_src/openwrt.html">OpenWrt</a></li>
<li><a href="features/../contribute/build_from_src/openharmony.html">OpenHarmony</a></li>
<li><a href="features/../contribute/build_from_src/raspberrypi.html">Respberry Pi</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="comparison"><a class="header" href="#comparison">Comparison</a></h1>
<h2 id="whats-the-relationship-between-webassembly-and-docker"><a class="header" href="#whats-the-relationship-between-webassembly-and-docker">What's the relationship between WebAssembly and Docker?</a></h2>
<p>Check out our infographic <a href="https://wasmedge.org/wasm_docker/">WebAssembly vs. Docker</a>. WebAssembly runs side by side with Docker in cloud native and edge native applications.</p>
<h2 id="whats-the-difference-for-native-clients-nacl-application-runtimes-and-webassembly"><a class="header" href="#whats-the-difference-for-native-clients-nacl-application-runtimes-and-webassembly">What's the difference for Native clients (NaCl), Application runtimes, and WebAssembly?</a></h2>
<p>We created a handy table for the comparison.</p>
<div class="table-wrapper"><table><thead><tr><th></th><th>NaCl</th><th>Application runtimes (eg Node &amp; Python)</th><th>Docker-like container</th><th>WebAssembly</th></tr></thead><tbody>
<tr><td>Performance</td><td>Great</td><td>Poor</td><td>OK</td><td>Great</td></tr>
<tr><td>Resource footprint</td><td>Great</td><td>Poor</td><td>Poor</td><td>Great</td></tr>
<tr><td>Isolation</td><td>Poor</td><td>OK</td><td>OK</td><td>Great</td></tr>
<tr><td>Safety</td><td>Poor</td><td>OK</td><td>OK</td><td>Great</td></tr>
<tr><td>Portability</td><td>Poor</td><td>Great</td><td>OK</td><td>Great</td></tr>
<tr><td>Security</td><td>Poor</td><td>OK</td><td>OK</td><td>Great</td></tr>
<tr><td>Language and framework choice</td><td>N/A</td><td>N/A</td><td>Great</td><td>OK</td></tr>
<tr><td>Ease of use</td><td>OK</td><td>Great</td><td>Great</td><td>OK</td></tr>
<tr><td>Manageability</td><td>Poor</td><td>Poor</td><td>Great</td><td>Great</td></tr>
</tbody></table>
</div>
<h2 id="whats-the-difference-between-webassembly-and-ebpf"><a class="header" href="#whats-the-difference-between-webassembly-and-ebpf">What's the difference between WebAssembly and eBPF?</a></h2>
<p><code>eBPF</code> is the bytecode format for a Linux kernel space VM that is suitable for network or security related tasks. WebAssembly is the bytecode format for a user space VM that is suited for business applications. <a href="https://medium.com/codex/ebpf-and-webassembly-whose-vm-reigns-supreme-c2861ce08f89">See details here</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="wasmedge-use-cases"><a class="header" href="#wasmedge-use-cases">WasmEdge Use Cases</a></h1>
<p>Featuring AOT compiler optimization, WasmEdge is one of the fastest WebAssembly runtimes on the market today. Therefore WasmEdge is widely used in edge computing, automotive, Jamstack, serverless, SaaS, service mesh, and even blockchain applications.</p>
<ul>
<li>
<p>Modern web apps feature rich UIs that are rendered in the browser and/or on the edge cloud. WasmEdge works with popular web UI frameworks, such as React, Vue, Yew, and Percy, to support isomorphic <a href="use_cases/server_side_render.html">server-side rendering (SSR) functions on edge servers</a>. It could also support server-side rendering of Unity3D animations and AI-generated interactive videos for web applications on the edge cloud.</p>
</li>
<li>
<p>WasmEdge provides a lighweight, secure and high-performance runtime for <a href="use_cases/microservice.html">microservices</a>. It is fully compatible with application service frameworks such as Dapr, and service orchestrators like Kubernetes. WasmEdge microservices can run on edge servers, and have access to distributed cache, to support both stateless and stateful business logic functions for modern web apps. Also related: <a href="use_cases/serverless_faas.html">Serverless function-as-a-service in public clouds</a>.</p>
</li>
<li>
<p><a href="use_cases/serverless_saas.html">Serverless SaaS (Software-as-a-Service) functions</a> enables users to extend and customize their SaaS experience without operating their own API callback servers. The serverless functions can be embedded into the SaaS or reside on edge servers next to the SaaS servers. Developers simply upload functions to respond to SaaS events or to connect SaaS APIs.</p>
</li>
<li>
<p><a href="use_cases/smart_device.html">Smart device apps</a> could embed WasmEdge as a middleware runtime to render interactive content on the UI, connect to native device drivers, and access specialized hardware features (i.e, the GPU for AI inference). The benefits of the WasmEdge runtime over native-compiled machine code include security, safety, portability, manageability, and developer productivity. WasmEdge runs on Android, OpenHarmony, and seL4 RTOS devices.</p>
</li>
<li>
<p>WasmEdge could support <a href="use_cases/js_or_dsl_runtime.html">high performance DSLs (Domain Specifc Languages) or act as a cloud-native JavaScript runtime</a> by embedding a JS execution engine or interpreter.</p>
</li>
<li>
<p>Developers can leverage container tools such as <a href="use_cases/kubernetes.html">Kubernetes</a>, Docker and CRI-O to deploy, manage, and run lightweight WebAssembly applications.</p>
</li>
<li>
<p>WasmEdge applications can be plugged into existing <a href="use_cases/frameworks.html">application frameworks or platforms</a>.</p>
</li>
</ul>
<p>If you have any great ideas on WasmEdge, don't hesitate to open <a href="https://github.com/WasmEdge/WasmEdge/issues">a GitHub issue</a> to discuss together.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="server-side-rendering-modern-web-ui"><a class="header" href="#server-side-rendering-modern-web-ui">Server Side Rendering Modern Web UI</a></h1>
<p>Traditional web applications follows the client-server model. In the past era of application servers, the entire UI is dynamically generated from the server. The browser is simply a thin client that displays the rendered web pages at real time. However, as the browser becomes more capable and sophisticated, the client can now take on more workload to improve application UX, performance, and security.</p>
<p>That gives rise to the era of Jamstack. There is now a clear separation between frontend and backend services. The frontend is a static web site (HTML + JavaScript + WebAssembly) generated from UI frameworks such as React.js, Vue.js, Yew or Percy, and the backend consists of microservices. Yet, as Jamstack gains popularity, the diversity of clients (both browsers and apps) makes it very difficult to achieve great performance across all use cases.</p>
<p>The solution is server-side rendering (SSR). That is to have edge servers run the &quot;client side&quot; UI code (ie the React generated JavaScript OR Percy generated WebAssembly), and send back the rendered HTML DOM objects to the browser. In this case, the edge server must execute the exact same code (i.e. <a href="use_cases/../write_wasm/js.html">JavaScript</a> and WebAssembly) as the browser to render the UI. That is called isomorphic Jamstack applications. The WasmEdge runtime provides a lightweight, high performance, OCI complaint, and polyglot container to run all kinds of SSR functions on edge servers.</p>
<ul>
<li><a href="use_cases/../write_wasm/js/ssr.html">React JS SSR function</a></li>
<li>Vue JS SSR function (coming soon)</li>
<li>Yew Rust compiled to WebAssembly SSR function (coming soon)</li>
<li><a href="use_cases/../write_wasm/rust/ssr.html">Percy Rust compiled to WebAssembly SSR function</a></li>
</ul>
<p>We also exploring ways to render more complex UI and interactions on WasmEdge-based edge servers, and then stream the rendered results to the client application. Potential examples include</p>
<ul>
<li>Render Unity3D animations on the edge server (based on <a href="https://docs.unity3d.com/2020.1/Documentation/Manual/webgl-gettingstarted.html">WebAssembly rendering of Unity3D</a>)</li>
<li>Render interactive video (generated from AI) on the edge server</li>
</ul>
<p>Of course, the edge cloud could grow well beyond SSR for UI components. It could also host high-performance microservices for business logic and serverless functions. Read on to the next chapter.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="microservices"><a class="header" href="#microservices">Microservices</a></h1>
<p>The edge cloud can run application logic microservices very close to the client device.</p>
<ul>
<li>The microservices could be stateless computational tasks, such as <a href="use_cases/../write_wasm/rust/tensorflow.html">AI inference</a> and <a href="use_cases/frameworks/app/yomo.html">stream data analysis</a>, which offload computation from the client.</li>
<li>The microservices could also <a href="https://github.com/second-state/wasmedge-anna-rs">interact with data cache services</a> that sync with backend databases.</li>
</ul>
<p>The edge cloud has advantages such as low latency, high security, and high performance. Operationally, WasmEdge can be embedded into cloud-native infrastructure via its SDKs in <a href="use_cases/../sdk/c.html">C</a>, <a href="use_cases/../sdk/go.html">Go</a> and <a href="use_cases/../sdk/rust.html">Rust</a>. It is also an OCI compliant runtime that can be directly <a href="use_cases/kubernetes/cri.html">managed by container tools</a> as a lightweight and high-performance alternative to Linux containers. The following application frameworks have been tested to work with WasmEdge-based microservices.</p>
<h2 id="dapr-distributed-application-runtime"><a class="header" href="#dapr-distributed-application-runtime">Dapr (Distributed Application Runtime)</a></h2>
<ul>
<li><a href="use_cases/frameworks/mesh/dapr.html">Tutorial</a></li>
<li><a href="https://github.com/second-state/dapr-wasm">Code template</a></li>
</ul>
<h2 id="service-mesh-work-in-progress"><a class="header" href="#service-mesh-work-in-progress">Service mesh (work in progress)</a></h2>
<ul>
<li>Linkerd</li>
<li>MOSN</li>
<li>Envoy</li>
</ul>
<h2 id="orchestration-and-management"><a class="header" href="#orchestration-and-management">Orchestration and management</a></h2>
<ul>
<li><a href="use_cases/kubernetes.html">Kubernetes</a></li>
<li><a href="use_cases/kubernetes/kubernetes/kubeedge.html">KubeEdge</a></li>
<li><a href="use_cases/kubernetes/kubernetes/superedge.html">SuperEdge</a></li>
<li><a href="use_cases/kubernetes/kubernetes/openyurt.html">OpenYurt</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="serverless-function-as-a-service-in-public-clouds"><a class="header" href="#serverless-function-as-a-service-in-public-clouds">Serverless Function-As-A-Service in Public Clouds</a></h1>
<p>WasmEdge works with existing serverless or Jamstack platforms to provide a high-performance, portable and secure runtime for functions. It offers significant benefits even when it runs inside Docker or microVMs on those platforms.</p>
<h2 id="aws-lambda"><a class="header" href="#aws-lambda">AWS Lambda</a></h2>
<ul>
<li><a href="https://www.cncf.io/blog/2021/08/25/webassembly-serverless-functions-in-aws-lambda/">Tutorial</a></li>
<li><a href="https://github.com/second-state/aws-lambda-wasm-runtime">Code template</a></li>
</ul>
<h2 id="tencent-serverless-functions"><a class="header" href="#tencent-serverless-functions">Tencent Serverless Functions</a></h2>
<ul>
<li><a href="https://my.oschina.net/u/4532842/blog/5172639">Tutorial in Chinese</a></li>
<li><a href="https://github.com/second-state/tencent-scf-wasm-runtime">Code template</a></li>
</ul>
<h2 id="vercel-serverless-functions"><a class="header" href="#vercel-serverless-functions">Vercel Serverless Functions</a></h2>
<ul>
<li><a href="https://www.secondstate.io/articles/vercel-wasmedge-webassembly-rust/">Tutorial</a></li>
<li><a href="https://github.com/second-state/vercel-wasm-runtime">Code template</a></li>
</ul>
<h2 id="netlify-functions"><a class="header" href="#netlify-functions">Netlify Functions</a></h2>
<ul>
<li><a href="https://www.secondstate.io/articles/netlify-wasmedge-webassembly-rust-serverless/">Tutorial</a></li>
<li><a href="https://github.com/second-state/netlify-wasm-runtime">Code template</a></li>
</ul>
<h2 id="second-state-functions"><a class="header" href="#second-state-functions">Second State Functions</a></h2>
<ul>
<li><a href="https://www.secondstate.io/faas/">Tutorials</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="serverless-software-as-a-service-functions"><a class="header" href="#serverless-software-as-a-service-functions">Serverless Software-As-A-Service Functions</a></h1>
<p>WasmEdge can support customized SaaS extensions or applications using serverless functions instead of traditional network APIs. That dramatically improves SaaS users' and developers' productivity.</p>
<ul>
<li>WasmEdge could be embedded into SaaS products to execute user-defined functions. In this scenario, the WasmEdge function API replaces the SaaS web API. The embedded WasmEdge functions are much faster, safer, and easier to use than RPC functions over the web.</li>
<li>Edge servers could provide WasmEdge-based containers to interact with existing SaaS or PaaS APIs without requiring the user to run his own servers (eg callback servers). The serverless API services can be co-located in the same networks as the SaaS to provide optimal performance and security.</li>
</ul>
<p>The examples below showcase how WasmEdge-based serverless functions connect together SaaS APIs from different services, and process data flows across those SaaS APIs according each user's business logic.</p>
<h2 id="slack"><a class="header" href="#slack">Slack</a></h2>
<ul>
<li><a href="http://reactor.secondstate.info/en/docs/user_guideline.html">Build a serverless chatbot for Slack</a></li>
</ul>
<h2 id="lark"><a class="header" href="#lark">Lark</a></h2>
<p>It is also known as <code>飞书</code> aka the Chinese Slack. It is created by Byte Dance, the parent company of Tiktok.</p>
<ul>
<li><a href="http://reactor.secondstate.info/en/docs/user_guideline.html">Build a serverless chatbot for Lark</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="wasmedge-on-smart-devices"><a class="header" href="#wasmedge-on-smart-devices">WasmEdge On Smart Devices</a></h1>
<p>Smart device apps could embed WasmEdge as a middleware runtime to render interactive content on the UI, connect to native device drivers, and access specialized hardware features (i.e, the GPU for AI inference). The benefits of the WasmEdge runtime over native-compiled machine code include security, safety, portability, manageability, OTA upgradability, and developer productivity. WasmEdge runs on the following device OSes.</p>
<ul>
<li><a href="use_cases/../contribute/build_from_src/android.html">Android</a></li>
<li><a href="use_cases/../contribute/build_from_src/openharmony.html">OpenHarmony</a></li>
<li><a href="use_cases/../contribute/build_from_src/raspberrypi.html">Raspberry Pi</a></li>
<li><a href="use_cases/../contribute/build_from_src/sel4.html">The seL4 RTOS</a></li>
</ul>
<p>With WasmEdge on both the device and the edge server, we can support <a href="use_cases/server_side_render.html">isomorphic Server-Side Rendering (SSR)</a> and <a href="use_cases/microservice.html">microservices</a> for rich-client mobile applications that is both portable and upgradable.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="javascript-or-domain-specifc-language-runtime"><a class="header" href="#javascript-or-domain-specifc-language-runtime">JavaScript or Domain Specifc Language Runtime</a></h1>
<p>In order for WebAssembly to be widely adopted by developers as a runtime, it must support &quot;easy&quot; languages like JavaScript. Or, better yet, through its advanced compiler toolchain, WasmEdge could support high performance DSLs (Domain Specifc Languages), which are low code solutions designed for specific tasks.</p>
<h2 id="javascript"><a class="header" href="#javascript">JavaScript</a></h2>
<p>WasmEdge can act as a cloud-native JavaScript runtime by embedding a JS execution engine or interpreter. It is faster and lighter than running a JS engine inside Docker. WasmEdge supports JS APIs to access native extension libraries such as network sockets, tensorflow, and user-defined shared libraries. It also allows embedding JS into other high-performance languages (eg, Rust) or using Rust / C to implement JS functions.</p>
<ul>
<li>Tutorials
<ul>
<li><a href="https://www.secondstate.io/articles/run-javascript-in-webassembly-with-wasmedge/">Run JavaScript</a></li>
<li><a href="https://www.secondstate.io/articles/embed-javascript-in-rust/">Embed JavaScript in Rust</a></li>
<li><a href="https://www.secondstate.io/articles/embed-rust-in-javascript/">Create JavaScript API using Rust functions</a></li>
<li><a href="https://www.secondstate.io/articles/call-native-functions-from-javascript/">Call C native shared library functions from JavaScript</a></li>
</ul>
</li>
<li><a href="use_cases/../write_wasm/js.html">Examples</a></li>
<li><a href="https://github.com/second-state/wasmedge-quickjs">WasmEdge’s embedded QuickJS engine</a></li>
</ul>
<h2 id="dsl-for-image-classification"><a class="header" href="#dsl-for-image-classification">DSL for image classification</a></h2>
<p>The image classification DSL is a YAML format that allows the user to specify a tensorflow model and its parameters. WasmEdge takes an image as the input of the DSL and outputs the detected item name / label.</p>
<ul>
<li>Example: <a href="https://github.com/second-state/wasm-learning/blob/master/cli/classify_yml/config/food.yml">Run a YAML to detect food items in an image</a></li>
</ul>
<h2 id="dsl-for-chatbots"><a class="header" href="#dsl-for-chatbots">DSL for chatbots</a></h2>
<p>A chatbot DSL function takes an input string and responds with a reply string. The DSL specifies the internal state transtions of the chatbot, as well as AI models for language understanding. This work is in progress.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="wasmedge-in-kubernetes"><a class="header" href="#wasmedge-in-kubernetes">WasmEdge in Kubernetes</a></h1>
<p>Developers can leverage container tools such as Kubernetes, Docker and CRI-O to deploy, manage, and run lightweight WebAssembly applications. In this chapter, we will demonstrate how Kubernetes ecosystem tools work with WasmEdge WebAssembly applications.</p>
<p>Compared with Linux containers, <a href="https://www.infoq.com/articles/arm-vs-x86-cloud-performance/">WebAssembly could be 100x faster at startup</a>, have a much smaller memory and disk footprint, and have a better-defined safety sandbox. However, the trade-off is that WebAssembly requires its own language SDKs, and compiler toolchains, making it a more constrained developer environment than Linux containers. WebAssembly is increasingly used in Edge Computing scenarios where it is difficult to deploy Linux containers or when the application performance is vital.</p>
<p>One of the great advantages of Linux application containers is the rich ecosystem of tools. The good news is that you can use the exact same tools to manage WebAssembly applications, enabling Linux containers and WebAssembly apps to run side-by-side in the same system.</p>
<p><img src="use_cases/kubernetes.png" alt="kubernetes" /></p>
<p>The contents of this chapter are organized by the approaches for integrating WasmEdge into container toolchains.</p>
<ul>
<li>The <a href="use_cases/kubernetes/docker/lxc.html">slimmed Linux container tailored for WasmEdge</a> offers the easiest option (but with performance trade-offs) to integrate WasmEdge applications into any container tooling system.</li>
<li>The most important integration approach is to replace the underlying OCI runtime of the toolchain stack with a WasmEdge-enabled <code>crun</code> runtime.
<ul>
<li><a href="use_cases/kubernetes/quickstart.html">Quick start</a> provides simple and scripted tutorials to run WasmEdge-based applications as container images in Kubernetes.</li>
<li><a href="use_cases/kubernetes/demo.html">Demo apps</a> discusses the two demo WasmEdge applications we will run in Kubernetes clusters. Those applications are compiled from Rust source code, packaged as OCI images, and uploaded to Docker Hub.</li>
<li><a href="use_cases/kubernetes/container.html">Container runtimes</a> covers how to configure low level container runtimes, such as crun, to load and run WebAssembly OCI images.</li>
<li><a href="use_cases/kubernetes/cri.html">CRI runtimes</a> covers how to configure and use high level container runtimes, such as CRI-O and containerd, to load and run WebAssembly OCI images on top of low level container runtimes.</li>
<li><a href="use_cases/kubernetes/kubernetes.html">Kubernetes</a> covers how to configure and use Kubernetes and Kubernetes variations, such as KubeEdge and SuperEdge, to load and run WebAssembly OCI images on top of CRI runtimes.</li>
</ul>
</li>
<li>If you cannot replace the OCI runtime in your toolchain with WasmEdge-enabled <code>crun</code>, you can use a <a href="use_cases/kubernetes/docker/containerd.html">containerd shim</a> to start and run a WasmEdge application without any intrusive change.</li>
</ul>
<p>The goal is to load and run WebAssembly OCI images side by side with Linux OCI images (e.g., today's Docker containers) across the entire Kubernetes stack.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="quick-start-1"><a class="header" href="#quick-start-1">Quick start</a></h1>
<p>We have created Ubuntu-based scripts for you to quickly get started with the following combination of runtimes in a standard Kubernetes setup.</p>
<div class="table-wrapper"><table><thead><tr><th>CRI (high level) runtime</th><th>OCI (low level) runtime</th><th></th></tr></thead><tbody>
<tr><td>CRI-O</td><td>crun + WasmEdge</td><td><a href="https://github.com/second-state/wasmedge-containers-examples/blob/main/.github/workflows/kubernetes-crio.yml">Script</a></td></tr>
<tr><td>containerd</td><td>crun + WasmEdge</td><td><a href="https://github.com/second-state/wasmedge-containers-examples/blob/main/.github/workflows/kubernetes-containerd.yml">Script</a></td></tr>
</tbody></table>
</div>
<h2 id="cri-o-and-crun"><a class="header" href="#cri-o-and-crun">CRI-O and crun</a></h2>
<p>You can use the CRI-O <a href="https://github.com/second-state/wasmedge-containers-examples/blob/main/crio/install.sh">install.sh</a> script to install CRI-O and <code>crun</code> on Ubuntu 20.04.</p>
<pre><code class="language-bash">wget -qO- https://raw.githubusercontent.com/second-state/wasmedge-containers-examples/main/crio/install.sh | bash
</code></pre>
<p>Next, install Kubernetes using the <a href="https://github.com/second-state/wasmedge-containers-examples/blob/main/kubernetes_crio/install.sh">following script</a>.</p>
<pre><code class="language-bash">wget -qO- https://raw.githubusercontent.com/second-state/wasmedge-containers-examples/main/kubernetes_crio/install.sh | bash
</code></pre>
<p>The <a href="https://github.com/second-state/wasmedge-containers-examples/blob/main/kubernetes_crio/simple_wasi_application.sh">simple_wasi_application.sh</a> script shows how to pull <a href="use_cases/kubernetes/demo/wasi.html">a WebAssembly application</a> from Docker Hub, and then run it as a containerized application in Kubernetes.</p>
<pre><code class="language-bash">wget -qO- https://raw.githubusercontent.com/second-state/wasmedge-containers-examples/main/kubernetes_crio/simple_wasi_application.sh | bash
</code></pre>
<p>You should see results from the WebAssembly program printed in the console log. <a href="https://github.com/second-state/wasmedge-containers-examples/runs/4186005677?check_suite_focus=true#step:6:3007">Here is an example</a>.</p>
<h2 id="containerd-and-crun"><a class="header" href="#containerd-and-crun">containerd and crun</a></h2>
<p>You can use the containerd <a href="https://github.com/second-state/wasmedge-containers-examples/blob/main/containerd/install.sh">install.sh</a> script to install <code>containerd</code> and <code>crun</code> on Ubuntu 20.04.</p>
<pre><code class="language-bash">wget -qO- https://raw.githubusercontent.com/second-state/wasmedge-containers-examples/main/containerd/install.sh | bash
</code></pre>
<p>Next, install Kubernetes using the <a href="https://github.com/second-state/wasmedge-containers-examples/blob/main/kubernetes_containerd/install.sh">following script</a>.</p>
<pre><code class="language-bash">wget -qO- https://raw.githubusercontent.com/second-state/wasmedge-containers-examples/main/kubernetes_containerd/install.sh | bash
</code></pre>
<p>The <a href="https://github.com/second-state/wasmedge-containers-examples/blob/main/kubernetes_containerd/simple_wasi_application.sh">simple_wasi_application.sh</a> script shows how to pull <a href="use_cases/kubernetes/demo/wasi.html">a WebAssembly application</a> from Docker Hub, and then run it as a containerized application in Kubernetes.</p>
<pre><code class="language-bash">wget -qO- https://raw.githubusercontent.com/second-state/wasmedge-containers-examples/main/kubernetes_containerd/simple_wasi_application.sh | bash
</code></pre>
<p>You should see results from the WebAssembly program printed in the console log. <a href="https://github.com/second-state/wasmedge-containers-examples/runs/4577789181?check_suite_focus=true#step:6:3010">Here is an example</a>.</p>
<p>Read on to the rest of this chapter to learn how exactly those runtimes are configured.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="demo-apps"><a class="header" href="#demo-apps">Demo apps</a></h1>
<p>In this chapter, we will cover two demo apps. We will build them from Rust source code, build OCI images around them, and then publish the images to Docker Hub.</p>
<p>If you have not done so, please</p>
<ul>
<li><a href="https://www.rust-lang.org/tools/install">Install Rust</a></li>
<li><a href="https://hub.docker.com/">Register for Docker Hub</a></li>
</ul>
<p>Next, explore the examples</p>
<ul>
<li><a href="use_cases/kubernetes/demo/wasi.html">A simple WASI example</a></li>
<li><a href="use_cases/kubernetes/demo/server.html">A HTTP server example</a></li>
</ul>
<p>Since we have already built and published those demo apps on Docker Hub, you could also just go straight to the container runtime sections to use these images.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="a-simple-webassembly-example"><a class="header" href="#a-simple-webassembly-example">A simple WebAssembly example</a></h1>
<p>In this article, I will show you how to build a container image for a WebAssembly application. It can then be started and managed by Kubernetes ecosystem tools, such as CRI-O, Docker, crun, and Kubernetes.</p>
<h2 id="prerequisites"><a class="header" href="#prerequisites">Prerequisites</a></h2>
<blockquote>
<p>If you simply want a wasm bytecode file to test as a container image, you can skip the building process and just <a href="https://github.com/second-state/wasm-learning/blob/master/cli/wasi/wasi_example_main.wasm">download the wasm file here</a>.</p>
</blockquote>
<p>If you have not done so already, follow these simple instructions to <a href="https://www.rust-lang.org/tools/install">install Rust</a>.</p>
<h2 id="download-example-code"><a class="header" href="#download-example-code">Download example code</a></h2>
<pre><code class="language-bash">git clone https://github.com/second-state/wasm-learning
cd wasm-learning/cli/wasi
</code></pre>
<h2 id="build-the-wasm-bytecode"><a class="header" href="#build-the-wasm-bytecode">Build the WASM bytecode</a></h2>
<pre><code class="language-bash">rustup target add wasm32-wasi
cargo build --target wasm32-wasi --release
</code></pre>
<p>The wasm bytecode application is in the <code>target/wasm32-wasi/release/wasi_example_main.wasm</code> file. You can now publish and use it as a container image.</p>
<h2 id="apply-executable-permission-on-the-wasm-bytecode"><a class="header" href="#apply-executable-permission-on-the-wasm-bytecode">Apply executable permission on the Wasm bytecode</a></h2>
<pre><code class="language-bash">chmod +x target/wasm32-wasi/release/wasi_example_main.wasm
</code></pre>
<h2 id="create-dockerfile"><a class="header" href="#create-dockerfile">Create Dockerfile</a></h2>
<p>Create a file called <code>Dockerfile</code> in the <code>target/wasm32-wasi/release/</code> folder with the following content:</p>
<pre><code class="language-dockerfile">FROM scratch
ADD wasi_example_main.wasm /
CMD [&quot;/wasi_example_main.wasm&quot;]
</code></pre>
<h2 id="create-container-image-with-annotations"><a class="header" href="#create-container-image-with-annotations">Create container image with annotations</a></h2>
<blockquote>
<p>Please note that adding self-defined annotation is still a new feature in buildah.</p>
</blockquote>
<p>The <code>crun</code> container runtime can start the above WebAssembly-based container image. But it requires the <code>module.wasm.image/variant=compat-smart</code> annotation on the container image to indicate that it is a WebAssembly application without a guest OS. You can find the details in <a href="https://github.com/containers/crun/blob/main/docs/wasm-wasi-example.md">Official crun repo</a>.</p>
<p>To add <code>module.wasm.image/variant=compat-smart</code> annotation in the container image, you will need the latest <a href="https://buildah.io/">buildah</a>. Currently, Docker does not support this feature. Please follow <a href="https://github.com/containers/buildah/blob/main/install.md">the install instructions of buildah</a> to build the latest buildah binary.</p>
<h3 id="build-and-install-the-latest-buildah-on-ubuntu"><a class="header" href="#build-and-install-the-latest-buildah-on-ubuntu">Build and install the latest buildah on Ubuntu</a></h3>
<p>On Ubuntu zesty and xenial, use these commands to prepare for buildah.</p>
<pre><code class="language-bash">sudo apt-get -y install software-properties-common

export OS=&quot;xUbuntu_20.04&quot;
sudo bash -c &quot;echo \&quot;deb https://download.opensuse.org/repositories/devel:/kubic:/libcontainers:/stable/$OS/ /\&quot; &gt; /etc/apt/sources.list.d/devel:kubic:libcontainers:stable.list&quot;
sudo bash -c &quot;curl -L https://download.opensuse.org/repositories/devel:/kubic:/libcontainers:/stable/$OS/Release.key | apt-key add -&quot;

sudo add-apt-repository -y ppa:alexlarsson/flatpak
sudo apt-get -y -qq update
sudo apt-get -y install bats git libapparmor-dev libdevmapper-dev libglib2.0-dev libgpgme-dev libseccomp-dev libselinux1-dev skopeo-containers go-md2man containers-common
sudo apt-get -y install golang-1.16 make
</code></pre>
<p>Then, follow these steps to build and install buildah on Ubuntu.</p>
<pre><code class="language-bash">mkdir -p ~/buildah
cd ~/buildah
export GOPATH=`pwd`
git clone https://github.com/containers/buildah ./src/github.com/containers/buildah
cd ./src/github.com/containers/buildah
PATH=/usr/lib/go-1.16/bin:$PATH make
cp bin/buildah /usr/bin/buildah
buildah --help
</code></pre>
<h3 id="create-and-publish-a-container-image-with-buildah"><a class="header" href="#create-and-publish-a-container-image-with-buildah">Create and publish a container image with buildah</a></h3>
<p>In the <code>target/wasm32-wasi/release/</code> folder, do the following.</p>
<pre><code class="language-bash">$ sudo buildah build --annotation &quot;module.wasm.image/variant=compat-smart&quot; -t wasm-wasi-example .
# make sure docker is install and running
# systemctl status docker
# to make sure regular user can use docker
# sudo usermod -aG docker $USER
# newgrp docker

# You may need to use docker login to create the `~/.docker/config.json` for auth.
$ sudo buildah push --authfile ~/.docker/config.json wasm-wasi-example docker://docker.io/wasmedge/example-wasi:latest
</code></pre>
<p>That's it! Now you can try to run it in <a href="use_cases/kubernetes/demo/../cri/crio.html#run-a-simple-webassembly-app">CRI-O</a> or <a href="use_cases/kubernetes/demo/../kubernetes/kubernetes-crio.html#a-simple-webassembly-app">Kubernetes</a>!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="http-server-example"><a class="header" href="#http-server-example">HTTP server example</a></h1>
<p>Let's build a container image for a WebAssembly HTTP service.
The HTTP service application is developed in Rust using the <a href="https://github.com/second-state/wasmedge_wasi_socket">WasmEdge networking socket API</a>.
Kubernetes could manage the wasm application lifecycle with CRI-O, Docker and Containerd.</p>
<h2 id="prerequisites-1"><a class="header" href="#prerequisites-1">Prerequisites</a></h2>
<p>This is a Rust example, which require you to install <a href="https://www.rust-lang.org/tools/install">Rust</a> and <a href="use_cases/kubernetes/demo/../../../quick_start/install.html">WasmEdge</a> before you can Compile and Run the http service.</p>
<h2 id="download-example-code-1"><a class="header" href="#download-example-code-1">Download example code</a></h2>
<pre><code class="language-bash">mkdir http_server
cd http_server
wget -q https://raw.githubusercontent.com/second-state/wasmedge_wasi_socket/main/examples/http_server/Cargo.toml
mkdir src
cd src
wget -q https://raw.githubusercontent.com/second-state/wasmedge_wasi_socket/main/examples/http_server/src/main.rs
cd ../
</code></pre>
<h2 id="build-the-wasm-bytecode-1"><a class="header" href="#build-the-wasm-bytecode-1">Build the WASM bytecode</a></h2>
<pre><code class="language-bash">rustup target add wasm32-wasi
cargo build --target wasm32-wasi --release
</code></pre>
<p>The wasm bytecode application is now should be located in the <code>./target/wasm32-wasi/release/http_server.wasm</code>
You can now test run it with wasmedge and then publish it as a container image.</p>
<h2 id="apply-executable-permission-on-the-wasm-bytecode-1"><a class="header" href="#apply-executable-permission-on-the-wasm-bytecode-1">Apply executable permission on the Wasm bytecode</a></h2>
<pre><code class="language-bash">chmod +x ./target/wasm32-wasi/release/http_server.wasm
</code></pre>
<h2 id="running-the-http_server-application-bytecode-with-wasmedge"><a class="header" href="#running-the-http_server-application-bytecode-with-wasmedge">Running the http_server application bytecode with wasmedge</a></h2>
<p>When you run the bytecode with wasmedge and see the result as the following, you are ready to package the bytecode into the container.</p>
<pre><code class="language-bash">$ wasmedge ./target/wasm32-wasi/release/http_server.wasm
new connection at 1234
</code></pre>
<p>You can test the server from another terminal window.</p>
<pre><code class="language-bash">$ curl -X POST http://127.0.0.1:1234 -d 'name=WasmEdge'
echo: name=WasmEdge
</code></pre>
<h2 id="create-dockerfile-1"><a class="header" href="#create-dockerfile-1">Create Dockerfile</a></h2>
<p>Create a file called <code>Dockerfile</code> in the <code>target/wasm32-wasi/release/</code> folder with the following content:</p>
<pre><code class="language-dockerfile">FROM scratch
ADD http_server.wasm /
CMD [&quot;/http_server.wasm&quot;]
</code></pre>
<h2 id="create-container-image-with-annotations-1"><a class="header" href="#create-container-image-with-annotations-1">Create container image with annotations</a></h2>
<blockquote>
<p>Please note that adding self-defined annotation is still a new feature in buildah.</p>
</blockquote>
<p>The <code>crun</code> container runtime can start the above WebAssembly-based container image. But it requires the <code>module.wasm.image/variant=compat-smart</code> annotation on the container image to indicate that it is a WebAssembly application without a guest OS. You can find the details in <a href="https://github.com/containers/crun/blob/main/docs/wasm-wasi-example.md">Official crun repo</a>.</p>
<p>To add <code>module.wasm.image/variant=compat-smart</code> annotation in the container image, you will need the latest <a href="https://buildah.io/">buildah</a>. Currently, Docker does not support this feature. Please follow <a href="https://github.com/containers/buildah/blob/main/install.md">the install instructions of buildah</a> to build the latest buildah binary.</p>
<h3 id="build-and-install-the-latest-buildah-on-ubuntu-1"><a class="header" href="#build-and-install-the-latest-buildah-on-ubuntu-1">Build and install the latest buildah on Ubuntu</a></h3>
<p>On Ubuntu zesty and xenial, use these commands to prepare for buildah.</p>
<pre><code class="language-bash">sudo apt-get -y install software-properties-common

export OS=&quot;xUbuntu_20.04&quot;
sudo bash -c &quot;echo \&quot;deb https://download.opensuse.org/repositories/devel:/kubic:/libcontainers:/stable/$OS/ /\&quot; &gt; /etc/apt/sources.list.d/devel:kubic:libcontainers:stable.list&quot;
sudo bash -c &quot;curl -L https://download.opensuse.org/repositories/devel:/kubic:/libcontainers:/stable/$OS/Release.key | apt-key add -&quot;

sudo add-apt-repository -y ppa:alexlarsson/flatpak
sudo apt-get -y -qq update

sudo apt-get -y install bats git libapparmor-dev libdevmapper-dev libglib2.0-dev libgpgme-dev libseccomp-dev libselinux1-dev skopeo-containers go-md2man containers-common
sudo apt-get -y install golang-1.16 make
</code></pre>
<p>Then, follow these steps to build and install buildah on Ubuntu.</p>
<pre><code class="language-bash">mkdir -p ~/buildah
cd ~/buildah
export GOPATH=`pwd`
git clone https://github.com/containers/buildah ./src/github.com/containers/buildah
cd ./src/github.com/containers/buildah
PATH=/usr/lib/go-1.16/bin:$PATH make
cp bin/buildah /usr/bin/buildah
buildah --help
</code></pre>
<h3 id="create-and-publish-a-container-image-with-buildah-1"><a class="header" href="#create-and-publish-a-container-image-with-buildah-1">Create and publish a container image with buildah</a></h3>
<p>In the <code>target/wasm32-wasi/release/</code> folder, do the following.</p>
<pre><code class="language-bash">sudo buildah build --annotation &quot;module.wasm.image/variant=compat-smart&quot; -t http_server .

#
# make sure docker is install and running
# systemctl status docker
# to make sure regular user can use docker
# sudo usermod -aG docker $USER#
# newgrp docker

# You may need to use docker login to create the `~/.docker/config.json` for auth.
#
# docker login

sudo buildah push --authfile ~/.docker/config.json http_server docker://docker.io/wasmedge/example-wasi-http:latest
</code></pre>
<p>That's it! Now you can try to run it in <a href="use_cases/kubernetes/demo/../cri/crio.html#run-a-http-server-app">CRI-O</a> or <a href="use_cases/kubernetes/demo/../kubernetes/kubernetes-crio.html#a-webassembly-based-http-service">Kubernetes</a>!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="container-runtimes"><a class="header" href="#container-runtimes">Container runtimes</a></h1>
<p>The container image can be started by any OCI-compliant container runtime, such as</p>
<ul>
<li><a href="use_cases/kubernetes/container/crun.html">crun</a>: a high performance and lightweight container runtime written in C</li>
<li><a href="use_cases/kubernetes/container/runc.html">runc</a>: a widely used container runtime written in Go</li>
<li><a href="use_cases/kubernetes/container/youki.html">youki</a>: a OCI-compatible container runtime implementation written in Rust</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="crun"><a class="header" href="#crun">crun</a></h1>
<p>The <a href="https://github.com/containers/crun">crun project</a> has WasmEdge support baked in.
For now, the easiest approach is just built it yourself from source. First, let's make sure that <code>crun</code> dependencies are installed on your Ubuntu 20.04.
For other Linux distributions, please <a href="https://github.com/containers/crun#readme">see here</a>.</p>
<pre><code class="language-bash">sudo apt update
sudo apt install -y make git gcc build-essential pkgconf libtool \
    libsystemd-dev libprotobuf-c-dev libcap-dev libseccomp-dev libyajl-dev \
    go-md2man libtool autoconf python3 automake
</code></pre>
<p>Next, configure, build, and install a <code>crun</code> binary with WasmEdge support.</p>
<pre><code class="language-bash">git clone https://github.com/containers/crun
cd crun
./autogen.sh
./configure --with-wasmedge
make
sudo make install
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="runc"><a class="header" href="#runc">runc</a></h1>
<p>Coming soon, or you can <a href="https://github.com/WasmEdge/WasmEdge/issues/639">help out</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="youki"><a class="header" href="#youki">youki</a></h1>
<p>Coming soon, or you can <a href="https://github.com/WasmEdge/WasmEdge/issues/664">help out</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cri-runtimes"><a class="header" href="#cri-runtimes">CRI runtimes</a></h1>
<p>The high-level container runtime, such as <a href="https://cri-o.io/">CRI-O</a> and <a href="https://containerd.io/">containerd</a>, pulls container images from registries (e.g., Docker Hub), manages them on disk, and launches a lower-level runtime to run container processes.
From this chapter, you can check out specific tutorials for CRI-O and containerd.</p>
<ul>
<li><a href="use_cases/kubernetes/cri/crio.html">CRI-O</a></li>
<li><a href="use_cases/kubernetes/cri/containerd.html">containerd</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cri-o"><a class="header" href="#cri-o">CRI-O</a></h1>
<h2 id="quick-start-2"><a class="header" href="#quick-start-2">Quick start</a></h2>
<p>The <a href="https://github.com/second-state/wasmedge-containers-examples/">GitHub repo</a> contains scripts and Github Actions for running our example
apps on CRI-O.</p>
<ul>
<li>Simple WebAssembly example <a href="https://github.com/second-state/wasmedge-containers-examples/blob/main/crio/README.md">Quick start</a> | <a href="https://github.com/second-state/wasmedge-containers-examples/blob/main/.github/workflows/crio.yml">Github Actions</a></li>
<li>HTTP service example <a href="https://github.com/second-state/wasmedge-containers-examples/blob/main/crio/http_server/README.md">Quick start</a> | <a href="https://github.com/second-state/wasmedge-containers-examples/blob/main/.github/workflows/crio-server.yml">Github Actions</a></li>
</ul>
<p>In the sections below, we will explain the steps in the quick start scripts.</p>
<ul>
<li><a href="use_cases/kubernetes/cri/crio.html#install-cri-o">Install CRI-O</a></li>
<li><a href="use_cases/kubernetes/cri/crio.html#configure-cri-o-to-use-crun">Configure CRI-O and crun</a></li>
<li><a href="use_cases/kubernetes/cri/crio.html#run-a-simple-webassembly-app">Example 1: Simple WebAssembly</a></li>
<li><a href="use_cases/kubernetes/cri/crio.html#run-a-http-server-app">Example 2: HTTP server in WebAssembly</a></li>
</ul>
<h2 id="install-cri-o"><a class="header" href="#install-cri-o">Install CRI-O</a></h2>
<p>Use the following commands to install CRI-O on your system.</p>
<pre><code class="language-bash">export OS=&quot;xUbuntu_20.04&quot;
export VERSION=&quot;1.21&quot;
apt update
apt install -y libseccomp2 || sudo apt update -y libseccomp2
echo &quot;deb https://download.opensuse.org/repositories/devel:/kubic:/libcontainers:/stable/$OS/ /&quot; &gt; /etc/apt/sources.list.d/devel:kubic:libcontainers:stable.list
echo &quot;deb https://download.opensuse.org/repositories/devel:/kubic:/libcontainers:/stable:/cri-o:/$VERSION/$OS/ /&quot; &gt; /etc/apt/sources.list.d/devel:kubic:libcontainers:stable:cri-o:$VERSION.list

curl -L https://download.opensuse.org/repositories/devel:kubic:libcontainers:stable:cri-o:$VERSION/$OS/Release.key | apt-key add -
curl -L https://download.opensuse.org/repositories/devel:/kubic:/libcontainers:/stable/$OS/Release.key | apt-key add -

apt-get update
apt-get install criu libyajl2
apt-get install cri-o cri-o-runc cri-tools containernetworking-plugins
systemctl start crio
</code></pre>
<h2 id="configure-cri-o-to-use-crun"><a class="header" href="#configure-cri-o-to-use-crun">Configure CRI-O to use crun</a></h2>
<p>CRI-O uses the <code>runc</code> runtime by default and we need to configure it to use <code>crun</code> instead.
That is done by adding to two configuration files.</p>
<blockquote>
<p>Make sure that you have <a href="use_cases/kubernetes/cri/../container/crun.html">built and installed the <code>crun</code> binary with WasmEdge support</a> before starting the following steps.</p>
</blockquote>
<p>First, create a <code>/etc/crio/crio.conf</code> file and add the following lines as its content. It tells CRI-O to use <code>crun</code> by default.</p>
<pre><code class="language-conf">[crio.runtime]
default_runtime = &quot;crun&quot;
</code></pre>
<p>The <code>crun</code> runtime is in turn defined in the <code>/etc/crio/crio.conf.d/01-crio-runc.conf</code> file.</p>
<pre><code class="language-conf">[crio.runtime.runtimes.runc]
runtime_path = &quot;/usr/lib/cri-o-runc/sbin/runc&quot;
runtime_type = &quot;oci&quot;
runtime_root = &quot;/run/runc&quot;
# The above is the original content

# Add our crunw runtime here
[crio.runtime.runtimes.crun]
runtime_path = &quot;/usr/bin/crun&quot;
runtime_type = &quot;oci&quot;
runtime_root = &quot;/run/crun&quot;
</code></pre>
<p>Next, restart CRI-O to apply the configuration changes.</p>
<pre><code class="language-bash">systemctl restart crio
</code></pre>
<h2 id="run-a-simple-webassembly-app"><a class="header" href="#run-a-simple-webassembly-app">Run a simple WebAssembly app</a></h2>
<p>Now, we can run a simple WebAssembly program using CRI-O.
<a href="use_cases/kubernetes/cri/../demo/wasi.html">A separate article</a> explains how to compile, package, and publish the WebAssembly
program as a container image to Docker hub.
In this section, we will start off pulling this WebAssembly-based container
image from Docker hub using CRI-O tools.</p>
<pre><code class="language-bash">sudo crictl pull docker.io/hydai/wasm-wasi-example:with-wasm-annotation
</code></pre>
<p>Next, we need to create two simple configuration files that specifies how
CRI-O should run this WebAssembly image in a sandbox. We already have those
two files <a href="https://github.com/second-state/wasmedge-containers-examples/blob/main/crio/container_wasi.json">container_wasi.json</a> and <a href="https://github.com/second-state/wasmedge-containers-examples/blob/main/crio/sandbox_config.json">sandbox_config.json</a>.
You can just download them to your local directory as follows.</p>
<pre><code class="language-bash">wget https://raw.githubusercontent.com/second-state/wasmedge-containers-examples/main/crio/sandbox_config.json
wget https://raw.githubusercontent.com/second-state/wasmedge-containers-examples/main/crio/container_wasi.json
</code></pre>
<p>Now you can use CRI-O to create a pod and a container using the specified configurations.</p>
<pre><code class="language-bash"># Create the POD. Output will be different from example.
$ sudo crictl runp sandbox_config.json
7992e75df00cc1cf4bff8bff660718139e3ad973c7180baceb9c84d074b516a4
# Set a helper variable for later use.
$ POD_ID=7992e75df00cc1cf4bff8bff660718139e3ad973c7180baceb9c84d074b516a4

# Create the container instance. Output will be different from example.
$ sudo crictl create $POD_ID container_wasi.json sandbox_config.json
# Set a helper variable for later use.
CONTAINER_ID=1d056e4a8a168f0c76af122d42c98510670255b16242e81f8e8bce8bd3a4476f
</code></pre>
<p>Starting the container would execute the WebAssembly program. You can see the output in the console.</p>
<pre><code class="language-bash"># List the container, the state should be `Created`
$ sudo crictl ps -a
CONTAINER           IMAGE                                          CREATED              STATE               NAME                     ATTEMPT             POD ID
1d056e4a8a168       wasmedge/example-wasi:latest                   About a minute ago   Created             podsandbox1-wasm-wasi   0                   7992e75df00cc

# Start the container
$ sudo crictl start $CONTAINER_ID

# Check the container status again.
# If the container is not finishing its job, you will see the Running state
# Because this example is very tiny. You may see Exited at this moment.
$ sudo crictl ps -a
CONTAINER           IMAGE                                          CREATED              STATE               NAME                     ATTEMPT             POD ID
1d056e4a8a168       wasmedge/example-wasi:latest                   About a minute ago   Running             podsandbox1-wasm-wasi   0                   7992e75df00cc

# When the container is finished. You can see the state becomes Exited.
$ sudo crictl ps -a
CONTAINER           IMAGE                                          CREATED              STATE               NAME                     ATTEMPT             POD ID
1d056e4a8a168       wasmedge/example-wasi:latest                   About a minute ago   Exited              podsandbox1-wasm-wasi   0                   7992e75df00cc

# Check the container's logs. It should show outputs from the WebAssembly programs
$ sudo crictl logs $CONTAINER_ID

Test 1: Print Random Number
Random number: 960251471

Test 2: Print Random Bytes
Random bytes: [50, 222, 62, 128, 120, 26, 64, 42, 210, 137, 176, 90, 60, 24, 183, 56, 150, 35, 209, 211, 141, 146, 2, 61, 215, 167, 194, 1, 15, 44, 156, 27, 179, 23, 241, 138, 71, 32, 173, 159, 180, 21, 198, 197, 247, 80, 35, 75, 245, 31, 6, 246, 23, 54, 9, 192, 3, 103, 72, 186, 39, 182, 248, 80, 146, 70, 244, 28, 166, 197, 17, 42, 109, 245, 83, 35, 106, 130, 233, 143, 90, 78, 155, 29, 230, 34, 58, 49, 234, 230, 145, 119, 83, 44, 111, 57, 164, 82, 120, 183, 194, 201, 133, 106, 3, 73, 164, 155, 224, 218, 73, 31, 54, 28, 124, 2, 38, 253, 114, 222, 217, 202, 59, 138, 155, 71, 178, 113]

Test 3: Call an echo function
Printed from wasi: This is from a main function
This is from a main function

Test 4: Print Environment Variables
The env vars are as follows.
PATH: /usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
TERM: xterm
HOSTNAME: crictl_host
PATH: /usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
The args are as follows.
/var/lib/containers/storage/overlay/006e7cf16e82dc7052994232c436991f429109edea14a8437e74f601b5ee1e83/merged/wasi_example_main.wasm
50000000

Test 5: Create a file `/tmp.txt` with content `This is in a file`

Test 6: Read the content from the previous file
File content is This is in a file

Test 7: Delete the previous file
</code></pre>
<p>Next, you can try to run the app in <a href="use_cases/kubernetes/cri/../kubernetes/kubernetes-crio.html">Kubernetes</a>!</p>
<h2 id="run-a-http-server-app"><a class="header" href="#run-a-http-server-app">Run a HTTP server app</a></h2>
<p>Finally, we can run a simple WebAssembly-based HTTP micro-service in CRI-O.
<a href="use_cases/kubernetes/cri/../demo/server.html">A separate article</a> explains how to compile, package, and publish the WebAssembly
program as a container image to Docker hub.
In this section, we will start off pulling this WebAssembly-based container
image from Docker hub using CRI-O tools.</p>
<pre><code class="language-bash">sudo crictl pull docker.io/avengermojo/http_server:with-wasm-annotation
</code></pre>
<p>Next, we need to create two simple configuration files that specifies how
CRI-O should run this WebAssembly image in a sandbox. We already have those
two files <a href="https://raw.githubusercontent.com/second-state/wasmedge-containers-examples/main/crio/http_server/container_http_server.json">container_http_server.json</a> and <a href="https://github.com/second-state/wasmedge-containers-examples/blob/main/crio/sandbox_config.json">sandbox_config.json</a>.
You can just download them to your local directory as follows.</p>
<blockquote>
<p>The <code>sandbox_config.json</code> file is the same for the simple WASI example and the HTTP server example. The other <code>container_*.json</code> file is application specific as it contains the application's Docker Hub URL.</p>
</blockquote>
<pre><code class="language-bash">wget https://raw.githubusercontent.com/second-state/wasmedge-containers-examples/main/crio/sandbox_config.json
wget https://raw.githubusercontent.com/second-state/wasmedge-containers-examples/main/crio/http_server/container_http_server.json
</code></pre>
<p>Now you can use CRI-O to create a pod and a container using the specified configurations.</p>
<pre><code class="language-bash"># Create the POD. Output will be different from example.
$ sudo crictl runp sandbox_config.json
7992e75df00cc1cf4bff8bff660718139e3ad973c7180baceb9c84d074b516a4
# Set a helper variable for later use.
$ POD_ID=7992e75df00cc1cf4bff8bff660718139e3ad973c7180baceb9c84d074b516a4

# Create the container instance. Output will be different from example.
$ sudo crictl create $POD_ID container_http_server.json sandbox_config.json
# Set a helper variable for later use.
CONTAINER_ID=1d056e4a8a168f0c76af122d42c98510670255b16242e81f8e8bce8bd3a4476f
</code></pre>
<p>Starting the container would execute the WebAssembly program. You can see the output in the console.</p>
<pre><code class="language-bash"># Start the container
$ sudo crictl start $CONTAINER_ID

# Check the container status. It should be Running. 
# If not, wait a few seconds and check again
$ sudo crictl ps -a
CONTAINER           IMAGE                                          CREATED                  STATE               NAME                ATTEMPT             POD ID
4eeddf8613691       wasmedge/example-wasi-http:latest              Less than a second ago   Running             http_server         0                   1d84f30e7012e

# Check the container's logs to see the HTTP server is listening at port 1234
$ sudo crictl logs $CONTAINER_ID
new connection at 1234

# Get the IP address assigned to the container
$ sudo crictl inspect $CONTAINER_ID | grep IP.0 | cut -d: -f 2 | cut -d'&quot;' -f 2
10.85.0.2

# Test the HTTP service at that IP address
$ curl -d &quot;name=WasmEdge&quot; -X POST http://10.85.0.2:1234
echo: name=WasmEdge
</code></pre>
<p>Next, you can try to run it in <a href="use_cases/kubernetes/cri/../kubernetes/kubernetes-crio.html">Kubernetes</a>!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="containerd"><a class="header" href="#containerd">containerd</a></h1>
<h2 id="quick-start-3"><a class="header" href="#quick-start-3">Quick start</a></h2>
<p>The <a href="https://github.com/second-state/wasmedge-containers-examples/">GitHub repo</a> contains scripts and Github Actions for running our example
apps on containerd.</p>
<ul>
<li>Simple WebAssembly example <a href="https://github.com/second-state/wasmedge-containers-examples/blob/main/containerd/README.md">Quick start</a> | <a href="https://github.com/second-state/wasmedge-containers-examples/blob/main/.github/workflows/containerd.yml">Github Actions</a></li>
<li>HTTP service example <a href="https://github.com/second-state/wasmedge-containers-examples/blob/main/containerd/http_server/README.md">Quick start</a> | <a href="https://github.com/second-state/wasmedge-containers-examples/blob/main/.github/workflows/containerd-server.yml">Github Actions</a></li>
</ul>
<p>In the sections below, we will explain the steps in the quick start scripts.</p>
<ul>
<li><a href="use_cases/kubernetes/cri/containerd.html#install-containerd">Install containerd</a></li>
<li><a href="use_cases/kubernetes/cri/containerd.html#run-a-simple-webassembly-app">Example 1: Simple WebAssembly</a></li>
<li><a href="use_cases/kubernetes/cri/containerd.html#run-a-http-server-app">Example 2: HTTP server in WebAssembly</a></li>
</ul>
<h2 id="install-containerd"><a class="header" href="#install-containerd">Install containerd</a></h2>
<p>Use the following commands to install containerd on your system.</p>
<pre><code class="language-bash">export VERSION=&quot;1.5.7&quot;
echo -e &quot;Version: $VERSION&quot;
echo -e &quot;Installing libseccomp2 ...&quot;
sudo apt install -y libseccomp2
echo -e &quot;Installing wget&quot;
sudo apt install -y wget

wget https://github.com/containerd/containerd/releases/download/v${VERSION}/cri-containerd-cni-${VERSION}-linux-amd64.tar.gz
wget https://github.com/containerd/containerd/releases/download/v${VERSION}/cri-containerd-cni-${VERSION}-linux-amd64.tar.gz.sha256sum
sha256sum --check cri-containerd-cni-${VERSION}-linux-amd64.tar.gz.sha256sum

sudo tar --no-overwrite-dir -C / -xzf cri-containerd-cni-${VERSION}-linux-amd64.tar.gz
sudo systemctl daemon-reload
</code></pre>
<p>Configure containerd to use <code>crun</code> as the underlying OCI runtime.
It makes changes to the <code>/etc/containerd/config.toml</code> file.</p>
<pre><code class="language-bash">sudo mkdir -p /etc/containerd/
sudo bash -c &quot;containerd config default &gt; /etc/containerd/config.toml&quot;
wget https://raw.githubusercontent.com/second-state/wasmedge-containers-examples/main/containerd/containerd_config.diff
sudo patch -d/ -p0 &lt; containerd_config.diff
</code></pre>
<p>Start the containerd service.</p>
<pre><code class="language-bash">sudo systemctl start containerd
</code></pre>
<p>Next, make sure that you have <a href="use_cases/kubernetes/cri/../container/crun.html">built and installed the <code>crun</code> binary with WasmEdge support</a> before running the following examples.</p>
<h2 id="run-a-simple-webassembly-app-1"><a class="header" href="#run-a-simple-webassembly-app-1">Run a simple WebAssembly app</a></h2>
<p>Now, we can run a simple WebAssembly program using containerd.
<a href="use_cases/kubernetes/cri/../demo/wasi.html">A separate article</a> explains how to compile, package, and publish the WebAssembly
program as a container image to Docker hub.
In this section, we will start off pulling this WebAssembly-based container
image from Docker hub using containerd tools.</p>
<pre><code class="language-bash">sudo ctr i pull docker.io/wasmedge/example-wasi:latest
</code></pre>
<p>Now, you can run the example in just one line with ctr (the containerd cli).</p>
<pre><code class="language-bash">sudo ctr run --rm --runc-binary crun --runtime io.containerd.runc.v2 --label module.wasm.image/variant=compat-smart docker.io/wasmedge/example-wasi:latest wasm-example /wasi_example_main.wasm 50000000
</code></pre>
<p>Starting the container would execute the WebAssembly program. You can see the output in the console.</p>
<pre><code class="language-bash">Creating POD ...
Random number: -1678124602
Random bytes: [12, 222, 246, 184, 139, 182, 97, 3, 74, 155, 107, 243, 20, 164, 175, 250, 60, 9, 98, 25, 244, 92, 224, 233, 221, 196, 112, 97, 151, 155, 19, 204, 54, 136, 171, 93, 204, 129, 177, 163, 187, 52, 33, 32, 63, 104, 128, 20, 204, 60, 40, 183, 236, 220, 130, 41, 74, 181, 103, 178, 43, 231, 92, 211, 219, 47, 223, 137, 70, 70, 132, 96, 208, 126, 142, 0, 133, 166, 112, 63, 126, 164, 122, 49, 94, 80, 26, 110, 124, 114, 108, 90, 62, 250, 195, 19, 189, 203, 175, 189, 236, 112, 203, 230, 104, 130, 150, 39, 113, 240, 17, 252, 115, 42, 12, 185, 62, 145, 161, 3, 37, 161, 195, 138, 232, 39, 235, 222]
Printed from wasi: This is from a main function
This is from a main function
The env vars are as follows.
The args are as follows.
/wasi_example_main.wasm
50000000
File content is This is in a file
</code></pre>
<p>Next, you can try to run it in <a href="use_cases/kubernetes/cri/../kubernetes/kubernetes-containerd.html#a-simple-webassembly-app">Kubernetes</a>!</p>
<h2 id="run-a-http-server-app-1"><a class="header" href="#run-a-http-server-app-1">Run a HTTP server app</a></h2>
<p>Finally, we can run a simple WebAssembly-based HTTP micro-service in containerd.
<a href="use_cases/kubernetes/cri/../demo/server.html">A separate article</a> explains how to compile, package, and publish the WebAssembly
program as a container image to Docker hub.
In this section, we will start off pulling this WebAssembly-based container
image from Docker hub using containerd tools.</p>
<pre><code class="language-bash">sudo ctr i pull docker.io/wasmedge/example-wasi-http:latest
</code></pre>
<p>Now, you can run the example in just one line with ctr (the containerd cli). Notice that we are running the container with <code>--net-host</code> so that the HTTP server inside the WasmEdge container is accessible from the outside shell.</p>
<pre><code class="language-bash">sudo ctr run --rm --net-host --runc-binary crun --runtime io.containerd.runc.v2 --label module.wasm.image/variant=compat-smart docker.io/wasmedge/example-wasi-http:latest http-server-example /http_server.wasm
</code></pre>
<p>Starting the container would execute the WebAssembly program. You can see the output in the console.</p>
<pre><code class="language-bash">new connection at 1234

# Test the HTTP service at that IP address
curl -d &quot;name=WasmEdge&quot; -X POST http://127.0.0.1:1234
echo: name=WasmEdge
</code></pre>
<p>Next, you can try to run it in <a href="use_cases/kubernetes/cri/../kubernetes/kubernetes-containerd.html#a-webassembly-based-http-service">Kubernetes</a>!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="kubernetes"><a class="header" href="#kubernetes">Kubernetes</a></h1>
<p>Most high-level container runtimes implement Kubernetes' CRI (Container Runtime Interface) spec so that they can be managed by Kubernetes tools. That means you can use Kubernetes tools to manage the WebAssembly app image in pods and namespaces.
Check out specific instructions for different flavors of Kubernetes setup in this chapter.</p>
<ul>
<li><a href="use_cases/kubernetes/kubernetes/kubernetes-crio.html">Kubernetes + CRI-O</a></li>
<li><a href="use_cases/kubernetes/kubernetes/kubernetes-containerd.html">Kubernetes + containerd</a></li>
<li><a href="use_cases/kubernetes/kubernetes/kind.html">KinD</a></li>
<li><a href="use_cases/kubernetes/kubernetes/kubeedge.html">KubeEdge</a></li>
<li><a href="use_cases/kubernetes/kubernetes/superedge.html">SuperEdge</a></li>
<li><a href="use_cases/kubernetes/kubernetes/openyurt.html">OpenYurt</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="kubernetes--cri-o"><a class="header" href="#kubernetes--cri-o">Kubernetes + CRI-O</a></h1>
<h2 id="quick-start-4"><a class="header" href="#quick-start-4">Quick start</a></h2>
<p>The <a href="https://github.com/second-state/wasmedge-containers-examples/">GitHub repo</a> contains scripts and Github Actions for running our example apps on Kubernetes + CRI-O.</p>
<ul>
<li>Simple WebAssembly example <a href="https://github.com/second-state/wasmedge-containers-examples/blob/main/kubernetes_crio/README.md">Quick start</a> | <a href="https://github.com/second-state/wasmedge-containers-examples/blob/main/.github/workflows/kubernetes-crio.yml">Github Actions</a></li>
<li>WebAssembly-based HTTP service <a href="https://github.com/second-state/wasmedge-containers-examples/blob/main/kubernetes_crio/http_server/README.md">Quick start</a> | <a href="https://github.com/second-state/wasmedge-containers-examples/blob/main/.github/workflows/kubernetes-crio-server.yml">Github Actions</a></li>
</ul>
<p>In the rest of this section, we will explain the steps in detail.
We will assume that you have already <a href="use_cases/kubernetes/kubernetes/../cri/crio.html">installed and configured CRI-O</a> to work with WasmEdge container images.</p>
<h2 id="install-and-start-kubernetes"><a class="header" href="#install-and-start-kubernetes">Install and start Kubernetes</a></h2>
<p>Run the following commands from a terminal window.
It sets up Kubernetes for local development.</p>
<pre><code class="language-bash"># Install go
$ wget https://golang.org/dl/go1.17.1.linux-amd64.tar.gz
$ sudo rm -rf /usr/local/go
sudo tar -C /usr/local -xzf go1.17.1.linux-amd64.tar.gz
source /home/${USER}/.profile

# Clone k8s
git clone https://github.com/kubernetes/kubernetes.git
cd kubernetes
git checkout v1.22.2

# Install etcd with hack script in k8s
sudo CGROUP_DRIVER=systemd CONTAINER_RUNTIME=remote CONTAINER_RUNTIME_ENDPOINT='unix:///var/run/crio/crio.sock' ./hack/install-etcd.sh
export PATH=&quot;/home/${USER}/kubernetes/third_party/etcd:${PATH}&quot;
sudo cp third_party/etcd/etcd* /usr/local/bin/

# After run the above command, you can find the following files: /usr/local/bin/etcd  /usr/local/bin/etcdctl  /usr/local/bin/etcdutl

# Build and run k8s with CRI-O
sudo apt-get install -y build-essential
sudo CGROUP_DRIVER=systemd CONTAINER_RUNTIME=remote CONTAINER_RUNTIME_ENDPOINT='unix:///var/run/crio/crio.sock' ./hack/local-up-cluster.sh

... ...
Local Kubernetes cluster is running. Press Ctrl-C to shut it down.
</code></pre>
<p>Do NOT close your terminal window. Kubernetes is running!</p>
<h2 id="run-webassembly-container-images-in-kubernetes"><a class="header" href="#run-webassembly-container-images-in-kubernetes">Run WebAssembly container images in Kubernetes</a></h2>
<p>Finally, we can run WebAssembly programs in Kubernetes as containers in pods.
In this section, we will start from <strong>another terminal window</strong> and start using the cluster.</p>
<pre><code class="language-bash">export KUBERNETES_PROVIDER=local

sudo cluster/kubectl.sh config set-cluster local --server=https://localhost:6443 --certificate-authority=/var/run/kubernetes/server-ca.crt
sudo cluster/kubectl.sh config set-credentials myself --client-key=/var/run/kubernetes/client-admin.key --client-certificate=/var/run/kubernetes/client-admin.crt
sudo cluster/kubectl.sh config set-context local --cluster=local --user=myself
sudo cluster/kubectl.sh config use-context local
sudo cluster/kubectl.sh
</code></pre>
<p>Let's check the status to make sure that the cluster is running.</p>
<pre><code class="language-bash">$ sudo cluster/kubectl.sh cluster-info

# Expected output
Cluster &quot;local&quot; set.
User &quot;myself&quot; set.
Context &quot;local&quot; created.
Switched to context &quot;local&quot;.
Kubernetes control plane is running at https://localhost:6443
CoreDNS is running at https://localhost:6443/api/v1/namespaces/kube-system/services/kube-dns:dns/proxy

To further debug and diagnose cluster problems, use 'kubectl cluster-info dump'.
</code></pre>
<h3 id="a-simple-webassembly-app"><a class="header" href="#a-simple-webassembly-app">A simple WebAssembly app</a></h3>
<p><a href="use_cases/kubernetes/kubernetes/../demo/wasi.html">A separate article</a> explains how to compile, package, and publish a simple WebAssembly WASI program as a container image to Docker hub.
Run the WebAssembly-based image from Docker Hub in the Kubernetes cluster as follows.</p>
<pre><code class="language-bash">sudo cluster/kubectl.sh run -it --rm --restart=Never wasi-demo --image=wasmedge/example-wasi:latest --annotations=&quot;module.wasm.image/variant=compat-smart&quot; /wasi_example_main.wasm 50000000
</code></pre>
<p>The output from the containerized application is printed into the console.</p>
<pre><code class="language-bash">Random number: 401583443
Random bytes: [192, 226, 162, 92, 129, 17, 186, 164, 239, 84, 98, 255, 209, 79, 51, 227, 103, 83, 253, 31, 78, 239, 33, 218, 68, 208, 91, 56, 37, 200, 32, 12, 106, 101, 241, 78, 161, 16, 240, 158, 42, 24, 29, 121, 78, 19, 157, 185, 32, 162, 95, 214, 175, 46, 170, 100, 212, 33, 27, 190, 139, 121, 121, 222, 230, 125, 251, 21, 210, 246, 215, 127, 176, 224, 38, 184, 201, 74, 76, 133, 233, 129, 48, 239, 106, 164, 190, 29, 118, 71, 79, 203, 92, 71, 68, 96, 33, 240, 228, 62, 45, 196, 149, 21, 23, 143, 169, 163, 136, 206, 214, 244, 26, 194, 25, 101, 8, 236, 247, 5, 164, 117, 40, 220, 52, 217, 92, 179]
Printed from wasi: This is from a main function
This is from a main function
The env vars are as follows.
The args are as follows.
/wasi_example_main.wasm
50000000
File content is This is in a file
pod &quot;wasi-demo-2&quot; deleted
</code></pre>
<h3 id="a-webassembly-based-http-service"><a class="header" href="#a-webassembly-based-http-service">A WebAssembly-based HTTP service</a></h3>
<p><a href="use_cases/kubernetes/kubernetes/../demo/server.html">A separate article</a> explains how to compile, package, and publish a simple WebAssembly HTTP service application as a container image to Docker hub.
Since the HTTP service container requires networking support provided by Kubernetes, we will use a <a href="https://github.com/second-state/wasmedge-containers-examples/blob/main/kubernetes_crio/http_server/k8s-http_server.yaml">k8s-http_server.yaml</a> file to specify its exact configuration.</p>
<pre><code class="language-yaml">apiVersion: v1
kind: Pod
metadata:
  name: http-server
  namespace: default
  annotations:
    module.wasm.image/variant: compat-smart
spec:
  hostNetwork: true
  containers:
  - name: http-server
    image: wasmedge/example-wasi-http:latest
    command: [ &quot;/http_server.wasm&quot; ]
    ports:
    - containerPort: 1234
      protocol: TCP
    livenessProbe:
      tcpSocket:
        port: 1234
      initialDelaySeconds: 3
      periodSeconds: 30
</code></pre>
<p>Run the WebAssembly-based image from Docker Hub using the above <code>k8s-http_server.yaml</code> file in the Kubernetes cluster as follows.</p>
<pre><code class="language-bash">sudo ./kubernetes/cluster/kubectl.sh apply -f k8s-http_server.yaml
</code></pre>
<p>Use the following command to see the running container applications and their IP addresses.
Since we are using <code>hostNetwork</code> in the yaml configuration, the HTTP server image is running on the local network with IP address <code>127.0.0.1</code>.</p>
<pre><code class="language-bash">$ sudo cluster/kubectl.sh get pod --all-namespaces -o wide

NAMESPACE     NAME                       READY   STATUS             RESTARTS      AGE   IP          NODE        NOMINATED NODE   READINESS GATES
default       http-server                1/1     Running            1 (26s ago)     60s     127.0.0.1   127.0.0.1   &lt;none&gt;           &lt;none&gt;
</code></pre>
<p>Now, you can use the <code>curl</code> command to access the HTTP service.</p>
<pre><code class="language-bash">$ curl -d &quot;name=WasmEdge&quot; -X POST http://127.0.0.1:1234
echo: name=WasmEdge
</code></pre>
<p>That's it!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="kubernetes--containerd"><a class="header" href="#kubernetes--containerd">Kubernetes + containerd</a></h1>
<h2 id="quick-start-5"><a class="header" href="#quick-start-5">Quick start</a></h2>
<p>The <a href="https://github.com/second-state/wasmedge-containers-examples/">GitHub repo</a> contains scripts and Github Actions for running our example apps on Kubernetes + containerd.</p>
<ul>
<li>Simple WebAssembly example <a href="https://github.com/second-state/wasmedge-containers-examples/blob/main/kubernetes_containerd/README.md">Quick start</a> | <a href="https://github.com/second-state/wasmedge-containers-examples/blob/main/.github/workflows/kubernetes-containerd.yml">Github Actions</a></li>
<li>WebAssembly-based HTTP service <a href="https://github.com/second-state/wasmedge-containers-examples/blob/main/kubernetes_containerd/http_server/README.md">Quick start</a> | <a href="https://github.com/second-state/wasmedge-containers-examples/blob/main/.github/workflows/kubernetes-containerd-server.yml">Github Actions</a></li>
</ul>
<p>In the rest of this section, we will explain the steps in detail.
We will assume that you have already <a href="use_cases/kubernetes/kubernetes/../cri/containerd.html">installed and configured containerd</a> to work with WasmEdge container images.</p>
<h2 id="install-and-start-kubernetes-1"><a class="header" href="#install-and-start-kubernetes-1">Install and start Kubernetes</a></h2>
<p>Run the following commands from a terminal window.
It sets up Kubernetes for local development.</p>
<pre><code class="language-bash"># Install go
$ wget https://golang.org/dl/go1.17.1.linux-amd64.tar.gz
$ sudo rm -rf /usr/local/go
$ sudo tar -C /usr/local -xzf go1.17.1.linux-amd64.tar.gz
$ source /home/${USER}/.profile

# Clone k8s
$ git clone https://github.com/kubernetes/kubernetes.git
$ cd kubernetes
$ git checkout v1.22.2

# Install etcd with hack script in k8s
$ sudo CGROUP_DRIVER=systemd CONTAINER_RUNTIME=remote CONTAINER_RUNTIME_ENDPOINT='unix:///var/run/crio/crio.sock' ./hack/install-etcd.sh
$ export PATH=&quot;/home/${USER}/kubernetes/third_party/etcd:${PATH}&quot;
$ sudo cp third_party/etcd/etcd* /usr/local/bin/

# After run the above command, you can find the following files: /usr/local/bin/etcd  /usr/local/bin/etcdctl  /usr/local/bin/etcdutl

# Build and run k8s with containerd
$ sudo apt-get install -y build-essential
$ sudo CGROUP_DRIVER=systemd CONTAINER_RUNTIME=remote CONTAINER_RUNTIME_ENDPOINT='unix:///var/run/crio/crio.sock' ./hack/local-up-cluster.sh

... ...
Local Kubernetes cluster is running. Press Ctrl-C to shut it down.
</code></pre>
<p>Do NOT close your terminal window. Kubernetes is running!</p>
<h2 id="run-webassembly-container-images-in-kubernetes-1"><a class="header" href="#run-webassembly-container-images-in-kubernetes-1">Run WebAssembly container images in Kubernetes</a></h2>
<p>Finally, we can run WebAssembly programs in Kubernetes as containers in pods.
In this section, we will start from <strong>another terminal window</strong> and start using the cluster.</p>
<pre><code class="language-bash">export KUBERNETES_PROVIDER=local

sudo cluster/kubectl.sh config set-cluster local --server=https://localhost:6443 --certificate-authority=/var/run/kubernetes/server-ca.crt
sudo cluster/kubectl.sh config set-credentials myself --client-key=/var/run/kubernetes/client-admin.key --client-certificate=/var/run/kubernetes/client-admin.crt
sudo cluster/kubectl.sh config set-context local --cluster=local --user=myself
sudo cluster/kubectl.sh config use-context local
sudo cluster/kubectl.sh
</code></pre>
<p>Let's check the status to make sure that the cluster is running.</p>
<pre><code class="language-bash">$ sudo cluster/kubectl.sh cluster-info

# Expected output
Cluster &quot;local&quot; set.
User &quot;myself&quot; set.
Context &quot;local&quot; created.
Switched to context &quot;local&quot;.
Kubernetes control plane is running at https://localhost:6443
CoreDNS is running at https://localhost:6443/api/v1/namespaces/kube-system/services/kube-dns:dns/proxy

To further debug and diagnose cluster problems, use 'kubectl cluster-info dump'.
</code></pre>
<h3 id="a-simple-webassembly-app-1"><a class="header" href="#a-simple-webassembly-app-1">A simple WebAssembly app</a></h3>
<p><a href="use_cases/kubernetes/kubernetes/../demo/wasi.html">A separate article</a> explains how to compile, package, and publish a simple WebAssembly WASI program as a container image to Docker hub.
Run the WebAssembly-based image from Docker Hub in the Kubernetes cluster as follows.</p>
<pre><code class="language-bash">sudo cluster/kubectl.sh run -it --rm --restart=Never wasi-demo --image=wasmedge/example-wasi:latest --annotations=&quot;module.wasm.image/variant=compat-smart&quot; --overrides='{&quot;kind&quot;:&quot;Pod&quot;, &quot;apiVersion&quot;:&quot;v1&quot;, &quot;spec&quot;: {&quot;hostNetwork&quot;: true}}' /wasi_example_main.wasm 50000000
</code></pre>
<p>The output from the containerized application is printed into the console.</p>
<pre><code class="language-bash">Random number: 401583443
Random bytes: [192, 226, 162, 92, 129, 17, 186, 164, 239, 84, 98, 255, 209, 79, 51, 227, 103, 83, 253, 31, 78, 239, 33, 218, 68, 208, 91, 56, 37, 200, 32, 12, 106, 101, 241, 78, 161, 16, 240, 158, 42, 24, 29, 121, 78, 19, 157, 185, 32, 162, 95, 214, 175, 46, 170, 100, 212, 33, 27, 190, 139, 121, 121, 222, 230, 125, 251, 21, 210, 246, 215, 127, 176, 224, 38, 184, 201, 74, 76, 133, 233, 129, 48, 239, 106, 164, 190, 29, 118, 71, 79, 203, 92, 71, 68, 96, 33, 240, 228, 62, 45, 196, 149, 21, 23, 143, 169, 163, 136, 206, 214, 244, 26, 194, 25, 101, 8, 236, 247, 5, 164, 117, 40, 220, 52, 217, 92, 179]
Printed from wasi: This is from a main function
This is from a main function
The env vars are as follows.
The args are as follows.
/wasi_example_main.wasm
50000000
File content is This is in a file
pod &quot;wasi-demo-2&quot; deleted
</code></pre>
<h3 id="a-webassembly-based-http-service-1"><a class="header" href="#a-webassembly-based-http-service-1">A WebAssembly-based HTTP service</a></h3>
<p><a href="use_cases/kubernetes/kubernetes/../demo/server.html">A separate article</a> explains how to compile, package, and publish a simple WebAssembly HTTP service application as a container image to Docker hub.
Run the WebAssembly-based image from Docker Hub in the Kubernetes cluster as follows.</p>
<pre><code class="language-bash">sudo cluster/kubectl.sh run --restart=Never http-server --image=wasmedge/example-wasi-http:latest --annotations=&quot;module.wasm.image/variant=compat-smart&quot; --overrides='{&quot;kind&quot;:&quot;Pod&quot;, &quot;apiVersion&quot;:&quot;v1&quot;, &quot;spec&quot;: {&quot;hostNetwork&quot;: true}}'
</code></pre>
<p>Since we are using <code>hostNetwork</code> in the <code>kubectl run</code> command, the HTTP server image is running on the local network with IP address <code>127.0.0.1</code>.
Now, you can use the <code>curl</code> command to access the HTTP service.</p>
<pre><code class="language-bash">$ curl -d &quot;name=WasmEdge&quot; -X POST http://127.0.0.1:1234
echo: name=WasmEdge
</code></pre>
<p>That's it!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="kubernetes-in-docker-kind"><a class="header" href="#kubernetes-in-docker-kind">Kubernetes in Docker (KinD)</a></h1>
<p>KinD is a Kubernetes distribution that runs inside Docker and is well suited for local development or integration testing. It runs containerd as CRI and runc as OCI Runtime.</p>
<h2 id="quick-start-6"><a class="header" href="#quick-start-6">Quick start</a></h2>
<p>As prerequisite we need to install KinD first. To do that the <a href="https://kind.sigs.k8s.io/docs/user/quick-start/#installing-from-release-binaries">quick start guide</a> and the <a href="https://github.com/kubernetes-sigs/kind/releases">release page</a> can be used to install the latest version of the KinD CLI.</p>
<p>If KinD is installed we can directly start with the example from <a href="https://github.com/Liquid-Reply/kind-crun-wasm">here</a>:</p>
<pre><code class="language-bash"># Create a &quot;WASM in KinD&quot; Cluster
kind create cluster --image ghcr.io/liquid-reply/kind-crun-wasm:v1.23.0
# Run the example
kubectl run -it --rm --restart=Never wasi-demo --image=wasmedge/example-wasi:latest --annotations=&quot;module.wasm.image/variant=compat-smart&quot; /wasi_example_main.wasm 50000000
</code></pre>
<p>In the rest of this section, we will explain how to create a KinD node image with wasmedge support.</p>
<h2 id="build-crun"><a class="header" href="#build-crun">Build crun</a></h2>
<p>KinD uses the <code>kindest/node</code> image for the control plane and worker nodes. The image contains containerd as CRI and runc as OCI Runtime. To enable WasmEdge support we replace <code>runc</code> with <code>crun</code>.</p>
<p>For the node image we only need the crun binary and not the entire build toolchain. Therefore we use a multistage dockerfile where we create crun in the first step and only copy the crun binary to the node image.</p>
<pre><code class="language-Dockerfile">FROM ubuntu:21.10 AS builder
WORKDIR /data
RUN DEBIAN_FRONTEND=noninteractive apt update \
    &amp;&amp; DEBIAN_FRONTEND=noninteractive apt install -y curl make git gcc build-essential pkgconf libtool libsystemd-dev libprotobuf-c-dev libcap-dev libseccomp-dev libyajl-dev go-md2man libtool autoconf python3 automake \
    &amp;&amp; curl https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/utils/install.sh | bash -s -- -p /usr/local \
    &amp;&amp; git clone --single-branch --branch feat/handler_per_container https://github.com/liquid-reply/crun \
    &amp;&amp; cd crun \
    &amp;&amp; ./autogen.sh \
    &amp;&amp; ./configure --with-wasmedge --enable-embedded-yajl\
    &amp;&amp; make 

...
</code></pre>
<p>Now we have a fresh <code>crun</code> binary with wasmedge enabled under <code>/data/crun/crun</code> that we can copy from this container in the next step.</p>
<h2 id="replace-crun-and-configure-containerd"><a class="header" href="#replace-crun-and-configure-containerd">Replace crun and configure containerd</a></h2>
<p>Both runc and crun implement the OCI runtime spec and they have the same CLI parametes. Therefore we can just replace the runc binary with our crun-wasmedge binary we created before.</p>
<p>Since crun is using some shared libraries we need to install libyajl, wasmedge and criu to make our crun work.</p>
<p>Now we already have a KinD that uses crun instead of runc. Now we just need two config changes. The first one in the <code>/etc/containerd/config.toml</code> where we add the <code>pod_annotations</code>that can be passed to the runtime:</p>
<pre><code class="language-toml">[plugins.&quot;io.containerd.grpc.v1.cri&quot;.containerd.runtimes.runc]
  pod_annotations = [&quot;*.wasm.*&quot;, &quot;wasm.*&quot;, &quot;module.wasm.image/*&quot;, &quot;*.module.wasm.image&quot;, &quot;module.wasm.image/variant.*&quot;]
</code></pre>
<p>And the second one to the <code>/etc/containerd/cri-base.json</code> where we remove a hook that causes some issues.</p>
<p>The resulting dockerfile looks as follows:</p>
<pre><code class="language-Dockerfile">...

FROM kindest/node:v1.23.0

COPY config.toml /etc/containerd/config.toml
COPY --from=builder /data/crun/crun /usr/local/sbin/runc
COPY --from=builder /usr/local/lib/libwasmedge.so /usr/local/lib/libwasmedge.so

RUN echo &quot;Installing Packages ...&quot; \
    &amp;&amp; bash -c 'cat &lt;&lt;&lt; $(jq &quot;del(.hooks.createContainer)&quot; /etc/containerd/cri-base.json) &gt; /etc/containerd/cri-base.json' \
    &amp;&amp; ldconfig
</code></pre>
<h2 id="build-and-test"><a class="header" href="#build-and-test">Build and test</a></h2>
<p>Finally we can build a new <code>node-wasmedge</code> image. To test it, we create a kind cluster from that image and run the simple app example.</p>
<pre><code class="language-bash">docker build -t node-wasmedge .
kind create cluster --image node-wasmedge
# Now you can run the example to validate your cluster
kubectl run -it --rm --restart=Never wasi-demo --image=wasmedge/example-wasi:latest --annotations=&quot;module.wasm.image/variant=compat-smart&quot; /wasi_example_main.wasm 50000000
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="create-a-crun-demo-for-kubeedge"><a class="header" href="#create-a-crun-demo-for-kubeedge">Create a crun demo for KubeEdge</a></h1>
<h2 id="1-setup-cloud-side-kubeedge-master-node"><a class="header" href="#1-setup-cloud-side-kubeedge-master-node">1. Setup Cloud Side (KubeEdge Master Node)</a></h2>
<h3 id="install-go"><a class="header" href="#install-go">Install Go</a></h3>
<pre><code class="language-bash">$ wget https://golang.org/dl/go1.17.3.linux-amd64.tar.gz
$ tar xzvf go1.17.3.linux-amd64.tar.gz

$ export PATH=/home/${user}/go/bin:$PATH
$ go version
go version go1.17.3 linux/amd64
</code></pre>
<h3 id="install-cri-o-1"><a class="header" href="#install-cri-o-1">Install CRI-O</a></h3>
<p>Please see <a href="https://github.com/cri-o/cri-o/blob/main/install.md#install-packaged-versions-of-cri-o">CRI-O Installation Instructions</a>.</p>
<pre><code class="language-bash"># Create the .conf file to load the modules at bootup
cat &lt;&lt;EOF | sudo tee /etc/modules-load.d/crio.conf
overlay
br_netfilter
EOF

sudo modprobe overlay
sudo modprobe br_netfilter

# Set up required sysctl params, these persist across reboots.
cat &lt;&lt;EOF | sudo tee /etc/sysctl.d/99-kubernetes-cri.conf
net.bridge.bridge-nf-call-iptables  = 1
net.ipv4.ip_forward                 = 1
net.bridge.bridge-nf-call-ip6tables = 1
EOF

sudo sysctl --system
export OS=&quot;xUbuntu_20.04&quot;
export VERSION=&quot;1.21&quot;
cat &lt;&lt;EOF | sudo tee /etc/apt/sources.list.d/devel:kubic:libcontainers:stable.list
deb https://download.opensuse.org/repositories/devel:/kubic:/libcontainers:/stable/$OS/ /
EOF
cat &lt;&lt;EOF | sudo tee /etc/apt/sources.list.d/devel:kubic:libcontainers:stable:cri-o:$VERSION.list
deb http://download.opensuse.org/repositories/devel:/kubic:/libcontainers:/stable:/cri-o:/$VERSION/$OS/ /
EOF

curl -L https://download.opensuse.org/repositories/devel:/kubic:/libcontainers:/stable/$OS/Release.key | sudo apt-key --keyring /etc/apt/trusted.gpg.d/libcontainers.gpg add -
curl -L https://download.opensuse.org/repositories/devel:kubic:libcontainers:stable:cri-o:$VERSION/$OS/Release.key | sudo apt-key --keyring /etc/apt/trusted.gpg.d/libcontainers-cri-o.gpg add -

sudo apt-get update
sudo apt-get install cri-o cri-o-runc

sudo systemctl daemon-reload
sudo systemctl enable crio --now
sudo systemctl status cri-o
</code></pre>
<p>output:</p>
<pre><code class="language-bash">$ sudo systemctl status cri-o
● crio.service - Container Runtime Interface for OCI (CRI-O)
     Loaded: loaded (/lib/systemd/system/crio.service; enabled; vendor preset: enabled)
     Active: active (running) since Mon 2021-12-06 13:46:29 UTC; 16h ago
       Docs: https://github.com/cri-o/cri-o
   Main PID: 6868 (crio)
      Tasks: 14
     Memory: 133.2M
     CGroup: /system.slice/crio.service
             └─6868 /usr/bin/crio

Dec 07 06:04:13 master crio[6868]: time=&quot;2021-12-07 06:04:13.694226800Z&quot; level=info msg=&quot;Checking image status: k8s.gcr.io/pause:3.4.1&quot; id=1dbb722e-f031-410c-9f45-5d4b5760163e name=/runtime.v1alpha2.ImageServic&gt;
Dec 07 06:04:13 master crio[6868]: time=&quot;2021-12-07 06:04:13.695739507Z&quot; level=info msg=&quot;Image status: &amp;{0xc00047fdc0 map[]}&quot; id=1dbb722e-f031-410c-9f45-5d4b5760163e name=/runtime.v1alpha2.ImageService/ImageSta&gt;
Dec 07 06:09:13 master crio[6868]: time=&quot;2021-12-07 06:09:13.698823984Z&quot; level=info msg=&quot;Checking image status: k8s.gcr.io/pause:3.4.1&quot; id=661b754b-48a4-401b-a03f-7f7a553c7eb6 name=/runtime.v1alpha2.ImageServic&gt;
Dec 07 06:09:13 master crio[6868]: time=&quot;2021-12-07 06:09:13.703259157Z&quot; level=info msg=&quot;Image status: &amp;{0xc0004d98f0 map[]}&quot; id=661b754b-48a4-401b-a03f-7f7a553c7eb6 name=/runtime.v1alpha2.ImageService/ImageSta&gt;
Dec 07 06:14:13 master crio[6868]: time=&quot;2021-12-07 06:14:13.707778419Z&quot; level=info msg=&quot;Checking image status: k8s.gcr.io/pause:3.4.1&quot; id=8c7e4d36-871a-452e-ab55-707053604077 name=/runtime.v1alpha2.ImageServic&gt;
Dec 07 06:14:13 master crio[6868]: time=&quot;2021-12-07 06:14:13.709379469Z&quot; level=info msg=&quot;Image status: &amp;{0xc000035030 map[]}&quot; id=8c7e4d36-871a-452e-ab55-707053604077 name=/runtime.v1alpha2.ImageService/ImageSta&gt;
Dec 07 06:19:13 master crio[6868]: time=&quot;2021-12-07 06:19:13.713158978Z&quot; level=info msg=&quot;Checking image status: k8s.gcr.io/pause:3.4.1&quot; id=827b6315-f145-4f76-b8da-31653d5892a2 name=/runtime.v1alpha2.ImageServic&gt;
Dec 07 06:19:13 master crio[6868]: time=&quot;2021-12-07 06:19:13.714030148Z&quot; level=info msg=&quot;Image status: &amp;{0xc000162bd0 map[]}&quot; id=827b6315-f145-4f76-b8da-31653d5892a2 name=/runtime.v1alpha2.ImageService/ImageSta&gt;
Dec 07 06:24:13 master crio[6868]: time=&quot;2021-12-07 06:24:13.716746612Z&quot; level=info msg=&quot;Checking image status: k8s.gcr.io/pause:3.4.1&quot; id=1d53a917-4d98-4723-9ea8-a2951a472cff name=/runtime.v1alpha2.ImageServic&gt;
Dec 07 06:24:13 master crio[6868]: time=&quot;2021-12-07 06:24:13.717381882Z&quot; level=info msg=&quot;Image status: &amp;{0xc00042ce00 map[]}&quot; id=1d53a917-4d98-4723-9ea8-a2951a472cff name=/runtime.v1alpha2.ImageService/ImageSta&gt;
</code></pre>
<h3 id="install-and-creating-a-cluster-with-kubeadm-for-k8s"><a class="header" href="#install-and-creating-a-cluster-with-kubeadm-for-k8s">Install and Creating a cluster with kubeadm for K8s</a></h3>
<p>Please see <a href="https://kubernetes.io/docs/setup/production-environment/tools/kubeadm/create-cluster-kubeadm/">Creating a cluster with kubeadm</a>.</p>
<h4 id="install-k8s"><a class="header" href="#install-k8s">Install K8s</a></h4>
<pre><code class="language-bash">sudo apt-get update
sudo apt-get install -y apt-transport-https curl
echo &quot;deb [signed-by=/usr/share/keyrings/kubernetes-archive-keyring.gpg] https://apt.kubernetes.io/ kubernetes-xenial main&quot; | sudo tee /etc/apt/sources.list.d/kubernetes.list

sudo apt update
K_VER=&quot;1.21.0-00&quot;
sudo apt install -y kubelet=${K_VER} kubectl=${K_VER} kubeadm=${K_VER}
sudo apt-mark hold kubelet kubeadm kubectl
</code></pre>
<h4 id="create-a-cluster-with-kubeadm"><a class="header" href="#create-a-cluster-with-kubeadm">Create a cluster with kubeadm</a></h4>
<pre><code class="language-bash">#kubernetes scheduler requires this setting to be done.
$ sudo swapoff -a
$ sudo vim /etc/fstab
mark contain swapfile of row

$ cat /etc/cni/net.d/100-crio-bridge.conf
{
    &quot;cniVersion&quot;: &quot;0.3.1&quot;,
    &quot;name&quot;: &quot;crio&quot;,
    &quot;type&quot;: &quot;bridge&quot;,
    &quot;bridge&quot;: &quot;cni0&quot;,
    &quot;isGateway&quot;: true,
    &quot;ipMasq&quot;: true,
    &quot;hairpinMode&quot;: true,
    &quot;ipam&quot;: {
        &quot;type&quot;: &quot;host-local&quot;,
        &quot;routes&quot;: [
            { &quot;dst&quot;: &quot;0.0.0.0/0&quot; },
            { &quot;dst&quot;: &quot;1100:200::1/24&quot; }
        ],
        &quot;ranges&quot;: [
            [{ &quot;subnet&quot;: &quot;10.85.0.0/16&quot; }],
            [{ &quot;subnet&quot;: &quot;1100:200::/24&quot; }]
        ]
    }
}
$ export CIDR=10.85.0.0/16
$ sudo kubeadm init --apiserver-advertise-address=192.168.122.160 --pod-network-cidr=$CIDR --cri-socket=/var/run/crio/crio.sock

$ mkdir -p $HOME/.kube
$ sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config
$ sudo chown $(id -u):$(id -g) $HOME/.kube/config
</code></pre>
<p>output:</p>
<pre><code class="language-bash">Your Kubernetes control-plane has initialized successfully!

To start using your cluster, you need to run the following as a regular user:

  mkdir -p $HOME/.kube
  sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config
  sudo chown $(id -u):$(id -g) $HOME/.kube/config

You should now deploy a Pod network to the cluster.
Run &quot;kubectl apply -f [podnetwork].yaml&quot; with one of the options listed at:
  /docs/concepts/cluster-administration/addons/

You can now join any number of machines by running the following on each node
as root:

  kubeadm join &lt;control-plane-host&gt;:&lt;control-plane-port&gt; --token &lt;token&gt; --discovery-token-ca-cert-hash sha256:&lt;hash&gt;
</code></pre>
<p>To make kubectl work for your non-root user, run these commands, which are also part of the kubeadm init output:</p>
<pre><code class="language-bash">mkdir -p $HOME/.kube
sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config
sudo chown $(id -u):$(id -g) $HOME/.kube/config
</code></pre>
<h3 id="setup-kubeedge-master-node"><a class="header" href="#setup-kubeedge-master-node">Setup KubeEdge Master Node</a></h3>
<p>Please see <a href="https://kubeedge.io/en/docs/setup/keadm/">Deploying using Keadm</a>.</p>
<p>IMPORTANT NOTE:</p>
<ol>
<li>At least one of kubeconfig or master must be configured correctly, so that it can be used to verify the version and other info of the k8s cluster.</li>
<li>Please make sure edge node can connect cloud node using local IP of cloud node, or you need to specify public IP of cloud node with --advertise-address flag.</li>
<li>--advertise-address(only work since 1.3 release) is the address exposed by the cloud side (will be added to the SANs of the CloudCore certificate), the default value is the local IP.</li>
</ol>
<pre><code class="language-bash">wget https://github.com/kubeedge/kubeedge/releases/download/v1.8.0/keadm-v1.8.0-linux-amd64.tar.gz
tar xzvf keadm-v1.8.0-linux-amd64.tar.gz
cd keadm-v1.8.0-linux-amd64/keadm/
sudo ./keadm init --advertise-address=192.168.122.160 --kube-config=/home/${user}/.kube/config
</code></pre>
<p>output:</p>
<pre><code class="language-bash">Kubernetes version verification passed, KubeEdge installation will start...
...
KubeEdge cloudcore is running, For logs visit:  /var/log/kubeedge/cloudcore.log
</code></pre>
<h2 id="2-setup-edge-side-kubeedge-worker-node"><a class="header" href="#2-setup-edge-side-kubeedge-worker-node">2. Setup Edge Side (KubeEdge Worker Node)</a></h2>
<p>You can use the CRI-O <a href="use_cases/kubernetes/kubernetes/../crio/install.sh">install.sh</a> script to install CRI-O and <code>crun</code> on Ubuntu 20.04.</p>
<pre><code class="language-bash">wget -qO- https://raw.githubusercontent.com/second-state/wasmedge-containers-examples/main/crio/install.sh | bash
</code></pre>
<h3 id="install-go-on-edge-side"><a class="header" href="#install-go-on-edge-side">Install Go on Edge Side</a></h3>
<pre><code class="language-bash">$ wget https://golang.org/dl/go1.17.3.linux-amd64.tar.gz
$ tar xzvf go1.17.3.linux-amd64.tar.gz

$ export PATH=/home/${user}/go/bin:$PATH
$ go version
go version go1.17.3 linux/amd64
</code></pre>
<h3 id="get-token-from-cloud-side"><a class="header" href="#get-token-from-cloud-side">Get Token From Cloud Side</a></h3>
<p>Run keadm gettoken in cloud side will return the token, which will be used when joining edge nodes.</p>
<pre><code class="language-bash">$ sudo ./keadm gettoken --kube-config=/home/${user}/.kube/config
27a37ef16159f7d3be8fae95d588b79b3adaaf92727b72659eb89758c66ffda2.eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJleHAiOjE1OTAyMTYwNzd9.JBj8LLYWXwbbvHKffJBpPd5CyxqapRQYDIXtFZErgYE
</code></pre>
<h3 id="download-kubeedge-and-join-edge-nodes"><a class="header" href="#download-kubeedge-and-join-edge-nodes">Download Kubeedge and join edge nodes</a></h3>
<p>Please see <a href="https://kubeedge.io/en/docs/advanced/cri/#cri-o">Setting different container runtime with CRI</a> and <a href="https://kubeedge.io/en/docs/setup/keadm/">Deploying using Keadm</a>.</p>
<pre><code class="language-bash">$ wget https://github.com/kubeedge/kubeedge/releases/download/v1.8.0/keadm-v1.8.0-linux-amd64.tar.gz
$ tar xzvf keadm-v1.8.0-linux-amd64.tar.gz
$ cd keadm-v1.8.0-linux-amd64/keadm/

$ sudo ./keadm join \
--cloudcore-ipport=192.168.122.160:10000 \
--edgenode-name=edge \
--token=b4550d45b773c0480446277eed1358dcd8a02a0c214646a8082d775f9c447d81.eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJleHAiOjE2Mzg4ODUzNzd9.A9WOYJFrgL2swVGnydpb4gMojyvyoNPCXaA4rXGowqU \
--remote-runtime-endpoint=unix:///var/run/crio/crio.sock \
--runtimetype=remote \
--cgroupdriver=systemd
</code></pre>
<p>Output:</p>
<pre><code class="language-bash">Host has mosquit+ already installed and running. Hence skipping the installation steps !!!
...
KubeEdge edgecore is running, For logs visit:  /var/log/kubeedge/edgecore.log
</code></pre>
<h3 id="get-edge-node-status-from-cloud-side"><a class="header" href="#get-edge-node-status-from-cloud-side">Get Edge Node Status From Cloud Side</a></h3>
<p>Output:</p>
<pre><code class="language-bash">kubectl get node
NAME       STATUS    ROLES                  AGE   VERSION
edge       Ready     agent,edge             10s   v1.19.3-kubeedge-v1.8.2
master     Ready     control-plane,master   68m   v1.21.0
</code></pre>
<h2 id="3-enable-kubectl-logs-feature"><a class="header" href="#3-enable-kubectl-logs-feature">3. Enable kubectl logs Feature</a></h2>
<p>Before metrics-server deployed, kubectl logs feature must be activated, please <a href="https://kubeedge.io/en/docs/setup/keadm/#enable-kubectl-logs-feature">see here</a>.</p>
<h2 id="4-run-a-simple-webassembly-app"><a class="header" href="#4-run-a-simple-webassembly-app">4. Run a simple WebAssembly app</a></h2>
<p>We can run the WebAssembly-based image from Docker Hub in the Kubernetes cluster.</p>
<h3 id="cloud-side"><a class="header" href="#cloud-side">Cloud Side</a></h3>
<pre><code class="language-bash">$ kubectl run -it --restart=Never wasi-demo --image=wasmedge/example-wasi:latest --annotations=&quot;module.wasm.image/variant=compat-smart&quot; /wasi_example_main.wasm 50000000

Random number: -1694733782
Random bytes: [6, 226, 176, 126, 136, 114, 90, 2, 216, 17, 241, 217, 143, 189, 123, 197, 17, 60, 49, 37, 71, 69, 67, 108, 66, 39, 105, 9, 6, 72, 232, 238, 102, 5, 148, 243, 249, 183, 52, 228, 54, 176, 63, 249, 216, 217, 46, 74, 88, 204, 130, 191, 182, 19, 118, 193, 77, 35, 189, 6, 139, 68, 163, 214, 231, 100, 138, 246, 185, 47, 37, 49, 3, 7, 176, 97, 68, 124, 20, 235, 145, 166, 142, 159, 114, 163, 186, 46, 161, 144, 191, 211, 69, 19, 179, 241, 8, 207, 8, 112, 80, 170, 33, 51, 251, 33, 105, 0, 178, 175, 129, 225, 112, 126, 102, 219, 106, 77, 242, 104, 198, 238, 193, 247, 23, 47, 22, 29]
Printed from wasi: This is from a main function
This is from a main function
The env vars are as follows.
The args are as follows.
/wasi_example_main.wasm
50000000
File content is This is in a file
</code></pre>
<p>The WebAssembly app of pod successfully deploy to edge node.</p>
<pre><code class="language-bash">$ kubectl describe pod wasi-demo

Name:         wasi-demo
Namespace:    default
Priority:     0
Node:         edge/192.168.122.229
Start Time:   Mon, 06 Dec 2021 15:45:34 +0000
Labels:       run=wasi-demo
Annotations:  module.wasm.image/variant: compat-smart
Status:       Succeeded
IP:           
IPs:          &lt;none&gt;
Containers:
  wasi-demo:
    Container ID:  cri-o://1ae4d0d7f671050331a17e9b61b5436bf97ad35ad0358bef043ab820aed81069
    Image:         wasmedge/example-wasi:latest
    Image ID:      docker.io/wasmedge/example-wasi@sha256:525aab8d6ae8a317fd3e83cdac14b7883b92321c7bec72a545edf276bb2100d6
    Port:          &lt;none&gt;
    Host Port:     &lt;none&gt;
    Args:
      /wasi_example_main.wasm
      50000000
    State:          Terminated
      Reason:       Completed
      Exit Code:    0
      Started:      Mon, 06 Dec 2021 15:45:33 +0000
      Finished:     Mon, 06 Dec 2021 15:45:33 +0000
    Ready:          False
    Restart Count:  0
    Environment:    &lt;none&gt;
    Mounts:
      /var/run/secrets/kubernetes.io/serviceaccount from kube-api-access-bhszr (ro)
Conditions:
  Type           Status
  Initialized    True 
  Ready          False 
  PodScheduled   True 
Volumes:
  kube-api-access-bhszr:
    Type:                    Projected (a volume that contains injected data from multiple sources)
    TokenExpirationSeconds:  3607
    ConfigMapName:           kube-root-ca.crt
    ConfigMapOptional:       &lt;nil&gt;
    DownwardAPI:             true
QoS Class:                   BestEffort
Node-Selectors:              &lt;none&gt;
Tolerations:                 node.kubernetes.io/not-ready:NoExecute op=Exists for 300s
                             node.kubernetes.io/unreachable:NoExecute op=Exists for 300s
Events:
  Type    Reason     Age   From               Message
  ----    ------     ----  ----               -------
</code></pre>
<h3 id="edge-side"><a class="header" href="#edge-side">Edge Side</a></h3>
<pre><code class="language-bash">$ sudo crictl ps -a
CONTAINER           IMAGE                                                                                           CREATED             STATE               NAME                ATTEMPT             POD ID
1ae4d0d7f6710       0423b8eb71e312b8aaa09a0f0b6976381ff567d5b1e5729bf9b9aa87bff1c9f3                                16 minutes ago      Exited              wasi-demo           0                   2bc2ac0c32eda
1e6c7cb6bc731       k8s.gcr.io/kube-proxy@sha256:2a25285ff19f9b4025c8e54dac42bb3cd9aceadc361f2570489b8d723cb77135   18 minutes ago      Running             kube-proxy          0                   8b7e7388ad866
</code></pre>
<p>That's it.</p>
<h2 id="5-demo-run-screen-recording"><a class="header" href="#5-demo-run-screen-recording">5. Demo Run Screen Recording</a></h2>
<p><a href="https://asciinema.org/a/wkLOu6xnAOSAQdmYayumwrAvh"><img src="https://asciinema.org/a/wkLOu6xnAOSAQdmYayumwrAvh.svg" alt="asciicast" /></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="superedge"><a class="header" href="#superedge">SuperEdge</a></h1>
<h2 id="install-superedge"><a class="header" href="#install-superedge">Install Superedge</a></h2>
<p><a href="use_cases/kubernetes/kubernetes/../docs/installation/install_edge_kubernetes.html">One-click install of edge Kubernetes cluster</a></p>
<ul>
<li>Download the installation package</li>
</ul>
<blockquote>
<p>Choose installation package according to your installation node CPU architecture [amd64, arm64]</p>
</blockquote>
<pre><code class="language-bash">arch=amd64 version=v0.6.0 &amp;&amp; rm -rf edgeadm-linux-* &amp;&amp; wget https://superedge-1253687700.cos.ap-guangzhou.myqcloud.com/$version/$arch/edgeadm-linux-containerd-$arch-$version.tgz &amp;&amp; tar -xzvf edgeadm-linux-* &amp;&amp; cd edgeadm-linux-$arch-$version &amp;&amp; ./edgeadm
</code></pre>
<ul>
<li>Install edge Kubernetes master node with containerd runtime</li>
</ul>
<pre><code class="language-bash">./edgeadm init --kubernetes-version=1.18.2 --image-repository superedge.tencentcloudcr.com/superedge --service-cidr=10.96.0.0/12 --pod-network-cidr=192.168.0.0/16 --install-pkg-path ./kube-linux-*.tar.gz --apiserver-cert-extra-sans=&lt;Master Public IP&gt; --apiserver-advertise-address=&lt;Master Intranet IP&gt; --enable-edge=true --runtime=containerd
</code></pre>
<ul>
<li>Join edge node with containerd runtime</li>
</ul>
<pre><code class="language-bash">./edgeadm join &lt;Master Public/Intranet IP Or Domain&gt;:Port --token xxxx --discovery-token-ca-cert-hash sha256:xxxxxxxxxx --install-pkg-path &lt;edgeadm kube-* install package address path&gt; --enable-edge=true --runtime=containerd
</code></pre>
<p>See the detailed process<a href="use_cases/kubernetes/kubernetes/../docs/installation/install_edge_kubernetes.html">One-click install of edge Kubernetes cluster</a></p>
<p>Other installation, deployment, and administration, see our <a href="use_cases/kubernetes/kubernetes/../docs/tutorial.html"><strong>Tutorial</strong></a>.</p>
<h2 id="install-wasmedge"><a class="header" href="#install-wasmedge">Install WasmEdge</a></h2>
<p>Use the simple install script to install WasmEdge on your edge node.</p>
<pre><code class="language-bash">curl -sSf https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/utils/install.sh | bash
</code></pre>
<h2 id="build-and-install-crun-with-wasmedge"><a class="header" href="#build-and-install-crun-with-wasmedge">Build And install Crun with WasmEdge</a></h2>
<p>The <a href="https://github.com/containers/crun">crun</a> project has WasmEdge support baked in. For now, the easiest approach is just to build it yourself from source. First, let's make sure that crun dependencies are installed on your Ubuntu 20.04. For other Linux distributions, please see <a href="https://github.com/containers/crun#readme">here</a>.</p>
<pre><code class="language-bash">sudo apt update
sudo apt install -y make git gcc build-essential pkgconf libtool \
    libsystemd-dev libprotobuf-c-dev libcap-dev libseccomp-dev libyajl-dev \
    go-md2man libtool autoconf python3 automake
</code></pre>
<p>Next, configure, build, and install a crun binary with WasmEdge support.</p>
<pre><code class="language-bash">git clone https://github.com/containers/crun
cd crun
./autogen.sh
./configure --with-wasmedge
make
sudo make install
</code></pre>
<h2 id="reconfigure-containerd-with-crun-runtime"><a class="header" href="#reconfigure-containerd-with-crun-runtime">Reconfigure containerd with crun runtime</a></h2>
<p>Superedge containerd node has default config, we should modify the configuration file(/etc/containerd/config.toml) according to the following steps.</p>
<p>Firstly, we generate <code>config.toml.diff</code> diff file and patch it.</p>
<pre><code class="language-bash">cat &gt; config.toml.diff &lt;&lt; EOF
--- /etc/containerd/config.toml 2022-02-14 15:05:40.061562127 +0800
+++ /etc/containerd/config.toml.crun    2022-02-14 15:03:35.846052853 +0800
@@ -24,17 +24,23 @@
   max_concurrent_downloads = 10

   [plugins.cri.containerd]
-        default_runtime_name = &quot;runc&quot;
-    [plugins.cri.containerd.runtimes.runc]
+        default_runtime_name = &quot;crun&quot;
+    [plugins.cri.containerd.runtimes.crun]
       runtime_type = &quot;io.containerd.runc.v2&quot;
-      pod_annotations = []
+      pod_annotations = [&quot;*.wasm.*&quot;, &quot;wasm.*&quot;, &quot;module.wasm.image/*&quot;, &quot;*.module.wasm.image&quot;, &quot;module.wasm.image/variant.*&quot;]
       container_annotations = []
       privileged_without_host_devices = false
-      [plugins.cri.containerd.runtimes.runc.options]
-        BinaryName = &quot;runc&quot;
+      [plugins.cri.containerd.runtimes.crun.options]
+        BinaryName = &quot;crun&quot;
   # cni
   [plugins.cri.cni]
     bin_dir = &quot;/opt/cni/bin&quot;
     conf_dir = &quot;/etc/cni/net.d&quot;
     conf_template = &quot;&quot;

+  [plugins.&quot;io.containerd.runtime.v1.linux&quot;]
+    no_shim = false
+    runtime = &quot;crun&quot;
+    runtime_root = &quot;&quot;
+    shim = &quot;containerd-shim&quot;
+    shim_debug = false
EOF
</code></pre>
<pre><code class="language-bash">sudo patch -d/ -p0 &lt; config.toml.diff
sudo systemctl restart containerd
</code></pre>
<h2 id="create-wasmedge-application-in-superedge"><a class="header" href="#create-wasmedge-application-in-superedge">Create Wasmedge application in Superedge</a></h2>
<p>We can run a wasm image which has been pushed to <a href="https://hub.docker.com/r/hydai/wasm-wasi-example">dockerhub</a>. If you want to learn how to compile, package, and publish the WebAssembly program as a container image to Docker hub, please refer to <a href="use_cases/kubernetes/kubernetes/../demo/wasi.html">here</a>.</p>
<pre><code class="language-bash">cat &gt; wasmedge-app.yaml &lt;&lt; EOF
apiVersion: v1
kind: Pod
metadata:
  annotations:
    module.wasm.image/variant: compat-smart
  labels:
    run: wasi-demo
  name: wasi-demo
spec:
  containers:
  - args:
    - /wasi_example_main.wasm
    - &quot;50000000&quot;
    image: wasmedge/example-wasi:latest
    imagePullPolicy: IfNotPresent
    name: wasi-demo
  hostNetwork: true
  restartPolicy: Never
EOF

kubectl create -f wasmedge-app.yaml
</code></pre>
<p>The output will show by executing <code>kubectl logs wasi-demo</code> command.</p>
<pre><code class="language-bash">Random number: -1643170076
Random bytes: [15, 223, 242, 238, 69, 114, 217, 106, 80, 214, 44, 225, 20, 182, 2, 189, 226, 184, 97, 40, 154, 6, 56, 202, 45, 89, 184, 80, 5, 89, 73, 222, 143, 132, 17, 79, 145, 64, 33, 17, 250, 102, 91, 94, 26, 200, 28, 161, 46, 93, 123, 36, 100, 167, 43, 159, 82, 112, 255, 165, 37, 232, 17, 139, 97, 14, 28, 169, 225, 156, 147, 22, 174, 148, 209, 57, 82, 213, 19, 215, 11, 18, 32, 217, 188, 142, 54, 127, 237, 237, 230, 137, 86, 162, 185, 66, 88, 95, 226, 53, 174, 76, 226, 25, 151, 186, 156, 16, 62, 63, 230, 148, 133, 102, 33, 138, 20, 83, 31, 60, 246, 90, 167, 189, 103, 238, 106, 51]
Printed from wasi: This is from a main function
This is from a main function
The env vars are as follows.
The args are as follows.
/wasi_example_main.wasm
50000000
File content is This is in a file
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="openyurt--containerd--crun"><a class="header" href="#openyurt--containerd--crun">OpenYurt + containerd + crun</a></h1>
<p>In this article, we will introduce how to run a WasmEdge simple demo app with Containerd over <a href="https://github.com/openyurtio/openyurt">OpenYurt</a>.</p>
<h2 id="set-up-an-openyurt-cluster"><a class="header" href="#set-up-an-openyurt-cluster">Set up an OpenYurt Cluster</a></h2>
<p>Here, we introduce two ways to set up an OpenYurt Cluster.
The first one is to set up an OpenYurt Cluster from scratch, use <code>yurtctl convert</code> to realize a K8s Cluster conversion to an OpenYurt Cluster.
The second one is to use the ability of OpenYurt Experience Center, which is easy to achieve an OpenYurt Cluster.</p>
<h3 id="prerequisite"><a class="header" href="#prerequisite">Prerequisite</a></h3>
<div class="table-wrapper"><table><thead><tr><th></th><th>OS/kernel</th><th>Private IP/Public IP</th></tr></thead><tbody>
<tr><td>Master</td><td>Ubuntu  20.04.3 LTS/5.4.0-91-generic</td><td>192.168.3.169/120.55.126.18</td></tr>
<tr><td>Node</td><td>Ubuntu  20.04.3 LTS/5.4.0-91-generic</td><td>192.168.3.170/121.43.113.152</td></tr>
</tbody></table>
</div>
<p>It should be noted that some steps may differ slightly depending on the operating system differences.
Please refer to the installation of <a href="https://github.com/openyurtio/openyurt">OpenYurt</a> and <a href="https://github.com/containers/crun">crun</a>.</p>
<p>We use <code>yurtctl convert</code> to convert a K8s Cluster to OpenYurt Cluster, so we should set up a K8s Cluster.
If you use <code>yurtctl init/join</code> to set up an OpenYurt Cluster, you can skip this step which introduces the process of installing K8s.</p>
<p>Find the difference between <code>yurtctl convert/revert</code> and <code>yurtctl init/join</code>, you can refer to the following two articles.</p>
<p><a href="https://openyurt.io/docs/installation/yurtctl-init-join">how use <code>Yurtctl init/join</code></a></p>
<p><a href="https://openyurt.io/docs/installation/yurtctl-convert-revert">Conversion between OpenYurt and Kubernetes:<code>yurtctl convert/revert</code></a></p>
<ul>
<li>Close the swap space of the master and node firstly.</li>
</ul>
<pre><code class="language-bash">sudo swapoff -a
//verify
free -m
</code></pre>
<ul>
<li>Configure the file /etc/hosts of two nodes as the following.</li>
</ul>
<pre><code class="language-bash">192.168.3.169  oy-master 
120.55.126.18  oy-master
92.168.3.170   oy-node
121.43.113.152 oy-node
</code></pre>
<ul>
<li>Load the br_netfilter Kernel module and modify the Kernel parameter.</li>
</ul>
<pre><code class="language-bash">//load the module
sudo modprobe br_netfilter
//verify   
lsmod | grep br_netfilter
// create k8s.conf
cat &lt;&lt;EOF | sudo tee /etc/sysctl.d/k8s.conf
net.bridge.bridge-nf-call-ip6tables = 1
net.bridge.bridge-nf-call-iptables = 1
EOF
sudo sysctl --system 
</code></pre>
<ul>
<li>Setup the value of rp-filter (adjusting the value of two parameters in <code>/etc/sysctl.d/10-network-security.conf</code> from 2 to 1 and setting up the value of /proc/sys/net/ipv4/ip_forward to 1)</li>
</ul>
<pre><code class="language-bash">sudo vi /etc/sysctl.d/10-network-security.conf
echo 1 &gt; /proc/sys/net/ipv4/ip_forward
sudo sysctl --system
</code></pre>
<h4 id="install-containerd-and-modify-the-default-configure-of-containerd"><a class="header" href="#install-containerd-and-modify-the-default-configure-of-containerd">Install containerd and modify the default configure of containerd</a></h4>
<p>Use the following commands to install containerd on your edge node which will run a WasmEdge simple demo.</p>
<pre><code class="language-bash">export VERSION=&quot;1.5.7&quot;
echo -e &quot;Version: $VERSION&quot;
echo -e &quot;Installing libseccomp2 ...&quot;
sudo apt install -y libseccomp2
echo -e &quot;Installing wget&quot;
sudo apt install -y wget

wget https://github.com/containerd/containerd/releases/download/v${VERSION}/cri-containerd-cni-${VERSION}-linux-amd64.tar.gz
wget https://github.com/containerd/containerd/releases/download/v${VERSION}/cri-containerd-cni-${VERSION}-linux-amd64.tar.gz.sha256sum
sha256sum --check cri-containerd-cni-${VERSION}-linux-amd64.tar.gz.sha256sum

sudo tar --no-overwrite-dir -C / -xzf cri-containerd-cni-${VERSION}-linux-amd64.tar.gz
sudo systemctl daemon-reload
</code></pre>
<p>As the crun project support WasmEdge as default, we just need to configure the containerd configuration for runc. So we need to modify the runc parameters in /etc/containerd/config.toml to curn and add pod_annotation.</p>
<pre><code class="language-bash">sudo mkdir -p /etc/containerd/
sudo bash -c &quot;containerd config default &gt; /etc/containerd/config.toml&quot;
wget https://raw.githubusercontent.com/second-state/wasmedge-containers-examples/main/containerd/containerd_config.diff
sudo patch -d/ -p0 &lt; containerd_config.diff
</code></pre>
<p>After that, restart containerd to make the configuration take effect.</p>
<pre><code class="language-bash">systemctl start containerd
</code></pre>
<h4 id="install-wasmedge-1"><a class="header" href="#install-wasmedge-1">Install WasmEdge</a></h4>
<p>Use the <a href="use_cases/kubernetes/kubernetes/../../../quick_start/install.html">simple install script</a> to install WasmEdge on your edge node.</p>
<pre><code class="language-bash">curl -sSf https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/utils/install.sh | bash
</code></pre>
<h4 id="build-and-install-crun"><a class="header" href="#build-and-install-crun">Build and install crun</a></h4>
<p>We need a crun binary that supports WasmEdge on the edge node. For now, the most straightforward approach is to build it yourself from the source. First, let's ensure that crun dependencies are installed on your Ubuntu 20.04. For other Linux distributions, please see <a href="https://github.com/containers/crun#readme">here</a>.</p>
<ul>
<li>Dependencies are required for the build</li>
</ul>
<pre><code class="language-bash">sudo apt update
sudo apt install -y make git gcc build-essential pkgconf libtool \
  libsystemd-dev libprotobuf-c-dev libcap-dev libseccomp-dev libyajl-dev \
  go-md2man libtool autoconf python3 automake
</code></pre>
<ul>
<li>Configure, build, and install a crun binary with WasmEdge support.</li>
</ul>
<pre><code class="language-bash">git clone https://github.com/containers/crun
cd crun
./autogen.sh
./configure --with-wasmedge
make
sudo make install
</code></pre>
<h3 id="from-scratch-set-up-an-openyurt-cluster"><a class="header" href="#from-scratch-set-up-an-openyurt-cluster">From scratch set up an OpenYurt Cluster</a></h3>
<p>In this demo, we will use two machines to set up an OpenYurt Cluster. One simulated cloud node is called Master, the other one simulated edge node is called Node. These two nodes form the simplest
OpenYurt Cluster, where OpenYurt components run on.</p>
<h4 id="set-up-a-k8s-cluster"><a class="header" href="#set-up-a-k8s-cluster">Set up a K8s Cluster</a></h4>
<p>Kubernetes version 1.18.9</p>
<pre><code class="language-bash">$ sudo apt-get update &amp;&amp; sudo apt-get install -y ca-certificates curl software-properties-common apt-transport-https
// add K8s source
$ curl -s https://mirrors.aliyun.com/kubernetes/apt/doc/apt-key.gpg | sudo apt-key add -
$ sudo tee /etc/apt/sources.list.d/kubernetes.list &lt;&lt;EOF
$ deb https://mirrors.aliyun.com/kubernetes/apt/ kubernetes-xenial main
// install K8s components 1.18.9
$ sudo apt-get update &amp;&amp; sudo apt-get install -y kubelet=1.18.9-00 kubeadm=1.18.9-00 kubectl=1.18.9-00 
// Initialize the master node
$ sudo kubeadm init --pod-network-cidr 172.16.0.0/16 \
--apiserver-advertise-address=192.168.3.167 \
--image-repository registry.cn-hangzhou.aliyuncs.com/google_containers
// join the work node
$ kubeadm join 192.168.3.167:6443 --token 3zefbt.99e6denc1cxpk9fg \
   --discovery-token-ca-cert-hash sha256:8077d4e7dd6eee64a999d56866ae4336073ed5ffc3f23281d757276b08b9b195
</code></pre>
<h4 id="install-yurtctl"><a class="header" href="#install-yurtctl">Install yurtctl</a></h4>
<p>Use the following command line to install yurtctl. The yurtctl CLI tool helps install/uninstall OpenYurt and also convert a standard Kubernetes cluster to an OpenYurt cluster.</p>
<pre><code class="language-bash">git clone https://github.com/openyurtio/openyurt.git
cd openyurt
make build WHAT=cmd/yurtctl
</code></pre>
<h4 id="install-openyurt-components"><a class="header" href="#install-openyurt-components">Install OpenYurt components</a></h4>
<p>OpenYurt includes several components. YurtHub is the traffic proxy between the components on the node and Kube-apiserver. The YurtHub on the edge will cache the data returned from the cloud. Yurt controller supplements the upstream node controller to support edge computing requirements. TunnelServer connects with the TunnelAgent daemon running in each edge node via a reverse proxy to establish secure network access between the cloud site control plane and the edge nodes that are connected to the intranet. For more detailed information, you could refer to the <a href="https://github.com/openyurtio/openyurt">OpenYurt docs</a>.</p>
<pre><code class="language-bash">yurtctl convert --deploy-yurttunnel --cloud-nodes oy-master --provider kubeadm\
--yurt-controller-manager-image=&quot;openyurt/yurt-controller-manager:v0.5.0&quot;\
--yurt-tunnel-agent-image=&quot;openyurt/yurt-tunnel-agent:v0.5.0&quot;\
--yurt-tunnel-server-image=&quot;openyurt/yurt-tunnel-server:v0.5.0&quot;\
--node-servant-image=&quot;openyurt/node-servant:latest&quot;\
--yurthub-image=&quot;openyurt/yurthub:v0.5.0&quot;
</code></pre>
<p>We need to change the <code>openyurt/node-server-version</code> to latest here: <code>--node-servant-image=&quot;openyurt/node-servant:latest&quot;</code></p>
<p>Actually, OpenYurt components 0.6.0 version is recommended to be installed and proved to be a success to run a WasmEdge demo.
How to install OpenYurt:0.6.0, you can see <a href="https://github.com/openyurtio/openyurt/releases/tag/v0.6.0">this</a></p>
<h3 id="use-openyurt-experience-center-to-quickly-set-up-an-openyurt-cluster"><a class="header" href="#use-openyurt-experience-center-to-quickly-set-up-an-openyurt-cluster">Use OpenYurt Experience Center to quickly set up an OpenYurt Cluster</a></h3>
<p>An easier way to set up an OpenYurt Cluster is to use the OpenYurt Experience Center. All you need to do is to sign up for an account for testing, and then you will get an OpenYurt cluster. Next, you could just use <code>yurtctl join</code> command line to join an edge node. See more OpenYurt Experience Center details <a href="https://openyurt.io/docs/installation/openyurt-experience-center/overview/">here</a>.</p>
<h2 id="run-a-simple-webassembly-app-2"><a class="header" href="#run-a-simple-webassembly-app-2">Run a simple WebAssembly app</a></h2>
<p>Next, let's run a WebAssembly program through the OpenYurt cluster as a container in the pod. This section will start off pulling this WebAssembly-based container image from Docker hub. If you want to learn how to compile, package, and publish the WebAssembly program as a container image to Docker hub, please refer to <a href="use_cases/kubernetes/kubernetes/../demo/wasi.html">WasmEdge Book</a>.</p>
<p>One thing is to note that because the kubectl run (version 1.18.9 ) missed annotations parameters, we need to adjust the command line here. If you are using OpenYurt Experience Center with OpenYurt 0.6.0 and Kubernetes 1.20.11 by default, please refer to <a href="use_cases/kubernetes/kubernetes/../kubernetes.html">the Kubernetes sections</a> in the WasmEdge book to run the wasm app.</p>
<pre><code class="language-bash">// kubectl 1.18.9
$ sudo kubectl run -it --rm --restart=Never wasi-demo --image=wasmedge/example-wasi:latest  --overrides='{&quot;kind&quot;:&quot;Pod&quot;,&quot;metadata&quot;:{&quot;annotations&quot;:{&quot;module.wasm.image/variant&quot;:&quot;compat-smart&quot;}} , &quot;apiVersion&quot;:&quot;v1&quot;, &quot;spec&quot;: {&quot;hostNetwork&quot;: true}}' /wasi_example_main.wasm 50000000

// kubectl 1.20.11
$ sudo kubectl run -it --rm --restart=Never wasi-demo --image=wasmedge/example-wasi:latest --annotations=&quot;module.wasm.image/variant=compat-smart&quot; --overrides='{&quot;kind&quot;:&quot;Pod&quot;, &quot;apiVersion&quot;:&quot;v1&quot;, &quot;spec&quot;: {&quot;hostNetwork&quot;: true}}' /wasi_example_main.wasm 50000000

</code></pre>
<p>The output from the containerized application is printed into the console. It is the same for all Kubernetes versions.</p>
<pre><code class="language-bash">Random number: 1123434661
Random bytes: [25, 169, 202, 211, 22, 29, 128, 133, 168, 185, 114, 161, 48, 154, 56, 54, 99, 5, 229, 161, 225, 47, 85, 133, 90, 61, 156, 86, 3, 14, 10, 69, 185, 225, 226, 181, 141, 67, 44, 121, 157, 98, 247, 148, 201, 248, 236, 190, 217, 245, 131, 68, 124, 28, 193, 143, 215, 32, 184, 50, 71, 92, 148, 35, 180, 112, 125, 12, 152, 111, 32, 30, 86, 15, 107, 225, 39, 30, 178, 215, 182, 113, 216, 137, 98, 189, 72, 68, 107, 246, 108, 210, 148, 191, 28, 40, 233, 200, 222, 132, 247, 207, 239, 32, 79, 238, 18, 62, 67, 114, 186, 6, 212, 215, 31, 13, 53, 138, 97, 169, 28, 183, 235, 221, 218, 81, 84, 235]
Printed from wasi: This is from a main function
This is from a main function
The env vars are as follows.
The args are as follows.
/wasi_example_main.wasm
50000000
File content is This is in a file
pod &quot;wasi-demo&quot; deleted
</code></pre>
<p>You can now check out the pod status through the Kubernetes command line.</p>
<pre><code class="language-bash">crictl ps -a
</code></pre>
<p>You can see the events from scheduling to running the WebAssembly workload in the log.</p>
<pre><code class="language-bash">CONTAINER           IMAGE               CREATED             STATE               NAME                 ATTEMPT             POD ID
0c176ed65599a       0423b8eb71e31       8 seconds ago       Exited              wasi-demo  
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="running-wasmedge-apps-with-the-docker-cli"><a class="header" href="#running-wasmedge-apps-with-the-docker-cli">Running WasmEdge apps with the Docker CLI</a></h1>
<p>The Docker CLI is a very popular developer tool. However, it is not easy to replace Docker's underlying OCI runtime (<code>runc</code>) with the WasmEdge-enabled <code>crun</code>. In this section, we will discuss two ways to run WasmEdge applications in Docker.</p>
<ul>
<li><a href="use_cases/kubernetes/docker/lxc.html">Wrap WasmEdge in a slim Linux container</a></li>
<li><a href="use_cases/kubernetes/docker/containerd.html">Use containerd shim</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="use-the-slim-linux-container"><a class="header" href="#use-the-slim-linux-container">Use the slim Linux container</a></h1>
<p>An easy way to run WebAssembly applications in the Docker ecosystem is to simply embed the WebAssembly bytecode file in a Linux container image. Specifically, we trim down the Linux OS inside the container to the point where it is just enough to support the <code>wasmedge</code> runtime. This approach has many advantages.</p>
<ul>
<li>It works seamlessly with any tool in the Docker or container ecosystem since the WebAssembly application is wrapped in a regular container.</li>
<li>The memory footprint of the entire image of Linux OS and WasmEdge can be reduced to as low as 4MB.</li>
<li>The attack surface of the slimmed Linux OS is dramatically reduced from a regular Linux OS.</li>
<li>The overall application security is managed by the WebAssembly sandbox. The risk for software supply chain attack is greatly reduced since the WebAssembly sandbox only has access to explicitly declared capabilities.</li>
<li>The above three advantages are amplified if the application is complex. For example, a WasmEdge AI inference application would NOT require a Python install. A WasmEdge node.js application would NOT require a Node.js and v8 install.</li>
</ul>
<p>However, this approach still requires starting up a Linux container. The containerized Linux OS, however slim, still takes 80% of the total image size. There is still a lot of room for optimization. The performance and security of this approach would not be as great as running WebAssembly applications directly in <a href="use_cases/kubernetes/docker/../container/crun.html">crun</a> or in a <a href="use_cases/kubernetes/docker/containerd.html">containerd shim</a>.</p>
<h2 id="run-a-simple-webassembly-app-3"><a class="header" href="#run-a-simple-webassembly-app-3">Run a simple WebAssembly app</a></h2>
<p>We can run a simple WebAssembly program using Docker. An slim Linux image with WasmEdge installed is only 4MB as opposed to 30MB for a general Linux image for native compiled applications. The Linux + WasmEdge image is similar to a unikernel OS image. It minimizes the footprint, performance overhead, and potential attack surface for WebAssembly applications.</p>
<p><a href="https://github.com/second-state/wasm-learning/tree/master/cli/wasi">The sample application is here</a>. First, create a <code>Dockerfile</code> based on our release image. Include the <a href="https://github.com/second-state/wasm-learning/raw/master/cli/wasi/wasi_example_main.wasm">wasm application file</a> in the new image, and run the <code>wasmedge</code> command at start up.</p>
<pre><code class="language-shell">FROM wasmedge/slim-runtime:0.10.1
ADD wasi_example_main.wasm /
CMD [&quot;wasmedge&quot;, &quot;--dir&quot;, &quot;.:/&quot;, &quot;/wasi_example_main.wasm&quot;]
</code></pre>
<p>Run the WebAssembly application in Docker CLI as follows.</p>
<pre><code class="language-shell">$ docker build -t wasmedge/myapp -f Dockerfile ./
... ...
Successfully tagged wasmedge/myapp:latest

$ docker run --rm wasmedge/myapp
Random number: -807910034
Random bytes: [113, 123, 78, 85, 63, 124, 68, 66, 151, 71, 91, 249, 242, 160, 164, 133, 35, 209, 106, 143, 202, 87, 147, 87, 236, 49, 238, 165, 125, 175, 172, 114, 136, 205, 200, 176, 30, 122, 149, 21, 39, 58, 221, 102, 165, 179, 124, 13, 60, 166, 188, 127, 83, 95, 145, 0, 25, 209, 226, 190, 10, 184, 139, 191, 243, 149, 197, 85, 186, 160, 162, 156, 181, 74, 255, 99, 203, 161, 108, 153, 90, 155, 247, 183, 106, 79, 48, 255, 172, 17, 193, 36, 245, 195, 170, 202, 119, 238, 104, 254, 214, 227, 149, 20, 8, 147, 105, 227, 114, 146, 246, 153, 251, 139, 130, 1, 219, 56, 228, 154, 146, 203, 205, 56, 27, 115, 79, 254]
Printed from wasi: This is from a main function
This is from a main function
The env vars are as follows.
The args are as follows.
wasi_example_main.wasm
File content is This is in a file
</code></pre>
<h2 id="run-a-http-server-app-2"><a class="header" href="#run-a-http-server-app-2">Run a HTTP server app</a></h2>
<p>We can run a simple WebAssembly-based HTTP micro-service using the Docker CLI. The <a href="https://github.com/second-state/wasmedge_wasi_socket/tree/main/examples/http_server">sample application is here</a>. Follow instructions to compile and build the <code>http_server.wasm</code> file.</p>
<p>Create a <code>Dockerfile</code> based on our release image. Include the <code>http_server.wasm</code> application file in the new image, and run the <code>wasmedge</code> command at start up.</p>
<pre><code class="language-shell">FROM wasmedge/slim-runtime:0.10.1
ADD http_server.wasm /
CMD [&quot;wasmedge&quot;, &quot;--dir&quot;, &quot;.:/&quot;, &quot;/http_server.wasm&quot;]
</code></pre>
<p>Run the WebAssembly server application in Docker CLI as follows. Notice that we map the server port from the container to the host.</p>
<pre><code class="language-shell">$ docker build -t wasmedge/myapp -f Dockerfile ./
... ...
Successfully tagged wasmedge/myapp:latest

$ docker run --rm -p 1234:1234 wasmedge/myapp
new connection at 1234
</code></pre>
<p>You can now access the server from another terminal.</p>
<pre><code class="language-shell">$ curl -X POST http://127.0.0.1:1234 -d &quot;name=WasmEdge&quot;
echo: name=WasmEdge
</code></pre>
<h2 id="run-a-lightweight-nodejs-server"><a class="header" href="#run-a-lightweight-nodejs-server">Run a lightweight Node.js server</a></h2>
<p>With WasmEdge QuickJS support for the Node.js API, we can run a lightweight and secure node.js server from Docker CLI. The slim Linux + WasmEdge + Node.js support image size is less than 15MB as opposed to over 350MB for a standard Node.js image. You will need to do the following.</p>
<ul>
<li><a href="https://github.com/second-state/wasmedge-quickjs/releases/download/v0.4.0-alpha/wasmedge_quickjs.wasm">Download the WasmEdge QuickJS runtime</a> here. You will have the <code>wasmedge_quickjs.wasm</code> file.</li>
<li><a href="https://github.com/second-state/wasmedge-quickjs/tree/main/modules">Download the modules</a> directory from the WasmEdge QuickJS repo.</li>
<li>Create a JavaScript file for the server. Below is an example <code>http_echo.js</code> file you can use.</li>
</ul>
<pre><code class="language-javascript">import { createServer, request, fetch } from 'http';

createServer((req, resp) =&gt; {
  req.on('data', (body) =&gt; {
    resp.write('echo:')
    resp.end(body)
  })
}).listen(8001, () =&gt; {
  print('listen 8001 ...\n');
})
</code></pre>
<p>Add those files to the Docker image and run the JavaScript file at startup.</p>
<pre><code class="language-shell">FROM wasmedge/slim-runtime:0.10.1
ADD wasmedge_quickjs.wasm /
ADD http_echo.js /
ADD modules /modules
CMD [&quot;wasmedge&quot;, &quot;--dir&quot;, &quot;.:/&quot;, &quot;/wasmedge_quickjs.wasm&quot;, &quot;http_echo.js&quot;]
</code></pre>
<p>Start the server from Docker CLI.</p>
<pre><code class="language-shell">$ docker build -t wasmedge/myapp -f Dockerfile ./
... ...
Successfully tagged wasmedge/myapp:latest

$ docker run --rm -p 8001:8001 wasmedge/myapp
listen 8001 ...
</code></pre>
<p>You can now access the server from another terminal.</p>
<pre><code class="language-shell">$ curl -X POST http://127.0.0.1:8001 -d &quot;WasmEdge&quot;
echo:WasmEdge
</code></pre>
<h2 id="run-a-lightweight-tensorflow-inference-application"><a class="header" href="#run-a-lightweight-tensorflow-inference-application">Run a lightweight Tensorflow inference application</a></h2>
<p>A unique and powerful feature of the WasmEdge runtime is its support for AI frameworks. In this example, we will show you how to run an image recognition service from Docker CLI. <a href="https://github.com/WasmEdge/wasmedge_hyper_demo/tree/main/server-tflite">The sample application is here</a>. First, create a <code>Dockerfile</code> based on our <code>tensorflow</code> release image. Include the <a href="https://github.com/WasmEdge/wasmedge_hyper_demo/raw/main/server-tflite/wasmedge_hyper_server_tflite.wasm">wasm application file</a> in the new image, and run the <code>wasmedge-tensorflow-lite</code> command at start up.</p>
<p>The Dockerfile is as follows. The whole package is 115MB. It is less than 1/4 of a typically Linux + Python + Tensorflow setup.</p>
<pre><code class="language-shell">FROM wasmedge/slim-tf:0.10.1
ADD wasmedge_hyper_server_tflite.wasm /
CMD [&quot;wasmedge-tensorflow-lite&quot;, &quot;--dir&quot;, &quot;.:/&quot;, &quot;/wasmedge_hyper_server_tflite.wasm&quot;]
</code></pre>
<p>Start the server from Docker CLI.</p>
<pre><code class="language-shell">$ docker build -t wasmedge/myapp -f Dockerfile ./
... ...
Successfully tagged wasmedge/myapp:latest

$ docker run --rm -p 3000:3000 wasmedge/myapp
listen 3000 ...
</code></pre>
<p>You can now access the server from another terminal.</p>
<pre><code class="language-shell">$ curl http://localhost:3000/classify -X POST --data-binary &quot;@grace_hopper.jpg&quot;
military uniform is detected with 206/255 confidence
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="use-the-containerd-shim"><a class="header" href="#use-the-containerd-shim">Use the containerd shim</a></h1>
<p>As we discussed, wrapping WebAssembly inside a Docker Linux container results in performance and security penalties. However, we cannot easily replace the OCI runtime (<code>runc</code>) in the Docker toolchain as well. In this chapter, we will discuss another approach to start and run WebAssembly bytecode applications directly from the Docker CLI.</p>
<p>Coming soon</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="app-frameworks-and-platforms"><a class="header" href="#app-frameworks-and-platforms">App Frameworks and Platforms</a></h1>
<p>WasmEdge applications can be plugged into existing application frameworks or platforms. WasmEdge provides a safe and efficient extension mechanism for those frameworks.</p>
<p>In this chapter, we will introduce several such frameworks and platforms.</p>
<ul>
<li><a href="use_cases/frameworks/mesh.html">Service mesh and frameworks</a> support WasmEdge to run as containers for microservices. We will cover distributed application framework <a href="use_cases/frameworks/mesh/dapr.html">Dapr</a>, service mesh <a href="use_cases/frameworks/mesh/mosn.html">MOSN</a>, and event mesh <a href="use_cases/frameworks/mesh/eventmesh.html">Apache EventMesh</a>.</li>
<li><a href="use_cases/frameworks/app.html">Application frameworks</a> support WasmEdge as an embedded function or plug-in runtime. We will cover streaming data framework <a href="use_cases/frameworks/app/yomo.html">YoMo</a> and Go function schedulder / framework <a href="use_cases/frameworks/app/reactr.html">Reactr</a>.</li>
<li><a href="use_cases/frameworks/serverless.html">Serverless platforms</a> allows WasmEdge programs to run as serverless functions in their infrastructure. We will cover <a href="use_cases/frameworks/serverless/aws.html">AWS Lambda</a>, <a href="use_cases/frameworks/serverless/tencent.html">Tencent Serverless Cloud Functions</a>, <a href="use_cases/frameworks/serverless/vercel.html">Vercel Serverless Functions</a>, <a href="use_cases/frameworks/serverless/netlify.html">Netlify Functions</a>, and <a href="use_cases/frameworks/serverless/secondstate.html">Second State Functions</a>.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="service-mesh-and-distributed-runtimes"><a class="header" href="#service-mesh-and-distributed-runtimes">Service mesh and distributed runtimes</a></h1>
<p>WasmEdge could be a lightweight runtime for sidecar microservices and the API proxy as the Docker alternative.</p>
<h2 id="sidecar-microservices"><a class="header" href="#sidecar-microservices">Sidecar microservices</a></h2>
<p>For sidecar frameworks that support multiple application runtimes, we could simply embed WasmEdge applications into the sidecar through its C, Go, Rust, or Node.js SDKs. In addition, WasmEdge applications could be managed directly by container tools and act as sidecar microservices.</p>
<ul>
<li><a href="use_cases/frameworks/mesh/dapr.html">Dapr</a> showcases how to run WasmEdge microservices as Dapr sidecars.</li>
<li><a href="use_cases/frameworks/mesh/eventmesh.html">Apache EventMesh</a> showcases how to run WasmEdge microservices as Apache EventMesh sidecars</li>
</ul>
<h2 id="extension-for-the-api-proxy"><a class="header" href="#extension-for-the-api-proxy">Extension for the API proxy</a></h2>
<p>The API proxy is another crucial component in the service mesh. It manages and directs API requests to sidecars in a manner that keeps the system scalable. Developers need to script those proxies to route traffic according to changing infrastructure and ops requirements. Seeing widespread demand for using WebAssembly instead of the LUA scripting language, the community came together and created the proxy-wasm spec. It defines the host interface that WebAssembly runtimes must support to plug into the proxy. WasmEdge supports proxy-wasm now.</p>
<ul>
<li><a href="use_cases/frameworks/mesh/mosn.html">MOSN</a> shows how to use WasmEdge as extensions for MOSN.</li>
<li><a href="use_cases/frameworks/mesh/wasm-nginx-module.html">wasm-nginx-module</a> shows how to use WasmEdge run Go/Rust code in OpenResty.</li>
</ul>
<p>If you have some great ideas on WasmEdge and microservices, feel free to create an issue or PR on the <a href="https://github.com/WasmEdge/WasmEdge">WasmEdge</a> GitHub repo!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="dapr"><a class="header" href="#dapr">Dapr</a></h1>
<p>In this article, I will demonstrate how to use WasmEdge as a sidecar application runtime for Dapr. There are two ways to do this:</p>
<ul>
<li><strong>Standalone WasmEdge</strong> is the <strong>recommended approach</strong> is to write a microservice using <a href="use_cases/frameworks/mesh/../../../write_wasm/rust/networking-nonblocking.html">Rust</a> or <a href="use_cases/frameworks/mesh/../../../write_wasm/js/networking.html">JavaScript</a>, and run it in WasmEdge. The WasmEdge application serves web requests and communicates with the sidecar via sockets using the Dapr API. In this case, we can <a href="use_cases/frameworks/mesh/../../kubernetes/quickstart.html">run WasmEdge as a managed container in k8s</a>.</li>
<li>Alternatively, Embedded WasmEdge is to create a simple microservice in Rust or Go to listen for web requests and communicate with the Dapr sidecar. It passes the request data to a WasmEdge runtime for processing. The business logic of the microservice is a WebAssembly function created and deployed by an application developer.</li>
</ul>
<blockquote>
<p>While the first approach (running the entire microservice in WasmEdge) is much preferred, we are still working on a fully fledged Dapr SDKs for WasmEdge. You can track their progress in GitHub issues -- <a href="https://github.com/WasmEdge/WasmEdge/issues/1571">Rust</a> and <a href="https://github.com/WasmEdge/WasmEdge/issues/1572">JavaScript</a>.</p>
</blockquote>
<h2 id="quick-start-7"><a class="header" href="#quick-start-7">Quick start</a></h2>
<p>First you need to install <a href="https://docs.dapr.io/getting-started/install-dapr-cli">Dapr</a> and <a href="use_cases/frameworks/mesh/../../../quick_start/install.html">WasmEdge</a>. <a href="https://golang.org/doc/install">Go</a> and <a href="https://www.rust-lang.org/tools/install">Rust</a> are optional for the standalone WasmEdge approach. However, they are required for the demo app since it showcases both standalone and embedded WasmEdge approaches.</p>
<p>Fork or clone the demo application from Github. You can use this repo as your own application template.</p>
<pre><code class="language-bash">git clone https://github.com/second-state/dapr-wasm
</code></pre>
<p>The demo has 4 Dapr sidecar applications. The <a href="https://github.com/second-state/dapr-wasm/tree/main/web-port">web-port</a> project provides a public web service for a static HTML page. This is the application’s UI. From the static HTML page, the user can select a microservice to turn an input image into grayscale. All 3 microsoervices below perform the same function. They are just implemented using different appraoches.</p>
<ul>
<li><strong>Standalone WasmEdge approach:</strong> The <a href="https://github.com/second-state/dapr-wasm/tree/main/image-api-wasi-socket-rs">image-api-wasi-socket-rs</a> project provides a standalone WasmEdge sidecar microservice that takes the input image and returns the grayscale image. The microservice is written in Rust and compiled into WebAssembly bytecode to run in WasmEdge.</li>
<li>Embedded WasmEdge approach #1: The <a href="https://github.com/second-state/dapr-wasm/tree/main/image-api-rs">image-api-rs</a> project provides a simple Rust-based microservice. It embeds a <a href="https://github.com/second-state/dapr-wasm/tree/main/functions/grayscale">WasmEdge function</a> to turn an input image into a grayscale image.</li>
<li>Embedded WasmEdge approach #2: The <a href="https://github.com/second-state/dapr-wasm/tree/main/image-api-go">image-api-go</a> project provides a simple Go-based microservice. It embeds a <a href="https://github.com/second-state/dapr-wasm/tree/main/functions/grayscale">WasmEdge function</a> to turn an input image into a grayscale image.</li>
</ul>
<p>You can follow the instructions in the <a href="https://github.com/second-state/dapr-wasm/blob/main/README.md">README</a> to start the sidecar services. Here are commands to build the WebAssembly functions and start the sidecar services. The first set of commands deploy the static web page service and the standalone WasmEdge service written in Rust. It forms a complete application to turn an input image into grayscale.</p>
<pre><code class="language-bash"># Build and start the static HTML web page service for the UI and router for sending the uploaded image to the grayscale microservice
cd web-port
go build
./run_web.sh
cd ../

# Build the standalone image grayscale web service for WasmEdge
cd image-api-wasi-socket-rs
cargo build  --target wasm32-wasi
cd ../

# Run the microservice as a Dapr sidecar app
cd image-api-wasi-socket-rs
./run_api_wasi_socket_rs.sh
cd ../
</code></pre>
<p>The second set of commands create the alternative microservices for the embedded WasmEdge function.</p>
<pre><code class="language-bash"># Build the grayscale WebAssembly functions, and deploy them to the sidecar projects
cd functions/grayscale
./build.sh
cd ../../

# Build and start the Rust-based microservice for embedding the grayscale WasmEdge function
cd image-api-rs
cargo build --release
./run_api_rs.sh
cd ../

# Build and start the Go-based microservice for embedding the grayscale WasmEdge function
cd image-api-go
go build
./run_api_go.sh
cd ../
</code></pre>
<p>Finally, you should be able to see the web UI in your browser.</p>
<h2 id="recommended-the-standalone-wasmedge-microservice-in-rust"><a class="header" href="#recommended-the-standalone-wasmedge-microservice-in-rust">Recommended: The standalone WasmEdge microservice in Rust</a></h2>
<p>The <a href="https://github.com/second-state/dapr-wasm/blob/main/image-api-wasi-socket-rs/src/main.rs">standalone WasmEdge microservice</a> starts a non-blocking TCP server inside WasmEdge. The TCP server passes incoming requests to <code>handle_client()</code>, which passes HTTP requests to <code>handle_http()</code>, which calls <code>grayscale()</code> to process the image data in the request.</p>
<pre><pre class="playground"><code class="language-rust">fn main() -&gt; std::io::Result&lt;()&gt; {
    let port = std::env::var(&quot;PORT&quot;).unwrap_or(9005.to_string());
    println!(&quot;new connection at {}&quot;, port);
    let listener = TcpListener::bind(format!(&quot;127.0.0.1:{}&quot;, port))?;
    loop {
        let _ = handle_client(listener.accept()?.0);
    }
}

fn handle_client(mut stream: TcpStream) -&gt; std::io::Result&lt;()&gt; {
  ... ...
}

fn handle_http(req: Request&lt;Vec&lt;u8&gt;&gt;) -&gt; bytecodec::Result&lt;Response&lt;String&gt;&gt; {
  ... ...
}

fn grayscale(image: &amp;[u8]) -&gt; Vec&lt;u8&gt; {
    let detected = image::guess_format(&amp;image);
    let mut buf = vec![];
    if detected.is_err() {
        return buf;
    }
    
    let image_format_detected = detected.unwrap();
    let img = image::load_from_memory(&amp;image).unwrap();
    let filtered = img.grayscale();
    match image_format_detected {
        ImageFormat::Gif =&gt; {
            filtered.write_to(&amp;mut buf, ImageOutputFormat::Gif).unwrap();
        }
        _ =&gt; {
            filtered.write_to(&amp;mut buf, ImageOutputFormat::Png).unwrap();
        }
    };
    return buf;
}
</code></pre></pre>
<blockquote>
<p>Work in progress: It will soon interact with the Dapr sidecar through the <a href="https://github.com/WasmEdge/WasmEdge/issues/1571">WasmEdge Dapr SDK in Rust</a>.</p>
</blockquote>
<p>Now, you can build the microservice. It is a simple matter of compiling from Rust to WebAssembly.</p>
<pre><code class="language-bash">cd image-api-wasi-socket-rs
cargo build  --target wasm32-wasi
</code></pre>
<p>Deploy the WasmEdge microservice in Dapr as follows.</p>
<pre><code class="language-bash">dapr run --app-id image-api-wasi-socket-rs \
         --app-protocol http \
         --app-port 9005 \
         --dapr-http-port 3503 \
         --components-path ../config \
         --log-level debug \
         wasmedge ./target/wasm32-wasi/debug/image-api-wasi-socket-rs.wasm
</code></pre>
<h2 id="alternative-the-embedded-wasmedge-microservices"><a class="header" href="#alternative-the-embedded-wasmedge-microservices">Alternative: The embedded WasmEdge microservices</a></h2>
<p>The embedded WasmEdge approach requires us to create a WebAssembly function for the business logic (image processing) first, and then embed it into simple Dapr microservices.</p>
<h3 id="rust-function-for-image-processing"><a class="header" href="#rust-function-for-image-processing">Rust function for image processing</a></h3>
<p>The <a href="https://github.com/second-state/dapr-wasm/blob/main/functions/grayscale/src/lib.rs">Rust function</a> is simple. It uses the <a href="use_cases/frameworks/mesh/../../../write_wasm/rust/bindgen.html">wasmedge_bindgen</a> macro to makes it easy to call the function from a Go or Rust host embedding the WebAssembly function. It takes and returns base64 encoded image data for the web.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[wasmedge_bindgen]
pub fn grayscale(image_data: String) -&gt; String {
    let image_bytes = image_data.split(&quot;,&quot;).map(|x| x.parse::&lt;u8&gt;().unwrap()).collect::&lt;Vec&lt;u8&gt;&gt;();
    return grayscale::grayscale_internal(&amp;image_bytes);
}
<span class="boring">}
</span></code></pre></pre>
<p>The Rust function that actually performs the task is as follows.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn grayscale_internal(image_data: &amp;[u8]) -&gt; String {
    let image_format_detected: ImageFormat = image::guess_format(&amp;image_data).unwrap();
    let img = image::load_from_memory(&amp;image_data).unwrap();
    let filtered = img.grayscale();
    let mut buf = vec![];
    match image_format_detected {
        ImageFormat::Gif =&gt; {
            filtered.write_to(&amp;mut buf, ImageOutputFormat::Gif).unwrap();
        }
        _ =&gt; {
            filtered.write_to(&amp;mut buf, ImageOutputFormat::Png).unwrap();
        }
    };
    let mut base64_encoded = String::new();
    base64::encode_config_buf(&amp;buf, base64::STANDARD, &amp;mut base64_encoded);
    return base64_encoded.to_string();
}
<span class="boring">}
</span></code></pre></pre>
<h3 id="the-go-host-wrapper-for-microservice"><a class="header" href="#the-go-host-wrapper-for-microservice">The Go host wrapper for microservice</a></h3>
<p>The <a href="https://github.com/second-state/dapr-wasm/tree/main/image-api-go">Go-based microservice</a> embeds the above imaging processing function in WasmEdge. The <a href="https://github.com/second-state/dapr-wasm/blob/main/image-api-go/image_api.go">microservice itself</a> is a web server and utilizes the Dapr Go SDK.</p>
<pre><code class="language-go">func main() {
  s := daprd.NewService(&quot;:9003&quot;)

  if err := s.AddServiceInvocationHandler(&quot;/api/image&quot;, imageHandlerWASI); err != nil {
    log.Fatalf(&quot;error adding invocation handler: %v&quot;, err)
  }

  if err := s.Start(); err != nil &amp;&amp; err != http.ErrServerClosed {
    log.Fatalf(&quot;error listenning: %v&quot;, err)
  }
}
</code></pre>
<p>The <code>imageHandlerWASI()</code> function <a href="use_cases/frameworks/mesh/../../../sdk/go/function.html">starts a WasmEdge instance</a> and calls the image processing (grayscale) function in it via <a href="use_cases/frameworks/mesh/../../../write_wasm/rust/bindgen.html">wasmedge_bindgen</a>.</p>
<p>Build and deploy the Go microservice to Dapr as follows.</p>
<pre><code class="language-bash">cd image-api-go
go build
dapr run --app-id image-api-go \
         --app-protocol http \
         --app-port 9003 \
         --dapr-http-port 3501 \
         --log-level debug \
         --components-path ../config \
         ./image-api-go
</code></pre>
<h3 id="the-rust-host-wrapper-for-microservice"><a class="header" href="#the-rust-host-wrapper-for-microservice">The Rust host wrapper for microservice</a></h3>
<p>The <a href="https://github.com/second-state/dapr-wasm/tree/main/image-api-rs">Rust-based microservice</a> embeds the above imaging processing function in WasmEdge. The <a href="https://github.com/second-state/dapr-wasm/blob/main/image-api-rs/src/main.rs">microservice itself</a> is a Tokio and Warp based web server.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[tokio::main]
pub async fn run_server(port: u16) {
    pretty_env_logger::init();
    let home = warp::get().map(warp::reply);

    let image = warp::post()
        .and(warp::path(&quot;api&quot;))
        .and(warp::path(&quot;image&quot;))
        .and(warp::body::bytes())
        .map(|bytes: bytes::Bytes| {
            let v: Vec&lt;u8&gt; = bytes.iter().map(|&amp;x| x).collect();
            let res = image_process_wasmedge_sys(&amp;v);
            let _encoded = base64::encode(&amp;res);
            Response::builder()
                .header(&quot;content-type&quot;, &quot;image/png&quot;)
                .body(res)
        });

    let routes = home.or(image);
    let routes = routes.with(warp::cors().allow_any_origin());

    let log = warp::log(&quot;dapr_wasm&quot;);
    let routes = routes.with(log);
    warp::serve(routes).run((Ipv4Addr::UNSPECIFIED, port)).await
}
<span class="boring">}
</span></code></pre></pre>
<p>The <code>image_process_wasmedge_sys()</code> function <a href="use_cases/frameworks/mesh/../../../sdk/rust/sys_run_host_func.html">starts a WasmEdge instance</a> and calls the image processing (grayscale) function in it via <a href="use_cases/frameworks/mesh/../../../write_wasm/rust/bindgen.html">wasmedge_bindgen</a>.</p>
<p>Build and deploy the Rust microservice to Dapr as follows.</p>
<pre><code class="language-bash">cd image-api-rs
cargo build --release
dapr stop image-api-rs

# Change this to your own path for WasmEdge
export LD_LIBRARY_PATH=/home/coder/.wasmedge/lib64/

dapr run --app-id image-api-rs \
         --app-protocol http \
         --app-port 9004 \
         --dapr-http-port 3502 \
         --components-path ../config \
         --log-level debug \
         ./target/release/image-api-rs
</code></pre>
<p>That's it! <a href="https://github.com/WasmEdge/WasmEdge/discussions">Let us know</a> your cool Dapr microservices in WebAssembly!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mosn"><a class="header" href="#mosn">MOSN</a></h1>
<p>Coming soon.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="wasm-nginx-module"><a class="header" href="#wasm-nginx-module">wasm-nginx-module</a></h1>
<p>The wasm-nginx-module is an Nginx module built upon OpenResty. By implementing the <a href="https://github.com/proxy-wasm/spec">Proxy Wasm ABI</a>, any Wasm program written with Proxy Wasm SDK can be run inside it. Hence, you can write Go or Rust code, compile them into Wasm, then load &amp; execute it in Nginx.</p>
<blockquote>
<p>The wasm-nginx-module is already used in APISIX and allows it to <a href="https://github.com/apache/apisix/blob/master/docs/en/latest/wasm.md">run Wasm plugin like Lua plugin</a>.</p>
</blockquote>
<p>In order to follow along the tutorials in this chapter, you will need to first <a href="https://github.com/api7/wasm-nginx-module#install-dependencies">build your Nginx with wasm-nginx-module included and WasmEdge shared library installed in the right path</a>.</p>
<p>Once you have Nginx installed, let me show you a real world example - using Wasm to inject custom responses in Nginx.</p>
<h2 id="inject-custom-response-via-go-in-nginx-step-by-step"><a class="header" href="#inject-custom-response-via-go-in-nginx-step-by-step">Inject Custom Response via Go in Nginx, Step by Step</a></h2>
<h3 id="go-step-1-write-code-based-on-proxy-wasm-go-sdk"><a class="header" href="#go-step-1-write-code-based-on-proxy-wasm-go-sdk">Go Step 1: Write code based on proxy-wasm-go-sdk</a></h3>
<p>The implementation code (including <code>go.mod</code> and others) can be found at <a href="https://github.com/apache/apisix/tree/master/t/wasm">here</a>.</p>
<p>It should be explained that although the proxy-wasm-go-sdk project carries the Go name, it actually uses tinygo instead of native Go, which has some problems supporting WASI (which you can think of as a non-browser WASM runtime interface), see <a href="https://github.com/tetratelabs/proxy-wasm-go-sdk/blob/main/doc/OVERVIEW.md#tinygo-vs-the-official-go-compiler">here</a> for more details.</p>
<p>We also provide a Rust version (including Cargo.toml and others) <a href="https://github.com/api7/wasm-nginx-module/tree/main/t/testdata/rust/fault-injection">there</a>.</p>
<h3 id="go-step-2-build-the-corresponding-wasm-file"><a class="header" href="#go-step-2-build-the-corresponding-wasm-file">Go Step 2: Build the corresponding Wasm file</a></h3>
<pre><code class="language-shell">tinygo build -o ./fault-injection/main.go.wasm -scheduler=none -target=wasi ./fault-injection/main.go
</code></pre>
<h3 id="go-step-3-load-and-execute-the-wasm-file"><a class="header" href="#go-step-3-load-and-execute-the-wasm-file">Go Step 3: Load and execute the Wasm file</a></h3>
<p>Then, start Nginx with the configuration below:</p>
<pre><code class="language-conf">worker_processes  1;

error_log  /tmp/error.log warn;

events {
    worker_connections  10240;
}

http {
    wasm_vm wasmedge;
    init_by_lua_block {
        local wasm = require(&quot;resty.proxy-wasm&quot;)
        package.loaded.plugin = assert(wasm.load(&quot;fault_injection&quot;,
            &quot;/path/to/fault-injection/main.go.wasm&quot;))
    }
    server {
        listen 1980;
        location / {
            content_by_lua_block {
                local wasm = require(&quot;resty.proxy-wasm&quot;)
                local ctx = assert(wasm.on_configure(package.loaded.plugin,
                    '{&quot;http_status&quot;: 403, &quot;body&quot;: &quot;powered by wasm-nginx-module&quot;}'))
                assert(wasm.on_http_request_headers(ctx))
            }
        }
    }
}
</code></pre>
<p>This configuration loads the Wasm file we just built, executes it with the configuration <code>{&quot;http_status&quot;: 403, &quot;body&quot;: &quot;powered by wasm-nginx-module&quot;}</code>.</p>
<h3 id="go-step-4-verify-the-result"><a class="header" href="#go-step-4-verify-the-result">Go Step 4: verify the result</a></h3>
<p>After Nginx starts, we can use <code>curl http://127.0.0.1:1980/ -i</code> to verify the execution result of the Wasm.</p>
<p>It is expected to see the output:</p>
<pre><code class="language-bash">HTTP/1.1 403 Forbidden
...

powered by wasm-nginx-module
</code></pre>
<h2 id="inject-custom-response-via-rust-in-nginx-step-by-step"><a class="header" href="#inject-custom-response-via-rust-in-nginx-step-by-step">Inject Custom Response via Rust in Nginx, Step by Step</a></h2>
<h3 id="rust-step-1-write-code-based-on-proxy-wasm-rust-sdk"><a class="header" href="#rust-step-1-write-code-based-on-proxy-wasm-rust-sdk">Rust Step 1: Write code based on proxy-wasm-rust-sdk</a></h3>
<p>We also provide a Rust version (including Cargo.toml and others) <a href="https://github.com/api7/wasm-nginx-module/tree/main/t/testdata/rust/fault-injection">here</a>.</p>
<h3 id="rust-step-2-build-the-corresponding-wasm-file"><a class="header" href="#rust-step-2-build-the-corresponding-wasm-file">Rust Step 2: Build the corresponding Wasm file</a></h3>
<pre><code class="language-shell">cargo build --target=wasm32-wasi
</code></pre>
<h3 id="rust-step-3-load-and-execute-the-wasm-file"><a class="header" href="#rust-step-3-load-and-execute-the-wasm-file">Rust Step 3: Load and execute the Wasm file</a></h3>
<p>Then, start Nginx with the configuration below:</p>
<pre><code class="language-conf">worker_processes  1;

error_log  /tmp/error.log warn;

events {
    worker_connections  10240;
}

http {
    wasm_vm wasmedge;
    init_by_lua_block {
        local wasm = require(&quot;resty.proxy-wasm&quot;)
        package.loaded.plugin = assert(wasm.load(&quot;fault_injection&quot;,
            &quot;/path/to/fault-injection/target/wasm32-wasi/debug/fault_injection.wasm&quot;))
    }
    server {
        listen 1980;
        location / {
            content_by_lua_block {
                local wasm = require(&quot;resty.proxy-wasm&quot;)
                local ctx = assert(wasm.on_configure(package.loaded.plugin,
                    '{&quot;http_status&quot;: 403, &quot;body&quot;: &quot;powered by wasm-nginx-module&quot;}'))
                assert(wasm.on_http_request_headers(ctx))
            }
        }
    }
}
</code></pre>
<p>This configuration loads the Wasm file we just built, executes it with the configuration <code>{&quot;http_status&quot;: 403, &quot;body&quot;: &quot;powered by wasm-nginx-module&quot;}</code>.</p>
<h3 id="rust-step-4-verify-the-result"><a class="header" href="#rust-step-4-verify-the-result">Rust Step 4: verify the result</a></h3>
<p>After Nginx starts, we can use <code>curl http://127.0.0.1:1980/ -i</code> to verify the execution result of the Wasm.</p>
<p>It is expected to see the output:</p>
<pre><code class="language-bash">HTTP/1.1 403 Forbidden
...

powered by wasm-nginx-module
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="apache-eventmesh"><a class="header" href="#apache-eventmesh">Apache EventMesh</a></h1>
<p>Coming soon, or you can <a href="https://github.com/WasmEdge/WasmEdge/issues/632">help out</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="app-frameworks"><a class="header" href="#app-frameworks">App frameworks</a></h1>
<p>WasmEdge provides a safe and efficient extension mechanism for applications.
Of course, application developers can always use <a href="use_cases/frameworks/../../sdk.html">WasmEdge SDKs</a> to embed WebAssembly functions. But some applications and frameworks opt to build their own extension / embedding APIs on top of the WasmEdge SDK, which supports more ergonomic integration with the application's native use cases and programming models.</p>
<ul>
<li><a href="use_cases/frameworks/app/yomo.html">YoMo</a> is a data stream processing framework. WasmEdge functions can be plugged into the framework to process data in-stream.</li>
<li><a href="use_cases/frameworks/app/reactr.html">Reactr</a> is a Go language framework for managing and extending WebAssembly functions for the purpose of easy embedding into other Go applications.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="yomo"><a class="header" href="#yomo">YoMo</a></h1>
<p><a href="https://yomo.run/">YoMo</a> is a programming framework enabling developers to build a distributed cloud system (Geo-Distributed Cloud System). YoMo's communication layer is made on top of the QUIC protocol, which brings high-speed data transmission. In addition, it has a built-in Streaming Serverless &quot;streaming function&quot;, which significantly improves the development experience of distributed cloud systems. The distributed cloud system built by YoMo provides an ultra-high-speed communication mechanism between near-field computing power and terminals. It has a wide range of use cases in Metaverse, VR/AR, IoT, etc.</p>
<blockquote>
<p>YoMo is written in the Go language. For streaming Serverless, Golang plugins and shared libraries are used to load users' code dynamically, which also have certain limitations for developers. Coupled with Serverless architecture's rigid demand for isolation, this makes WebAssembly an excellent choice for running user-defined functions.</p>
</blockquote>
<p>For example, in the process of real-time AI inference in AR/VR devices or smart factories, the camera sends real-time unstructured data to the computing node in the near-field MEC (multi-access edge computing) device through YoMo.  YoMo sends the AI computing result to the end device in real-time when the AI inference is completed. Thus, the hosted AI inference function will be automatically executed.</p>
<p>However, a challenge for YoMo is to incorporate and manage handler functions written by multiple outside developers in an edge computing node. It requires runtime isolation for those functions without sacrificing performance. Traditional software container solutions, such as Docker, are not up to the task. They are too heavy and slow to handle real-time tasks.</p>
<p>WebAssembly provides a lightweight and high-performance software container. It is ideally suited as a runtime for YoMo’s data processing handler functions.</p>
<p>In this article, we will show you how to create a Rust function for Tensorflow-based image classification, compile it into WebAssembly, and then use YoMo to run it as a stream data handler. We use <a href="https://wasmedge.org/">WasmEdge</a> as our WebAssembly runtime because it offers the highest performance and flexibility compared with other WebAssembly runtimes. It is the only WebAssembly VM that reliably supports Tensorflow. YoMo manages WasmEdge VM instances and the contained WebAssembly bytecode apps through <a href="use_cases/frameworks/app/../../../sdk/go.html">WasmEdge’s Golang API</a>.</p>
<blockquote>
<p>Source code: <a href="https://github.com/yomorun/yomo-wasmedge-tensorflow">https://github.com/yomorun/yomo-wasmedge-tensorflow</a></p>
</blockquote>
<p>Checkout <a href="https://www.youtube.com/watch?v=E0ltsn6cLIU">the WasmEdge image classification function in action in YoMo</a></p>
<h2 id="prerequisite-1"><a class="header" href="#prerequisite-1">Prerequisite</a></h2>
<p>Obviously, you will need to have <a href="https://golang.org/doc/install">Golang installed</a>, but I will assume you already did.</p>
<blockquote>
<p>Golang version should be newer than 1.15 for our example to work.</p>
</blockquote>
<p>You also need to install the YoMo CLI application. It orchestrates and coordinates data streaming and handler function invocations.</p>
<pre><code class="language-bash">$ go install github.com/yomorun/cli/yomo@latest
$ yomo version
YoMo CLI version: v0.1.3
</code></pre>
<p>Next, please install the WasmEdge and its Tensorflow shared libraries. <a href="https://wasmedge.org/">WasmEdge</a> is a leading WebAssembly runtime hosted by the CNCF. We will use it to embed and run WebAssembly programs from YoMo.</p>
<pre><code class="language-bash">curl -sSf https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/utils/install.sh | bash
</code></pre>
<p>Finally, since our demo WebAssembly functions are written in Rust, you will also need a <a href="https://www.rust-lang.org/tools/install">Rust compiler</a>.</p>
<p>For the rest of the demo, fork and clone the <a href="https://github.com/yomorun/yomo-wasmedge-tensorflow">source code repository</a>.</p>
<pre><code class="language-bash">git clone https://github.com/yomorun/yomo-wasmedge-tensorflow.git
</code></pre>
<h2 id="the-image-classification-function"><a class="header" href="#the-image-classification-function">The image classification function</a></h2>
<p>The <a href="https://github.com/yomorun/yomo-wasmedge-tensorflow/tree/main/flow/rust_mobilenet_food">image classification function</a> to process the YoMo image stream is written in Rust. It utilizes the WasmEdge Tensorflow API to process an input image.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[wasmedge_bindgen]
pub fn infer(image_data: Vec&lt;u8&gt;) -&gt; Result&lt;Vec&lt;u8&gt;, String&gt; {
  let start = Instant::now();

  // Load the TFLite model and its meta data (the text label for each recognized object number)
  let model_data: &amp;[u8] = include_bytes!(&quot;lite-model_aiy_vision_classifier_food_V1_1.tflite&quot;);
  let labels = include_str!(&quot;aiy_food_V1_labelmap.txt&quot;);

  // Pre-process the image to a format that can be used by this model
  let flat_img = wasmedge_tensorflow_interface::load_jpg_image_to_rgb8(&amp;image_data[..], 192, 192);
  println!(&quot;RUST: Loaded image in ... {:?}&quot;, start.elapsed());

  // Run the TFLite model using the WasmEdge Tensorflow API
  let mut session = wasmedge_tensorflow_interface::Session::new(&amp;model_data, wasmedge_tensorflow_interface::ModelType::TensorFlowLite);
  session.add_input(&quot;input&quot;, &amp;flat_img, &amp;[1, 192, 192, 3])
         .run();
  let res_vec: Vec&lt;u8&gt; = session.get_output(&quot;MobilenetV1/Predictions/Softmax&quot;);

  // Find the object index in res_vec that has the greatest probability
  // Translate the probability into a confidence level
  // Translate the object index into a label from the model meta data food_name
  let mut i = 0;
  let mut max_index: i32 = -1;
  let mut max_value: u8 = 0;
  while i &lt; res_vec.len() {
    let cur = res_vec[i];
    if cur &gt; max_value {
      max_value = cur;
      max_index = i as i32;
    }
    i += 1;
  }
  println!(&quot;RUST: index {}, prob {}&quot;, max_index, max_value);

  let confidence: String;
  if max_value &gt; 200 {
    confidence = &quot;is very likely&quot;.to_string();
  } else if max_value &gt; 125 {
    confidence = &quot;is likely&quot;.to_string();
  } else {
    confidence = &quot;could be&quot;.to_string();
  }

  let ret_str: String;
  if max_value &gt; 50 {
    let mut label_lines = labels.lines();
    for _i in 0..max_index {
      label_lines.next();
    }
    let food_name = label_lines.next().unwrap().to_string();
    ret_str = format!(
      &quot;It {} a &lt;a href='https://www.google.com/search?q={}'&gt;{}&lt;/a&gt; in the picture&quot;,
      confidence, food_name, food_name
    );
  } else {
    ret_str = &quot;It does not appears to be a food item in the picture.&quot;.to_string();
  }

  println!(
    &quot;RUST: Finished post-processing in ... {:?}&quot;,
    start.elapsed()
  );
  return Ok(ret_str.as_bytes().to_vec());
}
<span class="boring">}
</span></code></pre></pre>
<p>You should add <code>wasm32-wasi</code> target to rust to compile this function into WebAssembly bytecode.</p>
<pre><code class="language-bash">rustup target add wasm32-wasi

cd flow/rust_mobilenet_food
cargo build --target wasm32-wasi --release
# The output WASM will be target/wasm32-wasi/release/rust_mobilenet_food_lib.wasm

# Copy the wasm bytecode file to the flow/ directory
cp target/wasm32-wasi/release/rust_mobilenet_food_lib.wasm ../
</code></pre>
<p>To release the best performance of WasmEdge, you should enable the AOT mode by compiling the <code>.wasm</code> file to the <code>.so</code>.</p>
<pre><code class="language-bash">wasmedgec rust_mobilenet_food_lib.wasm rust_mobilenet_food_lib.so
</code></pre>
<h2 id="integration-with-yomo"><a class="header" href="#integration-with-yomo">Integration with YoMo</a></h2>
<p>On the YoMo side, we use the WasmEdge Golang API to start and run WasmEdge VM for the image classification function. The <a href="https://github.com/yomorun/yomo-wasmedge-tensorflow/blob/main/flow/app.go">app.go</a> file in the source code project is as follows.</p>
<pre><code class="language-go">package main

import (
  &quot;crypto/sha1&quot;
  &quot;fmt&quot;
  &quot;log&quot;
  &quot;os&quot;
  &quot;sync/atomic&quot;

  &quot;github.com/second-state/WasmEdge-go/wasmedge&quot;
  bindgen &quot;github.com/second-state/wasmedge-bindgen/host/go&quot;
  &quot;github.com/yomorun/yomo&quot;
)

var (
  counter uint64
)

const ImageDataKey = 0x10

func main() {
  // Connect to Zipper service
  sfn := yomo.NewStreamFunction(&quot;image-recognition&quot;, yomo.WithZipperAddr(&quot;localhost:9900&quot;))
  defer sfn.Close()

  // set only monitoring data
  sfn.SetObserveDataID(ImageDataKey)

  // set handler
  sfn.SetHandler(Handler)

  // start
  err := sfn.Connect()
  if err != nil {
    log.Print(&quot;❌ Connect to zipper failure: &quot;, err)
    os.Exit(1)
  }

  select {}
}

// Handler process the data in the stream
func Handler(img []byte) (byte, []byte) {
  // Initialize WasmEdge's VM
  vmConf, vm := initVM()
  bg := bindgen.Instantiate(vm)
  defer bg.Release()
  defer vm.Release()
  defer vmConf.Release()

  // recognize the image
  res, err := bg.Execute(&quot;infer&quot;, img)
  if err == nil {
    fmt.Println(&quot;GO: Run bindgen -- infer:&quot;, string(res))
  } else {
    fmt.Println(&quot;GO: Run bindgen -- infer FAILED&quot;)
  }

  // print logs
  hash := genSha1(img)
  log.Printf(&quot;✅ received image-%d hash %v, img_size=%d \n&quot;, atomic.AddUint64(&amp;counter, 1), hash, len(img))

  return 0x11, nil
}

// genSha1 generate the hash value of the image
func genSha1(buf []byte) string {
  h := sha1.New()
  h.Write(buf)
  return fmt.Sprintf(&quot;%x&quot;, h.Sum(nil))
}

// initVM initialize WasmEdge's VM
func initVM() (*wasmedge.Configure, *wasmedge.VM) {
  wasmedge.SetLogErrorLevel()
  // Set Tensorflow not to print debug info
  os.Setenv(&quot;TF_CPP_MIN_LOG_LEVEL&quot;, &quot;3&quot;)
  os.Setenv(&quot;TF_CPP_MIN_VLOG_LEVEL&quot;, &quot;3&quot;)

  // Create configure
  vmConf := wasmedge.NewConfigure(wasmedge.WASI)

  // Create VM with configure
  vm := wasmedge.NewVMWithConfig(vmConf)

  // Init WASI
  var wasi = vm.GetImportObject(wasmedge.WASI)
  wasi.InitWasi(
    os.Args[1:],     // The args
    os.Environ(),    // The envs
    []string{&quot;.:.&quot;}, // The mapping directories
  )

  // Register WasmEdge-tensorflow and WasmEdge-image
  var tfobj = wasmedge.NewTensorflowImportObject()
  var tfliteobj = wasmedge.NewTensorflowLiteImportObject()
  vm.RegisterImport(tfobj)
  vm.RegisterImport(tfliteobj)
  var imgobj = wasmedge.NewImageImportObject()
  vm.RegisterImport(imgobj)

  // Instantiate wasm
  vm.LoadWasmFile(&quot;rust_mobilenet_food_lib.so&quot;)
  vm.Validate()

  return vmConf, vm
}
</code></pre>
<h2 id="in-action"><a class="header" href="#in-action">In action</a></h2>
<p>Finally, we can start YoMo and see the entire data processing pipeline in action. Start the YoMo CLI application from the project folder. The <a href="https://github.com/yomorun/yomo-wasmedge-tensorflow/blob/main/zipper/workflow.yaml">yaml file</a> defines port YoMo should listen on and the workflow handler to trigger for incoming data.  Note that the flow name <code>image-recognition</code> matches the name in the aforementioned data handler <a href="https://github.com/yomorun/yomo-wasmedge-tensorflow/blob/main/flow/app.go">app.go</a>.</p>
<pre><code class="language-bash">yomo serve -c ./zipper/workflow.yaml
</code></pre>
<p>Start the handler function by running the aforementioned <a href="https://github.com/yomorun/yomo-wasmedge-tensorflow/blob/main/flow/app.go">app.go</a> program.</p>
<pre><code class="language-bash">cd flow
go run --tags &quot;tensorflow image&quot; app.go
</code></pre>
<p><a href="https://github.com/yomorun/yomo-wasmedge-tensorflow/blob/main/source/main.go">Start a simulated data source</a> by sending a video to YoMo. The video is a series of image frames. The WasmEdge function in <a href="https://github.com/yomorun/yomo-wasmedge-tensorflow/blob/main/flow/app.go">app.go</a> will be invoked against every image frame in the video.</p>
<pre><code class="language-bash"># Download a video file
wget -P source 'https://github.com/yomorun/yomo-wasmedge-tensorflow/releases/download/v0.1.0/hot-dog.mp4'

# Stream the video to YoMo
go run ./source/main.go ./source/hot-dog.mp4
</code></pre>
<p>You can see the output from the WasmEdge handler function in the console. It prints the names of the objects detected in each image frame in the video.</p>
<h2 id="whats-next"><a class="header" href="#whats-next">What's next</a></h2>
<p>In this article, we have seen how to use the WasmEdge Tensorflow API and Golang SDK in YoMo framework to process an image stream in near real-time.</p>
<p>In collaboration with YoMo, we will soon deploy WasmEdge in production in smart factories for a variety of assembly line tasks. WasmEdge is the software runtime for edge computing!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="reactr"><a class="header" href="#reactr">Reactr</a></h1>
<p><a href="https://github.com/suborbital/reactr">Reactr</a> is a fast, performant function scheduling library written in Go. Reactr is designed to be flexible, with the ability to run embedded in your Go applications and first-class support for WebAssembly.
Taking advantage of Go's superior concurrency capabilities, Reactr can manage and execute hundreds of WebAssembly runtime instances all at once, making a great framework for server-side applications.</p>
<p>Reactr allows you to run WebAssembly functions in Go, so does the <a href="use_cases/frameworks/app/../../../sdk/go.html">WasmEdge Go SDK</a>.
The unique feature of Reactr is that it provides a rich set of host functions in Go, which support access to networks and databases etc. Reactr then provides Rust (and Swift / AssemblyScript) APIs to call those host functions from within the WebAssembly function.</p>
<p>In this article, we will show you how to use WasmEdge together with Reactr to take advantage of the best of both worlds. WasmEdge is the <a href="use_cases/frameworks/app/../../../features.html">fastest and most extensible WebAssembly runtime</a>.
It is also the fastest in <a href="https://github.com/suborbital/reactr/runs/4476074960?check_suite_focus=true">Reactr's official test suite</a>.
We will show you how to run Rust functions compiled to WebAssembly as well as JavaScript programs in WasmEdge and Reactr.</p>
<blockquote>
<p>WasmEdge provides <a href="use_cases/frameworks/app/../../../write_wasm/js.html">advanced support for JavaScript</a> including <a href="use_cases/frameworks/app/../../../write_wasm/js/rust.html">mixing Rust with JavaScript</a> for improved performance.</p>
</blockquote>
<ul>
<li><a href="use_cases/frameworks/app/reactr.html#hello-world">Hello world</a></li>
<li><a href="use_cases/frameworks/app/reactr.html#database-query">Database query</a></li>
<li><a href="use_cases/frameworks/app/reactr.html#embed-javascript-in-go">Embed JavaScript in Go</a></li>
</ul>
<h2 id="prerequisites-2"><a class="header" href="#prerequisites-2">Prerequisites</a></h2>
<p>You need have <a href="https://www.rust-lang.org/tools/install">Rust</a>, <a href="https://go.dev/doc/install">Go</a>, and <a href="use_cases/frameworks/app/../../../quick_start/install.html">WasmEdge</a> installed on your system.
The GCC compiler (installed via the <code>build-essential</code> package) is also needed for WasmEdge.</p>
<pre><code class="language-bash">sudo apt-get update
sudo apt-get -y upgrade
sudo apt install build-essential

curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh
source $HOME/.cargo/env
rustup target add wasm32-wasi

curl -OL https://golang.org/dl/go1.17.5.linux-amd64.tar.gz
sudo tar -C /usr/local -xvf go1.17.5.linux-amd64.tar.gz
export PATH=$PATH:/usr/local/go/bin

wget -qO- https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/utils/install.sh | bash
source $HOME/.wasmedge/env
</code></pre>
<h2 id="hello-world"><a class="header" href="#hello-world">Hello world</a></h2>
<p>A simple <code>hello world</code> example for Reactr is <a href="https://github.com/second-state/wasm-learning/tree/master/reactr/hello">available here</a>.</p>
<h3 id="hello-world-rust-function-compiled-to-webassembly"><a class="header" href="#hello-world-rust-function-compiled-to-webassembly">Hello world: Rust function compiled to WebAssembly</a></h3>
<p>Let's first create <a href="https://github.com/second-state/wasm-learning/blob/master/reactr/hello/hello-echo/src/lib.rs">a simple Rust function</a> to echo hello.
The Rust function <code>HelloEcho::run()</code> is as follows. It will be exposed to the Go host application through Reactr.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use suborbital::runnable::*;

struct HelloEcho{}

impl Runnable for HelloEcho {
  fn run(&amp;self, input: Vec&lt;u8&gt;) -&gt; Result&lt;Vec&lt;u8&gt;, RunErr&gt; {
    let in_string = String::from_utf8(input).unwrap();
    Ok(format!(&quot;hello {}&quot;, in_string).as_bytes().to_vec())
  }
}
<span class="boring">}
</span></code></pre></pre>
<p>Let's build the Rust function into a WebAssembly bytecode file.</p>
<pre><code class="language-bash">cd hello-echo
cargo build --target wasm32-wasi --release
cp target/wasm32-wasi/release/hello_echo.wasm ..
cd ..
</code></pre>
<h3 id="hello-world-go-host-application"><a class="header" href="#hello-world-go-host-application">Hello world: Go host application</a></h3>
<p>Next, lets look into the <a href="https://github.com/second-state/wasm-learning/blob/master/reactr/hello/main.go">Go host app</a> that executes the WebAssembly functions.
The <code>runBundle()</code> function executes the <code>run()</code> function in the <code>Runnable</code> struct once.</p>
<pre><code class="language-go">func runBundle() {
  r := rt.New()
  doWasm := r.Register(&quot;hello-echo&quot;, rwasm.NewRunner(&quot;./hello_echo.wasm&quot;))

  res, err := doWasm([]byte(&quot;wasmWorker!&quot;)).Then()
  if err != nil {
    fmt.Println(err)
    return
  }

  fmt.Println(string(res.([]byte)))
}
</code></pre>
<p>The <code>runGroup()</code> function executes the Rust-compiled WebAssembly <code>run()</code> function multiple times asynchronously in a group, and receives the results as they come in.</p>
<pre><code class="language-go">func runGroup() {
  r := rt.New()

  doWasm := r.Register(&quot;hello-echo&quot;, rwasm.NewRunner(&quot;./hello_echo.wasm&quot;))

  grp := rt.NewGroup()
  for i := 0; i &lt; 100000; i++ {
    grp.Add(doWasm([]byte(fmt.Sprintf(&quot;world %d&quot;, i))))
  }

  if err := grp.Wait(); err != nil {
    fmt.Println(err)
  }
}
</code></pre>
<p>Finally, let's run the Go host application and see the results printed to the console.</p>
<blockquote>
<p>You must use the <code>-tags wasmedge</code> flag to take advantage of the performance and extended WebAssembly APIs provided by WasmEdge.</p>
</blockquote>
<pre><code class="language-bash">go mod tidy
go run -tags wasmedge main.go
</code></pre>
<h2 id="database-query"><a class="header" href="#database-query">Database query</a></h2>
<p>In <a href="https://github.com/second-state/wasm-learning/tree/master/reactr/db">this example</a>, we will demonstrate how to use Reactr host functions and APIs to query a PostgreSQL database from your WebAssembly function.</p>
<h3 id="database-query-install-and-set-up-a-postgresql-database"><a class="header" href="#database-query-install-and-set-up-a-postgresql-database">Database query: Install and set up a PostgreSQL database</a></h3>
<p>We will start a PostgreSQL instance through Docker.</p>
<pre><code class="language-bash">docker pull postgres
docker run --name reactr-postgres -p 5432:5432 -e POSTGRES_PASSWORD=12345 -d postgres
</code></pre>
<p>Next, let's create a database and populate it with some sample data.</p>
<pre><code class="language-bash">$ docker run -it --rm --network host postgres psql -h 127.0.0.1 -U postgres
postgres=# CREATE DATABASE reactr;
postgres=# \c reactr;

# Create a table:
postgres=# CREATE TABLE users (
    uuid        varchar(100) CONSTRAINT firstkey PRIMARY KEY,
    email       varchar(50) NOT NULL,
    created_at  date,
    state       char(1),
    identifier  integer
);
</code></pre>
<p>Leave this running and start another terminal window to interact with this PostgreSQL server.</p>
<h3 id="database-query-rust-function-compiled-to-webassembly"><a class="header" href="#database-query-rust-function-compiled-to-webassembly">Database query: Rust function compiled to WebAssembly</a></h3>
<p>Let's create <a href="https://github.com/second-state/wasm-learning/blob/master/reactr/db/rs-db/src/lib.rs">a Rust function</a> to access the PostgreSQL database.
The Rust function <code>RsDbtest::run()</code> is as follows. It will be exposed to the Go host application through Reactr. It uses named queries such as <code>PGInsertUser</code> and <code>PGSelectUserWithUUID</code> to operate the database. Those queries are defined in the Go host application, and we will see them later.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use suborbital::runnable::*;
use suborbital::db;
use suborbital::util;
use suborbital::db::query;
use suborbital::log;
use uuid::Uuid;

struct RsDbtest{}

impl Runnable for RsDbtest {
  fn run(&amp;self, _: Vec&lt;u8&gt;) -&gt; Result&lt;Vec&lt;u8&gt;, RunErr&gt; {
    let uuid = Uuid::new_v4().to_string();

    let mut args: Vec&lt;query::QueryArg&gt; = Vec::new();
    args.push(query::QueryArg::new(&quot;uuid&quot;, uuid.as_str()));
    args.push(query::QueryArg::new(&quot;email&quot;, &quot;connor@suborbital.dev&quot;));

    match db::insert(&quot;PGInsertUser&quot;, args) {
      Ok(_) =&gt; log::info(&quot;insert successful&quot;),
      Err(e) =&gt; {
        return Err(RunErr::new(500, e.message.as_str()))
      }
    };

    let mut args2: Vec&lt;query::QueryArg&gt; = Vec::new();
    args2.push(query::QueryArg::new(&quot;uuid&quot;, uuid.as_str()));

    match db::update(&quot;PGUpdateUserWithUUID&quot;, args2.clone()) {
      Ok(rows) =&gt; log::info(format!(&quot;update: {}&quot;, util::to_string(rows).as_str()).as_str()),
      Err(e) =&gt; {
        return Err(RunErr::new(500, e.message.as_str()))
      }
    }

    match db::select(&quot;PGSelectUserWithUUID&quot;, args2.clone()) {
      Ok(result) =&gt; log::info(format!(&quot;select: {}&quot;, util::to_string(result).as_str()).as_str()),
      Err(e) =&gt; {
        return Err(RunErr::new(500, e.message.as_str()))
      }
    }

    match db::delete(&quot;PGDeleteUserWithUUID&quot;, args2.clone()) {
      Ok(rows) =&gt; log::info(format!(&quot;delete: {}&quot;, util::to_string(rows).as_str()).as_str()),
      Err(e) =&gt; {
        return Err(RunErr::new(500, e.message.as_str()))
      }
    }

    ... ...
  }
}
<span class="boring">}
</span></code></pre></pre>
<p>Let's build the Rust function into a WebAssembly bytecode file.</p>
<pre><code class="language-bash">cd rs-db
cargo build --target wasm32-wasi --release
cp target/wasm32-wasi/release/rs_db.wasm ..
cd ..
</code></pre>
<h3 id="database-query-go-host-application"><a class="header" href="#database-query-go-host-application">Database query: Go host application</a></h3>
<p>The <a href="https://github.com/second-state/wasm-learning/blob/master/reactr/db/main.go">Go host app</a> first defines the SQL queries and gives each of them a name.
We will then pass those queries to the Reactr runtime as a configuration.</p>
<pre><code class="language-go">func main() {
  dbConnString, exists := os.LookupEnv(&quot;REACTR_DB_CONN_STRING&quot;)
  if !exists {
    fmt.Println(&quot;skipping as conn string env var not set&quot;)
    return
  }

  q1 := rcap.Query{
    Type:     rcap.QueryTypeInsert,
    Name:     &quot;PGInsertUser&quot;,
    VarCount: 2,
    Query: `
    INSERT INTO users (uuid, email, created_at, state, identifier)
    VALUES ($1, $2, NOW(), 'A', 12345)`,
  }

  q2 := rcap.Query{
    Type:     rcap.QueryTypeSelect,
    Name:     &quot;PGSelectUserWithUUID&quot;,
    VarCount: 1,
    Query: `
    SELECT * FROM users
    WHERE uuid = $1`,
  }

  q3 := rcap.Query{
    Type:     rcap.QueryTypeUpdate,
    Name:     &quot;PGUpdateUserWithUUID&quot;,
    VarCount: 1,
    Query: `
    UPDATE users SET state='B' WHERE uuid = $1`,
  }

  q4 := rcap.Query{
    Type:     rcap.QueryTypeDelete,
    Name:     &quot;PGDeleteUserWithUUID&quot;,
    VarCount: 1,
    Query: `
    DELETE FROM users WHERE uuid = $1`,
  }

  config := rcap.DefaultConfigWithDB(vlog.Default(), rcap.DBTypePostgres, dbConnString, []rcap.Query{q1, q2, q3, q4})

  r, err := rt.NewWithConfig(config)
  if err != nil {
    fmt.Println(err)
    return
  }

  ... ...
}
</code></pre>
<p>Then, we can run the WebAssembly function from Reactr.</p>
<pre><code class="language-go">func main() {
  ... ...

  doWasm := r.Register(&quot;rs-db&quot;, rwasm.NewRunner(&quot;./rs_db.wasm&quot;))

  res, err := doWasm(nil).Then()
  if err != nil {
    fmt.Println(err)
    return
  }

  fmt.Println(string(res.([]byte)))
}
</code></pre>
<p>Finally, let's run the Go host application and see the results printed to the console.</p>
<blockquote>
<p>You must use the <code>-tags wasmedge</code> flag to take advantage of the performance and extended WebAssembly APIs provided by WasmEdge.</p>
</blockquote>
<pre><code class="language-bash">export REACTR_DB_CONN_STRING='postgresql://postgres:12345@127.0.0.1:5432/reactr'
go mod tidy
go run -tags wasmedge main.go
</code></pre>
<h2 id="embed-javascript-in-go"><a class="header" href="#embed-javascript-in-go">Embed JavaScript in Go</a></h2>
<p>As we mentioned, a key feature of the WasmEdge Runtime is its advanced <a href="use_cases/frameworks/app/../../../write_wasm/js.html">JavaScript support</a>, which allows JavaScript programs to run in lightweight, high-performance, safe, multi-language, and <a href="use_cases/frameworks/app/../../kubernetes.html">Kubernetes-managed WasmEdge containers</a>.
A simple example of embedded JavaScript function in Reactr is <a href="https://github.com/second-state/wasm-learning/tree/master/reactr/quickjs">available here</a>.</p>
<h3 id="javascript-example"><a class="header" href="#javascript-example">JavaScript example</a></h3>
<p>The <a href="https://github.com/second-state/wasm-learning/tree/master/reactr/quickjs/hello.js">JavaScript example function</a> is very simple. It just returns a string value.</p>
<pre><code class="language-javascript">let h = 'hello';
let w = 'wasmedge';
`${h} ${w}`;
</code></pre>
<h3 id="javascript-example-go-host-application"><a class="header" href="#javascript-example-go-host-application">JavaScript example: Go host application</a></h3>
<p>The <a href="https://github.com/second-state/wasm-learning/tree/master/reactr/quickjs/main.go">Go host app</a> uses the Reactr API to run WasmEdge's standard JavaScript interpreter <a href="https://github.com/second-state/wasm-learning/blob/master/reactr/quickjs/rs_embed_js.wasm">rs_embed_js.wasm</a>. You can build your own version of JavaScript interpreter by modifying <a href="https://github.com/second-state/wasm-learning/tree/master/reactr/quickjs/rs-embed-js">this Rust project</a>.</p>
<blockquote>
<p>Learn more about how to embed <a href="https://github.com/second-state/wasmedge-quickjs/tree/main/examples/embed_js">JavaScript code in Rust</a>, and how to <a href="use_cases/frameworks/app/../../../write_wasm/js/rust.html">use Rust to implement JavaScript APIs</a> in WasmEdge.</p>
</blockquote>
<p>The Go host application just need to start the job for <code>rs_embed_js.wasm</code> and pass the JavaScript content to it. The Go application can then capture and print the return value from JavaScript.</p>
<pre><code class="language-go">func main() {
  r := rt.New()
  doWasm := r.Register(&quot;hello-quickjs&quot;, rwasm.NewRunner(&quot;./rs_embed_js.wasm&quot;))

  code, err := ioutil.ReadFile(os.Args[1])
  if err != nil {
    fmt.Print(err)
  }
  res, err := doWasm(code).Then()
  if err != nil {
    fmt.Println(err)
    return
  }

  fmt.Println(string(res.([]byte)))
}
</code></pre>
<p>Run the Go host application as follows.</p>
<pre><code class="language-bash">$ cd quickjs
$ go mod tidy
$ go run -tags wasmedge main.go hello.js
String(JsString(hello wasmedge))
</code></pre>
<p>The printed result shows the type information of the string in Rust and Go APIs. You can strip out this information by changing the Rust or Go applications.</p>
<h3 id="javascript-example-feature-examples"><a class="header" href="#javascript-example-feature-examples">JavaScript example: Feature examples</a></h3>
<p>WasmEdge supports many advanced JavaScript features. For the next step, you could try our <a href="https://github.com/second-state/wasmedge-quickjs/tree/main/example_js/react_ssr">React SSR example</a> to generate an HTML UI from a Reactr function!
You can just build the <code>dist/main.js</code> from the React SSR example, and copy it over to this example folder to see it in action!</p>
<pre><code class="language-bash">$ cd quickjs
# copy over the dist/main.js file from the react ssr example
$ go mod tidy
$ go run -tags wasmedge main.go main.js
&lt;div data-reactroot=&quot;&quot;&gt;&lt;div&gt;This is home&lt;/div&gt;&lt;div&gt;&lt;div&gt;This is page&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;
UnDefined
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="serverless-platforms"><a class="header" href="#serverless-platforms">Serverless platforms</a></h1>
<p>Our vision for the future is to run WebAssembly as an alternative lightweight runtime side-by-side with Docker and microVMs in cloud native infrastructure. WebAssembly offers much higher performance and consumes much less resources than Docker-like containers or microVMs. However, the public cloud only supports running WebAssembly inside a microVM. Nonetheless, running WebAssembly functions inside a microVM still offers many advantages over running containerized NaCl programs.</p>
<p>Running WebAssembly functions inside Docker-like containers offer advantages over running NaCl programs directly in Docker.</p>
<p>For starters, WebAssembly provides fine-grained runtime isolation for individual functions. A microservice could have multiple functions and support services running inside a Docker-like container. WebAssembly can make the microservice more secure and more stable.</p>
<p>Second, the WebAssembly bytecode is portable. Developers only need to build it once and do not need to worry about changes or updates to the underlying Vercel serverless container (OS and hardware). It also allows developers to reuse the same WebAssembly functions in other cloud environments.</p>
<p>Third, WebAssembly apps are easy to deploy and manage. They have much less platform dependencies and complexities compared with NaCl dynamic libraries and executables.</p>
<p>Finally, the <a href="https://www.secondstate.io/articles/wasi-tensorflow/">WasmEdge Tensorflow API</a> provides the most ergonomic way to execute Tensorflow models in the Rust programming language. WasmEdge installs the correct combination of Tensorflow dependency libraries, and provides a unified API for developers.</p>
<p>In this section, we will show you how to run WebAssembly serverless functions in public clouds. Each platform has its own code template and contains two examples in Rust, one is the normal image processing, The other one is TensorFlow inference using the WasmEdge TensorFlow SDK.</p>
<ul>
<li><a href="use_cases/frameworks/serverless/vercel.html">Vercel</a> discuss how to leverage WasmEdge to accelerate the Jamstack application deployed on Vercel.</li>
<li><a href="use_cases/frameworks/serverless/netlify.html">Netlify</a> discuss how to leverage WasmEdge to accelerate the Jamstack application deployed on Netlify.</li>
<li><a href="use_cases/frameworks/serverless/aws.html">AWS Lambda</a> discuss how to leverage WasmEdge to accelerate the serverless functions deployed on AWS Lambda.</li>
<li><a href="use_cases/frameworks/serverless/tencent.html">Tencent</a> discuss how to leverage WasmEdge to accelerate the serverless functions deployed on Tencent cloud.</li>
</ul>
<blockquote>
<p>If you would like to add more WasmEdge examples on public cloud platform,like Google Cloud Functions, feel free to create a PR for WasmEdge and let the community know what you did.</p>
</blockquote>
<p><img src="use_cases/frameworks/serverless-wasmedge.png" alt="serverless-wasmedge.png" /></p>
<p>Running WasmEdge from Docker containers deployed on public cloud is an easy way to add high-performance functions to web applications. Going forward an even better approach is to use <a href="https://www.computer.org/csdl/magazine/so/5555/01/09214403/1nHNGfu2Ypi">WasmEdge as the container itself</a>. There will be no Docker and no Node.js to bootstrap WasmEdge. This way, we can reach much higher efficiency for running serverless functions.</p>
<ul>
<li><a href="use_cases/frameworks/serverless/secondstate.html">Second State Functions</a> will discuss how to use WasmEdge ad the container itself, since Second State Functions is a serverless platform with pure WebAssembly/WasmEdge.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rust-and-webassembly-serverless-functions-in-vercel"><a class="header" href="#rust-and-webassembly-serverless-functions-in-vercel">Rust and WebAssembly Serverless functions in Vercel</a></h1>
<p>In this article, we will show you two serverless functions in Rust and WasmEdge deployed on Vercel. One is the image processing function, the other one is the TensorFlow inference function.</p>
<blockquote>
<p>For more insights on why WasmEdge on Vercel, please refer to the article <a href="https://www.secondstate.io/articles/vercel-wasmedge-webassembly-rust/">Rust and WebAssembly Serverless Functions in Vercel</a>.</p>
</blockquote>
<h2 id="prerequisite-2"><a class="header" href="#prerequisite-2">Prerequisite</a></h2>
<p>Since our demo WebAssembly functions are written in Rust, you will need a <a href="https://www.rust-lang.org/tools/install">Rust compiler</a>. Make sure that you install the <code>wasm32-wasi</code> compiler target as follows, in order to generate WebAssembly bytecode.</p>
<pre><code class="language-bash">rustup target add wasm32-wasi
</code></pre>
<p>The demo application front end is written in <a href="https://nextjs.org/">Next.js</a>, and deployed on Vercel. We will assume that you already have the basic knowledge of how to work with Vercel.</p>
<h2 id="example-1-image-processing"><a class="header" href="#example-1-image-processing">Example 1: Image processing</a></h2>
<p>Our first demo application allows users to upload an image and then invoke a serverless function to turn it into black and white. A <a href="https://vercel-wasm-runtime.vercel.app/">live demo</a> deployed on Vercel is available.</p>
<p>Fork the <a href="https://github.com/second-state/vercel-wasm-runtime">demo application’s GitHub repo</a> to get started. To deploy the application on Vercel, just <a href="https://vercel.com/docs/git#deploying-a-git-repository">import the Github repo</a> from <a href="https://vercel.com/docs/git/vercel-for-github">Vercel for Github</a> web page.</p>
<p>This repo is a standard Next.js application for the Vercel platform. The backend serverless function is in the <a href="https://github.com/second-state/vercel-wasm-runtime/tree/main/api/functions/image-grayscale"><code>api/functions/image_grayscale</code></a> folder. The <a href="https://github.com/second-state/vercel-wasm-runtime/blob/main/api/functions/image-grayscale/src/main.rs"><code>src/main.rs</code></a> file contains the Rust program’s source code. The Rust program reads image data from the <code>STDIN</code>, and then outputs the black-white image to the <code>STDOUT</code>.</p>
<pre><pre class="playground"><code class="language-rust">use hex;
use std::io::{self, Read};
use image::{ImageOutputFormat, ImageFormat};

fn main() {
  let mut buf = Vec::new();
  io::stdin().read_to_end(&amp;mut buf).unwrap();

  let image_format_detected: ImageFormat = image::guess_format(&amp;buf).unwrap();
  let img = image::load_from_memory(&amp;buf).unwrap();
  let filtered = img.grayscale();
  let mut buf = vec![];
  match image_format_detected {
    ImageFormat::Gif =&gt; {
      filtered.write_to(&amp;mut buf, ImageOutputFormat::Gif).unwrap();
    },
    _ =&gt; {
      filtered.write_to(&amp;mut buf, ImageOutputFormat::Png).unwrap();
    },
  };
  io::stdout().write_all(&amp;buf).unwrap();
  io::stdout().flush().unwrap();
}
</code></pre></pre>
<p>You can use Rust’s <code>cargo</code> tool to build the Rust program into WebAssembly bytecode or native code.</p>
<pre><code class="language-bash">cd api/functions/image-grayscale/
cargo build --release --target wasm32-wasi 
</code></pre>
<p>Copy the build artifacts to the <code>api</code> folder.</p>
<pre><code class="language-bash">cp target/wasm32-wasi/release/grayscale.wasm ../../
</code></pre>
<blockquote>
<p>Vercel runs <a href="https://github.com/second-state/vercel-wasm-runtime/blob/main/api/pre.sh"><code>api/pre.sh</code></a> upon setting up the serverless environment. It installs the WasmEdge runtime, and then compiles each WebAssembly bytecode program into a native <code>so</code> library for faster execution.</p>
</blockquote>
<p>The <a href="https://github.com/second-state/vercel-wasm-runtime/blob/main/api/hello.js"><code>api/hello.js</code></a> file conforms Vercel serverless specification. It loads the WasmEdge runtime, starts the compiled WebAssembly program in WasmEdge, and passes the uploaded image data via <code>STDIN</code>. Notice <a href="https://github.com/second-state/vercel-wasm-runtime/blob/main/api/hello.js"><code>api/hello.js</code></a> runs the compiled <code>grayscale.so</code> file generated by <a href="https://github.com/second-state/vercel-wasm-runtime/blob/main/api/pre.sh"><code>api/pre.sh</code></a> for better performance.</p>
<pre><code class="language-javascript">const fs = require('fs');
const { spawn } = require('child_process');
const path = require('path');

module.exports = (req, res) =&gt; {
  const wasmedge = spawn(
      path.join(__dirname, 'wasmedge'), 
      [path.join(__dirname, 'grayscale.so')]);

  let d = [];
  wasmedge.stdout.on('data', (data) =&gt; {
    d.push(data);
  });

  wasmedge.on('close', (code) =&gt; {
    let buf = Buffer.concat(d);

    res.setHeader('Content-Type', req.headers['image-type']);
    res.send(buf);
  });

  wasmedge.stdin.write(req.body);
  wasmedge.stdin.end('');
}
</code></pre>
<p>That's it. <a href="https://vercel.com/docs/git#deploying-a-git-repository">Deploy the repo to Vercel</a> and you now have a Vercel Jamstack app with a high-performance Rust and WebAssembly based serverless backend.</p>
<h2 id="example-2-ai-inference"><a class="header" href="#example-2-ai-inference">Example 2: AI inference</a></h2>
<p>The <a href="https://vercel-wasm-runtime-cozpr5z84-wangshishuo1.vercel.app/">second demo</a> application allows users to upload an image and then invoke a serverless function to classify the main subject on the image.</p>
<p>It is in <a href="https://github.com/second-state/vercel-wasm-runtime">the same GitHub repo</a> as the previous example but in the <code>tensorflow</code> branch. Note: when you <a href="https://vercel.com/docs/git#deploying-a-git-repository">import this GitHub repo</a> on the Vercel website, it will create a <a href="https://vercel.com/docs/platform/deployments#preview">preview URL</a> for each branch. The <code>tensorflow</code> branch would have its own deployment URL.</p>
<p>The backend serverless function for image classification is in the <a href="https://github.com/second-state/vercel-wasm-runtime/tree/tensorflow/api/functions/image-classification"><code>api/functions/image-classification</code></a> folder in the <code>tensorflow</code> branch.  The <a href="https://github.com/second-state/vercel-wasm-runtime/blob/tensorflow/api/functions/image-classification/src/main.rs"><code>src/main.rs</code></a> file contains the Rust program’s source code. The Rust program reads image data from the <code>STDIN</code>, and then outputs the text output to the <code>STDOUT</code>. It utilizes the WasmEdge Tensorflow API to run the AI inference.</p>
<pre><pre class="playground"><code class="language-rust">pub fn main() {
  // Step 1: Load the TFLite model
  let model_data: &amp;[u8] = include_bytes!(&quot;models/mobilenet_v1_1.0_224/mobilenet_v1_1.0_224_quant.tflite&quot;);
  let labels = include_str!(&quot;models/mobilenet_v1_1.0_224/labels_mobilenet_quant_v1_224.txt&quot;);

  // Step 2: Read image from STDIN
  let mut buf = Vec::new();
  io::stdin().read_to_end(&amp;mut buf).unwrap();

  // Step 3: Resize the input image for the tensorflow model
  let flat_img = wasmedge_tensorflow_interface::load_jpg_image_to_rgb8(&amp;buf, 224, 224);

  // Step 4: AI inference
  let mut session = wasmedge_tensorflow_interface::Session::new(&amp;model_data, wasmedge_tensorflow_interface::ModelType::TensorFlowLite);
  session.add_input(&quot;input&quot;, &amp;flat_img, &amp;[1, 224, 224, 3])
         .run();
  let res_vec: Vec&lt;u8&gt; = session.get_output(&quot;MobilenetV1/Predictions/Reshape_1&quot;);

  // Step 5: Find the food label that responds to the highest probability in res_vec
  // ... ...
  let mut label_lines = labels.lines();
  for _i in 0..max_index {
    label_lines.next();
  }

  // Step 6: Generate the output text
  let class_name = label_lines.next().unwrap().to_string();
  if max_value &gt; 50 {
    println!(&quot;It {} a &lt;a href='https://www.google.com/search?q={}'&gt;{}&lt;/a&gt; in the picture&quot;, confidence.to_string(), class_name, class_name);
  } else {
    println!(&quot;It does not appears to be any food item in the picture.&quot;);
  }
}
</code></pre></pre>
<p>You can use the <code>cargo</code> tool to build the Rust program into WebAssembly bytecode or native code.</p>
<pre><code class="language-bash">cd api/functions/image-classification/
cargo build --release --target wasm32-wasi
</code></pre>
<p>Copy the build artifacts to the <code>api</code> folder.</p>
<pre><code class="language-bash">cp target/wasm32-wasi/release/classify.wasm ../../
</code></pre>
<p>Again, the <a href="https://github.com/second-state/vercel-wasm-runtime/blob/tensorflow/api/pre.sh"><code>api/pre.sh</code></a> script installs WasmEdge runtime and its Tensorflow dependencies in this application. It also compiles the <code>classify.wasm</code> bytecode program to the <code>classify.so</code> native shared library at the time of deployment.</p>
<p>The <a href="https://github.com/second-state/vercel-wasm-runtime/blob/tensorflow/api/hello.js"><code>api/hello.js</code></a> file conforms Vercel serverless specification. It loads the WasmEdge runtime, starts the compiled WebAssembly program in WasmEdge, and passes the uploaded image data via <code>STDIN</code>. Notice <a href="https://github.com/second-state/vercel-wasm-runtime/blob/tensorflow/api/hello.js"><code>api/hello.js</code></a> runs the compiled <code>classify.so</code> file generated by <a href="https://github.com/second-state/vercel-wasm-runtime/blob/tensorflow/api/pre.sh"><code>api/pre.sh</code></a> for better performance.</p>
<pre><code class="language-javascript">const fs = require('fs');
const { spawn } = require('child_process');
const path = require('path');

module.exports = (req, res) =&gt; {
  const wasmedge = spawn(
    path.join(__dirname, 'wasmedge-tensorflow-lite'),
    [path.join(__dirname, 'classify.so')],
    {env: {'LD_LIBRARY_PATH': __dirname}}
  );

  let d = [];
  wasmedge.stdout.on('data', (data) =&gt; {
    d.push(data);
  });

  wasmedge.on('close', (code) =&gt; {
    res.setHeader('Content-Type', `text/plain`);
    res.send(d.join(''));
  });

  wasmedge.stdin.write(req.body);
  wasmedge.stdin.end('');
}
</code></pre>
<p>You can now <a href="https://vercel.com/docs/git#deploying-a-git-repository">deploy your forked repo to Vercel</a> and have a web app for subject classification.</p>
<p>Next, it's your turn to use <a href="https://github.com/second-state/vercel-wasm-runtime">the vercel-wasm-runtime repo</a> as a template to develop your own Rust serverless functions in Vercel. Looking forward to your great work.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="webassembly-serverless-functions-in-netlify"><a class="header" href="#webassembly-serverless-functions-in-netlify">WebAssembly Serverless Functions in Netlify</a></h1>
<p>In this article we will show you two serverless functions in Rust and WasmEdge deployed on Netlify. One is the image processing function, the other one is the TensorFlow inference function.</p>
<blockquote>
<p>For more insights on why WasmEdge on Netlify, please refer to the article <a href="https://www.secondstate.io/articles/netlify-wasmedge-webassembly-rust-serverless/">WebAssembly Serverless Functions in Netlify</a>.</p>
</blockquote>
<h2 id="prerequisite-3"><a class="header" href="#prerequisite-3">Prerequisite</a></h2>
<p>Since our demo WebAssembly functions are written in Rust, you will need a <a href="https://www.rust-lang.org/tools/install">Rust compiler</a>. Make sure that you install the <code>wasm32-wasi</code> compiler target as follows, in order to generate WebAssembly bytecode.</p>
<pre><code class="language-bash">rustup target add wasm32-wasi
</code></pre>
<p>The demo application front end is written in <a href="https://nextjs.org/">Next.js</a>, and deployed on Netlify. We will assume that you already have the basic knowledge of how to work with Next.js and Netlify.</p>
<h2 id="example-1-image-processing-1"><a class="header" href="#example-1-image-processing-1">Example 1: Image processing</a></h2>
<p>Our first demo application allows users to upload an image and then invoke a serverless function to turn it into black and white. A <a href="https://60fe22f9ff623f0007656040--reverent-hodgkin-dc1f51.netlify.app/">live demo</a> deployed on Netlify is available.</p>
<p>Fork the <a href="https://github.com/second-state/netlify-wasm-runtime">demo application’s GitHub repo</a> to get started. To deploy the application on Netlify, just <a href="https://www.netlify.com/blog/2016/09/29/a-step-by-step-guide-deploying-on-netlify/">add your github repo to Netlify</a>.</p>
<p>This repo is a standard Next.js application for the Netlify platform. The backend serverless function is in the <a href="https://github.com/second-state/netlify-wasm-runtime/tree/main/api/functions/image-grayscale"><code>api/functions/image_grayscale</code></a> folder. The <a href="https://github.com/second-state/netlify-wasm-runtime/blob/main/api/functions/image-grayscale/src/main.rs"><code>src/main.rs</code></a> file contains the Rust program’s source code. The Rust program reads image data from the <code>STDIN</code>, and then outputs the black-white image to the <code>STDOUT</code>.</p>
<pre><pre class="playground"><code class="language-rust">use hex;
use std::io::{self, Read};
use image::{ImageOutputFormat, ImageFormat};

fn main() {
  let mut buf = Vec::new();
  io::stdin().read_to_end(&amp;mut buf).unwrap();

  let image_format_detected: ImageFormat = image::guess_format(&amp;buf).unwrap();
  let img = image::load_from_memory(&amp;buf).unwrap();
  let filtered = img.grayscale();
  let mut buf = vec![];
  match image_format_detected {
    ImageFormat::Gif =&gt; {
      filtered.write_to(&amp;mut buf, ImageOutputFormat::Gif).unwrap();
    },
    _ =&gt; {
      filtered.write_to(&amp;mut buf, ImageOutputFormat::Png).unwrap();
    },
  };
  io::stdout().write_all(&amp;buf).unwrap();
  io::stdout().flush().unwrap();
}
</code></pre></pre>
<p>You can use Rust’s <code>cargo</code> tool to build the Rust program into WebAssembly bytecode or native code.</p>
<pre><code class="language-bash">cd api/functions/image-grayscale/
cargo build --release --target wasm32-wasi 
</code></pre>
<p>Copy the build artifacts to the <code>api</code> folder.</p>
<pre><code class="language-bash">cp target/wasm32-wasi/release/grayscale.wasm ../../
</code></pre>
<blockquote>
<p>The Netlify function runs <a href="https://github.com/second-state/netlify-wasm-runtime/blob/main/api/pre.sh"><code>api/pre.sh</code></a> upon setting up the serverless environment. It installs the WasmEdge runtime, and then compiles each WebAssembly bytecode program into a native <code>so</code> library for faster execution.</p>
</blockquote>
<p>The <a href="https://github.com/second-state/netlify-wasm-runtime/blob/main/api/hello.js"><code>api/hello.js</code></a> script loads the WasmEdge runtime, starts the compiled WebAssembly program in WasmEdge, and passes the uploaded image data via <code>STDIN</code>. Notice <a href="https://github.com/second-state/netlify-wasm-runtime/blob/main/api/hello.js"><code>api/hello.js</code></a> runs the compiled <code>grayscale.so</code> file generated by <a href="https://github.com/second-state/netlify-wasm-runtime/blob/main/api/pre.sh"><code>api/pre.sh</code></a> for better performance.</p>
<pre><code class="language-javascript">const fs = require('fs');
const { spawn } = require('child_process');
const path = require('path');

module.exports = (req, res) =&gt; {
  const wasmedge = spawn(
      path.join(__dirname, 'wasmedge'), 
      [path.join(__dirname, 'grayscale.so')]);

  let d = [];
  wasmedge.stdout.on('data', (data) =&gt; {
    d.push(data);
  });

  wasmedge.on('close', (code) =&gt; {
    let buf = Buffer.concat(d);

    res.setHeader('Content-Type', req.headers['image-type']);
    res.send(buf);
  });

  wasmedge.stdin.write(req.body);
  wasmedge.stdin.end('');
}
</code></pre>
<p>That's it. <a href="https://www.netlify.com/blog/2016/09/29/a-step-by-step-guide-deploying-on-netlify/">Deploy the repo to Netlify</a> and you now have a Netlify Jamstack app with a high-performance Rust and WebAssembly based serverless backend.</p>
<h2 id="example-2-ai-inference-1"><a class="header" href="#example-2-ai-inference-1">Example 2: AI inference</a></h2>
<p>The <a href="https://60ff7e2d10fe590008db70a9--reverent-hodgkin-dc1f51.netlify.app/">second demo</a> application allows users to upload an image and then invoke a serverless function to classify the main subject on the image.</p>
<p>It is in <a href="https://github.com/second-state/netlify-wasm-runtime/tree/tensorflow">the same GitHub repo</a> as the previous example but in the <code>tensorflow</code> branch. The backend serverless function for image classification is in the <a href="https://github.com/second-state/netlify-wasm-runtime/tree/tensorflow/api/functions/image-classification"><code>api/functions/image-classification</code></a> folder in the <code>tensorflow</code> branch.  The <a href="https://github.com/second-state/netlify-wasm-runtime/blob/tensorflow/api/functions/image-classification/src/main.rs"><code>src/main.rs</code></a> file contains the Rust program’s source code. The Rust program reads image data from the <code>STDIN</code>, and then outputs the text output to the <code>STDOUT</code>. It utilizes the WasmEdge Tensorflow API to run the AI inference.</p>
<pre><pre class="playground"><code class="language-rust">pub fn main() {
  // Step 1: Load the TFLite model
  let model_data: &amp;[u8] = include_bytes!(&quot;models/mobilenet_v1_1.0_224/mobilenet_v1_1.0_224_quant.tflite&quot;);
  let labels = include_str!(&quot;models/mobilenet_v1_1.0_224/labels_mobilenet_quant_v1_224.txt&quot;);

  // Step 2: Read image from STDIN
  let mut buf = Vec::new();
  io::stdin().read_to_end(&amp;mut buf).unwrap();

  // Step 3: Resize the input image for the tensorflow model
  let flat_img = wasmedge_tensorflow_interface::load_jpg_image_to_rgb8(&amp;buf, 224, 224);

  // Step 4: AI inference
  let mut session = wasmedge_tensorflow_interface::Session::new(&amp;model_data, wasmedge_tensorflow_interface::ModelType::TensorFlowLite);
  session.add_input(&quot;input&quot;, &amp;flat_img, &amp;[1, 224, 224, 3])
         .run();
  let res_vec: Vec&lt;u8&gt; = session.get_output(&quot;MobilenetV1/Predictions/Reshape_1&quot;);

  // Step 5: Find the food label that responds to the highest probability in res_vec
  // ... ...
  let mut label_lines = labels.lines();
  for _i in 0..max_index {
    label_lines.next();
  }

  // Step 6: Generate the output text
  let class_name = label_lines.next().unwrap().to_string();
  if max_value &gt; 50 {
    println!(&quot;It {} a &lt;a href='https://www.google.com/search?q={}'&gt;{}&lt;/a&gt; in the picture&quot;, confidence.to_string(), class_name, class_name);
  } else {
    println!(&quot;It does not appears to be any food item in the picture.&quot;);
  }
}
</code></pre></pre>
<p>You can use the <code>cargo</code> tool to build the Rust program into WebAssembly bytecode or native code.</p>
<pre><code class="language-bash">cd api/functions/image-classification/
cargo build --release --target wasm32-wasi
</code></pre>
<p>Copy the build artifacts to the <code>api</code> folder.</p>
<pre><code class="language-bash">cp target/wasm32-wasi/release/classify.wasm ../../
</code></pre>
<p>Again, the <a href="https://github.com/second-state/netlify-wasm-runtime/blob/tensorflow/api/pre.sh"><code>api/pre.sh</code></a> script installs WasmEdge runtime and its Tensorflow dependencies in this application. It also compiles the <code>classify.wasm</code> bytecode program to the <code>classify.so</code> native shared library at the time of deployment.</p>
<p>The <a href="https://github.com/second-state/netlify-wasm-runtime/blob/tensorflow/api/hello.js"><code>api/hello.js</code></a> script loads the WasmEdge runtime, starts the compiled WebAssembly program in WasmEdge, and passes the uploaded image data via <code>STDIN</code>. Notice <a href="https://github.com/second-state/netlify-wasm-runtime/blob/tensorflow/api/hello.js"><code>api/hello.js</code></a> runs the compiled <code>classify.so</code> file generated by <a href="https://github.com/second-state/netlify-wasm-runtime/blob/tensorflow/api/pre.sh"><code>api/pre.sh</code></a> for better performance.</p>
<pre><code class="language-javascript">const fs = require('fs');
const { spawn } = require('child_process');
const path = require('path');

module.exports = (req, res) =&gt; {
  const wasmedge = spawn(
    path.join(__dirname, 'wasmedge-tensorflow-lite'),
    [path.join(__dirname, 'classify.so')],
    {env: {'LD_LIBRARY_PATH': __dirname}}
  );

  let d = [];
  wasmedge.stdout.on('data', (data) =&gt; {
    d.push(data);
  });

  wasmedge.on('close', (code) =&gt; {
    res.setHeader('Content-Type', `text/plain`);
    res.send(d.join(''));
  });

  wasmedge.stdin.write(req.body);
  wasmedge.stdin.end('');
}
</code></pre>
<p>You can now <a href="https://www.netlify.com/blog/2016/09/29/a-step-by-step-guide-deploying-on-netlify/">deploy your forked repo to Netlify</a> and have a web app for subject classification.</p>
<p>Next, it's your turn to develop Rust serverless functions in Netlify using the <a href="https://github.com/second-state/netlify-wasm-runtime">netlify-wasm-runtime repo</a> as a template. Looking forward to your great work.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="webassembly-serverless-functions-in-aws-lambda"><a class="header" href="#webassembly-serverless-functions-in-aws-lambda">WebAssembly Serverless Functions in AWS Lambda</a></h1>
<p>In this article, we will show you two serverless functions in Rust and WasmEdge deployed on AWS Lambda. One is the image processing function, the other one is the TensorFlow inference function.</p>
<blockquote>
<p>For the insight on why WasmEdge on AWS Lambda, please refer to the article <a href="https://www.secondstate.io/articles/webassembly-serverless-functions-in-aws-lambda/">WebAssembly Serverless Functions in AWS Lambda</a></p>
</blockquote>
<h2 id="prerequisites-3"><a class="header" href="#prerequisites-3">Prerequisites</a></h2>
<p>Since our demo WebAssembly functions are written in Rust, you will need a <a href="https://www.rust-lang.org/tools/install">Rust compiler</a>. Make sure that you install the <code>wasm32-wasi</code> compiler target as follows, in order to generate WebAssembly bytecode.</p>
<pre><code class="language-bash">rustup target add wasm32-wasi
</code></pre>
<p>The demo application front end is written in <a href="https://nextjs.org/">Next.js</a>, and deployed on AWS Lambda. We will assume that you already have the basic knowledge of how to work with Next.js and Lambda.</p>
<h2 id="example-1-image-processing-2"><a class="header" href="#example-1-image-processing-2">Example 1: Image processing</a></h2>
<p>Our first demo application allows users to upload an image and then invoke a serverless function to turn it into black and white. A <a href="https://second-state.github.io/aws-lambda-wasm-runtime/">live demo</a> deployed through GitHub Pages is available.</p>
<p>Fork the <a href="https://github.com/second-state/aws-lambda-wasm-runtime">demo application’s GitHub repo</a> to get started. To deploy the application on AWS Lambda, follow the guide in the repository <a href="https://github.com/second-state/aws-lambda-wasm-runtime/blob/tensorflow/README.md">README</a>.</p>
<h3 id="create-the-function"><a class="header" href="#create-the-function">Create the function</a></h3>
<p>This repo is a standard Next.js application. The backend serverless function is in the <code>api/functions/image_grayscale</code> folder. The <code>src/main.rs</code> file contains the Rust program’s source code. The Rust program reads image data from the <code>STDIN</code>, and then outputs the black-white image to the <code>STDOUT</code>.</p>
<pre><pre class="playground"><code class="language-rust">use hex;
use std::io::{self, Read};
use image::{ImageOutputFormat, ImageFormat};

fn main() {
  let mut buf = Vec::new();
  io::stdin().read_to_end(&amp;mut buf).unwrap();

  let image_format_detected: ImageFormat = image::guess_format(&amp;buf).unwrap();
  let img = image::load_from_memory(&amp;buf).unwrap();
  let filtered = img.grayscale();
  let mut buf = vec![];
  match image_format_detected {
    ImageFormat::Gif =&gt; {
      filtered.write_to(&amp;mut buf, ImageOutputFormat::Gif).unwrap();
    },
    _ =&gt; {
      filtered.write_to(&amp;mut buf, ImageOutputFormat::Png).unwrap();
    },
  };
  io::stdout().write_all(&amp;buf).unwrap();
  io::stdout().flush().unwrap();
}
</code></pre></pre>
<p>You can use Rust’s <code>cargo</code> tool to build the Rust program into WebAssembly bytecode or native code.</p>
<pre><code class="language-bash">cd api/functions/image-grayscale/
cargo build --release --target wasm32-wasi 
</code></pre>
<p>Copy the build artifacts to the <code>api</code> folder.</p>
<pre><code class="language-bash">cp target/wasm32-wasi/release/grayscale.wasm ../../
</code></pre>
<blockquote>
<p>When we build the docker image, <code>api/pre.sh</code> is executed. <code>pre.sh</code> installs the WasmEdge runtime, and then compiles each WebAssembly bytecode program into a native <code>so</code> library for faster execution.</p>
</blockquote>
<h3 id="create-the-service-script-to-load-the-function"><a class="header" href="#create-the-service-script-to-load-the-function">Create the service script to load the function</a></h3>
<p>The <a href="https://github.com/second-state/aws-lambda-wasm-runtime/blob/main/api/hello.js"><code>api/hello.js</code></a> script loads the WasmEdge runtime, starts the compiled WebAssembly program in WasmEdge, and passes the uploaded image data via <code>STDIN</code>. Notice that <a href="https://github.com/second-state/aws-lambda-wasm-runtime/blob/main/api/hello.js"><code>api/hello.js</code></a> runs the compiled <code>grayscale.so</code> file generated by <a href="https://github.com/second-state/aws-lambda-wasm-runtime/blob/main/api/pre.sh"><code>api/pre.sh</code></a> for better performance.</p>
<pre><code class="language-javascript">const { spawn } = require('child_process');
const path = require('path');

function _runWasm(reqBody) {
  return new Promise(resolve =&gt; {
    const wasmedge = spawn(path.join(__dirname, 'wasmedge'), [path.join(__dirname, 'grayscale.so')]);

    let d = [];
    wasmedge.stdout.on('data', (data) =&gt; {
      d.push(data);
    });

    wasmedge.on('close', (code) =&gt; {
      let buf = Buffer.concat(d);
      resolve(buf);
    });

    wasmedge.stdin.write(reqBody);
    wasmedge.stdin.end('');
  });
}
</code></pre>
<p>The <code>exports.handler</code> part of <code>hello.js</code> exports an async function handler, used to handle different events every time the serverless function is called. In this example, we simply process the image by calling the function above and return the result, but more complicated event-handling behavior may be defined based on your need. We also need to return some <code>Access-Control-Allow</code> headers to avoid <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS">Cross-Origin Resource Sharing (CORS)</a> errors when calling the serverless function from a browser. You can read more about CORS errors <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS/Errors">here</a> if you encounter them when replicating our example.</p>
<pre><code class="language-javascript">exports.handler = async function(event, context) {
  var typedArray = new Uint8Array(event.body.match(/[\da-f]{2}/gi).map(function (h) {
    return parseInt(h, 16);
  }));
  let buf = await _runWasm(typedArray);
  return {
    statusCode: 200,
    headers: {
      &quot;Access-Control-Allow-Headers&quot; : &quot;Content-Type,X-Amz-Date,Authorization,X-Api-Key,X-Amz-Security-Token&quot;,
      &quot;Access-Control-Allow-Origin&quot;: &quot;*&quot;,
      &quot;Access-Control-Allow-Methods&quot;: &quot;DELETE, GET, HEAD, OPTIONS, PATCH, POST, PUT&quot;
    },
    body: buf.toString('hex')
  };
}
</code></pre>
<h3 id="build-the-docker-image-for-lambda-deployment"><a class="header" href="#build-the-docker-image-for-lambda-deployment">Build the Docker image for Lambda deployment</a></h3>
<p>Now we have the WebAssembly bytecode function and the script to load and connect to the web request. In order to deploy them as a function service on AWS Lambda, you still need to package the whole thing into a Docker image.</p>
<p>We are not going to cover in detail about how to build the Docker image and deploy on AWS Lambda, as there are detailed steps in the <a href="https://github.com/second-state/aws-lambda-wasm-runtime/blob/tensorflow/README.md#deploy">Deploy section of the repository README</a>. However, we will highlight some lines in the <a href="https://github.com/second-state/aws-lambda-wasm-runtime/blob/tensorflow/api/Dockerfile"><code>Dockerfile</code></a> for you to avoid some pitfalls.</p>
<pre><code class="language-dockerfile">FROM public.ecr.aws/lambda/nodejs:14

# Change directory to /var/task
WORKDIR /var/task

RUN yum update -y &amp;&amp; yum install -y curl tar gzip

# Bundle and pre-compile the wasm files
COPY *.wasm ./
COPY pre.sh ./
RUN chmod +x pre.sh
RUN ./pre.sh

# Bundle the JS files
COPY *.js ./

CMD [ &quot;hello.handler&quot; ]
</code></pre>
<p>First, we are building the image from <a href="https://hub.docker.com/r/amazon/aws-lambda-nodejs">AWS Lambda's Node.js base image</a>. The advantage of using AWS Lambda's base image is that it includes the <a href="https://github.com/aws/aws-lambda-nodejs-runtime-interface-client">Lambda Runtime Interface Client (RIC)</a>, which we need to implement in our Docker image as it is required by AWS Lambda. The Amazon Linux uses <code>yum</code> as the package manager.</p>
<blockquote>
<p>These base images contain the Amazon Linux Base operating system, the runtime for a given language, dependencies and the Lambda Runtime Interface Client (RIC), which implements the Lambda <a href="https://docs.aws.amazon.com/lambda/latest/dg/runtimes-api.html">Runtime API</a>. The Lambda Runtime Interface Client allows your runtime to receive requests from and send requests to the Lambda service.</p>
</blockquote>
<p>Second, we need to put our function and all its dependencies in the <code>/var/task</code> directory. Files in other folders will not be executed by AWS Lambda.</p>
<p>Third, we need to define the default command when we start our container. <code>CMD [ &quot;hello.handler&quot; ]</code> means that we will call the <code>handler</code> function in <code>hello.js</code> whenever our serverless function is called. Recall that we have defined and exported the handler function in the previous steps through <code>exports.handler = ...</code> in <code>hello.js</code>.</p>
<h3 id="optional-test-the-docker-image-locally"><a class="header" href="#optional-test-the-docker-image-locally">Optional: test the Docker image locally</a></h3>
<p>Docker images built from AWS Lambda's base images can be tested locally following <a href="https://docs.aws.amazon.com/lambda/latest/dg/images-test.html">this guide</a>. Local testing requires <a href="https://github.com/aws/aws-lambda-runtime-interface-emulator">AWS Lambda Runtime Interface Emulator (RIE)</a>, which is already installed in all of AWS Lambda's base images. To test your image, first, start the Docker container by running:</p>
<pre><code class="language-bash">docker run -p 9000:8080  myfunction:latest 
</code></pre>
<p>This command sets a function endpoint on your local machine at <code>http://localhost:9000/2015-03-31/functions/function/invocations</code>.</p>
<p>Then, from a separate terminal window, run:</p>
<pre><code class="language-bash">curl -XPOST &quot;http://localhost:9000/2015-03-31/functions/function/invocations&quot; -d '{}'
</code></pre>
<p>And you should get your expected output in the terminal.</p>
<p>If you don't want to use a base image from AWS Lambda, you can also use your own base image and install RIC and/or RIE while building your Docker image. Just follow <strong>Create an image from an alternative base image</strong> section from <a href="https://docs.aws.amazon.com/lambda/latest/dg/images-create.html">this guide</a>.</p>
<p>That's it! After building your Docker image, you can deploy it to AWS Lambda following steps outlined in the repository <a href="https://github.com/second-state/aws-lambda-wasm-runtime/blob/tensorflow/README.md#deploy">README</a>. Now your serverless function is ready to rock!</p>
<h2 id="example-2-ai-inference-2"><a class="header" href="#example-2-ai-inference-2">Example 2: AI inference</a></h2>
<p>The <a href="https://github.com/second-state/aws-lambda-wasm-runtime/tree/tensorflow">second demo</a> application allows users to upload an image and then invoke a serverless function to classify the main subject on the image.</p>
<p>It is in <a href="https://github.com/second-state/aws-lambda-wasm-runtime/tree/tensorflow">the same GitHub repo</a> as the previous example but in the <code>tensorflow</code> branch. The backend serverless function for image classification is in the <code>api/functions/image-classification</code> folder in the <code>tensorflow</code> branch. The <code>src/main.rs</code> file contains the Rust program’s source code. The Rust program reads image data from the <code>STDIN</code>, and then outputs the text output to the <code>STDOUT</code>. It utilizes the WasmEdge Tensorflow API to run the AI inference.</p>
<pre><pre class="playground"><code class="language-rust">pub fn main() {
  // Step 1: Load the TFLite model
  let model_data: &amp;[u8] = include_bytes!(&quot;models/mobilenet_v1_1.0_224/mobilenet_v1_1.0_224_quant.tflite&quot;);
  let labels = include_str!(&quot;models/mobilenet_v1_1.0_224/labels_mobilenet_quant_v1_224.txt&quot;);

  // Step 2: Read image from STDIN
  let mut buf = Vec::new();
  io::stdin().read_to_end(&amp;mut buf).unwrap();

  // Step 3: Resize the input image for the tensorflow model
  let flat_img = wasmedge_tensorflow_interface::load_jpg_image_to_rgb8(&amp;buf, 224, 224);

  // Step 4: AI inference
  let mut session = wasmedge_tensorflow_interface::Session::new(&amp;model_data, wasmedge_tensorflow_interface::ModelType::TensorFlowLite);
  session.add_input(&quot;input&quot;, &amp;flat_img, &amp;[1, 224, 224, 3])
         .run();
  let res_vec: Vec&lt;u8&gt; = session.get_output(&quot;MobilenetV1/Predictions/Reshape_1&quot;);

  // Step 5: Find the food label that responds to the highest probability in res_vec
  // ... ...
  let mut label_lines = labels.lines();
  for _i in 0..max_index {
    label_lines.next();
  }

  // Step 6: Generate the output text
  let class_name = label_lines.next().unwrap().to_string();
  if max_value &gt; 50 {
    println!(&quot;It {} a &lt;a href='https://www.google.com/search?q={}'&gt;{}&lt;/a&gt; in the picture&quot;, confidence.to_string(), class_name, class_name);
  } else {
    println!(&quot;It does not appears to be any food item in the picture.&quot;);
  }
}
</code></pre></pre>
<p>You can use the <code>cargo</code> tool to build the Rust program into WebAssembly bytecode or native code.</p>
<pre><code class="language-bash">cd api/functions/image-classification/
cargo build --release --target wasm32-wasi
</code></pre>
<p>Copy the build artifacts to the <code>api</code> folder.</p>
<pre><code class="language-bash">cp target/wasm32-wasi/release/classify.wasm ../../
</code></pre>
<p>Again, the <code>api/pre.sh</code> script installs WasmEdge runtime and its Tensorflow dependencies in this application. It also compiles the <code>classify.wasm</code> bytecode program to the <code>classify.so</code> native shared library at the time of deployment.</p>
<p>The <a href="https://github.com/second-state/aws-lambda-wasm-runtime/blob/tensorflow/api/hello.js"><code>api/hello.js</code></a> script loads the WasmEdge runtime, starts the compiled WebAssembly program in WasmEdge, and passes the uploaded image data via <code>STDIN</code>. Notice <a href="https://github.com/second-state/aws-lambda-wasm-runtime/blob/tensorflow/api/hello.js"><code>api/hello.js</code></a> runs the compiled <code>classify.so</code> file generated by <a href="https://github.com/second-state/aws-lambda-wasm-runtime/blob/tensorflow/api/pre.sh"><code>api/pre.sh</code></a> for better performance. The handler function is similar to our previous example, and is omitted here.</p>
<pre><code class="language-javascript">const { spawn } = require('child_process');
const path = require('path');

function _runWasm(reqBody) {
  return new Promise(resolve =&gt; {
    const wasmedge = spawn(
      path.join(__dirname, 'wasmedge-tensorflow-lite'),
      [path.join(__dirname, 'classify.so')],
      {env: {'LD_LIBRARY_PATH': __dirname}}
    );

    let d = [];
    wasmedge.stdout.on('data', (data) =&gt; {
      d.push(data);
    });

    wasmedge.on('close', (code) =&gt; {
      resolve(d.join(''));
    });

    wasmedge.stdin.write(reqBody);
    wasmedge.stdin.end('');
  });
}

exports.handler = ... // _runWasm(reqBody) is called in the handler
</code></pre>
<p>You can build your Docker image and deploy the function in the same way as outlined in the previous example. Now you have created a web app for subject classification!</p>
<p>Next, it's your turn to use the <a href="https://github.com/second-state/aws-lambda-wasm-runtime/tree/main">aws-lambda-wasm-runtime repo</a> as a template to develop Rust serverless function on AWS Lambda. Looking forward to your great work.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="webassembly-serverless-functions-on-tencent-cloud"><a class="header" href="#webassembly-serverless-functions-on-tencent-cloud">WebAssembly serverless functions on Tencent Cloud</a></h1>
<p>As the main users of Tencent Cloud are from China, so the tutorial is <a href="https://my.oschina.net/u/4532842/blog/5172639">written in Chinese</a>.</p>
<p>We also provide a code template for deploying serverless WebAssembly functions on Tencent Cloud, please check out <a href="https://github.com/second-state/tencent-scf-wasm-runtime">the tencent-scf-wasm-runtime repo</a>.</p>
<p>Fork the repo and start writing your own rust functions.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="second-state-functions-1"><a class="header" href="#second-state-functions-1">Second State Functions</a></h1>
<p>Second State Functions, powered by WasmEdge, supports the Rust language as a first class citizen.</p>
<p>It could</p>
<ul>
<li><a href="https://www.secondstate.io/articles/getting-started-with-function-as-a-service-in-rust/">Handle text-based input and output</a></li>
<li><a href="https://www.secondstate.io/articles/use-binary-data-as-function-input-and-output/">Use Binary data as function input and output</a></li>
<li><a href="https://www.secondstate.io/articles/use-binary-data-as-function-input-and-output/">Mix bytes and strings in function argument and return value</a></li>
<li><a href="https://www.secondstate.io/articles/internet-of-functions-webhooks/">Use webhooks as function input and output</a></li>
<li><a href="https://www.secondstate.io/articles/internet-of-functions-http-proxy/">Access internet resources via a <code>http_proxy</code> API</a></li>
<li><a href="https://www.secondstate.io/articles/wasi-tensorflow/">Running TensorFlow models at native speed via the WasmEdge TensorFlow API</a></li>
</ul>
<p>Check out the <a href="https://www.secondstate.io/faas/">Second State Functions</a> website for more tutorials.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="write-a-webassembly-application"><a class="header" href="#write-a-webassembly-application">Write a WebAssembly Application</a></h1>
<p>A key value proposition of WebAssembly is that it supports multiple programming languages. WebAssembly is a &quot;managed runtime&quot; for many programming languages including <a href="write_wasm/c.html">C/C++</a>, <a href="write_wasm/rust.html">Rust</a>, <a href="write_wasm/go.html">Go</a>, <a href="write_wasm/swift.html">Swift</a>, <a href="write_wasm/kotlin.html">Kotlin</a>, <a href="write_wasm/as.html">AssemblyScript</a>, <a href="write_wasm/grain.html">Grain</a> and even <a href="write_wasm/js.html">JavaScript</a> and <a href="write_wasm/python.html">Python</a>.</p>
<ul>
<li>For compiled languages (e.g., C and Rust), WasmEdge WebAssembly provides a safe, secure, isolated, and containerized runtime as opposed to Native Client (NaCl).</li>
<li>For interpreted or managed languages (e.g., JavaScript and Python), WasmEdge WebAssembly provides a secure, fast, lightweight, and containerized runtime as opposed to Docker + guest OS + native interpreter.</li>
</ul>
<p>In this chapter, we will discuss how to compile sources into WebAssembly in different languages and run them in WasmEdge.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="c"><a class="header" href="#c">C</a></h1>
<p>A simple example for compiling C code into WebAssembly is <a href="write_wasm/c/simd.html">SIMD</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="webassembly-simd-example-in-c"><a class="header" href="#webassembly-simd-example-in-c">WebAssembly SIMD Example in C</a></h1>
<p><a href="https://webassembly.github.io/simd/core/syntax/instructions.html#simd-instructions">128-bit packed Single Instruction Multiple Data (SIMD)</a> instructions provide simultaneous computations over packed data in just one instruction. It's commonly used to improve performance for multimedia applications. With the SIMD proposal, the modules can benefit from using these commonly used instructions in modern hardware to gain more speedup.</p>
<p>If you are interested in enabling the SIMD proposal will improve how much performance of the applications, please refer to our <a href="https://github.com/second-state/wasm32-wasi-benchmark/tree/simd">wasm32-wasi benchmark</a> for more information.
In our benchmark, the Mandelbrot Set application can have <strong>2.65x</strong> speedup.</p>
<h2 id="c-language-code---mandelbrot-set"><a class="header" href="#c-language-code---mandelbrot-set">C language Code - Mandelbrot Set</a></h2>
<p>We modified the Mandelbrot Set example from our <a href="https://github.com/second-state/wasm32-wasi-benchmark/blob/master/src/mandelbrot.c">wasm32-wasi benchmark project</a>.</p>
<pre><code class="language-c">#define LIMIT_SQUARED 4.0
#define MAXIMUM_ITERATIONS 50

#include &lt;inttypes.h&gt;
#include &lt;math.h&gt;
#include &lt;stdbool.h&gt;
#include &lt;stdint.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

typedef double doublex2 __attribute__((vector_size(16)));
typedef uint64_t uint64x2_t __attribute__((vector_size(16)));

static inline void calcSum(doublex2 *r, doublex2 *i, doublex2 *sum,
                           const doublex2 init_r[4], const doublex2 init_i) {
  for (uint64_t x_Minor = 0; x_Minor &lt; 4; x_Minor++) {
    doublex2 r2 = r[x_Minor] * r[x_Minor];
    doublex2 i2 = i[x_Minor] * i[x_Minor];
    doublex2 ri = r[x_Minor] * i[x_Minor];

    sum[x_Minor] = r2 + i2;

    r[x_Minor] = r2 - i2 + init_r[x_Minor];
    i[x_Minor] = ri + ri + init_i;
  }
}

static inline bool vec_gt(const doublex2 *v) {
  const doublex2 f = {LIMIT_SQUARED, LIMIT_SQUARED};
  const uint64x2_t r = (v[0] &gt; f) &amp; (v[1] &gt; f) &amp; (v[2] &gt; f) &amp; (v[3] &gt; f);
  return r[0] &amp;&amp; r[1];
}

static inline uint8_t clrPixels_gt(const doublex2 *v) {
  const doublex2 f = {LIMIT_SQUARED, LIMIT_SQUARED};
  const uint64x2_t r0 = v[0] &lt;= f;
  const uint64x2_t r1 = v[1] &lt;= f;
  const uint64x2_t r2 = v[2] &lt;= f;
  const uint64x2_t r3 = v[3] &lt;= f;
  return (r0[0] &amp; 0x1) &lt;&lt; 7 | (r0[1] &amp; 0x1) &lt;&lt; 6 | (r1[0] &amp; 0x1) &lt;&lt; 5 |
         (r1[1] &amp; 0x1) &lt;&lt; 4 | (r2[0] &amp; 0x1) &lt;&lt; 3 | (r2[1] &amp; 0x1) &lt;&lt; 2 |
         (r3[0] &amp; 0x1) &lt;&lt; 1 | (r3[1] &amp; 0x1) &lt;&lt; 0;
}

static inline uint8_t mand8(const doublex2 init_r[4], const doublex2 init_i) {
  doublex2 pixel_Group_r[4], pixel_Group_i[4];
  for (uint64_t x_Minor = 0; x_Minor &lt; 4; x_Minor++) {
    pixel_Group_r[x_Minor] = init_r[x_Minor];
    pixel_Group_i[x_Minor] = init_i;
  }

  doublex2 sum[4];
  for (unsigned j = 0; j &lt; 6; j++) {
    for (unsigned k = 0; k &lt; 8; k++) {
      calcSum(pixel_Group_r, pixel_Group_i, sum, init_r, init_i);
    }
    if (vec_gt(sum)) {
      return 0x00;
    }
  }
  calcSum(pixel_Group_r, pixel_Group_i, sum, init_r, init_i);
  calcSum(pixel_Group_r, pixel_Group_i, sum, init_r, init_i);
  return clrPixels_gt(sum);
}

static inline uint64_t mand64(const doublex2 init_r[4], const doublex2 init_i) {
  uint64_t sixtyfour_Pixels = 0;
  for (uint64_t byte = 0; byte &lt; 8; byte++) {
    const uint64_t eight_Pixels = mand8(init_r + 4 * byte, init_i);
    sixtyfour_Pixels =
        (sixtyfour_Pixels &gt;&gt; UINT64_C(8)) | (eight_Pixels &lt;&lt; UINT64_C(56));
  }
  return sixtyfour_Pixels;
}

int main(int argc, char **argv) {
  const uint64_t image_Width_And_Height =
      (__builtin_expect(atoi(argv[1]), 15000) + 7) / 8 * 8;

  uint8_t *const pixels =
      malloc(image_Width_And_Height * image_Width_And_Height / 8);

  doublex2 initial_r[image_Width_And_Height / 2];
  double initial_i[image_Width_And_Height];
  for (uint64_t xy = 0; xy &lt; image_Width_And_Height; xy++) {
    initial_r[xy / 2] =
        2.0 / image_Width_And_Height * (doublex2){xy, xy + 1} - 1.5;
    initial_i[xy] = 2.0 / image_Width_And_Height * xy - 1.0;
  }

  if (image_Width_And_Height % 64) {
    // process 8 pixels (one byte) at a time
    for (uint64_t y = 0; y &lt; image_Width_And_Height; y++) {
      const doublex2 prefetched_Initial_i = {initial_i[y], initial_i[y]};
      const size_t rowStart = y * image_Width_And_Height / 8;
      for (uint64_t x_Major = 0; x_Major &lt; image_Width_And_Height;
           x_Major += 8) {
        const doublex2 *prefetched_Initial_r = &amp;initial_r[x_Major / 2];
        pixels[rowStart + x_Major / 8] =
            mand8(prefetched_Initial_r, prefetched_Initial_i);
      }
    }
  } else {
    // process 64 pixels (8 bytes) at a time
    for (uint64_t y = 0; y &lt; image_Width_And_Height; y++) {
      const doublex2 prefetched_Initial_i = {initial_i[y], initial_i[y]};
      const size_t rowStart = y * image_Width_And_Height / 8;
      for (uint64_t x_Major = 0; x_Major &lt; image_Width_And_Height;
           x_Major += 8) {
        const doublex2 *prefetched_Initial_r = &amp;initial_r[x_Major / 2];
        const uint64_t sixtyfour_Pixels =
            mand64(prefetched_Initial_r, prefetched_Initial_i);
        memcpy(&amp;pixels[rowStart + x_Major / 8], &amp;sixtyfour_Pixels, 8);
      }
    }
  }

  fprintf(stdout, &quot;P4\n%&quot; PRIu64 &quot; %&quot; PRIu64 &quot;\n&quot;, image_Width_And_Height,
          image_Width_And_Height);
  fwrite(pixels, image_Width_And_Height * image_Width_And_Height / 8, 1,
         stdout);

  free(pixels);

  return 0;
}
</code></pre>
<h2 id="compile-the-c-simd-application-to-wasm-simd-binary-with-emcc"><a class="header" href="#compile-the-c-simd-application-to-wasm-simd-binary-with-emcc">Compile the C-SIMD application to Wasm-SIMD binary with emcc</a></h2>
<h3 id="install-emcc"><a class="header" href="#install-emcc">Install emcc</a></h3>
<p>To compile it, you will need to install the latest emcc toolchain. Please refer to the <a href="https://github.com/emscripten-core/emsdk">emcc official repository</a> for the detailed instructions.</p>
<pre><code class="language-bash">git clone --depth 1 https://github.com/emscripten-core/emsdk.git
cd emsdk
./emsdk install latest
./emsdk activate latest
source ./emsdk_env.sh
</code></pre>
<h3 id="compile-with-emcc"><a class="header" href="#compile-with-emcc">Compile with emcc</a></h3>
<pre><code class="language-bash">emcc -g -Oz --llvm-lto 1 -s STANDALONE_WASM -s INITIAL_MEMORY=32MB -s MAXIMUM_MEMORY=4GB \
  -mmutable-globals \
  -mnontrapping-fptoint \
  -msign-ext \
  mandelbrot-simd.c -o mandelbrot-simd.wasm
</code></pre>
<h2 id="run-with-wasmedge"><a class="header" href="#run-with-wasmedge">Run with wasmedge</a></h2>
<h3 id="interpreter-mode"><a class="header" href="#interpreter-mode">Interpreter mode</a></h3>
<pre><code class="language-bash">wasmedge mandelbrot-simd.wasm 15000
</code></pre>
<h3 id="ahead-of-time-mode"><a class="header" href="#ahead-of-time-mode">Ahead-of-Time mode</a></h3>
<pre><code class="language-bash"># Compile wasm-simd with wasmedge aot compiler
$ wasmedgec mandelbrot-simd.wasm mandelbrot-simd-out.wasm
# Run the native binary with wasmedge
$ wasmedge mandelbrot-simd-out.wasm 15000
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rust"><a class="header" href="#rust">Rust</a></h1>
<p>Rust is one of the &quot;first-class citizen&quot; programming languages in the WebAssembly ecosystem. All WasmEdge extensions to WebAssembly also come with Rust APIs for developers.
In this chapter, we will show you how to compile your Rust applications to WebAssembly and to run in the WasmEdge runtime.</p>
<h2 id="prerequisites-4"><a class="header" href="#prerequisites-4">Prerequisites</a></h2>
<p>You need to install <a href="https://www.rust-lang.org/tools/install">Rust</a> and <a href="write_wasm/../quick_start/install.html">WasmEdge</a> in order to get started.
You should also install the <code>wasm32-wasi</code> target of the Rust toolchain.</p>
<pre><code class="language-bash">rustup target add wasm32-wasi
</code></pre>
<h2 id="hello-world-1"><a class="header" href="#hello-world-1">Hello world</a></h2>
<p>The Hello world example is a standalone Rust application that can be executed by the <a href="write_wasm/../cli.html">WasmEdge CLI</a>. Its <a href="https://github.com/second-state/wasm-learning/tree/master/cli/hello">source code is available here</a>.</p>
<p>The full source code for the Rust <a href="https://github.com/second-state/wasm-learning/blob/master/cli/hello/src/main.rs">main.rs</a> file is as follows.
It echoes the command line arguments passed to this program at runtime.</p>
<pre><pre class="playground"><code class="language-rust">use std::env;

fn main() {
  println!(&quot;hello&quot;);
  for argument in env::args().skip(1) {
    println!(&quot;{}&quot;, argument);
  }
}
</code></pre></pre>
<h3 id="hello-world-build-the-wasm-bytecode"><a class="header" href="#hello-world-build-the-wasm-bytecode">Hello world: Build the WASM bytecode</a></h3>
<pre><code class="language-bash">cargo build --target wasm32-wasi
</code></pre>
<h3 id="hello-world-run-the-application-from-command-line"><a class="header" href="#hello-world-run-the-application-from-command-line">Hello world: Run the application from command line</a></h3>
<p>We will use the <code>wasmedge</code> command to run the program.</p>
<pre><code class="language-bash">$ wasmedge target/wasm32-wasi/debug/hello.wasm second state
hello
second
state
</code></pre>
<h2 id="a-simple-function"><a class="header" href="#a-simple-function">A simple function</a></h2>
<p>The <a href="https://github.com/second-state/wasm-learning/tree/master/cli/add">add example</a> is a Rust library function that can be executed by the <a href="write_wasm/../cli/wasmedge.html">WasmEdge CLI</a> in the reactor mode.</p>
<p>The full source code for the Rust <a href="https://github.com/second-state/wasm-learning/blob/master/cli/add/src/lib.rs">lib.rs</a> file is as follows.
It provides a simple <code>add()</code> function.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[no_mangle]
pub fn add(a: i32, b: i32) -&gt; i32 {
  return a + b;
}
<span class="boring">}
</span></code></pre></pre>
<h3 id="a-simple-function-build-the-wasm-bytecode"><a class="header" href="#a-simple-function-build-the-wasm-bytecode">A simple function: Build the WASM bytecode</a></h3>
<pre><code class="language-bash">cargo build --target wasm32-wasi
</code></pre>
<h3 id="a-simple-function-run-the-application-from-command-line"><a class="header" href="#a-simple-function-run-the-application-from-command-line">A simple function: Run the application from command line</a></h3>
<p>We will use <code>wasmedge</code> in reactor mode to run the program. We pass the function name and its input parameters as command line arguments.</p>
<pre><code class="language-bash">$ wasmedge --reactor target/wasm32-wasi/debug/add.wasm add 2 2
4
</code></pre>
<h2 id="pass-parameters-with-complex-data-types"><a class="header" href="#pass-parameters-with-complex-data-types">Pass Parameters with Complex Data Types</a></h2>
<p>Of course, in most cases, you will not call functions using CLI arguments.
Instead, you will probably need to use a <a href="write_wasm/../sdk.html">language SDK from WasmEdge</a> to call the function, pass call parameters, and receive return values.
Below are some SDK examples for complex call parameters and return values.</p>
<ul>
<li><a href="write_wasm/../sdk/go/function.html">Use wasmedge-bindgen in a Go host app</a></li>
<li><a href="write_wasm/../sdk/go/memory.html">Use direct memory passing in a Go host app</a></li>
</ul>
<h2 id="improve-the-performance"><a class="header" href="#improve-the-performance">Improve the Performance</a></h2>
<p>To achieve native Rust performance for those applications, you could use the <code>wasmedgec</code> command to AOT compile the <code>wasm</code> program, and then run it with the <code>wasmedge</code> command.</p>
<pre><code class="language-bash">$ wasmedgec hello.wasm hello_aot.wasm

$ wasmedge hello_aot.wasm second state
hello
second
state
</code></pre>
<p>For the <code>--reactor</code> mode,</p>
<pre><code class="language-bash">$ wasmedgec add.wasm add_aot.wasm

$ wasmedge --reactor add_aot.wasm add 2 2
4
</code></pre>
<h2 id="further-readings"><a class="header" href="#further-readings">Further readings</a></h2>
<ul>
<li><a href="write_wasm/rust/bindgen.html">Bindgen</a> can helper developers to create the WebAssembly library from Rust.</li>
<li><a href="write_wasm/rust/wasi.html">Access OS services via WASI</a> shows how the WebAssembly program can access the underlying OS services, such as file system and environment variables.</li>
<li><a href="write_wasm/rust/tensorflow.html">Tensorflow</a> shows how to create Tensorflow-based AI inference applications for WebAssembly using the WasmEdge TensorFlow Rust SDK.</li>
<li><a href="write_wasm/rust/wasinn.html">Neural Network for WASI</a> shows how the WebAssembly program can leverage OpenVINO model to access the Machine Learning (ML) functions.</li>
<li><a href="write_wasm/rust/wasicrypto.html">Crypto for WASI</a> shows how the WebAssembly program can access the crypto functions.</li>
<li><a href="write_wasm/rust/networking.html">Simple networking socket</a> shows how to create simple HTTP client and server applications using the WasmEdge networking socket Rust SDK.</li>
<li><a href="write_wasm/rust/networking-https.html">Simple networking socket in https</a> shows how to create simple HTTPS client and server applications using the WasmEdge networking socket Rust SDK.</li>
<li><a href="write_wasm/rust/networking-nonblocking.html">Non-blocking networking socket</a> shows how to create a high-performance non-blocking networking applications with concurrent open connections using the WasmEdge networking socket Rust SDK.</li>
<li><a href="write_wasm/rust/ssr.html">Server-side rendering</a> shows how to build an interactive web app with Rust, and then render the HTML DOM UI on the server using WasmEdge. The Rust source code is compiled to WebAssembly to render the HTML DOM in the browser or on the server.</li>
<li><a href="write_wasm/rust/command.html">Command interface</a> shows how to create native command applications for WebAssembly using the Wasmedge command interface Rust SDK.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bindgen-of-rust-functions"><a class="header" href="#bindgen-of-rust-functions">Bindgen of Rust Functions</a></h1>
<p>If your Rust program has a <code>main()</code> function, you could compile it into WebAssembly, and run it using the <code>wasmedge</code> CLI tool as a standalone application. However, a far more common use case is to compile a Rust function into WebAssembly, and then call it from a host application. That is known as an embedded WASM function. The host application uses WasmEdge language SDKs (e.g., <a href="write_wasm/rust/../../sdk/go.html">Go</a>, <a href="write_wasm/rust/../../sdk/rust.html">Rust</a>, <a href="write_wasm/rust/../../sdk/c.html">C</a>, <a href="write_wasm/rust/../../sdk/go.html">Python</a> and <a href="write_wasm/rust/../../sdk/node.html">Node.js</a>) to call those WASM functions compiled from Rust source code.</p>
<p>All the WasmEdge host language SDKs support simple function calls. However, the WASM spec only supports a few simple data types as call parameters and return values, such as <code>i32</code>, <code>i64</code>, <code>f32</code>, <code>f64</code>, and <code>v128</code>. The <code>wasmedge-bindgen</code> crate would transform parameters and return values of Rust functions into simple integer types when the Rust function is compiled into WASM. For example, a string is automatically converted into two integers, a memory address and a length, which can be handled by the standard WASM spec. It is very easy to do this in Rust source code. Just annotate your function with the <code>#[wasmedge-bindgen]</code> macro. You can compile the annotated Rust code using the standard Rust compiler toolchain (e.g., the latest <code>Cargo</code>).</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use wasmedge_bindgen::*;
use wasmedge_bindgen_macro::*;

#[wasmedge_bindgen]
pub fn say(s: String) -&gt; Result&lt;Vec&lt;u8&gt;, String&gt; {
  let r = String::from(&quot;hello &quot;);
  return Ok((r + s.as_str()).as_bytes().to_vec());
}
<span class="boring">}
</span></code></pre></pre>
<p>Of course, once the above Rust code is compiled into WASM, the function <code>say()</code> no longer takes the <code>String</code> parameter nor returns the <code>Vec&lt;u8&gt;</code>. So, the caller (i.e., the host application) must also deconstruct the call parameter into the memory pointer first before the call, and assemble the return value from the memory pointer after the call. These actions can be handled automagically by the WasmEdge language SDKs. To see a complete example, including the Rust WASM function and the Go host application, check out our tutorial in the Go SDK documentation.</p>
<p><strong><a href="write_wasm/rust/../../sdk/go/function.html">A complete wasmedge-bindgen example in Rust (WASM) and Go (host)</a></strong></p>
<p>Of course, the developer could choose to do <code>wasmedge-bindgen</code>'s work by hand and pass a memory pointer directly. If you are interested in this approach to call Rust compiled WASM functions, check out our <a href="write_wasm/rust/../../sdk/go/memory.html">examples in the Go SDK</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="access-os-services"><a class="header" href="#access-os-services">Access OS services</a></h1>
<p>The WASI (WebAssembly Systems Interface) standard is designed to allow WebAssembly applications to access operating system services.
The <code>wasm32-wasi</code> target in the Rust compiler supports WASI.
In this section, we will use <a href="https://github.com/second-state/wasm-learning/tree/master/cli/wasi">an example project</a> to show how to use Rust standard APIs to access operating system services.</p>
<h2 id="random-numbers"><a class="header" href="#random-numbers">Random numbers</a></h2>
<p>The WebAssembly VM is a pure software construct. It does not have a hardware entropy source for random numbers. That's why WASI defines a function for WebAssembly programs to call its host operating system to get a random seed. As a Rust developer, all you need is to use the popular (de facto standard) <code>rand</code> and/or <code>getrandom</code> crates. With the <code>wasm32-wasi</code> compiler backend, these crates generate the correct WASI calls in the WebAssembly bytecode. The <code>Cargo.toml</code> dependencies are as follows.</p>
<pre><code class="language-toml">[dependencies]
rand = &quot;0.7.3&quot;
getrandom = &quot;0.1.14&quot;
</code></pre>
<p>The Rust code to get random number from WebAssembly is this.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use rand::prelude::*;

pub fn get_random_i32() -&gt; i32 {
  let x: i32 = random();
  return x;
}

pub fn get_random_bytes() -&gt; Vec&lt;u8&gt; {
  let mut rng = thread_rng();
  let mut arr = [0u8; 128];
  rng.fill(&amp;mut arr[..]);
  return arr.to_vec();
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="printing-and-debugging-from-rust"><a class="header" href="#printing-and-debugging-from-rust">Printing and debugging from Rust</a></h2>
<p>The Rust <code>println!</code> marco just works in WASI. The statements print to the <code>STDOUT</code> of the process that runs the WasmEdge.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn echo(content: &amp;str) -&gt; String {
  println!(&quot;Printed from wasi: {}&quot;, content);
  return content.to_string();
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="arguments-and-environment-variables"><a class="header" href="#arguments-and-environment-variables">Arguments and environment variables</a></h2>
<p>It is possible to pass CLI arguments to and access OS environment variables in a WasmEdge application.
They are just <code>env::args()</code> and <code>env::vars()</code> arrays in Rust.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::env;

pub fn print_env() {
  println!(&quot;The env vars are as follows.&quot;);
  for (key, value) in env::vars() {
    println!(&quot;{}: {}&quot;, key, value);
  }

  println!(&quot;The args are as follows.&quot;);
  for argument in env::args() {
    println!(&quot;{}&quot;, argument);
  }
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="reading-and-writing-files"><a class="header" href="#reading-and-writing-files">Reading and writing files</a></h2>
<p>WASI allows your Rust functions to access the host computer's file system through the standard Rust <code>std::fs</code> API.
In the Rust program, you operate on files through a relative path. The relative path's root is specified when you start the WasmEdge runtime.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fs;
use std::fs::File;
use std::io::{Write, Read};

pub fn create_file(path: &amp;str, content: &amp;str) {
  let mut output = File::create(path).unwrap();
  output.write_all(content.as_bytes()).unwrap();
}

pub fn read_file(path: &amp;str) -&gt; String {
  let mut f = File::open(path).unwrap();
  let mut s = String::new();
  match f.read_to_string(&amp;mut s) {
    Ok(_) =&gt; s,
    Err(e) =&gt; e.to_string(),
  }
}

pub fn del_file(path: &amp;str) {
  fs::remove_file(path).expect(&quot;Unable to delete&quot;);
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="a-main-app"><a class="header" href="#a-main-app">A main() app</a></h2>
<p>With a <code>main()</code> function, the Rust program can be compiled into a standalone WebAssembly program.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
  println!(&quot;Random number: {}&quot;, get_random_i32());
  println!(&quot;Random bytes: {:?}&quot;, get_random_bytes());
  println!(&quot;{}&quot;, echo(&quot;This is from a main function&quot;));
  print_env();
  create_file(&quot;tmp.txt&quot;, &quot;This is in a file&quot;);
  println!(&quot;File content is {}&quot;, read_file(&quot;tmp.txt&quot;));
  del_file(&quot;tmp.txt&quot;);
}
</code></pre></pre>
<p>Use the command below to compile <a href="https://github.com/second-state/wasm-learning/tree/master/cli/wasi">the Rust project</a>.</p>
<pre><code class="language-bash">cargo build --target wasm32-wasi
</code></pre>
<p>To run it in <code>wasmedge</code>, do the following. The <code>--dir</code> option maps the current directory of the command shell to the file system current directory inside the WebAssembly app.</p>
<pre><code class="language-bash">$ wasmedge --dir .:. target/wasm32-wasi/debug/wasi.wasm hello
Random number: -68634548
Random bytes: [87, 117, 194, 122, 74, 189, 29, 1, 113, 26, 90, 6, 151, 20, 11, 169, 131, 212, 161, 220, 216, 190, 77, 234, 30, 10, 159, 7, 14, 89, 81, 111, 247, 136, 39, 195, 83, 90, 153, 225, 66, 16, 150, 217, 137, 172, 216, 203, 251, 37, 4, 27, 32, 57, 76, 237, 99, 147, 24, 175, 208, 157, 3, 220, 46, 224, 199, 153, 144, 96, 120, 89, 160, 38, 171, 239, 87, 218, 41, 184, 220, 78, 157, 57, 229, 198, 222, 72, 219, 118, 237, 27, 229, 28, 51, 116, 88, 101, 40, 139, 160, 51, 156, 102, 66, 233, 101, 50, 131, 9, 253, 186, 73, 148, 85, 36, 155, 254, 168, 202, 23, 96, 181, 99, 120, 136, 28, 147]
This is from a main function
The env vars are as follows.
... ...
The args are as follows.
target/wasm32-wasi/debug/wasi.wasm
hello
File content is This is in a file
</code></pre>
<h2 id="functions"><a class="header" href="#functions">Functions</a></h2>
<p>As <a href="write_wasm/rust/../rust.html#a-simple-function">we have seen</a>, you can create WebAssembly functions in a Rust <code>lib.rs</code> project. You can also use WASI functions in those functions.
However, an important caveat is that, without a <code>main()</code> function, you will need to explicitly call a helper function to initialize environment for WASI functions to work properly.
In the Rust program, add a helper crate in Cargo.toml so that the WASI initialization code can be applied to your exported public library functions.</p>
<pre><code class="language-toml">[dependencies]
... ...
wasmedge-wasi-helper = &quot;=0.2.0&quot;
</code></pre>
<p>In the Rust function, we need to call <code>_initialize()</code> before we access any arguments and environment variables or operate any files.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn print_env() -&gt; i32 {
  _initialize();
  ... ...
}

pub fn create_file(path: &amp;str, content: &amp;str) -&gt; String {
  _initialize();
  ... ...
}

pub fn read_file(path: &amp;str) -&gt; String {
  _initialize();
  ... ...
}

pub fn del_file(path: &amp;str) -&gt; String {
  _initialize();
  ... ...
}
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tensorflow"><a class="header" href="#tensorflow">Tensorflow</a></h1>
<p>AI inference is a computationally intensive task that could benefit greatly from the speed of Rust and WebAssembly. However, the standard WebAssembly sandbox provides very limited access to the native OS and hardware, such as multi-core CPUs, GPU and specialized AI inference chips. It is not ideal for the AI workload.</p>
<p>The popular WebAssembly System Interface (WASI) provides a design pattern for sandboxed WebAssembly programs to securely access native host functions. The WasmEdge Runtime extends the WASI model to support access to native Tensorflow libraries from WebAssembly programs. The <a href="https://github.com/second-state/wasmedge_tensorflow_interface">WasmEdge Tensorflow Rust SDK</a> provides the security, portability, and ease-of-use of WebAssembly and native speed for Tensorflow.</p>
<blockquote>
<p>If you are not familiar with Rust, you can try our <a href="https://github.com/second-state/wasm-learning/tree/master/cli/classify_yml">experimental AI inference DSL</a> or try our <a href="write_wasm/rust/../js/tensorflow.html">JavaScript examples</a>.</p>
</blockquote>
<h2 id="table-of-contents"><a class="header" href="#table-of-contents">Table of contents</a></h2>
<ul>
<li><a href="write_wasm/rust/tensorflow.html#a-rust-example">A Rust example</a></li>
<li><a href="write_wasm/rust/tensorflow.html#deployment-options">Deployment options</a></li>
</ul>
<h2 id="a-rust-example"><a class="header" href="#a-rust-example">A Rust example</a></h2>
<h3 id="prerequisite-4"><a class="header" href="#prerequisite-4">Prerequisite</a></h3>
<p>You need to install <a href="write_wasm/rust/../../quick_start/install.html">WasmEdge</a> and <a href="https://www.rust-lang.org/tools/install">Rust</a>.</p>
<h3 id="build"><a class="header" href="#build">Build</a></h3>
<p>Check out the example source code.</p>
<pre><code class="language-bash">git clone https://github.com/second-state/wasm-learning/
cd cli/tflite
</code></pre>
<p>Use Rust <code>Cargo</code> to build the WebAssembly target.</p>
<pre><code class="language-bash">rustup target add wasm32-wasi
cargo build --target wasm32-wasi --release
</code></pre>
<h3 id="run"><a class="header" href="#run">Run</a></h3>
<p>The <code>wasmedge-tensorflow-lite</code> utility is the WasmEdge build that includes the Tensorflow and Tensorflow Lite extensions.</p>
<pre><code class="language-bash">$ wasmedge-tensorflow-lite target/wasm32-wasi/release/classify.wasm &lt; grace_hopper.jpg
It is very likely a &lt;a href='https://www.google.com/search?q=military uniform'&gt;military uniform&lt;/a&gt; in the picture
</code></pre>
<h3 id="make-it-run-faster"><a class="header" href="#make-it-run-faster">Make it run faster</a></h3>
<p>To make Tensorflow inference run <em>much</em> faster, you could AOT compile it down to machine native code, and then use WasmEdge sandbox to run the native code.</p>
<pre><code class="language-bash">$ wasmedgec target/wasm32-wasi/release/classify.wasm classify.wasm
$ wasmedge-tensorflow-lite classify.wasm &lt; grace_hopper.jpg
It is very likely a &lt;a href='https://www.google.com/search?q=military uniform'&gt;military uniform&lt;/a&gt; in the picture
</code></pre>
<h3 id="code-walkthrough"><a class="header" href="#code-walkthrough">Code walkthrough</a></h3>
<p>It is fairly straightforward to use the WasmEdge Tensorflow API. You can see the entire source code in <a href="https://github.com/second-state/wasm-learning/blob/master/cli/tflite/src/main.rs">main.rs</a>.</p>
<p>First, it reads the trained TFLite model file (ImageNet) and its label file. The label file maps numeric output from the model to English names for the classified objects.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>  let model_data: &amp;[u8] = include_bytes!(&quot;models/mobilenet_v1_1.0_224/mobilenet_v1_1.0_224_quant.tflite&quot;);
  let labels = include_str!(&quot;models/mobilenet_v1_1.0_224/labels_mobilenet_quant_v1_224.txt&quot;);
<span class="boring">}
</span></code></pre></pre>
<p>Next, it reads the image from <code>STDIN</code> and converts it to the size and RGB pixel arrangement required by the Tensorflow Lite model.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>  let mut buf = Vec::new();
  io::stdin().read_to_end(&amp;mut buf).unwrap();

  let flat_img = wasmedge_tensorflow_interface::load_jpg_image_to_rgb8(&amp;buf, 224, 224);
<span class="boring">}
</span></code></pre></pre>
<p>Then, the program runs the TFLite model with its required input tensor (i.e., the flat image in this case), and receives the model output. In this case, the model output is an array of numbers. Each number corresponds to the probability of an object name in the label text file.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>  let mut session = wasmedge_tensorflow_interface::Session::new(&amp;model_data, wasmedge_tensorflow_interface::ModelType::TensorFlowLite);
  session.add_input(&quot;input&quot;, &amp;flat_img, &amp;[1, 224, 224, 3])
         .run();
  let res_vec: Vec&lt;u8&gt; = session.get_output(&quot;MobilenetV1/Predictions/Reshape_1&quot;);
<span class="boring">}
</span></code></pre></pre>
<p>Let's find the object with the highest probability, and then look up the name in the labels file.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>  let mut i = 0;
  let mut max_index: i32 = -1;
  let mut max_value: u8 = 0;
  while i &lt; res_vec.len() {
    let cur = res_vec[i];
    if cur &gt; max_value {
      max_value = cur;
      max_index = i as i32;
    }
    i += 1;
  }

  let mut label_lines = labels.lines();
  for _i in 0..max_index {
    label_lines.next();
  }
<span class="boring">}
</span></code></pre></pre>
<p>Finally, it prints the result to <code>STDOUT</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>  let class_name = label_lines.next().unwrap().to_string();
  if max_value &gt; 50 {
    println!(&quot;It {} a &lt;a href='https://www.google.com/search?q={}'&gt;{}&lt;/a&gt; in the picture&quot;, confidence.to_string(), class_name, class_name);
  } else {
    println!(&quot;It does not appears to be any food item in the picture.&quot;);
  }
<span class="boring">}
</span></code></pre></pre>
<h2 id="deployment-options"><a class="header" href="#deployment-options">Deployment options</a></h2>
<p>All the tutorials below use the <a href="https://github.com/second-state/wasmedge_tensorflow_interface">WasmEdge Rust API for Tensorflow</a> to create AI inference functions. Those Rust functions are then compiled to WebAssembly and deployed together with WasmEdge on the cloud.</p>
<h3 id="serverless-functions"><a class="header" href="#serverless-functions">Serverless functions</a></h3>
<p>The following tutorials showcase how to deploy WebAssembly programs (written in Rust) on public cloud serverless platforms. The WasmEdge Runtime runs inside a Docker container on those platforms. Each serverless platform provides APIs to get data into and out of the WasmEdge runtime through STDIN and STDOUT.</p>
<ul>
<li><a href="https://www.secondstate.io/articles/vercel-wasmedge-webassembly-rust/">Vercel Serverless Functions</a></li>
<li><a href="https://www.secondstate.io/articles/netlify-wasmedge-webassembly-rust-serverless/">Netlify Functions</a></li>
<li><a href="https://github.com/second-state/aws-lambda-wasm-runtime">AWS Lambda</a></li>
<li><a href="https://github.com/second-state/tencent-scf-wasm-runtime">Tencent Serverless Functions</a> (in Chinese)</li>
</ul>
<h3 id="second-sate-faas-and-nodejs"><a class="header" href="#second-sate-faas-and-nodejs">Second Sate FaaS and Node.js</a></h3>
<p>The following tutorials showcase how to deploy WebAssembly functions (written in Rust) on the Second State FaaS. Since the FaaS service is running on Node.js, you can follow the same tutorials for running those functions in your own Node.js server.</p>
<ul>
<li><a href="https://www.secondstate.io/articles/faas-image-classification/">Tensorflow: Image classification using the MobileNet models</a> | <a href="https://second-state.github.io/wasm-learning/faas/mobilenet/html/index.html">Live demo</a></li>
<li><a href="https://www.secondstate.io/articles/faas-face-detection/">Tensorflow: Face detection using the MTCNN models</a> | <a href="https://second-state.github.io/wasm-learning/faas/mtcnn/html/index.html">Live demo</a></li>
</ul>
<h3 id="service-mesh"><a class="header" href="#service-mesh">Service mesh</a></h3>
<p>The following tutorials showcase how to deploy WebAssembly functions and programs (written in Rust) as sidecar microservices.</p>
<ul>
<li><a href="https://github.com/second-state/dapr-wasm">The Dapr template</a> shows how to build and deploy Dapr sidecars in Go and Rust languages. The sidecars then use the WasmEdge SDK to start WebAssembly programs to process workloads to the microservices.</li>
</ul>
<h3 id="data-streaming-framework"><a class="header" href="#data-streaming-framework">Data streaming framework</a></h3>
<p>The following tutorials showcase how to deploy WebAssembly functions (written in Rust) as embedded handler functions in data streaming frameworks for AIoT.</p>
<ul>
<li><a href="https://www.secondstate.io/articles/yomo-wasmedge-real-time-data-streams/">The YoMo template</a> starts the WasmEdge Runtime to process image data as the data streams in from a camera in a smart factory.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="neural-network-for-wasi"><a class="header" href="#neural-network-for-wasi">Neural Network for WASI</a></h1>
<p>In WasmEdge, we implemented the <a href="https://github.com/WebAssembly/wasi-nn">WASI-NN</a> (Neural Network for WASI) proposal to allow access the Machine Learning (ML) functions with the fashion of graph loader APIs by the following functions:</p>
<ul>
<li><a href="https://github.com/WebAssembly/wasi-nn/blob/master/phases/ephemeral/witx/wasi_ephemeral_nn.witx#L108-L118"><code>Load</code></a> a model using variable opaque byte arrays</li>
<li><a href="https://github.com/WebAssembly/wasi-nn/blob/master/phases/ephemeral/witx/wasi_ephemeral_nn.witx#L125-L129"><code>Init_execution_context</code></a> and bind some tensors to it using <a href="https://github.com/WebAssembly/wasi-nn/blob/master/phases/ephemeral/witx/wasi_ephemeral_nn.witx#L134-L142"><code>set_input</code></a></li>
<li><a href="https://github.com/WebAssembly/wasi-nn/blob/master/phases/ephemeral/witx/wasi_ephemeral_nn.witx#L165-L168"><code>Compute</code></a> the ML inference using the bound context</li>
<li>Retrieve the inference result tensors using <a href="https://github.com/WebAssembly/wasi-nn/blob/master/phases/ephemeral/witx/wasi_ephemeral_nn.witx#L147-L160"><code>get_output</code></a></li>
</ul>
<p>You can find more detail about the WASI-NN proposal in <a href="write_wasm/rust/wasinn.html#reference">Reference</a>.</p>
<p>In this section, we will use <a href="https://github.com/second-state/WasmEdge-WASINN-examples">the example repository</a> to demonstrate how to use the <a href="https://crates.io/crates/wasi-nn">WASI-NN rust crate</a> to write the WASM and run an image classification demo with WasmEdge WASI-NN plug-in.</p>
<h2 id="prerequisites-5"><a class="header" href="#prerequisites-5">Prerequisites</a></h2>
<p>Currently, WasmEdge used OpenVINO™ or PyTorch as the WASI-NN backend implementation. For using WASI-NN on WasmEdge, you need to install <a href="https://docs.openvino.ai/2021.4/openvino_docs_install_guides_installing_openvino_linux.html#">OpenVINO™</a>(2021) or <a href="https://pytorch.org/get-started/locally/">PyTorch 1.8.2 LTS</a> for the backend.</p>
<p>In the current status, the <a href="write_wasm/rust/../../quick_start/install.html">WasmEdge Installer</a> will install the <code>manylinux2014</code> version of WasmEdge releases, but the WASI-NN plug-in for WasmEdge only supports <code>Ubuntu 20.04</code> or later now. Please refer to the following steps to get the WasmEdge with WASI-NN plug-in.</p>
<p>You can also <a href="write_wasm/rust/../../contribute/build_from_src/plugin_wasi_nn.html">build WasmEdge with WASI-NN plug-in from source</a>.</p>
<h3 id="get-wasmedge-with-wasi-nn-plug-in-openvino-backend"><a class="header" href="#get-wasmedge-with-wasi-nn-plug-in-openvino-backend">Get WasmEdge with WASI-NN Plug-in OpenVINO Backend</a></h3>
<p>First you should <a href="write_wasm/rust/../../contribute/build_from_src/plugin_wasi_nn.html#build-wasmedge-with-wasi-nn-openvino-backend">install the OpenVINO dependency</a>:</p>
<pre><code class="language-bash">export OPENVINO_VERSION=&quot;2021.4.582&quot;
export OPENVINO_YEAR=&quot;2021&quot;
curl -sSL https://apt.repos.intel.com/openvino/$OPENVINO_YEAR/GPG-PUB-KEY-INTEL-OPENVINO-$OPENVINO_YEAR | sudo gpg --dearmor &gt; /usr/share/keyrings/GPG-PUB-KEY-INTEL-OPENVINO-$OPENVINO_YEAR.gpg
echo &quot;deb [signed-by=/usr/share/keyrings/GPG-PUB-KEY-INTEL-OPENVINO-$OPENVINO_YEAR.gpg] https://apt.repos.intel.com/openvino/$OPENVINO_YEAR all main&quot; | sudo tee /etc/apt/sources.list.d/intel-openvino-$OPENVINO_YEAR.list
sudo apt update
sudo apt install -y intel-openvino-runtime-ubuntu20-$OPENVINO_VERSION
source /opt/intel/openvino_2021/bin/setupvars.sh
ldconfig
</code></pre>
<p>And then get the WasmEdge and the WASI-NN plug-in with OpenVINO backend:</p>
<pre><code class="language-bash">curl -sLO https://github.com/WasmEdge/WasmEdge/releases/download/0.11.1/WasmEdge-0.11.1-ubuntu20.04_x86_64.tar.gz
tar -zxf WasmEdge-0.11.1-ubuntu20.04_x86_64.tar.gz
rm -f WasmEdge-0.11.1-ubuntu20.04_x86_64.tar.gz
curl -sLO https://github.com/WasmEdge/WasmEdge/releases/download/0.11.1/WasmEdge-plugin-wasi_nn-openvino-0.11.1-ubuntu20.04_x86_64.tar.gz
tar -zxf WasmEdge-plugin-wasi_nn-openvino-0.11.1-ubuntu20.04_x86_64.tar.gz
rm -f WasmEdge-plugin-wasi_nn-openvino-0.11.1-ubuntu20.04_x86_64.tar.gz
mv libwasmedgePluginWasiNN.so WasmEdge-0.11.1-Linux/lib/wasmedge
export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:$(pwd)/WasmEdge-0.11.1-Linux/lib
export PATH=$PATH:$(pwd)/WasmEdge-0.11.1-Linux/bin
export WASMEDGE_PLUGIN_PATH=$(pwd)/WasmEdge-0.11.1-Linux/lib/wasmedge
</code></pre>
<h3 id="get-wasmedge-with-wasi-nn-plug-in-pytorch-backend"><a class="header" href="#get-wasmedge-with-wasi-nn-plug-in-pytorch-backend">Get WasmEdge with WASI-NN Plug-in PyTorch Backend</a></h3>
<p>First you should <a href="write_wasm/rust/../../contribute/build_from_src/plugin_wasi_nn.html#build-wasmedge-with-wasi-nn-pytorch-backend">install the PyTorch dependency</a>:</p>
<pre><code class="language-bash">export PYTORCH_VERSION=&quot;1.8.2&quot;
curl -s -L -O --remote-name-all https://download.pytorch.org/libtorch/lts/1.8/cpu/libtorch-cxx11-abi-shared-with-deps-${PYTORCH_VERSION}%2Bcpu.zip
unzip -q &quot;libtorch-cxx11-abi-shared-with-deps-${PYTORCH_VERSION}%2Bcpu.zip&quot;
rm -f &quot;libtorch-cxx11-abi-shared-with-deps-${PYTORCH_VERSION}%2Bcpu.zip&quot;
export LD_LIBRARY_PATH=${LD_LIBRARY_PATH}:$(pwd)/libtorch/lib
</code></pre>
<p>And then get the WasmEdge and the WASI-NN plug-in with PyTorch backend:</p>
<pre><code class="language-bash">curl -sLO https://github.com/WasmEdge/WasmEdge/releases/download/0.11.1/WasmEdge-0.11.1-ubuntu20.04_x86_64.tar.gz
tar -zxf WasmEdge-0.11.1-ubuntu20.04_x86_64.tar.gz
rm -f WasmEdge-0.11.1-ubuntu20.04_x86_64.tar.gz
curl -sLO https://github.com/WasmEdge/WasmEdge/releases/download/0.11.1/WasmEdge-plugin-wasi_nn-pytorch-0.11.1-ubuntu20.04_x86_64.tar.gz
tar -zxf WasmEdge-plugin-wasi_nn-pytorch-0.11.1-ubuntu20.04_x86_64.tar.gz
rm -f WasmEdge-plugin-wasi_nn-pytorch-0.11.1-ubuntu20.04_x86_64.tar.gz
mv libwasmedgePluginWasiNN.so WasmEdge-0.11.1-Linux/lib/wasmedge
export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:$(pwd)/WasmEdge-0.11.1-Linux/lib
export PATH=$PATH:$(pwd)/WasmEdge-0.11.1-Linux/bin
export WASMEDGE_PLUGIN_PATH=$(pwd)/WasmEdge-0.11.1-Linux/lib/wasmedge
</code></pre>
<h2 id="write-webassembly-using-wasi-nn"><a class="header" href="#write-webassembly-using-wasi-nn">Write WebAssembly Using WASI-NN</a></h2>
<p>You can refer to the <a href="https://github.com/second-state/WasmEdge-WASINN-examples/tree/master/openvino-mobilenet-image">OpenVINO backend example</a> and the <a href="https://github.com/second-state/WasmEdge-WASINN-examples/tree/master/pytorch-mobilenet-image">PyTorch backend example</a>.</p>
<h3 id="optional-rust-installation"><a class="header" href="#optional-rust-installation">(Optional) Rust Installation</a></h3>
<p>If you want to build the example WASM from Rust by yourself, the <a href="https://doc.rust-lang.org/book/ch01-01-installation.html">Rust inatallation</a> is required.</p>
<pre><code class="language-bash">curl --proto '=https' --tlsv1.2 https://sh.rustup.rs -sSf | sh -s -- -y
source &quot;$HOME/.cargo/env&quot;
</code></pre>
<p>And make sure to add <code>wasm32-wasi</code> target with the following command:</p>
<pre><code class="language-bash">rustup target add wasm32-wasi
</code></pre>
<h3 id="optional-building-the-wasm-file-from-rust-source"><a class="header" href="#optional-building-the-wasm-file-from-rust-source">(Optional) Building the WASM File From Rust Source</a></h3>
<p>First get the example repository:</p>
<pre><code class="language-bash">git clone https://github.com/second-state/WasmEdge-WASINN-examples.git
cd WasmEdge-WASINN-examples
</code></pre>
<p>To build the OpenVINO example WASM, run:</p>
<pre><code class="language-bash">cd openvino-mobilenet-image/rust
cargo build --release --target=wasm32-wasi
</code></pre>
<p>The outputted <a href="https://github.com/second-state/WasmEdge-WASINN-examples/raw/master/openvino-mobilenet-image/wasmedge-wasinn-example-mobilenet-image.wasm"><code>wasmedge-wasinn-example-mobilenet-image.wasm</code></a> will be under <code>rust/target/wasm32-wasi/release/</code>.</p>
<p>To build the PyTorch example WASM, run:</p>
<pre><code class="language-bash">cd pytorch-mobilenet-image/rust
cargo build --release --target=wasm32-wasi
</code></pre>
<p>The outputted <a href="https://github.com/second-state/WasmEdge-WASINN-examples/raw/master/pytorch-mobilenet-image/wasmedge-wasinn-example-mobilenet-image.wasm"><code>wasmedge-wasinn-example-mobilenet-image.wasm</code></a> will be under <code>rust/target/wasm32-wasi/release/</code>.</p>
<p>We can find that the outputted WASM files import the necessary WASI-NN functions by converting into WAT format with tools like <a href="https://webassembly.github.io/wabt/demo/wasm2wat/"><code>wasm2wat</code></a>:</p>
<pre><code class="language-wasm"> ...
 (import &quot;wasi_ephemeral_nn&quot; &quot;load&quot; (func $_ZN7wasi_nn9generated17wasi_ephemeral_nn4load17hdca997591f45db43E (type 8)))
  (import &quot;wasi_ephemeral_nn&quot; &quot;init_execution_context&quot; (func $_ZN7wasi_nn9generated17wasi_ephemeral_nn22init_execution_context17h2cb3b4398c18d1fdE (type 4)))
  (import &quot;wasi_ephemeral_nn&quot; &quot;set_input&quot; (func $_ZN7wasi_nn9generated17wasi_ephemeral_nn9set_input17h4d10422433f5c246E (type 7)))
  (import &quot;wasi_ephemeral_nn&quot; &quot;get_output&quot; (func $_ZN7wasi_nn9generated17wasi_ephemeral_nn10get_output17h117ce8ea097ddbebE (type 8)))
  (import &quot;wasi_ephemeral_nn&quot; &quot;compute&quot; (func $_ZN7wasi_nn9generated17wasi_ephemeral_nn7compute17h96ef5b407fe8173aE (type 5)))
  ...
</code></pre>
<h3 id="using-wasi-nn-with-openvino-backend-in-rust"><a class="header" href="#using-wasi-nn-with-openvino-backend-in-rust">Using WASI-NN with OpenVINO™ Backend in Rust</a></h3>
<p>The <a href="https://github.com/second-state/WasmEdge-WASINN-examples/tree/master/openvino-mobilenet-image/rust/src/main.rs">main.rs</a> is the full example Rust source.</p>
<p>First, read the model description and weights into memory:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let args: Vec&lt;String&gt; = env::args().collect();
let model_xml_name: &amp;str = &amp;args[1]; // File name for the model xml
let model_bin_name: &amp;str = &amp;args[2]; // File name for the weights
let image_name: &amp;str = &amp;args[3]; // File name for the input image

let xml = fs::read_to_string(model_xml_name).unwrap();
let weights = fs::read(model_bin_name).unwrap();
<span class="boring">}
</span></code></pre></pre>
<p>We should use a helper function to convert the input image into the tensor data (the tensor type is <code>F32</code>):</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn image_to_tensor(path: String, height: u32, width: u32) -&gt; Vec&lt;u8&gt; {
  let pixels = Reader::open(path).unwrap().decode().unwrap();
  let dyn_img: DynamicImage = pixels.resize_exact(width, height, image::imageops::Triangle);
  let bgr_img = dyn_img.to_bgr8();
  // Get an array of the pixel values
  let raw_u8_arr: &amp;[u8] = &amp;bgr_img.as_raw()[..];
  // Create an array to hold the f32 value of those pixels
  let bytes_required = raw_u8_arr.len() * 4;
  let mut u8_f32_arr: Vec&lt;u8&gt; = vec![0; bytes_required];

  for i in 0..raw_u8_arr.len() {
    // Read the number as a f32 and break it into u8 bytes
    let u8_f32: f32 = raw_u8_arr[i] as f32;
    let u8_bytes = u8_f32.to_ne_bytes();

    for j in 0..4 {
      u8_f32_arr[(i * 4) + j] = u8_bytes[j];
    }
  }
  return u8_f32_arr;
}
<span class="boring">}
</span></code></pre></pre>
<p>And use this helper funcion to convert the input image:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let tensor_data = image_to_tensor(image_name.to_string(), 224, 224);
<span class="boring">}
</span></code></pre></pre>
<p>Now we can start our inference with WASI-NN:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// load model
let graph = unsafe {
  wasi_nn::load(
    &amp;[&amp;xml.into_bytes(), &amp;weights],
    wasi_nn::GRAPH_ENCODING_OPENVINO,
    wasi_nn::EXECUTION_TARGET_CPU,
  )
  .unwrap()
};
// initialize the computation context
let context = unsafe { wasi_nn::init_execution_context(graph).unwrap() };
// initialize the input tensor
let tensor = wasi_nn::Tensor {
  dimensions: &amp;[1, 3, 224, 224],
  r#type: wasi_nn::TENSOR_TYPE_F32,
  data: &amp;tensor_data,
};
// set_input
unsafe {
  wasi_nn::set_input(context, 0, tensor).unwrap();
}
// Execute the inference.
unsafe {
  wasi_nn::compute(context).unwrap();
}
// retrieve output
let mut output_buffer = vec![0f32; 1001];
unsafe {
  wasi_nn::get_output(
    context,
    0,
    &amp;mut output_buffer[..] as *mut [f32] as *mut u8,
    (output_buffer.len() * 4).try_into().unwrap(),
  )
  .unwrap();
}
<span class="boring">}
</span></code></pre></pre>
<p>Where the <code>wasi_nn::GRAPH_ENCODING_OPENVINO</code> means using the OpenVINO™ backend, and <code>wasi_nn::EXECUTION_TARGET_CPU</code> means running the computation on CPU.</p>
<p>Finally, we sort the output and then print the top-5 classification result:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let results = sort_results(&amp;output_buffer);
for i in 0..5 {
  println!(
    &quot;   {}.) [{}]({:.4}){}&quot;,
    i + 1,
    results[i].0,
    results[i].1,
    imagenet_classes::IMAGENET_CLASSES[results[i].0]
  );
}
<span class="boring">}
</span></code></pre></pre>
<h3 id="using-wasi-nn-with-pytorch-backend-in-rust"><a class="header" href="#using-wasi-nn-with-pytorch-backend-in-rust">Using WASI-NN with PyTorch Backend in Rust</a></h3>
<p>The <a href="https://github.com/second-state/WasmEdge-WASINN-examples/tree/master/pytorch-mobilenet-image/rust/src/main.rs">main.rs</a> is the full example Rust source.</p>
<p>First, read the model description and weights into memory:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let args: Vec&lt;String&gt; = env::args().collect();
let model_bin_name: &amp;str = &amp;args[1]; // File name for the pytorch model
let image_name: &amp;str = &amp;args[2]; // File name for the input image

let weights = fs::read(model_bin_name).unwrap();
<span class="boring">}
</span></code></pre></pre>
<p>We should use a helper function to convert the input image into the tensor data (the tensor type is <code>F32</code>):</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn image_to_tensor(path: String, height: u32, width: u32) -&gt; Vec&lt;u8&gt; {
  let mut file_img = File::open(path).unwrap();
  let mut img_buf = Vec::new();
  file_img.read_to_end(&amp;mut img_buf).unwrap();
  let img = image::load_from_memory(&amp;img_buf).unwrap().to_rgb8();
  let resized =
      image::imageops::resize(&amp;img, height, width, ::image::imageops::FilterType::Triangle);
  let mut flat_img: Vec&lt;f32&gt; = Vec::new();
  for rgb in resized.pixels() {
    flat_img.push((rgb[0] as f32 / 255. - 0.485) / 0.229);
    flat_img.push((rgb[1] as f32 / 255. - 0.456) / 0.224);
    flat_img.push((rgb[2] as f32 / 255. - 0.406) / 0.225);
  }
  let bytes_required = flat_img.len() * 4;
  let mut u8_f32_arr: Vec&lt;u8&gt; = vec![0; bytes_required];

  for c in 0..3 {
    for i in 0..(flat_img.len() / 3) {
      // Read the number as a f32 and break it into u8 bytes
      let u8_f32: f32 = flat_img[i * 3 + c] as f32;
      let u8_bytes = u8_f32.to_ne_bytes();

      for j in 0..4 {
        u8_f32_arr[((flat_img.len() / 3 * c + i) * 4) + j] = u8_bytes[j];
      }
    }
  }
  return u8_f32_arr;
}
<span class="boring">}
</span></code></pre></pre>
<p>And use this helper funcion to convert the input image:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let tensor_data = image_to_tensor(image_name.to_string(), 224, 224);
<span class="boring">}
</span></code></pre></pre>
<p>Now we can start our inference with WASI-NN:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// load model
let graph = unsafe {
  wasi_nn::load(
    &amp;[&amp;weights],
    1, //wasi_nn::GRAPH_ENCODING_TORCH
    wasi_nn::EXECUTION_TARGET_CPU,
  )
  .unwrap()
};
// initialize the computation context
let context = unsafe { wasi_nn::init_execution_context(graph).unwrap() };
// initialize the input tensor
let tensor = wasi_nn::Tensor {
  dimensions: &amp;[1, 3, 224, 224],
  r#type: wasi_nn::TENSOR_TYPE_F32,
  data: &amp;tensor_data,
};
// set_input
unsafe {
  wasi_nn::set_input(context, 0, tensor).unwrap();
}
// Execute the inference.
unsafe {
  wasi_nn::compute(context).unwrap();
}
// retrieve output
let mut output_buffer = vec![0f32; 1001];
unsafe {
  wasi_nn::get_output(
    context,
    0,
    &amp;mut output_buffer[..] as *mut [f32] as *mut u8,
    (output_buffer.len() * 4).try_into().unwrap(),
  )
  .unwrap();
}
<span class="boring">}
</span></code></pre></pre>
<p>Where the <code>wasi_nn::GRAPH_ENCODING_TORCH</code> means using the PyTorch backend (now use the value <code>1</code> instead), and <code>wasi_nn::EXECUTION_TARGET_CPU</code> means running the computation on CPU.</p>
<p>Finally, we sort the output and then print the top-5 classification result:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let results = sort_results(&amp;output_buffer);
for i in 0..5 {
  println!(
    &quot;   {}.) [{}]({:.4}){}&quot;,
    i + 1,
    results[i].0,
    results[i].1,
    imagenet_classes::IMAGENET_CLASSES[results[i].0]
  );
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="run-1"><a class="header" href="#run-1">Run</a></h2>
<h3 id="openvino-backend-example"><a class="header" href="#openvino-backend-example">OpenVINO Backend Example</a></h3>
<p>Please <a href="write_wasm/rust/wasinn.html#prerequisites">install WasmEdge with the WASI-NN OpenVINO backend plug-in</a> first.</p>
<p>For the example demo of <a href="https://arxiv.org/abs/1704.04861">Mobilenet</a>, we need the <a href="https://github.com/intel/openvino-rs/raw/v0.3.3/crates/openvino/tests/fixtures/mobilenet/">fixture files</a>:</p>
<ul>
<li><code>wasmedge-wasinn-example-mobilenet.wasm</code>: the <a href="https://github.com/second-state/WasmEdge-WASINN-examples/raw/master/openvino-mobilenet-image/wasmedge-wasinn-example-mobilenet-image.wasm">built WASM from rust</a></li>
<li><code>mobilenet.xml</code>: the model description.</li>
<li><code>mobilenet.bin</code>: the model weights.</li>
<li><code>input.jpg</code>: the input image (224x224 JPEG).</li>
</ul>
<p>The above Mobilenet artifacts are generated by <a href="https://docs.openvino.ai/2021.4/openvino_docs_MO_DG_Deep_Learning_Model_Optimizer_DevGuide.html">OpenVINO™ Model Optimizer</a>. Thanks for the amazing jobs done by Andrew Brown, you can find the artifacts and a <code>build.sh</code> which can regenerate the artifacts <a href="https://github.com/intel/openvino-rs/tree/main/crates/openvino/tests/fixtures/mobilenet">here</a>.</p>
<p>You can download these files by the following commands:</p>
<pre><code class="language-bash">curl -sLO https://github.com/second-state/WasmEdge-WASINN-examples/raw/master/openvino-mobilenet-image/wasmedge-wasinn-example-mobilenet-image.wasm
curl -sLO https://github.com/intel/openvino-rs/raw/v0.3.3/crates/openvino/tests/fixtures/mobilenet/mobilenet.bin
curl -sLO https://github.com/intel/openvino-rs/raw/v0.3.3/crates/openvino/tests/fixtures/mobilenet/mobilenet.xml
curl -sL -o input.jpg https://github.com/bytecodealliance/wasi-nn/raw/main/rust/examples/images/1.jpg
</code></pre>
<p>Then you can use the OpenVINO-enabled WasmEdge which was compiled above to execute the WASM file (in interpreter mode):</p>
<pre><code class="language-bash">wasmedge --dir .:. wasmedge-wasinn-example-mobilenet.wasm mobilenet.xml mobilenet.bin input.jpg
# If you didn't install the project, you should give the `WASMEDGE_PLUGIN_PATH` environment variable for specifying the WASI-NN plugin path.
</code></pre>
<p>If everything goes well, you should have the terminal output:</p>
<pre><code class="language-bash">Read graph XML, size in bytes: 143525
Read graph weights, size in bytes: 13956476
Loaded graph into wasi-nn with ID: 0
Created wasi-nn execution context with ID: 0
Read input tensor, size in bytes: 602112
Executed graph inference
   1.) [954](0.9789)banana
   2.) [940](0.0074)spaghetti squash
   3.) [951](0.0014)lemon
   4.) [969](0.0005)eggnog
   5.) [942](0.0005)butternut squash
</code></pre>
<p>For the AOT mode which is much more quickly, you can compile the WASM first:</p>
<pre><code class="language-bash">wasmedgec wasmedge-wasinn-example-mobilenet.wasm out.wasm
wasmedge --dir .:. out.wasm mobilenet.xml mobilenet.bin input.jpg
</code></pre>
<h3 id="pytorch-backend-example"><a class="header" href="#pytorch-backend-example">PyTorch Backend Example</a></h3>
<p>Please <a href="write_wasm/rust/wasinn.html#prerequisites">install WasmEdge with the WASI-NN PyTorch backend plug-in</a> first.</p>
<p>For the example demo of <a href="https://arxiv.org/abs/1704.04861">Mobilenet</a>, we need these following files:</p>
<ul>
<li><code>wasmedge-wasinn-example-mobilenet.wasm</code>: the <a href="https://github.com/second-state/WasmEdge-WASINN-examples/raw/master/pytorch-mobilenet-image/wasmedge-wasinn-example-mobilenet-image.wasm">built WASM from rust</a></li>
<li><code>mobilenet.pt</code>: the PyTorch Mobilenet model.</li>
<li><code>input.jpg</code>: the input image (224x224 JPEG).</li>
</ul>
<p>The above Mobilenet PyTorch model is generated by <a href="https://github.com/second-state/WasmEdge-WASINN-examples/blob/master/pytorch-mobilenet-image/gen_mobilenet_model.py">the Python code</a>.</p>
<p>You can download these files by the following commands:</p>
<pre><code class="language-bash">curl -sLO https://github.com/second-state/WasmEdge-WASINN-examples/raw/master/pytorch-mobilenet-image/wasmedge-wasinn-example-mobilenet-image.wasm
curl -sLO https://github.com/second-state/WasmEdge-WASINN-examples/raw/master/pytorch-mobilenet-image/mobilenet.pt
curl -sL -o input.jpg https://github.com/bytecodealliance/wasi-nn/raw/main/rust/examples/images/1.jpg
</code></pre>
<p>Then you can use the PyTorch-enabled WasmEdge which was compiled above to execute the WASM file (in interpreter mode):</p>
<pre><code class="language-bash"># Please check that you've already install the libtorch and set the `LD_LIBRARY_PATH`.
wasmedge --dir .:. wasmedge-wasinn-example-mobilenet.wasm mobilenet.pt input.jpg
# If you didn't install the project, you should give the `WASMEDGE_PLUGIN_PATH` environment variable for specifying the WASI-NN plugin path.
</code></pre>
<p>If everything goes well, you should have the terminal output:</p>
<pre><code class="language-bash">Read torchscript binaries, size in bytes: 14376924
Loaded graph into wasi-nn with ID: 0
Created wasi-nn execution context with ID: 0
Read input tensor, size in bytes: 602112
Executed graph inference
   1.) [954](20.6681)banana
   2.) [940](12.1483)spaghetti squash
   3.) [951](11.5748)lemon
   4.) [950](10.4899)orange
   5.) [953](9.4834)pineapple, ananas
</code></pre>
<p>For the AOT mode which is much more quickly, you can compile the WASM first:</p>
<pre><code class="language-bash">wasmedgec wasmedge-wasinn-example-mobilenet.wasm out.wasm
wasmedge --dir .:. out.wasm mobilenet.pt input.jpg
</code></pre>
<h2 id="reference"><a class="header" href="#reference">Reference</a></h2>
<p>The intoduction of WASI-NN can be referred to <a href="https://bytecodealliance.org/articles/using-wasi-nn-in-wasmtime">this amazing blog</a> written by Andrew Brown. This demo is greatly adapted from another <a href="https://github.com/radu-matei/wasi-nn-guest">demo</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="crypto-for-wasi"><a class="header" href="#crypto-for-wasi">Crypto for WASI</a></h1>
<p>While optimizing compilers could allow efficient implementation of cryptographic features in WebAssembly, there are several occasions as below where a host implementation is more desirable. <a href="https://github.com/WebAssembly/wasi-crypto/blob/main/docs/HighLevelGoals.md">WASI-crypto</a> aims to fill those gaps by defining a standard interface as a set of APIs.
Current not support android.</p>
<h2 id="prerequisites-6"><a class="header" href="#prerequisites-6">Prerequisites</a></h2>
<p>In the current status, the <a href="write_wasm/rust/../../quick_start/install.html">WasmEdge Installer</a> will install the <code>manylinux2014</code> version of WasmEdge releases on Linux platforms.</p>
<p>For installation with the installer, you can follow the commands:</p>
<pre><code class="language-bash">curl -sSf https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/utils/install.sh | bash -s -- -v 0.11.1
curl -sLO https://github.com/WasmEdge/WasmEdge/releases/download/0.11.1/WasmEdge-plugin-wasi_crypto-0.11.1-manylinux2014_x86_64.tar.gz
tar -zxf WasmEdge-plugin-wasi_crypto-0.11.1-manylinux2014_x86_64.tar.gz
rm -f WasmEdge-plugin-wasi_crypto-0.11.1-manylinux2014_x86_64.tar.gz
mv libwasmedgePluginWasiCrypto.so $HOME/.wasmedge/plugin
</code></pre>
<p>If you choose to install WasmEdge under <code>/usr</code>, please note that the plug-in path is different:</p>
<pre><code class="language-bash">curl -sSf https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/utils/install.sh | bash -s -- -v 0.11.1 -p /usr/local
curl -sLO https://github.com/WasmEdge/WasmEdge/releases/download/0.11.1/WasmEdge-plugin-wasi_crypto-0.11.1-manylinux2014_x86_64.tar.gz
tar -zxf WasmEdge-plugin-wasi_crypto-0.11.1-manylinux2014_x86_64.tar.gz
rm -f WasmEdge-plugin-wasi_crypto-0.11.1-manylinux2014_x86_64.tar.gz
mv libwasmedgePluginWasiCrypto.so /usr/local/lib/wasmedge/
</code></pre>
<p>If you want to use the <code>Ubuntu 20.04</code> version, please install with the following commands:</p>
<pre><code class="language-bash">curl -sLO https://github.com/WasmEdge/WasmEdge/releases/download/0.11.1/WasmEdge-0.11.1-ubuntu20.04_x86_64.tar.gz
tar -zxf WasmEdge-0.11.1-ubuntu20.04_x86_64.tar.gz
rm -f WasmEdge-0.11.1-ubuntu20.04_x86_64.tar.gz
curl -sLO https://github.com/WasmEdge/WasmEdge/releases/download/0.11.1/WasmEdge-plugin-wasi_crypto-0.11.1-ubuntu20.04_x86_64.tar.gz
tar -zxf WasmEdge-plugin-wasi_crypto-0.11.1-ubuntu20.04_x86_64.tar.gz
rm -f WasmEdge-plugin-wasi_crypto-0.11.1-ubuntu20.04_x86_64.tar.gz
mv libwasmedgePluginWasiCrypto.so WasmEdge-0.11.1-Linux/lib/wasmedge
export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:$(pwd)/WasmEdge-0.11.1-Linux/lib
export PATH=$PATH:$(pwd)/WasmEdge-0.11.1-Linux/bin
export WASMEDGE_PLUGIN_PATH=$(pwd)/WasmEdge-0.11.1-Linux/lib/wasmedge
</code></pre>
<blockquote>
<p>The <code>manylinux2014</code> WasmEdge should use the <code>manylinux2014</code> version of plug-in, while the <code>Ubuntu 20.04</code> WasmEdge should also use the <code>Ubuntu 20.04</code> version of plug-in, too.</p>
</blockquote>
<p>You can also <a href="write_wasm/rust/../../contribute/build_from_src/plugin_wasi_crypto.html">build WasmEdge with WASI-Crypto plug-in from source</a>.</p>
<h2 id="write-webassembly-using-wasi-crypto"><a class="header" href="#write-webassembly-using-wasi-crypto">Write WebAssembly Using WASI-Crypto</a></h2>
<h3 id="optional-rust-installation-1"><a class="header" href="#optional-rust-installation-1">(Optional) Rust Installation</a></h3>
<p>For importing WASI-Crypto in rust, you should use the <a href="https://github.com/WebAssembly/wasi-crypto/tree/main/implementations/bindings/rust">wasi-crypto binding</a> in your cargo.toml</p>
<pre><code class="language-toml">[dependencies]
wasi-crypto = &quot;0.1.5&quot;
</code></pre>
<h3 id="high-level-operations"><a class="header" href="#high-level-operations">High Level Operations</a></h3>
<h4 id="hash-function"><a class="header" href="#hash-function">Hash Function</a></h4>
<div class="table-wrapper"><table><thead><tr><th>Identifier</th><th>Algorithm</th></tr></thead><tbody>
<tr><td><code>SHA-256</code></td><td>SHA-256 hash function</td></tr>
<tr><td><code>SHA-512</code></td><td>SHA-512 hash function</td></tr>
<tr><td><code>SHA-512/256</code></td><td>SHA-512/256 hash function with a specific IV</td></tr>
</tbody></table>
</div>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// hash &quot;test&quot; by SHA-256
let hash : Vec&lt;u8&gt; = Hash::hash(&quot;SHA-256&quot;, b&quot;test&quot;, 32, None)?;
assert_eq!(hash.len(), 32);
<span class="boring">}
</span></code></pre></pre>
<h4 id="message-authentications-function"><a class="header" href="#message-authentications-function">Message Authentications function</a></h4>
<div class="table-wrapper"><table><thead><tr><th>Identifier</th><th>Algorithm</th></tr></thead><tbody>
<tr><td><code>HMAC/SHA-256</code></td><td>RFC2104 MAC using the SHA-256 hash function</td></tr>
<tr><td><code>HMAC/SHA-512</code></td><td>RFC2104 MAC using the SHA-512 hash function</td></tr>
</tbody></table>
</div>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// generate key
let key = AuthKey::generate(&quot;HMAC/SHA-512&quot;)?;
// generate tag
let tag = Auth::auth(&quot;test&quot;, &amp;key)?;
// verify
Auth::auth_verify(&quot;test&quot;, &amp;key, tag)?;
<span class="boring">}
</span></code></pre></pre>
<h4 id="key-driven-function"><a class="header" href="#key-driven-function">Key Driven function</a></h4>
<div class="table-wrapper"><table><thead><tr><th>Identifier</th><th>Algorithm</th></tr></thead><tbody>
<tr><td><code>HKDF-EXTRACT/SHA-256</code></td><td>RFC5869 <code>EXTRACT</code> function using the SHA-256 hash function</td></tr>
<tr><td><code>HKDF-EXTRACT/SHA-512</code></td><td>RFC5869 <code>EXTRACT</code> function using the SHA-512 hash function</td></tr>
<tr><td><code>HKDF-EXPAND/SHA-256</code></td><td>RFC5869 <code>EXPAND</code> function using the SHA-256 hash function</td></tr>
<tr><td><code>HKDF-EXPAND/SHA-512</code></td><td>RFC5869 <code>EXPAND</code> function using the SHA-512 hash function</td></tr>
</tbody></table>
</div>
<p>Example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let key = HkdfKey::generate(&quot;HKDF-EXTRACT/SHA-512&quot;)?;
let prk = Hkdf::new(&quot;HKDF-EXPAND/SHA-512&quot;, &amp;key, Some(b&quot;salt&quot;))?;
let derived_key = prk.expand(&quot;info&quot;, 100)?;
assert_eq!(derived_key.len(), 100);
<span class="boring">}
</span></code></pre></pre>
<h4 id="signatures-operation"><a class="header" href="#signatures-operation">Signatures Operation</a></h4>
<div class="table-wrapper"><table><thead><tr><th>Identifier</th><th>Algorithm</th></tr></thead><tbody>
<tr><td><code>ECDSA_P256_SHA256</code></td><td>ECDSA over the NIST p256 curve with the SHA-256 hash function</td></tr>
<tr><td><code>ECDSA_K256_SHA256</code></td><td>ECDSA over the secp256k1 curve with the SHA-256 hash function</td></tr>
<tr><td><code>Ed25519</code></td><td>Edwards Curve signatures over Edwards25519 (pure EdDSA) as specified in RFC8032</td></tr>
<tr><td><code>RSA_PKCS1_2048_SHA256</code></td><td>RSA signatures with a 2048 bit modulus, PKCS1 padding and the SHA-256 hash function</td></tr>
<tr><td><code>RSA_PKCS1_2048_SHA384</code></td><td>RSA signatures with a 2048 bit modulus, PKCS1 padding and the SHA-384 hash function</td></tr>
<tr><td><code>RSA_PKCS1_2048_SHA512</code></td><td>RSA signatures with a 2048 bit modulus, PKCS1 padding and the SHA-512 hash function</td></tr>
<tr><td><code>RSA_PKCS1_3072_SHA384</code></td><td>RSA signatures with a 3072 bit modulus, PKCS1 padding and the SHA-384 hash function</td></tr>
<tr><td><code>RSA_PKCS1_3072_SHA512</code></td><td>RSA signatures with a 3072 bit modulus, PKCS1 padding and the SHA-512 hash function</td></tr>
<tr><td><code>RSA_PKCS1_4096_SHA512</code></td><td>RSA signatures with a 4096 bit modulus, PKCS1 padding and the SHA-512 hash function</td></tr>
<tr><td><code>RSA_PSS_2048_SHA256</code></td><td>RSA signatures with a 2048 bit modulus, PSS padding and the SHA-256 hash function</td></tr>
<tr><td><code>RSA_PSS_2048_SHA384</code></td><td>RSA signatures with a 2048 bit modulus, PSS padding and the SHA-384 hash function</td></tr>
<tr><td><code>RSA_PSS_2048_SHA512</code></td><td>RSA signatures with a 2048 bit modulus, PSS padding and the SHA-512 hash function</td></tr>
<tr><td><code>RSA_PSS_3072_SHA384</code></td><td>RSA signatures with a 2048 bit modulus, PSS padding and the SHA-384 hash function</td></tr>
<tr><td><code>RSA_PSS_3072_SHA512</code></td><td>RSA signatures with a 3072 bit modulus, PSS padding and the SHA-512 hash function</td></tr>
<tr><td><code>RSA_PSS_4096_SHA512</code></td><td>RSA signatures with a 4096 bit modulus, PSS padding and the SHA-512 hash function</td></tr>
</tbody></table>
</div>
<p>Example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let pk = SignaturePublicKey::from_raw(&quot;Ed25519&quot;, &amp;[0; 32])?;

let kp = SignatureKeyPair::generate(&quot;Ed25519&quot;)?;
let signature = kp.sign(&quot;hello&quot;)?;

kp.publickey()?.signature_verify(&quot;hello&quot;, &amp;signature)?;
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="simple-networking-sockets"><a class="header" href="#simple-networking-sockets">Simple Networking Sockets</a></h1>
<p>The <a href="https://github.com/second-state/wasmedge_wasi_socket">wasmedge_wasi_socket</a> crate enables Rust developers to create networking applications and compile them into WebAssembly for WasmEdge Runtime. One of the key features of WasmEdge is that it supports non-blocking sockets. That allows even a single threaded WASM application to handle concurrent network requests. For example, while the program is waiting for data to stream in from one connection, it can start or handle another connection.</p>
<p>In this chapter, we will start with simple HTTP client and server examples. Then <a href="write_wasm/rust/networking-nonblocking.html">in the next chapter</a>, we will cover the more complex non-blocking examples. And <a href="write_wasm/rust/networking-https.html">in this chapter</a>, we will give the examples for HTTPS requests.</p>
<h2 id="an-http-client-example"><a class="header" href="#an-http-client-example">An HTTP client example</a></h2>
<p>The <a href="https://github.com/second-state/wasmedge_wasi_socket/tree/main/examples/http_client">source code</a> for the HTTP client is available as follows.</p>
<pre><pre class="playground"><code class="language-rust">use wasmedge_http_req::request;

fn main() {
  let mut writer = Vec::new(); //container for body of a response
  let res = request::get(&quot;http://127.0.0.1:1234/get&quot;, &amp;mut writer).unwrap();

  println!(&quot;GET&quot;);
  println!(&quot;Status: {} {}&quot;, res.status_code(), res.reason());
  println!(&quot;Headers {}&quot;, res.headers());
  println!(&quot;{}&quot;, String::from_utf8_lossy(&amp;writer));

  let mut writer = Vec::new(); //container for body of a response
  const BODY: &amp;[u8; 27] = b&quot;field1=value1&amp;field2=value2&quot;;
  // let res = request::post(&quot;https://httpbin.org/post&quot;, BODY, &amp;mut writer).unwrap();
  // no https , no dns
  let res = request::post(&quot;http://127.0.0.1:1234/post&quot;, BODY, &amp;mut writer).unwrap();

  println!(&quot;POST&quot;);
  println!(&quot;Status: {} {}&quot;, res.status_code(), res.reason());
  println!(&quot;Headers {}&quot;, res.headers());
  println!(&quot;{}&quot;, String::from_utf8_lossy(&amp;writer));
}
</code></pre></pre>
<p>The following command compiles the Rust program.</p>
<pre><code class="language-bash">cargo build --target wasm32-wasi --release
</code></pre>
<p>The following command runs the application in WasmEdge.</p>
<pre><code class="language-bash">wasmedge target/wasm32-wasi/release/http_client.wasm
</code></pre>
<blockquote>
<p>Noticed that you should <a href="write_wasm/rust/networking-https.html#prerequisites">install the WasmEdge-HttpsReq plug-in</a>.</p>
</blockquote>
<h2 id="an-http-server-example"><a class="header" href="#an-http-server-example">An HTTP server example</a></h2>
<p>The <a href="https://github.com/second-state/wasmedge_wasi_socket/tree/main/examples/http_server">source code</a> for the HTTP server application is available as follows.</p>
<pre><pre class="playground"><code class="language-rust">use bytecodec::DecodeExt;
use httpcodec::{HttpVersion, ReasonPhrase, Request, RequestDecoder, Response, StatusCode};
use std::io::{Read, Write};
#[cfg(feature = &quot;std&quot;)]
use std::net::{Shutdown, TcpListener, TcpStream};
#[cfg(not(feature = &quot;std&quot;))]
use wasmedge_wasi_socket::{Shutdown, TcpListener, TcpStream};

fn handle_http(req: Request&lt;String&gt;) -&gt; bytecodec::Result&lt;Response&lt;String&gt;&gt; {
  Ok(Response::new(
    HttpVersion::V1_0,
    StatusCode::new(200)?,
    ReasonPhrase::new(&quot;&quot;)?,
    format!(&quot;echo: {}&quot;, req.body()),
  ))
}

fn handle_client(mut stream: TcpStream) -&gt; std::io::Result&lt;()&gt; {
  let mut buff = [0u8; 1024];
  let mut data = Vec::new();

  loop {
    let n = stream.read(&amp;mut buff)?;
    data.extend_from_slice(&amp;buff[0..n]);
    if n &lt; 1024 {
      break;
    }
  }

  let mut decoder =
    RequestDecoder::&lt;httpcodec::BodyDecoder&lt;bytecodec::bytes::Utf8Decoder&gt;&gt;::default();

  let req = match decoder.decode_from_bytes(data.as_slice()) {
    Ok(req) =&gt; handle_http(req),
    Err(e) =&gt; Err(e),
  };

  let r = match req {
    Ok(r) =&gt; r,
    Err(e) =&gt; {
      let err = format!(&quot;{:?}&quot;, e);
      Response::new(
        HttpVersion::V1_0,
        StatusCode::new(500).unwrap(),
        ReasonPhrase::new(err.as_str()).unwrap(),
        err.clone(),
      )
    }
  };

  let write_buf = r.to_string();
  stream.write(write_buf.as_bytes())?;
  stream.shutdown(Shutdown::Both)?;
  Ok(())
}

fn main() -&gt; std::io::Result&lt;()&gt; {
  let port = std::env::var(&quot;PORT&quot;).unwrap_or(1234.to_string());
  println!(&quot;new connection at {}&quot;, port);
  let listener = TcpListener::bind(format!(&quot;0.0.0.0:{}&quot;, port))?;
  loop {
    let _ = handle_client(listener.accept()?.0);
  }
}
</code></pre></pre>
<p>The following command compiles the Rust program.</p>
<pre><code class="language-bash">cargo build --target wasm32-wasi --release
</code></pre>
<p>The following command runs the application in WasmEdge.</p>
<pre><code class="language-bash">$ wasmedge target/wasm32-wasi/release/http_server.wasm
new connection at 1234
</code></pre>
<p>To test the HTTP server, you can submit a HTTP request to it via <code>curl</code>.</p>
<pre><code class="language-bash">$ curl -d &quot;name=WasmEdge&quot; -X POST http://127.0.0.1:1234
echo: name=WasmEdge
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="networking-for-https"><a class="header" href="#networking-for-https">Networking for HTTPS</a></h1>
<p>The WasmEdge WASI socket API supports HTTP networking in Wasm apps. In order to achieve the goal of supporting HTTPS requests with the same API as an HTTP request, we now create a WasmEdge plugin using the OpenSSL library. In this chapter, we will give the example of HTTPS requests and explain the design.</p>
<h2 id="prerequisites-7"><a class="header" href="#prerequisites-7">Prerequisites</a></h2>
<p>In the current status, the <a href="write_wasm/rust/../../quick_start/install.html">WasmEdge Installer</a> will install the <code>manylinux2014</code> version of WasmEdge releases on Linux platforms.</p>
<p>For installation with the installer, you can follow the commands:</p>
<pre><code class="language-bash">curl -sSf https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/utils/install.sh | bash -s -- -v 0.11.1
curl -sLO https://github.com/WasmEdge/WasmEdge/releases/download/0.11.1/WasmEdge-plugin-wasmedge_httpsreq-0.11.1-manylinux2014_x86_64.tar.gz
tar -zxf WasmEdge-plugin-wasmedge_httpsreq-0.11.1-manylinux2014_x86_64.tar.gz
rm -f WasmEdge-plugin-wasmedge_httpsreq-0.11.1-manylinux2014_x86_64.tar.gz
mv libwasmedgePluginHttpsReq.so $HOME/.wasmedge/plugin
</code></pre>
<p>If you choose to install WasmEdge under <code>/usr</code>, please note that the plug-in path is different:</p>
<pre><code class="language-bash">curl -sSf https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/utils/install.sh | bash -s -- -v 0.11.1 -p /usr/local
curl -sLO https://github.com/WasmEdge/WasmEdge/releases/download/0.11.1/WasmEdge-plugin-wasmedge_httpsreq-0.11.1-manylinux2014_x86_64.tar.gz
tar -zxf WasmEdge-plugin-wasmedge_httpsreq-0.11.1-manylinux2014_x86_64.tar.gz
rm -f WasmEdge-plugin-wasmedge_httpsreq-0.11.1-manylinux2014_x86_64.tar.gz
mv libwasmedgePluginHttpsReq.so /usr/local/lib/wasmedge/
</code></pre>
<p>If you want to use the <code>Ubuntu 20.04</code> version, please install with the following commands:</p>
<pre><code class="language-bash">curl -sLO https://github.com/WasmEdge/WasmEdge/releases/download/0.11.1/WasmEdge-0.11.1-ubuntu20.04_x86_64.tar.gz
tar -zxf WasmEdge-0.11.1-ubuntu20.04_x86_64.tar.gz
rm -f WasmEdge-0.11.1-ubuntu20.04_x86_64.tar.gz
curl -sLO https://github.com/WasmEdge/WasmEdge/releases/download/0.11.1/WasmEdge-plugin-wasmedge_httpsreq-0.11.1-ubuntu20.04_x86_64.tar.gz
tar -zxf WasmEdge-plugin-wasmedge_httpsreq-0.11.1-ubuntu20.04_x86_64.tar.gz
rm -f WasmEdge-plugin-wasmedge_httpsreq-0.11.1-ubuntu20.04_x86_64.tar.gz
mv libwasmedgePluginHttpsReq.so WasmEdge-0.11.1-Linux/lib/wasmedge
export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:$(pwd)/WasmEdge-0.11.1-Linux/lib
export PATH=$PATH:$(pwd)/WasmEdge-0.11.1-Linux/bin
export WASMEDGE_PLUGIN_PATH=$(pwd)/WasmEdge-0.11.1-Linux/lib/wasmedge
</code></pre>
<blockquote>
<p>The <code>manylinux2014</code> WasmEdge should use the <code>manylinux2014</code> version of plug-in, while the <code>Ubuntu 20.04</code> WasmEdge should also use the <code>Ubuntu 20.04</code> version of plug-in, too.</p>
</blockquote>
<p>You can also <a href="write_wasm/rust/../../contribute/build_from_src/plugin_wasmedge_httpsreq.html">build WasmEdge with WASI-Crypto plug-in from source</a>.</p>
<h2 id="an-https-request-example"><a class="header" href="#an-https-request-example">An HTTPS request example</a></h2>
<p>The <a href="https://github.com/2019zhou/wasmedge_http_req/blob/zhou/httpsreq/examples/get_https.rs">example source code</a> for the HTTPS request is available as follows. The HTTP and HTTPS APIs are the same. The Err messages are presented differently because the HTTP uses the rust code while the HTTPS request uses a wasmedge host function.</p>
<pre><pre class="playground"><code class="language-rust">use wasmedge_http_req::request;

fn main() {
    // get request
    let mut writer = Vec::new(); //container for body of a response
    let mut res = request::get(&quot;https://httpbin.org/get&quot;, &amp;mut writer).unwrap();

    println!(&quot;Status: {} {}&quot;, res.status_code(), res.reason());
    println!(&quot;Headers {}&quot;, res.headers());
    //println!(&quot;{}&quot;, String::from_utf8_lossy(&amp;writer));  // uncomment this line to display the content of writer

    // head request
    res = request::head(&quot;https://httpbin.org/head&quot;).unwrap();

    println!(&quot;Status: {} {}&quot;, res.status_code(), res.reason());
    println!(&quot;{:?}&quot;, res.headers());

    // post request
    writer = Vec::new(); //container for body of a response
    const BODY: &amp;[u8; 27] = b&quot;field1=value1&amp;field2=value2&quot;;
    res = request::post(&quot;https://httpbin.org/post&quot;, BODY, &amp;mut writer).unwrap();

    println!(&quot;Status: {} {}&quot;, res.status_code(), res.reason());
    println!(&quot;Headers {}&quot;, res.headers());
    //println!(&quot;{}&quot;, String::from_utf8_lossy(&amp;writer));  // uncomment this line to display the content of writer

    // add headers and set version
    let uri = Uri::try_from(&quot;http://httpbin.org/get&quot;).unwrap();
    // let uri = Uri::try_from(&quot;https://httpbin.org/get&quot;).unwrap(); // uncomment the line for https request

    // add headers to the request
    let mut headers = Headers::new();
    headers.insert(&quot;Accept-Charset&quot;, &quot;utf-8&quot;);
    headers.insert(&quot;Accept-Language&quot;, &quot;en-US&quot;);
    headers.insert(&quot;Host&quot;, &quot;rust-lang.org&quot;);
    headers.insert(&quot;Connection&quot;, &quot;Close&quot;);

    let mut response = Request::new(&amp;uri)
        .headers(headers)
        .send(&amp;mut writer)
        .unwrap();

    println!(&quot;{}&quot;, String::from_utf8_lossy(&amp;writer));

    // set version
    response = Request::new(&amp;uri)
        .version(HttpVersion::Http10)
        .send(&amp;mut writer)
        .unwrap();

    println!(&quot;{}&quot;, String::from_utf8_lossy(&amp;writer));
}
</code></pre></pre>
<p>The following command compiles the Rust program</p>
<pre><code class="language-bash"># build the wasmedge httpsreq plugin module
sudo apt-get install libssl-dev
cmake -DCMAKE_BUILD_TYPE=Release -DWASMEDGE_BUILD_TESTS=OFF -DWASMEDGE_PLUGIN_HTTPSREQ=On  .. &amp;&amp; make -j4

cargo build --target wasm32-wasi --release
</code></pre>
<p>The following command runs the application in WasmEdge.</p>
<pre><code class="language-bash">wasmedge target/wasm32-wasi/release/get_https.wasm
wasmedge target/wasm32-wasi/release/post_https.wasm
wasmedge target/wasm32-wasi/release/head_https.wasm
</code></pre>
<h2 id="explanation-of-design"><a class="header" href="#explanation-of-design">Explanation of design</a></h2>
<p>It is observed that the request is first parsed and then added to a stream which sends the parsed request to the server. We remain the first step that is HTTPS request is parsed in the original Rust code. We modify the second step by replacing it with a function called <code>send_data</code> that is implemented by the <a href="https://github.com/WasmEdge/WasmEdge/tree/master/plugins/wasmedge_httpsreq">wasmedge_httpsreq host function</a>. We also let the original Rust source code to process the received content by implementing two additional functions <code>get_rcv_len</code> and <code>get_rcv</code>.</p>
<p>The advantage of this design is that because the first step is retained, we can use the same API for HTTP and HTTPS request. Besides, one function (i.e. send_data in httpsreq plugin) is needed for all types of requests as long as it is supported in wasmedge_http_req. <code>send_data</code> function receives three parameters namely the host, the port and the parsed request. An example for using the send_data function is available as follows.</p>
<pre><code class="language-Rust">send_data(&quot;www.google.com&quot;, 443, &quot;GET / HTTP/1.1\nHost: www.google.com\r\nConnection: Close\r\nReferer: https://www.google.com/\r\n\r\n&quot;);
</code></pre>
<p>So, We only do a little change to the original Rust code.</p>
<pre><code class="language-Rust">if self.inner.uri.scheme() == &quot;https&quot; {
let buf = &amp;self.inner.parse_msg();
    let body = String::from_utf8_lossy(buf);
    send_data(host, port.into(), &amp;body);
    let output = get_receive();
    let tmp = String::from_utf8(output.rcv_vec).unwrap();
    let res = Response::try_from(tmp.as_bytes(), writer).unwrap();
    return Ok(res);
}
</code></pre>
<p>To add the host function to a crate that can be used by Rust code, we also implement the <a href="https://github.com/second-state/wasmedge_http_req">httpreq module</a>.</p>
<h3 id="implemention-of-httpsreq-host-function"><a class="header" href="#implemention-of-httpsreq-host-function">Implemention of httpsreq host function</a></h3>
<p>The httpsreq host has three functions (i.e. <code>send_data</code>, <code>get_rcv_len</code> and <code>get_rcv</code>)
The <code>send_data</code> function uses the OpenSSL library to send the data to the server. The <code>send_data</code> function receives three inputs, that is, the host, the port and the parsed request.</p>
<pre><code class="language-cpp">Expect&lt;void&gt; WasmEdgeHttpsReqSendData::body(const Runtime::CallingFrame &amp;Frame,
                                            uint32_t HostPtr, uint32_t HostLen,
                                            uint32_t Port, uint32_t BodyPtr,
                                            uint32_t BodyLen)
</code></pre>
<p>The <code>get_rcv</code> function and <code>get_rcv_len</code> function pass the received content out of the host function which is later processed by the original Rust code. The get_rcv function receives the pointer while the get_rcv_len function returns the length of the received content.</p>
<pre><code class="language-cpp">Expect&lt;void&gt; WasmEdgeHttpsReqGetRcv::body(const Runtime::CallingFrame &amp;Frame,
                                          uint32_t BufPtr)

Expect&lt;uint32_t&gt;
WasmEdgeHttpsReqGetRcvLen::body(const Runtime::CallingFrame &amp;)
</code></pre>
<p>It then opens the connection. Next, use the <code>SSL_write</code> to write the parsed request to the connection. Finally, it receives by using <code>SSL_read</code> and prints the receive to the console.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="non-blocking-networking-sockets"><a class="header" href="#non-blocking-networking-sockets">Non-blocking Networking Sockets</a></h1>
<p>While the simple HTTP connections from the previous chapter are easy to implement, they are not ready for production use. If the program can only have one connection open at a time (e.g., blocking), the fast CPU would be waiting for the slow network. Non-blocking I/O means that the application program can keep multiple connections open at the same time, and process data in and out of those connections as they come in. The program can either alternatingly poll those open connections or wait for incoming data to trigger async functions. That allows I/O intensive programs to run much faster even in a single-threaded environment. In this chapter, we will cover both polling and async programming models.</p>
<h2 id="a-non-blocking-http-client-example"><a class="header" href="#a-non-blocking-http-client-example">A non-blocking HTTP client example</a></h2>
<p>The <a href="https://github.com/second-state/wasmedge_wasi_socket/tree/main/examples/nonblock_http_client">source code</a> for a non-blocking HTTP client application is available. The following <code>main()</code> function starts two HTTP connections. The program keeps both connections open, and alternatingly checks for incoming data from them. In another word, the two connections are not blocking each other. Their data are handled concurrently (or alternatingly) as the data comes in.</p>
<pre><pre class="playground"><code class="language-rust">use httparse::{Response, EMPTY_HEADER};
use std::io::{self, Read, Write};
use std::str::from_utf8;
use wasmedge_wasi_socket::TcpStream;

fn main() {
    let req = &quot;GET / HTTP/1.0\n\n&quot;;
    let mut first_connection = TcpStream::connect(&quot;127.0.0.1:80&quot;).unwrap();
    first_connection.set_nonblocking(true).unwrap();
    first_connection.write_all(req.as_bytes()).unwrap();

    let mut second_connection = TcpStream::connect(&quot;127.0.0.1:80&quot;).unwrap();
    second_connection.set_nonblocking(true).unwrap();
    second_connection.write_all(req.as_bytes()).unwrap();

    let mut first_buf = vec![0; 4096];
    let mut first_bytes_read = 0;
    let mut second_buf = vec![0; 4096];
    let mut second_bytes_read = 0;

    loop {
        let mut first_complete = false;
        let mut second_complete = false;
        if !first_complete {
            match read_data(&amp;mut first_connection, &amp;mut first_buf, first_bytes_read) {
                Ok((bytes_read, false)) =&gt; {
                    first_bytes_read = bytes_read;
                }
                Ok((bytes_read, true)) =&gt; {
                    println!(&quot;First connection completed&quot;);
                    if bytes_read != 0 {
                        parse_data(&amp;first_buf, bytes_read);
                    }
                    first_complete = true;
                }
                Err(e) =&gt; {
                    println!(&quot;First connection error: {}&quot;, e);
                    first_complete = true;
                }
            }
        }
        if !second_complete {
            match read_data(&amp;mut second_connection, &amp;mut second_buf, second_bytes_read) {
                Ok((bytes_read, false)) =&gt; {
                    second_bytes_read = bytes_read;
                }
                Ok((bytes_read, true)) =&gt; {
                    println!(&quot;Second connection completed&quot;);
                    if bytes_read != 0 {
                        parse_data(&amp;second_buf, bytes_read);
                    }
                    second_complete = true;
                }
                Err(e) =&gt; {
                    println!(&quot;Second connection error: {}&quot;, e);
                    second_complete = true;
                }
            }
        }
        if first_complete &amp;&amp; second_complete {
            break;
        }
    }
}
</code></pre></pre>
<p>The following command compiles the Rust program.</p>
<pre><code class="language-bash">cargo build --target wasm32-wasi --release
</code></pre>
<p>The following command runs the application in WasmEdge.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>wasmedge target/wasm32-wasi/release/nonblock_http_client.wasm
<span class="boring">}
</span></code></pre></pre>
<h2 id="a-non-blocking-http-server-example"><a class="header" href="#a-non-blocking-http-server-example">A non-blocking HTTP server example</a></h2>
<p>The <a href="https://github.com/second-state/wasmedge_wasi_socket/tree/main/examples/http_server">source code</a> for a non-blocking HTTP server application is available. The following <code>main()</code> function starts an HTTP server. It receives events from multiple open connections, and processes those events as they are received by calling the async handler functions registered to each connection. This server can process events from multiple open connections concurrently.</p>
<pre><pre class="playground"><code class="language-rust">fn main() -&gt; std::io::Result&lt;()&gt; {
    let mut poll = Poll::new();
    let server = TcpListener::bind(&quot;127.0.0.1:1234&quot;, true)?;
    println!(&quot;Listening on 127.0.0.1:1234&quot;);
    let mut connections = HashMap::new();
    let mut handlers = HashMap::new();
    const SERVER: Token = Token(0);
    let mut unique_token = Token(SERVER.0 + 1);

    poll.register(&amp;server, SERVER, Interest::Read);

    loop {
        let events = poll.poll().unwrap();

        for event in events {
            match event.token {
                SERVER =&gt; loop {
                    let (connection, address) = match server.accept(FDFLAGS_NONBLOCK) {
                        Ok((connection, address)) =&gt; (connection, address),
                        Err(ref e) if e.kind() == std::io::ErrorKind::WouldBlock =&gt; break,
                        Err(e) =&gt; panic!(&quot;accept error: {}&quot;, e),
                    };

                    println!(&quot;Accepted connection from: {}&quot;, address);

                    let token = unique_token.add();
                    poll.register(&amp;connection, token, Interest::Read);
                    connections.insert(token, connection);
                },
                token =&gt; {
                    let done = if let Some(connection) = connections.get_mut(&amp;token) {
                        let handler = match handlers.get_mut(&amp;token) {
                            Some(handler) =&gt; handler,
                            None =&gt; {
                                let handler = Handler::new();
                                handlers.insert(token, handler);
                                handlers.get_mut(&amp;token).unwrap()
                            }
                        };
                        handle_connection(&amp;mut poll, connection, handler, &amp;event)?
                    } else {
                        false
                    };
                    if done {
                        if let Some(connection) = connections.remove(&amp;token) {
                            connection.shutdown(Shutdown::Both)?;
                            poll.unregister(&amp;connection);
                            handlers.remove(&amp;token);
                        }
                    }
                }
            }
        }
    }
}
</code></pre></pre>
<p>The <code>handle_connection()</code> function processes the data from those open connections. In this case, it just writes the request body into the response. It is also done asynchronously -- meaning that the <code>handle_connection()</code> function creates an event for the response, and puts it in the queue. The main application loop processes the event and sends the response when it is waiting for data from other connections.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn handle_connection(
    poll: &amp;mut Poll,
    connection: &amp;mut TcpStream,
    handler: &amp;mut Handler,
    event: &amp;Event,
) -&gt; io::Result&lt;bool&gt; {
    if event.is_readable() {
        let mut connection_closed = false;
        let mut received_data = vec![0; 4096];
        let mut bytes_read = 0;
        loop {
            match connection.read(&amp;mut received_data[bytes_read..]) {
                Ok(0) =&gt; {
                    connection_closed = true;
                    break;
                }
                Ok(n) =&gt; {
                    bytes_read += n;
                    if bytes_read == received_data.len() {
                        received_data.resize(received_data.len() + 1024, 0);
                    }
                }
                Err(ref err) if would_block(err) =&gt; {
                    if bytes_read != 0 {
                        let received_data = &amp;received_data[..bytes_read];
                        let mut bs: parsed::stream::ByteStream =
                            match String::from_utf8(received_data.to_vec()) {
                                Ok(s) =&gt; s,
                                Err(_) =&gt; {
                                    continue;
                                }
                            }
                            .into();
                        let req = match parsed::http::parse_http_request(&amp;mut bs) {
                            Some(req) =&gt; req,
                            None =&gt; {
                                break;
                            }
                        };
                        for header in req.headers.iter() {
                            if header.name.eq(&quot;Conntent-Length&quot;) {
                                let content_length = header.value.parse::&lt;usize&gt;().unwrap();
                                if content_length &gt; received_data.len() {
                                    return Ok(true);
                                }
                            }
                        }
                        println!(
                            &quot;{:?} request: {:?} {:?}&quot;,
                            connection.peer_addr().unwrap(),
                            req.method,
                            req.path
                        );
                        let res = Response {
                            protocol: &quot;HTTP/1.1&quot;.to_string(),
                            code: 200,
                            message: &quot;OK&quot;.to_string(),
                            headers: vec![
                                Header {
                                    name: &quot;Content-Length&quot;.to_string(),
                                    value: req.content.len().to_string(),
                                },
                                Header {
                                    name: &quot;Connection&quot;.to_string(),
                                    value: &quot;close&quot;.to_string(),
                                },
                            ],
                            content: req.content,
                        };

                        handler.response = Some(res.into());

                        poll.reregister(connection, event.token, Interest::Write);
                        break;
                    } else {
                        println!(&quot;Empty request&quot;);
                        return Ok(true);
                    }
                }
                Err(ref err) if interrupted(err) =&gt; continue,
                Err(err) =&gt; return Err(err),
            }
        }

        if connection_closed {
            println!(&quot;Connection closed&quot;);
            return Ok(true);
        }
    }

    if event.is_writable() &amp;&amp; handler.response.is_some() {
        let resp = handler.response.clone().unwrap();
        match connection.write(resp.as_bytes()) {
            Ok(n) if n &lt; resp.len() =&gt; return Err(io::ErrorKind::WriteZero.into()),
            Ok(_) =&gt; {
                return Ok(true);
            }
            Err(ref err) if would_block(err) =&gt; {}
            Err(ref err) if interrupted(err) =&gt; {
                return handle_connection(poll, connection, handler, event)
            }
            Err(err) =&gt; return Err(err),
        }
    }

    Ok(false)
}
<span class="boring">}
</span></code></pre></pre>
<p>The following command compiles the Rust program.</p>
<pre><code class="language-bash">cargo build --target wasm32-wasi --release
</code></pre>
<p>The following command runs the application in WasmEdge.</p>
<pre><code class="language-bash">$ wasmedge target/wasm32-wasi/release/poll_http_server.wasm
new connection at 1234
</code></pre>
<p>To test the HTTP server, you can submit a HTTP request to it via <code>curl</code>.</p>
<pre><code class="language-bash">$ curl -d &quot;name=WasmEdge&quot; -X POST http://127.0.0.1:1234
echo: name=WasmEdge
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="server-side-rendering"><a class="header" href="#server-side-rendering">Server-side rendering</a></h1>
<p>Frontend web frameworks allow developers to create web apps in a high level language and component model. The web app is built into a static web site to be rendered in the browser. While many frontend web frameworks are based on JavaScript, such as React and Vue, Rust-based frameworks are also emerging as the Rust language gains traction among developers. Those web frameworks render the HTML DOM UI using the WebAssembly, which is compiled from Rust source code. They use <a href="https://github.com/rustwasm/wasm-bindgen">wasm-bindgen</a> to tie the Rust to the HTML DOM.
While all of these frameworks send <code>.wasm</code> files to the browser to render the UI on the client-side, some provide the additional choice for <a href="https://en.wikipedia.org/wiki/Server-side_scripting">Server-side rendering</a>. That is to run the WebAssembly code and build the HTML DOM UI on the server, and stream the HTML content to the browser for faster performance and startup time on slow devices and networks.</p>
<blockquote>
<p>If you are interested in JavaScript-based Jamstack and SSR frameworks, such as React, please <a href="write_wasm/rust/../js/ssr.html">checkout our JavaScript SSR chapter</a>.</p>
</blockquote>
<p>This article will explore how to render the web UI on the server using WasmEdge.
We pick <a href="https://github.com/chinedufn/percy">Percy</a> as our framework because it is relatively mature in SSR and <a href="https://en.wikipedia.org/wiki/Hydration_(web_development)">Hydration</a>. Percy already provides an <a href="https://github.com/chinedufn/percy/tree/master/examples/isomorphic">example</a> for SSR. It's highly recommended to read it first to understand how it works. The default SSR setup with Percy utilizes a native Rust web server. The Rust code is compiled to machine native code for the server. However, in order to host user applications on the server, we need a sandbox. While we could run native code inside a Linux container (Docker), a far more efficient (and safer) approach is to run the compiled code in a WebAssembly VM on the server, especially considerring the rendering code is already compiled into WebAssembly.</p>
<p>Now, let's go through the steps to run a Percy SSR service in a WasmEdge server.</p>
<p>Assuming we are in the <code>examples/isomorphic</code> directory, make a new crate beside the existing <code>server</code>.</p>
<pre><code class="language-bash">cargo new server-wasmedge
</code></pre>
<p>You'll receive a warning to let you put the new crate into the workspace, so insert below into <code>members</code> of <code>[workspace]</code>. The file is <code>../../Cargo.toml</code>.</p>
<pre><code class="language-toml">&quot;examples/isomorphic/server-wasmedge&quot;
</code></pre>
<p>With the file open, put these two lines in the bottom:</p>
<pre><code class="language-toml">[patch.crates-io]
wasm-bindgen = { git = &quot;https://github.com/KernelErr/wasm-bindgen.git&quot;, branch = &quot;wasi-compat&quot; }
</code></pre>
<blockquote>
<p>Why do we need a forked <code>wasm-bindgen</code>? That is because <code>wasm-bindgen</code> is the required glue between Rust and HTML in the browser. On the server, however, we need to build the Rust code to the <code>wasm32-wasi</code> target, which is incompatible with <code>wasm-bindgen</code>. Our forked <code>wasm-bindgen</code> has conditional configs that removes browser-specific code in the generated <code>.wasm</code> file for the <code>wasm32-wasi</code> target.</p>
</blockquote>
<p>Then replace the crate's <code>Cargo.toml</code> with following content.</p>
<pre><code class="language-toml">[package]
name = &quot;isomorphic-server-wasmedge&quot;
version = &quot;0.1.0&quot;
edition = &quot;2021&quot;

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]
wasmedge_wasi_socket = &quot;0&quot;
querystring = &quot;1.1.0&quot;
parsed = { version = &quot;0.3&quot;, features = [&quot;http&quot;] }
anyhow = &quot;1&quot;
serde = { version = &quot;1.0&quot;, features = [&quot;derive&quot;] }
isomorphic-app = { path = &quot;../app&quot; } 
</code></pre>
<p>The <code>wasmedge_wasi_socket</code> crate is the socket API of WasmEdge. This project is under development. Next copy the <code>index.html</code> file into the crate's root.</p>
<pre><code class="language-bash">cp server/src/index.html server-wasmedge/src/
</code></pre>
<p>Then let's create some Rust code to start a web service in WasmEdge! The <code>main.rs</code> program listens to the request and sends the response via the stream.</p>
<pre><pre class="playground"><code class="language-rust">use std::io::Write;
use wasmedge_wasi_socket::{Shutdown, TcpListener};

mod handler;
mod mime;
mod response;

fn main() {
    let server = TcpListener::bind(&quot;127.0.0.1:3000&quot;, false).unwrap();
    println!(&quot;Server listening on 127.0.0.1:3000&quot;);

    // Simple single thread HTTP server
    // For server with Pool support, see https://github.com/second-state/wasmedge_wasi_socket/tree/main/examples/poll_http_server
    loop {
        let (mut stream, addr) = server.accept(0).unwrap();
        println!(&quot;Accepted connection from {}&quot;, addr);
        match handler::handle_req(&amp;mut stream, addr) {
            Ok((res, binary)) =&gt; {
                let res: String = res.into();
                let bytes = res.as_bytes();
                stream.write_all(bytes).unwrap();
                if let Some(binary) = binary {
                    stream.write_all(&amp;binary).unwrap();
                }
            }
            Err(e) =&gt; {
                println!(&quot;Error: {:?}&quot;, e);
            }
        };
        stream.shutdown(Shutdown::Both).unwrap();
    }
}
</code></pre></pre>
<p>The <code>handler.rs</code> parses the received data to the path and query objects and return the corresponding response.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use crate::response;
use anyhow::Result;
use parsed::http::Response;
use std::io::Read;
use wasmedge_wasi_socket::{SocketAddr, TcpStream};

pub fn handle_req(stream: &amp;mut TcpStream, addr: SocketAddr) -&gt; Result&lt;(Response, Option&lt;Vec&lt;u8&gt;&gt;)&gt; {
    let mut buf = [0u8; 1024];
    let mut received_data: Vec&lt;u8&gt; = Vec::new();

    loop {
        let n = stream.read(&amp;mut buf)?;
        received_data.extend_from_slice(&amp;buf[..n]);
        if n &lt; 1024 {
            break;
        }
    }

    let mut bs: parsed::stream::ByteStream = match String::from_utf8(received_data) {
        Ok(s) =&gt; s.into(),
        Err(_) =&gt; return Ok((response::bad_request(), None)),
    };

    let req = match parsed::http::parse_http_request(&amp;mut bs) {
        Some(req) =&gt; req,
        None =&gt; return Ok((response::bad_request(), None)),
    };

    println!(&quot;{:?} request: {:?} {:?}&quot;, addr, req.method, req.path);

    let mut path_split = req.path.split(&quot;?&quot;);
    let path = path_split.next().unwrap_or(&quot;/&quot;);
    let query_str = path_split.next().unwrap_or(&quot;&quot;);
    let query = querystring::querify(&amp;query_str);
    let mut init_count: Option&lt;u32&gt; = None;
    for (k, v) in query {
        if k.eq(&quot;init&quot;) {
            match v.parse::&lt;u32&gt;() {
                Ok(v) =&gt; init_count = Some(v),
                Err(_) =&gt; return Ok((response::bad_request(), None)),
            }
        }
    }

    let (res, binary) = if path.starts_with(&quot;/static&quot;) {
        response::file(&amp;path)
    } else {
        // render page
        response::ssr(&amp;path, init_count)
    }
    .unwrap_or_else(|_| response::internal_error());

    Ok((res, binary))
}
<span class="boring">}
</span></code></pre></pre>
<p>The <code>response.rs</code> program packs the response object for static assets and for server rendered content.
For the latter, you could see that SSR happens at <code>app.render().to_string()</code>, the result string is put into HTML by replacing the placeholder text.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use crate::mime::MimeType;
use anyhow::Result;
use parsed::http::{Header, Response};
use std::fs::{read};
use std::path::Path;
use isomorphic_app::App;

const HTML_PLACEHOLDER: &amp;str = &quot;#HTML_INSERTED_HERE_BY_SERVER#&quot;;
const STATE_PLACEHOLDER: &amp;str = &quot;#INITIAL_STATE_JSON#&quot;;

pub fn ssr(path: &amp;str, init: Option&lt;u32&gt;) -&gt; Result&lt;(Response, Option&lt;Vec&lt;u8&gt;&gt;)&gt; {
    let html = format!(&quot;{}&quot;, include_str!(&quot;./index.html&quot;));

    let app = App::new(init.unwrap_or(1001), path.to_string());
    let state = app.store.borrow();

    let html = html.replace(HTML_PLACEHOLDER, &amp;app.render().to_string());
    let html = html.replace(STATE_PLACEHOLDER, &amp;state.to_json());

    Ok((Response {
        protocol: &quot;HTTP/1.0&quot;.to_string(),
        code: 200,
        message: &quot;OK&quot;.to_string(),
        headers: vec![
            Header {
                name: &quot;content-type&quot;.to_string(),
                value: MimeType::from_ext(&quot;html&quot;).get(),
            },
            Header {
                name: &quot;content-length&quot;.to_string(),
                value: html.len().to_string(),
            },
        ],
        content: html.into_bytes(),
    }, None))
}

/// Get raw file content
pub fn file(path: &amp;str) -&gt; Result&lt;(Response, Option&lt;Vec&lt;u8&gt;&gt;)&gt; {
    let path = Path::new(&amp;path);
    if path.exists() {
        let content_type: MimeType = match path.extension() {
            Some(ext) =&gt; MimeType::from_ext(ext.to_str().get_or_insert(&quot;&quot;)),
            None =&gt; MimeType::from_ext(&quot;&quot;),
        };
        let content = read(path)?;

        Ok((Response {
            protocol: &quot;HTTP/1.0&quot;.to_string(),
            code: 200,
            message: &quot;OK&quot;.to_string(),
            headers: vec![
                Header {
                    name: &quot;content-type&quot;.to_string(),
                    value: content_type.get(),
                },
                Header {
                    name: &quot;content-length&quot;.to_string(),
                    value: content.len().to_string(),
                },
            ],
            content: vec![],
        }, Some(content)))
    } else {
        Ok((Response {
            protocol: &quot;HTTP/1.0&quot;.to_string(),
            code: 404,
            message: &quot;Not Found&quot;.to_string(),
            headers: vec![],
            content: vec![],
        }, None))
    }
}

/// Bad Request
pub fn bad_request() -&gt; Response {
    Response {
        protocol: &quot;HTTP/1.0&quot;.to_string(),
        code: 400,
        message: &quot;Bad Request&quot;.to_string(),
        headers: vec![],
        content: vec![],
    }
}

/// Internal Server Error
pub fn internal_error() -&gt; (Response, Option&lt;Vec&lt;u8&gt;&gt;) {
    (Response {
        protocol: &quot;HTTP/1.0&quot;.to_owned(),
        code: 500,
        message: &quot;Internal Server Error&quot;.to_owned(),
        headers: vec![],
        content: vec![],
    }, None)
}
<span class="boring">}
</span></code></pre></pre>
<p>The <code>mime.rs</code> program is a map for assets' extension name and the Mime type.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct MimeType {
    pub r#type: String,
}

impl MimeType {
    pub fn new(r#type: &amp;str) -&gt; Self {
        MimeType {
            r#type: r#type.to_string(),
        }
    }

    pub fn from_ext(ext: &amp;str) -&gt; Self {
        match ext {
            &quot;html&quot; =&gt; MimeType::new(&quot;text/html&quot;),
            &quot;css&quot; =&gt; MimeType::new(&quot;text/css&quot;),
            &quot;map&quot; =&gt; MimeType::new(&quot;application/json&quot;),
            &quot;js&quot; =&gt; MimeType::new(&quot;application/javascript&quot;),
            &quot;json&quot; =&gt; MimeType::new(&quot;application/json&quot;),
            &quot;svg&quot; =&gt; MimeType::new(&quot;image/svg+xml&quot;),
            &quot;wasm&quot; =&gt; MimeType::new(&quot;application/wasm&quot;),
            _ =&gt; MimeType::new(&quot;text/plain&quot;),
        }
    }

    pub fn get(self) -&gt; String {
        self.r#type
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>That's it! Now let's build and run the web application. If you have tested the original example, you probably have already built the client WebAssembly.</p>
<pre><code class="language-bash">cd client
./build-wasm.sh
</code></pre>
<p>Next, build and run the server.</p>
<pre><code class="language-bash">cd ../server-wasmedge
cargo build --target wasm32-wasi
OUTPUT_CSS=&quot;$(pwd)/../client/build/app.css&quot; wasmedge --dir /static:../client/build ../../../target/wasm32-wasi/debug/isomorphic-server-wasmedge.wasm
</code></pre>
<p>Navigate to <code>http://127.0.0.1:3000</code> and you will see the web application in action.</p>
<p>Furthermore, you can place all the steps into a shell script <code>../start-wasmedge.sh</code>.</p>
<pre><code class="language-bash">#!/bin/bash

cd $(dirname $0)

cd ./client

./build-wasm.sh

cd ../server-wasmedge

OUTPUT_CSS=&quot;$(pwd)/../client/build/app.css&quot; cargo run -p isomorphic-server-wasmedge
</code></pre>
<p>Add the following to the <code>.cargo/config.toml</code> file.</p>
<pre><code class="language-toml">[build]
target = &quot;wasm32-wasi&quot;

[target.wasm32-wasi]
runner = &quot;wasmedge --dir /static:../client/build&quot; 
</code></pre>
<p>After that, a single CLI command <code>./start-wasmedge.sh</code> would perform all the tasks to build and run the web application!</p>
<p>We forked the Percy repository and made a ready-to-build <a href="https://github.com/second-state/percy/tree/master/examples/isomorphic/server-wasmedge">server-wasmedge</a> example project for you. Happy coding!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="command-interface"><a class="header" href="#command-interface">Command interface</a></h1>
<p>WASI enables WebAssembly programs to call standard library functions in the host operating system. It does so through a fine-grained security model known as “capability-based security”. The WebAssembly VM owner can grant access to host system resources when the VM starts up. The program cannot access any resources (e.g., file folders) that are not explicitly allowed.</p>
<p>Now, why limit ourselves to standard library functions? The same approach can be used to call just any host functions from WebAssembly. WasmEdge provides a WASI-like extension to access any command line programs in the host operating system.</p>
<p>The command line program can</p>
<ul>
<li>Take input via command line arguments, as well as the <code>STDIN</code> stream.</li>
<li>Return value and data via the <code>STDOUT</code> stream.</li>
</ul>
<p>Application developers for WasmEdge can use our Rust interface crate to access this functionality. In <code>Cargo.toml</code>, make sure that you have this dependency.</p>
<pre><code class="language-toml">[dependencies]
rust_process_interface_library = &quot;0.1.3&quot;
</code></pre>
<p>In the Rust application, you can now use the API methods to start a new process for the operating system command program, pass in arguments via the <code>arg()</code> method as well as via the <code>STDIN</code>, and receives the return values via the <code>STDOUT</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut cmd = Command::new(&quot;http_proxy&quot;);

cmd.arg(&quot;post&quot;)
   .arg(&quot;https://api.sendgrid.com/v3/mail/send&quot;)
   .arg(auth_header);  
cmd.stdin_u8vec(payload.to_string().as_bytes());

let out = cmd.output();
<span class="boring">}
</span></code></pre></pre>
<p>The Rust function is then compiled into WebAssembly and can run in the WasmEdge.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="javascript-1"><a class="header" href="#javascript-1">JavaScript</a></h1>
<p>WebAssembly started as a &quot;JavaScript alternative for browsers&quot;. The idea is to run high-performance applications compiled from languages like C/C++ or Rust safely in browsers. In the browser, WebAssembly runs side by side with JavaScript.</p>
<p>As WebAssembly is increasingly used in the cloud, it is now a universal runtime for cloud-native applications. Compared with Linux containers, WebAssembly runtimes achieve higher performance with lower resource consumption.</p>
<p>In cloud-native use cases, developers often want to use JavaScript to write business applications. That means we must now support JavaScript in WebAssembly. Furthermore, we should support calling C/C++ or Rust functions from JavaScript in a WebAssembly runtime to take advantage of WebAssembly's computational efficiency. The WasmEdge WebAssembly runtime allows you to do exactly that.</p>
<p><img src="write_wasm/javascript.png" alt="javascript" /></p>
<p>In this section, we will demonstrate how to run and enhance JavaScript in WasmEdge.</p>
<ul>
<li><a href="write_wasm/js/quickstart.html">Getting started</a> demonstrates how to run simple JavaScript programs in WasmEdge.</li>
<li><a href="write_wasm/js/nodejs.html">Node.js compatibility</a> describes Node.js APIs support in WasmEdge QuickJS.</li>
<li><a href="write_wasm/js/networking.html">Networking sockets</a> shows how to create non-blocking (async) HTTP clients, including the <code>fetch</code> API, and server applications in JavaScript.</li>
<li><a href="write_wasm/js/ssr.html">React SSR</a> shows example React SSR applications, including streaming SSR support.</li>
<li><a href="write_wasm/js/tensorflow.html">TensorFlow</a> shows how to use WasmEdge's TensorFlow extension from its JavaScript API.</li>
<li><a href="write_wasm/js/es6.html">ES6 modules</a> shows how to incorporate ES6 modules in WasmEdge.</li>
<li><a href="write_wasm/js/npm.html">Node.js and NPM modules</a> shows how to incorporate NPM modules in WasmEdge.</li>
<li><a href="write_wasm/js/modules.html">Built-in modules</a> shows how to add JavaScript functions into the WasmEdge runtime as built-in API functions.</li>
<li><a href="write_wasm/js/rust.html">Use Rust to implement JS API</a> discusses how to use Rust to implement and support a JavaScript API.</li>
</ul>
<h2 id="a-note-on-v8"><a class="header" href="#a-note-on-v8">A note on v8</a></h2>
<p>Now, the choice of QuickJS as our JavaScript engine might raise the question of performance. Isn't QuickJS <a href="https://bellard.org/quickjs/bench.html">a lot slower</a> than v8 due to a lack of JIT support? Yes, but ...</p>
<p>First of all, QuickJS is a lot smaller than v8. In fact, it only takes 1/40 (or 2.5%) of the runtime resources v8 consumes. You can run a lot more QuickJS functions than v8 functions on a single physical machine.</p>
<p>Second, for most business logic applications, raw performance is not critical. The application may have computationally intensive tasks, such as AI inference on the fly. WasmEdge allows the QuickJS applications to drop to high-performance WebAssembly for these tasks while it is not so easy with v8 to add such extensions modules.</p>
<p>Third, WasmEdge is <a href="write_wasm/../use_cases/kubernetes.html">itself an OCI compliant container</a>.
It is secure by default, supports resource isolation, and can be managed by container tools to run side by side with Linux containers in a single k8s cluster.</p>
<p>Finally, v8 has a very large attack surface and requires <a href="https://blog.cloudflare.com/mitigating-spectre-and-other-security-threats-the-cloudflare-workers-security-model/">major efforts</a> to run securely in a public cloud environment.
It is known that <a href="https://www.theregister.com/2021/08/06/edge_super_duper_security_mode/">many JavaScript security issues arise from JIT</a>. Maybe turning off JIT in the cloud-native environment is not such a bad idea!</p>
<p>In the end, running v8 in a cloud-native environment often requires a full stack of software tools consisting of &quot;Linux container + guest OS + node or deno + v8&quot;, which makes it much heavier and slower than a simple WasmEdge + QuickJS container runtime.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="quick-start-with-javascript-on-wasmedge"><a class="header" href="#quick-start-with-javascript-on-wasmedge">Quick Start with JavaScript on WasmEdge</a></h1>
<p>First, let's download the WebAssembly-based JavaScript interpreter program for WasmEdge. It is based on <a href="https://bellard.org/quickjs/">QuickJS</a>. See the <a href="write_wasm/js/quickstart.html#build-it-yourself">build it yourself</a> section to learn how to compile it from Rust source code.</p>
<pre><code class="language-bash">curl -OL https://github.com/second-state/wasmedge-quickjs/releases/download/v0.4.0-alpha/wasmedge_quickjs.wasm
</code></pre>
<p>You can now try a simple &quot;hello world&quot; JavaScript program (<a href="https://github.com/second-state/wasmedge-quickjs/blob/main/example_js/hello.js">example_js/hello.js</a>), which prints out the command line arguments to the console.</p>
<pre><code class="language-javascript">import * as os from 'os';
import * as std from 'std';

args = args.slice(1);
print('Hello', ...args);
setTimeout(() =&gt; {
  print('timeout 2s');
}, 2000);
</code></pre>
<p>Run the <code>hello.js</code> file in WasmEdge’s QuickJS runtime as follows. Make sure you have installed <a href="write_wasm/js/../../quick_start/install.html">WasmEdge</a>.</p>
<pre><code class="language-bash">$ wasmedge --dir .:. wasmedge_quickjs.wasm example_js/hello.js WasmEdge Runtime
Hello WasmEdge Runtime
</code></pre>
<blockquote>
<p>Note: the <code>--dir .:.</code> on the command line is to give <code>wasmedge</code> permission to read the local directory in the file system for the <code>hello.js</code> file.</p>
</blockquote>
<h2 id="build-it-yourself"><a class="header" href="#build-it-yourself">Build it yourself</a></h2>
<p>This section is optional. Read on if you are interested in <a href="write_wasm/js/rust.html">adding custom built-in JavaScript APIs</a> to the runtime.</p>
<p>Fork or clone <a href="https://github.com/second-state/wasmedge-quickjs">the wasmedge-quickjs Github repository</a>.</p>
<pre><code class="language-bash">git clone https://github.com/second-state/wasmedge-quickjs
</code></pre>
<p>Following the instructions from that repo, you will be able to build a JavaScript interpreter for WasmEdge.</p>
<pre><code class="language-bash"># Install GCC
sudo apt update
sudo apt install build-essential

# Install wasm32-wasi target for Rust
rustup target add wasm32-wasi

# Build the QuickJS JavaScript interpreter
cargo build --target wasm32-wasi --release
</code></pre>
<p>The WebAssembly-based JavaScript interpreter program is located in the build <code>target</code> directory.</p>
<p>WasmEdge provides a <code>wasmedgec</code> utility to compile and add a native machine code section to the <code>wasm</code> file. You can use <code>wasmedge</code> to run the natively instrumented <code>wasm</code> file to get much faster performance.</p>
<pre><code class="language-bash">wasmedgec target/wasm32-wasi/release/wasmedge_quickjs.wasm wasmedge_quickjs.wasm
wasmedge --dir .:. wasmedge_quickjs.wasm example_js/hello.js
</code></pre>
<p>Next, we will discuss more advanced use case for JavaScript in WasmEdge.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="nodejs-support"><a class="header" href="#nodejs-support">Node.js support</a></h1>
<p>Many existing JavaScript apps simply use Node.js built-in APIs. In order to support and reuse these JavaScript apps, we are in the process of implementing many Node.JS APIs for WasmEdge QuickJS. The goal is to have unmodified Node.js programs running in WasmEdge QuickJS.</p>
<p>In order to use Node.js APIs in WasmEdge, you must make the <code>modules</code> directory from <a href="https://github.com/second-state/wasmedge-quickjs">wasmedge-quickjs</a> accessible to the WasmEdge Runtime. The simplest approach is to clone the <a href="https://github.com/second-state/wasmedge-quickjs">wasmedge-quickjs</a> repo, and run the Node.js app from the repo's top directory.</p>
<pre><code class="language-bash">git clone https://github.com/second-state/wasmedge-quickjs
cd wasmedge-quickjs
curl -OL https://github.com/second-state/wasmedge-quickjs/releases/download/v0.4.0-alpha/wasmedge_quickjs.wasm
cp -r /path/to/my_node_app .
wasmedge --dir .:. wasmedge_quickjs.wasm my_node_app/index.js
</code></pre>
<blockquote>
<p>If you want to run <code>wasmedge</code> from a directory outside of the repo, you will need to tell it where to find the <code>modules</code> directory using the <code>--dir</code> option. A typical command will look like this: <code>wasmedge --dir .:. --dir ./modules:/path/to/modules wasmedge_quickjs.wasm app.js</code></p>
</blockquote>
<p>The progress of Node.js support in WasmEdge QuickJS is <strong><a href="https://github.com/WasmEdge/WasmEdge/issues/1535">tracked in this issue</a>.</strong> There are two approaches for supporting Node.js APIs in WasmEdge QuickJS.</p>
<h2 id="the-javascript-modules"><a class="header" href="#the-javascript-modules">The JavaScript modules</a></h2>
<p>Some Node.js functions can be implemented in pure JavaScript using the <a href="write_wasm/js/modules.html">modules</a> approach. For example,</p>
<ul>
<li>The <a href="https://github.com/second-state/wasmedge-quickjs/blob/main/modules/querystring.js">querystring</a> functions just perform string manipulations.</li>
<li>The <a href="https://github.com/second-state/wasmedge-quickjs/blob/main/modules/buffer.js">buffer</a> functions manage and encode arrays and memory structures.</li>
<li>The <a href="https://github.com/second-state/wasmedge-quickjs/blob/main/modules/encoding.js">encoding</a> and <a href="https://github.com/second-state/wasmedge-quickjs/blob/main/modules/http.js">http</a> functions support corresponding Node.js APIs by wrapping around <a href="write_wasm/js/rust.html">Rust internal modules</a>.</li>
</ul>
<h2 id="the-rust-internal-modules"><a class="header" href="#the-rust-internal-modules">The Rust internal modules</a></h2>
<p>Other Node.js functions must be implemented in Rust using the <a href="write_wasm/js/rust.html">internal_module</a> approach. There are two reasons for that. First, some Node.js API functions are CPU intensive (e.g., encoding) and is most efficiently implemented in Rust. Second, some Node.js API functions require access to the underlying system (e.g., networking and file system) through native host functions.</p>
<ul>
<li>The <a href="https://github.com/second-state/wasmedge-quickjs/blob/main/src/internal_module/core.rs">core</a> module provides OS level functions such as <code>timeout</code>.</li>
<li>The <a href="https://github.com/second-state/wasmedge-quickjs/blob/main/src/internal_module/encoding.rs">encoding</a> module provides high-performance encoding and decoding functions, which are in turn <a href="https://github.com/second-state/wasmedge-quickjs/blob/main/modules/encoding.js">wrapped into Node.js encoding APIs</a>.</li>
<li>The <a href="https://github.com/second-state/wasmedge-quickjs/blob/main/src/internal_module/wasi_net_module.rs">wasi_net_module</a> provides JavaScript networking functions implemented via the Rust-based WasmEdge WASI socket API. It is then wrapped into the <a href="https://github.com/second-state/wasmedge-quickjs/blob/main/modules/http.js">Node.js http module</a>.</li>
</ul>
<p>Node.js compatibility support in WasmEdge QuickJS is a work in progress. It is a great way for new developers to get familiar with WasmEdge QuickJS. Join us!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="http-and-networking-apps"><a class="header" href="#http-and-networking-apps">HTTP and networking apps</a></h1>
<p>The QuickJS WasmEdge Runtime supports Node.js's <code>http</code> and <code>fetch</code> APIs via the WasmEdge <a href="https://github.com/second-state/wasmedge_wasi_socket">networking socket extension</a>. That enables WasmEdge developers to create HTTP server and client, as well as TCP/IP server and client, applications in JavaScript.</p>
<p>The networking API in WasmEdge is non-blocking and hence supports asynchronous I/O intensive applications. With this API, the JavaScript program can open multiple connections concurrently. It polls those connections, or registers async callback functions, to process data whenever data comes in, without waiting for any one connection to complete its data transfer. That allows the single-threaded application to handle multiple multiple concurrent requests.</p>
<ul>
<li><a href="write_wasm/js/networking.html#fetch-client">Fetch client</a></li>
<li><a href="write_wasm/js/networking.html#http-server">HTTP server</a></li>
<li><a href="write_wasm/js/networking.html#http-client">HTTP client</a></li>
<li><a href="write_wasm/js/networking.html#tcp-server">TCP server</a></li>
<li><a href="write_wasm/js/networking.html#tcp-client">TCP client</a></li>
</ul>
<h2 id="fetch-client"><a class="header" href="#fetch-client">Fetch client</a></h2>
<p>The <code>fetch</code> API is widely used in browser and node-based JavaScript applications to fetch content over the network. Building on top of its non-blocking aysnc network socket API, the WasmEdge QuickJS runtime supports the <code>fetch</code> API. That makes a lot of JS APIs and modules reusable out of the box.</p>
<p>The <a href="https://github.com/second-state/wasmedge-quickjs/blob/main/example_js/wasi_http_fetch.js">example_js/wasi_http_fetch.js</a> example demonstrates how to use the <code>fetch</code> API in WasmEdge. The code snippet below shows an async HTTP GET from the <code>httpbin.org</code> test server. While the program waits for and processes the GET content, it can start another request.</p>
<pre><code class="language-javascript">async function test_fetch() {
  try {
    let r = await fetch('http://httpbin.org/get?id=1')
    print('test_fetch\n', await r.text())
  } catch (e) {
    print(e)
  }
}
test_fetch()
</code></pre>
<p>The code snippet below shows how to do an sync HTTP POST to a remote server.</p>
<pre><code class="language-javascript">async function test_fetch_post() {
  try {
    let r = await fetch(&quot;http://httpbin.org/post&quot;, { method: 'post', 'body': 'post_body' })
    print('test_fetch_post\n', await r.text())
  } catch (e) {
    print(e)
  }
}
test_fetch_post()
</code></pre>
<p>An async HTTP PUT request is as follows.</p>
<pre><code class="language-javascript">async function test_fetch_put() {
  try {
    let r = await fetch(&quot;http://httpbin.org/put&quot;,
      {
        method: &quot;put&quot;,
        body: JSON.stringify({ a: 1 }),
        headers: { 'Context-type': 'application/json' }
      })
    print('test_fetch_put\n', await r.text())
  } catch (e) {
    print(e)
  }
}
test_fetch_put()
</code></pre>
<p>To run this example, use the following WasmEdge CLI command.</p>
<pre><code class="language-bash">wasmedge --dir .:. /path/to/wasmedge_quickjs.wasm example_js/wasi_http_fetch.js
</code></pre>
<p>You can see the HTTP responses printed to the console.</p>
<h2 id="http-server"><a class="header" href="#http-server">HTTP server</a></h2>
<p>If you want to run microservices in the WasmEdge runtime, you will need to create a HTTP server with it. The <a href="https://github.com/second-state/wasmedge-quickjs/blob/main/example_js/wasi_http_echo.js">example_js/wasi_http_echo.js</a> example shows you how to create an HTTP server listening on port 8001 using Node.js compatible APIs. It prepends &quot;echo:&quot; to any incoming request and sends it back as the response.</p>
<pre><code class="language-javascript">import { createServer, request, fetch } from 'http';

createServer((req, resp) =&gt; {
  req.on('data', (body) =&gt; {
    resp.write('echo:')
    resp.end(body)
  })
}).listen(8001, () =&gt; {
  print('listen 8001 ...\n');
})
</code></pre>
<h2 id="http-client"><a class="header" href="#http-client">HTTP client</a></h2>
<p>Once the HTTP server starts, you can connect to it and send in a request using the Node.js <code>request</code> API.</p>
<pre><code class="language-javascript">async function test_request() {
  let client = request({ href: &quot;http://127.0.0.1:8001/request&quot;, method: 'POST' }, (resp) =&gt; {
    var data = '';
    resp.on('data', (chunk) =&gt; {
      data += chunk;
    })
    resp.on('end', () =&gt; {
      print('request client recv:', data)
      print()
    })
  })

  client.end('hello server')
}
</code></pre>
<p>Of course, you can also use the simpler <code>fetch</code> API.</p>
<pre><code class="language-javascript">async function test_fetch() {
  let resp = await fetch('http://127.0.0.1:8001/fetch', { method: 'POST', body: 'hello server' })
  print('fetch client recv:', await resp.text())
  print()
}
</code></pre>
<p>To run this example, use the following WasmEdge CLI command.</p>
<pre><code class="language-bash">wasmedge --dir .:. /path/to/wasmedge_quickjs.wasm example_js/wasi_http_echo.js
</code></pre>
<h2 id="tcp-server"><a class="header" href="#tcp-server">TCP server</a></h2>
<p>The WasmEdge runtime goes beyond the Node.js API. With the <code>WasiTcpServer</code> API, it can create a server that accepts non-HTTP requests. The <a href="https://github.com/second-state/wasmedge-quickjs/blob/main/example_js/wasi_net_echo.js">example_js/wasi_net_echo.js</a> example shows you how to this.</p>
<pre><code class="language-javascript">import * as net from 'wasi_net';
import { TextDecoder } from 'util'

async function server_start() {
  print('listen 8000 ...');
  try {
    let s = new net.WasiTcpServer(8000);
    for (var i = 0; i &lt; 100; i++) {
      let cs = await s.accept();
      handle_client(cs);
    }
  } catch (e) {
    print('server accept error:', e)
  }
}

server_start();
</code></pre>
<p>The <code>handle_client()</code> function contains the logic on how to process and respond to the incoming request. You will need to read and parse the data stream in the request yourself in this function. In this example, it simply echoes the data back with a prefix.</p>
<pre><code class="language-javascript">async function handle_client(cs) {
  print('server accept:', cs.peer());
  try {
    while (true) {
      let d = await cs.read();
      if (d == undefined || d.byteLength &lt;= 0) {
        break;
      }
      let s = new TextDecoder().decode(d);
      print('server recv:', s);
      cs.write('echo:' + s);
    }
  } catch (e) {
    print('server handle_client error:', e);
  }
  print('server: conn close');
}
</code></pre>
<h2 id="tcp-client"><a class="header" href="#tcp-client">TCP client</a></h2>
<p>The TCP client uses WasmEdge's <code>WasiTcpConn</code> API to send in a request and receive the echoed response.</p>
<pre><code class="language-javascript">async function connect_test() {
  try {
    let ss = await net.WasiTcpConn.connect('127.0.0.1:8000')
    ss.write('hello');
    let msg = await ss.read() || &quot;&quot;;
    print('client recv:', new TextDecoder().decode(msg));
  } catch (e) {
    print('client catch:', e);
  } finally {
    nextTick(() =&gt; {
      exit(0)
    })
  }
}

connect_test();
</code></pre>
<p>To run this example, use the following WasmEdge CLI command.</p>
<pre><code class="language-bash">wasmedge --dir .:. /path/to/wasmedge_quickjs.wasm example_js/wasi_net_echo.js
</code></pre>
<p>With async HTTP networking, developers can create I/O intensive applications, such as database-driven microservices, in JavaScript and run them safely and efficiently in WasmEdge.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="react-ssr"><a class="header" href="#react-ssr">React SSR</a></h1>
<p><a href="https://reactjs.org/">React</a> is very popular JavaScript web UI framework. A React application is &quot;compiled&quot; into an HTML and JavaScript static web site. The web UI is rendered through the generated JavaScript code. However, it is often too slow and resource consuming to execute the complex generated JavaScript entirely in the browser to build the interactive HTML DOM objects. <a href="https://medium.com/jspoint/a-beginners-guide-to-react-server-side-rendering-ssr-bf3853841d55">React Server Side Rendering (SSR)</a> delegates the JavaScript UI rendering to a server, and have the server stream rendered HTML DOM objects to the browser. The WasmEdge JavaScript runtime provides a lightweight and high performance container to run React SSR functions on edge servers.</p>
<blockquote>
<p>Server-side rendering (SSR) is a popular technique for rendering a client-side single page application (SPA) on the server and then sending a fully rendered page to the client. This allows for dynamic components to be served as static HTML markup. This approach can be useful for search engine optimization (SEO) when indexing does not handle JavaScript properly. It may also be beneficial in situations where downloading a large JavaScript bundle is impaired by a slow network. -- <a href="https://www.digitalocean.com/community/tutorials/react-server-side-rendering">from Digital Ocean</a>.</p>
</blockquote>
<p>In this article, we will show you how to use the WasmEdge QuickJS runtime to implement a React SSR function.
Compared with the Docker + Linux + nodejs + v8 approach, WasmEdge is safer (suitable for multi-tenancy environments) and much lighter (1% of the footprint) with similar performance.</p>
<p>We will start from a complete tutorial to create and deploy a simple React Streaming SSR web application, and then move on to a full React 18 demo.</p>
<ul>
<li><a href="write_wasm/js/ssr.html#getting-started">Getting started with React streaming SSR</a></li>
<li><a href="write_wasm/js/ssr.html#a-full-react-18-app">A full React 18 app</a></li>
<li><a href="write_wasm/js/ssr.html#appendix-the-create-react-app-template">Appendix: the create-react-app template</a></li>
</ul>
<h2 id="getting-started"><a class="header" href="#getting-started">Getting started</a></h2>
<p>The <a href="https://github.com/second-state/wasmedge-quickjs/tree/main/example_js/react_ssr_stream">example_js/react_ssr_stream</a> folder in the GitHub repo contains the example's source code. It showcases how to streaming render an HTML string from templates in a JavaScript app running in WasmEdge.</p>
<p>The <a href="https://github.com/second-state/wasmedge-quickjs/blob/main/example_js/react_ssr_stream/component/LazyHome.jsx">component/LazyHome.jsx</a> file is the main page template in React. It &quot;lazy&quot; loads the inner page template after a 2s delay once the outer HTML is rendered and returned to the user.</p>
<pre><code class="language-javascript">import React, { Suspense } from 'react';
import * as LazyPage from './LazyPage.jsx';

async function sleep(ms) {
  return new Promise((r, _) =&gt; {
    setTimeout(() =&gt; r(), ms)
  });
}

async function loadLazyPage() {
  await sleep(2000);
  return LazyPage
}

class LazyHome extends React.Component {
  render() {
    let LazyPage1 = React.lazy(() =&gt; loadLazyPage());
    return (
      &lt;html lang=&quot;en&quot;&gt;
        &lt;head&gt;
          &lt;meta charSet=&quot;utf-8&quot; /&gt;
          &lt;title&gt;Title&lt;/title&gt;
        &lt;/head&gt;
        &lt;body&gt;
          &lt;div&gt;
            &lt;div&gt; This is LazyHome &lt;/div&gt;
            &lt;Suspense fallback={&lt;div&gt; loading... &lt;/div&gt;}&gt;
              &lt;LazyPage1 /&gt;
            &lt;/Suspense&gt;
          &lt;/div&gt;
        &lt;/body&gt;
      &lt;/html&gt;
    );
  }
}

export default LazyHome;
</code></pre>
<p>The <a href="https://github.com/second-state/wasmedge-quickjs/blob/main/example_js/react_ssr_stream/component/LazyPage.jsx">LazyPage.jsx</a> is the inner page template. It is rendered 2s after the outer page is already returned to the user.</p>
<pre><code class="language-javascript">import React from 'react';

class LazyPage extends React.Component {
  render() {
    return (
      &lt;div&gt;
        &lt;div&gt;
          This is lazy page
        &lt;/div&gt;
      &lt;/div&gt;
    );
  }
}

export default LazyPage;
</code></pre>
<p>The <a href="https://github.com/second-state/wasmedge-quickjs/blob/main/example_js/react_ssr_stream/main.mjs">main.mjs</a>
file starts a non-blocking HTTP server using standard Node.js APIs, and then renders the HTML page in multiple chuncks to the response.</p>
<pre><code class="language-javascript">import * as React from 'react';
import { renderToPipeableStream } from 'react-dom/server';
import { createServer } from 'http';

import LazyHome from './component/LazyHome.jsx';

createServer((req, res) =&gt; {
  res.setHeader('Content-type', 'text/html; charset=utf-8');
  renderToPipeableStream(&lt;LazyHome /&gt;).pipe(res);
}).listen(8001, () =&gt; {
  print('listen 8001...');
})
</code></pre>
<p>The <a href="https://github.com/second-state/wasmedge-quickjs/blob/main/example_js/react_ssr_stream/rollup.config.js">rollup.config.js</a> and <a href="https://github.com/second-state/wasmedge-quickjs/blob/main/example_js/react_ssr_stream/package.json">package.json</a> files are to build the React SSR dependencies and components into a bundled JavaScript file for WasmEdge. You should use the <code>npm</code> command to build it.
The output is in the <code>dist/main.mjs</code> file.</p>
<pre><code class="language-bash">npm install
npm run build
</code></pre>
<p>Copy over the system's <code>modules</code> to the working directory for Node.js API support as <a href="write_wasm/js/nodejs.html">noted here</a>.</p>
<pre><code class="language-bash">cp -r ../../modules .
</code></pre>
<p>To run the example, do the following on the CLI to start the server.</p>
<pre><code class="language-bash">nohup wasmedge --dir .:. /path/to/wasmedge_quickjs.wasm dist/main.mjs &amp;
</code></pre>
<p>Send the server a HTTP request via <code>curl</code> or the browser.</p>
<pre><code class="language-bash">curl http://localhost:8001
</code></pre>
<p>The results are as follows. The service first returns an HTML page with an empty inner section (i.e., the <code>loading</code> section), and then 2s later, the HTML content for the inner section and the JavaScript to display it.</p>
<pre><code class="language-bash">  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current
                                 Dload  Upload   Total   Spent    Left  Speed

  0     0    0     0    0     0      0      0 --:--:-- --:--:-- --:--:--     0
100   211    0   211    0     0   1029      0 --:--:-- --:--:-- --:--:--  1024
100   275    0   275    0     0    221      0 --:--:--  0:00:01 --:--:--   220
100   547    0   547    0     0    245      0 --:--:--  0:00:02 --:--:--   245
100  1020    0  1020    0     0    413      0 --:--:--  0:00:02 --:--:--   413

&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;&lt;meta charSet=&quot;utf-8&quot;/&gt;&lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div&gt;&lt;div&gt; This is LazyHome &lt;/div&gt;&lt;!--$?--&gt;&lt;template id=&quot;B:0&quot;&gt;&lt;/template&gt;&lt;div&gt; loading... &lt;/div&gt;&lt;!--/$--&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;&lt;div hidden id=&quot;S:0&quot;&gt;&lt;template id=&quot;P:1&quot;&gt;&lt;/template&gt;&lt;/div&gt;&lt;div hidden id=&quot;S:1&quot;&gt;&lt;div&gt;&lt;div&gt;This is lazy page&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;script&gt;function $RS(a,b){a=document.getElementById(a);b=document.getElementById(b);for(a.parentNode.removeChild(a);a.firstChild;)b.parentNode.insertBefore(a.firstChild,b);b.parentNode.removeChild(b)};$RS(&quot;S:1&quot;,&quot;P:1&quot;)&lt;/script&gt;&lt;script&gt;function $RC(a,b){a=document.getElementById(a);b=document.getElementById(b);b.parentNode.removeChild(b);if(a){a=a.previousSibling;var f=a.parentNode,c=a.nextSibling,e=0;do{if(c&amp;&amp;8===c.nodeType){var d=c.data;if(&quot;/$&quot;===d)if(0===e)break;else e--;else&quot;$&quot;!==d&amp;&amp;&quot;$?&quot;!==d&amp;&amp;&quot;$!&quot;!==d||e++}d=c.nextSibling;f.removeChild(c);c=d}while(c);for(;b.firstChild;)f.insertBefore(b.firstChild,c);a.data=&quot;$&quot;;a._reactRetry&amp;&amp;a._reactRetry()}};$RC(&quot;B:0&quot;,&quot;S:0&quot;)&lt;/script&gt;
</code></pre>
<h2 id="a-full-react-18-app"><a class="header" href="#a-full-react-18-app">A full React 18 app</a></h2>
<p>In this section, we will demonstrate a complete React 18 SSR application. It renders the web UI through streaming SSR. The <a href="https://github.com/second-state/wasmedge-quickjs/tree/main/example_js/react18_ssr">example_js/react18_ssr</a> folder in the GitHub repo contains the example's source code. The <a href="https://github.com/second-state/wasmedge-quickjs/tree/main/example_js/react18_ssr/component">component</a> folder contains the entire React 18 application's source code, and the <a href="https://github.com/second-state/wasmedge-quickjs/tree/main/example_js/react18_ssr/public">public</a> folder contains the public resources (CSS and images) for the web application. The application also demonstrates a data provider for the UI.</p>
<p>The <a href="https://github.com/second-state/wasmedge-quickjs/blob/main/example_js/react18_ssr/main.mjs">main.mjs</a>
file starts a non-blocking HTTP server, fetches data from a data provider, maps the <code>main.css</code> and <code>main.js</code> files in the <code>public</code> folder to web URLs, and then renders the HTML page for each request in <code>renderToPipeableStream()</code>.</p>
<pre><code class="language-javascript">import * as React from 'react';
import { renderToPipeableStream } from 'react-dom/server';
import { createServer } from 'http';
import * as std from 'std';

import App from './component/App.js';
import { DataProvider } from './component/data.js'

let assets = {
  'main.js': '/main.js',
  'main.css': '/main.css',
};

const css = std.loadFile('./public/main.css')

function createServerData() {
  let done = false;
  let promise = null;
  return {
    read() {
      if (done) {
        return;
      }
      if (promise) {
        throw promise;
      }
      promise = new Promise(resolve =&gt; {
        setTimeout(() =&gt; {
          done = true;
          promise = null;
          resolve();
        }, 2000);
      });
      throw promise;
    },
  };
}

createServer((req, res) =&gt; {
  print(req.url)
  if (req.url == '/main.css') {
    res.setHeader('Content-Type', 'text/css; charset=utf-8')
    res.end(css)
  } else if (req.url == '/favicon.ico') {
    res.end()
  } else {
    res.setHeader('Content-type', 'text/html');

    res.on('error', (e) =&gt; {
      print('res error', e)
    })
    let data = createServerData()
    print('createServerData')

    const stream = renderToPipeableStream(
      &lt;DataProvider data={data}&gt;
        &lt;App assets={assets} /&gt;
      &lt;/DataProvider&gt;, {
      onShellReady: () =&gt; {
        stream.pipe(res)
      },
      onShellError: (e) =&gt; {
        print('onShellError:', e)
      }
    }
    );
  }
}).listen(8002, () =&gt; {
  print('listen 8002...')
})
</code></pre>
<p>The <a href="https://github.com/second-state/wasmedge-quickjs/blob/main/example_js/react18_ssr/rollup.config.js">rollup.config.js</a> and <a href="https://github.com/second-state/wasmedge-quickjs/blob/main/example_js/react18_ssr/package.json">package.json</a> files are to build the React 18 SSR dependencies and components into a bundled JavaScript file for WasmEdge. You should use the <code>npm</code> command to build it.
The output is in the <code>dist/main.mjs</code> file.</p>
<pre><code class="language-bash">npm install
npm run build
</code></pre>
<p>Copy over the system's <code>modules</code> to the working directory for Node.js API support as <a href="write_wasm/js/nodejs.html">noted here</a>.</p>
<pre><code class="language-bash">cp -r ../../modules .
</code></pre>
<p>To run the example, do the following on the CLI to start the server.</p>
<pre><code class="language-bash">nohup wasmedge --dir .:. /path/to/wasmedge_quickjs.wasm dist/main.mjs &amp;
</code></pre>
<p>Send the server a HTTP request via <code>curl</code> or the browser.</p>
<pre><code class="language-bash">curl http://localhost:8002
</code></pre>
<p>The results are as follows. The service first returns an HTML page with an empty inner section (i.e., the <code>loading</code> section), and then 2s later, the HTML content for the inner section and the JavaScript to display it.</p>
<pre><code class="language-bash">  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current
                                 Dload  Upload   Total   Spent    Left  Speed

  0     0    0     0    0     0      0      0 --:--:-- --:--:-- --:--:--     0
100   439    0   439    0     0   1202      0 --:--:-- --:--:-- --:--:--  1199
100  2556    0  2556    0     0   1150      0 --:--:--  0:00:02 --:--:--  1150
100  2556    0  2556    0     0    926      0 --:--:--  0:00:02 --:--:--   926
100  2806    0  2806    0     0    984      0 --:--:--  0:00:02 --:--:--   984
&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;&lt;meta charSet=&quot;utf-8&quot;/&gt;&lt;meta name=&quot;viewport
&quot; content=&quot;width=device-width, initial-scale=1&quot;/&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;/m
ain.css&quot;/&gt;&lt;title&gt;Hello&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;noscript&gt;&lt;b&gt;Enable JavaScript to run
 this app.&lt;/b&gt;&lt;/noscript&gt;&lt;!--$--&gt;&lt;main&gt;&lt;nav&gt;&lt;a href=&quot;/&quot;&gt;Home&lt;/a&gt;&lt;/nav&gt;&lt;aside cla
ss=&quot;sidebar&quot;&gt;&lt;!--$?--&gt;&lt;template id=&quot;B:0&quot;&gt;&lt;/template&gt;&lt;div class=&quot;spinner spinner-
-active&quot; role=&quot;progressbar&quot; aria-busy=&quot;true&quot;&gt;&lt;/div&gt;&lt;!--/$--&gt;&lt;/aside&gt;&lt;article cla
ss=&quot;post&quot;&gt;&lt;!--$?--&gt;&lt;template id=&quot;B:1&quot;&gt;&lt;/template&gt;&lt;div class=&quot;spinner spinner--ac
tive&quot; role=&quot;progressbar&quot; aria-busy=&quot;true&quot;&gt;&lt;/div&gt;&lt;!--/$--&gt;&lt;section class=&quot;comment
s&quot;&gt;&lt;h2&gt;Comments&lt;/h2&gt;&lt;!--$?--&gt;&lt;template id=&quot;B:2&quot;&gt;&lt;/template&gt;&lt;div class=&quot;spinner s
pinner--active&quot; role=&quot;progressbar&quot; aria-busy=&quot;true&quot;&gt;&lt;/div&gt;&lt;!--/$--&gt;&lt;/section&gt;&lt;h2
&gt;Thanks for reading!&lt;/h2&gt;&lt;/article&gt;&lt;/main&gt;&lt;!--/$--&gt;&lt;script&gt;assetManifest = {&quot;mai
n.js&quot;:&quot;/main.js&quot;,&quot;main.css&quot;:&quot;/main.css&quot;};&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;&lt;div hidden id=&quot;
S:0&quot;&gt;&lt;template id=&quot;P:3&quot;&gt;&lt;/template&gt;&lt;/div&gt;&lt;div hidden id=&quot;S:1&quot;&gt;&lt;template id=&quot;P:4&quot;
&gt;&lt;/template&gt;&lt;/div&gt;&lt;div hidden id=&quot;S:2&quot;&gt;&lt;template id=&quot;P:5&quot;&gt;&lt;/template&gt;&lt;/div&gt;&lt;div 
hidden id=&quot;S:3&quot;&gt;&lt;h1&gt;Archive&lt;/h1&gt;&lt;ul&gt;&lt;li&gt;May 2021&lt;/li&gt;&lt;li&gt;April 2021&lt;/li&gt;&lt;li&gt;Marc
h 2021&lt;/li&gt;&lt;li&gt;February 2021&lt;/li&gt;&lt;li&gt;January 2021&lt;/li&gt;&lt;li&gt;December 2020&lt;/li&gt;&lt;li&gt;
November 2020&lt;/li&gt;&lt;li&gt;October 2020&lt;/li&gt;&lt;li&gt;September 2020&lt;/li&gt;&lt;/ul&gt;&lt;/div&gt;&lt;script
&gt;function $RS(a,b){a=document.getElementById(a);b=document.getElementById(b);for
(a.parentNode.removeChild(a);a.firstChild;)b.parentNode.insertBefore(a.firstChil
d,b);b.parentNode.removeChild(b)};$RS(&quot;S:3&quot;,&quot;P:3&quot;)&lt;/script&gt;&lt;script&gt;function $RC(
a,b){a=document.getElementById(a);b=document.getElementById(b);b.parentNode.remo
veChild(b);if(a){a=a.previousSibling;var f=a.parentNode,c=a.nextSibling,e=0;do{i
f(c&amp;&amp;8===c.nodeType){var d=c.data;if(&quot;/$&quot;===d)if(0===e)break;else e--;else&quot;$&quot;!==
d&amp;&amp;&quot;$?&quot;!==d&amp;&amp;&quot;$!&quot;!==d||e++}d=c.nextSibling;f.removeChild(c);c=d}while(c);for(;b.
firstChild;)f.insertBefore(b.firstChild,c);a.data=&quot;$&quot;;a._reactRetry&amp;&amp;a._reactRet
ry()}};$RC(&quot;B:0&quot;,&quot;S:0&quot;)&lt;/script&gt;&lt;div hidden id=&quot;S:4&quot;&gt;&lt;h1&gt;Hello world&lt;/h1&gt;&lt;p&gt;This
 demo is &lt;!-- --&gt;&lt;b&gt;artificially slowed down&lt;/b&gt;. Open&lt;!-- --&gt; &lt;!-- --&gt;&lt;code&gt;ser
ver/delays.js&lt;/code&gt; to adjust how much different things are slowed down.&lt;!-- --
&gt;&lt;/p&gt;&lt;p&gt;Notice how HTML for comments &amp;quot;streams in&amp;quot; before the JS (or Re
act) has loaded on the page.&lt;/p&gt;&lt;p&gt;Also notice that the JS for comments and side
bar has been code-split, but HTML for it is still included in the server output.
&lt;/p&gt;&lt;/div&gt;&lt;script&gt;$RS(&quot;S:4&quot;,&quot;P:4&quot;)&lt;/script&gt;&lt;script&gt;$RC(&quot;B:1&quot;,&quot;S:1&quot;)&lt;/script&gt;&lt;div
 hidden id=&quot;S:5&quot;&gt;&lt;p class=&quot;comment&quot;&gt;Wait, it doesn&amp;#x27;t wait for React to load
?&lt;/p&gt;&lt;p class=&quot;comment&quot;&gt;How does this even work?&lt;/p&gt;&lt;p class=&quot;comment&quot;&gt;I like ma
rshmallows&lt;/p&gt;&lt;/div&gt;&lt;script&gt;$RS(&quot;S:5&quot;,&quot;P:5&quot;)&lt;/script&gt;&lt;script&gt;$RC(&quot;B:2&quot;,&quot;S:2&quot;)&lt;/s
cript&gt;
</code></pre>
<p>The streaming SSR examples make use of WasmEdge's unique asynchronous networking capabilities and ES6 module support (i.e., the rollup bundled JS file contains ES6 modules). You can learn more about <a href="write_wasm/js/networking.html">async networking</a> and <a href="write_wasm/js/es6.html">ES6</a> in this book.</p>
<h2 id="appendix-the-create-react-app-template"><a class="header" href="#appendix-the-create-react-app-template">Appendix the create-react-app template</a></h2>
<p>The <code>create-react-app</code> template is a popular starting point for many developers to create React apps. In this tutorial, we will provide a step-by-step guide on how to use it to create React streaming SSR applications that run on WasmEdge.</p>
<h3 id="step-1--create-the-react-app"><a class="header" href="#step-1--create-the-react-app">Step 1 — Create the React App</a></h3>
<p>First, use <code>npx</code> to create a new React app. Let’s name the app <code>react-ssr-example</code>.</p>
<pre><code class="language-bash">npx create-react-app react-ssr-example
</code></pre>
<p>Then, <code>cd</code> into the directory for the newly created app.</p>
<pre><code class="language-bash">cd react-ssr-example
</code></pre>
<p>Start the new app in order to verify the installation.</p>
<pre><code class="language-bash">npm start
</code></pre>
<p>You should see the example React app displayed in your browser window. At this stage, the app is rendered in the browser. The browser runs the generated React JavaScript to build the HTML DOM UI.</p>
<p>Now in order to prepare for SSR, you will need to make some changes to the app's <code>index.js</code> file. Change ReactDOM's <code>render</code> method to <code>hydrate</code> to indicate to the DOM renderer that you intend to rehydrate the app after it is rendered on the server.
Replace the contents of the <code>index.js</code> file with the following.</p>
<pre><code class="language-javascript">import React from 'react';
import ReactDOM from 'react-dom';
import App from './App';
ReactDOM.hydrate(
  &lt;React.StrictMode&gt;
    &lt;App /&gt;
  &lt;/React.StrictMode&gt;,
  document.getElementById('root')
);
</code></pre>
<p>Note: you should import <code>React</code> redundantly in the <code>src/App.js</code>, so the server will recognize it.</p>
<pre><code class="language-js">import React from 'react';
//...
</code></pre>
<p>That concludes setting up the application, you can move on to setting up the server-side rendering functions.</p>
<h3 id="step-2--create-an-wasmedge-quickjs-server-and-render-the-app-component"><a class="header" href="#step-2--create-an-wasmedge-quickjs-server-and-render-the-app-component">Step 2 — Create an WasmEdge QuickJS Server and Render the App Component</a></h3>
<p>Now that you have the app in place, let’s set up a server that will render the HTML DOM by running the React JavaScript and then send the rendered elements to the browser. We will use WasmEdge as a secure, high-performance and lightweight container to run React JavaScript.</p>
<p>Create a new <code>server</code> directory in the project's root directory.</p>
<pre><code class="language-bash">mkdir server
</code></pre>
<p>Then, inside the <code>server</code> directory, create a new <code>index.js</code> file with the server code.</p>
<pre><code class="language-javascript">import * as React from 'react';
import ReactDOMServer from 'react-dom/server';
import * as std from 'std';
import * as http from 'wasi_http';
import * as net from 'wasi_net';

import App from '../src/App.js';

async function handle_client(cs) {
  print('open:', cs.peer());
  let buffer = new http.Buffer();

  while (true) {
    try {
      let d = await cs.read();
      if (d == undefined || d.byteLength &lt;= 0) {
        return;
      }
      buffer.append(d);
      let req = buffer.parseRequest();
      if (req instanceof http.WasiRequest) {
        handle_req(cs, req);
        break;
      }
    } catch (e) {
      print(e);
    }
  }
  print('end:', cs.peer());
}

function enlargeArray(oldArr, newLength) {
  let newArr = new Uint8Array(newLength);
  oldArr &amp;&amp; newArr.set(oldArr, 0);
  return newArr;
}

async function handle_req(s, req) {
  print('uri:', req.uri)

  let resp = new http.WasiResponse();
  let content = '';
  if (req.uri == '/') {
    const app = ReactDOMServer.renderToString(&lt;App /&gt;);
    content = std.loadFile('./build/index.html');
    content = content.replace('&lt;div id=&quot;root&quot;&gt;&lt;/div&gt;', `&lt;div id=&quot;root&quot;&gt;${app}&lt;/div&gt;`);
  } else {
    let chunk = 1000; // Chunk size of each reading
    let length = 0; // The whole length of the file
    let byteArray = null; // File content as Uint8Array
    
    // Read file into byteArray by chunk
    let file = std.open('./build' + req.uri, 'r');
    while (true) {
      byteArray = enlargeArray(byteArray, length + chunk);
      let readLen = file.read(byteArray.buffer, length, chunk);
      length += readLen;
      if (readLen &lt; chunk) {
        break;
      }
    }
    content = byteArray.slice(0, length).buffer;
    file.close();
  }
  let contentType = 'text/html; charset=utf-8';
  if (req.uri.endsWith('.css')) {
    contentType = 'text/css; charset=utf-8';
  } else if (req.uri.endsWith('.js')) {
    contentType = 'text/javascript; charset=utf-8';
  } else if (req.uri.endsWith('.json')) {
    contentType = 'text/json; charset=utf-8';
  } else if (req.uri.endsWith('.ico')) {
    contentType = 'image/vnd.microsoft.icon';
  } else if (req.uri.endsWith('.png')) {
    contentType = 'image/png';
  }
  resp.headers = {
    'Content-Type': contentType
  };

  let r = resp.encode(content);
  s.write(r);
}

async function server_start() {
  print('listen 8002...');
  try {
    let s = new net.WasiTcpServer(8002);
    for (var i = 0; ; i++) {
      let cs = await s.accept();
      handle_client(cs);
    }
  } catch (e) {
    print(e);
  }
}

server_start();
</code></pre>
<p>The server renders the <code>&lt;App&gt;</code> component, and then sends the rendered HTML string back to the browser. Three important things are taking place here.</p>
<ul>
<li>ReactDOMServer's <code>renderToString</code> is used to render the <code>&lt;App/&gt;</code> to an HTML string.</li>
<li>The <code>index.html</code> file from the app's <code>build</code> output directory is loaded as a template. The app's content is injected into the <code>&lt;div&gt;</code> element with an id of <code>&quot;root&quot;</code>. It is then sent back as HTTP response.</li>
<li>Other files from the <code>build</code> directory are read and served as needed at the requests of the browser.</li>
</ul>
<h3 id="step-3--build-and-deploy"><a class="header" href="#step-3--build-and-deploy">Step 3 — Build and deploy</a></h3>
<p>For the server code to work, you will need to bundle and transpile it. In this section, we will show you how to use webpack and Babel. In this next section, we will demonstrate an alternative (and potentially easier) approach using rollup.js.</p>
<p>Create a new Babel configuration file named <code>.babelrc.json</code> in the project's root directory and add the <code>env</code> and <code>react-app</code> presets.</p>
<pre><code class="language-json">{
  &quot;presets&quot;: [
    &quot;@babel/preset-env&quot;,
    &quot;@babel/preset-react&quot;
  ]
}
</code></pre>
<p>Create a webpack config for the server that uses Babel Loader to transpile the code. Start by creating the <code>webpack.server.js</code> file in the project's root directory.</p>
<pre><code class="language-js">const path = require('path');
module.exports = {
  entry: './server/index.js',
  externals: [
    {&quot;wasi_http&quot;: &quot;wasi_http&quot;},
    {&quot;wasi_net&quot;: &quot;wasi_net&quot;},
    {&quot;std&quot;: &quot;std&quot;}
  ],
  output: {
    path: path.resolve('server-build'),
    filename: 'index.js',
    chunkFormat: &quot;module&quot;,
    library: {
      type: &quot;module&quot;
    },
  },
  experiments: {
    outputModule: true
  },
  module: {
    rules: [
      {
        test: /\.js$/,
        use: 'babel-loader'
      },
      {
        test: /\.css$/,
        use: [&quot;css-loader&quot;]
      },
      {
        test: /\.svg$/,
        use: [&quot;svg-url-loader&quot;]
      }
    ]
  }
};
</code></pre>
<p>With this configuration, the transpiled server bundle will be output to the <code>server-build</code> folder in a file called <code>index.js</code>.</p>
<p>Next, add the <code>svg-url-loader</code> package by entering the following commands in your terminal.</p>
<pre><code class="language-bash">npm install svg-url-loader --save-dev
</code></pre>
<p>This completes the dependency installation and webpack and Babel configuration.</p>
<p>Now, revisit <code>package.json</code> and add helper npm scripts. Add <code>dev:build-server</code>, <code>dev:start-server</code> scripts to the <code>package.json</code> file to build and serve the SSR application.</p>
<pre><code class="language-json">&quot;scripts&quot;: {
  &quot;dev:build-server&quot;: &quot;NODE_ENV=development webpack --config webpack.server.js --mode=development&quot;,
  &quot;dev:start-server&quot;: &quot;wasmedge --dir .:. wasmedge_quickjs.wasm ./server-build/index.js&quot;,
  // ...
},
</code></pre>
<ul>
<li>The <code>dev:build-server</code> script sets the environment to <code>&quot;development&quot;</code> and invokes webpack with the configuration file you created earlier.</li>
<li>The <code>dev:start-server</code> script runs the WasmEdge server from the <code>wasmedge</code> CLI tool to serve the built output. The <code>wasmedge_quickjs.wasm</code> program contains the QuickJS runtime. <a href="write_wasm/js/quickstart.html">Learn more</a></li>
</ul>
<p>Now you can run the following commands to build the client-side app, bundle and transpile the server code, and start up the server on <code>:8002</code>.</p>
<pre><code class="language-bash">npm run build
npm run dev:build-server
npm run dev:start-server
</code></pre>
<p>Open <code>http://localhost:8002/</code> in your web browser and observe your server-side rendered app.</p>
<p>Previously, the HTML source in the browser is simply the template with SSR placeholders.</p>
<pre><code class="language-html">Output
&lt;div id=&quot;root&quot;&gt;&lt;/div&gt;
</code></pre>
<p>Now, with the SSR function running on the server, the HTML source in the browser is as follows.</p>
<pre><code class="language-html">Output
&lt;div id=&quot;root&quot;&gt;&lt;div class=&quot;App&quot; data-reactroot=&quot;&quot;&gt;...&lt;/div&gt;&lt;/div&gt;
</code></pre>
<h3 id="step-4-alternative----build-and-deploy-with-rollupjs"><a class="header" href="#step-4-alternative----build-and-deploy-with-rollupjs">Step 4 (alternative) -- build and deploy with rollup.js</a></h3>
<p>Alternatively, you could use the <a href="https://rollupjs.org/guide/en/">rollup.js</a> tool to <a href="write_wasm/js/npm.html">package all application components and library modules</a> into a single file for WasmEdge to execute.</p>
<p>Create a rollup config for the server that uses Babel Loader to transpile the code. Start by creating the <code>rollup.config.js</code> file in the project's root directory.</p>
<pre><code class="language-js">const {babel} = require('@rollup/plugin-babel');
const nodeResolve = require('@rollup/plugin-node-resolve');
const commonjs = require('@rollup/plugin-commonjs');
const replace = require('@rollup/plugin-replace');

const globals = require('rollup-plugin-node-globals');
const builtins = require('rollup-plugin-node-builtins');
const plugin_async = require('rollup-plugin-async');
const css = require(&quot;rollup-plugin-import-css&quot;);
const svg = require('rollup-plugin-svg');

const babelOptions = {
  babelrc: false,
  presets: [
    '@babel/preset-react'
  ],
  babelHelpers: 'bundled'
};

module.exports = [
  {
    input: './server/index.js',
    output: {
      file: 'server-build/index.js',
      format: 'esm',
    },
    external: [ 'std', 'wasi_net','wasi_http'],
    plugins: [
      plugin_async(),
      babel(babelOptions),
      nodeResolve({preferBuiltins: true}),
      commonjs({ignoreDynamicRequires: false}),
      css(),
      svg({base64: true}),
      globals(),
      builtins(),
      replace({
        preventAssignment: true,  
        'process.env.NODE_ENV': JSON.stringify('production'),
        'process.env.NODE_DEBUG': JSON.stringify(''),
      }),
    ],
  },
];
</code></pre>
<p>With this configuration, the transpiled server bundle will be output to the <code>server-build</code> folder in a file called <code>index.js</code>.</p>
<p>Next, add the dependent packages to the <code>package.json</code> then install with <code>npm</code>.</p>
<pre><code class="language-json">  &quot;devDependencies&quot;: {
    //...
    &quot;@rollup/plugin-babel&quot;: &quot;^5.3.0&quot;,
    &quot;@rollup/plugin-commonjs&quot;: &quot;^21.0.1&quot;,
    &quot;@rollup/plugin-node-resolve&quot;: &quot;^7.1.3&quot;,
    &quot;@rollup/plugin-replace&quot;: &quot;^3.0.0&quot;,
    &quot;rollup&quot;: &quot;^2.60.1&quot;,
    &quot;rollup-plugin-async&quot;: &quot;^1.2.0&quot;,
    &quot;rollup-plugin-import-css&quot;: &quot;^3.0.3&quot;,
    &quot;rollup-plugin-node-builtins&quot;: &quot;^2.1.2&quot;,
    &quot;rollup-plugin-node-globals&quot;: &quot;^1.4.0&quot;,
    &quot;rollup-plugin-svg&quot;: &quot;^2.0.0&quot;
  }
</code></pre>
<pre><code class="language-bash">npm install
</code></pre>
<p>This completes the dependency installation and rollup configuration.</p>
<p>Now, revisit <code>package.json</code> and add helper npm scripts. Add <code>dev:build-server</code>, <code>dev:start-server</code> scripts to the <code>package.json</code> file to build and serve the SSR application.</p>
<pre><code class="language-json">&quot;scripts&quot;: {
  &quot;dev:build-server&quot;: &quot;rollup -c rollup.config.js&quot;,
  &quot;dev:start-server&quot;: &quot;wasmedge --dir .:. wasmedge_quickjs.wasm ./server-build/index.js&quot;,
  // ...
},
</code></pre>
<ul>
<li>The <code>dev:build-server</code> script sets the environment to <code>&quot;development&quot;</code> and invokes webpack with the configuration file you created earlier.</li>
<li>The <code>dev:start-server</code> script runs the WasmEdge server from the <code>wasmedge</code> CLI tool to serve the built output. The <code>wasmedge_quickjs.wasm</code> program contains the QuickJS runtime. <a href="write_wasm/js/quickstart.html">Learn more</a></li>
</ul>
<p>Now you can run the following commands to build the client-side app, bundle and transpile the server code, and start up the server on <code>:8002</code>.</p>
<pre><code class="language-bash">npm run build
npm run dev:build-server
npm run dev:start-server
</code></pre>
<p>Open <code>http://localhost:8002/</code> in your web browser and observe your server-side rendered app.</p>
<p>Previously, the HTML source in the browser is simply the template with SSR placeholders.</p>
<pre><code class="language-html">Output
&lt;div id=&quot;root&quot;&gt;&lt;/div&gt;
</code></pre>
<p>Now, with the SSR function running on the server, the HTML source in the browser is as follows.</p>
<pre><code class="language-html">Output
&lt;div id=&quot;root&quot;&gt;&lt;div class=&quot;App&quot; data-reactroot=&quot;&quot;&gt;...&lt;/div&gt;&lt;/div&gt;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tensorflow-1"><a class="header" href="#tensorflow-1">TensorFlow</a></h1>
<p>The interpreter supports the WasmEdge TensorFlow lite inference extension so that your JavaScript can run an ImageNet model for image classification. This article will show you how to use the TensorFlow Rust SDK for WasmEdge from your javascript program. You will first download the WasmEdge QuickJS Runtime with tensorflow support built-in.</p>
<pre><code class="language-bash">curl -OL https://github.com/second-state/wasmedge-quickjs/releases/download/v0.4.0-alpha/wasmedge_quickjs_tf.wasm
</code></pre>
<p>Here is an example of JavaScript. You could find the full code from <a href="https://github.com/second-state/wasmedge-quickjs/tree/main/example_js/tensorflow_lite_demo">example_js/tensorflow_lite_demo/</a>.</p>
<pre><code class="language-javascript">import {Image} from 'image';
import * as std from 'std';
import {TensorflowLiteSession} from 'tensorflow_lite';

let img = new Image(__dirname + '/food.jpg');
let img_rgb = img.to_rgb().resize(192, 192);
let rgb_pix = img_rgb.pixels();

let session = new TensorflowLiteSession(
    __dirname + '/lite-model_aiy_vision_classifier_food_V1_1.tflite');
session.add_input('input', rgb_pix);
session.run();
let output = session.get_output('MobilenetV1/Predictions/Softmax');
let output_view = new Uint8Array(output);
let max = 0;
let max_idx = 0;
for (var i in output_view) {
  let v = output_view[i];
  if (v &gt; max) {
    max = v;
    max_idx = i;
  }
}
let label_file = std.open(__dirname + '/aiy_food_V1_labelmap.txt', 'r');
let label = '';
for (var i = 0; i &lt;= max_idx; i++) {
  label = label_file.getline();
}
label_file.close();

print('label:');
print(label);
print('confidence:');
print(max / 255);
</code></pre>
<p>To run the JavaScript in the WasmEdge runtime, you can do the following on the CLI. You should now see the name of the food item recognized by the TensorFlow lite ImageNet model.</p>
<pre><code class="language-bash">$ wasmedge-tensorflow-lite --dir .:. /path/to/wasmedge_quickjs_tf.wasm example_js/tensorflow_lite_demo/main.js
label:
Hot dog
confidence:
0.8941176470588236
</code></pre>
<blockquote>
<p>The <code>wasmedge-tensorflow-lite</code> program is part of the WasmEdge package. It is the WasmEdge runtime with the Tensorflow extension built in.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="es6-module-support"><a class="header" href="#es6-module-support">ES6 module support</a></h1>
<p>The WasmEdge QuickJS runtime supports ES6 modules. In fact, the rollup commands we used in the <a href="write_wasm/js/ssr.html">React SSR</a> examples convert and bundle CommonJS and NPM modules into ES6 modules so that they can be executed in WasmEdge QuickJS. This article will show you how to use ES6 module in WasmEdge.</p>
<p>We will take the example in <a href="https://github.com/second-state/wasmedge-quickjs/tree/main/example_js/es6_module_demo">example_js/es6_module_demo</a> folder as an example. The <a href="https://github.com/second-state/wasmedge-quickjs/blob/main/example_js/es6_module_demo/module_def.js">module_def.js</a> file defines and exports a simple JS function.</p>
<pre><code class="language-javascript">function hello(){
  console.log('hello from module_def.js');
}

export {hello};
</code></pre>
<p>The <a href="https://github.com/second-state/wasmedge-quickjs/blob/main/example_js/es6_module_demo/module_def_async.js">module_def_async.js</a> file defines and exports an aysnc function and a variable.</p>
<pre><code class="language-javascript">export async function hello() {
  console.log('hello from module_def_async.js');
  return 'module_def_async.js : return value';
}

export var something = 'async thing';
</code></pre>
<p>The <a href="https://github.com/second-state/wasmedge-quickjs/blob/main/example_js/es6_module_demo/demo.js">demo.js</a> file imports functions and variables from those modules and executes them.</p>
<pre><code class="language-javascript">import {hello as module_def_hello} from './module_def.js';

module_def_hello();

var f = async () =&gt; {
  let {hello, something} = await import('./module_def_async.js');
  await hello();
  console.log('./module_def_async.js `something` is ', something);
};

f();
</code></pre>
<p>To run the example, you can do the following on the CLI.</p>
<pre><code class="language-bash">$ wasmedge --dir .:. /path/to/wasmedge_quickjs.wasm example_js/es6_module_demo/demo.js
hello from module_def.js
hello from module_def_async.js
./module_def_async.js `something` is  async thing
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="nodejs-and-npm-module"><a class="header" href="#nodejs-and-npm-module">NodeJS and NPM module</a></h1>
<p>With <a href="https://rollupjs.org/guide/en/">rollup.js</a>, we can run CommonJS (CJS) and NodeJS (NPM) modules in WasmEdge too. The <a href="https://github.com/second-state/wasmedge-quickjs/blob/main/example_js/simple_common_js_demo/npm_main.js">simple_common_js_demo/npm_main.js</a> demo shows how it works. It utilizes the third-party <code>md5</code> and <code>mathjs</code> modules.</p>
<pre><code class="language-javascript">const md5 = require('md5');
console.log('md5(message)=', md5('message'));

const {sqrt} = require('mathjs');
console.log('sqrt(-4)=', sqrt(-4).toString());
</code></pre>
<p>In order to run it, we must first use the <a href="https://rollupjs.org/guide/en/">rollup.js</a> tool to build all dependencies into a single file. In the process, <code>rollup.js</code> converts CommonJS modules into <a href="write_wasm/js/es6.html">WasmEdge-compatible ES6 modules</a>. The build script is <a href="https://github.com/second-state/wasmedge-quickjs/blob/main/example_js/simple_common_js_demo/rollup.config.js">rollup.config.js</a>.</p>
<pre><code class="language-javascript">const {babel} = require('@rollup/plugin-babel');
const nodeResolve = require('@rollup/plugin-node-resolve');
const commonjs = require('@rollup/plugin-commonjs');
const replace = require('@rollup/plugin-replace');

const globals = require('rollup-plugin-node-globals');
const builtins = require('rollup-plugin-node-builtins');
const plugin_async = require('rollup-plugin-async');

const babelOptions = {
  'presets': ['@babel/preset-react']
};

module.exports = [
  {
    input: './npm_main.js',
    output: {
      inlineDynamicImports: true,
      file: 'dist/npm_main.mjs',
      format: 'esm',
    },
    external: ['process', 'wasi_net','std'],
    plugins: [
      plugin_async(),
      nodeResolve(),
      commonjs({ignoreDynamicRequires: false}),
      babel(babelOptions),
      globals(),
      builtins(),
      replace({
        'process.env.NODE_ENV': JSON.stringify('production'),
        'process.env.NODE_DEBUG': JSON.stringify(''),
      }),
    ],
  },
];
</code></pre>
<p>The <a href="https://github.com/second-state/wasmedge-quickjs/blob/main/example_js/simple_common_js_demo/package.json">package.json</a> file specifies the <code>rollup.js</code> dependencies and the command to build the <a href="https://github.com/second-state/wasmedge-quickjs/blob/main/example_js/simple_common_js_demo/npm_main.js">npm_main.js</a> demo program into a single bundle.</p>
<pre><code class="language-json">{
  &quot;dependencies&quot;: {
    &quot;mathjs&quot;: &quot;^9.5.1&quot;,
    &quot;md5&quot;: &quot;^2.3.0&quot;
  },
  &quot;devDependencies&quot;: {
    &quot;@babel/core&quot;: &quot;^7.16.5&quot;,
    &quot;@babel/preset-env&quot;: &quot;^7.16.5&quot;,
    &quot;@babel/preset-react&quot;: &quot;^7.16.5&quot;,
    &quot;@rollup/plugin-babel&quot;: &quot;^5.3.0&quot;,
    &quot;@rollup/plugin-commonjs&quot;: &quot;^21.0.1&quot;,
    &quot;@rollup/plugin-node-resolve&quot;: &quot;^7.1.3&quot;,
    &quot;@rollup/plugin-replace&quot;: &quot;^3.0.0&quot;,
    &quot;rollup&quot;: &quot;^2.60.1&quot;,
    &quot;rollup-plugin-babel&quot;: &quot;^4.4.0&quot;,
    &quot;rollup-plugin-node-builtins&quot;: &quot;^2.1.2&quot;,
    &quot;rollup-plugin-node-globals&quot;: &quot;^1.4.0&quot;,
    &quot;rollup-plugin-async&quot;: &quot;^1.2.0&quot;
  },
  &quot;scripts&quot;: {
    &quot;build&quot;: &quot;rollup -c rollup.config.js&quot;
  }
}
</code></pre>
<p>Run the following NPM commands to build <a href="https://github.com/second-state/wasmedge-quickjs/blob/main/example_js/simple_common_js_demo/npm_main.js">npm_main.js</a> demo program into <code>dist/npm_main.mjs</code>.</p>
<pre><code class="language-bash">npm install
npm run build
cd ../../
</code></pre>
<p>Run the result JS file in WasmEdge CLI as follows.</p>
<pre><code class="language-bash">$ wasmedge --dir .:. /path/to/wasmedge_quickjs.wasm example_js/simple_common_js_demo/dist/npm_main.mjs
md5(message)= 78e731027d8fd50ed642340b7c9a63b3
sqrt(-4)= 2i
</code></pre>
<p>You can import and run any NPM packages in WasmEdge this way.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="system-modules"><a class="header" href="#system-modules">System modules</a></h1>
<p>The WasmEdge QuickJS runtime supports <a href="write_wasm/js/es6.html">ES6</a> and <a href="write_wasm/js/npm.html">NPM</a> modules for application developers. However, those approaches are too cumbersome for system developers. They need an easier way to add multiple JavaScript modules and APIs into the runtime without having to go through build tools like rollup.js. The WasmEdge QuickJS modules system allow developers to just drop JavaScript files into a <code>modules</code> folder, and have the JavaScript functions defined in the files immediately available to all JavaScript programs in the runtime. A good use case for this modules system is to support <a href="write_wasm/js/nodejs.html">Node.js</a> APIs in WasmEdge.</p>
<p>The module system is just a collection of JavaScript files in the <code>modules</code> directory in the WasmEdge QuickJS distribution. To use the JavaScript functions and APIs defined in those modules, you just need to map this directory to the <code>/modules</code> directory inside the WasmEdge Runtime instance. The following example shows how to do this on the WasmEdge CLI. You can do this with any of the host language SDKs that support embedded use of WasmEdge.</p>
<pre><code class="language-bash">$ ls modules

    buffer.js encoding.js events.js http.js
    ... JavaScript files for the modules ...

$ wasmedge --dir .:. target/wasm32-wasi/release/wasmedge_quickjs.wasm example_js/hello.js WasmEdge Runtime
</code></pre>
<p>The <a href="https://github.com/second-state/wasmedge-quickjs/tree/main/example_js/module_demo">module_demo</a> shows how you can use the modules system to add your own JavaScript APIs. To run the demo, first copy the two files in the demo's <a href="https://github.com/second-state/wasmedge-quickjs/tree/main/example_js/module_demo/modules">modules</a> directory to your WasmEdge QuickJS's <code>modules</code> directory.</p>
<pre><code class="language-bash">cp example_js/module_demo/modules/* modules/
</code></pre>
<p>The two JavaScript files in the <code>modules</code> directory provide two simple functions. Below is the <a href="https://github.com/second-state/wasmedge-quickjs/blob/main/example_js/module_demo/modules/my_mod_1.js">modules/my_mod_1.js</a> file.</p>
<pre><code class="language-javascript">export function hello_mod_1(){
  console.log('hello from &quot;my_mod_1.js&quot;')
}
</code></pre>
<p>And the <a href="https://github.com/second-state/wasmedge-quickjs/blob/main/example_js/module_demo/modules/my_mod_2.js">modules/my_mod_2.js</a> file.</p>
<pre><code class="language-javascript">export function hello_mod_2(){
  console.log('hello from &quot;my_mod_2.js&quot;')
}
</code></pre>
<p>Then, just run the <a href="https://github.com/second-state/wasmedge-quickjs/blob/main/example_js/module_demo/demo.js">demo.js</a> file to call the two exported functions from the modules.</p>
<pre><code class="language-javascript">import { hello_mod_1 } from 'my_mod_1'
import { hello_mod_2 } from 'my_mod_2'

hello_mod_1()
hello_mod_2()
</code></pre>
<p>Here is the command to run the demo and the output.</p>
<pre><code class="language-bash">$ wasmedge --dir .:. target/wasm32-wasi/release/wasmedge_quickjs.wasm example_js/module_demo/demo.js

hello from &quot;my_mod_1.js&quot;
hello from &quot;my_mod_2.js&quot;
</code></pre>
<p>Following the above tutorials, you can easily add third-party JavaScript functions and APIs into your WasmEdge QuickJS runtime. For the official distribution, we included JavaScript files to support <a href="write_wasm/js/nodejs.html">Node.js APIs</a>. You can use <a href="https://github.com/second-state/wasmedge-quickjs/tree/main/modules">those files</a> as further examples.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="use-rust-to-implement-js-api"><a class="header" href="#use-rust-to-implement-js-api">Use Rust to implement JS API</a></h1>
<p>For JavaScript developers, incorporating Rust functions into JavaScript APIs is useful. That enables developers to write programs in &quot;pure JavaScript&quot; and yet still take advantage of the high performance Rust functions. With the <a href="https://github.com/WasmEdge/WasmEdge">WasmEdge Runtime</a>, you can do exactly that.</p>
<blockquote>
<p>The <a href="https://github.com/second-state/wasmedge-quickjs/tree/main/src/internal_module">internal_module</a> folder in the official WasmEdge QuickJS distribution provides Rust-based implementations of some built-in JavaScript API functions. Those functions typically require interactions with host functions in the WasmEdge runtime (e.g., networking and tensorflow), and hence cannot be accessed by pure JavaScript implementations in <a href="write_wasm/js/modules.html">modules</a>.</p>
</blockquote>
<p>Check out the <a href="https://github.com/second-state/wasmedge-quickjs/">wasmedge-quickjs</a> Github repo and change to the <code>examples/embed_js</code> folder to follow along.</p>
<pre><code class="language-bash">git clone https://github.com/second-state/wasmedge-quickjs
cd examples/embed_js
</code></pre>
<blockquote>
<p>You must have <a href="https://www.rust-lang.org/tools/install">Rust</a> and <a href="write_wasm/js/../../quick_start/install.html">WasmEdge</a> installed to build and run the examples we show you.</p>
</blockquote>
<p>The <code>embed_js</code> demo showcases several different examples on how to embed JavaScript inside Rust. You can build and run all the examples as follows.</p>
<pre><code class="language-bash">cargo build --target wasm32-wasi --release
wasmedge --dir .:. target/wasm32-wasi/release/embed_js.wasm
</code></pre>
<blockquote>
<p>Note: The <code>--dir .:.</code> on the command line is to give wasmedge permission to read the local directory in the file system.</p>
</blockquote>
<h2 id="create-a-javascript-function-api"><a class="header" href="#create-a-javascript-function-api">Create a JavaScript function API</a></h2>
<p>The following code snippet defines a Rust function that can be incorporate into the JavaScript interpreter as an API.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn run_rust_function(ctx: &amp;mut Context) {

  struct HelloFn;
  impl JsFn for HelloFn {
    fn call(_ctx: &amp;mut Context, _this_val: JsValue, argv: &amp;[JsValue]) -&gt; JsValue {
      println!(&quot;hello from rust&quot;);
      println!(&quot;argv={:?}&quot;, argv);
      JsValue::UnDefined
    }
  }
  
  ...
}
<span class="boring">}
</span></code></pre></pre>
<p>The following code snippet shows how to add this Rust function into the JavaScript interpreter, give a name <code>hi()</code> as its JavaScript API, and then call it from JavaScript code.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn run_rust_function(ctx: &amp;mut Context) {
  ...
  
  let f = ctx.new_function::&lt;HelloFn&gt;(&quot;hello&quot;);
  ctx.get_global().set(&quot;hi&quot;, f.into());
  let code = r#&quot;hi(1,2,3)&quot;#;
  let r = ctx.eval_global_str(code);
  println!(&quot;return value:{:?}&quot;, r);
}
<span class="boring">}
</span></code></pre></pre>
<p>The execution result is as follows.</p>
<pre><code class="language-bash">hello from rust
argv=[Int(1), Int(2), Int(3)]
return value:UnDefined
</code></pre>
<p>Using this approach, you can create a JavaScript interpreter with customized API functions. The interpreter runs inside WasmEdge, and can execute JavaScript code, which calls such API functions, from CLI or the network.</p>
<h2 id="create-a-javascript-object-api"><a class="header" href="#create-a-javascript-object-api">Create a JavaScript object API</a></h2>
<p>In the JavaScript API design, we sometimes need to provide an object that encapsulates both data and function. In the following example, we define a Rust function for the JavaScript API.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn rust_new_object_and_js_call(ctx: &amp;mut Context) {
  struct ObjectFn;
  impl JsFn for ObjectFn {
    fn call(_ctx: &amp;mut Context, this_val: JsValue, argv: &amp;[JsValue]) -&gt; JsValue {
      println!(&quot;hello from rust&quot;);
      println!(&quot;argv={:?}&quot;, argv);
      if let JsValue::Object(obj) = this_val {
        let obj_map = obj.to_map();
        println!(&quot;this={:#?}&quot;, obj_map);
      }
      JsValue::UnDefined
    }
  }

  ...
}
<span class="boring">}
</span></code></pre></pre>
<p>We then create an &quot;object&quot; on the Rust side, set its data fields, and then register the Rust function as a JavaScript function associated with the objects.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut obj = ctx.new_object();
obj.set(&quot;a&quot;, 1.into());
obj.set(&quot;b&quot;, ctx.new_string(&quot;abc&quot;).into());

let f = ctx.new_function::&lt;ObjectFn&gt;(&quot;anything&quot;);
obj.set(&quot;f&quot;, f.into());
<span class="boring">}
</span></code></pre></pre>
<p>Next, we make the Rust &quot;object&quot; available as JavaScript object <code>test_obj</code> in the JavaScript interpreter.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>ctx.get_global().set(&quot;test_obj&quot;, obj.into());
<span class="boring">}
</span></code></pre></pre>
<p>In the JavaScript code, you can now directly use <code>test_obj</code> as part of the API.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let code = r#&quot;
  print('test_obj keys=',Object.keys(test_obj))
  print('test_obj.a=',test_obj.a)
  print('test_obj.b=',test_obj.b)
  test_obj.f(1,2,3,&quot;hi&quot;)
&quot;#;

ctx.eval_global_str(code);
<span class="boring">}
</span></code></pre></pre>
<p>The execution result is as follows.</p>
<pre><code class="language-bash">test_obj keys= a,b,f
test_obj.a= 1
test_obj.b= abc
hello from rust
argv=[Int(1), Int(2), Int(3), String(JsString(hi))]
this=Ok(
  {
    &quot;a&quot;: Int(
      1,
    ),
    &quot;b&quot;: String(
      JsString(
        abc,
      ),
    ),
    &quot;f&quot;: Function(
      JsFunction(
        function anything() {
          [native code]
        },
      ),
    ),
  },
)
</code></pre>
<h2 id="a-complete-javascript-object-api"><a class="header" href="#a-complete-javascript-object-api">A complete JavaScript object API</a></h2>
<p>In the previous example, we demonstrated simple examples to create JavaScript APIs from Rust. In this example, we will create a complete Rust module and make it available as a JavaScript object API. The project is in the <a href="https://github.com/second-state/wasmedge-quickjs/tree/main/examples/embed_rust_module">examples/embed_rust_module</a> folder. You can build and run it as a standard Rust application in WasmEdge.</p>
<pre><code class="language-bash">cargo build --target wasm32-wasi --release
wasmedge --dir .:. target/wasm32-wasi/release/embed_rust_module.wasm
</code></pre>
<p>The Rust implementation of the object is a module as follows. It has data fields, constructor, getters and setters, and functions.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>mod point {
  use wasmedge_quickjs::*;

  #[derive(Debug)]
  struct Point(i32, i32);

  struct PointDef;

  impl JsClassDef&lt;Point&gt; for PointDef {
    const CLASS_NAME: &amp;'static str = &quot;Point\0&quot;;
    const CONSTRUCTOR_ARGC: u8 = 2;

    fn constructor(_: &amp;mut Context, argv: &amp;[JsValue]) -&gt; Option&lt;Point&gt; {
      println!(&quot;rust-&gt; new Point {:?}&quot;, argv);
      let x = argv.get(0);
      let y = argv.get(1);
      if let ((Some(JsValue::Int(ref x)), Some(JsValue::Int(ref y)))) = (x, y) {
        Some(Point(*x, *y))
      } else {
        None
      }
    }

    fn proto_init(p: &amp;mut JsClassProto&lt;Point, PointDef&gt;) {
      struct X;
      impl JsClassGetterSetter&lt;Point&gt; for X {
        const NAME: &amp;'static str = &quot;x\0&quot;;

        fn getter(_: &amp;mut Context, this_val: &amp;mut Point) -&gt; JsValue {
          println!(&quot;rust-&gt; get x&quot;);
          this_val.0.into()
        }

        fn setter(_: &amp;mut Context, this_val: &amp;mut Point, val: JsValue) {
          println!(&quot;rust-&gt; set x:{:?}&quot;, val);
          if let JsValue::Int(x) = val {
            this_val.0 = x
          }
        }
      }

      struct Y;
      impl JsClassGetterSetter&lt;Point&gt; for Y {
        const NAME: &amp;'static str = &quot;y\0&quot;;

        fn getter(_: &amp;mut Context, this_val: &amp;mut Point) -&gt; JsValue {
          println!(&quot;rust-&gt; get y&quot;);
          this_val.1.into()
        }

        fn setter(_: &amp;mut Context, this_val: &amp;mut Point, val: JsValue) {
          println!(&quot;rust-&gt; set y:{:?}&quot;, val);
          if let JsValue::Int(y) = val {
            this_val.1 = y
          }
        }
      }

      struct FnPrint;
      impl JsMethod&lt;Point&gt; for FnPrint {
        const NAME: &amp;'static str = &quot;pprint\0&quot;;
        const LEN: u8 = 0;

        fn call(_: &amp;mut Context, this_val: &amp;mut Point, _argv: &amp;[JsValue]) -&gt; JsValue {
          println!(&quot;rust-&gt; pprint: {:?}&quot;, this_val);
          JsValue::Int(1)
        }
      }

      p.add_getter_setter(X);
      p.add_getter_setter(Y);
      p.add_function(FnPrint);
    }
  }

  struct PointModule;
  impl ModuleInit for PointModule {
    fn init_module(ctx: &amp;mut Context, m: &amp;mut JsModuleDef) {
      m.add_export(&quot;Point\0&quot;, PointDef::class_value(ctx));
    }
  }

  pub fn init_point_module(ctx: &amp;mut Context) {
    ctx.register_class(PointDef);
    ctx.register_module(&quot;point\0&quot;, PointModule, &amp;[&quot;Point\0&quot;]);
  }
}
<span class="boring">}
</span></code></pre></pre>
<p>In the interpreter implementation, we call <code>point::init_point_module</code> first to register the Rust module with the JavaScript context, and then we can run a JavaScript program that simply use the <code>point</code> object.</p>
<pre><pre class="playground"><code class="language-rust">use wasmedge_quickjs::*;
fn main() {
  let mut ctx = Context::new();
  point::init_point_module(&amp;mut ctx);

  let code = r#&quot;
    import('point').then((point)=&gt;{
    let p0 = new point.Point(1,2)
    print(&quot;js-&gt;&quot;,p0.x,p0.y)
    p0.pprint()
    try{
      let p = new point.Point()
      print(&quot;js-&gt; p:&quot;,p)
      print(&quot;js-&gt;&quot;,p.x,p.y)
      p.x=2
      p.pprint()
    } catch(e) {
      print(&quot;An error has been caught&quot;);
      print(e)
    }  
    })
  &quot;#;

  ctx.eval_global_str(code);
  ctx.promise_loop_poll();
}
</code></pre></pre>
<p>The execution result from the above application is as follows.</p>
<pre><code class="language-bash">rust-&gt; new Point [Int(1), Int(2)]
rust-&gt; get x
rust-&gt; get y
js-&gt; 1 2
rust-&gt; pprint: Point(1, 2)
rust-&gt; new Point []
js-&gt; p: undefined
An error has been caught
TypeError: cannot read property 'x' of undefined
</code></pre>
<h2 id="code-reuse"><a class="header" href="#code-reuse">Code reuse</a></h2>
<p>Using the Rust API, we could create JavaScript classes that inherit (or extend) from existing classes. That allows developers to create complex JavaScript APIs using Rust by building on existing solutions. You can see <a href="https://github.com/second-state/wasmedge-quickjs/blob/main/examples/js_extend.rs">an example here</a>.</p>
<p>Next, you can see the Rust code in the <a href="https://github.com/second-state/wasmedge-quickjs/tree/main/src/internal_module">internal_module</a> folder for more examples on how to implement common JavaScript build-in functions including <a href="write_wasm/js/nodejs.html">Node.js</a> APIs.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="go"><a class="header" href="#go">Go</a></h1>
<p>The best way to run Go programs in WasmEdge is to compile Go source code to WebAssembly using <a href="https://tinygo.org/">TinyGo</a>. In this article, we will show you how.</p>
<h2 id="install-tinygo"><a class="header" href="#install-tinygo">Install TinyGo</a></h2>
<p>You must have <a href="https://go.dev/doc/install">Go already installed</a> on your machine before installing TinyGo. Go v1.17 or above is recommended.
For Ubuntu or other Debian-based Linux systems on x86 processors, you could use the following command line to install TinyGo. For other platforms, please refer to <a href="https://tinygo.org/getting-started/install/">TinyGo docs</a>.</p>
<pre><code class="language-bash">wget https://github.com/tinygo-org/tinygo/releases/download/v0.21.0/tinygo_0.21.0_amd64.deb
sudo dpkg -i tinygo_0.21.0_amd64.deb`
</code></pre>
<p>Next, run the following command line to check out if the installation is successful.</p>
<pre><code class="language-bash">$ tinygo version
tinygo version 0.21.0 linux/amd64 (using go version go1.16.7 and LLVM version 11.0.0)
</code></pre>
<h2 id="hello-world-2"><a class="header" href="#hello-world-2">Hello world</a></h2>
<p>The simple Go app has a <code>main()</code> function to print a message to the console.
The source code in <code>main.go</code> file is as follows.</p>
<pre><code class="language-go">package main

func main() {
  println(&quot;Hello TinyGo from WasmEdge!&quot;)
}
</code></pre>
<blockquote>
<p>Inside the <code>main()</code> function, you can use Go standard API to read / write files, and access command line arguments and <code>env</code> variables.</p>
</blockquote>
<h3 id="hello-world-compile-and-build"><a class="header" href="#hello-world-compile-and-build">Hello world: Compile and build</a></h3>
<p>Next, compile the <code>main.go</code> program to WebAssembly using TinyGo.</p>
<pre><code class="language-bash">tinygo build -o hello.wasm -target wasi main.go
</code></pre>
<p>You will see a file named <code>hello.wasm</code> in the same directory. This is a WebAssembly bytecode file.</p>
<h3 id="hello-world-run"><a class="header" href="#hello-world-run">Hello world: Run</a></h3>
<p>You can run it with the <a href="write_wasm/../cli/wasmedge.html">WasmEdge CLI</a>.</p>
<pre><code class="language-bash">$ wasmedge hello.wasm
Hello TinyGo from WasmEdge!
</code></pre>
<h2 id="a-simple-function-1"><a class="header" href="#a-simple-function-1">A simple function</a></h2>
<p>The second example is a Go function that takes a call parameter to compute a fibonacci number. However, in order for the Go application to set up proper access to the OS (e.g., to access the command line arguments), you must include an empty <code>main()</code> function in the source code.</p>
<pre><code class="language-go">package main

func main(){
}

//export fibArray
func fibArray(n int32) int32{
  arr := make([]int32, n)
  for i := int32(0); i &lt; n; i++ {
    switch {
    case i &lt; 2:
      arr[i] = i
    default:
      arr[i] = arr[i-1] + arr[i-2]
    }
  }
  return arr[n-1]
}
</code></pre>
<h3 id="a-simple-function-compile-and-build"><a class="header" href="#a-simple-function-compile-and-build">A simple function: Compile and build</a></h3>
<p>Next, compile the <code>main.go</code> program to WebAssembly using TinyGo.</p>
<pre><code class="language-bash">tinygo build -o fib.wasm -target wasi main.go
</code></pre>
<p>You will see a file named <code>fib.wasm</code> in the same directory. This is a WebAssembly bytecode file.</p>
<h3 id="a-simple-function-run"><a class="header" href="#a-simple-function-run">A simple function: Run</a></h3>
<p>You can run it with the <a href="write_wasm/../cli/wasmedge.html">WasmEdge CLI</a> in its <code>--reactor</code> mode.
The command line arguments that follow the <code>wasm</code> file are the function name and its call parameters.</p>
<pre><code class="language-bash">$ wasmedge --reactor fib.wasm fibArray 10
34
</code></pre>
<h2 id="improve-performance"><a class="header" href="#improve-performance">Improve performance</a></h2>
<p>To achieve native Go performance for those applications, you could use the <code>wasmedgec</code> command to AOT compile the <code>wasm</code> program, and then run it with the <code>wasmedge</code> command.</p>
<pre><code class="language-bash">$ wasmedgec hello.wasm hello.wasm

$ wasmedge hello.wasm
Hello TinyGo from WasmEdge!
</code></pre>
<p>For the <code>--reactor</code> mode,</p>
<pre><code class="language-bash">$ wasmedgec fib.wasm fib.wasm

$ wasmedge --reactor fib.wasm fibArray 10
34
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="swift"><a class="header" href="#swift">Swift</a></h1>
<p>The <a href="https://swiftwasm.org/">swiftwasm</a> project compiles Swift source code to WebAssembly.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="assemblyscript"><a class="header" href="#assemblyscript">AssemblyScript</a></h1>
<p><a href="https://www.assemblyscript.org/">AssemblyScript</a> is a TypeScript-like language designed for WebAssembly. AssemblyScript programs can be easily compiled into WebAssembly.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="kotlin"><a class="header" href="#kotlin">Kotlin</a></h1>
<p>Check out how to <a href="https://blog.jdriven.com/2021/04/running-kotlin-in-the-browser-with-wasm/">compile Kotlin programs to WebAssembly</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="grain"><a class="header" href="#grain">Grain</a></h1>
<p><a href="https://grain-lang.org/">Grain</a> is a strongly typed languages designed for WebAssembly. Checkout its <a href="https://grain-lang.org/docs/guide/hello_world">Hello world</a> example.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="python"><a class="header" href="#python">Python</a></h1>
<p>There are already several different language implementations of the Python runtime, and some of them support WebAssembly. This document will describe how to run <a href="https://github.com/RustPython/RustPython">RustPython</a> on WasmEdge to execute Python programs.</p>
<h2 id="compile-rustpython"><a class="header" href="#compile-rustpython">Compile RustPython</a></h2>
<p>To compile RustPython, you should have the Rust toolchain installed on your machine. And <code>wasm32-wasi</code> platform support should be enabled.</p>
<pre><code class="language-bash">rustup target add wasm32-wasi
</code></pre>
<p>Then you could use the following command to clone and compile RustPython:</p>
<pre><code class="language-bash">git clone https://github.com/RustPython/RustPython.git
cd RustPython
cargo build --release --target wasm32-wasi --features=&quot;freeze-stdlib&quot;
</code></pre>
<p><code>freeze-stdlib</code> feature is enabled for including Python standard library inside the binary file. The output file should be able at <code>target/wasm32-wasi/release/rustpython.wasm</code>.</p>
<h2 id="aot-compile"><a class="header" href="#aot-compile">AOT Compile</a></h2>
<p>WasmEdge supports compiling WebAssembly bytecode programs into native machine code for better performance. It is highly recommended to compile the RustPython to native machine code before running.</p>
<pre><code class="language-bash">wasmedgec ./target/wasm32-wasi/release/rustpython.wasm ./target/wasm32-wasi/release/rustpython.wasm
</code></pre>
<h2 id="run-2"><a class="header" href="#run-2">Run</a></h2>
<pre><code class="language-bash">wasmedge ./target/wasm32-wasi/release/rustpython.wasm
</code></pre>
<p>Then you could get a Python shell in WebAssembly!</p>
<h2 id="grant-file-system-access"><a class="header" href="#grant-file-system-access">Grant file system access</a></h2>
<p>You can pre-open directories to let WASI programs have permission to read and write files stored on the real machine. The following command mounted the current working directory to the WASI virtual file system.</p>
<pre><code class="language-bash">wasmedge --dir .:. ./target/wasm32-wasi/release/rustpython.wasm
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="use-wasmedge-library-in-programming-languages"><a class="header" href="#use-wasmedge-library-in-programming-languages">Use WasmEdge Library in Programming Languages</a></h1>
<p>Besides using the WasmEdge command line tools to executing the WebAssembly applications, WasmEdge also provides SDKs for various programming languages.
The WasmEdge library allows developers to embed the WasmEdge into their host applications, so that the WebAssembly applications can be executed in the WasmEdge sandbox safely.
Furthermore, developers can implement the host functions for the extensions with the WasmEdge library.</p>
<p>In this chapter, we will discuss how to use WasmEdge SDKs to embed WasmEdge into <a href="sdk/c.html">C</a>, <a href="sdk/rust.html">Rust</a>, <a href="sdk/go.html">Go</a>, <a href="sdk/node.html">Node.js</a>, and <a href="sdk/python.html">Python</a> host applications.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="wasmedge-c-sdk"><a class="header" href="#wasmedge-c-sdk">WasmEdge C SDK</a></h1>
<p>The WasmEdge C API denotes an interface to embed the WasmEdge runtime into a C program. The followings are the quick start guide for working with the C APIs of WasmEdge. For the details of the WasmEdge C API, please refer to the <a href="sdk/c/ref.html">full documentation</a>. Before programming with the WasmEdge C API, please <a href="sdk/../quick_start/install.html">install WasmEdge</a> first.</p>
<p>The WasmEdge C API is also the fundamental API for other languages' SDK.</p>
<h2 id="quick-start-guide-for-the-wasmedge-runner"><a class="header" href="#quick-start-guide-for-the-wasmedge-runner">Quick Start Guide for the WasmEdge runner</a></h2>
<p>The following is an example for running a WASM file.
Assume that the WASM file <a href="https://github.com/WasmEdge/WasmEdge/raw/master/examples/wasm/fibonacci.wasm">fibonacci.wasm</a> is copied into the current directory, and the C file <code>test_wasmedge.c</code> is as following:</p>
<pre><code class="language-c">#include &lt;wasmedge/wasmedge.h&gt;
#include &lt;stdio.h&gt;
int main(int Argc, const char* Argv[]) {
  /* Create the configure context and add the WASI support. */
  /* This step is not necessary unless you need WASI support. */
  WasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();
  WasmEdge_ConfigureAddHostRegistration(ConfCxt, WasmEdge_HostRegistration_Wasi);
  /* The configure and store context to the VM creation can be NULL. */
  WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(ConfCxt, NULL);

  /* The parameters and returns arrays. */
  WasmEdge_Value Params[1] = { WasmEdge_ValueGenI32(32) };
  WasmEdge_Value Returns[1];
  /* Function name. */
  WasmEdge_String FuncName = WasmEdge_StringCreateByCString(&quot;fib&quot;);
  /* Run the WASM function from file. */
  WasmEdge_Result Res = WasmEdge_VMRunWasmFromFile(VMCxt, Argv[1], FuncName, Params, 1, Returns, 1);

  if (WasmEdge_ResultOK(Res)) {
    printf(&quot;Get result: %d\n&quot;, WasmEdge_ValueGetI32(Returns[0]));
  } else {
    printf(&quot;Error message: %s\n&quot;, WasmEdge_ResultGetMessage(Res));
  }

  /* Resources deallocations. */
  WasmEdge_VMDelete(VMCxt);
  WasmEdge_ConfigureDelete(ConfCxt);
  WasmEdge_StringDelete(FuncName);
  return 0;
}
</code></pre>
<p>Then you can compile and run: (the 32th fibonacci number is 3524578 in 0-based index)</p>
<pre><code class="language-bash">$ gcc test_wasmedge.c -lwasmedge -o test_wasmedge
$ ./test_wasmedge fibonacci.wasm
Get result: 3524578
</code></pre>
<h2 id="quick-start-guide-for-the-wasmedge-aot-compiler"><a class="header" href="#quick-start-guide-for-the-wasmedge-aot-compiler">Quick Start Guide for the WasmEdge AOT compiler</a></h2>
<p>Assume that the WASM file <a href="https://github.com/WasmEdge/WasmEdge/raw/master/examples/wasm/fibonacci.wasm">fibonacci.wasm</a> is copied into the current directory, and the C file <code>test_wasmedge_compiler.c</code> is as following:</p>
<pre><code class="language-c">#include &lt;wasmedge/wasmedge.h&gt;
#include &lt;stdio.h&gt;
int main(int Argc, const char* Argv[]) {
  /* Create the configure context. */
  WasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();
  /* ... Adjust settings in the configure context. */
  /* Result. */
  WasmEdge_Result Res;

  /* Create the compiler context. The configure context can be NULL. */
  WasmEdge_CompilerContext *CompilerCxt = WasmEdge_CompilerCreate(ConfCxt);
  /* Compile the WASM file with input and output paths. */
  Res = WasmEdge_CompilerCompile(CompilerCxt, Argv[1], Argv[2]);
  if (!WasmEdge_ResultOK(Res)) {
    printf(&quot;Compilation failed: %s\n&quot;, WasmEdge_ResultGetMessage(Res));
    return 1;
  }

  WasmEdge_CompilerDelete(CompilerCxt);
  WasmEdge_ConfigureDelete(ConfCxt);
  return 0;
}
</code></pre>
<p>Then you can compile and run (the output file is <code>fibonacci_aot.wasm</code>):</p>
<pre><code class="language-bash">$ gcc test_wasmedge_compiler.c -lwasmedge -o test_wasmedge_compiler
$ ./test_wasmedge_compiler fibonacci.wasm fibonacci_aot.wasm
[2021-07-02 11:08:08.651] [info] compile start
[2021-07-02 11:08:08.653] [info] verify start
[2021-07-02 11:08:08.653] [info] optimize start
[2021-07-02 11:08:08.670] [info] codegen start
[2021-07-02 11:08:08.706] [info] compile done
</code></pre>
<p>The compiled-WASM file can be used as a WASM input for the WasmEdge runner.
The following is the comparison of the interpreter mode and the AOT mode:</p>
<pre><code class="language-bash">$ time ./test_wasmedge fibonacci.wasm
Get result: 5702887

real 0m2.715s
user 0m2.700s
sys 0m0.008s

$ time ./test_wasmedge fibonacci_aot.wasm
Get result: 5702887

real 0m0.036s
user 0m0.022s
sys 0m0.011s
</code></pre>
<h2 id="api-references"><a class="header" href="#api-references">API References</a></h2>
<ul>
<li><a href="sdk/c/ref.html">0.11.0</a></li>
<li><a href="sdk/c/0.10.1/ref.html">0.10.1</a>
<ul>
<li><a href="sdk/c/0.10.1/upgrade_to_0.11.0.html">Upgrade to 0.11.0</a></li>
</ul>
</li>
<li><a href="sdk/c/0.9.1/ref.html">0.9.1</a>
<ul>
<li><a href="sdk/c/0.9.1/upgrade_to_0.10.0.html">Upgrade to 0.10.0</a></li>
</ul>
</li>
</ul>
<h2 id="examples-1"><a class="header" href="#examples-1">Examples</a></h2>
<ul>
<li>Use the <a href="sdk/c/externref.html">external reference</a> of WebAssembly input and output in C/C++</li>
<li>Implement the <a href="sdk/c/hostfunction.html">host functions</a> in C/C++</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="host-functions"><a class="header" href="#host-functions">Host Functions</a></h1>
<p><a href="https://webassembly.github.io/spec/core/exec/runtime.html#syntax-hostfunc">Host functions</a> are the functions outside WebAssembly and passed to WASM modules as imports.
The following steps give an example of implementing host functions and registering a <code>host module</code> into the WasmEdge runtime.</p>
<h2 id="host-instances"><a class="header" href="#host-instances">Host Instances</a></h2>
<p>WasmEdge supports registering <code>host function</code>, <code>memory</code>, <code>table</code>, and <code>global</code> instances as imports.</p>
<h3 id="functions-1"><a class="header" href="#functions-1">Functions</a></h3>
<p>The host function body definition in WasmEdge is defined as follows:</p>
<pre><code class="language-c">typedef WasmEdge_Result (*WasmEdge_HostFunc_t)(
    void *Data, const WasmEdge_CallingFrameContext *CallFrameCxt,
    const WasmEdge_Value *Params, WasmEdge_Value *Returns);
</code></pre>
<p>A simple host function can be defined as follows:</p>
<pre><code class="language-c">#include &lt;wasmedge/wasmedge.h&gt;

/* This function can add 2 i32 values and return the result. */
WasmEdge_Result Add(void *, const WasmEdge_CallingFrameContext *,
                    const WasmEdge_Value *In, WasmEdge_Value *Out) {
  /*
  * Params: {i32, i32}
  * Returns: {i32}
  */
 
  /* Retrieve the value 1. */
  int32_t Val1 = WasmEdge_ValueGetI32(In[0]);
  /* Retrieve the value 2. */
  int32_t Val2 = WasmEdge_ValueGetI32(In[1]);
  /* Output value 1 is Val1 + Val2. */
  Out[0] = WasmEdge_ValueGenI32(Val1 + Val2);
  /* Return the status of success. */
  return WasmEdge_Result_Success;
}
</code></pre>
<p>For adding the host function into a host module instance, developers should create the function instance with the function type context first.</p>
<pre><code class="language-c">enum WasmEdge_ValType ParamList[2] = {WasmEdge_ValType_I32,
                                      WasmEdge_ValType_I32};
enum WasmEdge_ValType ReturnList[1] = {WasmEdge_ValType_I32};
/* Create a function type: {i32, i32} -&gt; {i32}. */
WasmEdge_FunctionTypeContext *HostFType =
    WasmEdge_FunctionTypeCreate(ParamList, 2, ReturnList, 1);
/*
  * Create a function context with the function type and host function body.
  * The `Cost` parameter can be 0 if developers do not need the cost
  * measuring.
  */
WasmEdge_FunctionInstanceContext *HostFunc =
    WasmEdge_FunctionInstanceCreate(HostFType, Add, NULL, 0);
/*
  * The third parameter is the pointer to the additional data.
  * Developers should guarantee the life cycle of the data, and it can be NULL if the external data is not needed.
  */
WasmEdge_FunctionTypeDelete(HostType);
</code></pre>
<h3 id="tables-memories-and-globals"><a class="header" href="#tables-memories-and-globals">Tables, Memories, and Globals</a></h3>
<p>To create a <code>host table</code>, <code>memory</code>, and <code>global</code> instance, developers can use similar APIs.</p>
<pre><code class="language-c">/* Create a host table exported as &quot;table&quot;. */
WasmEdge_Limit TabLimit = {
    .HasMax = true, .Shared = false, .Min = 10, .Max = 20};
WasmEdge_TableTypeContext *HostTType =
    WasmEdge_TableTypeCreate(WasmEdge_RefType_FuncRef, TabLimit);
WasmEdge_TableInstanceContext *HostTable =
    WasmEdge_TableInstanceCreate(HostTType);
WasmEdge_TableTypeDelete(HostTType);

/* Create a host memory exported as &quot;memory&quot;. */
WasmEdge_Limit MemLimit = {.HasMax = true, .Shared = false, .Min = 1, .Max = 2};
WasmEdge_MemoryTypeContext *HostMType = WasmEdge_MemoryTypeCreate(MemLimit);
WasmEdge_MemoryInstanceContext *HostMemory =
    WasmEdge_MemoryInstanceCreate(HostMType);
WasmEdge_MemoryTypeDelete(HostMType);

/* Create a host global exported as &quot;global_i32&quot; and initialized as `666`. */
WasmEdge_GlobalTypeContext *HostGType =
    WasmEdge_GlobalTypeCreate(WasmEdge_ValType_I32, WasmEdge_Mutability_Const);
WasmEdge_GlobalInstanceContext *HostGlobal =
    WasmEdge_GlobalInstanceCreate(HostGType, WasmEdge_ValueGenI32(666));
WasmEdge_GlobalTypeDelete(HostGType);
</code></pre>
<h2 id="host-modules"><a class="header" href="#host-modules">Host Modules</a></h2>
<p>The host module is a module instance that contains <code>host functions</code>, <code>tables</code>, <code>memories</code>, and <code>globals</code>, the same as the WASM modules. Developers can use APIs to add the instances into a host module.
After registering the host modules into a <code>VM</code> or <code>Store</code> context, the exported instances in that modules can be imported by WASM modules when instantiating.</p>
<h3 id="module-instance-creation"><a class="header" href="#module-instance-creation">Module Instance Creation</a></h3>
<p>Module instance supplies exported module name.</p>
<pre><code class="language-c">WasmEdge_String HostName = WasmEdge_StringCreateByCString(&quot;test&quot;);
WasmEdge_ModuleInstanceContext *HostMod =
    WasmEdge_ModuleInstanceCreate(HostName);
WasmEdge_StringDelete(HostName);
</code></pre>
<h3 id="add-instances"><a class="header" href="#add-instances">Add Instances</a></h3>
<p>Developers can add the <code>host functions</code>, <code>tables</code>, <code>memories</code>, and <code>globals</code> into the module instance with the export name.
After adding to the module, the ownership of the instances is moved into the module. Developers should <strong>NOT</strong> access or destroy them.</p>
<pre><code class="language-c">/* Add the host function created above with the export name &quot;add&quot;. */
HostName = WasmEdge_StringCreateByCString(&quot;add&quot;);
WasmEdge_ModuleInstanceAddFunction(HostMod, HostName, HostFunc);
WasmEdge_StringDelete(HostName);

/* Add the table created above with the export name &quot;table&quot;. */
HostName = WasmEdge_StringCreateByCString(&quot;table&quot;);
WasmEdge_ModuleInstanceAddTable(HostMod, HostName, HostTable);
WasmEdge_StringDelete(HostName);

/* Add the memory created above with the export name &quot;memory&quot;. */
HostName = WasmEdge_StringCreateByCString(&quot;memory&quot;);
WasmEdge_ModuleInstanceAddMemory(HostMod, HostName, HostMemory);
WasmEdge_StringDelete(HostName);

/* Add the global created above with the export name &quot;global_i32&quot;. */
HostName = WasmEdge_StringCreateByCString(&quot;global_i32&quot;);
WasmEdge_ModuleInstanceAddGlobal(HostMod, HostName, HostGlobal);
WasmEdge_StringDelete(HostName);
</code></pre>
<h3 id="register-host-modules-to-wasmedge"><a class="header" href="#register-host-modules-to-wasmedge">Register Host Modules to WasmEdge</a></h3>
<p>For importing the host functions in WASM, developers can register the host modules into a <code>VM</code> or <code>Store</code> context.</p>
<pre><code class="language-c">WasmEdge_StoreContext *StoreCxt = WasmEdge_StoreCreate();
WasmEdge_ExecutorContext *ExecCxt = WasmEdge_ExecutorCreate(NULL, NULL);

/* Register the module instance into the store. */
WasmEdge_Result Res =
    WasmEdge_ExecutorRegisterImport(ExecCxt, StoreCxt, HostModCxt);
if (!WasmEdge_ResultOK(Res)) {
  printf(&quot;Host module registration failed: %s\n&quot;,
         WasmEdge_ResultGetMessage(Res));
  return -1;
}
/*
 * Developers can register the host module into a VM context by the
 * `WasmEdge_VMRegisterModuleFromImport()` API.
 */
/*
 * The owner of the host module will not be changed. Developers can register
 * the host module into several VMs or stores.
 */

/* Although being registered, the host module should be destroyed. */
WasmEdge_StoreDelete(StoreCxt);
WasmEdge_ExecutorDelete(ExecCxt);
WasmEdge_ModuleInstanceDelete(HostModCxt);
</code></pre>
<h2 id="host-function-body-implementation-tips"><a class="header" href="#host-function-body-implementation-tips">Host Function Body Implementation Tips</a></h2>
<p>There are some tips about implementing the host functions.</p>
<h3 id="calling-frame-context"><a class="header" href="#calling-frame-context">Calling Frame Context</a></h3>
<p>The <code>WasmEdge_CallingFrameContext</code> is the context to provide developers to access the module instance of the <a href="https://webassembly.github.io/spec/core/exec/runtime.html#activations-and-frames">frame on the top of the calling stack</a>.
According to the <a href="https://webassembly.github.io/spec/core/exec/instructions.html#function-calls">WASM spec</a>, a frame with the module instance to which the caller function belonging is pushed into the stack when invoking a function.
Therefore, the host functions can access the module instance of the top frame to retrieve the memory instances to read/write data.</p>
<pre><code class="language-c">/* Host function body definition. */
WasmEdge_Result LoadOffset(void *Data,
                           const WasmEdge_CallingFrameContext *CallFrameCxt,
                           const WasmEdge_Value *In, WasmEdge_Value *Out) {
  /* Function type: {i32} -&gt; {} */
  uint32_t Offset = (uint32_t)WasmEdge_ValueGetI32(In[0]);
  uint32_t Num = 0;

  /* Get the 0th memory instance of the module of the top frame on the stack. */
  /*
   * Noticed that the `MemCxt` will be `NULL` if there's no memory instance in
   * the module instance on the top frame.
   */
  WasmEdge_MemoryInstanceContext *MemCxt =
      WasmEdge_CallingFrameGetMemoryInstance(CallFrameCxt, 0);
  WasmEdge_Result Res =
      WasmEdge_MemoryInstanceGetData(MemCxt, (uint8_t *)(&amp;Num), Offset, 4);
  if (WasmEdge_ResultOK(Res)) {
    printf(&quot;u32 at memory[%u]: %u\n&quot;, Offset, Num);
  } else {
    return Res;
  }
  return WasmEdge_Result_Success;
}
</code></pre>
<p>The <code>WasmEdge_CallingFrameGetModuleInstance()</code> API can help developers to get the module instance of the top frame on the stack.
With the module instance context, developers can use the module instance-related APIs to get its contents.
The <code>WasmEdge_CallingFrameGetExecutor()</code> API can help developers to get the currently used executor context.
Therefore developers can use the executor to recursively invoke other WASM functions without creating a new executor context.</p>
<h3 id="return-error-codes"><a class="header" href="#return-error-codes">Return Error Codes</a></h3>
<p>Usually, the host function in WasmEdge can return the <code>WasmEdge_Result_Success</code> to present the successful execution.
For presenting the host function execution failed, one way is to return a trap with the error code.
Then the WasmEdge runtime will cause the trap in WASM and return that error.</p>
<p><em>Note: We don't recommend using system calls such as <code>exit()</code>. That will shut down the whole WasmEdge runtime.</em></p>
<p>For simply generating the trap, developers can return the <code>WasmEdge_Result_Fail</code>. If developers call the <code>WasmEdge_ResultOK()</code> with the returned result, they will get <code>false</code>. If developers call the <code>WasmEdge_ResultGetCode()</code> with the returned result, they will always get <code>2</code>.</p>
<p>For the versions after <code>0.11.0</code>, developers can specify the error code within 24-bit (smaller than <code>16777216</code>) size.</p>
<pre><code class="language-c">/* Host function body definition. */
WasmEdge_Result FaildFunc(void *Data,
                          const WasmEdge_CallingFrameContext *CallFrameCxt,
                          const WasmEdge_Value *In, WasmEdge_Value *Out) {
  /* This will create a trap in WASM with the error code. */
  return WasmEdge_ResultGen(WasmEdge_ErrCategory_UserLevelError, 12345678);
}
</code></pre>
<p>Therefore when developers call the <code>WasmEdge_ResultGetCode()</code> with the returned result, they will get the error code <code>12345678</code>.
Noticed that if developers call the <code>WasmEdge_ResultGetMessage()</code>, they will always get the C string <code>&quot;user defined error code&quot;</code>.</p>
<h3 id="host-data"><a class="header" href="#host-data">Host Data</a></h3>
<p>The third parameter of the <code>WasmEdge_FunctionInstanceCreate()</code> API is for the host data as the type <code>void *</code>.
Developers can pass the data into the host functions when creating. Then in the host function body, developers can access the data from the first argument.
Developers should guarantee that the availability of the host data should be longer than the host functions.</p>
<pre><code class="language-c">/* Host function body definition. */
WasmEdge_Result PrintData(void *Data,
                          const WasmEdge_CallingFrameContext *,
                          const WasmEdge_Value *In, WasmEdge_Value *Out) {
  /* Function type: {} -&gt; {} */
  printf(&quot;Data: %lf\n&quot;, *(double *)Data);
  return WasmEdge_Result_Success;
}

/* The host data. */
double Number = 0.0f;

/* Create a function type: {} -&gt; {}. */
WasmEdge_FunctionTypeContext *HostFType =
    WasmEdge_FunctionTypeCreate(NULL, 0, NULL, 0);
/* Create a function context with the function type and host function body. */
WasmEdge_FunctionInstanceContext *HostFunc =
    WasmEdge_FunctionInstanceCreate(HostFType, (void *)(&amp;Number), NULL, 0);
WasmEdge_FunctionTypeDelete(HostType);
</code></pre>
<h3 id="forcing-termination"><a class="header" href="#forcing-termination">Forcing Termination</a></h3>
<p>Sometimes developers may want to terminate the WASM execution with the success status.
WasmEdge provides a method for terminating WASM execution in host functions.
Developers can return <code>WasmEdge_Result_Terminate</code> to trigger the forcing termination of the current execution.
If developers call the <code>WasmEdge_ResultOK()</code> with the returned result, they will get <code>true</code>. If developers call the <code>WasmEdge_ResultGetCode()</code> with the returned result, they will always get <code>1</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="customized-external-references"><a class="header" href="#customized-external-references">Customized External References</a></h1>
<p><a href="https://webassembly.github.io/spec/core/syntax/types.html#syntax-reftype">External References</a> denotes an opaque and unforgettable reference to a host object. A new <code>externref</code> type can be passed into a Wasm module or returned from it. The Wasm module cannot reveal an <code>externref</code> value's bit pattern, nor create a fake host reference by an integer value.</p>
<h2 id="tutorial"><a class="header" href="#tutorial">Tutorial</a></h2>
<p>The following tutorial is the summary of the <code>externref</code> example in WasmEdge.</p>
<h3 id="prepare-your-wasm-file"><a class="header" href="#prepare-your-wasm-file">Prepare Your Wasm File</a></h3>
<p>The Wasm file should contain importing host functions that would take the <code>externref</code>.
Take <a href="https://github.com/WasmEdge/WasmEdge/raw/master/test/externref/externrefTestData/funcs.wasm">the test WASM file</a> (<a href="https://github.com/WasmEdge/WasmEdge/blob/master/test/externref/externrefTestData/funcs.wat">this WAT</a> is the corresponding text format) as an example:</p>
<pre><code class="language-wasm">(module
  (type $t0 (func (param externref i32) (result i32)))
  (type $t1 (func (param externref i32 i32) (result i32)))
  (type $t2 (func (param externref externref i32 i32) (result i32)))
  (import &quot;extern_module&quot; &quot;functor_square&quot; (func $functor_square (type $t0)))
  (import &quot;extern_module&quot; &quot;class_add&quot; (func $class_add (type $t1)))
  (import &quot;extern_module&quot; &quot;func_mul&quot; (func $func_mul (type $t1)))
  (func $call_add (export &quot;call_add&quot;) (type $t1) (param $p0 externref) (param $p1 i32) (param $p2 i32) (result i32)
    (call $class_add
      (local.get $p0)
      (local.get $p1)
      (local.get $p2)))
  (func $call_mul (export &quot;call_mul&quot;) (type $t1) (param $p0 externref) (param $p1 i32) (param $p2 i32) (result i32)
    (call $func_mul
      (local.get $p0)
      (local.get $p1)
      (local.get $p2)))
  (func $call_square (export &quot;call_square&quot;) (type $t0) (param $p0 externref) (param $p1 i32) (result i32)
    (call $functor_square
      (local.get $p0)
      (local.get $p1)))
  (func $call_add_square (export &quot;call_add_square&quot;) (type $t2) (param $p0 externref) (param $p1 externref) (param $p2 i32) (param $p3 i32) (result i32)
    (call $functor_square
      (local.get $p1)
      (call $class_add
        (local.get $p0)
        (local.get $p2)
        (local.get $p3))))
  (memory $memory (export &quot;memory&quot;) 1))
</code></pre>
<p>Users can convert <code>wat</code> to <code>wasm</code> through <a href="https://webassembly.github.io/wabt/demo/wat2wasm/">wat2wasm</a> live tool. Noted that <code>reference types</code> checkbox should be checked on this page.</p>
<h3 id="implement-host-module-and-register-into-wasmedge"><a class="header" href="#implement-host-module-and-register-into-wasmedge">Implement Host Module and Register into WasmEdge</a></h3>
<p>The host module should be implemented and registered into WasmEdge before executing Wasm. Assume that the following code is saved as <code>main.c</code>:</p>
<pre><code class="language-c">#include &lt;wasmedge/wasmedge.h&gt;

#include &lt;stdio.h&gt;

uint32_t SquareFunc(uint32_t A) { return A * A; }
uint32_t AddFunc(uint32_t A, uint32_t B) { return A + B; }
uint32_t MulFunc(uint32_t A, uint32_t B) { return A * B; }

// Host function to call `SquareFunc` by external reference
WasmEdge_Result ExternSquare(void *Data,
                             const WasmEdge_CallingFrameContext *CallFrameCxt,
                             const WasmEdge_Value *In, WasmEdge_Value *Out) {
  // Function type: {externref, i32} -&gt; {i32}
  uint32_t (*Func)(uint32_t) = WasmEdge_ValueGetExternRef(In[0]);
  uint32_t C = Func(WasmEdge_ValueGetI32(In[1]));
  Out[0] = WasmEdge_ValueGenI32(C);
  return WasmEdge_Result_Success;
}

// Host function to call `AddFunc` by external reference
WasmEdge_Result ExternAdd(void *Data,
                          const WasmEdge_CallingFrameContext *CallFrameCxt,
                          const WasmEdge_Value *In, WasmEdge_Value *Out) {
  // Function type: {externref, i32, i32} -&gt; {i32}
  uint32_t (*Func)(uint32_t, uint32_t) = WasmEdge_ValueGetExternRef(In[0]);
  uint32_t C = Func(WasmEdge_ValueGetI32(In[1]), WasmEdge_ValueGetI32(In[2]));
  Out[0] = WasmEdge_ValueGenI32(C);
  return WasmEdge_Result_Success;
}

// Host function to call `ExternMul` by external reference
WasmEdge_Result ExternMul(void *Data,
                          const WasmEdge_CallingFrameContext *CallFrameCxt,
                          const WasmEdge_Value *In, WasmEdge_Value *Out) {
  // Function type: {externref, i32, i32} -&gt; {i32}
  uint32_t (*Func)(uint32_t, uint32_t) = WasmEdge_ValueGetExternRef(In[0]);
  uint32_t C = Func(WasmEdge_ValueGetI32(In[1]), WasmEdge_ValueGetI32(In[2]));
  Out[0] = WasmEdge_ValueGenI32(C);
  return WasmEdge_Result_Success;
}

// Helper function to create the &quot;extern_module&quot; module instance.
WasmEdge_ModuleInstanceContext *CreateExternModule() {
  WasmEdge_String HostName;
  WasmEdge_FunctionTypeContext *HostFType = NULL;
  WasmEdge_FunctionInstanceContext *HostFunc = NULL;
  enum WasmEdge_ValType P[3], R[1];

  HostName = WasmEdge_StringCreateByCString(&quot;extern_module&quot;);
  WasmEdge_ModuleInstanceContext *HostMod =
      WasmEdge_ModuleInstanceCreate(HostName);
  WasmEdge_StringDelete(HostName);

  // Add host function &quot;functor_square&quot;: {externref, i32} -&gt; {i32}
  P[0] = WasmEdge_ValType_ExternRef;
  P[1] = WasmEdge_ValType_I32;
  R[0] = WasmEdge_ValType_I32;
  HostFType = WasmEdge_FunctionTypeCreate(P, 2, R, 1);
  HostFunc = WasmEdge_FunctionInstanceCreate(HostFType, ExternSquare, NULL, 0);
  WasmEdge_FunctionTypeDelete(HostFType);
  HostName = WasmEdge_StringCreateByCString(&quot;functor_square&quot;);
  WasmEdge_ModuleInstanceAddFunction(HostMod, HostName, HostFunc);
  WasmEdge_StringDelete(HostName);

  // Add host function &quot;class_add&quot;: {externref, i32, i32} -&gt; {i32}
  P[2] = WasmEdge_ValType_I32;
  HostFType = WasmEdge_FunctionTypeCreate(P, 3, R, 1);
  HostFunc = WasmEdge_FunctionInstanceCreate(HostFType, ExternAdd, NULL, 0);
  WasmEdge_FunctionTypeDelete(HostFType);
  HostName = WasmEdge_StringCreateByCString(&quot;class_add&quot;);
  WasmEdge_ModuleInstanceAddFunction(HostMod, HostName, HostFunc);
  WasmEdge_StringDelete(HostName);

  // Add host function &quot;func_mul&quot;: {externref, i32, i32} -&gt; {i32}
  HostFType = WasmEdge_FunctionTypeCreate(P, 3, R, 1);
  HostFunc = WasmEdge_FunctionInstanceCreate(HostFType, ExternMul, NULL, 0);
  WasmEdge_FunctionTypeDelete(HostFType);
  HostName = WasmEdge_StringCreateByCString(&quot;func_mul&quot;);
  WasmEdge_ModuleInstanceAddFunction(HostMod, HostName, HostFunc);
  WasmEdge_StringDelete(HostName);

  return HostMod;
}

int main() {
  WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(NULL, NULL);
  WasmEdge_ModuleInstanceContext *HostMod = CreateExternModule();
  WasmEdge_Value P[3], R[1];
  WasmEdge_String FuncName;
  WasmEdge_Result Res;

  Res = WasmEdge_VMRegisterModuleFromImport(VMCxt, HostMod);
  if (!WasmEdge_ResultOK(Res)) {
    printf(&quot;Host module instance registration failed\n&quot;);
    return EXIT_FAILURE;
  }
  Res = WasmEdge_VMLoadWasmFromFile(VMCxt, &quot;funcs.wasm&quot;);
  if (!WasmEdge_ResultOK(Res)) {
    printf(&quot;WASM file loading failed\n&quot;);
    return EXIT_FAILURE;
  }
  Res = WasmEdge_VMValidate(VMCxt);
  if (!WasmEdge_ResultOK(Res)) {
    printf(&quot;WASM validation failed\n&quot;);
    return EXIT_FAILURE;
  }
  Res = WasmEdge_VMInstantiate(VMCxt);
  if (!WasmEdge_ResultOK(Res)) {
    printf(&quot;WASM instantiation failed\n&quot;);
    return EXIT_FAILURE;
  }

  // Test 1: call add -- 1234 + 5678
  P[0] = WasmEdge_ValueGenExternRef(AddFunc);
  P[1] = WasmEdge_ValueGenI32(1234);
  P[2] = WasmEdge_ValueGenI32(5678);
  FuncName = WasmEdge_StringCreateByCString(&quot;call_add&quot;);
  Res = WasmEdge_VMExecute(VMCxt, FuncName, P, 3, R, 1);
  WasmEdge_StringDelete(FuncName);
  if (WasmEdge_ResultOK(Res)) {
    printf(&quot;Test 1 -- `call_add` -- 1234 + 5678 = %d\n&quot;,
           WasmEdge_ValueGetI32(R[0]));
  } else {
    printf(&quot;Test 1 -- `call_add` -- 1234 + 5678 -- failed\n&quot;);
    return EXIT_FAILURE;
  }

  // Test 2: call mul -- 789 * 4321
  P[0] = WasmEdge_ValueGenExternRef(MulFunc);
  P[1] = WasmEdge_ValueGenI32(789);
  P[2] = WasmEdge_ValueGenI32(4321);
  FuncName = WasmEdge_StringCreateByCString(&quot;call_mul&quot;);
  Res = WasmEdge_VMExecute(VMCxt, FuncName, P, 3, R, 1);
  WasmEdge_StringDelete(FuncName);
  if (WasmEdge_ResultOK(Res)) {
    printf(&quot;Test 2 -- `call_mul` -- 789 * 4321 = %d\n&quot;,
           WasmEdge_ValueGetI32(R[0]));
  } else {
    printf(&quot;Test 2 -- `call_mul` -- 789 * 4321 -- failed\n&quot;);
    return EXIT_FAILURE;
  }

  // Test 3: call square -- 8256^2
  P[0] = WasmEdge_ValueGenExternRef(SquareFunc);
  P[1] = WasmEdge_ValueGenI32(8256);
  FuncName = WasmEdge_StringCreateByCString(&quot;call_square&quot;);
  Res = WasmEdge_VMExecute(VMCxt, FuncName, P, 2, R, 1);
  if (WasmEdge_ResultOK(Res)) {
    printf(&quot;Test 3 -- `call_mul` -- 8256 ^ 2 = %d\n&quot;,
           WasmEdge_ValueGetI32(R[0]));
  } else {
    printf(&quot;Test 3 -- `call_mul` -- 8256 ^ 2 -- failed\n&quot;);
    return EXIT_FAILURE;
  }

  return EXIT_SUCCESS;
}
</code></pre>
<h3 id="setup-the-environment-and-compile"><a class="header" href="#setup-the-environment-and-compile">Setup the Environment And Compile</a></h3>
<ol>
<li>
<p>Install the WasmEdge shared library.</p>
<p>Please refer to the <a href="sdk/c/../../quick_start/install.html">Installation</a> for details.</p>
</li>
<li>
<p>Prepare the WASM file and the <code>main.c</code> source file as above.</p>
</li>
<li>
<p>Compile</p>
<pre><code class="language-bash">gcc main.c -lwasmedge
# Or you can use g++ for the C++ case, or use the clang.
</code></pre>
</li>
<li>
<p>Run the Test</p>
<pre><code class="language-bash">$ ./a.out
Test 1 -- `call_add` -- 1234 + 5678 = 6912
Test 2 -- `call_mul` -- 789 * 4321 = 3409269
Test 3 -- `call_mul` -- 8256 ^ 2 = 68161536
</code></pre>
</li>
</ol>
<h2 id="wasm-module-with-external-references"><a class="header" href="#wasm-module-with-external-references">Wasm module with External References</a></h2>
<p>Take the following <code>wat</code> for example:</p>
<pre><code class="language-wasm">(module
  (type $t0 (func (param externref i32) (result i32)))
  ;; Import a host function which type is {externref i32} -&gt; {i32}
  (import &quot;extern_module&quot; &quot;functor_square&quot; (func $functor_square (type $t0)))
  ;; Wasm function which type is {externref i32} -&gt; {i32} and exported as &quot;call_square&quot;
  (func $call_square (export &quot;call_square&quot;) (type $t0) (param $p0 externref) (param $p1 i32) (result i32)
    (call $functor_square (local.get $p0) (local.get $p1))
  )
  (memory $memory (export &quot;memory&quot;) 1))
</code></pre>
<p>The Wasm function &quot;<code>call_square</code>&quot; takes an <code>externref</code> parameter, and calls the imported host function <code>functor_square</code> with that <code>externref</code>.
Therefore, the <code>functor_square</code> host function can get the object reference when users call &quot;<code>call_square</code>&quot; Wasm function and pass the object's reference.</p>
<h2 id="wasmedge-externref-example"><a class="header" href="#wasmedge-externref-example">WasmEdge ExternRef Example</a></h2>
<p>The following examples are how to use <code>externref</code> in Wasm with WasmEdge C API.</p>
<h3 id="wasm-code"><a class="header" href="#wasm-code">Wasm Code</a></h3>
<p>The Wasm code must pass the <code>externref</code> to host functions that want to access it.
Take the following <code>wat</code> for example, which is a part of <a href="https://github.com/WasmEdge/WasmEdge/blob/master/test/externref/externrefTestData/funcs.wat">the test WASM file</a>:</p>
<pre><code class="language-wasm">(module
  (type $t0 (func (param externref i32 i32) (result i32)))
  (import &quot;extern_module&quot; &quot;func_mul&quot; (func $func_mul (type $t0)))
  (func $call_mul (export &quot;call_mul&quot;) (type $t0) (param $p0 externref) (param $p1 i32) (param $p2 i32) (result i32)
    (call $func_mul (local.get $p0) (local.get $p1) (local.get $p2))
  )
  (memory $memory (export &quot;memory&quot;) 1))
</code></pre>
<p>The host function &quot;<code>extern_module::func_mul</code>&quot; takes <code>externref</code> as a function pointer to multiply parameters 1 and 2 and then returns the result. The exported Wasm function &quot;<code>call_mul</code>&quot; calls &quot;<code>func_mul</code>&quot; and passes the <code>externref</code> and 2 numbers as arguments.</p>
<h3 id="host-functions-1"><a class="header" href="#host-functions-1">Host Functions</a></h3>
<p>To instantiate the above example Wasm, the host functions must be registered into WasmEdge. See <a href="sdk/c/ref.html#host-functions">Host Functions</a> for more details.
The host functions which take <code>externref</code>s must know the original objects' types. We take the function pointer case for example.</p>
<pre><code class="language-c">/* Function to pass as function pointer. */
uint32_t MulFunc(uint32_t A, uint32_t B) { return A * B; }

/* Host function to call the function by external reference as a function pointer */
WasmEdge_Result ExternMul(void *, const WasmEdge_CallingFrameContext *,
                          const WasmEdge_Value *In, WasmEdge_Value *Out) {
  /* Function type: {externref, i32, i32} -&gt; {i32} */
  void *Ptr = WasmEdge_ValueGetExternRef(In[0]);
  uint32_t (*Obj)(uint32_t, uint32_t) = Ptr;
  /*
   * For C++, the `reinterpret_cast` is needed:
   * uint32_t (*Obj)(uint32_t, uint32_t) = 
   *   *reinterpret_cast&lt;uint32_t (*)(uint32_t, uint32_t)&gt;(Ptr);
   */
  uint32_t C = Obj(WasmEdge_ValueGetI32(In[1]), WasmEdge_ValueGetI32(In[2]));
  Out[0] = WasmEdge_ValueGenI32(C);
  return WasmEdge_Result_Success;
}
</code></pre>
<p>&quot;<code>MulFunc</code>&quot; is a function that will be passed into Wasm as <code>externref</code>. In the &quot;<code>func_mul</code>&quot; host function, users can use &quot;<code>WasmEdge_ValueGetExternRef</code>&quot; API to get the pointer from the <code>WasmEdge_Value</code> which contains a <code>externref</code>.</p>
<p>Developers can add the host functions with names into a module instance.</p>
<pre><code class="language-c">/* Create a module instance. */
WasmEdge_String HostName = WasmEdge_StringCreateByCString(&quot;extern_module&quot;);
WasmEdge_ModuleInstanceContext *HostMod =
    WasmEdge_ModuleInstanceCreate(HostName);
WasmEdge_StringDelete(HostName);

/* Create a function instance and add into the module instance. */
enum WasmEdge_ValType P[3], R[1];
P[0] = WasmEdge_ValType_ExternRef;
P[1] = WasmEdge_ValType_I32;
P[2] = WasmEdge_ValType_I32;
R[0] = WasmEdge_ValType_I32;
WasmEdge_FunctionTypeContext *HostFType =
    WasmEdge_FunctionTypeCreate(P, 3, R, 1);
WasmEdge_FunctionInstanceContext *HostFunc =
    WasmEdge_FunctionInstanceCreate(HostFType, ExternFuncMul, NULL, 0);
WasmEdge_FunctionTypeDelete(HostFType);
HostName = WasmEdge_StringCreateByCString(&quot;func_mul&quot;);
WasmEdge_ModuleInstanceAddFunction(HostMod, HostName, HostFunc);
WasmEdge_StringDelete(HostName);

...
</code></pre>
<h3 id="execution"><a class="header" href="#execution">Execution</a></h3>
<p>Take <a href="https://github.com/WasmEdge/WasmEdge/raw/master/test/externref/externrefTestData/funcs.wasm">the test WASM file</a> (<a href="https://github.com/WasmEdge/WasmEdge/blob/master/test/externref/externrefTestData/funcs.wat">this WAT</a> is the corresponding text format) for example.
Assume that the <code>funcs.wasm</code> is copied into the current directory.
The following is the example to execute WASM with <code>externref</code> through the WasmEdge C API.</p>
<pre><code class="language-c">/* Create the VM context. */
WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(NULL, NULL);
/* Create the module instance context that contains the host functions. */
WasmEdge_ModuleInstanceContext *HostMod = /* Ignored ... */;
/* Assume that the host functions are added to the module instance above. */
WasmEdge_Value P[3], R[1];
WasmEdge_String FuncName;
WasmEdge_Result Res;

/* Register the module instance into VM. */
Res = WasmEdge_VMRegisterModuleFromImport(VMCxt, HostMod);
if (!WasmEdge_ResultOK(Res)) {
  printf(&quot;Import object registration failed\n&quot;);
  return EXIT_FAILURE;
}
/* Load WASM from the file. */
Res = WasmEdge_VMLoadWasmFromFile(VMCxt, &quot;funcs.wasm&quot;);
if (!WasmEdge_ResultOK(Res)) {
  printf(&quot;WASM file loading failed\n&quot;);
  return EXIT_FAILURE;
}
/* Validate WASM. */
Res = WasmEdge_VMValidate(VMCxt);
if (!WasmEdge_ResultOK(Res)) {
  printf(&quot;WASM validation failed\n&quot;);
  return EXIT_FAILURE;
}
/* Instantiate the WASM module. */
Res = WasmEdge_VMInstantiate(VMCxt);
if (!WasmEdge_ResultOK(Res)) {
  printf(&quot;WASM instantiation failed\n&quot;);
  return EXIT_FAILURE;
}

/* Run a WASM function. */
P[0] = WasmEdge_ValueGenExternRef(AddFunc);
P[1] = WasmEdge_ValueGenI32(1234);
P[2] = WasmEdge_ValueGenI32(5678);
/* Run the `call_add` function. */
FuncName = WasmEdge_StringCreateByCString(&quot;call_add&quot;);
Res = WasmEdge_VMExecute(VMCxt, FuncName, P, 3, R, 1);
WasmEdge_StringDelete(FuncName);
if (WasmEdge_ResultOK(Res)) {
  printf(&quot;Run -- `call_add` -- 1234 + 5678 = %d\n&quot;,
          WasmEdge_ValueGetI32(R[0]));
} else {
  printf(&quot;Run -- `call_add` -- 1234 + 5678 -- failed\n&quot;);
  return EXIT_FAILURE;
}
</code></pre>
<h2 id="passing-objects"><a class="header" href="#passing-objects">Passing Objects</a></h2>
<p>The above example is passing a function reference as <code>externref</code>. The following examples are about how to pass an object reference into WASM as <code>externref</code> in C++.</p>
<h3 id="passing-a-class"><a class="header" href="#passing-a-class">Passing a Class</a></h3>
<p>To pass a class as <code>externref</code>, the object instance is needed.</p>
<pre><code class="language-cpp">class AddClass {
public:
  uint32_t add(uint32_t A, uint32_t B) const { return A + B; }
};

AddClass AC;
</code></pre>
<p>Then users can pass the object into WasmEdge by using <code>WasmEdge_ValueGenExternRef()</code> API.</p>
<pre><code class="language-cpp">WasmEdge_Value P[3], R[1];
P[0] = WasmEdge_ValueGenExternRef(&amp;AC);
P[1] = WasmEdge_ValueGenI32(1234);
P[2] = WasmEdge_ValueGenI32(5678);
WasmEdge_String FuncName = WasmEdge_StringCreateByCString(&quot;call_add&quot;);
WasmEdge_Result Res = WasmEdge_VMExecute(VMCxt, FuncName, P, 3, R, 1);
WasmEdge_StringDelete(FuncName);
if (WasmEdge_ResultOK(Res)) {
  std::cout &lt;&lt; &quot;Result : &quot; &lt;&lt; WasmEdge_ValueGetI32(R[0]) std::endl;
  // Will print `6912`.
} else {
  return EXIT_FAILURE;
}
</code></pre>
<p>In the host function which would access the object by reference, users can use the <code>WasmEdge_ValueGetExternRef()</code> API to retrieve the reference to the object.</p>
<pre><code class="language-cpp">// Modify the `ExternAdd` in the above tutorial.
WasmEdge_Result ExternAdd(void *, const WasmEdge_CallingFrameContext *,
                          const WasmEdge_Value *In, WasmEdge_Value *Out) {
  // Function type: {externref, i32, i32} -&gt; {i32}
  void *Ptr = WasmEdge_ValueGetExternRef(In[0]);
  AddClass &amp;Obj = *reinterpret_cast&lt;AddClass *&gt;(Ptr);
  uint32_t C =
      Obj.add(WasmEdge_ValueGetI32(In[1]), WasmEdge_ValueGetI32(In[2]));
  Out[0] = WasmEdge_ValueGenI32(C);
  return WasmEdge_Result_Success;
}
</code></pre>
<h3 id="passing-an-object-as-functor"><a class="header" href="#passing-an-object-as-functor">Passing an Object As Functor</a></h3>
<p>As the same as passing a class instance, the functor object instance is needed.</p>
<pre><code class="language-cpp">struct SquareStruct {
  uint32_t operator()(uint32_t Val) const { return Val * Val; }
};

SquareStruct SS;
</code></pre>
<p>Then users can pass the object into WasmEdge by using the <code>WasmEdge_ValueGenExternRef()</code> API.</p>
<pre><code class="language-cpp">WasmEdge_Value P[2], R[1];
P[0] = WasmEdge_ValueGenExternRef(&amp;SS);
P[1] = WasmEdge_ValueGenI32(1024);
WasmEdge_String FuncName = WasmEdge_StringCreateByCString(&quot;call_square&quot;);
WasmEdge_Result Res = WasmEdge_VMExecute(VMCxt, FuncName, P, 2, R, 1);
WasmEdge_StringDelete(FuncName);
if (WasmEdge_ResultOK(Res)) {
  std::cout &lt;&lt; &quot;Result : &quot; &lt;&lt; WasmEdge_ValueGetI32(R[0]) std::endl;
  // Will print `1048576`.
} else {
  return EXIT_FAILURE;
}
</code></pre>
<p>In the host function which would access the object by reference, users can use the <code>WasmEdge_ValueGetExternRef</code> API to retrieve the reference to the object, and the reference is a functor.</p>
<pre><code class="language-cpp">// Modify the `ExternSquare` in the above tutorial.
WasmEdge_Result ExternSquare(void *, const WasmEdge_CallingFrameContext *,
                          const WasmEdge_Value *In, WasmEdge_Value *Out) {
  // Function type: {externref, i32, i32} -&gt; {i32}
  void *Ptr = WasmEdge_ValueGetExternRef(In[0]);
  SquareStruct &amp;Obj = *reinterpret_cast&lt;SquareStruct *&gt;(Ptr);
  uint32_t C = Obj(WasmEdge_ValueGetI32(In[1]));
  Out[0] = WasmEdge_ValueGenI32(C);
  return WasmEdge_Result_Success;
}
</code></pre>
<h3 id="passing-stl-objects"><a class="header" href="#passing-stl-objects">Passing STL Objects</a></h3>
<p>The <a href="https://github.com/WasmEdge/WasmEdge/raw/master/test/externref/externrefTestData/stl.wasm">example Wasm binary</a> (<a href="https://github.com/WasmEdge/WasmEdge/blob/master/test/externref/externrefTestData/stl.wat">this WAT</a> is the corresponding text format) provides functions to interact with host functions which can access C++ STL objects.
Assume that the WASM file <code>stl.wasm</code> is copied into the current directory.</p>
<p>Take the <code>std::ostream</code> and <code>std::string</code> objects for example. Assume that there's a host function accesses to a <code>std::ostream</code> and a <code>std::string</code> through <code>externref</code>s:</p>
<pre><code class="language-cpp">// Host function to output std::string through std::ostream
WasmEdge_Result ExternSTLOStreamStr(void *,
                                    const WasmEdge_CallingFrameContext *,
                                    const WasmEdge_Value *In,
                                    WasmEdge_Value *) {
  // Function type: {externref, externref} -&gt; {}
  void *Ptr0 = WasmEdge_ValueGetExternRef(In[0]);
  void *Ptr1 = WasmEdge_ValueGetExternRef(In[1]);
  std::ostream &amp;RefOS = *reinterpret_cast&lt;std::ostream *&gt;(Ptr0);
  std::string &amp;RefStr = *reinterpret_cast&lt;std::string *&gt;(Ptr1);
  RefOS &lt;&lt; RefStr;
  return WasmEdge_Result_Success;
}
</code></pre>
<p>Assume that the above host function is added to the module instance <code>HostMod</code>, and the <code>HostMod</code> is registered into a VM context <code>VMCxt</code>.
Then users can instantiate the Wasm module:</p>
<pre><code class="language-cpp">WasmEdge_Result Res = WasmEdge_VMLoadWasmFromFile(VMCxt, &quot;stl.wasm&quot;);
if (!WasmEdge_ResultOK(Res)) {
  printf(&quot;WASM file loading failed\n&quot;);
  return EXIT_FAILURE;
}
Res = WasmEdge_VMValidate(VMCxt);
if (!WasmEdge_ResultOK(Res)) {
  printf(&quot;WASM validation failed\n&quot;);
  return EXIT_FAILURE;
}
Res = WasmEdge_VMInstantiate(VMCxt);
if (!WasmEdge_ResultOK(Res)) {
  printf(&quot;WASM instantiation failed\n&quot;);
  return EXIT_FAILURE;
}
</code></pre>
<p>Last, pass the <code>std::cout</code> and a <code>std::string</code> object by external references.</p>
<pre><code class="language-cpp">std::string PrintStr(&quot;Hello world!&quot;);
WasmEdge_Value P[2], R[1];
P[0] = WasmEdge_ValueGenExternRef(&amp;std::cout);
P[1] = WasmEdge_ValueGenExternRef(&amp;PrintStr);
WasmEdge_String FuncName = WasmEdge_StringCreateByCString(&quot;call_ostream_str&quot;);
WasmEdge_Result Res = WasmEdge_VMExecute(VMCxt, FuncName, P, 2, R, 1);
// Will print &quot;Hello world!&quot; to stdout.
WasmEdge_StringDelete(FuncName);
if (!WasmEdge_ResultOK(Res)) {
  return EXIT_FAILURE;
}
</code></pre>
<p>For other C++ STL objects cases, such as <code>std::vector&lt;T&gt;</code>, <code>std::map&lt;T, U&gt;</code>, or <code>std::set&lt;T&gt;</code>, the object can be accessed correctly in host functions if the type in <code>reinterpret_cast</code> is correct.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="wasmedge-c-0111-api-documentation"><a class="header" href="#wasmedge-c-0111-api-documentation">WasmEdge C 0.11.1 API Documentation</a></h1>
<p><a href="https://github.com/WasmEdge/WasmEdge/blob/master/include/api/wasmedge/wasmedge.h">WasmEdge C API</a> denotes an interface to access the WasmEdge runtime. The followings are the guides to working with the C APIs of WasmEdge.</p>
<p><strong>Please notice that the WasmEdge C API provides SONAME and SOVERSION after the <code>0.11.0</code> release.</strong></p>
<p><strong>Please notice that <code>libwasmedge_c.so</code> is renamed to <code>libwasmedge.so</code> after the <code>0.11.0</code> release. Please use <code>-lwasmedge</code> instead of <code>-lwasmedge_c</code> for the linker option.</strong></p>
<p><strong>This document is for the <code>0.11.1</code> version. For the older <code>0.10.1</code> version, please refer to the <a href="sdk/c/0.10.1/ref.html">document here</a>.</strong></p>
<p><strong>Developers can refer to <a href="sdk/c/0.10.1/upgrade_to_0.11.0.html">here to upgrade to 0.11.0</a>.</strong></p>
<h2 id="table-of-contents-1"><a class="header" href="#table-of-contents-1">Table of Contents</a></h2>
<ul>
<li><a href="sdk/c/ref.html#wasmedge-installation">WasmEdge Installation</a>
<ul>
<li><a href="sdk/c/ref.html#download-and-install">Download And Install</a></li>
<li><a href="sdk/c/ref.html#compile-sources">Compile Sources</a></li>
<li><a href="sdk/c/ref.html#abi-compatibility">ABI Compatibility</a></li>
</ul>
</li>
<li><a href="sdk/c/ref.html#wasmedge-basics">WasmEdge Basics</a>
<ul>
<li><a href="sdk/c/ref.html#version">Version</a></li>
<li><a href="sdk/c/ref.html#logging-settings">Logging Settings</a></li>
<li><a href="sdk/c/ref.html#value-types">Value Types</a></li>
<li><a href="sdk/c/ref.html#strings">Strings</a></li>
<li><a href="sdk/c/ref.html#results">Results</a></li>
<li><a href="sdk/c/ref.html#contexts">Contexts</a></li>
<li><a href="sdk/c/ref.html#wasm-data-structures">WASM data structures</a></li>
<li><a href="sdk/c/ref.html#async">Async</a></li>
<li><a href="sdk/c/ref.html#configurations">Configurations</a></li>
<li><a href="sdk/c/ref.html#statistics">Statistics</a></li>
<li><a href="sdk/c/ref.html#tools-driver">Tools driver</a></li>
</ul>
</li>
<li><a href="sdk/c/ref.html#wasmedge-vm">WasmEdge VM</a>
<ul>
<li><a href="sdk/c/ref.html#wasm-execution-example-with-vm-context">WASM Execution Example With VM Context</a></li>
<li><a href="sdk/c/ref.html#vm-creations">VM Creations</a></li>
<li><a href="sdk/c/ref.html#preregistrations">Preregistrations</a></li>
<li><a href="sdk/c/ref.html#host-module-registrations">Host Module Registrations</a></li>
<li><a href="sdk/c/ref.html#wasm-registrations-and-executions">WASM Registrations And Executions</a></li>
<li><a href="sdk/c/ref.html#asynchronous-execution">Asynchronous execution</a></li>
<li><a href="sdk/c/ref.html#instance-tracing">Instance Tracing</a></li>
</ul>
</li>
<li><a href="sdk/c/ref.html#wasmedge-runtime">WasmEdge Runtime</a>
<ul>
<li><a href="sdk/c/ref.html#wasm-execution-example-step-by-step">WASM Execution Example Step-By-Step</a></li>
<li><a href="sdk/c/ref.html#loader">Loader</a></li>
<li><a href="sdk/c/ref.html#validator">Validator</a></li>
<li><a href="sdk/c/ref.html#executor">Executor</a></li>
<li><a href="sdk/c/ref.html#ast-module">AST Module</a></li>
<li><a href="sdk/c/ref.html#store">Store</a></li>
<li><a href="sdk/c/ref.html#instances">Instances</a></li>
<li><a href="sdk/c/ref.html#host-functions">Host Functions</a></li>
</ul>
</li>
<li><a href="sdk/c/ref.html#wasmedge-aot-compiler">WasmEdge AOT Compiler</a>
<ul>
<li><a href="sdk/c/ref.html#compilation-example">Compilation Example</a></li>
<li><a href="sdk/c/ref.html#compiler-options">Compiler Options</a></li>
</ul>
</li>
</ul>
<h2 id="wasmedge-installation"><a class="header" href="#wasmedge-installation">WasmEdge Installation</a></h2>
<h3 id="download-and-install"><a class="header" href="#download-and-install">Download And Install</a></h3>
<p>The easiest way to install WasmEdge is to run the following command. Your system should have <code>git</code> and <code>wget</code> as prerequisites.</p>
<pre><code class="language-bash">curl -sSf https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/utils/install.sh | bash -s -- -v 0.11.1
</code></pre>
<p>For more details, please refer to the <a href="sdk/c/../../quick_start/install.html">Installation Guide</a> for the WasmEdge installation.</p>
<h3 id="compile-sources"><a class="header" href="#compile-sources">Compile Sources</a></h3>
<p>After the installation of WasmEdge, the following guide can help you to test for the availability of the WasmEdge C API.</p>
<ol>
<li>
<p>Prepare the test C file (and assumed saved as <code>test.c</code>):</p>
<pre><code class="language-c">#include &lt;wasmedge/wasmedge.h&gt;
#include &lt;stdio.h&gt;
int main() {
  printf(&quot;WasmEdge version: %s\n&quot;, WasmEdge_VersionGet());
  return 0;
}
</code></pre>
</li>
<li>
<p>Compile the file with <code>gcc</code> or <code>clang</code>.</p>
<pre><code class="language-bash">gcc test.c -lwasmedge
</code></pre>
</li>
<li>
<p>Run and get the expected output.</p>
<pre><code class="language-bash">$ ./a.out
WasmEdge version: 0.11.1
</code></pre>
</li>
</ol>
<h3 id="abi-compatibility"><a class="header" href="#abi-compatibility">ABI Compatibility</a></h3>
<p>WasmEdge C API introduces SONAME and SOVERSION in the 0.11.0 release to present the compatibility between different C API versions.</p>
<p>The releases before 0.11.0 are all unversioned. Please make sure the library version is the same as the corresponding C API version you used.</p>
<div class="table-wrapper"><table><thead><tr><th>WasmEdge Version</th><th>WasmEdge C API Library Name</th><th>WasmEdge C API SONAME</th><th>WasmEdge C API SOVERSION</th></tr></thead><tbody>
<tr><td>&lt; 0.11.0</td><td>libwasmedge_c.so</td><td>Unversioned</td><td>Unversioned</td></tr>
<tr><td>since 0.11.0</td><td>libwasmedge.so</td><td>libwasmedge.so.0</td><td>libwasmedge.so.0.0.0</td></tr>
</tbody></table>
</div>
<h2 id="wasmedge-basics"><a class="header" href="#wasmedge-basics">WasmEdge Basics</a></h2>
<p>In this part, we will introduce the utilities and concepts of WasmEdge shared library.</p>
<h3 id="version"><a class="header" href="#version">Version</a></h3>
<p>The <code>Version</code> related APIs provide developers to check for the WasmEdge shared library version.</p>
<pre><code class="language-c">#include &lt;wasmedge/wasmedge.h&gt;
printf(&quot;WasmEdge version: %s\n&quot;, WasmEdge_VersionGet());
printf(&quot;WasmEdge version major: %u\n&quot;, WasmEdge_VersionGetMajor());
printf(&quot;WasmEdge version minor: %u\n&quot;, WasmEdge_VersionGetMinor());
printf(&quot;WasmEdge version patch: %u\n&quot;, WasmEdge_VersionGetPatch());
</code></pre>
<h3 id="logging-settings"><a class="header" href="#logging-settings">Logging Settings</a></h3>
<p>The <code>WasmEdge_LogSetErrorLevel()</code> and <code>WasmEdge_LogSetDebugLevel()</code> APIs can set the logging system to debug level or error level. By default, the error level is set, and the debug info is hidden.</p>
<h3 id="value-types"><a class="header" href="#value-types">Value Types</a></h3>
<p>In WasmEdge, developers should convert the values to <code>WasmEdge_Value</code> objects through APIs for matching to the WASM value types.</p>
<ol>
<li>
<p>Number types: <code>i32</code>, <code>i64</code>, <code>f32</code>, <code>f64</code>, and <code>v128</code> for the <code>SIMD</code> proposal</p>
<pre><code class="language-c">WasmEdge_Value Val;
Val = WasmEdge_ValueGenI32(123456);
printf(&quot;%d\n&quot;, WasmEdge_ValueGetI32(Val));
/* Will print &quot;123456&quot; */
Val = WasmEdge_ValueGenI64(1234567890123LL);
printf(&quot;%ld\n&quot;, WasmEdge_ValueGetI64(Val));
/* Will print &quot;1234567890123&quot; */
Val = WasmEdge_ValueGenF32(123.456f);
printf(&quot;%f\n&quot;, WasmEdge_ValueGetF32(Val));
/* Will print &quot;123.456001&quot; */
Val = WasmEdge_ValueGenF64(123456.123456789);
printf(&quot;%.10f\n&quot;, WasmEdge_ValueGetF64(Val));
/* Will print &quot;123456.1234567890&quot; */
</code></pre>
</li>
<li>
<p>Reference types: <code>funcref</code> and <code>externref</code> for the <code>Reference-Types</code> proposal</p>
<pre><code class="language-c">WasmEdge_Value Val;
void *Ptr;
bool IsNull;
uint32_t Num = 10;
/* Genreate a externref to NULL. */
Val = WasmEdge_ValueGenNullRef(WasmEdge_RefType_ExternRef);
IsNull = WasmEdge_ValueIsNullRef(Val);
/* The `IsNull` will be `TRUE`. */
Ptr = WasmEdge_ValueGetExternRef(Val);
/* The `Ptr` will be `NULL`. */

/* Get the function instance by creation or from module instance. */
const WasmEdge_FunctionInstanceContext *FuncCxt = ...;
/* Genreate a funcref with the given function instance context. */
Val = WasmEdge_ValueGenFuncRef(FuncCxt);
const WasmEdge_FunctionInstanceContext *GotFuncCxt =
    WasmEdge_ValueGetFuncRef(Val);
/* The `GotFuncCxt` will be the same as `FuncCxt`. */

/* Genreate a externref to `Num`. */
Val = WasmEdge_ValueGenExternRef(&amp;Num);
Ptr = WasmEdge_ValueGetExternRef(Val);
/* The `Ptr` will be `&amp;Num`. */
printf(&quot;%u\n&quot;, *(uint32_t *)Ptr);
/* Will print &quot;10&quot; */
Num += 55;
printf(&quot;%u\n&quot;, *(uint32_t *)Ptr);
/* Will print &quot;65&quot; */
</code></pre>
</li>
</ol>
<h3 id="strings"><a class="header" href="#strings">Strings</a></h3>
<p>The <code>WasmEdge_String</code> object is for the instance names when invoking a WASM function or finding the contexts of instances.</p>
<ol>
<li>
<p>Create a <code>WasmEdge_String</code> from a C string (<code>const char *</code> with NULL termination) or a buffer with length.</p>
<p>The content of the C string or buffer will be copied into the <code>WasmEdge_String</code> object.</p>
<pre><code class="language-c">char Buf[4] = {50, 55, 60, 65};
WasmEdge_String Str1 = WasmEdge_StringCreateByCString(&quot;test&quot;);
WasmEdge_String Str2 = WasmEdge_StringCreateByBuffer(Buf, 4);
/* The objects should be deleted by `WasmEdge_StringDelete()`. */
WasmEdge_StringDelete(Str1);
WasmEdge_StringDelete(Str2);
</code></pre>
</li>
<li>
<p>Wrap a <code>WasmEdge_String</code> to a buffer with length.</p>
<p>The content will not be copied, and the caller should guarantee the life cycle of the input buffer.</p>
<pre><code class="language-c">const char CStr[] = &quot;test&quot;;
WasmEdge_String Str = WasmEdge_StringWrap(CStr, 4);
/* The object should __NOT__ be deleted by `WasmEdge_StringDelete()`. */
</code></pre>
</li>
<li>
<p>String comparison</p>
<pre><code class="language-c">const char CStr[] = &quot;abcd&quot;;
char Buf[4] = {0x61, 0x62, 0x63, 0x64};
WasmEdge_String Str1 = WasmEdge_StringWrap(CStr, 4);
WasmEdge_String Str2 = WasmEdge_StringCreateByBuffer(Buf, 4);
bool IsEq = WasmEdge_StringIsEqual(Str1, Str2);
/* The `IsEq` will be `TRUE`. */
WasmEdge_StringDelete(Str2);
</code></pre>
</li>
<li>
<p>Convert to C string</p>
<pre><code class="language-c">char Buf[256];
WasmEdge_String Str =
    WasmEdge_StringCreateByCString(&quot;test_wasmedge_string&quot;);
uint32_t StrLength = WasmEdge_StringCopy(Str, Buf, sizeof(Buf));
/* StrLength will be 20 */
printf(&quot;String: %s\n&quot;, Buf);
/* Will print &quot;test_wasmedge_string&quot;. */
</code></pre>
</li>
</ol>
<h3 id="results"><a class="header" href="#results">Results</a></h3>
<p>The <code>WasmEdge_Result</code> object specifies the execution status.
APIs about WASM execution will return the <code>WasmEdge_Result</code> to denote the status.</p>
<pre><code class="language-c">WasmEdge_Result Res = WasmEdge_Result_Success;
bool IsSucceeded = WasmEdge_ResultOK(Res);
/* The `IsSucceeded` will be `TRUE`. */
uint32_t Code = WasmEdge_ResultGetCode(Res);
/* The `Code` will be 0. */
const char *Msg = WasmEdge_ResultGetMessage(Res);
/* The `Msg` will be &quot;success&quot;. */
enum WasmEdge_ErrCategory Category = WasmEdge_ResultGetCategory(Res);
/* The `Category` will be WasmEdge_ErrCategory_WASM. */

Res = WasmEdge_ResultGen(WasmEdge_ErrCategory_UserLevelError, 123);
/* Generate the user-defined result with code. */
Code = WasmEdge_ResultGetCode(Res);
/* The `Code` will be 123. */
Category = WasmEdge_ResultGetCategory(Res);
/* The `Category` will be WasmEdge_ErrCategory_UserLevelError. */
</code></pre>
<h3 id="contexts"><a class="header" href="#contexts">Contexts</a></h3>
<p>The objects, such as <code>VM</code>, <code>Store</code>, and <code>Function</code>, are composed of <code>Context</code>s.
All of the contexts can be created by calling the corresponding creation APIs and should be destroyed by calling the corresponding deletion APIs. Developers have responsibilities to manage the contexts for memory management.</p>
<pre><code class="language-c">/* Create the configure context. */
WasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();
/* Delete the configure context. */
WasmEdge_ConfigureDelete(ConfCxt);
</code></pre>
<p>The details of other contexts will be introduced later.</p>
<h3 id="wasm-data-structures"><a class="header" href="#wasm-data-structures">WASM Data Structures</a></h3>
<p>The WASM data structures are used for creating instances or can be queried from instance contexts.
The details of instances creation will be introduced in the <a href="sdk/c/ref.html#instances">Instances</a>.</p>
<ol>
<li>
<p>Limit</p>
<p>The <code>WasmEdge_Limit</code> struct is defined in the header:</p>
<pre><code class="language-c">/// Struct of WASM limit.
typedef struct WasmEdge_Limit {
  /// Boolean to describe has max value or not.
  bool HasMax;
  /// Boolean to describe is shared memory or not.
  bool Shared;
  /// Minimum value.
  uint32_t Min;
  /// Maximum value. Will be ignored if the `HasMax` is false.
  uint32_t Max;
} WasmEdge_Limit;
</code></pre>
<p>Developers can initialize the struct by assigning it's value, and the <code>Max</code> value is needed to be larger or equal to the <code>Min</code> value.
The API <code>WasmEdge_LimitIsEqual()</code> is provided to compare with 2 <code>WasmEdge_Limit</code> structs.</p>
</li>
<li>
<p>Function type context</p>
<p>The <code>Function Type</code> context is used for the <code>Function</code> creation, checking the value types of a <code>Function</code> instance, or getting the function type with function name from VM. Developers can use the <code>Function Type</code> context APIs to get the parameter or return value types information.</p>
<pre><code class="language-c">enum WasmEdge_ValType ParamList[2] = {WasmEdge_ValType_I32,
                                      WasmEdge_ValType_I64};
enum WasmEdge_ValType ReturnList[1] = {WasmEdge_ValType_FuncRef};
WasmEdge_FunctionTypeContext *FuncTypeCxt =
    WasmEdge_FunctionTypeCreate(ParamList, 2, ReturnList, 1);

enum WasmEdge_ValType Buf[16];
uint32_t ParamLen = WasmEdge_FunctionTypeGetParametersLength(FuncTypeCxt);
/* `ParamLen` will be 2. */
uint32_t GotParamLen =
    WasmEdge_FunctionTypeGetParameters(FuncTypeCxt, Buf, 16);
/* `GotParamLen` will be 2, and `Buf[0]` and `Buf[1]` will be the same as
 * `ParamList`. */
uint32_t ReturnLen = WasmEdge_FunctionTypeGetReturnsLength(FuncTypeCxt);
/* `ReturnLen` will be 1. */
uint32_t GotReturnLen =
    WasmEdge_FunctionTypeGetReturns(FuncTypeCxt, Buf, 16);
/* `GotReturnLen` will be 1, and `Buf[0]` will be the same as `ReturnList`.
 */

WasmEdge_FunctionTypeDelete(FuncTypeCxt);
</code></pre>
</li>
<li>
<p>Table type context</p>
<p>The <code>Table Type</code> context is used for <code>Table</code> instance creation or getting information from <code>Table</code> instances.</p>
<pre><code class="language-c">WasmEdge_Limit TabLim = {
    .HasMax = true, .Shared = false, .Min = 10, .Max = 20};
WasmEdge_TableTypeContext *TabTypeCxt =
    WasmEdge_TableTypeCreate(WasmEdge_RefType_ExternRef, TabLim);

enum WasmEdge_RefType GotRefType = WasmEdge_TableTypeGetRefType(TabTypeCxt);
/* `GotRefType` will be WasmEdge_RefType_ExternRef. */
WasmEdge_Limit GotTabLim = WasmEdge_TableTypeGetLimit(TabTypeCxt);
/* `GotTabLim` will be the same value as `TabLim`. */

WasmEdge_TableTypeDelete(TabTypeCxt);
</code></pre>
</li>
<li>
<p>Memory type context</p>
<p>The <code>Memory Type</code> context is used for <code>Memory</code> instance creation or getting information from <code>Memory</code> instances.</p>
<pre><code class="language-c">WasmEdge_Limit MemLim = {
    .HasMax = true, .Shared = false, .Min = 10, .Max = 20};
WasmEdge_MemoryTypeContext *MemTypeCxt = WasmEdge_MemoryTypeCreate(MemLim);

WasmEdge_Limit GotMemLim = WasmEdge_MemoryTypeGetLimit(MemTypeCxt);
/* `GotMemLim` will be the same value as `MemLim`. */

WasmEdge_MemoryTypeDelete(MemTypeCxt)
</code></pre>
</li>
<li>
<p>Global type context</p>
<p>The <code>Global Type</code> context is used for <code>Global</code> instance creation or getting information from <code>Global</code> instances.</p>
<pre><code class="language-c">WasmEdge_GlobalTypeContext *GlobTypeCxt = WasmEdge_GlobalTypeCreate(
    WasmEdge_ValType_F64, WasmEdge_Mutability_Var);

WasmEdge_ValType GotValType = WasmEdge_GlobalTypeGetValType(GlobTypeCxt);
/* `GotValType` will be WasmEdge_ValType_F64. */
WasmEdge_Mutability GotValMut =
    WasmEdge_GlobalTypeGetMutability(GlobTypeCxt);
/* `GotValMut` will be WasmEdge_Mutability_Var. */

WasmEdge_GlobalTypeDelete(GlobTypeCxt);
</code></pre>
</li>
<li>
<p>Import type context</p>
<p>The <code>Import Type</code> context is used for getting the imports information from a <a href="sdk/c/ref.html#ast-module">AST Module</a>.
Developers can get the external type (<code>function</code>, <code>table</code>, <code>memory</code>, or <code>global</code>), import module name, and external name from an <code>Import Type</code> context.
The details about querying <code>Import Type</code> contexts will be introduced in the <a href="sdk/c/ref.html#ast-module">AST Module</a>.</p>
<pre><code class="language-c">WasmEdge_ASTModuleContext *ASTCxt = ...;
/*
 * Assume that `ASTCxt` is returned by the `WasmEdge_LoaderContext` for the
 * result of loading a WASM file.
 */
const WasmEdge_ImportTypeContext *ImpType = ...;
/* Assume that `ImpType` is queried from the `ASTCxt` for the import. */

enum WasmEdge_ExternalType ExtType =
    WasmEdge_ImportTypeGetExternalType(ImpType);
/*
 * The `ExtType` can be one of `WasmEdge_ExternalType_Function`,
 * `WasmEdge_ExternalType_Table`, `WasmEdge_ExternalType_Memory`, or
 * `WasmEdge_ExternalType_Global`.
 */
WasmEdge_String ModName = WasmEdge_ImportTypeGetModuleName(ImpType);
WasmEdge_String ExtName = WasmEdge_ImportTypeGetExternalName(ImpType);
/*
 * The `ModName` and `ExtName` should not be destroyed and the string
 * buffers are binded into the `ASTCxt`.
 */
const WasmEdge_FunctionTypeContext *FuncTypeCxt =
    WasmEdge_ImportTypeGetFunctionType(ASTCxt, ImpType);
/*
 * If the `ExtType` is not `WasmEdge_ExternalType_Function`, the
 * `FuncTypeCxt` will be NULL.
 */
const WasmEdge_TableTypeContext *TabTypeCxt =
    WasmEdge_ImportTypeGetTableType(ASTCxt, ImpType);
/*
 * If the `ExtType` is not `WasmEdge_ExternalType_Table`, the `TabTypeCxt`
 * will be NULL.
 */
const WasmEdge_MemoryTypeContext *MemTypeCxt =
    WasmEdge_ImportTypeGetMemoryType(ASTCxt, ImpType);
/*
 * If the `ExtType` is not `WasmEdge_ExternalType_Memory`, the `MemTypeCxt`
 * will be NULL.
 */
const WasmEdge_GlobalTypeContext *GlobTypeCxt =
    WasmEdge_ImportTypeGetGlobalType(ASTCxt, ImpType);
/*
 * If the `ExtType` is not `WasmEdge_ExternalType_Global`, the `GlobTypeCxt`
 * will be NULL.
 */
</code></pre>
</li>
<li>
<p>Export type context</p>
<p>The <code>Export Type</code> context is used for getting the exports information from a <a href="sdk/c/ref.html#ast-module">AST Module</a>.
Developers can get the external type (<code>function</code>, <code>table</code>, <code>memory</code>, or <code>global</code>) and external name from an <code>Export Type</code> context.
The details about querying <code>Export Type</code> contexts will be introduced in the <a href="sdk/c/ref.html#ast-module">AST Module</a>.</p>
<pre><code class="language-c">WasmEdge_ASTModuleContext *ASTCxt = ...;
/*
 * Assume that `ASTCxt` is returned by the `WasmEdge_LoaderContext` for the
 * result of loading a WASM file.
 */
const WasmEdge_ExportTypeContext *ExpType = ...;
/* Assume that `ExpType` is queried from the `ASTCxt` for the export. */

enum WasmEdge_ExternalType ExtType =
    WasmEdge_ExportTypeGetExternalType(ExpType);
/*
 * The `ExtType` can be one of `WasmEdge_ExternalType_Function`,
 * `WasmEdge_ExternalType_Table`, `WasmEdge_ExternalType_Memory`, or
 * `WasmEdge_ExternalType_Global`.
 */
WasmEdge_String ExtName = WasmEdge_ExportTypeGetExternalName(ExpType);
/*
 * The `ExtName` should not be destroyed and the string buffer is binded
 * into the `ASTCxt`.
 */
const WasmEdge_FunctionTypeContext *FuncTypeCxt =
    WasmEdge_ExportTypeGetFunctionType(ASTCxt, ExpType);
/*
 * If the `ExtType` is not `WasmEdge_ExternalType_Function`, the
 * `FuncTypeCxt` will be NULL.
 */
const WasmEdge_TableTypeContext *TabTypeCxt =
    WasmEdge_ExportTypeGetTableType(ASTCxt, ExpType);
/*
 * If the `ExtType` is not `WasmEdge_ExternalType_Table`, the `TabTypeCxt`
 * will be NULL.
 */
const WasmEdge_MemoryTypeContext *MemTypeCxt =
    WasmEdge_ExportTypeGetMemoryType(ASTCxt, ExpType);
/*
 * If the `ExtType` is not `WasmEdge_ExternalType_Memory`, the `MemTypeCxt`
 * will be NULL.
 */
const WasmEdge_GlobalTypeContext *GlobTypeCxt =
    WasmEdge_ExportTypeGetGlobalType(ASTCxt, ExpType);
/*
 * If the `ExtType` is not `WasmEdge_ExternalType_Global`, the `GlobTypeCxt`
 * will be NULL.
 */
</code></pre>
</li>
</ol>
<h3 id="async"><a class="header" href="#async">Async</a></h3>
<p>After calling the <a href="sdk/c/ref.html#asynchronous-execution">asynchronous execution APIs</a>, developers will get the <code>WasmEdge_Async</code> object.
Developers own the object and should call the <code>WasmEdge_AsyncDelete()</code> API to destroy it.</p>
<ol>
<li>
<p>Wait for the asynchronous execution</p>
<p>Developers can wait the execution until finished:</p>
<pre><code class="language-c">WasmEdge_Async *Async = ...; /* Ignored. Asynchronous execute a function. */
/* Blocking and waiting for the execution. */
WasmEdge_AsyncWait(Async);
WasmEdge_AsyncDelete(Async);
</code></pre>
<p>Or developers can wait for a time limit.
If the time limit exceeded, developers can choose to cancel the execution.
For the interruptible execution in AOT mode, developers should set <code>TRUE</code> thourgh the <code>WasmEdge_ConfigureCompilerSetInterruptible()</code> API into the configure context for the AOT compiler.</p>
<pre><code class="language-c">WasmEdge_Async *Async = ...; /* Ignored. Asynchronous execute a function. */
/* Blocking and waiting for the execution for 1 second. */
bool IsEnd = WasmEdge_AsyncWaitFor(Async, 1000);
if (IsEnd) {
  /* The execution finished. Developers can get the result. */
  WasmEdge_Result Res = WasmEdge_AsyncGet(/* ... Ignored */);
} else {
  /*
   * The time limit exceeded. Developers can keep waiting or cancel the
   * execution.
   */
  WasmEdge_AsyncCancel(Async);
  WasmEdge_Result Res = WasmEdge_AsyncGet(Async, 0, NULL);
  /* The result error code will be `WasmEdge_ErrCode_Interrupted`. */
}
WasmEdge_AsyncDelete(Async);
</code></pre>
</li>
<li>
<p>Get the execution result of the asynchronous execution</p>
<p>Developers can use the <code>WasmEdge_AsyncGetReturnsLength()</code> API to get the return value list length.
This function will block and wait for the execution. If the execution has finished, this function will return the length immediately. If the execution failed, this function will return <code>0</code>.
This function can help the developers to create the buffer to get the return values. If developers have already known the buffer length, they can skip this function and use the <code>WasmEdge_AsyncGet()</code> API to get the result.</p>
<pre><code class="language-c">WasmEdge_Async *Async = ...; /* Ignored. Asynchronous execute a function. */
/*
 * Blocking and waiting for the execution and get the return value list
 * length.
 */
uint32_t Arity = WasmEdge_AsyncGetReturnsLength(Async);
WasmEdge_AsyncDelete(Async);
</code></pre>
<p>The <code>WasmEdge_AsyncGet()</code> API will block and wait for the execution. If the execution has finished, this function will fill the return values into the buffer and return the execution result immediately.</p>
<pre><code class="language-c">WasmEdge_Async *Async = ...; /* Ignored. Asynchronous execute a function. */
/* Blocking and waiting for the execution and get the return values. */
const uint32_t BUF_LEN = 256;
WasmEdge_Value Buf[BUF_LEN];
WasmEdge_Result Res = WasmEdge_AsyncGet(Async, Buf, BUF_LEN);
WasmEdge_AsyncDelete(Async);
</code></pre>
</li>
</ol>
<h3 id="configurations"><a class="header" href="#configurations">Configurations</a></h3>
<p>The configuration context, <code>WasmEdge_ConfigureContext</code>, manages the configurations for <code>Loader</code>, <code>Validator</code>, <code>Executor</code>, <code>VM</code>, and <code>Compiler</code>.
Developers can adjust the settings about the proposals, VM host pre-registrations (such as <code>WASI</code>), and AOT compiler options, and then apply the <code>Configure</code> context to create other runtime contexts.</p>
<ol>
<li>
<p>Proposals</p>
<p>WasmEdge supports turning on or off the WebAssembly proposals.
This configuration is effective in any contexts created with the <code>Configure</code> context.</p>
<pre><code class="language-c">enum WasmEdge_Proposal {
  WasmEdge_Proposal_ImportExportMutGlobals = 0,
  WasmEdge_Proposal_NonTrapFloatToIntConversions,
  WasmEdge_Proposal_SignExtensionOperators,
  WasmEdge_Proposal_MultiValue,
  WasmEdge_Proposal_BulkMemoryOperations,
  WasmEdge_Proposal_ReferenceTypes,
  WasmEdge_Proposal_SIMD,
  WasmEdge_Proposal_TailCall,
  WasmEdge_Proposal_MultiMemories,
  WasmEdge_Proposal_Annotations,
  WasmEdge_Proposal_Memory64,
  WasmEdge_Proposal_ExceptionHandling,
  WasmEdge_Proposal_ExtendedConst,
  WasmEdge_Proposal_Threads,
  WasmEdge_Proposal_FunctionReferences
};
</code></pre>
<p>Developers can add or remove the proposals into the <code>Configure</code> context.</p>
<pre><code class="language-c">/*
 * By default, the following proposals have turned on initially:
 * * Import/Export of mutable globals
 * * Non-trapping float-to-int conversions
 * * Sign-extension operators
 * * Multi-value returns
 * * Bulk memory operations
 * * Reference types
 * * Fixed-width SIMD
 *
 * For the current WasmEdge version, the following proposals are supported
 * (turned of by default) additionally:
 * * Tail-call
 * * Multiple memories
 * * Extended-const
 * * Threads
 */
WasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();
WasmEdge_ConfigureAddProposal(ConfCxt, WasmEdge_Proposal_MultiMemories);
WasmEdge_ConfigureRemoveProposal(ConfCxt, WasmEdge_Proposal_ReferenceTypes);
bool IsBulkMem = WasmEdge_ConfigureHasProposal(
    ConfCxt, WasmEdge_Proposal_BulkMemoryOperations);
/* The `IsBulkMem` will be `TRUE`. */
WasmEdge_ConfigureDelete(ConfCxt);
</code></pre>
</li>
<li>
<p>Host registrations</p>
<p>This configuration is used for the <code>VM</code> context to turn on the <code>WASI</code> or <code>wasmedge_process</code> supports and only effective in <code>VM</code> contexts.</p>
<pre><code class="language-c">enum WasmEdge_HostRegistration {
  WasmEdge_HostRegistration_Wasi = 0,
  WasmEdge_HostRegistration_WasmEdge_Process
};
</code></pre>
<p>The details will be introduced in the <a href="sdk/c/ref.html#preregistrations">preregistrations of VM context</a>.</p>
<pre><code class="language-c">WasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();
bool IsHostWasi = WasmEdge_ConfigureHasHostRegistration(
    ConfCxt, WasmEdge_HostRegistration_Wasi);
/* The `IsHostWasi` will be `FALSE`. */
WasmEdge_ConfigureAddHostRegistration(ConfCxt,
                                      WasmEdge_HostRegistration_Wasi);
IsHostWasi = WasmEdge_ConfigureHasHostRegistration(
    ConfCxt, WasmEdge_HostRegistration_Wasi);
/* The `IsHostWasi` will be `TRUE`. */
WasmEdge_ConfigureDelete(ConfCxt);
</code></pre>
</li>
<li>
<p>Maximum memory pages</p>
<p>Developers can limit the page size of memory instances by this configuration.
When growing the page size of memory instances in WASM execution and exceeding the limited size, the page growing will fail.
This configuration is only effective in the <code>Executor</code> and <code>VM</code> contexts.</p>
<pre><code class="language-c">WasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();
uint32_t PageSize = WasmEdge_ConfigureGetMaxMemoryPage(ConfCxt);
/* By default, the maximum memory page size is 65536. */
WasmEdge_ConfigureSetMaxMemoryPage(ConfCxt, 1024);
/*
 * Limit the memory size of each memory instance with not larger than 1024
 * pages (64 MiB).
 */
PageSize = WasmEdge_ConfigureGetMaxMemoryPage(ConfCxt);
/* The `PageSize` will be 1024. */
WasmEdge_ConfigureDelete(ConfCxt);
</code></pre>
</li>
<li>
<p>AOT compiler options</p>
<p>The AOT compiler options configure the behavior about optimization level, output format, dump IR, and generic binary.</p>
<pre><code class="language-c">enum WasmEdge_CompilerOptimizationLevel {
  // Disable as many optimizations as possible.
  WasmEdge_CompilerOptimizationLevel_O0 = 0,
  // Optimize quickly without destroying debuggability.
  WasmEdge_CompilerOptimizationLevel_O1,
  // Optimize for fast execution as much as possible without triggering
  // significant incremental compile time or code size growth.
  WasmEdge_CompilerOptimizationLevel_O2,
  // Optimize for fast execution as much as possible.
  WasmEdge_CompilerOptimizationLevel_O3,
  // Optimize for small code size as much as possible without triggering
  // significant incremental compile time or execution time slowdowns.
  WasmEdge_CompilerOptimizationLevel_Os,
  // Optimize for small code size as much as possible.
  WasmEdge_CompilerOptimizationLevel_Oz
};

enum WasmEdge_CompilerOutputFormat {
  // Native dynamic library format.
  WasmEdge_CompilerOutputFormat_Native = 0,
  // WebAssembly with AOT compiled codes in custom section.
  WasmEdge_CompilerOutputFormat_Wasm
};
</code></pre>
<p>These configurations are only effective in <code>Compiler</code> contexts.</p>
<pre><code class="language-c">WasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();
/* By default, the optimization level is O3. */
WasmEdge_ConfigureCompilerSetOptimizationLevel(
    ConfCxt, WasmEdge_CompilerOptimizationLevel_O2);
/* By default, the output format is universal WASM. */
WasmEdge_ConfigureCompilerSetOutputFormat(
    ConfCxt, WasmEdge_CompilerOutputFormat_Native);
/* By default, the dump IR is `FALSE`. */
WasmEdge_ConfigureCompilerSetDumpIR(ConfCxt, TRUE);
/* By default, the generic binary is `FALSE`. */
WasmEdge_ConfigureCompilerSetGenericBinary(ConfCxt, TRUE);
/* By default, the interruptible is `FALSE`.
/* Set this option to `TRUE` to support the interruptible execution in AOT
mode. */
WasmEdge_ConfigureCompilerSetInterruptible(ConfCxt, TRUE);
WasmEdge_ConfigureDelete(ConfCxt);
</code></pre>
</li>
<li>
<p>Statistics options</p>
<p>The statistics options configure the behavior about instruction counting, cost measuring, and time measuring in both runtime and AOT compiler.
These configurations are effective in <code>Compiler</code>, <code>VM</code>, and <code>Executor</code> contexts.</p>
<pre><code class="language-c">WasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();
/*
 * By default, the intruction counting is `FALSE` when running a
 * compiled-WASM or a pure-WASM.
 */
WasmEdge_ConfigureStatisticsSetInstructionCounting(ConfCxt, TRUE);
/*
 * By default, the cost measurement is `FALSE` when running a compiled-WASM
 * or a pure-WASM.
 */
WasmEdge_ConfigureStatisticsSetCostMeasuring(ConfCxt, TRUE);
/*
 * By default, the time measurement is `FALSE` when running a compiled-WASM
 * or a pure-WASM.
 */
WasmEdge_ConfigureStatisticsSetTimeMeasuring(ConfCxt, TRUE);
WasmEdge_ConfigureDelete(ConfCxt);
</code></pre>
</li>
</ol>
<h3 id="statistics"><a class="header" href="#statistics">Statistics</a></h3>
<p>The statistics context, <code>WasmEdge_StatisticsContext</code>, provides the instruction counter, cost summation, and cost limitation at runtime.</p>
<p>Before using statistics, the statistics configuration must be set. Otherwise, the return values of calling statistics are undefined behaviour.</p>
<ol>
<li>
<p>Instruction counter</p>
<p>The instruction counter can help developers to profile the performance of WASM running.
Developers can retrieve the <code>Statistics</code> context from the <code>VM</code> context, or create a new one for the <code>Executor</code> creation.
The details will be introduced in the next partitions.</p>
<pre><code class="language-c">WasmEdge_StatisticsContext *StatCxt = WasmEdge_StatisticsCreate();
/*
 * ...
 * After running the WASM functions with the `Statistics` context
 */
uint32_t Count = WasmEdge_StatisticsGetInstrCount(StatCxt);
double IPS = WasmEdge_StatisticsGetInstrPerSecond(StatCxt);
WasmEdge_StatisticsDelete(StatCxt);
</code></pre>
</li>
<li>
<p>Cost table</p>
<p>The cost table is to accumulate the cost of instructions with their weights.
Developers can set the cost table array (the indices are the byte code value of instructions, and the values are the cost of instructions) into the <code>Statistics</code> context.
If the cost limit value is set, the execution will return the <code>cost limit exceeded</code> error immediately when exceeds the cost limit in runtime.</p>
<pre><code class="language-c">WasmEdge_StatisticsContext *StatCxt = WasmEdge_StatisticsCreate();
uint64_t CostTable[16] = {
  0, 0,
  10, /* 0x02: Block */
  11, /* 0x03: Loop */
  12, /* 0x04: If */
  12, /* 0x05: Else */
  0, 0, 0, 0, 0, 0, 
  20, /* 0x0C: Br */
  21, /* 0x0D: Br_if */
  22, /* 0x0E: Br_table */
  0
};
/*
 * Developers can set the costs of each instruction. The value not
 * covered will be 0.
 */
WasmEdge_StatisticsSetCostTable(StatCxt, CostTable, 16);
WasmEdge_StatisticsSetCostLimit(StatCxt, 5000000);
/*
 * ...
 * After running the WASM functions with the `Statistics` context
 */
uint64_t Cost = WasmEdge_StatisticsGetTotalCost(StatCxt);
WasmEdge_StatisticsDelete(StatCxt);
</code></pre>
</li>
</ol>
<h3 id="tools-driver"><a class="header" href="#tools-driver">Tools Driver</a></h3>
<p>Besides executing the <code>wasmedge</code> and <code>wasmedgec</code> CLI tools, developers can trigger the WasmEdge CLI tools by WasmEdge C API.
The API arguments are the same as the command line arguments of the CLI tools.</p>
<pre><code class="language-c">#include &lt;wasmedge/wasmedge.h&gt;
#include &lt;stdio.h&gt;
int main(int argc, const char *argv[]) {
  /* Run the WasmEdge AOT compiler. */
  return WasmEdge_Driver_Compiler(argc, argv);
}
</code></pre>
<pre><code class="language-c">#include &lt;wasmedge/wasmedge.h&gt;
#include &lt;stdio.h&gt;
int main(int argc, const char *argv[]) {
  /* Run the WasmEdge runtime tool. */
  return WasmEdge_Driver_Tool(argc, argv);
}
</code></pre>
<h2 id="wasmedge-vm"><a class="header" href="#wasmedge-vm">WasmEdge VM</a></h2>
<p>In this partition, we will introduce the functions of <code>WasmEdge_VMContext</code> object and show examples of executing WASM functions.</p>
<h3 id="wasm-execution-example-with-vm-context"><a class="header" href="#wasm-execution-example-with-vm-context">WASM Execution Example With VM Context</a></h3>
<p>The following shows the example of running the WASM for getting the Fibonacci.
This example uses the <a href="https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/examples/wasm/fibonacci.wasm">fibonacci.wasm</a>, and the corresponding WAT file is at <a href="https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/examples/wasm/fibonacci.wat">fibonacci.wat</a>.</p>
<pre><code class="language-wasm">(module
  (export &quot;fib&quot; (func $fib))
  (func $fib (param $n i32) (result i32)
    (if
      (i32.lt_s (get_local $n)(i32.const 2))
      (return (i32.const 1))
    )
    (return
      (i32.add
        (call $fib (i32.sub (get_local $n)(i32.const 2)))
        (call $fib (i32.sub (get_local $n)(i32.const 1)))
      )
    )
  )
)
</code></pre>
<ol>
<li>
<p>Run WASM functions rapidly</p>
<p>Assume that the WASM file <a href="https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/examples/wasm/fibonacci.wasm"><code>fibonacci.wasm</code></a> is copied into the current directory, and the C file <code>test.c</code> is as following:</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;wasmedge/wasmedge.h&gt;
int main() {
  /* Create the configure context and add the WASI support. */
  /* This step is not necessary unless you need WASI support. */
  WasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();
  WasmEdge_ConfigureAddHostRegistration(ConfCxt,
                                        WasmEdge_HostRegistration_Wasi);
  /* The configure and store context to the VM creation can be NULL. */
  WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(ConfCxt, NULL);

  /* The parameters and returns arrays. */
  WasmEdge_Value Params[1] = {WasmEdge_ValueGenI32(5)};
  WasmEdge_Value Returns[1];
  /* Function name. */
  WasmEdge_String FuncName = WasmEdge_StringCreateByCString(&quot;fib&quot;);
  /* Run the WASM function from file. */
  WasmEdge_Result Res = WasmEdge_VMRunWasmFromFile(
      VMCxt, &quot;fibonacci.wasm&quot;, FuncName, Params, 1, Returns, 1);
  /*
   * Developers can run the WASM binary from buffer with the
   * `WasmEdge_VMRunWasmFromBuffer()` API, or from
   * `WasmEdge_ASTModuleContext` object with the
   * `WasmEdge_VMRunWasmFromASTModule()` API.
   */

  if (WasmEdge_ResultOK(Res)) {
    printf(&quot;Get the result: %d\n&quot;, WasmEdge_ValueGetI32(Returns[0]));
  } else {
    printf(&quot;Error message: %s\n&quot;, WasmEdge_ResultGetMessage(Res));
  }

  /* Resources deallocations. */
  WasmEdge_VMDelete(VMCxt);
  WasmEdge_ConfigureDelete(ConfCxt);
  WasmEdge_StringDelete(FuncName);
  return 0;
}
</code></pre>
<p>Then you can compile and run: (the 5th Fibonacci number is 8 in 0-based index)</p>
<pre><code class="language-bash">$ gcc test.c -lwasmedge
$ ./a.out
Get the result: 8
</code></pre>
</li>
<li>
<p>Instantiate and run WASM functions manually</p>
<p>Besides the above example, developers can run the WASM functions step-by-step with <code>VM</code> context APIs:</p>
<pre><code class="language-c">#include &lt;wasmedge/wasmedge.h&gt;
#include &lt;stdio.h&gt;
int main() {
  /* Create the configure context and add the WASI support. */
  /* This step is not necessary unless you need the WASI support. */
  WasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();
  WasmEdge_ConfigureAddHostRegistration(ConfCxt,
                                        WasmEdge_HostRegistration_Wasi);
  /* The configure and store context to the VM creation can be NULL. */
  WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(ConfCxt, NULL);

  /* The parameters and returns arrays. */
  WasmEdge_Value Params[1] = {WasmEdge_ValueGenI32(10)};
  WasmEdge_Value Returns[1];
  /* Function name. */
  WasmEdge_String FuncName = WasmEdge_StringCreateByCString(&quot;fib&quot;);
  /* Result. */
  WasmEdge_Result Res;

  /* Step 1: Load WASM file. */
  Res = WasmEdge_VMLoadWasmFromFile(VMCxt, &quot;fibonacci.wasm&quot;);
  /*
   * Developers can load the WASM binary from buffer with the
   * `WasmEdge_VMLoadWasmFromBuffer()` API, or from
   * `WasmEdge_ASTModuleContext` object with the
   * `WasmEdge_VMLoadWasmFromASTModule()` API.
   */
  if (!WasmEdge_ResultOK(Res)) {
    printf(&quot;Loading phase failed: %s\n&quot;, WasmEdge_ResultGetMessage(Res));
    return 1;
  }
  /* Step 2: Validate the WASM module. */
  Res = WasmEdge_VMValidate(VMCxt);
  if (!WasmEdge_ResultOK(Res)) {
    printf(&quot;Validation phase failed: %s\n&quot;, WasmEdge_ResultGetMessage(Res));
    return 1;
  }
  /* Step 3: Instantiate the WASM module. */
  Res = WasmEdge_VMInstantiate(VMCxt);
  /*
   * Developers can load, validate, and instantiate another WASM module to
   * replace the instantiated one. In this case, the old module will be
   * cleared, but the registered modules are still kept.
   */
  if (!WasmEdge_ResultOK(Res)) {
    printf(&quot;Instantiation phase failed: %s\n&quot;,
           WasmEdge_ResultGetMessage(Res));
    return 1;
  }
  /*
   * Step 4: Execute WASM functions. You can execute functions repeatedly
   * after instantiation.
   */
  Res = WasmEdge_VMExecute(VMCxt, FuncName, Params, 1, Returns, 1);
  if (WasmEdge_ResultOK(Res)) {
    printf(&quot;Get the result: %d\n&quot;, WasmEdge_ValueGetI32(Returns[0]));
  } else {
    printf(&quot;Execution phase failed: %s\n&quot;, WasmEdge_ResultGetMessage(Res));
  }

  /* Resources deallocations. */
  WasmEdge_VMDelete(VMCxt);
  WasmEdge_ConfigureDelete(ConfCxt);
  WasmEdge_StringDelete(FuncName);
  return 0;
}
</code></pre>
<p>Then you can compile and run: (the 10th Fibonacci number is 89 in 0-based index)</p>
<pre><code class="language-bash">$ gcc test.c -lwasmedge
$ ./a.out
Get the result: 89
</code></pre>
<p>The following graph explains the status of the <code>VM</code> context.</p>
<pre><code class="language-text">                       |========================|
              |-------&gt;|      VM: Initiated     |
              |        |========================|
              |                    |
              |                 LoadWasm
              |                    |
              |                    v
              |        |========================|
              |--------|       VM: Loaded       |&lt;-------|
              |        |========================|        |
              |              |            ^              |
              |         Validate          |              |
          Cleanup            |          LoadWasm         |
              |              v            |            LoadWasm
              |        |========================|        |
              |--------|      VM: Validated     |        |
              |        |========================|        |
              |              |            ^              |
              |      Instantiate          |              |
              |              |          RegisterModule   |
              |              v            |              |
              |        |========================|        |
              |--------|    VM: Instantiated    |--------|
                       |========================|
                             |            ^
                             |            |
                             --------------
                Instantiate, Execute, ExecuteRegistered
</code></pre>
<p>The status of the <code>VM</code> context would be <code>Inited</code> when created.
After loading WASM successfully, the status will be <code>Loaded</code>.
After validating WASM successfully, the status will be <code>Validated</code>.
After instantiating WASM successfully, the status will be <code>Instantiated</code>, and developers can invoke functions.
Developers can register WASM or module instances in any status, but they should instantiate WASM again.
Developers can also load WASM in any status, and they should validate and instantiate the WASM module before function invocation.
When in the <code>Instantiated</code> status, developers can instantiate the WASM module again to reset the old WASM runtime structures.</p>
</li>
</ol>
<h3 id="vm-creations"><a class="header" href="#vm-creations">VM Creations</a></h3>
<p>The <code>VM</code> creation API accepts the <code>Configure</code> context and the <code>Store</code> context.
If developers only need the default settings, just pass <code>NULL</code> to the creation API.
The details of the <code>Store</code> context will be introduced in <a href="sdk/c/ref.html#store">Store</a>.</p>
<pre><code class="language-c">WasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();
WasmEdge_StoreContext *StoreCxt = WasmEdge_StoreCreate();
WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(ConfCxt, StoreCxt);
/* The caller should guarantee the life cycle if the store context. */
WasmEdge_StatisticsContext *StatCxt = WasmEdge_VMGetStatisticsContext(VMCxt);
/*
 * The VM context already contains the statistics context and can be retrieved
 * by this API.
 */
/*
 * Note that the retrieved store and statistics contexts from the VM contexts by
 * VM APIs should __NOT__ be destroyed and owned by the VM contexts.
 */
WasmEdge_VMDelete(VMCxt);
WasmEdge_StoreDelete(StoreCxt);
WasmEdge_ConfigureDelete(ConfCxt);
</code></pre>
<h3 id="preregistrations"><a class="header" href="#preregistrations">Preregistrations</a></h3>
<p>WasmEdge provides the following built-in pre-registrations.</p>
<ol>
<li>
<p><a href="https://github.com/WebAssembly/WASI">WASI (WebAssembly System Interface)</a></p>
<p>Developers can turn on the WASI support for VM in the <code>Configure</code> context.</p>
<pre><code class="language-c">WasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();
WasmEdge_ConfigureAddHostRegistration(ConfCxt,
                                      WasmEdge_HostRegistration_Wasi);
WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(ConfCxt, NULL);
/*
 * The following API can retrieve the pre-registration module instances from
 * the VM context.
 */
/*
 * This API will return `NULL` if the corresponding pre-registration is not
 * set into the configuration.
 */
WasmEdge_ModuleInstanceContext *WasiModule =
    WasmEdge_VMGetImportModuleContext(VMCxt,
                                      WasmEdge_HostRegistration_Wasi);
/* Initialize the WASI. */
WasmEdge_ModuleInstanceInitWASI(WasiModule, /* ... ignored */);
WasmEdge_VMDelete(VMCxt);
WasmEdge_ConfigureDelete(ConfCxt);
</code></pre>
<p>And also can create the WASI module instance from API. The details will be introduced in the <a href="sdk/c/ref.html#host-functions">Host Functions</a> and the <a href="sdk/c/ref.html#host-module-registrations">Host Module Registrations</a>.</p>
</li>
<li>
<p><a href="https://crates.io/crates/wasmedge_process_interface">WasmEdge_Process</a></p>
<p>This pre-registration is for the process interface for WasmEdge on <code>Rust</code> sources.
After turning on this pre-registration, the VM will support the <code>wasmedge_process</code> plugin.</p>
<pre><code class="language-c">WasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();
WasmEdge_ConfigureAddHostRegistration(
    ConfCxt, WasmEdge_HostRegistration_WasmEdge_Process);
WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(ConfCxt, NULL);
/*
 * The following API can retrieve the pre-registration module instances from
 * the VM context.
 */
/*
 * This API will return `NULL` if the corresponding pre-registration is not
 * set into the configuration or the plugin load failed.
 */
WasmEdge_ModuleInstanceContext *ProcModule =
    WasmEdge_VMGetImportModuleContext(
        VMCxt, WasmEdge_HostRegistration_WasmEdge_Process);
/* Initialize the WasmEdge_Process. */
WasmEdge_ModuleInstanceInitWasmEdgeProcess(ProcModule, /* ... ignored */);
WasmEdge_VMDelete(VMCxt);
WasmEdge_ConfigureDelete(ConfCxt);
</code></pre>
<p>And also can create the WasmEdge_Process module instance from API. The details will be introduced in the <a href="sdk/c/ref.html#host-functions">Host Functions</a> and the <a href="sdk/c/ref.html#host-module-registrations">Host Module Registrations</a>.</p>
</li>
<li>
<p><a href="https://github.com/WebAssembly/wasi-nn">WASI-NN proposal</a></p>
<p>Developers can turn on the WASI-NN proposal support for VM in the <code>Configure</code> context.</p>
<blockquote>
<p>Note: Please check that the <a href="sdk/c/../../write_wasm/rust/wasinn.html">dependencies and prerequests</a> are satisfied.</p>
</blockquote>
<pre><code class="language-c">WasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();
WasmEdge_ConfigureAddHostRegistration(ConfCxt,
                                      WasmEdge_HostRegistration_WasiNN);
WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(ConfCxt, NULL);
/*
 * The following API can retrieve the pre-registration module instances from
 * the VM context.
 */
/*
 * This API will return `NULL` if the corresponding pre-registration is not
 * set into the configuration or the plugin load failed.
 */
WasmEdge_ModuleInstanceContext *NNModule =
    WasmEdge_VMGetImportModuleContext(VMCxt,
                                      WasmEdge_HostRegistration_WasiNN);
WasmEdge_VMDelete(VMCxt);
WasmEdge_ConfigureDelete(ConfCxt);
</code></pre>
<p>And also can create the WASI-NN module instance from API. The details will be introduced in the <a href="sdk/c/ref.html#host-functions">Host Functions</a> and the <a href="sdk/c/ref.html#host-module-registrations">Host Module Registrations</a>.</p>
</li>
<li>
<p><a href="https://github.com/WebAssembly/wasi-crypto">WASI-Crypto proposal</a></p>
<p>Developers can turn on the WASI-Crypto proposal support for VM in the <code>Configure</code> context.</p>
<blockquote>
<p>Note: Please check that the <a href="sdk/c/../../dev/rust/wasicrypto.html">dependencies and prerequests</a> are satisfied.</p>
</blockquote>
<pre><code class="language-c">WasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();
/* The WASI-Crypto related configures are suggested to turn on togeter. */
WasmEdge_ConfigureAddHostRegistration(
    ConfCxt, WasmEdge_HostRegistration_WasiCrypto_Common);
WasmEdge_ConfigureAddHostRegistration(
    ConfCxt, WasmEdge_HostRegistration_WasiCrypto_AsymmetricCommon);
WasmEdge_ConfigureAddHostRegistration(
    ConfCxt, WasmEdge_HostRegistration_WasiCrypto_Kx);
WasmEdge_ConfigureAddHostRegistration(
    ConfCxt, WasmEdge_HostRegistration_WasiCrypto_Signatures);
WasmEdge_ConfigureAddHostRegistration(
    ConfCxt, WasmEdge_HostRegistration_WasiCrypto_Symmetric);
WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(ConfCxt, NULL);
/*
 * The following API can retrieve the pre-registration module instances from
 * the VM context.
  */
/*
 * This API will return `NULL` if the corresponding pre-registration is not
 * set into the configuration or the plugin load failed.
  */
WasmEdge_ModuleInstanceContext *CryptoCommonModule =
    WasmEdge_VMGetImportModuleContext(
        VMCxt, WasmEdge_HostRegistration_WasiCrypto_Common);
WasmEdge_VMDelete(VMCxt);
WasmEdge_ConfigureDelete(ConfCxt);
</code></pre>
<p>And also can create the WASI-Crypto module instance from API. The details will be introduced in the <a href="sdk/c/ref.html#host-functions">Host Functions</a> and the <a href="sdk/c/ref.html#host-module-registrations">Host Module Registrations</a>.</p>
</li>
</ol>
<h3 id="host-module-registrations"><a class="header" href="#host-module-registrations">Host Module Registrations</a></h3>
<p><a href="https://webassembly.github.io/spec/core/exec/runtime.html#syntax-hostfunc">Host functions</a> are functions outside WebAssembly and passed to WASM modules as imports.
In WasmEdge, the host functions are composed into host modules as <code>WasmEdge_ModuleInstanceContext</code> objects with module names.
Please refer to the <a href="sdk/c/ref.html#host-functions">Host Functions in WasmEdge Runtime</a> for the details.
In this chapter, we show the example for registering the host modules into a <code>VM</code> context.</p>
<pre><code class="language-c">WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(NULL, NULL);
WasmEdge_ModuleInstanceContext *WasiModule =
    WasmEdge_ModuleInstanceCreateWASI(/* ... ignored ... */);
/* You can also create and register the WASI host modules by this API. */
WasmEdge_Result Res = WasmEdge_VMRegisterModuleFromImport(VMCxt, WasiModule);
/* The result status should be checked. */

/* ... */

WasmEdge_ModuleInstanceDelete(WasiModule);
/*
 * The created module instances should be deleted by the developers when the VM
 * deallocation.
 */
WasmEdge_VMDelete(VMCxt);
</code></pre>
<h3 id="wasm-registrations-and-executions"><a class="header" href="#wasm-registrations-and-executions">WASM Registrations And Executions</a></h3>
<p>In WebAssembly, the instances in WASM modules can be exported and can be imported by other WASM modules.
WasmEdge VM provides APIs for developers to register and export any WASM modules, and execute the functions or host functions in the registered WASM modules.</p>
<ol>
<li>
<p>Register the WASM modules with exported module names</p>
<p>Unless the module instances have already contained the module names, every WASM module should be named uniquely when registering.
Assume that the WASM file <a href="https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/examples/wasm/fibonacci.wasm"><code>fibonacci.wasm</code></a> is copied into the current directory.</p>
<pre><code class="language-c">WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(NULL, NULL);
WasmEdge_String ModName = WasmEdge_StringCreateByCString(&quot;mod&quot;);
WasmEdge_Result Res =
    WasmEdge_VMRegisterModuleFromFile(VMCxt, ModName, &quot;fibonacci.wasm&quot;);
/*
 * Developers can register the WASM module from buffer with the
 * `WasmEdge_VMRegisterModuleFromBuffer()` API, or from
 * `WasmEdge_ASTModuleContext` object with the
 * `WasmEdge_VMRegisterModuleFromASTModule()` API.
 */
/*
 * The result status should be checked.
 * The error will occur if the WASM module instantiation failed or the
 * module name conflicts.
 */
WasmEdge_StringDelete(ModName);
WasmEdge_VMDelete(VMCxt);
</code></pre>
</li>
<li>
<p>Execute the functions in registered WASM modules</p>
<p>Assume that the C file <code>test.c</code> is as follows:</p>
<pre><code class="language-c">#include &lt;wasmedge/wasmedge.h&gt;
#include &lt;stdio.h&gt;
int main() {
  WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(NULL, NULL);

  /* The parameters and returns arrays. */
  WasmEdge_Value Params[1] = {WasmEdge_ValueGenI32(20)};
  WasmEdge_Value Returns[1];
  /* Names. */
  WasmEdge_String ModName = WasmEdge_StringCreateByCString(&quot;mod&quot;);
  WasmEdge_String FuncName = WasmEdge_StringCreateByCString(&quot;fib&quot;);
  /* Result. */
  WasmEdge_Result Res;

  /* Register the WASM module into VM. */
  Res = WasmEdge_VMRegisterModuleFromFile(VMCxt, ModName, &quot;fibonacci.wasm&quot;);
  /*
   * Developers can register the WASM module from buffer with the
   * `WasmEdge_VMRegisterModuleFromBuffer()` API, or from
   * `WasmEdge_ASTModuleContext` object with the
   * `WasmEdge_VMRegisterModuleFromASTModule()` API.
   */
  if (!WasmEdge_ResultOK(Res)) {
    printf(&quot;WASM registration failed: %s\n&quot;,
           WasmEdge_ResultGetMessage(Res));
    return 1;
  }
  /*
   * The function &quot;fib&quot; in the &quot;fibonacci.wasm&quot; was exported with the module
   * name &quot;mod&quot;. As the same as host functions, other modules can import the
   * function `&quot;mod&quot; &quot;fib&quot;`.
   */

  /*
   * Execute WASM functions in registered modules.
   * Unlike the execution of functions, the registered functions can be
   * invoked without `WasmEdge_VMInstantiate()` because the WASM module was
   * instantiated when registering. Developers can also invoke the host
   * functions directly with this API.
   */
  Res = WasmEdge_VMExecuteRegistered(VMCxt, ModName, FuncName, Params, 1,
                                     Returns, 1);
  if (WasmEdge_ResultOK(Res)) {
    printf(&quot;Get the result: %d\n&quot;, WasmEdge_ValueGetI32(Returns[0]));
  } else {
    printf(&quot;Execution phase failed: %s\n&quot;, WasmEdge_ResultGetMessage(Res));
  }
  WasmEdge_StringDelete(ModName);
  WasmEdge_StringDelete(FuncName);
  WasmEdge_VMDelete(VMCxt);
  return 0;
}
</code></pre>
<p>Then you can compile and run: (the 20th Fibonacci number is 89 in 0-based index)</p>
<pre><code class="language-bash">$ gcc test.c -lwasmedge
$ ./a.out
Get the result: 10946
</code></pre>
</li>
</ol>
<h3 id="asynchronous-execution"><a class="header" href="#asynchronous-execution">Asynchronous Execution</a></h3>
<ol>
<li>
<p>Asynchronously run WASM functions rapidly</p>
<p>Assume that the WASM file <a href="https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/examples/wasm/fibonacci.wasm"><code>fibonacci.wasm</code></a> is copied into the current directory, and the C file <code>test.c</code> is as following:</p>
<pre><code class="language-c">#include &lt;wasmedge/wasmedge.h&gt;
#include &lt;stdio.h&gt;
int main() {
  /* Create the VM context. */
  WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(NULL, NULL);

  /* The parameters and returns arrays. */
  WasmEdge_Value Params[1] = {WasmEdge_ValueGenI32(20)};
  WasmEdge_Value Returns[1];
  /* Function name. */
  WasmEdge_String FuncName = WasmEdge_StringCreateByCString(&quot;fib&quot;);
  /* Asynchronously run the WASM function from file and get the
   * `WasmEdge_Async` object. */
  WasmEdge_Async *Async = WasmEdge_VMAsyncRunWasmFromFile(
      VMCxt, &quot;fibonacci.wasm&quot;, FuncName, Params, 1);
  /*
   * Developers can run the WASM binary from buffer with the
   * `WasmEdge_VMAsyncRunWasmFromBuffer()` API, or from
   * `WasmEdge_ASTModuleContext` object with the
   * `WasmEdge_VMAsyncRunWasmFromASTModule()` API.
   */

  /* Wait for the execution. */
  WasmEdge_AsyncWait(Async);
  /*
   * Developers can also use the `WasmEdge_AsyncGetReturnsLength()` or
   * `WasmEdge_AsyncGet()` APIs to wait for the asynchronous execution.
   * These APIs will wait until the execution finished.
   */

  /* Check the return values length. */
  uint32_t Arity = WasmEdge_AsyncGetReturnsLength(Async);
  /* The `Arity` should be 1. Developers can skip this step if they have
   * known the return arity. */

  /* Get the result. */
  WasmEdge_Result Res = WasmEdge_AsyncGet(Async, Returns, Arity);

  if (WasmEdge_ResultOK(Res)) {
    printf(&quot;Get the result: %d\n&quot;, WasmEdge_ValueGetI32(Returns[0]));
  } else {
    printf(&quot;Error message: %s\n&quot;, WasmEdge_ResultGetMessage(Res));
  }

  /* Resources deallocations. */
  WasmEdge_AsyncDelete(Async);
  WasmEdge_VMDelete(VMCxt);
  WasmEdge_StringDelete(FuncName);
  return 0;
}
</code></pre>
<p>Then you can compile and run: (the 20th Fibonacci number is 10946 in 0-based index)</p>
<pre><code class="language-bash">$ gcc test.c -lwasmedge
$ ./a.out
Get the result: 10946
</code></pre>
</li>
<li>
<p>Instantiate and asynchronously run WASM functions manually</p>
<p>Besides the above example, developers can run the WASM functions step-by-step with <code>VM</code> context APIs:</p>
<pre><code class="language-c">#include &lt;wasmedge/wasmedge.h&gt;
#include &lt;stdio.h&gt;
int main() {
  /* Create the VM context. */
  WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(NULL, NULL);

  /* The parameters and returns arrays. */
  WasmEdge_Value Params[1] = {WasmEdge_ValueGenI32(25)};
  WasmEdge_Value Returns[1];
  /* Function name. */
  WasmEdge_String FuncName = WasmEdge_StringCreateByCString(&quot;fib&quot;);
  /* Result. */
  WasmEdge_Result Res;

  /* Step 1: Load WASM file. */
  Res = WasmEdge_VMLoadWasmFromFile(VMCxt, &quot;fibonacci.wasm&quot;);
  /*
   * Developers can load the WASM binary from buffer with the
   * `WasmEdge_VMLoadWasmFromBuffer()` API, or from
   * `WasmEdge_ASTModuleContext` object with the
   * `WasmEdge_VMLoadWasmFromASTModule()` API.
   */
  if (!WasmEdge_ResultOK(Res)) {
    printf(&quot;Loading phase failed: %s\n&quot;, WasmEdge_ResultGetMessage(Res));
    return 1;
  }
  /* Step 2: Validate the WASM module. */
  Res = WasmEdge_VMValidate(VMCxt);
  if (!WasmEdge_ResultOK(Res)) {
    printf(&quot;Validation phase failed: %s\n&quot;, WasmEdge_ResultGetMessage(Res));
    return 1;
  }
  /* Step 3: Instantiate the WASM module. */
  Res = WasmEdge_VMInstantiate(VMCxt);
  /*
   * Developers can load, validate, and instantiate another WASM module to
   * replace the instantiated one. In this case, the old module will be
   * cleared, but the registered modules are still kept.
   */
  if (!WasmEdge_ResultOK(Res)) {
    printf(&quot;Instantiation phase failed: %s\n&quot;,
           WasmEdge_ResultGetMessage(Res));
    return 1;
  }
  /* Step 4: Asynchronously execute the WASM function and get the
   * `WasmEdge_Async` object. */
  WasmEdge_Async *Async =
      WasmEdge_VMAsyncExecute(VMCxt, FuncName, Params, 1);
  /*
   * Developers can execute functions repeatedly after instantiation.
   * For invoking the registered functions, you can use the
   * `WasmEdge_VMAsyncExecuteRegistered()` API.
   */

  /* Wait and check the return values length. */
  uint32_t Arity = WasmEdge_AsyncGetReturnsLength(Async);
  /* The `Arity` should be 1. Developers can skip this step if they have
   * known the return arity. */

  /* Get the result. */
  Res = WasmEdge_AsyncGet(Async, Returns, Arity);
  if (WasmEdge_ResultOK(Res)) {
    printf(&quot;Get the result: %d\n&quot;, WasmEdge_ValueGetI32(Returns[0]));
  } else {
    printf(&quot;Execution phase failed: %s\n&quot;, WasmEdge_ResultGetMessage(Res));
  }

  /* Resources deallocations. */
  WasmEdge_AsyncDelete(Async);
  WasmEdge_VMDelete(VMCxt);
  WasmEdge_StringDelete(FuncName);
}
</code></pre>
<p>Then you can compile and run: (the 25th Fibonacci number is 121393 in 0-based index)</p>
<pre><code class="language-bash">$ gcc test.c -lwasmedge
$ ./a.out
Get the result: 121393
</code></pre>
</li>
</ol>
<h3 id="instance-tracing"><a class="header" href="#instance-tracing">Instance Tracing</a></h3>
<p>Sometimes the developers may have requirements to get the instances of the WASM runtime.
The <code>VM</code> context supplies the APIs to retrieve the instances.</p>
<ol>
<li>
<p>Store</p>
<p>If the <code>VM</code> context is created without assigning a <code>Store</code> context, the <code>VM</code> context will allocate and own a <code>Store</code> context.</p>
<pre><code class="language-c">WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(NULL, NULL);
WasmEdge_StoreContext *StoreCxt = WasmEdge_VMGetStoreContext(VMCxt);
/* The object should __NOT__ be deleted by `WasmEdge_StoreDelete()`. */
WasmEdge_VMDelete(VMCxt);
</code></pre>
<p>Developers can also create the <code>VM</code> context with a <code>Store</code> context.
In this case, developers should guarantee the life cycle of the <code>Store</code> context.
Please refer to the <a href="sdk/c/ref.html#store">Store Contexts</a> for the details about the <code>Store</code> context APIs.</p>
<pre><code class="language-c">WasmEdge_StoreContext *StoreCxt = WasmEdge_StoreCreate();
WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(NULL, StoreCxt);
WasmEdge_StoreContext *StoreCxtMock = WasmEdge_VMGetStoreContext(VMCxt);
/* The `StoreCxt` and the `StoreCxtMock` are the same. */
WasmEdge_VMDelete(VMCxt);
WasmEdge_StoreDelete(StoreCxt);
</code></pre>
</li>
<li>
<p>List exported functions</p>
<p>After the WASM module instantiation, developers can use the <code>WasmEdge_VMExecute()</code> API to invoke the exported WASM functions. For this purpose, developers may need information about the exported WASM function list.
Please refer to the <a href="sdk/c/ref.html#instances">Instances in runtime</a> for the details about the function types.
Assume that the WASM file <a href="https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/examples/wasm/fibonacci.wasm"><code>fibonacci.wasm</code></a> is copied into the current directory, and the C file <code>test.c</code> is as following:</p>
<pre><code class="language-c">#include &lt;wasmedge/wasmedge.h&gt;
#include &lt;stdio.h&gt;
int main() {
  WasmEdge_StoreContext *StoreCxt = WasmEdge_StoreCreate();
  WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(NULL, StoreCxt);

  WasmEdge_VMLoadWasmFromFile(VMCxt, &quot;fibonacci.wasm&quot;);
  WasmEdge_VMValidate(VMCxt);
  WasmEdge_VMInstantiate(VMCxt);

  /* List the exported functions. */
  /* Get the number of exported functions. */
  uint32_t FuncNum = WasmEdge_VMGetFunctionListLength(VMCxt);
  /* Create the name buffers and the function type buffers. */
  const uint32_t BUF_LEN = 256;
  WasmEdge_String FuncNames[BUF_LEN];
  WasmEdge_FunctionTypeContext *FuncTypes[BUF_LEN];
  /*
   * Get the export function list.
   * If the function list length is larger than the buffer length, the
   * overflowed data will be discarded. The `FuncNames` and `FuncTypes` can
   * be NULL if developers don't need them.
   */
  uint32_t RealFuncNum =
      WasmEdge_VMGetFunctionList(VMCxt, FuncNames, FuncTypes, BUF_LEN);

  for (uint32_t I = 0; I &lt; RealFuncNum &amp;&amp; I &lt; BUF_LEN; I++) {
    char Buf[BUF_LEN];
    uint32_t Size = WasmEdge_StringCopy(FuncNames[I], Buf, sizeof(Buf));
    printf(&quot;Get exported function string length: %u, name: %s\n&quot;, Size,
           Buf);
    /*
     * The function names should be __NOT__ destroyed.
     * The returned function type contexts should __NOT__ be destroyed.
     */
  }
  return 0;
}
</code></pre>
<p>Then you can compile and run: (the only exported function in <code>fibonacci.wasm</code> is <code>fib</code>)</p>
<pre><code class="language-bash">$ gcc test.c -lwasmedge
$ ./a.out
Get exported function string length: 3, name: fib
</code></pre>
<p>If developers want to get the exported function names in the registered WASM modules, please retrieve the <code>Store</code> context from the <code>VM</code> context and refer to the APIs of <a href="sdk/c/ref.html#store">Store Contexts</a> to list the registered functions by the module name.</p>
</li>
<li>
<p>Get function types</p>
<p>The <code>VM</code> context provides APIs to find the function type by function name.
Please refer to the <a href="sdk/c/ref.html#instances">Instances in runtime</a> for the details about the function types.</p>
<pre><code class="language-c">/*
 * ...
 * Assume that a WASM module is instantiated in `VMCxt`.
 */
WasmEdge_String FuncName = WasmEdge_StringCreateByCString(&quot;fib&quot;);
const WasmEdge_FunctionTypeContext *FuncType =
    WasmEdge_VMGetFunctionType(VMCxt, FuncName);
/*
 * Developers can get the function types of functions in the registered
 * modules via the `WasmEdge_VMGetFunctionTypeRegistered()` API with the
 * module name. If the function is not found, these APIs will return `NULL`.
 * The returned function type contexts should __NOT__ be destroyed.
 */
WasmEdge_StringDelete(FuncName);
</code></pre>
</li>
<li>
<p>Get the active module</p>
<p>After the WASM module instantiation, an anonymous module is instantiated and owned by the <code>VM</code> context.
Developers may need to retrieve it to get the instances beyond the module.
Then developers can use the <code>WasmEdge_VMGetActiveModule()</code> API to get that anonymous module instance.
Please refer to the <a href="sdk/c/ref.html#instances">Module instance</a> for the details about the module instance APIs.</p>
<pre><code class="language-c">/*
 * ...
 * Assume that a WASM module is instantiated in `VMCxt`.
 */
const WasmEdge_ModuleInstanceContext *ModCxt =
    WasmEdge_VMGetActiveModule(VMCxt);
/*
 * If there's no WASM module instantiated, this API will return `NULL`.
 * The returned module instance context should __NOT__ be destroyed.
 */
</code></pre>
</li>
<li>
<p>Get the components</p>
<p>The <code>VM</code> context is composed by the <code>Loader</code>, <code>Validator</code>, and <code>Executor</code> contexts.
For the developers who want to use these contexts without creating another instances, these APIs can help developers to get them from the <code>VM</code> context.
The get contexts are owned by the <code>VM</code> context, and developers should not call their delete functions.</p>
<pre><code class="language-c">WasmEdge_LoaderContext *LoadCxt = WasmEdge_VMGetLoaderContext(VMCxt);
/* The object should __NOT__ be deleted by `WasmEdge_LoaderDelete()`. */
WasmEdge_ValidatorContext *ValidCxt = WasmEdge_VMGetValidatorContext(VMCxt);
/* The object should __NOT__ be deleted by `WasmEdge_ValidatorDelete()`. */
WasmEdge_ExecutorContext *ExecCxt = WasmEdge_VMGetExecutorContext(VMCxt);
/* The object should __NOT__ be deleted by `WasmEdge_ExecutorDelete()`. */
</code></pre>
</li>
</ol>
<h2 id="wasmedge-runtime"><a class="header" href="#wasmedge-runtime">WasmEdge Runtime</a></h2>
<p>In this partition, we will introduce the objects of WasmEdge runtime manually.</p>
<h3 id="wasm-execution-example-step-by-step"><a class="header" href="#wasm-execution-example-step-by-step">WASM Execution Example Step-By-Step</a></h3>
<p>Besides the WASM execution through the <a href="sdk/c/ref.html#wasmedge-vm"><code>VM</code> context</a>, developers can execute the WASM functions or instantiate WASM modules step-by-step with the <code>Loader</code>, <code>Validator</code>, <code>Executor</code>, and <code>Store</code> contexts.
Assume that the WASM file <a href="https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/examples/wasm/fibonacci.wasm"><code>fibonacci.wasm</code></a> is copied into the current directory, and the C file <code>test.c</code> is as following:</p>
<pre><code class="language-c">#include &lt;wasmedge/wasmedge.h&gt;
#include &lt;stdio.h&gt;
int main() {
  /*
   * Create the configure context. This step is not necessary because we didn't
   * adjust any setting.
   */
  WasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();
  /*
   * Create the statistics context. This step is not necessary if the statistics
   * in runtime is not needed.
   */
  WasmEdge_StatisticsContext *StatCxt = WasmEdge_StatisticsCreate();
  /*
   * Create the store context. The store context is the object to link the
   * modules for imports and exports.
   */
  WasmEdge_StoreContext *StoreCxt = WasmEdge_StoreCreate();
  /* Result. */
  WasmEdge_Result Res;

  /* Create the loader context. The configure context can be NULL. */
  WasmEdge_LoaderContext *LoadCxt = WasmEdge_LoaderCreate(ConfCxt);
  /* Create the validator context. The configure context can be NULL. */
  WasmEdge_ValidatorContext *ValidCxt = WasmEdge_ValidatorCreate(ConfCxt);
  /*
   * Create the executor context. The configure context and the statistics
   * context can be NULL.
   */
  WasmEdge_ExecutorContext *ExecCxt = WasmEdge_ExecutorCreate(ConfCxt, StatCxt);

  /*
   * Load the WASM file or the compiled-WASM file and convert into the AST
   * module context.
   */
  WasmEdge_ASTModuleContext *ASTCxt = NULL;
  Res = WasmEdge_LoaderParseFromFile(LoadCxt, &amp;ASTCxt, &quot;fibonacci.wasm&quot;);
  if (!WasmEdge_ResultOK(Res)) {
    printf(&quot;Loading phase failed: %s\n&quot;, WasmEdge_ResultGetMessage(Res));
    return 1;
  }
  /* Validate the WASM module. */
  Res = WasmEdge_ValidatorValidate(ValidCxt, ASTCxt);
  if (!WasmEdge_ResultOK(Res)) {
    printf(&quot;Validation phase failed: %s\n&quot;, WasmEdge_ResultGetMessage(Res));
    return 1;
  }
  /* Instantiate the WASM module into store context. */
  WasmEdge_ModuleInstanceContext *ModCxt = NULL;
  Res = WasmEdge_ExecutorInstantiate(ExecCxt, &amp;ModCxt, StoreCxt, ASTCxt);
  if (!WasmEdge_ResultOK(Res)) {
    printf(&quot;Instantiation phase failed: %s\n&quot;, WasmEdge_ResultGetMessage(Res));
    return 1;
  }

  /* Try to list the exported functions of the instantiated WASM module. */
  uint32_t FuncNum = WasmEdge_ModuleInstanceListFunctionLength(ModCxt);
  /* Create the name buffers. */
  const uint32_t BUF_LEN = 256;
  WasmEdge_String FuncNames[BUF_LEN];
  /*
   * If the list length is larger than the buffer length, the overflowed data
   * will be discarded.
   */
  uint32_t RealFuncNum =
      WasmEdge_ModuleInstanceListFunction(ModCxt, FuncNames, BUF_LEN);
  for (uint32_t I = 0; I &lt; RealFuncNum &amp;&amp; I &lt; BUF_LEN; I++) {
    char Buf[BUF_LEN];
    uint32_t Size = WasmEdge_StringCopy(FuncNames[I], Buf, sizeof(Buf));
    printf(&quot;Get exported function string length: %u, name: %s\n&quot;, Size, Buf);
    /* The function names should __NOT__ be destroyed. */
  }

  /* The parameters and returns arrays. */
  WasmEdge_Value Params[1] = {WasmEdge_ValueGenI32(18)};
  WasmEdge_Value Returns[1];
  /* Function name. */
  WasmEdge_String FuncName = WasmEdge_StringCreateByCString(&quot;fib&quot;);
  /* Find the exported function by function name. */
  WasmEdge_FunctionInstanceContext *FuncCxt =
      WasmEdge_ModuleInstanceFindFunction(ModCxt, FuncName);
  if (FuncCxt == NULL) {
    printf(&quot;Function `fib` not found.\n&quot;);
    return 1;
  }
  /* Invoke the WASM fnction. */
  Res = WasmEdge_ExecutorInvoke(ExecCxt, FuncCxt, Params, 1, Returns, 1);
  if (WasmEdge_ResultOK(Res)) {
    printf(&quot;Get the result: %d\n&quot;, WasmEdge_ValueGetI32(Returns[0]));
  } else {
    printf(&quot;Execution phase failed: %s\n&quot;, WasmEdge_ResultGetMessage(Res));
  }

  /* Resources deallocations. */
  WasmEdge_StringDelete(FuncName);
  WasmEdge_ASTModuleDelete(ASTCxt);
  WasmEdge_ModuleInstanceDelete(ModCxt);
  WasmEdge_LoaderDelete(LoadCxt);
  WasmEdge_ValidatorDelete(ValidCxt);
  WasmEdge_ExecutorDelete(ExecCxt);
  WasmEdge_ConfigureDelete(ConfCxt);
  WasmEdge_StoreDelete(StoreCxt);
  WasmEdge_StatisticsDelete(StatCxt);
  return 0;
}
</code></pre>
<p>Then you can compile and run: (the 18th Fibonacci number is 4181 in 0-based index)</p>
<pre><code class="language-bash">$ gcc test.c -lwasmedge
$ ./a.out
Get exported function string length: 3, name: fib
Get the result: 4181
</code></pre>
<h3 id="loader"><a class="header" href="#loader">Loader</a></h3>
<p>The <code>Loader</code> context loads the WASM binary from files or buffers.
Both the WASM and the compiled-WASM from the <a href="sdk/c/ref.html#wasmedge-aot-compiler">WasmEdge AOT Compiler</a> are supported.</p>
<pre><code class="language-c">uint8_t Buf[4096];
/* ... Read the WASM code to the buffer. */
uint32_t FileSize = ...;
/* The `FileSize` is the length of the WASM code. */

/* Developers can adjust settings in the configure context. */
WasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();
/* Create the loader context. The configure context can be NULL. */
WasmEdge_LoaderContext *LoadCxt = WasmEdge_LoaderCreate(ConfCxt);

WasmEdge_ASTModuleContext *ASTCxt = NULL;
WasmEdge_Result Res;

/* Load WASM or compiled-WASM from the file. */
Res = WasmEdge_LoaderParseFromFile(LoadCxt, &amp;ASTCxt, &quot;fibonacci.wasm&quot;);
if (!WasmEdge_ResultOK(Res)) {
  printf(&quot;Loading phase failed: %s\n&quot;, WasmEdge_ResultGetMessage(Res));
}
/* The output AST module context should be destroyed. */
WasmEdge_ASTModuleDelete(ASTCxt);

/* Load WASM or compiled-WASM from the buffer. */
Res = WasmEdge_LoaderParseFromBuffer(LoadCxt, &amp;ASTCxt, Buf, FileSize);
if (!WasmEdge_ResultOK(Res)) {
  printf(&quot;Loading phase failed: %s\n&quot;, WasmEdge_ResultGetMessage(Res));
}
/* The output AST module context should be destroyed. */
WasmEdge_ASTModuleDelete(ASTCxt);

WasmEdge_LoaderDelete(LoadCxt);
WasmEdge_ConfigureDelete(ConfCxt);
</code></pre>
<h3 id="validator"><a class="header" href="#validator">Validator</a></h3>
<p>The <code>Validator</code> context can validate the WASM module.
Every WASM module should be validated before instantiation.</p>
<pre><code class="language-c">/* 
 * ...
 * Assume that the `ASTCxt` is the output AST module context from the loader
 * context.
 * Assume that the `ConfCxt` is the configure context.
 */
/* Create the validator context. The configure context can be NULL. */
WasmEdge_ValidatorContext *ValidCxt = WasmEdge_ValidatorCreate(ConfCxt);
WasmEdge_Result Res = WasmEdge_ValidatorValidate(ValidCxt, ASTCxt);
if (!WasmEdge_ResultOK(Res)) {
  printf(&quot;Validation phase failed: %s\n&quot;, WasmEdge_ResultGetMessage(Res));
}
WasmEdge_ValidatorDelete(ValidCxt);
</code></pre>
<h3 id="executor"><a class="header" href="#executor">Executor</a></h3>
<p>The <code>Executor</code> context is the executor for both WASM and compiled-WASM.
This object should work base on the <code>Store</code> context. For the details of the <code>Store</code> context, please refer to the <a href="sdk/c/ref.html#store">next chapter</a>.</p>
<ol>
<li>
<p>Instantiate and register an <code>AST module</code> as a named <code>Module</code> instance</p>
<p>As the same of <a href="sdk/c/ref.html#host-module-registrations">registering host modules</a> or <a href="sdk/c/ref.html#wasm-registrations-and-executions">importing WASM modules</a> in <code>VM</code> contexts, developers can instantiate and register an <code>AST module</code> contexts into the <code>Store</code> context as a named <code>Module</code> instance by the <code>Executor</code> APIs.
After the registration, the result <code>Module</code> instance is exported with the given module name and can be linked when instantiating another module.
For the details about the <code>Module</code> instances APIs, please refer to the <a href="sdk/c/ref.html#instances">Instances</a>.</p>
<pre><code class="language-c">/*
 * ...
 * Assume that the `ASTCxt` is the output AST module context from the loader
 * context and has passed the validation. Assume that the `ConfCxt` is the
 * configure context.
 */
/* Create the statistics context. This step is not necessary. */
WasmEdge_StatisticsContext *StatCxt = WasmEdge_StatisticsCreate();
/*
 * Create the executor context. The configure and the statistics contexts
 * can be NULL.
 */
WasmEdge_ExecutorContext *ExecCxt =
    WasmEdge_ExecutorCreate(ConfCxt, StatCxt);
/*
 * Create the store context. The store context is the object to link the
 * modules for imports and exports.
 */
WasmEdge_StoreContext *StoreCxt = WasmEdge_StoreCreate();
/* Result. */
WasmEdge_Result Res;

WasmEdge_String ModName = WasmEdge_StringCreateByCString(&quot;mod&quot;);
/* The output module instance. */
WasmEdge_ModuleInstanceContext *ModCxt = NULL;
/*
 * Register the WASM module into the store with the export module name
 * &quot;mod&quot;.
 */
Res =
    WasmEdge_ExecutorRegister(ExecCxt, &amp;ModCxt, StoreCxt, ASTCxt, ModName);
if (!WasmEdge_ResultOK(Res)) {
  printf(&quot;WASM registration failed: %s\n&quot;, WasmEdge_ResultGetMessage(Res));
  return -1;
}
WasmEdge_StringDelete(ModName);

/* ... */

/* After the execution, the resources should be released. */
WasmEdge_ExecutorDelete(ExecCxt);
WasmEdge_StatisticsDelete(StatCxt);
WasmEdge_StoreDelete(StoreCxt);
WasmEdge_ModuleInstanceDelete(ModCxt);
</code></pre>
</li>
<li>
<p>Register an existing <code>Module</code> instance and export the module name</p>
<p>Besides instantiating and registering an <code>AST module</code> contexts, developers can register an existing <code>Module</code> instance into the store with exporting the module name (which is in the <code>Module</code> instance already).
This case occurs when developers create a <code>Module</code> instance for the host functions and want to register it for linking.
For the details about the construction of host functions in <code>Module</code> instances, please refer to the <a href="sdk/c/ref.html#host-functions">Host Functions</a>.</p>
<pre><code class="language-c">/*
 * ...
 * Assume that the `ASTCxt` is the output AST module context from the loader
 * context and has passed the validation. Assume that the `ConfCxt` is the
 * configure context.
 */
/* Create the statistics context. This step is not necessary. */
WasmEdge_StatisticsContext *StatCxt = WasmEdge_StatisticsCreate();
/*
 * Create the executor context. The configure and the statistics contexts
 * can be NULL.
 */
WasmEdge_ExecutorContext *ExecCxt =
    WasmEdge_ExecutorCreate(ConfCxt, StatCxt);
/*
 * Create the store context. The store context is the object to link the
 * modules for imports and exports. 
 */
WasmEdge_StoreContext *StoreCxt = WasmEdge_StoreCreate();
/* Result. */
WasmEdge_Result Res;

/* Create a module instance for host functions. */
WasmEdge_String ModName = WasmEdge_StringCreateByCString(&quot;host-module&quot;);
WasmEdge_ModuleInstanceContext *HostModCxt =
    WasmEdge_ModuleInstanceCreate(ModName);
WasmEdge_StringDelete(ModName);
/*
 * ...
 * Create and add the host functions, tables, memories, and globals into the
 * module instance.
 */

/* Register the module instance into store with the exported module name. */
/* The export module name is in the module instance already. */
Res = WasmEdge_ExecutorRegisterImport(ExecCxt, StoreCxt, HostModCxt);
if (!WasmEdge_ResultOK(Res)) {
  printf(&quot;WASM registration failed: %s\n&quot;, WasmEdge_ResultGetMessage(Res));
  return -1;
}

/* ... */

/* After the execution, the resources should be released. */
WasmEdge_ExecutorDelete(ExecCxt);
WasmEdge_StatisticsDelete(StatCxt);
WasmEdge_StoreDelete(StoreCxt);
WasmEdge_ModuleInstanceDelete(ModCxt);
</code></pre>
</li>
<li>
<p>Instantiate an <code>AST module</code> to an anonymous <code>Module</code> instance</p>
<p>WASM or compiled-WASM modules should be instantiated before the function invocation.
Before instantiating a WASM module, please check the <a href="https://webassembly.github.io/spec/core/syntax/modules.html#syntax-import">import section</a> for ensuring the imports are registered into the <code>Store</code> context for linking.</p>
<pre><code class="language-c">/*
 * ...
 * Assume that the `ASTCxt` is the output AST module context from the loader
 * context and has passed the validation. Assume that the `ConfCxt` is the
 * configure context.
 */
/* Create the statistics context. This step is not necessary. */
WasmEdge_StatisticsContext *StatCxt = WasmEdge_StatisticsCreate();
/*
 * Create the executor context. The configure and the statistics contexts
 * can be NULL.
 */
WasmEdge_ExecutorContext *ExecCxt =
    WasmEdge_ExecutorCreate(ConfCxt, StatCxt);
/*
 * Create the store context. The store context is the object to link the
 * modules for imports and exports.
 */
WasmEdge_StoreContext *StoreCxt = WasmEdge_StoreCreate();

/* The output module instance. */
WasmEdge_ModuleInstanceContext *ModCxt = NULL;
/* Instantiate the WASM module. */
WasmEdge_Result Res =
    WasmEdge_ExecutorInstantiate(ExecCxt, &amp;ModCxt, StoreCxt, ASTCxt);
if (!WasmEdge_ResultOK(Res)) {
  printf(&quot;WASM instantiation failed: %s\n&quot;, WasmEdge_ResultGetMessage(Res));
  return -1;
}

/* ... */

/* After the execution, the resources should be released. */
WasmEdge_ExecutorDelete(ExecCxt);
WasmEdge_StatisticsDelete(StatCxt);
WasmEdge_StoreDelete(StoreCxt);
WasmEdge_ModuleInstanceDelete(ModCxt);
</code></pre>
</li>
<li>
<p>Invoke functions</p>
<p>After registering or instantiating and get the result <code>Module</code> instance, developers can retrieve the exported <code>Function</code> instances from the <code>Module</code> instance for invocation.
For the details about the <code>Module</code> instances APIs, please refer to the <a href="sdk/c/ref.html#instances">Instances</a>.
Please refer to the <a href="sdk/c/ref.html#wasm-execution-example-step-by-step">example above</a> for the <code>Function</code> instance invocation with the <code>WasmEdge_ExecutorInvoke()</code> API.</p>
</li>
</ol>
<h3 id="ast-module"><a class="header" href="#ast-module">AST Module</a></h3>
<p>The <code>AST Module</code> context presents the loaded structure from a WASM file or buffer. Developer will get this object after loading a WASM file or buffer from <a href="sdk/c/ref.html#loader">Loader</a>.
Before instantiation, developers can also query the imports and exports of an <code>AST Module</code> context.</p>
<pre><code class="language-c">WasmEdge_ASTModuleContext *ASTCxt = ...;
/* Assume that a WASM is loaded into an AST module context. */

/* Create the import type context buffers. */
const uint32_t BUF_LEN = 256;
const WasmEdge_ImportTypeContext *ImpTypes[BUF_LEN];
uint32_t ImportNum = WasmEdge_ASTModuleListImportsLength(ASTCxt);
/*
 * If the list length is larger than the buffer length, the overflowed data will
 * be discarded.
 */
uint32_t RealImportNum =
    WasmEdge_ASTModuleListImports(ASTCxt, ImpTypes, BUF_LEN);
for (uint32_t I = 0; I &lt; RealImportNum &amp;&amp; I &lt; BUF_LEN; I++) {
  /* Working with the import type `ImpTypes[I]` ... */
}

/* Create the export type context buffers. */
const WasmEdge_ExportTypeContext *ExpTypes[BUF_LEN];
uint32_t ExportNum = WasmEdge_ASTModuleListExportsLength(ASTCxt);
/*
 * If the list length is larger than the buffer length, the overflowed data will
 * be discarded.
 */
uint32_t RealExportNum =
    WasmEdge_ASTModuleListExports(ASTCxt, ExpTypes, BUF_LEN);
for (uint32_t I = 0; I &lt; RealExportNum &amp;&amp; I &lt; BUF_LEN; I++) {
  /* Working with the export type `ExpTypes[I]` ... */
}

WasmEdge_ASTModuleDelete(ASTCxt);
/*
 * After deletion of `ASTCxt`, all data queried from the `ASTCxt` should not be
 * accessed.
 */
</code></pre>
<h3 id="store"><a class="header" href="#store">Store</a></h3>
<p><a href="https://webassembly.github.io/spec/core/exec/runtime.html#store">Store</a> is the runtime structure for the representation of all global state that can be manipulated by WebAssembly programs.
The <code>Store</code> context in WasmEdge is an object to provide the instance exporting and importing when instantiating WASM modules.
Developers can retrieve the named modules from the <code>Store</code> context.</p>
<pre><code class="language-c">WasmEdge_StoreContext *StoreCxt = WasmEdge_StoreCreate();

/*
 * ...
 * Register a WASM module via the executor context.
 */

/* Try to list the registered WASM modules. */
uint32_t ModNum = WasmEdge_StoreListModuleLength(StoreCxt);
/* Create the name buffers. */
const uint32_t BUF_LEN = 256;
WasmEdge_String ModNames[BUF_LEN];
/*
 * If the list length is larger than the buffer length, the overflowed data will
 * be discarded.
 */
uint32_t RealModNum = WasmEdge_StoreListModule(StoreCxt, ModNames, BUF_LEN);
for (uint32_t I = 0; I &lt; RealModNum &amp;&amp; I &lt; BUF_LEN; I++) {
  /* Working with the module name `ModNames[I]` ... */
  /* The module names should __NOT__ be destroyed. */
}

/* Find named module by name. */
WasmEdge_String ModName = WasmEdge_StringCreateByCString(&quot;module&quot;);
const WasmEdge_ModuleInstanceContext *ModCxt =
    WasmEdge_StoreFindModule(StoreCxt, ModName);
/* If the module with name not found, the `ModCxt` will be NULL. */
WasmEdge_StringDelete(ModName);
</code></pre>
<h3 id="instances"><a class="header" href="#instances">Instances</a></h3>
<p>The instances are the runtime structures of WASM. Developers can retrieve the <code>Module</code> instances from the <code>Store</code> contexts, and retrieve the other instances from the <code>Module</code> instances.
A single instance can be allocated by its creation function. Developers can construct instances into an <code>Module</code> instance for registration. Please refer to the <a href="sdk/c/ref.html#host-functions">Host Functions</a> for details.
The instances created by their creation functions should be destroyed by developers, EXCEPT they are added into an <code>Module</code> instance.</p>
<ol>
<li>
<p>Module instance</p>
<p>After instantiating or registering an <code>AST module</code> context, developers will get a <code>Module</code> instance as the result, and have the responsibility to destroy it when not in use.
A <code>Module</code> instance can also be created for the host module. Please refer to the <a href="sdk/c/ref.html#host-functions">host function</a> for the details.
<code>Module</code> instance provides APIs to list and find the exported instances in the module.</p>
<pre><code class="language-c">/*
 * ...
 * Instantiate a WASM module via the executor context and get the `ModCxt`
 * as the output module instance.
 */

/* Try to list the exported instance of the instantiated WASM module. */
/* Take the function instances for example here. */
uint32_t FuncNum = WasmEdge_ModuleInstanceListFunctionLength(ModCxt);
/* Create the name buffers. */
const uint32_t BUF_LEN = 256;
WasmEdge_String FuncNames[BUF_LEN];
/*
 * If the list length is larger than the buffer length, the overflowed data
 * will be discarded.
 */
uint32_t RealFuncNum =
    WasmEdge_ModuleInstanceListFunction(ModCxt, FuncNames, BUF_LEN);
for (uint32_t I = 0; I &lt; RealFuncNum &amp;&amp; I &lt; BUF_LEN; I++) {
  /* Working with the function name `FuncNames[I]` ... */
  /* The function names should __NOT__ be destroyed. */
}

/* Try to find the exported instance of the instantiated WASM module. */
/* Take the function instances for example here. */
/* Function name. */
WasmEdge_String FuncName = WasmEdge_StringCreateByCString(&quot;fib&quot;);
WasmEdge_FunctionInstanceContext *FuncCxt =
    WasmEdge_ModuleInstanceFindFunction(ModCxt, FuncName);
/* `FuncCxt` will be `NULL` if the function not found. */
/*
 * The returned instance is owned by the module instance context and should
 * __NOT__ be destroyed.
 */
WasmEdge_StringDelete(FuncName);
</code></pre>
</li>
<li>
<p>Function instance</p>
<p><a href="https://webassembly.github.io/spec/core/exec/runtime.html#syntax-hostfunc">Host functions</a> are functions outside WebAssembly and passed to WASM modules as imports.
In WasmEdge, developers can create the <code>Function</code> contexts for host functions and add them into an <code>Module</code> instance context for registering into a <code>VM</code> or a <code>Store</code>.
Developers can retrieve the <code>Function Type</code> from the <code>Function</code> contexts through the API.
For the details of the <code>Host Function</code> guide, please refer to the <a href="sdk/c/ref.html#host-functions">next chapter</a>.</p>
<pre><code class="language-c">/* Retrieve the function instance from the module instance context. */
WasmEdge_FunctionInstanceContext *FuncCxt = ...;
WasmEdge_FunctionTypeContext *FuncTypeCxt =
    WasmEdge_FunctionInstanceGetFunctionType(FuncCxt);
/*
 * The `FuncTypeCxt` is owned by the `FuncCxt` and should __NOT__ be
 * destroyed.
 */

/*
 * For the function instance creation, please refer to the `Host Function`
 * guide.
 */
</code></pre>
</li>
<li>
<p>Table instance</p>
<p>In WasmEdge, developers can create the <code>Table</code> contexts and add them into an <code>Module</code> instance context for registering into a <code>VM</code> or a <code>Store</code>.
The <code>Table</code> contexts supply APIs to control the data in table instances.</p>
<pre><code class="language-c">WasmEdge_Limit TabLimit = {
    .HasMax = true, .Shared = false, .Min = 10, .Max = 20};
/* Create the table type with limit and the `FuncRef` element type. */
WasmEdge_TableTypeContext *TabTypeCxt =
    WasmEdge_TableTypeCreate(WasmEdge_RefType_FuncRef, TabLimit);
/* Create the table instance with table type. */
WasmEdge_TableInstanceContext *HostTable =
    WasmEdge_TableInstanceCreate(TabTypeCxt);
/* Delete the table type. */
WasmEdge_TableTypeDelete(TabTypeCxt);
WasmEdge_Result Res;
WasmEdge_Value Data;

TabTypeCxt = WasmEdge_TableInstanceGetTableType(HostTable);
/*
 * The `TabTypeCxt` got from table instance is owned by the `HostTable` and
 * should __NOT__ be destroyed.
 */
enum WasmEdge_RefType RefType = WasmEdge_TableTypeGetRefType(TabTypeCxt);
/* `RefType` will be `WasmEdge_RefType_FuncRef`. */
Data = WasmEdge_ValueGenFuncRef(5);
Res = WasmEdge_TableInstanceSetData(HostTable, Data, 3);
/* Set the function index 5 to the table[3]. */
/*
 * This will get an &quot;out of bounds table access&quot; error
 * because the position (13) is out of the table size (10):
 *   Res = WasmEdge_TableInstanceSetData(HostTable, Data, 13);
 */
Res = WasmEdge_TableInstanceGetData(HostTable, &amp;Data, 3);
/* Get the FuncRef value of the table[3]. */
/*
 * This will get an &quot;out of bounds table access&quot; error
 * because the position (13) is out of the table size (10):
 *   Res = WasmEdge_TableInstanceGetData(HostTable, &amp;Data, 13);
 */

uint32_t Size = WasmEdge_TableInstanceGetSize(HostTable);
/* `Size` will be 10. */
Res = WasmEdge_TableInstanceGrow(HostTable, 6);
/* Grow the table size of 6, the table size will be 16. */
/*
 * This will get an &quot;out of bounds table access&quot; error because
 * the size (16 + 6) will reach the table limit(20):
 *   Res = WasmEdge_TableInstanceGrow(HostTable, 6);
 */

WasmEdge_TableInstanceDelete(HostTable);
</code></pre>
</li>
<li>
<p>Memory instance</p>
<p>In WasmEdge, developers can create the <code>Memory</code> contexts and add them into an <code>Module</code> instance context for registering into a <code>VM</code> or a <code>Store</code>.
The <code>Memory</code> contexts supply APIs to control the data in memory instances.</p>
<pre><code class="language-c">WasmEdge_Limit MemLimit = {
    .HasMax = true, .Shared = false, .Min = 1, .Max = 5};
/* Create the memory type with limit. The memory page size is 64KiB. */
WasmEdge_MemoryTypeContext *MemTypeCxt =
    WasmEdge_MemoryTypeCreate(MemLimit);
/* Create the memory instance with memory type. */
WasmEdge_MemoryInstanceContext *HostMemory =
    WasmEdge_MemoryInstanceCreate(MemTypeCxt);
/* Delete the memory type. */
WasmEdge_MemoryTypeDelete(MemTypeCxt);
WasmEdge_Result Res;
uint8_t Buf[256];

Buf[0] = 0xAA;
Buf[1] = 0xBB;
Buf[2] = 0xCC;
Res = WasmEdge_MemoryInstanceSetData(HostMemory, Buf, 0x1000, 3);
/* Set the data[0:2] to the memory[4096:4098]. */
/*
 * This will get an &quot;out of bounds memory access&quot; error
 * because [65535:65537] is out of 1 page size (65536):
 *   Res = WasmEdge_MemoryInstanceSetData(HostMemory, Buf, 0xFFFF, 3);
 */
Buf[0] = 0;
Buf[1] = 0;
Buf[2] = 0;
Res = WasmEdge_MemoryInstanceGetData(HostMemory, Buf, 0x1000, 3);
/* Get the memory[4096:4098]. Buf[0:2] will be `{0xAA, 0xBB, 0xCC}`. */
/*
 * This will get an &quot;out of bounds memory access&quot; error
 * because [65535:65537] is out of 1 page size (65536):
 *   Res = WasmEdge_MemoryInstanceSetData(HostMemory, Buf, 0xFFFF, 3);
 */

uint32_t PageSize = WasmEdge_MemoryInstanceGetPageSize(HostMemory);
/* `PageSize` will be 1. */
Res = WasmEdge_MemoryInstanceGrowPage(HostMemory, 2);
/* Grow the page size of 2, the page size of the memory instance will be 3.
 */
/*
 * This will get an &quot;out of bounds memory access&quot; error because
 * the page size (3 + 3) will reach the memory limit(5):
 *   Res = WasmEdge_MemoryInstanceGrowPage(HostMemory, 3);
 */

WasmEdge_MemoryInstanceDelete(HostMemory);
</code></pre>
</li>
<li>
<p>Global instance</p>
<p>In WasmEdge, developers can create the <code>Global</code> contexts and add them into an <code>Module</code> instance context for registering into a <code>VM</code> or a <code>Store</code>.
The <code>Global</code> contexts supply APIs to control the value in global instances.</p>
<pre><code class="language-c">WasmEdge_Value Val = WasmEdge_ValueGenI64(1000);
/* Create the global type with value type and mutation. */
WasmEdge_GlobalTypeContext *GlobTypeCxt = WasmEdge_GlobalTypeCreate(
    WasmEdge_ValType_I64, WasmEdge_Mutability_Var);
/* Create the global instance with value and global type. */
WasmEdge_GlobalInstanceContext *HostGlobal =
    WasmEdge_GlobalInstanceCreate(GlobTypeCxt, Val);
/* Delete the global type. */
WasmEdge_GlobalTypeDelete(GlobTypeCxt);
WasmEdge_Result Res;

GlobTypeCxt = WasmEdge_GlobalInstanceGetGlobalType(HostGlobal);
/* The `GlobTypeCxt` got from global instance is owned by the `HostGlobal`
 * and should __NOT__ be destroyed. */
enum WasmEdge_ValType ValType = WasmEdge_GlobalTypeGetValType(GlobTypeCxt);
/* `ValType` will be `WasmEdge_ValType_I64`. */
enum WasmEdge_Mutability ValMut =
    WasmEdge_GlobalTypeGetMutability(GlobTypeCxt);
/* `ValMut` will be `WasmEdge_Mutability_Var`. */

WasmEdge_GlobalInstanceSetValue(HostGlobal, WasmEdge_ValueGenI64(888));
/*
 * Set the value u64(888) to the global.
 * This function will do nothing if the value type mismatched or
 * the global mutability is `WasmEdge_Mutability_Const`.
 */
WasmEdge_Value GlobVal = WasmEdge_GlobalInstanceGetValue(HostGlobal);
/* Get the value (888 now) of the global context. */

WasmEdge_GlobalInstanceDelete(HostGlobal);
</code></pre>
</li>
</ol>
<h3 id="host-functions-2"><a class="header" href="#host-functions-2">Host Functions</a></h3>
<p><a href="https://webassembly.github.io/spec/core/exec/runtime.html#syntax-hostfunc">Host functions</a> are functions outside WebAssembly and passed to WASM modules as imports.
In WasmEdge, developers can create the <code>Function</code>, <code>Memory</code>, <code>Table</code>, and <code>Global</code> contexts and add them into an <code>Module</code> instance context for registering into a <code>VM</code> or a <code>Store</code>.</p>
<ol>
<li>
<p>Host function allocation</p>
<p>Developers can define C functions with the following function signature as the host function body:</p>
<pre><code class="language-c">typedef WasmEdge_Result (*WasmEdge_HostFunc_t)(
    void *Data, const WasmEdge_CallingFrameContext *CallFrameCxt,
    const WasmEdge_Value *Params, WasmEdge_Value *Returns);
</code></pre>
<p>The example of an <code>add</code> host function to add 2 <code>i32</code> values:</p>
<pre><code class="language-c">WasmEdge_Result Add(void *, const WasmEdge_CallingFrameContext *,
                    const WasmEdge_Value *In, WasmEdge_Value *Out) {
  /*
  * Params: {i32, i32}
  * Returns: {i32}
  * Developers should take care about the function type.
  */ 
  /* Retrieve the value 1. */
  int32_t Val1 = WasmEdge_ValueGetI32(In[0]);
  /* Retrieve the value 2. */
  int32_t Val2 = WasmEdge_ValueGetI32(In[1]);
  /* Output value 1 is Val1 + Val2. */
  Out[0] = WasmEdge_ValueGenI32(Val1 + Val2);
  /* Return the status of success. */
  return WasmEdge_Result_Success;
}
</code></pre>
<p>Then developers can create <code>Function</code> context with the host function body and the function type:</p>
<pre><code class="language-c">enum WasmEdge_ValType ParamList[2] = {WasmEdge_ValType_I32,
                                      WasmEdge_ValType_I32};
enum WasmEdge_ValType ReturnList[1] = {WasmEdge_ValType_I32};
/* Create a function type: {i32, i32} -&gt; {i32}. */
WasmEdge_FunctionTypeContext *HostFType =
    WasmEdge_FunctionTypeCreate(ParamList, 2, ReturnList, 1);
/*
 * Create a function context with the function type and host function body.
 * The `Cost` parameter can be 0 if developers do not need the cost
 * measuring.
 */
WasmEdge_FunctionInstanceContext *HostFunc =
    WasmEdge_FunctionInstanceCreate(HostFType, Add, NULL, 0);
/*
 * The third parameter is the pointer to the additional data.
 * Developers should guarantee the life cycle of the data, and it can be
 * `NULL` if the external data is not needed.
 */
WasmEdge_FunctionTypeDelete(HostType);

/*
 * If the function instance is __NOT__ added into a module instance context,
 * it should be deleted.
 */
WasmEdge_FunctionInstanceDelete(HostFunc);
</code></pre>
</li>
<li>
<p>Calling frame context</p>
<p>The <code>WasmEdge_CallingFrameContext</code> is the context to provide developers to access the module instance of the <a href="https://webassembly.github.io/spec/core/exec/runtime.html#activations-and-frames">frame on the top of the calling stack</a>.
According to the <a href="https://webassembly.github.io/spec/core/exec/instructions.html#function-calls">WASM spec</a>, a frame with the module instance is pushed into the stack when invoking a function.
Therefore, the host functions can access the module instance of the top frame to retrieve the memory instances to read/write data.</p>
<pre><code class="language-c">WasmEdge_Result LoadOffset(void *Data,
                           const WasmEdge_CallingFrameContext *CallFrameCxt,
                           const WasmEdge_Value *In, WasmEdge_Value *Out) {
  /* Function type: {i32} -&gt; {} */
  uint32_t Offset = (uint32_t)WasmEdge_ValueGetI32(In[0]);
  uint32_t Num = 0;

  /*
   * Get the 0-th memory instance of the module instance of the top frame on
   * stack.
   */
  WasmEdge_MemoryInstanceContext *MemCxt =
      WasmEdge_CallingFrameGetMemoryInstance(CallFrameCxt, 0);

  WasmEdge_Result Res =
      WasmEdge_MemoryInstanceGetData(MemCxt, (uint8_t *)(&amp;Num), Offset, 4);
  if (WasmEdge_ResultOK(Res)) {
    printf(&quot;u32 at memory[%lu]: %lu\n&quot;, Offset, Num);
  } else {
    return Res;
  }
  return WasmEdge_Result_Success;
}
</code></pre>
<p>Besides using the <code>WasmEdge_CallingFrameGetMemoryInstance()</code> API to get the memory instance by index in the module instance, developers can use the <code>WasmEdge_CallingFrameGetModuleInstance()</code> to get the module instance directly.
Therefore, developers can retrieve the exported contexts by the <code>WasmEdge_ModuleInstanceContext</code> APIs.
And also, developers can use the <code>WasmEdge_CallingFrameGetExecutor()</code> API to get the currently used executor context.</p>
</li>
<li>
<p>User-defined error code of the host functions</p>
<p>In host functions, WasmEdge provides <code>WasmEdge_Result_Success</code> to return success, <code>WasmEdge_Result_Terminate</code> to terminate the WASM execution, and <code>WasmEdge_Result_Fail</code> to return fail.
WasmEdge also provides the usage of returning the user-specified codes.
Developers can use the <code>WasmEdge_ResultGen()</code> API to generate the <code>WasmEdge_Result</code> with error code, and use the <code>WasmEdge_ResultGetCode()</code> API to get the error code.</p>
<blockquote>
<p>Notice: The error code only supports 24-bit integer (0 ~ 16777216 in <code>uint32_t</code>). The values larger than 24-bit will be truncated.</p>
</blockquote>
<p>Assume that a simple WASM from the WAT is as following:</p>
<pre><code class="language-wasm">(module
  (type $t0 (func (param i32)))
  (import &quot;extern&quot; &quot;trap&quot; (func $f-trap (type $t0)))
  (func (export &quot;trap&quot;) (param i32)
    local.get 0
    call $f-trap)
)
</code></pre>
<p>And the <code>test.c</code> is as following:</p>
<pre><code class="language-c">#include &lt;wasmedge/wasmedge.h&gt;
#include &lt;stdio.h&gt;

/* Host function body definition. */
WasmEdge_Result Trap(void *Data,
                     const WasmEdge_CallingFrameContext *CallFrameCxt,
                     const WasmEdge_Value *In, WasmEdge_Value *Out) {
  int32_t Val = WasmEdge_ValueGetI32(In[0]);
  /* Return the error code from the param[0]. */
  return WasmEdge_ResultGen(WasmEdge_ErrCategory_UserLevelError, Val);
}

int main() {
  /* Create the VM context. */
  WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(NULL, NULL);

  /* The WASM module buffer. */
  uint8_t WASM[] = {/* WASM header */
                    0x00, 0x61, 0x73, 0x6D, 0x01, 0x00, 0x00, 0x00,
                    /* Type section */
                    0x01, 0x05, 0x01,
                    /* function type {i32} -&gt; {} */
                    0x60, 0x01, 0x7F, 0x00,
                    /* Import section */
                    0x02, 0x0F, 0x01,
                    /* module name: &quot;extern&quot; */
                    0x06, 0x65, 0x78, 0x74, 0x65, 0x72, 0x6E,
                    /* extern name: &quot;trap&quot; */
                    0x04, 0x74, 0x72, 0x61, 0x70,
                    /* import desc: func 0 */
                    0x00, 0x00,
                    /* Function section */
                    0x03, 0x02, 0x01, 0x00,
                    /* Export section */
                    0x07, 0x08, 0x01,
                    /* export name: &quot;trap&quot; */
                    0x04, 0x74, 0x72, 0x61, 0x70,
                    /* export desc: func 0 */
                    0x00, 0x01,
                    /* Code section */
                    0x0A, 0x08, 0x01,
                    /* code body */
                    0x06, 0x00, 0x20, 0x00, 0x10, 0x00, 0x0B};

  /* Create the module instance. */
  WasmEdge_String ExportName = WasmEdge_StringCreateByCString(&quot;extern&quot;);
  WasmEdge_ModuleInstanceContext *HostModCxt =
      WasmEdge_ModuleInstanceCreate(ExportName);
  enum WasmEdge_ValType ParamList[1] = {WasmEdge_ValType_I32};
  WasmEdge_FunctionTypeContext *HostFType =
      WasmEdge_FunctionTypeCreate(ParamList, 1, NULL, 0);
  WasmEdge_FunctionInstanceContext *HostFunc =
      WasmEdge_FunctionInstanceCreate(HostFType, Trap, NULL, 0);
  WasmEdge_FunctionTypeDelete(HostFType);
  WasmEdge_String HostFuncName = WasmEdge_StringCreateByCString(&quot;trap&quot;);
  WasmEdge_ModuleInstanceAddFunction(HostModCxt, HostFuncName, HostFunc);
  WasmEdge_StringDelete(HostFuncName);

  WasmEdge_VMRegisterModuleFromImport(VMCxt, HostModCxt);

  /* The parameters and returns arrays. */
  WasmEdge_Value Params[1] = {WasmEdge_ValueGenI32(5566)};
  /* Function name. */
  WasmEdge_String FuncName = WasmEdge_StringCreateByCString(&quot;trap&quot;);
  /* Run the WASM function from file. */
  WasmEdge_Result Res = WasmEdge_VMRunWasmFromBuffer(
      VMCxt, WASM, sizeof(WASM), FuncName, Params, 1, NULL, 0);

  /* Get the result code and print. */
  printf(&quot;Get the error code: %u\n&quot;, WasmEdge_ResultGetCode(Res));

  /* Resources deallocations. */
  WasmEdge_VMDelete(VMCxt);
  WasmEdge_StringDelete(FuncName);
  WasmEdge_ModuleInstanceDelete(HostModCxt);
  return 0;
}
</code></pre>
<p>Then you can compile and run: (giving the expected error code <code>5566</code>)</p>
<pre><code class="language-bash">$ gcc test.c -lwasmedge
$ ./a.out
[2022-08-26 15:06:40.384] [error] user defined failed: user defined error code, Code: 0x15be
[2022-08-26 15:06:40.384] [error]     When executing function name: &quot;trap&quot;
Get the error code: 5566
</code></pre>
</li>
<li>
<p>Construct a module instance with host instances</p>
<p>Besides creating a <code>Module</code> instance by registering or instantiating a WASM module, developers can create a <code>Module</code> instance with a module name and add the <code>Function</code>, <code>Memory</code>, <code>Table</code>, and <code>Global</code> instances into it with their exporting names.</p>
<pre><code class="language-c">/* Host function body definition. */
WasmEdge_Result Add(void *Data,
                    const WasmEdge_CallingFrameContext *CallFrameCxt,
                    const WasmEdge_Value *In, WasmEdge_Value *Out) {
  int32_t Val1 = WasmEdge_ValueGetI32(In[0]);
  int32_t Val2 = WasmEdge_ValueGetI32(In[1]);
  Out[0] = WasmEdge_ValueGenI32(Val1 + Val2);
  return WasmEdge_Result_Success;
}

/* Create a module instance. */
WasmEdge_String ExportName = WasmEdge_StringCreateByCString(&quot;module&quot;);
WasmEdge_ModuleInstanceContext *HostModCxt =
    WasmEdge_ModuleInstanceCreate(ExportName);
WasmEdge_StringDelete(ExportName);

/* Create and add a function instance into the module instance. */
enum WasmEdge_ValType ParamList[2] = {WasmEdge_ValType_I32,
                                      WasmEdge_ValType_I32};
enum WasmEdge_ValType ReturnList[1] = {WasmEdge_ValType_I32};
WasmEdge_FunctionTypeContext *HostFType =
    WasmEdge_FunctionTypeCreate(ParamList, 2, ReturnList, 1);
WasmEdge_FunctionInstanceContext *HostFunc =
    WasmEdge_FunctionInstanceCreate(HostFType, Add, NULL, 0);
/*
 * The third parameter is the pointer to the additional data object.
 * Developers should guarantee the life cycle of the data, and it can be
 * `NULL` if the external data is not needed.
 */
WasmEdge_FunctionTypeDelete(HostFType);
WasmEdge_String FuncName = WasmEdge_StringCreateByCString(&quot;add&quot;);
WasmEdge_ModuleInstanceAddFunction(HostModCxt, FuncName, HostFunc);
WasmEdge_StringDelete(FuncName);

/* Create and add a table instance into the import object. */
WasmEdge_Limit TableLimit = {
    .HasMax = true, .Shared = false, .Min = 10, .Max = 20};
WasmEdge_TableTypeContext *HostTType =
    WasmEdge_TableTypeCreate(WasmEdge_RefType_FuncRef, TableLimit);
WasmEdge_TableInstanceContext *HostTable =
    WasmEdge_TableInstanceCreate(HostTType);
WasmEdge_TableTypeDelete(HostTType);
WasmEdge_String TableName = WasmEdge_StringCreateByCString(&quot;table&quot;);
WasmEdge_ModuleInstanceAddTable(HostModCxt, TableName, HostTable);
WasmEdge_StringDelete(TableName);

/* Create and add a memory instance into the import object. */
WasmEdge_Limit MemoryLimit = {
    .HasMax = true, .Shared = false, .Min = 1, .Max = 2};
WasmEdge_MemoryTypeContext *HostMType =
    WasmEdge_MemoryTypeCreate(MemoryLimit);
WasmEdge_MemoryInstanceContext *HostMemory =
    WasmEdge_MemoryInstanceCreate(HostMType);
WasmEdge_MemoryTypeDelete(HostMType);
WasmEdge_String MemoryName = WasmEdge_StringCreateByCString(&quot;memory&quot;);
WasmEdge_ModuleInstanceAddMemory(HostModCxt, MemoryName, HostMemory);
WasmEdge_StringDelete(MemoryName);

/* Create and add a global instance into the module instance. */
WasmEdge_GlobalTypeContext *HostGType = WasmEdge_GlobalTypeCreate(
    WasmEdge_ValType_I32, WasmEdge_Mutability_Var);
WasmEdge_GlobalInstanceContext *HostGlobal =
    WasmEdge_GlobalInstanceCreate(HostGType, WasmEdge_ValueGenI32(666));
WasmEdge_GlobalTypeDelete(HostGType);
WasmEdge_String GlobalName = WasmEdge_StringCreateByCString(&quot;global&quot;);
WasmEdge_ModuleInstanceAddGlobal(HostModCxt, GlobalName, HostGlobal);
WasmEdge_StringDelete(GlobalName);

/*
 * The module instance should be deleted.
 * Developers should __NOT__ destroy the instances added into the module
 * instance contexts.
 */
WasmEdge_ModuleInstanceDelete(HostModCxt);
</code></pre>
</li>
<li>
<p>Specified module instance</p>
<p><code>WasmEdge_ModuleInstanceCreateWASI()</code> API can create and initialize the <code>WASI</code> module instance.</p>
<p><code>WasmEdge_ModuleInstanceCreateWasiNN()</code> API can create and initialize the <code>wasi_ephemeral_nn</code> module instance for <code>WASI-NN</code> plugin.</p>
<p><code>WasmEdge_ModuleInstanceCreateWasiCryptoCommon()</code> API can create and initialize the <code>wasi_ephemeral_crypto_common</code> module instance for <code>WASI-Crypto</code> plugin.</p>
<p><code>WasmEdge_ModuleInstanceCreateWasiCryptoAsymmetricCommon()</code> API can create and initialize the <code>wasi_ephemeral_crypto_asymmetric_common</code> module instance for <code>WASI-Crypto</code> plugin.</p>
<p><code>WasmEdge_ModuleInstanceCreateWasiCryptoKx()</code> API can create and initialize the <code>wasi_ephemeral_crypto_kx</code> module instance for <code>WASI-Crypto</code> plugin.</p>
<p><code>WasmEdge_ModuleInstanceCreateWasiCryptoSignatures()</code> API can create and initialize the <code>wasi_ephemeral_crypto_signatures</code> module instance for <code>WASI-Crypto</code> plugin.</p>
<p><code>WasmEdge_ModuleInstanceCreateWasiCryptoSymmetric()</code> API can create and initialize the <code>wasi_ephemeral_crypto_symmetric</code> module instance for <code>WASI-Crypto</code> plugin.</p>
<p><code>WasmEdge_ModuleInstanceCreateWasmEdgeProcess()</code> API can create and initialize the <code>wasmedge_process</code> module instance for <code>wasmedge_process</code> plugin.</p>
<p>Developers can create these module instance contexts and register them into the <code>Store</code> or <code>VM</code> contexts rather than adjust the settings in the <code>Configure</code> contexts.</p>
<blockquote>
<p>Note: For the <code>WASI-NN</code> plugin, please check that the <a href="sdk/c/../../write_wasm/rust/wasinn.html#prerequisites">dependencies and prerequests</a> are satisfied.
Note: For the <code>WASI-Crypto</code> plugin, please check that the <a href="sdk/c/../../write_wasm/rust/wasicrypto.html#prerequisites">dependencies and prerequests</a> are satisfied. And the 5 modules are recommended to all be created and registered together.</p>
</blockquote>
<pre><code class="language-c">WasmEdge_ModuleInstanceContext *WasiModCxt =
    WasmEdge_ModuleInstanceCreateWASI(/* ... ignored */);
WasmEdge_ModuleInstanceContext *ProcModCxt =
    WasmEdge_ModuleInstanceCreateWasmEdgeProcess(/* ... ignored */);
WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(NULL, NULL);
/* Register the WASI and WasmEdge_Process into the VM context. */
WasmEdge_VMRegisterModuleFromImport(VMCxt, WasiModCxt);
WasmEdge_VMRegisterModuleFromImport(VMCxt, ProcModCxt);
/* Get the WASI exit code. */
uint32_t ExitCode = WasmEdge_ModuleInstanceWASIGetExitCode(WasiModCxt);
/*
 * The `ExitCode` will be EXIT_SUCCESS if the execution has no error.
 * Otherwise, it will return with the related exit code.
 */
WasmEdge_VMDelete(VMCxt);
/* The module instances should be deleted. */
WasmEdge_ModuleInstanceDelete(WasiModCxt);
WasmEdge_ModuleInstanceDelete(ProcModCxt);
</code></pre>
</li>
<li>
<p>Example</p>
<p>Assume that a simple WASM from the WAT is as following:</p>
<pre><code class="language-wasm">(module
  (type $t0 (func (param i32 i32) (result i32)))
  (import &quot;extern&quot; &quot;func-add&quot; (func $f-add (type $t0)))
  (func (export &quot;addTwo&quot;) (param i32 i32) (result i32)
    local.get 0
    local.get 1
    call $f-add)
)
</code></pre>
<p>And the <code>test.c</code> is as following:</p>
<pre><code class="language-c">#include &lt;wasmedge/wasmedge.h&gt;
#include &lt;stdio.h&gt;

/* Host function body definition. */
WasmEdge_Result Add(void *Data,
                    const WasmEdge_CallingFrameContext *CallFrameCxt,
                    const WasmEdge_Value *In, WasmEdge_Value *Out) {
  int32_t Val1 = WasmEdge_ValueGetI32(In[0]);
  int32_t Val2 = WasmEdge_ValueGetI32(In[1]);
  printf(&quot;Host function \&quot;Add\&quot;: %d + %d\n&quot;, Val1, Val2);
  Out[0] = WasmEdge_ValueGenI32(Val1 + Val2);
  return WasmEdge_Result_Success;
}

int main() {
  /* Create the VM context. */
  WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(NULL, NULL);

  /* The WASM module buffer. */
  uint8_t WASM[] = {/* WASM header */
                    0x00, 0x61, 0x73, 0x6D, 0x01, 0x00, 0x00, 0x00,
                    /* Type section */
                    0x01, 0x07, 0x01,
                    /* function type {i32, i32} -&gt; {i32} */
                    0x60, 0x02, 0x7F, 0x7F, 0x01, 0x7F,
                    /* Import section */
                    0x02, 0x13, 0x01,
                    /* module name: &quot;extern&quot; */
                    0x06, 0x65, 0x78, 0x74, 0x65, 0x72, 0x6E,
                    /* extern name: &quot;func-add&quot; */
                    0x08, 0x66, 0x75, 0x6E, 0x63, 0x2D, 0x61, 0x64, 0x64,
                    /* import desc: func 0 */
                    0x00, 0x00,
                    /* Function section */
                    0x03, 0x02, 0x01, 0x00,
                    /* Export section */
                    0x07, 0x0A, 0x01,
                    /* export name: &quot;addTwo&quot; */
                    0x06, 0x61, 0x64, 0x64, 0x54, 0x77, 0x6F,
                    /* export desc: func 0 */
                    0x00, 0x01,
                    /* Code section */
                    0x0A, 0x0A, 0x01,
                    /* code body */
                    0x08, 0x00, 0x20, 0x00, 0x20, 0x01, 0x10, 0x00, 0x0B};

  /* Create the module instance. */
  WasmEdge_String ExportName = WasmEdge_StringCreateByCString(&quot;extern&quot;);
  WasmEdge_ModuleInstanceContext *HostModCxt =
      WasmEdge_ModuleInstanceCreate(ExportName);
  enum WasmEdge_ValType ParamList[2] = {WasmEdge_ValType_I32,
                                        WasmEdge_ValType_I32};
  enum WasmEdge_ValType ReturnList[1] = {WasmEdge_ValType_I32};
  WasmEdge_FunctionTypeContext *HostFType =
      WasmEdge_FunctionTypeCreate(ParamList, 2, ReturnList, 1);
  WasmEdge_FunctionInstanceContext *HostFunc =
      WasmEdge_FunctionInstanceCreate(HostFType, Add, NULL, 0);
  WasmEdge_FunctionTypeDelete(HostFType);
  WasmEdge_String HostFuncName = WasmEdge_StringCreateByCString(&quot;func-add&quot;);
  WasmEdge_ModuleInstanceAddFunction(HostModCxt, HostFuncName, HostFunc);
  WasmEdge_StringDelete(HostFuncName);

  WasmEdge_VMRegisterModuleFromImport(VMCxt, HostModCxt);

  /* The parameters and returns arrays. */
  WasmEdge_Value Params[2] = {WasmEdge_ValueGenI32(1234),
                              WasmEdge_ValueGenI32(5678)};
  WasmEdge_Value Returns[1];
  /* Function name. */
  WasmEdge_String FuncName = WasmEdge_StringCreateByCString(&quot;addTwo&quot;);
  /* Run the WASM function from file. */
  WasmEdge_Result Res = WasmEdge_VMRunWasmFromBuffer(
      VMCxt, WASM, sizeof(WASM), FuncName, Params, 2, Returns, 1);

  if (WasmEdge_ResultOK(Res)) {
    printf(&quot;Get the result: %d\n&quot;, WasmEdge_ValueGetI32(Returns[0]));
  } else {
    printf(&quot;Error message: %s\n&quot;, WasmEdge_ResultGetMessage(Res));
  }

  /* Resources deallocations. */
  WasmEdge_VMDelete(VMCxt);
  WasmEdge_StringDelete(FuncName);
  WasmEdge_ModuleInstanceDelete(HostModCxt);
  return 0;
}
</code></pre>
<p>Then you can compile and run: (the result of 1234 + 5678 is 6912)</p>
<pre><code class="language-bash">$ gcc test.c -lwasmedge
$ ./a.out
Host function &quot;Add&quot;: 1234 + 5678
Get the result: 6912
</code></pre>
</li>
<li>
<p>Host Data Example</p>
<p>Developers can set a external data object to the <code>Function</code> context, and access to the object in the function body.
Assume that a simple WASM from the WAT is as following:</p>
<pre><code class="language-wasm">(module
  (type $t0 (func (param i32 i32) (result i32)))
  (import &quot;extern&quot; &quot;func-add&quot; (func $f-add (type $t0)))
  (func (export &quot;addTwo&quot;) (param i32 i32) (result i32)
    local.get 0
    local.get 1
    call $f-add)
)
</code></pre>
<p>And the <code>test.c</code> is as following:</p>
<pre><code class="language-c">#include &lt;wasmedge/wasmedge.h&gt;
#include &lt;stdio.h&gt;

/* Host function body definition. */
WasmEdge_Result Add(void *Data,
                    const WasmEdge_CallingFrameContext *CallFrameCxt,
                    const WasmEdge_Value *In, WasmEdge_Value *Out) {
  int32_t Val1 = WasmEdge_ValueGetI32(In[0]);
  int32_t Val2 = WasmEdge_ValueGetI32(In[1]);
  printf(&quot;Host function \&quot;Add\&quot;: %d + %d\n&quot;, Val1, Val2);
  Out[0] = WasmEdge_ValueGenI32(Val1 + Val2);
  /* Also set the result to the data. */
  int32_t *DataPtr = (int32_t *)Data;
  *DataPtr = Val1 + Val2;
  return WasmEdge_Result_Success;
}

int main() {
  /* Create the VM context. */
  WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(NULL, NULL);

  /* The WASM module buffer. */
  uint8_t WASM[] = {/* WASM header */
                    0x00, 0x61, 0x73, 0x6D, 0x01, 0x00, 0x00, 0x00,
                    /* Type section */
                    0x01, 0x07, 0x01,
                    /* function type {i32, i32} -&gt; {i32} */
                    0x60, 0x02, 0x7F, 0x7F, 0x01, 0x7F,
                    /* Import section */
                    0x02, 0x13, 0x01,
                    /* module name: &quot;extern&quot; */
                    0x06, 0x65, 0x78, 0x74, 0x65, 0x72, 0x6E,
                    /* extern name: &quot;func-add&quot; */
                    0x08, 0x66, 0x75, 0x6E, 0x63, 0x2D, 0x61, 0x64, 0x64,
                    /* import desc: func 0 */
                    0x00, 0x00,
                    /* Function section */
                    0x03, 0x02, 0x01, 0x00,
                    /* Export section */
                    0x07, 0x0A, 0x01,
                    /* export name: &quot;addTwo&quot; */
                    0x06, 0x61, 0x64, 0x64, 0x54, 0x77, 0x6F,
                    /* export desc: func 0 */
                    0x00, 0x01,
                    /* Code section */
                    0x0A, 0x0A, 0x01,
                    /* code body */
                    0x08, 0x00, 0x20, 0x00, 0x20, 0x01, 0x10, 0x00, 0x0B};

  /* The external data object: an integer. */
  int32_t Data;

  /* Create the module instance. */
  WasmEdge_String ExportName = WasmEdge_StringCreateByCString(&quot;extern&quot;);
  WasmEdge_ModuleInstanceContext *HostModCxt =
      WasmEdge_ModuleInstanceCreate(ExportName);
  enum WasmEdge_ValType ParamList[2] = {WasmEdge_ValType_I32,
                                        WasmEdge_ValType_I32};
  enum WasmEdge_ValType ReturnList[1] = {WasmEdge_ValType_I32};
  WasmEdge_FunctionTypeContext *HostFType =
      WasmEdge_FunctionTypeCreate(ParamList, 2, ReturnList, 1);
  WasmEdge_FunctionInstanceContext *HostFunc =
      WasmEdge_FunctionInstanceCreate(HostFType, Add, &amp;Data, 0);
  WasmEdge_FunctionTypeDelete(HostFType);
  WasmEdge_String HostFuncName = WasmEdge_StringCreateByCString(&quot;func-add&quot;);
  WasmEdge_ModuleInstanceAddFunction(HostModCxt, HostFuncName, HostFunc);
  WasmEdge_StringDelete(HostFuncName);

  WasmEdge_VMRegisterModuleFromImport(VMCxt, HostModCxt);

  /* The parameters and returns arrays. */
  WasmEdge_Value Params[2] = {WasmEdge_ValueGenI32(1234),
                              WasmEdge_ValueGenI32(5678)};
  WasmEdge_Value Returns[1];
  /* Function name. */
  WasmEdge_String FuncName = WasmEdge_StringCreateByCString(&quot;addTwo&quot;);
  /* Run the WASM function from file. */
  WasmEdge_Result Res = WasmEdge_VMRunWasmFromBuffer(
      VMCxt, WASM, sizeof(WASM), FuncName, Params, 2, Returns, 1);

  if (WasmEdge_ResultOK(Res)) {
    printf(&quot;Get the result: %d\n&quot;, WasmEdge_ValueGetI32(Returns[0]));
  } else {
    printf(&quot;Error message: %s\n&quot;, WasmEdge_ResultGetMessage(Res));
  }
  printf(&quot;Data value: %d\n&quot;, Data);

  /* Resources deallocations. */
  WasmEdge_VMDelete(VMCxt);
  WasmEdge_StringDelete(FuncName);
  WasmEdge_ModuleInstanceDelete(HostModCxt);
  return 0;
}
</code></pre>
<p>Then you can compile and run: (the result of 1234 + 5678 is 6912)</p>
<pre><code class="language-bash">$ gcc test.c -lwasmedge
$ ./a.out
Host function &quot;Add&quot;: 1234 + 5678
Get the result: 6912
Data value: 6912
</code></pre>
</li>
</ol>
<h2 id="wasmedge-aot-compiler"><a class="header" href="#wasmedge-aot-compiler">WasmEdge AOT Compiler</a></h2>
<p>In this partition, we will introduce the WasmEdge AOT compiler and the options.</p>
<p>WasmEdge runs the WASM files in interpreter mode, and WasmEdge also supports the AOT (ahead-of-time) mode running without modifying any code.
The WasmEdge AOT (ahead-of-time) compiler compiles the WASM files for running in AOT mode which is much faster than interpreter mode. Developers can compile the WASM files into the compiled-WASM files in shared library format for universal WASM format for the AOT mode execution.</p>
<h3 id="compilation-example"><a class="header" href="#compilation-example">Compilation Example</a></h3>
<p>Assume that the WASM file <a href="https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/examples/wasm/fibonacci.wasm"><code>fibonacci.wasm</code></a> is copied into the current directory, and the C file <code>test.c</code> is as following:</p>
<pre><code class="language-c">#include &lt;wasmedge/wasmedge.h&gt;
#include &lt;stdio.h&gt;
int main() {
  /* Create the configure context. */
  WasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();
  /* ... Adjust settings in the configure context. */
  /* Result. */
  WasmEdge_Result Res;

  /* Create the compiler context. The configure context can be NULL. */
  WasmEdge_CompilerContext *CompilerCxt = WasmEdge_CompilerCreate(ConfCxt);
  /* Compile the WASM file with input and output paths. */
  Res = WasmEdge_CompilerCompile(CompilerCxt, &quot;fibonacci.wasm&quot;,
                                 &quot;fibonacci-aot.wasm&quot;);
  if (!WasmEdge_ResultOK(Res)) {
    printf(&quot;Compilation failed: %s\n&quot;, WasmEdge_ResultGetMessage(Res));
    return 1;
  }

  WasmEdge_CompilerDelete(CompilerCxt);
  WasmEdge_ConfigureDelete(ConfCxt);
  return 0;
}
</code></pre>
<p>Then you can compile and run (the output file is &quot;fibonacci-aot.wasm&quot;):</p>
<pre><code class="language-bash">$ gcc test.c -lwasmedge
$ ./a.out
[2021-07-02 11:08:08.651] [info] compile start
[2021-07-02 11:08:08.653] [info] verify start
[2021-07-02 11:08:08.653] [info] optimize start
[2021-07-02 11:08:08.670] [info] codegen start
[2021-07-02 11:08:08.706] [info] compile done
</code></pre>
<h3 id="compiler-options"><a class="header" href="#compiler-options">Compiler Options</a></h3>
<p>Developers can set options for AOT compilers such as optimization level and output format:</p>
<pre><code class="language-c">/// AOT compiler optimization level enumeration.
enum WasmEdge_CompilerOptimizationLevel {
  /// Disable as many optimizations as possible.
  WasmEdge_CompilerOptimizationLevel_O0 = 0,
  /// Optimize quickly without destroying debuggability.
  WasmEdge_CompilerOptimizationLevel_O1,
  /// Optimize for fast execution as much as possible without triggering
  /// significant incremental compile time or code size growth.
  WasmEdge_CompilerOptimizationLevel_O2,
  /// Optimize for fast execution as much as possible.
  WasmEdge_CompilerOptimizationLevel_O3,
  /// Optimize for small code size as much as possible without triggering
  /// significant incremental compile time or execution time slowdowns.
  WasmEdge_CompilerOptimizationLevel_Os,
  /// Optimize for small code size as much as possible.
  WasmEdge_CompilerOptimizationLevel_Oz
};

/// AOT compiler output binary format enumeration.
enum WasmEdge_CompilerOutputFormat {
  /// Native dynamic library format.
  WasmEdge_CompilerOutputFormat_Native = 0,
  /// WebAssembly with AOT compiled codes in custom sections.
  WasmEdge_CompilerOutputFormat_Wasm
};
</code></pre>
<p>Please refer to the <a href="sdk/c/ref.html#configurations">AOT compiler options configuration</a> for details.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="wasmedge-0101-c-api-documentation"><a class="header" href="#wasmedge-0101-c-api-documentation">WasmEdge 0.10.1 C API Documentation</a></h1>
<p><a href="https://github.com/WasmEdge/WasmEdge/blob/0.10.1/include/api/wasmedge/wasmedge.h">WasmEdge C API</a> denotes an interface to access the WasmEdge runtime at version <code>0.10.1</code>. The followings are the guides to working with the C APIs of WasmEdge.</p>
<p><strong>Developers can refer to <a href="sdk/c/0.10.1/upgrade_to_0.11.0.html">here to upgrade to 0.11.0</a>.</strong></p>
<h2 id="table-of-contents-2"><a class="header" href="#table-of-contents-2">Table of Contents</a></h2>
<ul>
<li><a href="sdk/c/0.10.1/ref.html#wasmedge-installation">WasmEdge Installation</a>
<ul>
<li><a href="sdk/c/0.10.1/ref.html#download-and-install">Download And Install</a></li>
<li><a href="sdk/c/0.10.1/ref.html#compile-sources">Compile Sources</a></li>
</ul>
</li>
<li><a href="sdk/c/0.10.1/ref.html#wasmedge-basics">WasmEdge Basics</a>
<ul>
<li><a href="sdk/c/0.10.1/ref.html#version">Version</a></li>
<li><a href="sdk/c/0.10.1/ref.html#logging-settings">Logging Settings</a></li>
<li><a href="sdk/c/0.10.1/ref.html#value-types">Value Types</a></li>
<li><a href="sdk/c/0.10.1/ref.html#strings">Strings</a></li>
<li><a href="sdk/c/0.10.1/ref.html#results">Results</a></li>
<li><a href="sdk/c/0.10.1/ref.html#contexts">Contexts</a></li>
<li><a href="sdk/c/0.10.1/ref.html#wasm-data-structures">WASM data structures</a></li>
<li><a href="sdk/c/0.10.1/ref.html#async">Async</a></li>
<li><a href="sdk/c/0.10.1/ref.html#configurations">Configurations</a></li>
<li><a href="sdk/c/0.10.1/ref.html#statistics">Statistics</a></li>
<li><a href="sdk/c/0.10.1/ref.html#tools-driver">Tools driver</a></li>
</ul>
</li>
<li><a href="sdk/c/0.10.1/ref.html#wasmedge-vm">WasmEdge VM</a>
<ul>
<li><a href="sdk/c/0.10.1/ref.html#wasm-execution-example-with-vm-context">WASM Execution Example With VM Context</a></li>
<li><a href="sdk/c/0.10.1/ref.html#vm-creations">VM Creations</a></li>
<li><a href="sdk/c/0.10.1/ref.html#preregistrations">Preregistrations</a></li>
<li><a href="sdk/c/0.10.1/ref.html#host-module-registrations">Host Module Registrations</a></li>
<li><a href="sdk/c/0.10.1/ref.html#wasm-registrations-and-executions">WASM Registrations And Executions</a></li>
<li><a href="sdk/c/0.10.1/ref.html#asynchronous-execution">Asynchronous execution</a></li>
<li><a href="sdk/c/0.10.1/ref.html#instance-tracing">Instance Tracing</a></li>
</ul>
</li>
<li><a href="sdk/c/0.10.1/ref.html#wasmedge-runtime">WasmEdge Runtime</a>
<ul>
<li><a href="sdk/c/0.10.1/ref.html#wasm-execution-example-step-by-step">WASM Execution Example Step-By-Step</a></li>
<li><a href="sdk/c/0.10.1/ref.html#loader">Loader</a></li>
<li><a href="sdk/c/0.10.1/ref.html#validator">Validator</a></li>
<li><a href="sdk/c/0.10.1/ref.html#executor">Executor</a></li>
<li><a href="sdk/c/0.10.1/ref.html#ast-module">AST Module</a></li>
<li><a href="sdk/c/0.10.1/ref.html#store">Store</a></li>
<li><a href="sdk/c/0.10.1/ref.html#instances">Instances</a></li>
<li><a href="sdk/c/0.10.1/ref.html#host-functions">Host Functions</a></li>
</ul>
</li>
<li><a href="sdk/c/0.10.1/ref.html#wasmedge-aot-compiler">WasmEdge AOT Compiler</a>
<ul>
<li><a href="sdk/c/0.10.1/ref.html#compilation-example">Compilation Example</a></li>
<li><a href="sdk/c/0.10.1/ref.html#compiler-options">Compiler Options</a></li>
</ul>
</li>
</ul>
<h2 id="wasmedge-installation-1"><a class="header" href="#wasmedge-installation-1">WasmEdge Installation</a></h2>
<h3 id="download-and-install-1"><a class="header" href="#download-and-install-1">Download And Install</a></h3>
<p>The easiest way to install WasmEdge is to run the following command. Your system should have <code>git</code> and <code>wget</code> as prerequisites.</p>
<pre><code class="language-bash">curl -sSf https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/utils/install.sh | bash -s -- -v 0.10.1
</code></pre>
<p>For more details, please refer to the <a href="sdk/c/0.10.1/../../../quick_start/install.html">Installation Guide</a> for the WasmEdge installation.</p>
<h3 id="compile-sources-1"><a class="header" href="#compile-sources-1">Compile Sources</a></h3>
<p>After the installation of WasmEdge, the following guide can help you to test for the availability of the WasmEdge C API.</p>
<ol>
<li>
<p>Prepare the test C file (and assumed saved as <code>test.c</code>):</p>
<pre><code class="language-c">#include &lt;wasmedge/wasmedge.h&gt;
#include &lt;stdio.h&gt;
int main() {
  printf(&quot;WasmEdge version: %s\n&quot;, WasmEdge_VersionGet());
  return 0;
}
</code></pre>
</li>
<li>
<p>Compile the file with <code>gcc</code> or <code>clang</code>.</p>
<pre><code class="language-bash">gcc test.c -lwasmedge_c
</code></pre>
</li>
<li>
<p>Run and get the expected output.</p>
<pre><code class="language-bash">$ ./a.out
WasmEdge version: 0.10.1
</code></pre>
</li>
</ol>
<h2 id="wasmedge-basics-1"><a class="header" href="#wasmedge-basics-1">WasmEdge Basics</a></h2>
<p>In this part, we will introduce the utilities and concepts of WasmEdge shared library.</p>
<h3 id="version-1"><a class="header" href="#version-1">Version</a></h3>
<p>The <code>Version</code> related APIs provide developers to check for the WasmEdge shared library version.</p>
<pre><code class="language-c">#include &lt;wasmedge/wasmedge.h&gt;
printf(&quot;WasmEdge version: %s\n&quot;, WasmEdge_VersionGet());
printf(&quot;WasmEdge version major: %u\n&quot;, WasmEdge_VersionGetMajor());
printf(&quot;WasmEdge version minor: %u\n&quot;, WasmEdge_VersionGetMinor());
printf(&quot;WasmEdge version patch: %u\n&quot;, WasmEdge_VersionGetPatch());
</code></pre>
<h3 id="logging-settings-1"><a class="header" href="#logging-settings-1">Logging Settings</a></h3>
<p>The <code>WasmEdge_LogSetErrorLevel()</code> and <code>WasmEdge_LogSetDebugLevel()</code> APIs can set the logging system to debug level or error level. By default, the error level is set, and the debug info is hidden.</p>
<h3 id="value-types-1"><a class="header" href="#value-types-1">Value Types</a></h3>
<p>In WasmEdge, developers should convert the values to <code>WasmEdge_Value</code> objects through APIs for matching to the WASM value types.</p>
<ol>
<li>
<p>Number types: <code>i32</code>, <code>i64</code>, <code>f32</code>, <code>f64</code>, and <code>v128</code> for the <code>SIMD</code> proposal</p>
<pre><code class="language-c">WasmEdge_Value Val;
Val = WasmEdge_ValueGenI32(123456);
printf(&quot;%d\n&quot;, WasmEdge_ValueGetI32(Val));
/* Will print &quot;123456&quot; */
Val = WasmEdge_ValueGenI64(1234567890123LL);
printf(&quot;%ld\n&quot;, WasmEdge_ValueGetI64(Val));
/* Will print &quot;1234567890123&quot; */
Val = WasmEdge_ValueGenF32(123.456f);
printf(&quot;%f\n&quot;, WasmEdge_ValueGetF32(Val));
/* Will print &quot;123.456001&quot; */
Val = WasmEdge_ValueGenF64(123456.123456789);
printf(&quot;%.10f\n&quot;, WasmEdge_ValueGetF64(Val));
/* Will print &quot;123456.1234567890&quot; */
</code></pre>
</li>
<li>
<p>Reference types: <code>funcref</code> and <code>externref</code> for the <code>Reference-Types</code> proposal</p>
<pre><code class="language-c">WasmEdge_Value Val;
void *Ptr;
bool IsNull;
uint32_t Num = 10;
/* Genreate a externref to NULL. */
Val = WasmEdge_ValueGenNullRef(WasmEdge_RefType_ExternRef);
IsNull = WasmEdge_ValueIsNullRef(Val);
/* The `IsNull` will be `TRUE`. */
Ptr = WasmEdge_ValueGetExternRef(Val);
/* The `Ptr` will be `NULL`. */

/* Get the function instance by creation or from module instance. */
const WasmEdge_FunctionInstanceContext *FuncCxt = ...;
/* Genreate a funcref with the given function instance context. */
Val = WasmEdge_ValueGenFuncRef(FuncCxt);
const WasmEdge_FunctionInstanceContext *GotFuncCxt = WasmEdge_ValueGetFuncRef(Val);
/* The `GotFuncCxt` will be the same as `FuncCxt`. */

/* Genreate a externref to `Num`. */
Val = WasmEdge_ValueGenExternRef(&amp;Num);
Ptr = WasmEdge_ValueGetExternRef(Val);
/* The `Ptr` will be `&amp;Num`. */
printf(&quot;%u\n&quot;, *(uint32_t *)Ptr);
/* Will print &quot;10&quot; */
Num += 55;
printf(&quot;%u\n&quot;, *(uint32_t *)Ptr);
/* Will print &quot;65&quot; */
</code></pre>
</li>
</ol>
<h3 id="strings-1"><a class="header" href="#strings-1">Strings</a></h3>
<p>The <code>WasmEdge_String</code> object is for the instance names when invoking a WASM function or finding the contexts of instances.</p>
<ol>
<li>
<p>Create a <code>WasmEdge_String</code> from a C string (<code>const char *</code> with NULL termination) or a buffer with length.</p>
<p>The content of the C string or buffer will be copied into the <code>WasmEdge_String</code> object.</p>
<pre><code class="language-c">char Buf[4] = {50, 55, 60, 65};
WasmEdge_String Str1 = WasmEdge_StringCreateByCString(&quot;test&quot;);
WasmEdge_String Str2 = WasmEdge_StringCreateByBuffer(Buf, 4);
/* The objects should be deleted by `WasmEdge_StringDelete()`. */
WasmEdge_StringDelete(Str1);
WasmEdge_StringDelete(Str2);
</code></pre>
</li>
<li>
<p>Wrap a <code>WasmEdge_String</code> to a buffer with length.</p>
<p>The content will not be copied, and the caller should guarantee the life cycle of the input buffer.</p>
<pre><code class="language-c">const char CStr[] = &quot;test&quot;;
WasmEdge_String Str = WasmEdge_StringWrap(CStr, 4);
/* The object should __NOT__ be deleted by `WasmEdge_StringDelete()`. */
</code></pre>
</li>
<li>
<p>String comparison</p>
<pre><code class="language-c">const char CStr[] = &quot;abcd&quot;;
char Buf[4] = {0x61, 0x62, 0x63, 0x64};
WasmEdge_String Str1 = WasmEdge_StringWrap(CStr, 4);
WasmEdge_String Str2 = WasmEdge_StringCreateByBuffer(Buf, 4);
bool IsEq = WasmEdge_StringIsEqual(Str1, Str2);
/* The `IsEq` will be `TRUE`. */
WasmEdge_StringDelete(Str2);
</code></pre>
</li>
<li>
<p>Convert to C string</p>
<pre><code class="language-c">char Buf[256];
WasmEdge_String Str = WasmEdge_StringCreateByCString(&quot;test_wasmedge_string&quot;);
uint32_t StrLength = WasmEdge_StringCopy(Str, Buf, sizeof(Buf));
/* StrLength will be 20 */
printf(&quot;String: %s\n&quot;, Buf);
/* Will print &quot;test_wasmedge_string&quot;. */
</code></pre>
</li>
</ol>
<h3 id="results-1"><a class="header" href="#results-1">Results</a></h3>
<p>The <code>WasmEdge_Result</code> object specifies the execution status.
APIs about WASM execution will return the <code>WasmEdge_Result</code> to denote the status.</p>
<pre><code class="language-c">WasmEdge_Result Res = WasmEdge_Result_Success;
bool IsSucceeded = WasmEdge_ResultOK(Res);
/* The `IsSucceeded` will be `TRUE`. */
uint32_t Code = WasmEdge_ResultGetCode(Res);
/* The `Code` will be 0. */
const char *Msg = WasmEdge_ResultGetMessage(Res);
/* The `Msg` will be &quot;success&quot;. */
</code></pre>
<h3 id="contexts-1"><a class="header" href="#contexts-1">Contexts</a></h3>
<p>The objects, such as <code>VM</code>, <code>Store</code>, and <code>Function</code>, are composed of <code>Context</code>s.
All of the contexts can be created by calling the corresponding creation APIs and should be destroyed by calling the corresponding deletion APIs. Developers have responsibilities to manage the contexts for memory management.</p>
<pre><code class="language-c">/* Create the configure context. */
WasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();
/* Delete the configure context. */
WasmEdge_ConfigureDelete(ConfCxt);
</code></pre>
<p>The details of other contexts will be introduced later.</p>
<h3 id="wasm-data-structures-1"><a class="header" href="#wasm-data-structures-1">WASM Data Structures</a></h3>
<p>The WASM data structures are used for creating instances or can be queried from instance contexts.
The details of instances creation will be introduced in the <a href="sdk/c/0.10.1/ref.html#instances">Instances</a>.</p>
<ol>
<li>
<p>Limit</p>
<p>The <code>WasmEdge_Limit</code> struct is defined in the header:</p>
<pre><code class="language-c">/// Struct of WASM limit.
typedef struct WasmEdge_Limit {
  /// Boolean to describe has max value or not.
  bool HasMax;
  /// Boolean to describe is shared memory or not.
  bool Shared;
  /// Minimum value.
  uint32_t Min;
  /// Maximum value. Will be ignored if the `HasMax` is false.
  uint32_t Max;
} WasmEdge_Limit;
</code></pre>
<p>Developers can initialize the struct by assigning it's value, and the <code>Max</code> value is needed to be larger or equal to the <code>Min</code> value.
The API <code>WasmEdge_LimitIsEqual()</code> is provided to compare with 2 <code>WasmEdge_Limit</code> structs.</p>
</li>
<li>
<p>Function type context</p>
<p>The <code>Function Type</code> context is used for the <code>Function</code> creation, checking the value types of a <code>Function</code> instance, or getting the function type with function name from VM. Developers can use the <code>Function Type</code> context APIs to get the parameter or return value types information.</p>
<pre><code class="language-c">enum WasmEdge_ValType ParamList[2] = { WasmEdge_ValType_I32, WasmEdge_ValType_I64 };
enum WasmEdge_ValType ReturnList[1] = { WasmEdge_ValType_FuncRef };
WasmEdge_FunctionTypeContext *FuncTypeCxt = WasmEdge_FunctionTypeCreate(ParamList, 2, ReturnList, 1);

enum WasmEdge_ValType Buf[16];
uint32_t ParamLen = WasmEdge_FunctionTypeGetParametersLength(FuncTypeCxt);
/* `ParamLen` will be 2. */
uint32_t GotParamLen = WasmEdge_FunctionTypeGetParameters(FuncTypeCxt, Buf, 16);
/* `GotParamLen` will be 2, and `Buf[0]` and `Buf[1]` will be the same as `ParamList`. */
uint32_t ReturnLen = WasmEdge_FunctionTypeGetReturnsLength(FuncTypeCxt);
/* `ReturnLen` will be 1. */
uint32_t GotReturnLen = WasmEdge_FunctionTypeGetReturns(FuncTypeCxt, Buf, 16);
/* `GotReturnLen` will be 1, and `Buf[0]` will be the same as `ReturnList`. */

WasmEdge_FunctionTypeDelete(FuncTypeCxt);
</code></pre>
</li>
<li>
<p>Table type context</p>
<p>The <code>Table Type</code> context is used for <code>Table</code> instance creation or getting information from <code>Table</code> instances.</p>
<pre><code class="language-c">WasmEdge_Limit TabLim = {.HasMax = true, .Shared = false, .Min = 10, .Max = 20};
WasmEdge_TableTypeContext *TabTypeCxt = WasmEdge_TableTypeCreate(WasmEdge_RefType_ExternRef, TabLim);

enum WasmEdge_RefType GotRefType = WasmEdge_TableTypeGetRefType(TabTypeCxt);
/* `GotRefType` will be WasmEdge_RefType_ExternRef. */
WasmEdge_Limit GotTabLim = WasmEdge_TableTypeGetLimit(TabTypeCxt);
/* `GotTabLim` will be the same value as `TabLim`. */

WasmEdge_TableTypeDelete(TabTypeCxt);
</code></pre>
</li>
<li>
<p>Memory type context</p>
<p>The <code>Memory Type</code> context is used for <code>Memory</code> instance creation or getting information from <code>Memory</code> instances.</p>
<pre><code class="language-c">WasmEdge_Limit MemLim = {.HasMax = true, .Shared = false, .Min = 10, .Max = 20};
WasmEdge_MemoryTypeContext *MemTypeCxt = WasmEdge_MemoryTypeCreate(MemLim);

WasmEdge_Limit GotMemLim = WasmEdge_MemoryTypeGetLimit(MemTypeCxt);
/* `GotMemLim` will be the same value as `MemLim`. */

WasmEdge_MemoryTypeDelete(MemTypeCxt)
</code></pre>
</li>
<li>
<p>Global type context</p>
<p>The <code>Global Type</code> context is used for <code>Global</code> instance creation or getting information from <code>Global</code> instances.</p>
<pre><code class="language-c">WasmEdge_GlobalTypeContext *GlobTypeCxt = WasmEdge_GlobalTypeCreate(WasmEdge_ValType_F64, WasmEdge_Mutability_Var);

WasmEdge_ValType GotValType = WasmEdge_GlobalTypeGetValType(GlobTypeCxt);
/* `GotValType` will be WasmEdge_ValType_F64. */
WasmEdge_Mutability GotValMut = WasmEdge_GlobalTypeGetMutability(GlobTypeCxt);
/* `GotValMut` will be WasmEdge_Mutability_Var. */

WasmEdge_GlobalTypeDelete(GlobTypeCxt);
</code></pre>
</li>
<li>
<p>Import type context</p>
<p>The <code>Import Type</code> context is used for getting the imports information from a <a href="sdk/c/0.10.1/ref.html#ast-module">AST Module</a>.
Developers can get the external type (<code>function</code>, <code>table</code>, <code>memory</code>, or <code>global</code>), import module name, and external name from an <code>Import Type</code> context.
The details about querying <code>Import Type</code> contexts will be introduced in the <a href="sdk/c/0.10.1/ref.html#ast-module">AST Module</a>.</p>
<pre><code class="language-c">WasmEdge_ASTModuleContext *ASTCxt = ...;
/* Assume that `ASTCxt` is returned by the `WasmEdge_LoaderContext` for the result of loading a WASM file. */
const WasmEdge_ImportTypeContext *ImpType = ...;
/* Assume that `ImpType` is queried from the `ASTCxt` for the import. */

enum WasmEdge_ExternalType ExtType = WasmEdge_ImportTypeGetExternalType(ImpType);
/*
 * The `ExtType` can be one of `WasmEdge_ExternalType_Function`, `WasmEdge_ExternalType_Table`,
 * `WasmEdge_ExternalType_Memory`, or `WasmEdge_ExternalType_Global`.
 */
WasmEdge_String ModName = WasmEdge_ImportTypeGetModuleName(ImpType);
WasmEdge_String ExtName = WasmEdge_ImportTypeGetExternalName(ImpType);
/* The `ModName` and `ExtName` should not be destroyed and the string buffers are binded into the `ASTCxt`. */
const WasmEdge_FunctionTypeContext *FuncTypeCxt = WasmEdge_ImportTypeGetFunctionType(ASTCxt, ImpType);
/* If the `ExtType` is not `WasmEdge_ExternalType_Function`, the `FuncTypeCxt` will be NULL. */
const WasmEdge_TableTypeContext *TabTypeCxt = WasmEdge_ImportTypeGetTableType(ASTCxt, ImpType);
/* If the `ExtType` is not `WasmEdge_ExternalType_Table`, the `TabTypeCxt` will be NULL. */
const WasmEdge_MemoryTypeContext *MemTypeCxt = WasmEdge_ImportTypeGetMemoryType(ASTCxt, ImpType);
/* If the `ExtType` is not `WasmEdge_ExternalType_Memory`, the `MemTypeCxt` will be NULL. */
const WasmEdge_GlobalTypeContext *GlobTypeCxt = WasmEdge_ImportTypeGetGlobalType(ASTCxt, ImpType);
/* If the `ExtType` is not `WasmEdge_ExternalType_Global`, the `GlobTypeCxt` will be NULL. */
</code></pre>
</li>
<li>
<p>Export type context</p>
<p>The <code>Export Type</code> context is used for getting the exports information from a <a href="sdk/c/0.10.1/ref.html#ast-module">AST Module</a>.
Developers can get the external type (<code>function</code>, <code>table</code>, <code>memory</code>, or <code>global</code>) and external name from an <code>Export Type</code> context.
The details about querying <code>Export Type</code> contexts will be introduced in the <a href="sdk/c/0.10.1/ref.html#ast-module">AST Module</a>.</p>
<pre><code class="language-c">WasmEdge_ASTModuleContext *ASTCxt = ...;
/* Assume that `ASTCxt` is returned by the `WasmEdge_LoaderContext` for the result of loading a WASM file. */
const WasmEdge_ExportTypeContext *ExpType = ...;
/* Assume that `ExpType` is queried from the `ASTCxt` for the export. */

enum WasmEdge_ExternalType ExtType = WasmEdge_ExportTypeGetExternalType(ExpType);
/*
 * The `ExtType` can be one of `WasmEdge_ExternalType_Function`, `WasmEdge_ExternalType_Table`,
 * `WasmEdge_ExternalType_Memory`, or `WasmEdge_ExternalType_Global`.
 */
WasmEdge_String ExtName = WasmEdge_ExportTypeGetExternalName(ExpType);
/* The `ExtName` should not be destroyed and the string buffer is binded into the `ASTCxt`. */
const WasmEdge_FunctionTypeContext *FuncTypeCxt = WasmEdge_ExportTypeGetFunctionType(ASTCxt, ExpType);
/* If the `ExtType` is not `WasmEdge_ExternalType_Function`, the `FuncTypeCxt` will be NULL. */
const WasmEdge_TableTypeContext *TabTypeCxt = WasmEdge_ExportTypeGetTableType(ASTCxt, ExpType);
/* If the `ExtType` is not `WasmEdge_ExternalType_Table`, the `TabTypeCxt` will be NULL. */
const WasmEdge_MemoryTypeContext *MemTypeCxt = WasmEdge_ExportTypeGetMemoryType(ASTCxt, ExpType);
/* If the `ExtType` is not `WasmEdge_ExternalType_Memory`, the `MemTypeCxt` will be NULL. */
const WasmEdge_GlobalTypeContext *GlobTypeCxt = WasmEdge_ExportTypeGetGlobalType(ASTCxt, ExpType);
/* If the `ExtType` is not `WasmEdge_ExternalType_Global`, the `GlobTypeCxt` will be NULL. */
</code></pre>
</li>
</ol>
<h3 id="async-1"><a class="header" href="#async-1">Async</a></h3>
<p>After calling the <a href="sdk/c/0.10.1/ref.html#asynchronous-execution">asynchronous execution APIs</a>, developers will get the <code>WasmEdge_Async</code> object.
Developers own the object and should call the <code>WasmEdge_AsyncDelete()</code> API to destroy it.</p>
<ol>
<li>
<p>Wait for the asynchronous execution</p>
<p>Developers can wait the execution until finished:</p>
<pre><code class="language-c">WasmEdge_Async *Async = ...; /* Ignored. Asynchronous execute a function. */
/* Blocking and waiting for the execution. */
WasmEdge_AsyncWait(Async);
WasmEdge_AsyncDelete(Async);
</code></pre>
<p>Or developers can wait for a time limit.
If the time limit exceeded, developers can choose to cancel the execution.
For the interruptible execution in AOT mode, developers should set <code>TRUE</code> thourgh the <code>WasmEdge_ConfigureCompilerSetInterruptible()</code> API into the configure context for the AOT compiler.</p>
<pre><code class="language-c">WasmEdge_Async *Async = ...; /* Ignored. Asynchronous execute a function. */
/* Blocking and waiting for the execution for 1 second. */
bool IsEnd = WasmEdge_AsyncWaitFor(Async, 1000);
if (IsEnd) {
  /* The execution finished. Developers can get the result. */
  WasmEdge_Result Res = WasmEdge_AsyncGet(/* ... Ignored */);
} else {
  /* The time limit exceeded. Developers can keep waiting or cancel the execution. */
  WasmEdge_AsyncCancel(Async);
  WasmEdge_Result Res = WasmEdge_AsyncGet(Async, 0, NULL);
  /* The result error code will be `WasmEdge_ErrCode_Interrupted`. */
}
WasmEdge_AsyncDelete(Async);
</code></pre>
</li>
<li>
<p>Get the execution result of the asynchronous execution</p>
<p>Developers can use the <code>WasmEdge_AsyncGetReturnsLength()</code> API to get the return value list length.
This function will block and wait for the execution. If the execution has finished, this function will return the length immediately. If the execution failed, this function will return <code>0</code>.
This function can help the developers to create the buffer to get the return values. If developers have already known the buffer length, they can skip this function and use the <code>WasmEdge_AsyncGet()</code> API to get the result.</p>
<pre><code class="language-c">WasmEdge_Async *Async = ...; /* Ignored. Asynchronous execute a function. */
/* Blocking and waiting for the execution and get the return value list length. */
uint32_t Arity = WasmEdge_AsyncGetReturnsLength(Async);
WasmEdge_AsyncDelete(Async);
</code></pre>
<p>The <code>WasmEdge_AsyncGet()</code> API will block and wait for the execution. If the execution has finished, this function will fill the return values into the buffer and return the execution result immediately.</p>
<pre><code class="language-c">WasmEdge_Async *Async = ...; /* Ignored. Asynchronous execute a function. */
/* Blocking and waiting for the execution and get the return values. */
const uint32_t BUF_LEN = 256;
WasmEdge_Value Buf[BUF_LEN];
WasmEdge_Result Res = WasmEdge_AsyncGet(Async, Buf, BUF_LEN);
WasmEdge_AsyncDelete(Async);
</code></pre>
</li>
</ol>
<h3 id="configurations-1"><a class="header" href="#configurations-1">Configurations</a></h3>
<p>The configuration context, <code>WasmEdge_ConfigureContext</code>, manages the configurations for <code>Loader</code>, <code>Validator</code>, <code>Executor</code>, <code>VM</code>, and <code>Compiler</code>.
Developers can adjust the settings about the proposals, VM host pre-registrations (such as <code>WASI</code>), and AOT compiler options, and then apply the <code>Configure</code> context to create other runtime contexts.</p>
<ol>
<li>
<p>Proposals</p>
<p>WasmEdge supports turning on or off the WebAssembly proposals.
This configuration is effective in any contexts created with the <code>Configure</code> context.</p>
<pre><code class="language-c">enum WasmEdge_Proposal {
  WasmEdge_Proposal_ImportExportMutGlobals = 0,
  WasmEdge_Proposal_NonTrapFloatToIntConversions,
  WasmEdge_Proposal_SignExtensionOperators,
  WasmEdge_Proposal_MultiValue,
  WasmEdge_Proposal_BulkMemoryOperations,
  WasmEdge_Proposal_ReferenceTypes,
  WasmEdge_Proposal_SIMD,
  WasmEdge_Proposal_TailCall,
  WasmEdge_Proposal_MultiMemories,
  WasmEdge_Proposal_Annotations,
  WasmEdge_Proposal_Memory64,
  WasmEdge_Proposal_ExceptionHandling,
  WasmEdge_Proposal_ExtendedConst,
  WasmEdge_Proposal_Threads,
  WasmEdge_Proposal_FunctionReferences
};
</code></pre>
<p>Developers can add or remove the proposals into the <code>Configure</code> context.</p>
<pre><code class="language-c">/* 
 * By default, the following proposals have turned on initially:
 * * Import/Export of mutable globals
 * * Non-trapping float-to-int conversions
 * * Sign-extension operators
 * * Multi-value returns
 * * Bulk memory operations
 * * Reference types
 * * Fixed-width SIMD
 *
 * For the current WasmEdge version, the following proposals are supported
 * (turned of by default) additionally:
 * * Tail-call
 * * Multiple memories
 * * Extended-const
 * * Threads
 */
WasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();
WasmEdge_ConfigureAddProposal(ConfCxt, WasmEdge_Proposal_MultiMemories);
WasmEdge_ConfigureRemoveProposal(ConfCxt, WasmEdge_Proposal_ReferenceTypes);
bool IsBulkMem = WasmEdge_ConfigureHasProposal(ConfCxt, WasmEdge_Proposal_BulkMemoryOperations);
/* The `IsBulkMem` will be `TRUE`. */
WasmEdge_ConfigureDelete(ConfCxt);
</code></pre>
</li>
<li>
<p>Host registrations</p>
<p>This configuration is used for the <code>VM</code> context to turn on the <code>WASI</code> or <code>wasmedge_process</code> supports and only effective in <code>VM</code> contexts.</p>
<pre><code class="language-c">enum WasmEdge_HostRegistration {
  WasmEdge_HostRegistration_Wasi = 0,
  WasmEdge_HostRegistration_WasmEdge_Process
};
</code></pre>
<p>The details will be introduced in the <a href="sdk/c/0.10.1/ref.html#preregistrations">preregistrations of VM context</a>.</p>
<pre><code class="language-c">WasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();
bool IsHostWasi = WasmEdge_ConfigureHasHostRegistration(ConfCxt, WasmEdge_HostRegistration_Wasi);
/* The `IsHostWasi` will be `FALSE`. */
WasmEdge_ConfigureAddHostRegistration(ConfCxt, WasmEdge_HostRegistration_Wasi);
IsHostWasi = WasmEdge_ConfigureHasHostRegistration(ConfCxt, WasmEdge_HostRegistration_Wasi);
/* The `IsHostWasi` will be `TRUE`. */
WasmEdge_ConfigureDelete(ConfCxt);
</code></pre>
</li>
<li>
<p>Maximum memory pages</p>
<p>Developers can limit the page size of memory instances by this configuration.
When growing the page size of memory instances in WASM execution and exceeding the limited size, the page growing will fail.
This configuration is only effective in the <code>Executor</code> and <code>VM</code> contexts.</p>
<pre><code class="language-c">WasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();
uint32_t PageSize = WasmEdge_ConfigureGetMaxMemoryPage(ConfCxt);
/* By default, the maximum memory page size is 65536. */
WasmEdge_ConfigureSetMaxMemoryPage(ConfCxt, 1024);
/* Limit the memory size of each memory instance with not larger than 1024 pages (64 MiB). */
PageSize = WasmEdge_ConfigureGetMaxMemoryPage(ConfCxt);
/* The `PageSize` will be 1024. */
WasmEdge_ConfigureDelete(ConfCxt);
</code></pre>
</li>
<li>
<p>AOT compiler options</p>
<p>The AOT compiler options configure the behavior about optimization level, output format, dump IR, and generic binary.</p>
<pre><code class="language-c">enum WasmEdge_CompilerOptimizationLevel {
  // Disable as many optimizations as possible.
  WasmEdge_CompilerOptimizationLevel_O0 = 0,
  // Optimize quickly without destroying debuggability.
  WasmEdge_CompilerOptimizationLevel_O1,
  // Optimize for fast execution as much as possible without triggering
  // significant incremental compile time or code size growth.
  WasmEdge_CompilerOptimizationLevel_O2,
  // Optimize for fast execution as much as possible.
  WasmEdge_CompilerOptimizationLevel_O3,
  // Optimize for small code size as much as possible without triggering
  // significant incremental compile time or execution time slowdowns.
  WasmEdge_CompilerOptimizationLevel_Os,
  // Optimize for small code size as much as possible.
  WasmEdge_CompilerOptimizationLevel_Oz
};

enum WasmEdge_CompilerOutputFormat {
  // Native dynamic library format.
  WasmEdge_CompilerOutputFormat_Native = 0,
  // WebAssembly with AOT compiled codes in custom section.
  WasmEdge_CompilerOutputFormat_Wasm
};
</code></pre>
<p>These configurations are only effective in <code>Compiler</code> contexts.</p>
<pre><code class="language-c">WasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();
/* By default, the optimization level is O3. */
WasmEdge_ConfigureCompilerSetOptimizationLevel(ConfCxt, WasmEdge_CompilerOptimizationLevel_O2);
/* By default, the output format is universal WASM. */
WasmEdge_ConfigureCompilerSetOutputFormat(ConfCxt, WasmEdge_CompilerOutputFormat_Native);
/* By default, the dump IR is `FALSE`. */
WasmEdge_ConfigureCompilerSetDumpIR(ConfCxt, TRUE);
/* By default, the generic binary is `FALSE`. */
WasmEdge_ConfigureCompilerSetGenericBinary(ConfCxt, TRUE);
/* By default, the interruptible is `FALSE`.
/* Set this option to `TRUE` to support the interruptible execution in AOT mode. */
WasmEdge_ConfigureCompilerSetInterruptible(ConfCxt, TRUE);
WasmEdge_ConfigureDelete(ConfCxt);
</code></pre>
</li>
<li>
<p>Statistics options</p>
<p>The statistics options configure the behavior about instruction counting, cost measuring, and time measuring in both runtime and AOT compiler.
These configurations are effective in <code>Compiler</code>, <code>VM</code>, and <code>Executor</code> contexts.</p>
<pre><code class="language-c">WasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();
/* By default, the intruction counting is `FALSE` when running a compiled-WASM or a pure-WASM. */
WasmEdge_ConfigureStatisticsSetInstructionCounting(ConfCxt, TRUE);
/* By default, the cost measurement is `FALSE` when running a compiled-WASM or a pure-WASM. */
WasmEdge_ConfigureStatisticsSetCostMeasuring(ConfCxt, TRUE);
/* By default, the time measurement is `FALSE` when running a compiled-WASM or a pure-WASM. */
WasmEdge_ConfigureStatisticsSetTimeMeasuring(ConfCxt, TRUE);
WasmEdge_ConfigureDelete(ConfCxt);
</code></pre>
</li>
</ol>
<h3 id="statistics-1"><a class="header" href="#statistics-1">Statistics</a></h3>
<p>The statistics context, <code>WasmEdge_StatisticsContext</code>, provides the instruction counter, cost summation, and cost limitation at runtime.</p>
<p>Before using statistics, the statistics configuration must be set. Otherwise, the return values of calling statistics are undefined behaviour.</p>
<ol>
<li>
<p>Instruction counter</p>
<p>The instruction counter can help developers to profile the performance of WASM running.
Developers can retrieve the <code>Statistics</code> context from the <code>VM</code> context, or create a new one for the <code>Executor</code> creation.
The details will be introduced in the next partitions.</p>
<pre><code class="language-c">WasmEdge_StatisticsContext *StatCxt = WasmEdge_StatisticsCreate();
/*
 * ...
 * After running the WASM functions with the `Statistics` context
 */
uint32_t Count = WasmEdge_StatisticsGetInstrCount(StatCxt);
double IPS = WasmEdge_StatisticsGetInstrPerSecond(StatCxt);
WasmEdge_StatisticsDelete(StatCxt);
</code></pre>
</li>
<li>
<p>Cost table</p>
<p>The cost table is to accumulate the cost of instructions with their weights.
Developers can set the cost table array (the indices are the byte code value of instructions, and the values are the cost of instructions) into the <code>Statistics</code> context.
If the cost limit value is set, the execution will return the <code>cost limit exceeded</code> error immediately when exceeds the cost limit in runtime.</p>
<pre><code class="language-c">WasmEdge_StatisticsContext *StatCxt = WasmEdge_StatisticsCreate();
uint64_t CostTable[16] = {
  0, 0,
  10, /* 0x02: Block */
  11, /* 0x03: Loop */
  12, /* 0x04: If */
  12, /* 0x05: Else */
  0, 0, 0, 0, 0, 0, 
  20, /* 0x0C: Br */
  21, /* 0x0D: Br_if */
  22, /* 0x0E: Br_table */
  0
};
/* Developers can set the costs of each instruction. The value not covered will be 0. */
WasmEdge_StatisticsSetCostTable(StatCxt, CostTable, 16);
WasmEdge_StatisticsSetCostLimit(StatCxt, 5000000);
/*
 * ...
 * After running the WASM functions with the `Statistics` context
 */
uint64_t Cost = WasmEdge_StatisticsGetTotalCost(StatCxt);
WasmEdge_StatisticsDelete(StatCxt);
</code></pre>
</li>
</ol>
<h3 id="tools-driver-1"><a class="header" href="#tools-driver-1">Tools Driver</a></h3>
<p>Besides executing the <code>wasmedge</code> and <code>wasmedgec</code> CLI tools, developers can trigger the WasmEdge CLI tools by WasmEdge C API.
The API arguments are the same as the command line arguments of the CLI tools.</p>
<pre><code class="language-c">#include &lt;wasmedge/wasmedge.h&gt;
#include &lt;stdio.h&gt;
int main(int argc, const char *argv[]) {
  /* Run the WasmEdge AOT compiler. */
  return WasmEdge_Driver_Compiler(argc, argv);
}
</code></pre>
<pre><code class="language-c">#include &lt;wasmedge/wasmedge.h&gt;
#include &lt;stdio.h&gt;
int main(int argc, const char *argv[]) {
  /* Run the WasmEdge runtime tool. */
  return WasmEdge_Driver_Tool(argc, argv);
}
</code></pre>
<h2 id="wasmedge-vm-1"><a class="header" href="#wasmedge-vm-1">WasmEdge VM</a></h2>
<p>In this partition, we will introduce the functions of <code>WasmEdge_VMContext</code> object and show examples of executing WASM functions.</p>
<h3 id="wasm-execution-example-with-vm-context-1"><a class="header" href="#wasm-execution-example-with-vm-context-1">WASM Execution Example With VM Context</a></h3>
<p>The following shows the example of running the WASM for getting the Fibonacci.
This example uses the <a href="https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/examples/wasm/fibonacci.wasm">fibonacci.wasm</a>, and the corresponding WAT file is at <a href="https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/examples/wasm/fibonacci.wat">fibonacci.wat</a>.</p>
<pre><code class="language-wasm">(module
  (export &quot;fib&quot; (func $fib))
  (func $fib (param $n i32) (result i32)
    (if
      (i32.lt_s (get_local $n)(i32.const 2))
      (return (i32.const 1))
    )
    (return
      (i32.add
        (call $fib (i32.sub (get_local $n)(i32.const 2)))
        (call $fib (i32.sub (get_local $n)(i32.const 1)))
      )
    )
  )
)
</code></pre>
<ol>
<li>
<p>Run WASM functions rapidly</p>
<p>Assume that the WASM file <a href="https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/examples/wasm/fibonacci.wasm"><code>fibonacci.wasm</code></a> is copied into the current directory, and the C file <code>test.c</code> is as following:</p>
<pre><code class="language-c">#include &lt;wasmedge/wasmedge.h&gt;
#include &lt;stdio.h&gt;
int main() {
  /* Create the configure context and add the WASI support. */
  /* This step is not necessary unless you need WASI support. */
  WasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();
  WasmEdge_ConfigureAddHostRegistration(ConfCxt, WasmEdge_HostRegistration_Wasi);
  /* The configure and store context to the VM creation can be NULL. */
  WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(ConfCxt, NULL);

  /* The parameters and returns arrays. */
  WasmEdge_Value Params[1] = { WasmEdge_ValueGenI32(5) };
  WasmEdge_Value Returns[1];
  /* Function name. */
  WasmEdge_String FuncName = WasmEdge_StringCreateByCString(&quot;fib&quot;);
  /* Run the WASM function from file. */
  WasmEdge_Result Res = WasmEdge_VMRunWasmFromFile(VMCxt, &quot;fibonacci.wasm&quot;, FuncName, Params, 1, Returns, 1);
  /* 
   * Developers can run the WASM binary from buffer with the `WasmEdge_VMRunWasmFromBuffer()` API,
   * or from `WasmEdge_ASTModuleContext` object with the `WasmEdge_VMRunWasmFromASTModule()` API.
   */

  if (WasmEdge_ResultOK(Res)) {
    printf(&quot;Get the result: %d\n&quot;, WasmEdge_ValueGetI32(Returns[0]));
  } else {
    printf(&quot;Error message: %s\n&quot;, WasmEdge_ResultGetMessage(Res));
  }

  /* Resources deallocations. */
  WasmEdge_VMDelete(VMCxt);
  WasmEdge_ConfigureDelete(ConfCxt);
  WasmEdge_StringDelete(FuncName);
  return 0;
}
</code></pre>
<p>Then you can compile and run: (the 5th Fibonacci number is 8 in 0-based index)</p>
<pre><code class="language-bash">$ gcc test.c -lwasmedge_c
$ ./a.out
Get the result: 8
</code></pre>
</li>
<li>
<p>Instantiate and run WASM functions manually</p>
<p>Besides the above example, developers can run the WASM functions step-by-step with <code>VM</code> context APIs:</p>
<pre><code class="language-c">#include &lt;wasmedge/wasmedge.h&gt;
#include &lt;stdio.h&gt;
int main() {
  /* Create the configure context and add the WASI support. */
  /* This step is not necessary unless you need the WASI support. */
  WasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();
  WasmEdge_ConfigureAddHostRegistration(ConfCxt, WasmEdge_HostRegistration_Wasi);
  /* The configure and store context to the VM creation can be NULL. */
  WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(ConfCxt, NULL);

  /* The parameters and returns arrays. */
  WasmEdge_Value Params[1] = { WasmEdge_ValueGenI32(10) };
  WasmEdge_Value Returns[1];
  /* Function name. */
  WasmEdge_String FuncName = WasmEdge_StringCreateByCString(&quot;fib&quot;);
  /* Result. */
  WasmEdge_Result Res;
  
  /* Step 1: Load WASM file. */
  Res = WasmEdge_VMLoadWasmFromFile(VMCxt, &quot;fibonacci.wasm&quot;);
  /* 
   * Developers can load the WASM binary from buffer with the `WasmEdge_VMLoadWasmFromBuffer()` API,
   * or from `WasmEdge_ASTModuleContext` object with the `WasmEdge_VMLoadWasmFromASTModule()` API.
   */
  if (!WasmEdge_ResultOK(Res)) {
    printf(&quot;Loading phase failed: %s\n&quot;, WasmEdge_ResultGetMessage(Res));
    return 1;
  }
  /* Step 2: Validate the WASM module. */
  Res = WasmEdge_VMValidate(VMCxt);
  if (!WasmEdge_ResultOK(Res)) {
    printf(&quot;Validation phase failed: %s\n&quot;, WasmEdge_ResultGetMessage(Res));
    return 1;
  }
  /* Step 3: Instantiate the WASM module. */
  Res = WasmEdge_VMInstantiate(VMCxt);
  /* 
   * Developers can load, validate, and instantiate another WASM module to replace the
   * instantiated one. In this case, the old module will be cleared, but the registered
   * modules are still kept.
   */
  if (!WasmEdge_ResultOK(Res)) {
    printf(&quot;Instantiation phase failed: %s\n&quot;, WasmEdge_ResultGetMessage(Res));
    return 1;
  }
  /* Step 4: Execute WASM functions. You can execute functions repeatedly after instantiation. */
  Res = WasmEdge_VMExecute(VMCxt, FuncName, Params, 1, Returns, 1);
  if (WasmEdge_ResultOK(Res)) {
    printf(&quot;Get the result: %d\n&quot;, WasmEdge_ValueGetI32(Returns[0]));
  } else {
    printf(&quot;Execution phase failed: %s\n&quot;, WasmEdge_ResultGetMessage(Res));
  }

  /* Resources deallocations. */
  WasmEdge_VMDelete(VMCxt);
  WasmEdge_ConfigureDelete(ConfCxt);
  WasmEdge_StringDelete(FuncName);
  return 0;
}
</code></pre>
<p>Then you can compile and run: (the 10th Fibonacci number is 89 in 0-based index)</p>
<pre><code class="language-bash">$ gcc test.c -lwasmedge_c
$ ./a.out
Get the result: 89
</code></pre>
<p>The following graph explains the status of the <code>VM</code> context.</p>
<pre><code class="language-text">                       |========================|
              |-------&gt;|      VM: Initiated     |
              |        |========================|
              |                    |
              |                 LoadWasm
              |                    |
              |                    v
              |        |========================|
              |--------|       VM: Loaded       |&lt;-------|
              |        |========================|        |
              |              |            ^              |
              |         Validate          |              |
          Cleanup            |          LoadWasm         |
              |              v            |            LoadWasm
              |        |========================|        |
              |--------|      VM: Validated     |        |
              |        |========================|        |
              |              |            ^              |
              |      Instantiate          |              |
              |              |          RegisterModule   |
              |              v            |              |
              |        |========================|        |
              |--------|    VM: Instantiated    |--------|
                       |========================|
                             |            ^
                             |            |
                             --------------
                Instantiate, Execute, ExecuteRegistered
</code></pre>
<p>The status of the <code>VM</code> context would be <code>Inited</code> when created.
After loading WASM successfully, the status will be <code>Loaded</code>.
After validating WASM successfully, the status will be <code>Validated</code>.
After instantiating WASM successfully, the status will be <code>Instantiated</code>, and developers can invoke functions.
Developers can register WASM or module instances in any status, but they should instantiate WASM again.
Developers can also load WASM in any status, and they should validate and instantiate the WASM module before function invocation.
When in the <code>Instantiated</code> status, developers can instantiate the WASM module again to reset the old WASM runtime structures.</p>
</li>
</ol>
<h3 id="vm-creations-1"><a class="header" href="#vm-creations-1">VM Creations</a></h3>
<p>The <code>VM</code> creation API accepts the <code>Configure</code> context and the <code>Store</code> context.
If developers only need the default settings, just pass <code>NULL</code> to the creation API.
The details of the <code>Store</code> context will be introduced in <a href="sdk/c/0.10.1/ref.html#store">Store</a>.</p>
<pre><code class="language-c">WasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();
WasmEdge_StoreContext *StoreCxt = WasmEdge_StoreCreate();
WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(ConfCxt, StoreCxt);
/* The caller should guarantee the life cycle if the store context. */
WasmEdge_StatisticsContext *StatCxt = WasmEdge_VMGetStatisticsContext(VMCxt);
/* The VM context already contains the statistics context and can be retrieved by this API. */
/* 
 * Note that the retrieved store and statistics contexts from the VM contexts by VM APIs
 * should __NOT__ be destroyed and owned by the VM contexts.
 */
WasmEdge_VMDelete(VMCxt);
WasmEdge_StoreDelete(StoreCxt);
WasmEdge_ConfigureDelete(ConfCxt);
</code></pre>
<h3 id="preregistrations-1"><a class="header" href="#preregistrations-1">Preregistrations</a></h3>
<p>WasmEdge provides the following built-in pre-registrations.</p>
<ol>
<li>
<p><a href="https://github.com/WebAssembly/WASI">WASI (WebAssembly System Interface)</a></p>
<p>Developers can turn on the WASI support for VM in the <code>Configure</code> context.</p>
<pre><code class="language-c">WasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();
WasmEdge_ConfigureAddHostRegistration(ConfCxt, WasmEdge_HostRegistration_Wasi);
WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(ConfCxt, NULL);
/* The following API can retrieve the pre-registration module instances from the VM context. */
/* This API will return `NULL` if the corresponding pre-registration is not set into the configuration. */
WasmEdge_ModuleInstanceContext *WasiModule =
  WasmEdge_VMGetImportModuleContext(VMCxt, WasmEdge_HostRegistration_Wasi);
/* Initialize the WASI. */
WasmEdge_ModuleInstanceInitWASI(WasiModule, /* ... ignored */ );
WasmEdge_VMDelete(VMCxt);
WasmEdge_ConfigureDelete(ConfCxt);
</code></pre>
<p>And also can create the WASI module instance from API. The details will be introduced in the <a href="sdk/c/0.10.1/ref.html#host-functions">Host Functions</a> and the <a href="sdk/c/0.10.1/ref.html#host-module-registrations">Host Module Registrations</a>.</p>
</li>
<li>
<p><a href="https://crates.io/crates/wasmedge_process_interface">WasmEdge_Process</a></p>
<p>This pre-registration is for the process interface for WasmEdge on <code>Rust</code> sources.
After turning on this pre-registration, the VM will support the <code>wasmedge_process</code> plugin.</p>
<pre><code class="language-c">WasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();
WasmEdge_ConfigureAddHostRegistration(ConfCxt, WasmEdge_HostRegistration_WasmEdge_Process);
WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(ConfCxt, NULL);
/* The following API can retrieve the pre-registration module instances from the VM context. */
/* This API will return `NULL` if the corresponding pre-registration is not set into the configuration or the plugin load failed. */
WasmEdge_ModuleInstanceContext *ProcModule =
  WasmEdge_VMGetImportModuleContext(VMCxt, WasmEdge_HostRegistration_WasmEdge_Process);
/* Initialize the WasmEdge_Process. */
WasmEdge_ModuleInstanceInitWasmEdgeProcess(ProcModule, /* ... ignored */ );
WasmEdge_VMDelete(VMCxt);
WasmEdge_ConfigureDelete(ConfCxt);
</code></pre>
<p>And also can create the WasmEdge_Process module instance from API. The details will be introduced in the <a href="sdk/c/0.10.1/ref.html#host-functions">Host Functions</a> and the <a href="sdk/c/0.10.1/ref.html#host-module-registrations">Host Module Registrations</a>.</p>
</li>
<li>
<p><a href="https://github.com/WebAssembly/wasi-nn">WASI-NN proposal</a> (<code>0.10.1</code> or upper only)</p>
<p>Developers can turn on the WASI-NN proposal support for VM in the <code>Configure</code> context.</p>
<blockquote>
<p>Note: Please check that the <a href="sdk/c/0.10.1/../../../write_wasm/rust/wasinn.html">dependencies and prerequests</a> are satisfied.</p>
</blockquote>
<pre><code class="language-c">WasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();
WasmEdge_ConfigureAddHostRegistration(ConfCxt, WasmEdge_HostRegistration_WasiNN);
WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(ConfCxt, NULL);
/* The following API can retrieve the pre-registration module instances from the VM context. */
/* This API will return `NULL` if the corresponding pre-registration is not set into the configuration or the plugin load failed. */
WasmEdge_ModuleInstanceContext *NNModule =
  WasmEdge_VMGetImportModuleContext(VMCxt, WasmEdge_HostRegistration_WasiNN);
WasmEdge_VMDelete(VMCxt);
WasmEdge_ConfigureDelete(ConfCxt);
</code></pre>
<p>And also can create the WASI-NN module instance from API. The details will be introduced in the <a href="sdk/c/0.10.1/ref.html#host-functions">Host Functions</a> and the <a href="sdk/c/0.10.1/ref.html#host-module-registrations">Host Module Registrations</a>.</p>
</li>
<li>
<p><a href="https://github.com/WebAssembly/wasi-crypto">WASI-Crypto proposal</a> (<code>0.10.1</code> or upper only)</p>
<p>Developers can turn on the WASI-Crypto proposal support for VM in the <code>Configure</code> context.</p>
<blockquote>
<p>Note: Please check that the <a href="sdk/c/0.10.1/../../../write_wasm/rust/wasicrypto.html">dependencies and prerequests</a> are satisfied.</p>
</blockquote>
<pre><code class="language-c">WasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();
/* The WASI-Crypto related configures are suggested to turn on togeter. */
WasmEdge_ConfigureAddHostRegistration(ConfCxt, WasmEdge_HostRegistration_WasiCrypto_Common);
WasmEdge_ConfigureAddHostRegistration(ConfCxt, WasmEdge_HostRegistration_WasiCrypto_AsymmetricCommon);
WasmEdge_ConfigureAddHostRegistration(ConfCxt, WasmEdge_HostRegistration_WasiCrypto_Kx);
WasmEdge_ConfigureAddHostRegistration(ConfCxt, WasmEdge_HostRegistration_WasiCrypto_Signatures);
WasmEdge_ConfigureAddHostRegistration(ConfCxt, WasmEdge_HostRegistration_WasiCrypto_Symmetric);
WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(ConfCxt, NULL);
/* The following API can retrieve the pre-registration module instances from the VM context. */
/* This API will return `NULL` if the corresponding pre-registration is not set into the configuration or the plugin load failed. */
WasmEdge_ModuleInstanceContext *CryptoCommonModule =
  WasmEdge_VMGetImportModuleContext(VMCxt, WasmEdge_HostRegistration_WasiCrypto_Common);
WasmEdge_VMDelete(VMCxt);
WasmEdge_ConfigureDelete(ConfCxt);
</code></pre>
<p>And also can create the WASI-Crypto module instance from API. The details will be introduced in the <a href="sdk/c/0.10.1/ref.html#host-functions">Host Functions</a> and the <a href="sdk/c/0.10.1/ref.html#host-module-registrations">Host Module Registrations</a>.</p>
</li>
</ol>
<h3 id="host-module-registrations-1"><a class="header" href="#host-module-registrations-1">Host Module Registrations</a></h3>
<p><a href="https://webassembly.github.io/spec/core/exec/runtime.html#syntax-hostfunc">Host functions</a> are functions outside WebAssembly and passed to WASM modules as imports.
In WasmEdge, the host functions are composed into host modules as <code>WasmEdge_ModuleInstanceContext</code> objects with module names.
Please refer to the <a href="sdk/c/0.10.1/ref.html#host-functions">Host Functions in WasmEdge Runtime</a> for the details.
In this chapter, we show the example for registering the host modules into a <code>VM</code> context.</p>
<pre><code class="language-c">WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(NULL, NULL);
WasmEdge_ModuleInstanceContext *WasiModule =
  WasmEdge_ModuleInstanceCreateWASI( /* ... ignored ... */ );
/* You can also create and register the WASI host modules by this API. */
WasmEdge_Result Res = WasmEdge_VMRegisterModuleFromImport(VMCxt, WasiModule);
/* The result status should be checked. */

/* ... */

WasmEdge_ModuleInstanceDelete(WasiModule);
/* The created module instances should be deleted by the developers when the VM deallocation. */
WasmEdge_VMDelete(VMCxt);
</code></pre>
<h3 id="wasm-registrations-and-executions-1"><a class="header" href="#wasm-registrations-and-executions-1">WASM Registrations And Executions</a></h3>
<p>In WebAssembly, the instances in WASM modules can be exported and can be imported by other WASM modules.
WasmEdge VM provides APIs for developers to register and export any WASM modules, and execute the functions or host functions in the registered WASM modules.</p>
<ol>
<li>
<p>Register the WASM modules with exported module names</p>
<p>Unless the module instances have already contained the module names, every WASM module should be named uniquely when registering.
Assume that the WASM file <a href="https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/examples/wasm/fibonacci.wasm"><code>fibonacci.wasm</code></a> is copied into the current directory.</p>
<pre><code class="language-c">WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(NULL, NULL);
WasmEdge_String ModName = WasmEdge_StringCreateByCString(&quot;mod&quot;);
WasmEdge_Result Res = WasmEdge_VMRegisterModuleFromFile(VMCxt, ModName, &quot;fibonacci.wasm&quot;);
/* 
 * Developers can register the WASM module from buffer with the `WasmEdge_VMRegisterModuleFromBuffer()` API,
 * or from `WasmEdge_ASTModuleContext` object with the `WasmEdge_VMRegisterModuleFromASTModule()` API.
 */
/* 
 * The result status should be checked.
 * The error will occur if the WASM module instantiation failed or the module name conflicts.
 */
WasmEdge_StringDelete(ModName);
WasmEdge_VMDelete(VMCxt);
</code></pre>
</li>
<li>
<p>Execute the functions in registered WASM modules</p>
<p>Assume that the C file <code>test.c</code> is as follows:</p>
<pre><code class="language-c">#include &lt;wasmedge/wasmedge.h&gt;
#include &lt;stdio.h&gt;
int main() {
  WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(NULL, NULL);

  /* The parameters and returns arrays. */
  WasmEdge_Value Params[1] = { WasmEdge_ValueGenI32(20) };
  WasmEdge_Value Returns[1];
  /* Names. */
  WasmEdge_String ModName = WasmEdge_StringCreateByCString(&quot;mod&quot;);
  WasmEdge_String FuncName = WasmEdge_StringCreateByCString(&quot;fib&quot;);
  /* Result. */
  WasmEdge_Result Res;

  /* Register the WASM module into VM. */
  Res = WasmEdge_VMRegisterModuleFromFile(VMCxt, ModName, &quot;fibonacci.wasm&quot;);
  /* 
  * Developers can register the WASM module from buffer with the `WasmEdge_VMRegisterModuleFromBuffer()` API,
  * or from `WasmEdge_ASTModuleContext` object with the `WasmEdge_VMRegisterModuleFromASTModule()` API.
  */
  if (!WasmEdge_ResultOK(Res)) {
    printf(&quot;WASM registration failed: %s\n&quot;, WasmEdge_ResultGetMessage(Res));
    return 1;
  }
  /* 
  * The function &quot;fib&quot; in the &quot;fibonacci.wasm&quot; was exported with the module name &quot;mod&quot;.
  * As the same as host functions, other modules can import the function `&quot;mod&quot; &quot;fib&quot;`.
  */

  /* 
  * Execute WASM functions in registered modules.
  * Unlike the execution of functions, the registered functions can be invoked without
  * `WasmEdge_VMInstantiate()` because the WASM module was instantiated when registering.
  * Developers can also invoke the host functions directly with this API.
  */
  Res = WasmEdge_VMExecuteRegistered(VMCxt, ModName, FuncName, Params, 1, Returns, 1);
  if (WasmEdge_ResultOK(Res)) {
    printf(&quot;Get the result: %d\n&quot;, WasmEdge_ValueGetI32(Returns[0]));
  } else {
    printf(&quot;Execution phase failed: %s\n&quot;, WasmEdge_ResultGetMessage(Res));
  }
  WasmEdge_StringDelete(ModName);
  WasmEdge_StringDelete(FuncName);
  WasmEdge_VMDelete(VMCxt);
  return 0;
}
</code></pre>
<p>Then you can compile and run: (the 20th Fibonacci number is 89 in 0-based index)</p>
<pre><code class="language-bash">$ gcc test.c -lwasmedge_c
$ ./a.out
Get the result: 10946
</code></pre>
</li>
</ol>
<h3 id="asynchronous-execution-1"><a class="header" href="#asynchronous-execution-1">Asynchronous Execution</a></h3>
<ol>
<li>
<p>Asynchronously run WASM functions rapidly</p>
<p>Assume that the WASM file <a href="https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/examples/wasm/fibonacci.wasm"><code>fibonacci.wasm</code></a> is copied into the current directory, and the C file <code>test.c</code> is as following:</p>
<pre><code class="language-c">#include &lt;wasmedge/wasmedge.h&gt;
#include &lt;stdio.h&gt;
int main() {
  /* Create the VM context. */
  WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(NULL, NULL);

  /* The parameters and returns arrays. */
  WasmEdge_Value Params[1] = { WasmEdge_ValueGenI32(20) };
  WasmEdge_Value Returns[1];
  /* Function name. */
  WasmEdge_String FuncName = WasmEdge_StringCreateByCString(&quot;fib&quot;);
  /* Asynchronously run the WASM function from file and get the `WasmEdge_Async` object. */
  WasmEdge_Async *Async = WasmEdge_VMAsyncRunWasmFromFile(VMCxt, &quot;fibonacci.wasm&quot;, FuncName, Params, 1);
  /* 
   * Developers can run the WASM binary from buffer with the `WasmEdge_VMAsyncRunWasmFromBuffer()` API,
   * or from `WasmEdge_ASTModuleContext` object with the `WasmEdge_VMAsyncRunWasmFromASTModule()` API.
   */

  /* Wait for the execution. */
  WasmEdge_AsyncWait(Async);
  /*
   * Developers can also use the `WasmEdge_AsyncGetReturnsLength()` or `WasmEdge_AsyncGet()` APIs
   * to wait for the asynchronous execution. These APIs will wait until the execution finished.
   */

  /* Check the return values length. */
  uint32_t Arity = WasmEdge_AsyncGetReturnsLength(Async);
  /* The `Arity` should be 1. Developers can skip this step if they have known the return arity. */

  /* Get the result. */
  WasmEdge_Result Res = WasmEdge_AsyncGet(Async, Returns, Arity);

  if (WasmEdge_ResultOK(Res)) {
    printf(&quot;Get the result: %d\n&quot;, WasmEdge_ValueGetI32(Returns[0]));
  } else {
    printf(&quot;Error message: %s\n&quot;, WasmEdge_ResultGetMessage(Res));
  }

  /* Resources deallocations. */
  WasmEdge_AsyncDelete(Async);
  WasmEdge_VMDelete(VMCxt);
  WasmEdge_StringDelete(FuncName);
  return 0;
}
</code></pre>
<p>Then you can compile and run: (the 20th Fibonacci number is 10946 in 0-based index)</p>
<pre><code class="language-bash">$ gcc test.c -lwasmedge_c
$ ./a.out
Get the result: 10946
</code></pre>
</li>
<li>
<p>Instantiate and asynchronously run WASM functions manually</p>
<p>Besides the above example, developers can run the WASM functions step-by-step with <code>VM</code> context APIs:</p>
<pre><code class="language-c">#include &lt;wasmedge/wasmedge.h&gt;
#include &lt;stdio.h&gt;
int main() {
  /* Create the VM context. */
  WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(NULL, NULL);

  /* The parameters and returns arrays. */
  WasmEdge_Value Params[1] = { WasmEdge_ValueGenI32(25) };
  WasmEdge_Value Returns[1];
  /* Function name. */
  WasmEdge_String FuncName = WasmEdge_StringCreateByCString(&quot;fib&quot;);
  /* Result. */
  WasmEdge_Result Res;
  
  /* Step 1: Load WASM file. */
  Res = WasmEdge_VMLoadWasmFromFile(VMCxt, &quot;fibonacci.wasm&quot;);
  /* 
   * Developers can load the WASM binary from buffer with the `WasmEdge_VMLoadWasmFromBuffer()` API,
   * or from `WasmEdge_ASTModuleContext` object with the `WasmEdge_VMLoadWasmFromASTModule()` API.
   */
  if (!WasmEdge_ResultOK(Res)) {
    printf(&quot;Loading phase failed: %s\n&quot;, WasmEdge_ResultGetMessage(Res));
    return 1;
  }
  /* Step 2: Validate the WASM module. */
  Res = WasmEdge_VMValidate(VMCxt);
  if (!WasmEdge_ResultOK(Res)) {
    printf(&quot;Validation phase failed: %s\n&quot;, WasmEdge_ResultGetMessage(Res));
    return 1;
  }
  /* Step 3: Instantiate the WASM module. */
  Res = WasmEdge_VMInstantiate(VMCxt);
  /* 
   * Developers can load, validate, and instantiate another WASM module to replace the
   * instantiated one. In this case, the old module will be cleared, but the registered
   * modules are still kept.
   */
  if (!WasmEdge_ResultOK(Res)) {
    printf(&quot;Instantiation phase failed: %s\n&quot;, WasmEdge_ResultGetMessage(Res));
    return 1;
  }
  /* Step 4: Asynchronously execute the WASM function and get the `WasmEdge_Async` object. */
  WasmEdge_Async *Async = WasmEdge_VMAsyncExecute(VMCxt, FuncName, Params, 1);
  /* 
   * Developers can execute functions repeatedly after instantiation.
   * For invoking the registered functions, you can use the `WasmEdge_VMAsyncExecuteRegistered()` API.
   */

  /* Wait and check the return values length. */
  uint32_t Arity = WasmEdge_AsyncGetReturnsLength(Async);
  /* The `Arity` should be 1. Developers can skip this step if they have known the return arity. */

  /* Get the result. */
  Res = WasmEdge_AsyncGet(Async, Returns, Arity);
  if (WasmEdge_ResultOK(Res)) {
    printf(&quot;Get the result: %d\n&quot;, WasmEdge_ValueGetI32(Returns[0]));
  } else {
    printf(&quot;Execution phase failed: %s\n&quot;, WasmEdge_ResultGetMessage(Res));
  }

  /* Resources deallocations. */
  WasmEdge_AsyncDelete(Async);
  WasmEdge_VMDelete(VMCxt);
  WasmEdge_StringDelete(FuncName);
}
</code></pre>
<p>Then you can compile and run: (the 25th Fibonacci number is 121393 in 0-based index)</p>
<pre><code class="language-bash">$ gcc test.c -lwasmedge_c
$ ./a.out
Get the result: 121393
</code></pre>
</li>
</ol>
<h3 id="instance-tracing-1"><a class="header" href="#instance-tracing-1">Instance Tracing</a></h3>
<p>Sometimes the developers may have requirements to get the instances of the WASM runtime.
The <code>VM</code> context supplies the APIs to retrieve the instances.</p>
<ol>
<li>
<p>Store</p>
<p>If the <code>VM</code> context is created without assigning a <code>Store</code> context, the <code>VM</code> context will allocate and own a <code>Store</code> context.</p>
<pre><code class="language-c">WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(NULL, NULL);
WasmEdge_StoreContext *StoreCxt = WasmEdge_VMGetStoreContext(VMCxt);
/* The object should __NOT__ be deleted by `WasmEdge_StoreDelete()`. */
WasmEdge_VMDelete(VMCxt);
</code></pre>
<p>Developers can also create the <code>VM</code> context with a <code>Store</code> context.
In this case, developers should guarantee the life cycle of the <code>Store</code> context.
Please refer to the <a href="sdk/c/0.10.1/ref.html#store">Store Contexts</a> for the details about the <code>Store</code> context APIs.</p>
<pre><code class="language-c">WasmEdge_StoreContext *StoreCxt = WasmEdge_StoreCreate();
WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(NULL, StoreCxt);
WasmEdge_StoreContext *StoreCxtMock = WasmEdge_VMGetStoreContext(VMCxt);
/* The `StoreCxt` and the `StoreCxtMock` are the same. */
WasmEdge_VMDelete(VMCxt);
WasmEdge_StoreDelete(StoreCxt);
</code></pre>
</li>
<li>
<p>List exported functions</p>
<p>After the WASM module instantiation, developers can use the <code>WasmEdge_VMExecute()</code> API to invoke the exported WASM functions. For this purpose, developers may need information about the exported WASM function list.
Please refer to the <a href="sdk/c/0.10.1/ref.html#instances">Instances in runtime</a> for the details about the function types.
Assume that the WASM file <a href="https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/examples/wasm/fibonacci.wasm"><code>fibonacci.wasm</code></a> is copied into the current directory, and the C file <code>test.c</code> is as following:</p>
<pre><code class="language-c">#include &lt;wasmedge/wasmedge.h&gt;
#include &lt;stdio.h&gt;
int main() {
  WasmEdge_StoreContext *StoreCxt = WasmEdge_StoreCreate();
  WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(NULL, StoreCxt);

  WasmEdge_VMLoadWasmFromFile(VMCxt, &quot;fibonacci.wasm&quot;);
  WasmEdge_VMValidate(VMCxt);
  WasmEdge_VMInstantiate(VMCxt);

  /* List the exported functions. */
  /* Get the number of exported functions. */
  uint32_t FuncNum = WasmEdge_VMGetFunctionListLength(VMCxt);
  /* Create the name buffers and the function type buffers. */
  const uint32_t BUF_LEN = 256;
  WasmEdge_String FuncNames[BUF_LEN];
  WasmEdge_FunctionTypeContext *FuncTypes[BUF_LEN];
  /* 
   * Get the export function list.
   * If the function list length is larger than the buffer length, the overflowed data will be discarded.
   * The `FuncNames` and `FuncTypes` can be NULL if developers don't need them.
   */
  uint32_t RealFuncNum = WasmEdge_VMGetFunctionList(VMCxt, FuncNames, FuncTypes, BUF_LEN);

  for (uint32_t I = 0; I &lt; RealFuncNum &amp;&amp; I &lt; BUF_LEN; I++) {
    char Buf[BUF_LEN];
    uint32_t Size = WasmEdge_StringCopy(FuncNames[I], Buf, sizeof(Buf));
    printf(&quot;Get exported function string length: %u, name: %s\n&quot;, Size, Buf);
    /* 
     * The function names should be __NOT__ destroyed.
     * The returned function type contexts should __NOT__ be destroyed.
     */
  }
  return 0;
}
</code></pre>
<p>Then you can compile and run: (the only exported function in <code>fibonacci.wasm</code> is <code>fib</code>)</p>
<pre><code class="language-bash">$ gcc test.c -lwasmedge_c
$ ./a.out
Get exported function string length: 3, name: fib
</code></pre>
<p>If developers want to get the exported function names in the registered WASM modules, please retrieve the <code>Store</code> context from the <code>VM</code> context and refer to the APIs of <a href="sdk/c/0.10.1/ref.html#store">Store Contexts</a> to list the registered functions by the module name.</p>
</li>
<li>
<p>Get function types</p>
<p>The <code>VM</code> context provides APIs to find the function type by function name.
Please refer to the <a href="sdk/c/0.10.1/ref.html#instances">Instances in runtime</a> for the details about the function types.</p>
<pre><code class="language-c">/* 
 * ...
 * Assume that a WASM module is instantiated in `VMCxt`.
 */
WasmEdge_String FuncName = WasmEdge_StringCreateByCString(&quot;fib&quot;);
const WasmEdge_FunctionTypeContext *FuncType = WasmEdge_VMGetFunctionType(VMCxt, FuncName);
/* 
 * Developers can get the function types of functions in the registered modules
 * via the `WasmEdge_VMGetFunctionTypeRegistered()` API with the module name.
 * If the function is not found, these APIs will return `NULL`.
 * The returned function type contexts should __NOT__ be destroyed.
 */
WasmEdge_StringDelete(FuncName);
</code></pre>
</li>
<li>
<p>Get the active module</p>
<p>After the WASM module instantiation, an anonymous module is instantiated and owned by the <code>VM</code> context.
Developers may need to retrieve it to get the instances beyond the module.
Then developers can use the <code>WasmEdge_VMGetActiveModule()</code> API to get that anonymous module instance.
Please refer to the <a href="sdk/c/0.10.1/ref.html#instances">Module instance</a> for the details about the module instance APIs.</p>
<pre><code class="language-c">/* 
 * ...
 * Assume that a WASM module is instantiated in `VMCxt`.
 */
const WasmEdge_ModuleInstanceContext *ModCxt = WasmEdge_VMGetActiveModule(VMCxt);
/* 
 * If there's no WASM module instantiated, this API will return `NULL`.
 * The returned module instance context should __NOT__ be destroyed.
 */
</code></pre>
</li>
<li>
<p>Get the components</p>
<p>The <code>VM</code> context is composed by the <code>Loader</code>, <code>Validator</code>, and <code>Executor</code> contexts.
For the developers who want to use these contexts without creating another instances, these APIs can help developers to get them from the <code>VM</code> context.
The get contexts are owned by the <code>VM</code> context, and developers should not call their delete functions.</p>
<pre><code class="language-c">WasmEdge_LoaderContext *LoadCxt = WasmEdge_VMGetLoaderContext(VMCxt);
/* The object should __NOT__ be deleted by `WasmEdge_LoaderDelete()`. */
WasmEdge_ValidatorContext *ValidCxt = WasmEdge_VMGetValidatorContext(VMCxt);
/* The object should __NOT__ be deleted by `WasmEdge_ValidatorDelete()`. */
WasmEdge_ExecutorContext *ExecCxt = WasmEdge_VMGetExecutorContext(VMCxt);
/* The object should __NOT__ be deleted by `WasmEdge_ExecutorDelete()`. */
</code></pre>
</li>
</ol>
<h2 id="wasmedge-runtime-1"><a class="header" href="#wasmedge-runtime-1">WasmEdge Runtime</a></h2>
<p>In this partition, we will introduce the objects of WasmEdge runtime manually.</p>
<h3 id="wasm-execution-example-step-by-step-1"><a class="header" href="#wasm-execution-example-step-by-step-1">WASM Execution Example Step-By-Step</a></h3>
<p>Besides the WASM execution through the <a href="sdk/c/0.10.1/ref.html#wasmedge-vm"><code>VM</code> context</a>, developers can execute the WASM functions or instantiate WASM modules step-by-step with the <code>Loader</code>, <code>Validator</code>, <code>Executor</code>, and <code>Store</code> contexts.
Assume that the WASM file <a href="https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/examples/wasm/fibonacci.wasm"><code>fibonacci.wasm</code></a> is copied into the current directory, and the C file <code>test.c</code> is as following:</p>
<pre><code class="language-c">#include &lt;wasmedge/wasmedge.h&gt;
#include &lt;stdio.h&gt;
int main() {
  /* Create the configure context. This step is not necessary because we didn't adjust any setting. */
  WasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();
  /* Create the statistics context. This step is not necessary if the statistics in runtime is not needed. */
  WasmEdge_StatisticsContext *StatCxt = WasmEdge_StatisticsCreate();
  /* Create the store context. The store context is the object to link the modules for imports and exports. */
  WasmEdge_StoreContext *StoreCxt = WasmEdge_StoreCreate();
  /* Result. */
  WasmEdge_Result Res;

  /* Create the loader context. The configure context can be NULL. */
  WasmEdge_LoaderContext *LoadCxt = WasmEdge_LoaderCreate(ConfCxt);
  /* Create the validator context. The configure context can be NULL. */
  WasmEdge_ValidatorContext *ValidCxt = WasmEdge_ValidatorCreate(ConfCxt);
  /* Create the executor context. The configure context and the statistics context can be NULL. */
  WasmEdge_ExecutorContext *ExecCxt = WasmEdge_ExecutorCreate(ConfCxt, StatCxt);

  /* Load the WASM file or the compiled-WASM file and convert into the AST module context. */
  WasmEdge_ASTModuleContext *ASTCxt = NULL;
  Res = WasmEdge_LoaderParseFromFile(LoadCxt, &amp;ASTCxt, &quot;fibonacci.wasm&quot;);
  if (!WasmEdge_ResultOK(Res)) {
    printf(&quot;Loading phase failed: %s\n&quot;, WasmEdge_ResultGetMessage(Res));
    return 1;
  }
  /* Validate the WASM module. */
  Res = WasmEdge_ValidatorValidate(ValidCxt, ASTCxt);
  if (!WasmEdge_ResultOK(Res)) {
    printf(&quot;Validation phase failed: %s\n&quot;, WasmEdge_ResultGetMessage(Res));
    return 1;
  }
  /* Instantiate the WASM module into store context. */
  WasmEdge_ModuleInstanceContext *ModCxt = NULL;
  Res = WasmEdge_ExecutorInstantiate(ExecCxt, &amp;ModCxt, StoreCxt, ASTCxt);
  if (!WasmEdge_ResultOK(Res)) {
    printf(&quot;Instantiation phase failed: %s\n&quot;, WasmEdge_ResultGetMessage(Res));
    return 1;
  }

  /* Try to list the exported functions of the instantiated WASM module. */
  uint32_t FuncNum = WasmEdge_ModuleInstanceListFunctionLength(ModCxt);
  /* Create the name buffers. */
  const uint32_t BUF_LEN = 256;
  WasmEdge_String FuncNames[BUF_LEN];
  /* If the list length is larger than the buffer length, the overflowed data will be discarded. */
  uint32_t RealFuncNum = WasmEdge_ModuleInstanceListFunction(ModCxt, FuncNames, BUF_LEN);
  for (uint32_t I = 0; I &lt; RealFuncNum &amp;&amp; I &lt; BUF_LEN; I++) {
    char Buf[BUF_LEN];
    uint32_t Size = WasmEdge_StringCopy(FuncNames[I], Buf, sizeof(Buf));
    printf(&quot;Get exported function string length: %u, name: %s\n&quot;, Size, Buf);
    /* The function names should __NOT__ be destroyed. */
  }

  /* The parameters and returns arrays. */
  WasmEdge_Value Params[1] = { WasmEdge_ValueGenI32(18) };
  WasmEdge_Value Returns[1];
  /* Function name. */
  WasmEdge_String FuncName = WasmEdge_StringCreateByCString(&quot;fib&quot;);
  /* Find the exported function by function name. */
  WasmEdge_FunctionInstanceContext *FuncCxt = WasmEdge_ModuleInstanceFindFunction(ModCxt, FuncName);
  if (FuncCxt == NULL) {
    printf(&quot;Function `fib` not found.\n&quot;);
    return 1;
  }
  /* Invoke the WASM fnction. */
  Res = WasmEdge_ExecutorInvoke(ExecCxt, FuncCxt, Params, 1, Returns, 1);
  if (WasmEdge_ResultOK(Res)) {
    printf(&quot;Get the result: %d\n&quot;, WasmEdge_ValueGetI32(Returns[0]));
  } else {
    printf(&quot;Execution phase failed: %s\n&quot;, WasmEdge_ResultGetMessage(Res));
  }

  /* Resources deallocations. */
  WasmEdge_StringDelete(FuncName);
  WasmEdge_ASTModuleDelete(ASTCxt);
  WasmEdge_ModuleInstanceDelete(ModCxt);
  WasmEdge_LoaderDelete(LoadCxt);
  WasmEdge_ValidatorDelete(ValidCxt);
  WasmEdge_ExecutorDelete(ExecCxt);
  WasmEdge_ConfigureDelete(ConfCxt);
  WasmEdge_StoreDelete(StoreCxt);
  WasmEdge_StatisticsDelete(StatCxt);
  return 0;
}
</code></pre>
<p>Then you can compile and run: (the 18th Fibonacci number is 4181 in 0-based index)</p>
<pre><code class="language-bash">$ gcc test.c -lwasmedge_c
$ ./a.out
Get exported function string length: 3, name: fib
Get the result: 4181
</code></pre>
<h3 id="loader-1"><a class="header" href="#loader-1">Loader</a></h3>
<p>The <code>Loader</code> context loads the WASM binary from files or buffers.
Both the WASM and the compiled-WASM from the <a href="sdk/c/0.10.1/ref.html#wasmedge-aot-compiler">WasmEdge AOT Compiler</a> are supported.</p>
<pre><code class="language-c">uint8_t Buf[4096];
/* ... Read the WASM code to the buffer. */
uint32_t FileSize = ...;
/* The `FileSize` is the length of the WASM code. */

/* Developers can adjust settings in the configure context. */
WasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();
/* Create the loader context. The configure context can be NULL. */
WasmEdge_LoaderContext *LoadCxt = WasmEdge_LoaderCreate(ConfCxt);

WasmEdge_ASTModuleContext *ASTCxt = NULL;
WasmEdge_Result Res;

/* Load WASM or compiled-WASM from the file. */
Res = WasmEdge_LoaderParseFromFile(LoadCxt, &amp;ASTCxt, &quot;fibonacci.wasm&quot;);
if (!WasmEdge_ResultOK(Res)) {
  printf(&quot;Loading phase failed: %s\n&quot;, WasmEdge_ResultGetMessage(Res));
}
/* The output AST module context should be destroyed. */
WasmEdge_ASTModuleDelete(ASTCxt);

/* Load WASM or compiled-WASM from the buffer. */
Res = WasmEdge_LoaderParseFromBuffer(LoadCxt, &amp;ASTCxt, Buf, FileSize);
if (!WasmEdge_ResultOK(Res)) {
  printf(&quot;Loading phase failed: %s\n&quot;, WasmEdge_ResultGetMessage(Res));
}
/* The output AST module context should be destroyed. */
WasmEdge_ASTModuleDelete(ASTCxt);

WasmEdge_LoaderDelete(LoadCxt);
WasmEdge_ConfigureDelete(ConfCxt);
</code></pre>
<h3 id="validator-1"><a class="header" href="#validator-1">Validator</a></h3>
<p>The <code>Validator</code> context can validate the WASM module.
Every WASM module should be validated before instantiation.</p>
<pre><code class="language-c">/* 
 * ...
 * Assume that the `ASTCxt` is the output AST module context from the loader context.
 * Assume that the `ConfCxt` is the configure context.
 */
/* Create the validator context. The configure context can be NULL. */
WasmEdge_ValidatorContext *ValidCxt = WasmEdge_ValidatorCreate(ConfCxt);
WasmEdge_Result Res = WasmEdge_ValidatorValidate(ValidCxt, ASTCxt);
if (!WasmEdge_ResultOK(Res)) {
  printf(&quot;Validation phase failed: %s\n&quot;, WasmEdge_ResultGetMessage(Res));
}
WasmEdge_ValidatorDelete(ValidCxt);
</code></pre>
<h3 id="executor-1"><a class="header" href="#executor-1">Executor</a></h3>
<p>The <code>Executor</code> context is the executor for both WASM and compiled-WASM.
This object should work base on the <code>Store</code> context. For the details of the <code>Store</code> context, please refer to the <a href="sdk/c/0.10.1/ref.html#store">next chapter</a>.</p>
<ol>
<li>
<p>Instantiate and register an <code>AST module</code> as a named <code>Module</code> instance</p>
<p>As the same of <a href="sdk/c/0.10.1/ref.html#host-module-registrations">registering host modules</a> or <a href="sdk/c/0.10.1/ref.html#wasm-registrations-and-executions">importing WASM modules</a> in <code>VM</code> contexts, developers can instantiate and register an <code>AST module</code> contexts into the <code>Store</code> context as a named <code>Module</code> instance by the <code>Executor</code> APIs.
After the registration, the result <code>Module</code> instance is exported with the given module name and can be linked when instantiating another module.
For the details about the <code>Module</code> instances APIs, please refer to the <a href="sdk/c/0.10.1/ref.html#instances">Instances</a>.</p>
<pre><code class="language-c">/* 
* ...
* Assume that the `ASTCxt` is the output AST module context from the loader context
* and has passed the validation.
* Assume that the `ConfCxt` is the configure context.
*/
/* Create the statistics context. This step is not necessary. */
WasmEdge_StatisticsContext *StatCxt = WasmEdge_StatisticsCreate();
/* Create the executor context. The configure and the statistics contexts can be NULL. */
WasmEdge_ExecutorContext *ExecCxt = WasmEdge_ExecutorCreate(ConfCxt, StatCxt);
/* Create the store context. The store context is the object to link the modules for imports and exports. */
WasmEdge_StoreContext *StoreCxt = WasmEdge_StoreCreate();
/* Result. */
WasmEdge_Result Res;

WasmEdge_String ModName = WasmEdge_StringCreateByCString(&quot;mod&quot;);
/* The output module instance. */
WasmEdge_ModuleInstanceContext *ModCxt = NULL;
/* Register the WASM module into the store with the export module name &quot;mod&quot;. */
Res = WasmEdge_ExecutorRegister(ExecCxt, &amp;ModCxt, StoreCxt, ASTCxt, ModName);
if (!WasmEdge_ResultOK(Res)) {
  printf(&quot;WASM registration failed: %s\n&quot;, WasmEdge_ResultGetMessage(Res));
  return -1;
}
WasmEdge_StringDelete(ModName);

/* ... */

/* After the execution, the resources should be released. */
WasmEdge_ExecutorDelete(ExecCxt);
WasmEdge_StatisticsDelete(StatCxt);
WasmEdge_StoreDelete(StoreCxt);
WasmEdge_ModuleInstanceDelete(ModCxt);
</code></pre>
</li>
<li>
<p>Register an existing <code>Module</code> instance and export the module name</p>
<p>Besides instantiating and registering an <code>AST module</code> contexts, developers can register an existing <code>Module</code> instance into the store with exporting the module name (which is in the <code>Module</code> instance already).
This case occurs when developers create a <code>Module</code> instance for the host functions and want to register it for linking.
For the details about the construction of host functions in <code>Module</code> instances, please refer to the <a href="sdk/c/0.10.1/ref.html#host-functions">Host Functions</a>.</p>
<pre><code class="language-c">/* 
* ...
* Assume that the `ASTCxt` is the output AST module context from the loader context
* and has passed the validation.
* Assume that the `ConfCxt` is the configure context.
*/
/* Create the statistics context. This step is not necessary. */
WasmEdge_StatisticsContext *StatCxt = WasmEdge_StatisticsCreate();
/* Create the executor context. The configure and the statistics contexts can be NULL. */
WasmEdge_ExecutorContext *ExecCxt = WasmEdge_ExecutorCreate(ConfCxt, StatCxt);
/* Create the store context. The store context is the object to link the modules for imports and exports. */
WasmEdge_StoreContext *StoreCxt = WasmEdge_StoreCreate();
/* Result. */
WasmEdge_Result Res;

/* Create a module instance for host functions. */
WasmEdge_String ModName = WasmEdge_StringCreateByCString(&quot;host-module&quot;);
WasmEdge_ModuleInstanceContext *HostModCxt = WasmEdge_ModuleInstanceCreate(ModName);
WasmEdge_StringDelete(ModName);
/*
 * ...
 * Create and add the host functions, tables, memories, and globals into the module instance.
 */

/* Register the module instance into store with the exported module name. */
/* The export module name is in the module instance already. */
Res = WasmEdge_ExecutorRegisterImport(ExecCxt, StoreCxt, HostModCxt);
if (!WasmEdge_ResultOK(Res)) {
  printf(&quot;WASM registration failed: %s\n&quot;, WasmEdge_ResultGetMessage(Res));
  return -1;
}

/* ... */

/* After the execution, the resources should be released. */
WasmEdge_ExecutorDelete(ExecCxt);
WasmEdge_StatisticsDelete(StatCxt);
WasmEdge_StoreDelete(StoreCxt);
WasmEdge_ModuleInstanceDelete(ModCxt);
</code></pre>
</li>
<li>
<p>Instantiate an <code>AST module</code> to an anonymous <code>Module</code> instance</p>
<p>WASM or compiled-WASM modules should be instantiated before the function invocation.
Before instantiating a WASM module, please check the <a href="https://webassembly.github.io/spec/core/syntax/modules.html#syntax-import">import section</a> for ensuring the imports are registered into the <code>Store</code> context for linking.</p>
<pre><code class="language-c">/* 
* ...
* Assume that the `ASTCxt` is the output AST module context from the loader context
* and has passed the validation.
* Assume that the `ConfCxt` is the configure context.
*/
/* Create the statistics context. This step is not necessary. */
WasmEdge_StatisticsContext *StatCxt = WasmEdge_StatisticsCreate();
/* Create the executor context. The configure and the statistics contexts can be NULL. */
WasmEdge_ExecutorContext *ExecCxt = WasmEdge_ExecutorCreate(ConfCxt, StatCxt);
/* Create the store context. The store context is the object to link the modules for imports and exports. */
WasmEdge_StoreContext *StoreCxt = WasmEdge_StoreCreate();

/* The output module instance. */
WasmEdge_ModuleInstanceContext *ModCxt = NULL;
/* Instantiate the WASM module. */
WasmEdge_Result Res = WasmEdge_ExecutorInstantiate(ExecCxt, &amp;ModCxt, StoreCxt, ASTCxt);
if (!WasmEdge_ResultOK(Res)) {
  printf(&quot;WASM instantiation failed: %s\n&quot;, WasmEdge_ResultGetMessage(Res));
  return -1;
}

/* ... */

/* After the execution, the resources should be released. */
WasmEdge_ExecutorDelete(ExecCxt);
WasmEdge_StatisticsDelete(StatCxt);
WasmEdge_StoreDelete(StoreCxt);
WasmEdge_ModuleInstanceDelete(ModCxt);
</code></pre>
</li>
<li>
<p>Invoke functions</p>
<p>After registering or instantiating and get the result <code>Module</code> instance, developers can retrieve the exported <code>Function</code> instances from the <code>Module</code> instance for invocation.
For the details about the <code>Module</code> instances APIs, please refer to the <a href="sdk/c/0.10.1/ref.html#instances">Instances</a>.
Please refer to the <a href="sdk/c/0.10.1/ref.html#wasm-execution-example-step-by-step">example above</a> for the <code>Function</code> instance invocation with the <code>WasmEdge_ExecutorInvoke()</code> API.</p>
</li>
</ol>
<h3 id="ast-module-1"><a class="header" href="#ast-module-1">AST Module</a></h3>
<p>The <code>AST Module</code> context presents the loaded structure from a WASM file or buffer. Developer will get this object after loading a WASM file or buffer from <a href="sdk/c/0.10.1/ref.html#loader">Loader</a>.
Before instantiation, developers can also query the imports and exports of an <code>AST Module</code> context.</p>
<pre><code class="language-c">WasmEdge_ASTModuleContext *ASTCxt = ...;
/* Assume that a WASM is loaded into an AST module context. */

/* Create the import type context buffers. */
const uint32_t BUF_LEN = 256;
const WasmEdge_ImportTypeContext *ImpTypes[BUF_LEN];
uint32_t ImportNum = WasmEdge_ASTModuleListImportsLength(ASTCxt);
/* If the list length is larger than the buffer length, the overflowed data will be discarded. */
uint32_t RealImportNum = WasmEdge_ASTModuleListImports(ASTCxt, ImpTypes, BUF_LEN);
for (uint32_t I = 0; I &lt; RealImportNum &amp;&amp; I &lt; BUF_LEN; I++) {
  /* Working with the import type `ImpTypes[I]` ... */
}

/* Create the export type context buffers. */
const WasmEdge_ExportTypeContext *ExpTypes[BUF_LEN];
uint32_t ExportNum = WasmEdge_ASTModuleListExportsLength(ASTCxt);
/* If the list length is larger than the buffer length, the overflowed data will be discarded. */
uint32_t RealExportNum = WasmEdge_ASTModuleListExports(ASTCxt, ExpTypes, BUF_LEN);
for (uint32_t I = 0; I &lt; RealExportNum &amp;&amp; I &lt; BUF_LEN; I++) {
  /* Working with the export type `ExpTypes[I]` ... */
}

WasmEdge_ASTModuleDelete(ASTCxt);
/* After deletion of `ASTCxt`, all data queried from the `ASTCxt` should not be accessed. */
</code></pre>
<h3 id="store-1"><a class="header" href="#store-1">Store</a></h3>
<p><a href="https://webassembly.github.io/spec/core/exec/runtime.html#store">Store</a> is the runtime structure for the representation of all global state that can be manipulated by WebAssembly programs.
The <code>Store</code> context in WasmEdge is an object to provide the instance exporting and importing when instantiating WASM modules.
Developers can retrieve the named modules from the <code>Store</code> context.</p>
<pre><code class="language-c">WasmEdge_StoreContext *StoreCxt = WasmEdge_StoreCreate();

/*
 * ...
 * Register a WASM module via the executor context.
 */

/* Try to list the registered WASM modules. */
uint32_t ModNum = WasmEdge_StoreListModuleLength(StoreCxt);
/* Create the name buffers. */
const uint32_t BUF_LEN = 256;
WasmEdge_String ModNames[BUF_LEN];
/* If the list length is larger than the buffer length, the overflowed data will be discarded. */
uint32_t RealModNum = WasmEdge_StoreListModule(StoreCxt, ModNames, BUF_LEN);
for (uint32_t I = 0; I &lt; RealModNum &amp;&amp; I &lt; BUF_LEN; I++) {
  /* Working with the module name `ModNames[I]` ... */
  /* The module names should __NOT__ be destroyed. */
}

/* Find named module by name. */
WasmEdge_String ModName = WasmEdge_StringCreateByCString(&quot;module&quot;);
const WasmEdge_ModuleInstanceContext *ModCxt = WasmEdge_StoreFindModule(StoreCxt, ModName);
/* If the module with name not found, the `ModCxt` will be NULL. */
WasmEdge_StringDelete(ModName);
</code></pre>
<h3 id="instances-1"><a class="header" href="#instances-1">Instances</a></h3>
<p>The instances are the runtime structures of WASM. Developers can retrieve the <code>Module</code> instances from the <code>Store</code> contexts, and retrieve the other instances from the <code>Module</code> instances.
A single instance can be allocated by its creation function. Developers can construct instances into an <code>Module</code> instance for registration. Please refer to the <a href="sdk/c/0.10.1/ref.html#host-functions">Host Functions</a> for details.
The instances created by their creation functions should be destroyed by developers, EXCEPT they are added into an <code>Module</code> instance.</p>
<ol>
<li>
<p>Module instance</p>
<p>After instantiating or registering an <code>AST module</code> context, developers will get a <code>Module</code> instance as the result, and have the responsibility to destroy it when not in use.
A <code>Module</code> instance can also be created for the host module. Please refer to the <a href="sdk/c/0.10.1/ref.html#host-functions">host function</a> for the details.
<code>Module</code> instance provides APIs to list and find the exported instances in the module.</p>
<pre><code class="language-c">/*
* ...
* Instantiate a WASM module via the executor context and get the `ModCxt` as the output module instance.
*/

/* Try to list the exported instance of the instantiated WASM module. */
/* Take the function instances for example here. */
uint32_t FuncNum = WasmEdge_ModuleInstanceListFunctionLength(ModCxt);
/* Create the name buffers. */
const uint32_t BUF_LEN = 256;
WasmEdge_String FuncNames[BUF_LEN];
/* If the list length is larger than the buffer length, the overflowed data will be discarded. */
uint32_t RealFuncNum = WasmEdge_ModuleInstanceListFunction(ModCxt, FuncNames, BUF_LEN);
for (uint32_t I = 0; I &lt; RealFuncNum &amp;&amp; I &lt; BUF_LEN; I++) {
  /* Working with the function name `FuncNames[I]` ... */
  /* The function names should __NOT__ be destroyed. */
}

/* Try to find the exported instance of the instantiated WASM module. */
/* Take the function instances for example here. */
/* Function name. */
WasmEdge_String FuncName = WasmEdge_StringCreateByCString(&quot;fib&quot;);
WasmEdge_FunctionInstanceContext *FuncCxt = WasmEdge_ModuleInstanceFindFunction(ModCxt, FuncName);
/* `FuncCxt` will be `NULL` if the function not found. */
/* The returned instance is owned by the module instance context and should __NOT__ be destroyed. */
WasmEdge_StringDelete(FuncName);
</code></pre>
</li>
<li>
<p>Function instance</p>
<p><a href="https://webassembly.github.io/spec/core/exec/runtime.html#syntax-hostfunc">Host functions</a> are functions outside WebAssembly and passed to WASM modules as imports.
In WasmEdge, developers can create the <code>Function</code> contexts for host functions and add them into an <code>Module</code> instance context for registering into a <code>VM</code> or a <code>Store</code>.
Developers can retrieve the <code>Function Type</code> from the <code>Function</code> contexts through the API.
For the details of the <code>Host Function</code> guide, please refer to the <a href="sdk/c/0.10.1/ref.html#host-functions">next chapter</a>.</p>
<pre><code class="language-c">/* Retrieve the function instance from the module instance context. */
WasmEdge_FunctionInstanceContext *FuncCxt = ...;
WasmEdge_FunctionTypeContext *FuncTypeCxt = WasmEdge_FunctionInstanceGetFunctionType(FuncCxt);
/* The `FuncTypeCxt` is owned by the `FuncCxt` and should __NOT__ be destroyed. */

/* For the function instance creation, please refer to the `Host Function` guide. */
</code></pre>
</li>
<li>
<p>Table instance</p>
<p>In WasmEdge, developers can create the <code>Table</code> contexts and add them into an <code>Module</code> instance context for registering into a <code>VM</code> or a <code>Store</code>.
The <code>Table</code> contexts supply APIs to control the data in table instances.</p>
<pre><code class="language-c">WasmEdge_Limit TabLimit = {.HasMax = true, .Shared = false, .Min = 10, .Max = 20};
/* Create the table type with limit and the `FuncRef` element type. */
WasmEdge_TableTypeContext *TabTypeCxt = WasmEdge_TableTypeCreate(WasmEdge_RefType_FuncRef, TabLimit);
/* Create the table instance with table type. */
WasmEdge_TableInstanceContext *HostTable = WasmEdge_TableInstanceCreate(TabTypeCxt);
/* Delete the table type. */
WasmEdge_TableTypeDelete(TabTypeCxt);
WasmEdge_Result Res;
WasmEdge_Value Data;

TabTypeCxt = WasmEdge_TableInstanceGetTableType(HostTable);
/* The `TabTypeCxt` got from table instance is owned by the `HostTable` and should __NOT__ be destroyed. */
enum WasmEdge_RefType RefType = WasmEdge_TableTypeGetRefType(TabTypeCxt);
/* `RefType` will be `WasmEdge_RefType_FuncRef`. */
Data = WasmEdge_ValueGenFuncRef(5);
Res = WasmEdge_TableInstanceSetData(HostTable, Data, 3);
/* Set the function index 5 to the table[3]. */
/*
 * This will get an &quot;out of bounds table access&quot; error
 * because the position (13) is out of the table size (10):
 *   Res = WasmEdge_TableInstanceSetData(HostTable, Data, 13);
 */
Res = WasmEdge_TableInstanceGetData(HostTable, &amp;Data, 3);
/* Get the FuncRef value of the table[3]. */
/*
 * This will get an &quot;out of bounds table access&quot; error
 * because the position (13) is out of the table size (10):
 *   Res = WasmEdge_TableInstanceGetData(HostTable, &amp;Data, 13);
 */

uint32_t Size = WasmEdge_TableInstanceGetSize(HostTable);
/* `Size` will be 10. */
Res = WasmEdge_TableInstanceGrow(HostTable, 6);
/* Grow the table size of 6, the table size will be 16. */
/*
 * This will get an &quot;out of bounds table access&quot; error because
 * the size (16 + 6) will reach the table limit(20):
 *   Res = WasmEdge_TableInstanceGrow(HostTable, 6);
 */

WasmEdge_TableInstanceDelete(HostTable);
</code></pre>
</li>
<li>
<p>Memory instance</p>
<p>In WasmEdge, developers can create the <code>Memory</code> contexts and add them into an <code>Module</code> instance context for registering into a <code>VM</code> or a <code>Store</code>.
The <code>Memory</code> contexts supply APIs to control the data in memory instances.</p>
<pre><code class="language-c">WasmEdge_Limit MemLimit = {.HasMax = true, .Shared = false, .Min = 1, .Max = 5};
/* Create the memory type with limit. The memory page size is 64KiB. */
WasmEdge_MemoryTypeContext *MemTypeCxt = WasmEdge_MemoryTypeCreate(MemLimit);
/* Create the memory instance with memory type. */
WasmEdge_MemoryInstanceContext *HostMemory = WasmEdge_MemoryInstanceCreate(MemTypeCxt);
/* Delete the memory type. */
WasmEdge_MemoryTypeDelete(MemTypeCxt);
WasmEdge_Result Res;
uint8_t Buf[256];

Buf[0] = 0xAA;
Buf[1] = 0xBB;
Buf[2] = 0xCC;
Res = WasmEdge_MemoryInstanceSetData(HostMemory, Buf, 0x1000, 3);
/* Set the data[0:2] to the memory[4096:4098]. */
/*
 * This will get an &quot;out of bounds memory access&quot; error
 * because [65535:65537] is out of 1 page size (65536):
 *   Res = WasmEdge_MemoryInstanceSetData(HostMemory, Buf, 0xFFFF, 3);
 */
Buf[0] = 0;
Buf[1] = 0;
Buf[2] = 0;
Res = WasmEdge_MemoryInstanceGetData(HostMemory, Buf, 0x1000, 3);
/* Get the memory[4096:4098]. Buf[0:2] will be `{0xAA, 0xBB, 0xCC}`. */
/*
 * This will get an &quot;out of bounds memory access&quot; error
 * because [65535:65537] is out of 1 page size (65536):
 *   Res = WasmEdge_MemoryInstanceSetData(HostMemory, Buf, 0xFFFF, 3);
 */

uint32_t PageSize = WasmEdge_MemoryInstanceGetPageSize(HostMemory);
/* `PageSize` will be 1. */
Res = WasmEdge_MemoryInstanceGrowPage(HostMemory, 2);
/* Grow the page size of 2, the page size of the memory instance will be 3. */
/*
 * This will get an &quot;out of bounds memory access&quot; error because
 * the page size (3 + 3) will reach the memory limit(5):
 *   Res = WasmEdge_MemoryInstanceGrowPage(HostMemory, 3);
 */

WasmEdge_MemoryInstanceDelete(HostMemory);
</code></pre>
</li>
<li>
<p>Global instance</p>
<p>In WasmEdge, developers can create the <code>Global</code> contexts and add them into an <code>Module</code> instance context for registering into a <code>VM</code> or a <code>Store</code>.
The <code>Global</code> contexts supply APIs to control the value in global instances.</p>
<pre><code class="language-c">WasmEdge_Value Val = WasmEdge_ValueGenI64(1000);
/* Create the global type with value type and mutation. */
WasmEdge_GlobalTypeContext *GlobTypeCxt = WasmEdge_GlobalTypeCreate(WasmEdge_ValType_I64, WasmEdge_Mutability_Var);
/* Create the global instance with value and global type. */
WasmEdge_GlobalInstanceContext *HostGlobal = WasmEdge_GlobalInstanceCreate(GlobTypeCxt, Val);
/* Delete the global type. */
WasmEdge_GlobalTypeDelete(GlobTypeCxt);
WasmEdge_Result Res;

GlobTypeCxt = WasmEdge_GlobalInstanceGetGlobalType(HostGlobal);
/* The `GlobTypeCxt` got from global instance is owned by the `HostGlobal` and should __NOT__ be destroyed. */
enum WasmEdge_ValType ValType = WasmEdge_GlobalTypeGetValType(GlobTypeCxt);
/* `ValType` will be `WasmEdge_ValType_I64`. */
enum WasmEdge_Mutability ValMut = WasmEdge_GlobalTypeGetMutability(GlobTypeCxt);
/* `ValMut` will be `WasmEdge_Mutability_Var`. */

WasmEdge_GlobalInstanceSetValue(HostGlobal, WasmEdge_ValueGenI64(888));
/* 
 * Set the value u64(888) to the global.
 * This function will do nothing if the value type mismatched or
 * the global mutability is `WasmEdge_Mutability_Const`.
 */
WasmEdge_Value GlobVal = WasmEdge_GlobalInstanceGetValue(HostGlobal);
/* Get the value (888 now) of the global context. */

WasmEdge_GlobalInstanceDelete(HostGlobal);
</code></pre>
</li>
</ol>
<h3 id="host-functions-3"><a class="header" href="#host-functions-3">Host Functions</a></h3>
<p><a href="https://webassembly.github.io/spec/core/exec/runtime.html#syntax-hostfunc">Host functions</a> are functions outside WebAssembly and passed to WASM modules as imports.
In WasmEdge, developers can create the <code>Function</code>, <code>Memory</code>, <code>Table</code>, and <code>Global</code> contexts and add them into an <code>Module</code> instance context for registering into a <code>VM</code> or a <code>Store</code>.</p>
<ol>
<li>
<p>Host function allocation</p>
<p>Developers can define C functions with the following function signature as the host function body:</p>
<pre><code class="language-c">typedef WasmEdge_Result (*WasmEdge_HostFunc_t)(
  void *Data,
  WasmEdge_MemoryInstanceContext *MemCxt,
  const WasmEdge_Value *Params,
  WasmEdge_Value *Returns);
</code></pre>
<p>The example of an <code>add</code> host function to add 2 <code>i32</code> values:</p>
<pre><code class="language-c">WasmEdge_Result Add(void *, WasmEdge_MemoryInstanceContext *,
                    const WasmEdge_Value *In, WasmEdge_Value *Out) {
  /*
  * Params: {i32, i32}
  * Returns: {i32}
  * Developers should take care about the function type.
  */ 
  /* Retrieve the value 1. */
  int32_t Val1 = WasmEdge_ValueGetI32(In[0]);
  /* Retrieve the value 2. */
  int32_t Val2 = WasmEdge_ValueGetI32(In[1]);
  /* Output value 1 is Val1 + Val2. */
  Out[0] = WasmEdge_ValueGenI32(Val1 + Val2);
  /* Return the status of success. */
  return WasmEdge_Result_Success;
}
</code></pre>
<p>Then developers can create <code>Function</code> context with the host function body and the function type:</p>
<pre><code class="language-c">enum WasmEdge_ValType ParamList[2] = { WasmEdge_ValType_I32, WasmEdge_ValType_I32 };
enum WasmEdge_ValType ReturnList[1] = { WasmEdge_ValType_I32 };
/* Create a function type: {i32, i32} -&gt; {i32}. */
WasmEdge_FunctionTypeContext *HostFType = WasmEdge_FunctionTypeCreate(ParamList, 2, ReturnList, 1);
/* 
 * Create a function context with the function type and host function body.
 * The `Cost` parameter can be 0 if developers do not need the cost measuring.
 */
WasmEdge_FunctionInstanceContext *HostFunc = WasmEdge_FunctionInstanceCreate(HostFType, Add, NULL, 0);
/*
 * The third parameter is the pointer to the additional data.
 * Developers should guarantee the life cycle of the data, and it can be
 * `NULL` if the external data is not needed.
 */
WasmEdge_FunctionTypeDelete(HostType);

/* If the function instance is not added into a module instance context, it should be deleted. */
WasmEdge_FunctionInstanceDelete(HostFunc);
</code></pre>
</li>
<li>
<p>Construct a module instance with host instances</p>
<p>Besides creating a <code>Module</code> instance by registering or instantiating a WASM module, developers can create a <code>Module</code> instance with a module name and add the <code>Function</code>, <code>Memory</code>, <code>Table</code>, and <code>Global</code> instances into it with their exporting names.</p>
<pre><code class="language-c">/* Host function body definition. */
WasmEdge_Result Add(void *Data, WasmEdge_MemoryInstanceContext *MemCxt,
                    const WasmEdge_Value *In, WasmEdge_Value *Out) {
  int32_t Val1 = WasmEdge_ValueGetI32(In[0]);
  int32_t Val2 = WasmEdge_ValueGetI32(In[1]);
  Out[0] = WasmEdge_ValueGenI32(Val1 + Val2);
  return WasmEdge_Result_Success;
}

/* Create a module instance. */
WasmEdge_String ExportName = WasmEdge_StringCreateByCString(&quot;module&quot;);
WasmEdge_ModuleInstanceContext *HostModCxt = WasmEdge_ModuleInstanceCreate(ExportName);
WasmEdge_StringDelete(ExportName);

/* Create and add a function instance into the module instance. */
enum WasmEdge_ValType ParamList[2] = { WasmEdge_ValType_I32, WasmEdge_ValType_I32 };
enum WasmEdge_ValType ReturnList[1] = { WasmEdge_ValType_I32 };
WasmEdge_FunctionTypeContext *HostFType = 
  WasmEdge_FunctionTypeCreate(ParamList, 2, ReturnList, 1);
WasmEdge_FunctionInstanceContext *HostFunc =
  WasmEdge_FunctionInstanceCreate(HostFType, Add, NULL, 0);
/*
 * The third parameter is the pointer to the additional data object.
 * Developers should guarantee the life cycle of the data, and it can be
 * `NULL` if the external data is not needed.
 */
WasmEdge_FunctionTypeDelete(HostFType);
WasmEdge_String FuncName = WasmEdge_StringCreateByCString(&quot;add&quot;);
WasmEdge_ModuleInstanceAddFunction(HostModCxt, FuncName, HostFunc);
WasmEdge_StringDelete(FuncName);

/* Create and add a table instance into the import object. */
WasmEdge_Limit TableLimit = {.HasMax = true, .Shared = false, .Min = 10, .Max = 20};
WasmEdge_TableTypeContext *HostTType = 
  WasmEdge_TableTypeCreate(WasmEdge_RefType_FuncRef, TableLimit);
WasmEdge_TableInstanceContext *HostTable = WasmEdge_TableInstanceCreate(HostTType);
WasmEdge_TableTypeDelete(HostTType);
WasmEdge_String TableName = WasmEdge_StringCreateByCString(&quot;table&quot;);
WasmEdge_ModuleInstanceAddTable(HostModCxt, TableName, HostTable);
WasmEdge_StringDelete(TableName);

/* Create and add a memory instance into the import object. */
WasmEdge_Limit MemoryLimit = {.HasMax = true, .Shared = false, .Min = 1, .Max = 2};
WasmEdge_MemoryTypeContext *HostMType = WasmEdge_MemoryTypeCreate(MemoryLimit);
WasmEdge_MemoryInstanceContext *HostMemory = WasmEdge_MemoryInstanceCreate(HostMType);
WasmEdge_MemoryTypeDelete(HostMType);
WasmEdge_String MemoryName = WasmEdge_StringCreateByCString(&quot;memory&quot;);
WasmEdge_ModuleInstanceAddMemory(HostModCxt, MemoryName, HostMemory);
WasmEdge_StringDelete(MemoryName);

/* Create and add a global instance into the module instance. */
WasmEdge_GlobalTypeContext *HostGType =
  WasmEdge_GlobalTypeCreate(WasmEdge_ValType_I32, WasmEdge_Mutability_Var);
WasmEdge_GlobalInstanceContext *HostGlobal =
  WasmEdge_GlobalInstanceCreate(HostGType, WasmEdge_ValueGenI32(666));
WasmEdge_GlobalTypeDelete(HostGType);
WasmEdge_String GlobalName = WasmEdge_StringCreateByCString(&quot;global&quot;);
WasmEdge_ModuleInstanceAddGlobal(HostModCxt, GlobalName, HostGlobal);
WasmEdge_StringDelete(GlobalName);

/*
 * The module instance should be deleted.
 * Developers should __NOT__ destroy the instances added into the module instance contexts.
 */
WasmEdge_ModuleInstanceDelete(HostModCxt);
</code></pre>
</li>
<li>
<p>Specified module instance</p>
<p><code>WasmEdge_ModuleInstanceCreateWASI()</code> API can create and initialize the <code>WASI</code> module instance.</p>
<p><code>WasmEdge_ModuleInstanceCreateWasiNN()</code> API can create and initialize the <code>wasi_ephemeral_nn</code> module instance for <code>WASI-NN</code> plugin (<code>0.10.1</code> or upper only).</p>
<p><code>WasmEdge_ModuleInstanceCreateWasiCryptoCommon()</code> API can create and initialize the <code>wasi_ephemeral_crypto_common</code> module instance for <code>WASI-Crypto</code> plugin (<code>0.10.1</code> or upper only).</p>
<p><code>WasmEdge_ModuleInstanceCreateWasiCryptoAsymmetricCommon()</code> API can create and initialize the <code>wasi_ephemeral_crypto_asymmetric_common</code> module instance for <code>WASI-Crypto</code> plugin (<code>0.10.1</code> or upper only).</p>
<p><code>WasmEdge_ModuleInstanceCreateWasiCryptoKx()</code> API can create and initialize the <code>wasi_ephemeral_crypto_kx</code> module instance for <code>WASI-Crypto</code> plugin (<code>0.10.1</code> or upper only).</p>
<p><code>WasmEdge_ModuleInstanceCreateWasiCryptoSignatures()</code> API can create and initialize the <code>wasi_ephemeral_crypto_signatures</code> module instance for <code>WASI-Crypto</code> plugin (<code>0.10.1</code> or upper only).</p>
<p><code>WasmEdge_ModuleInstanceCreateWasiCryptoSymmetric()</code> API can create and initialize the <code>wasi_ephemeral_crypto_symmetric</code> module instance for <code>WASI-Crypto</code> plugin (<code>0.10.1</code> or upper only).</p>
<p><code>WasmEdge_ModuleInstanceCreateWasmEdgeProcess()</code> API can create and initialize the <code>wasmedge_process</code> module instance for <code>wasmedge_process</code> plugin.</p>
<p>Developers can create these module instance contexts and register them into the <code>Store</code> or <code>VM</code> contexts rather than adjust the settings in the <code>Configure</code> contexts.</p>
<blockquote>
<p>Note: For the <code>WASI-NN</code> plugin, please check that the <a href="sdk/c/0.10.1/../../../write_wasm/rust/wasinn.html#prerequisites">dependencies and prerequests</a> are satisfied.
Note: For the <code>WASI-Crypto</code> plugin, please check that the <a href="sdk/c/0.10.1/../../../write_wasm/rust/wasicrypto.html#prerequisites">dependencies and prerequests</a> are satisfied. And the 5 modules are recommended to all be created and registered together.</p>
</blockquote>
<pre><code class="language-c">WasmEdge_ModuleInstanceContext *WasiModCxt = WasmEdge_ModuleInstanceCreateWASI( /* ... ignored */ );
WasmEdge_ModuleInstanceContext *ProcModCxt = WasmEdge_ModuleInstanceCreateWasmEdgeProcess( /* ... ignored */ );
WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(NULL, NULL);
/* Register the WASI and WasmEdge_Process into the VM context. */
WasmEdge_VMRegisterModuleFromImport(VMCxt, WasiModCxt);
WasmEdge_VMRegisterModuleFromImport(VMCxt, ProcModCxt);
/* Get the WASI exit code. */
uint32_t ExitCode = WasmEdge_ModuleInstanceWASIGetExitCode(WasiModCxt);
/*
 * The `ExitCode` will be EXIT_SUCCESS if the execution has no error.
 * Otherwise, it will return with the related exit code.
 */
WasmEdge_VMDelete(VMCxt);
/* The module instances should be deleted. */
WasmEdge_ModuleInstanceDelete(WasiModCxt);
WasmEdge_ModuleInstanceDelete(ProcModCxt);
</code></pre>
</li>
<li>
<p>Example</p>
<p>Assume that a simple WASM from the WAT as following:</p>
<pre><code class="language-wasm">(module
  (type $t0 (func (param i32 i32) (result i32)))
  (import &quot;extern&quot; &quot;func-add&quot; (func $f-add (type $t0)))
  (func (export &quot;addTwo&quot;) (param i32 i32) (result i32)
    local.get 0
    local.get 1
    call $f-add)
)
</code></pre>
<p>And the <code>test.c</code> as following:</p>
<pre><code class="language-c">#include &lt;wasmedge/wasmedge.h&gt;
#include &lt;stdio.h&gt;

/* Host function body definition. */
WasmEdge_Result Add(void *Data, WasmEdge_MemoryInstanceContext *MemCxt,
                    const WasmEdge_Value *In, WasmEdge_Value *Out) {
  int32_t Val1 = WasmEdge_ValueGetI32(In[0]);
  int32_t Val2 = WasmEdge_ValueGetI32(In[1]);
  printf(&quot;Host function \&quot;Add\&quot;: %d + %d\n&quot;, Val1, Val2);
  Out[0] = WasmEdge_ValueGenI32(Val1 + Val2);
  return WasmEdge_Result_Success;
}

int main() {
  /* Create the VM context. */
  WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(NULL, NULL);

  /* The WASM module buffer. */
  uint8_t WASM[] = {
    /* WASM header */
    0x00, 0x61, 0x73, 0x6D, 0x01, 0x00, 0x00, 0x00,
    /* Type section */
    0x01, 0x07, 0x01,
    /* function type {i32, i32} -&gt; {i32} */
    0x60, 0x02, 0x7F, 0x7F, 0x01, 0x7F,
    /* Import section */
    0x02, 0x13, 0x01,
    /* module name: &quot;extern&quot; */
    0x06, 0x65, 0x78, 0x74, 0x65, 0x72, 0x6E,
    /* extern name: &quot;func-add&quot; */
    0x08, 0x66, 0x75, 0x6E, 0x63, 0x2D, 0x61, 0x64, 0x64,
    /* import desc: func 0 */
    0x00, 0x00,
    /* Function section */
    0x03, 0x02, 0x01, 0x00,
    /* Export section */
    0x07, 0x0A, 0x01,
    /* export name: &quot;addTwo&quot; */
    0x06, 0x61, 0x64, 0x64, 0x54, 0x77, 0x6F,
    /* export desc: func 0 */
    0x00, 0x01,
    /* Code section */
    0x0A, 0x0A, 0x01,
    /* code body */
    0x08, 0x00, 0x20, 0x00, 0x20, 0x01, 0x10, 0x00, 0x0B
  };

  /* Create the module instance. */
  WasmEdge_String ExportName = WasmEdge_StringCreateByCString(&quot;extern&quot;);
  WasmEdge_ModuleInstanceContext *HostModCxt = WasmEdge_ModuleInstanceCreate(ExportName);
  enum WasmEdge_ValType ParamList[2] = { WasmEdge_ValType_I32, WasmEdge_ValType_I32 };
  enum WasmEdge_ValType ReturnList[1] = { WasmEdge_ValType_I32 };
  WasmEdge_FunctionTypeContext *HostFType = WasmEdge_FunctionTypeCreate(ParamList, 2, ReturnList, 1);
  WasmEdge_FunctionInstanceContext *HostFunc = WasmEdge_FunctionInstanceCreate(HostFType, Add, NULL, 0);
  WasmEdge_FunctionTypeDelete(HostFType);
  WasmEdge_String HostFuncName = WasmEdge_StringCreateByCString(&quot;func-add&quot;);
  WasmEdge_ModuleInstanceAddFunction(HostModCxt, HostFuncName, HostFunc);
  WasmEdge_StringDelete(HostFuncName);

  WasmEdge_VMRegisterModuleFromImport(VMCxt, HostModCxt);

  /* The parameters and returns arrays. */
  WasmEdge_Value Params[2] = { WasmEdge_ValueGenI32(1234), WasmEdge_ValueGenI32(5678) };
  WasmEdge_Value Returns[1];
  /* Function name. */
  WasmEdge_String FuncName = WasmEdge_StringCreateByCString(&quot;addTwo&quot;);
  /* Run the WASM function from file. */
  WasmEdge_Result Res = WasmEdge_VMRunWasmFromBuffer(
    VMCxt, WASM, sizeof(WASM), FuncName, Params, 2, Returns, 1);

  if (WasmEdge_ResultOK(Res)) {
    printf(&quot;Get the result: %d\n&quot;, WasmEdge_ValueGetI32(Returns[0]));
  } else {
    printf(&quot;Error message: %s\n&quot;, WasmEdge_ResultGetMessage(Res));
  }

  /* Resources deallocations. */
  WasmEdge_VMDelete(VMCxt);
  WasmEdge_StringDelete(FuncName);
  WasmEdge_ModuleInstanceDelete(HostModCxt);
  return 0;
}
</code></pre>
<p>Then you can compile and run: (the result of 1234 + 5678 is 6912)</p>
<pre><code class="language-bash">$ gcc test.c -lwasmedge_c
$ ./a.out
Host function &quot;Add&quot;: 1234 + 5678
Get the result: 6912
</code></pre>
</li>
<li>
<p>Host Data Example</p>
<p>Developers can set a external data object to the <code>Function</code> context, and access to the object in the function body.
Assume that a simple WASM from the WAT as following:</p>
<pre><code class="language-wasm">(module
  (type $t0 (func (param i32 i32) (result i32)))
  (import &quot;extern&quot; &quot;func-add&quot; (func $f-add (type $t0)))
  (func (export &quot;addTwo&quot;) (param i32 i32) (result i32)
    local.get 0
    local.get 1
    call $f-add)
)
</code></pre>
<p>And the <code>test.c</code> as following:</p>
<pre><code class="language-c">#include &lt;wasmedge/wasmedge.h&gt;
#include &lt;stdio.h&gt;

/* Host function body definition. */
WasmEdge_Result Add(void *Data, WasmEdge_MemoryInstanceContext *MemCxt,
                    const WasmEdge_Value *In, WasmEdge_Value *Out) {
  int32_t Val1 = WasmEdge_ValueGetI32(In[0]);
  int32_t Val2 = WasmEdge_ValueGetI32(In[1]);
  printf(&quot;Host function \&quot;Add\&quot;: %d + %d\n&quot;, Val1, Val2);
  Out[0] = WasmEdge_ValueGenI32(Val1 + Val2);
  /* Also set the result to the data. */
  int32_t *DataPtr = (int32_t *)Data;
  *DataPtr = Val1 + Val2;
  return WasmEdge_Result_Success;
}

int main() {
  /* Create the VM context. */
  WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(NULL, NULL);

  /* The WASM module buffer. */
  uint8_t WASM[] = {
    /* WASM header */
    0x00, 0x61, 0x73, 0x6D, 0x01, 0x00, 0x00, 0x00,
    /* Type section */
    0x01, 0x07, 0x01,
    /* function type {i32, i32} -&gt; {i32} */
    0x60, 0x02, 0x7F, 0x7F, 0x01, 0x7F,
    /* Import section */
    0x02, 0x13, 0x01,
    /* module name: &quot;extern&quot; */
    0x06, 0x65, 0x78, 0x74, 0x65, 0x72, 0x6E,
    /* extern name: &quot;func-add&quot; */
    0x08, 0x66, 0x75, 0x6E, 0x63, 0x2D, 0x61, 0x64, 0x64,
    /* import desc: func 0 */
    0x00, 0x00,
    /* Function section */
    0x03, 0x02, 0x01, 0x00,
    /* Export section */
    0x07, 0x0A, 0x01,
    /* export name: &quot;addTwo&quot; */
    0x06, 0x61, 0x64, 0x64, 0x54, 0x77, 0x6F,
    /* export desc: func 0 */
    0x00, 0x01,
    /* Code section */
    0x0A, 0x0A, 0x01,
    /* code body */
    0x08, 0x00, 0x20, 0x00, 0x20, 0x01, 0x10, 0x00, 0x0B
  };

  /* The external data object: an integer. */
  int32_t Data;

  /* Create the module instance. */
  WasmEdge_String ExportName = WasmEdge_StringCreateByCString(&quot;extern&quot;);
  WasmEdge_ModuleInstanceContext *HostModCxt = WasmEdge_ModuleInstanceCreate(ExportName);
  enum WasmEdge_ValType ParamList[2] = { WasmEdge_ValType_I32, WasmEdge_ValType_I32 };
  enum WasmEdge_ValType ReturnList[1] = { WasmEdge_ValType_I32 };
  WasmEdge_FunctionTypeContext *HostFType = WasmEdge_FunctionTypeCreate(ParamList, 2, ReturnList, 1);
  WasmEdge_FunctionInstanceContext *HostFunc = WasmEdge_FunctionInstanceCreate(HostFType, Add, &amp;Data, 0);
  WasmEdge_FunctionTypeDelete(HostFType);
  WasmEdge_String HostFuncName = WasmEdge_StringCreateByCString(&quot;func-add&quot;);
  WasmEdge_ModuleInstanceAddFunction(HostModCxt, HostFuncName, HostFunc);
  WasmEdge_StringDelete(HostFuncName);

  WasmEdge_VMRegisterModuleFromImport(VMCxt, HostModCxt);

  /* The parameters and returns arrays. */
  WasmEdge_Value Params[2] = { WasmEdge_ValueGenI32(1234), WasmEdge_ValueGenI32(5678) };
  WasmEdge_Value Returns[1];
  /* Function name. */
  WasmEdge_String FuncName = WasmEdge_StringCreateByCString(&quot;addTwo&quot;);
  /* Run the WASM function from file. */
  WasmEdge_Result Res = WasmEdge_VMRunWasmFromBuffer(
    VMCxt, WASM, sizeof(WASM), FuncName, Params, 2, Returns, 1);

  if (WasmEdge_ResultOK(Res)) {
    printf(&quot;Get the result: %d\n&quot;, WasmEdge_ValueGetI32(Returns[0]));
  } else {
    printf(&quot;Error message: %s\n&quot;, WasmEdge_ResultGetMessage(Res));
  }
  printf(&quot;Data value: %d\n&quot;, Data);

  /* Resources deallocations. */
  WasmEdge_VMDelete(VMCxt);
  WasmEdge_StringDelete(FuncName);
  WasmEdge_ModuleInstanceDelete(HostModCxt);
  return 0;
}
</code></pre>
<p>Then you can compile and run: (the result of 1234 + 5678 is 6912)</p>
<pre><code class="language-bash">$ gcc test.c -lwasmedge_c
$ ./a.out
Host function &quot;Add&quot;: 1234 + 5678
Get the result: 6912
Data value: 6912
</code></pre>
</li>
</ol>
<h2 id="wasmedge-aot-compiler-1"><a class="header" href="#wasmedge-aot-compiler-1">WasmEdge AOT Compiler</a></h2>
<p>In this partition, we will introduce the WasmEdge AOT compiler and the options.</p>
<p>WasmEdge runs the WASM files in interpreter mode, and WasmEdge also supports the AOT (ahead-of-time) mode running without modifying any code.
The WasmEdge AOT (ahead-of-time) compiler compiles the WASM files for running in AOT mode which is much faster than interpreter mode. Developers can compile the WASM files into the compiled-WASM files in shared library format for universal WASM format for the AOT mode execution.</p>
<h3 id="compilation-example-1"><a class="header" href="#compilation-example-1">Compilation Example</a></h3>
<p>Assume that the WASM file <a href="https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/examples/wasm/fibonacci.wasm"><code>fibonacci.wasm</code></a> is copied into the current directory, and the C file <code>test.c</code> is as following:</p>
<pre><code class="language-c">#include &lt;wasmedge/wasmedge.h&gt;
#include &lt;stdio.h&gt;
int main() {
  /* Create the configure context. */
  WasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();
  /* ... Adjust settings in the configure context. */
  /* Result. */
  WasmEdge_Result Res;

  /* Create the compiler context. The configure context can be NULL. */
  WasmEdge_CompilerContext *CompilerCxt = WasmEdge_CompilerCreate(ConfCxt);
  /* Compile the WASM file with input and output paths. */
  Res = WasmEdge_CompilerCompile(CompilerCxt, &quot;fibonacci.wasm&quot;, &quot;fibonacci.wasm.so&quot;);
  if (!WasmEdge_ResultOK(Res)) {
      printf(&quot;Compilation failed: %s\n&quot;, WasmEdge_ResultGetMessage(Res));
      return 1;
  }

  WasmEdge_CompilerDelete(CompilerCxt);
  WasmEdge_ConfigureDelete(ConfCxt);
  return 0;
}
</code></pre>
<p>Then you can compile and run (the output file is &quot;fibonacci.wasm.so&quot;):</p>
<pre><code class="language-bash">$ gcc test.c -lwasmedge_c
$ ./a.out
[2021-07-02 11:08:08.651] [info] compile start
[2021-07-02 11:08:08.653] [info] verify start
[2021-07-02 11:08:08.653] [info] optimize start
[2021-07-02 11:08:08.670] [info] codegen start
[2021-07-02 11:08:08.706] [info] compile done
</code></pre>
<h3 id="compiler-options-1"><a class="header" href="#compiler-options-1">Compiler Options</a></h3>
<p>Developers can set options for AOT compilers such as optimization level and output format:</p>
<pre><code class="language-c">/// AOT compiler optimization level enumeration.
enum WasmEdge_CompilerOptimizationLevel {
  /// Disable as many optimizations as possible.
  WasmEdge_CompilerOptimizationLevel_O0 = 0,
  /// Optimize quickly without destroying debuggability.
  WasmEdge_CompilerOptimizationLevel_O1,
  /// Optimize for fast execution as much as possible without triggering
  /// significant incremental compile time or code size growth.
  WasmEdge_CompilerOptimizationLevel_O2,
  /// Optimize for fast execution as much as possible.
  WasmEdge_CompilerOptimizationLevel_O3,
  /// Optimize for small code size as much as possible without triggering
  /// significant incremental compile time or execution time slowdowns.
  WasmEdge_CompilerOptimizationLevel_Os,
  /// Optimize for small code size as much as possible.
  WasmEdge_CompilerOptimizationLevel_Oz
};

/// AOT compiler output binary format enumeration.
enum WasmEdge_CompilerOutputFormat {
  /// Native dynamic library format.
  WasmEdge_CompilerOutputFormat_Native = 0,
  /// WebAssembly with AOT compiled codes in custom sections.
  WasmEdge_CompilerOutputFormat_Wasm
};
</code></pre>
<p>Please refer to the <a href="sdk/c/0.10.1/ref.html#configurations">AOT compiler options configuration</a> for details.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="upgrade-to-wasmedge-0110"><a class="header" href="#upgrade-to-wasmedge-0110">Upgrade to WasmEdge 0.11.0</a></h1>
<p>Due to the WasmEdge C API breaking changes, this document shows the guideline for programming with WasmEdge C API to upgrade from the <code>0.10.1</code> to the <code>0.11.0</code> version.</p>
<h2 id="concepts"><a class="header" href="#concepts">Concepts</a></h2>
<ol>
<li>
<p>Supported the user-defined error code in host functions.</p>
<p>Developers can use the new API <code>WasmEdge_ResultGen()</code> to generate a <code>WasmEdge_Result</code> struct with <code>WasmEdge_ErrCategory_UserLevelError</code> and the error code.
With this support, developers can specify the host function error code when failed by themselves.
For the examples to specify the user-defined error code, please refer to <a href="sdk/c/0.10.1/upgrade_to_0.11.0.html#user-defined-error-code-in-host-functions">the example below</a>.</p>
</li>
<li>
<p>Calling frame for the host function extension</p>
<p>In the previous versions, host functions only pass the memory instance into the function body.
For supporting the WASM multiple memories proposal and providing the recursive invocation in host functions, the new context <code>WasmEdge_CallingFrameContext</code> replaced the memory instance in the second argument of the host function definition.
For the examples of the new host function definition, please refer to <a href="sdk/c/0.10.1/upgrade_to_0.11.0.html#calling-frame-in-host-functions">the example below</a>.</p>
</li>
<li>
<p>Apply the SONAME and SOVERSION.</p>
<p>When linking the WasmEdge shared library, please notice that <code>libwasmedge_c.so</code> is renamed to <code>libwasmedge.so</code> after the 0.11.0 release.
Please use <code>-lwasmedge</code> instead of <code>-lwasmedge_c</code> for the linker option.</p>
</li>
</ol>
<h2 id="user-defined-error-code-in-host-functions"><a class="header" href="#user-defined-error-code-in-host-functions">User Defined Error Code In Host Functions</a></h2>
<p>Assume that we want to specify that the host function failed in the versions before <code>0.10.1</code>:</p>
<pre><code class="language-c">/* Host function body definition. */
WasmEdge_Result FaildFunc(void *Data, WasmEdge_MemoryInstanceContext *MemCxt,
                          const WasmEdge_Value *In, WasmEdge_Value *Out) {
  /* This will create a trap in WASM. */
  return WasmEdge_Result_Fail;
}
</code></pre>
<p>When the execution is finished, developers will get the <code>WasmEdge_Result</code>.
If developers call the <code>WasmEdge_ResultOK()</code> with the returned result, they will get <code>false</code>.
If developers call the <code>WasmEdge_ResultGetCode()</code> with the returned result, they will always get <code>2</code>.</p>
<p>For the versions after <code>0.11.0</code>, developers can specify the error code within 24-bit (smaller than <code>16777216</code>) size.</p>
<pre><code class="language-c">/* Host function body definition. */
WasmEdge_Result FaildFunc(void *Data,
                          const WasmEdge_CallingFrameContext *CallFrameCxt,
                          const WasmEdge_Value *In, WasmEdge_Value *Out) {
  /* This will create a trap in WASM with the error code. */
  return WasmEdge_ResultGen(WasmEdge_ErrCategory_UserLevelError, 12345678);
}
</code></pre>
<p>Therefore when developers call the <code>WasmEdge_ResultGetCode()</code> with the returned result, they will get the error code <code>12345678</code>.
Noticed that if developers call the <code>WasmEdge_ResultGetMessage()</code>, they will always get the C string <code>&quot;user defined error code&quot;</code>.</p>
<h2 id="calling-frame-in-host-functions"><a class="header" href="#calling-frame-in-host-functions">Calling Frame In Host Functions</a></h2>
<p>When implementing the host functions, developers usually use the input memory instance to load or store data.
In the WasmEdge versions before <code>0.10.1</code>, the argument before the input and return value list of the host function definition is the memory instance context, so that developers can access the data in the memory instance.</p>
<pre><code class="language-c">/* Host function body definition. */
WasmEdge_Result LoadOffset(void *Data, WasmEdge_MemoryInstanceContext *MemCxt,
                           const WasmEdge_Value *In, WasmEdge_Value *Out) {
  /* Function type: {i32} -&gt; {} */
  uint32_t Offset = (uint32_t)WasmEdge_ValueGetI32(In[0]);
  uint32_t Num = 0;
  WasmEdge_Result Res =
      WasmEdge_MemoryInstanceGetData(MemCxt, (uint8_t *)(&amp;Num), Offset, 4);
  if (WasmEdge_ResultOK(Res)) {
    printf(&quot;u32 at memory[%u]: %u\n&quot;, Offset, Num);
  } else {
    return Res;
  }
  return WasmEdge_Result_Success;
}
</code></pre>
<p>The input memory instance is the one that belongs to the module instance on the top calling frame of the stack.
However, after applying the WASM multiple memories proposal, there may be more than 1 memory instance in a WASM module.
Furthermore, there may be requests for accessing the module instance on the top frame of the stack to get the exported WASM functions, such as recursive invocation in host functions.
To support these, the <code>WasmEdge_CallingFrameContext</code> is designed to replace the memory instance input of the host function.</p>
<p>In the WasmEdge versions after <code>0.11.0</code>, the host function definitions are changed:</p>
<pre><code class="language-c">typedef WasmEdge_Result (*WasmEdge_HostFunc_t)(
    void *Data, const WasmEdge_CallingFrameContext *CallFrameCxt,
    const WasmEdge_Value *Params, WasmEdge_Value *Returns);

typedef WasmEdge_Result (*WasmEdge_WrapFunc_t)(
    void *This, void *Data, const WasmEdge_CallingFrameContext *CallFrameCxt,
    const WasmEdge_Value *Params, const uint32_t ParamLen,
    WasmEdge_Value *Returns, const uint32_t ReturnLen);
</code></pre>
<p>Developers need to change to use the <code>WasmEdge_CallingFrameContext</code> related APIs to access the memory instance:</p>
<pre><code class="language-c">/* Host function body definition. */
WasmEdge_Result LoadOffset(void *Data,
                           const WasmEdge_CallingFrameContext *CallFrameCxt,
                           const WasmEdge_Value *In, WasmEdge_Value *Out) {
  /* Function type: {i32} -&gt; {} */
  uint32_t Offset = (uint32_t)WasmEdge_ValueGetI32(In[0]);
  uint32_t Num = 0;

  /* Get the 0th memory instance of the module of the top frame on the stack. */
  WasmEdge_MemoryInstanceContext *MemCxt =
      WasmEdge_CallingFrameGetMemoryInstance(CallFrameCxt, 0);
  WasmEdge_Result Res =
      WasmEdge_MemoryInstanceGetData(MemCxt, (uint8_t *)(&amp;Num), Offset, 4);
  if (WasmEdge_ResultOK(Res)) {
    printf(&quot;u32 at memory[%u]: %u\n&quot;, Offset, Num);
  } else {
    return Res;
  }
  return WasmEdge_Result_Success;
}
</code></pre>
<p>The <code>WasmEdge_CallingFrameGetModuleInstance()</code> API can help developers to get the module instance of the top frame on the stack.
With the module instance context, developers can use the module instance-related APIs to get its contents.</p>
<p>The <code>WasmEdge_CallingFrameGetExecutor()</code> API can help developers to get the currently used executor context.
Therefore developers can use the executor to recursively invoke other WASM functions without creating a new executor context.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="wasmedge-091-c-api-documentation"><a class="header" href="#wasmedge-091-c-api-documentation">WasmEdge 0.9.1 C API Documentation</a></h1>
<p><a href="https://github.com/WasmEdge/WasmEdge/blob/0.9.1/include/api/wasmedge/wasmedge.h">WasmEdge C API</a> denotes an interface to access the WasmEdge runtime at version <code>0.9.1</code>. The followings are the guides to working with the C APIs of WasmEdge.</p>
<p><strong>Developers can refer <a href="sdk/c/0.9.1/upgrade_to_0.10.0.html">here to upgrade to 0.10.0</a>.</strong></p>
<h2 id="table-of-contents-3"><a class="header" href="#table-of-contents-3">Table of Contents</a></h2>
<ul>
<li><a href="sdk/c/0.9.1/ref.html#wasmedge-installation">WasmEdge Installation</a>
<ul>
<li><a href="sdk/c/0.9.1/ref.html#download-and-install">Download And Install</a></li>
<li><a href="sdk/c/0.9.1/ref.html#compile-sources">Compile Sources</a></li>
</ul>
</li>
<li><a href="sdk/c/0.9.1/ref.html#wasmedge-basics">WasmEdge Basics</a>
<ul>
<li><a href="sdk/c/0.9.1/ref.html#version">Version</a></li>
<li><a href="sdk/c/0.9.1/ref.html#logging-settings">Logging Settings</a></li>
<li><a href="sdk/c/0.9.1/ref.html#value-types">Value Types</a></li>
<li><a href="sdk/c/0.9.1/ref.html#strings">Strings</a></li>
<li><a href="sdk/c/0.9.1/ref.html#results">Results</a></li>
<li><a href="sdk/c/0.9.1/ref.html#contexts">Contexts</a></li>
<li><a href="sdk/c/0.9.1/ref.html#wasm-data-structures">WASM data structures</a></li>
<li><a href="sdk/c/0.9.1/ref.html#async">Async</a></li>
<li><a href="sdk/c/0.9.1/ref.html#configurations">Configurations</a></li>
<li><a href="sdk/c/0.9.1/ref.html#statistics">Statistics</a></li>
</ul>
</li>
<li><a href="sdk/c/0.9.1/ref.html#wasmedge-vm">WasmEdge VM</a>
<ul>
<li><a href="sdk/c/0.9.1/ref.html#wasm-execution-example-with-vm-context">WASM Execution Example With VM Context</a></li>
<li><a href="sdk/c/0.9.1/ref.html#vm-creations">VM Creations</a></li>
<li><a href="sdk/c/0.9.1/ref.html#preregistrations">Preregistrations</a></li>
<li><a href="sdk/c/0.9.1/ref.html#host-module-registrations">Host Module Registrations</a></li>
<li><a href="sdk/c/0.9.1/ref.html#wasm-registrations-and-executions">WASM Registrations And Executions</a></li>
<li><a href="sdk/c/0.9.1/ref.html#asynchronous-execution">Asynchronous execution</a></li>
<li><a href="sdk/c/0.9.1/ref.html#instance-tracing">Instance Tracing</a></li>
</ul>
</li>
<li><a href="sdk/c/0.9.1/ref.html#wasmedge-runtime">WasmEdge Runtime</a>
<ul>
<li><a href="sdk/c/0.9.1/ref.html#wasm-execution-example-step-by-step">WASM Execution Example Step-By-Step</a></li>
<li><a href="sdk/c/0.9.1/ref.html#loader">Loader</a></li>
<li><a href="sdk/c/0.9.1/ref.html#validator">Validator</a></li>
<li><a href="sdk/c/0.9.1/ref.html#executor">Executor</a></li>
<li><a href="sdk/c/0.9.1/ref.html#ast-module">AST Module</a></li>
<li><a href="sdk/c/0.9.1/ref.html#store">Store</a></li>
<li><a href="sdk/c/0.9.1/ref.html#instances">Instances</a></li>
<li><a href="sdk/c/0.9.1/ref.html#host-functions">Host Functions</a></li>
</ul>
</li>
<li><a href="sdk/c/0.9.1/ref.html#wasmedge-aot-compiler">WasmEdge AOT Compiler</a>
<ul>
<li><a href="sdk/c/0.9.1/ref.html#compilation-example">Compilation Example</a></li>
<li><a href="sdk/c/0.9.1/ref.html#compiler-options">Compiler Options</a></li>
</ul>
</li>
</ul>
<h2 id="wasmedge-installation-2"><a class="header" href="#wasmedge-installation-2">WasmEdge Installation</a></h2>
<h3 id="download-and-install-2"><a class="header" href="#download-and-install-2">Download And Install</a></h3>
<p>The easiest way to install WasmEdge is to run the following command. Your system should have <code>git</code> and <code>wget</code> as prerequisites.</p>
<pre><code class="language-bash">curl -sSf https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/utils/install.sh | bash -s -- -v 0.9.1
</code></pre>
<p>For more details, please refer to the <a href="sdk/c/0.9.1/../../../quick_start/install.html">Installation Guide</a> for the WasmEdge installation.</p>
<h3 id="compile-sources-2"><a class="header" href="#compile-sources-2">Compile Sources</a></h3>
<p>After the installation of WasmEdge, the following guide can help you to test for the availability of the WasmEdge C API.</p>
<ol>
<li>
<p>Prepare the test C file (and assumed saved as <code>test.c</code>):</p>
<pre><code class="language-c">#include &lt;wasmedge/wasmedge.h&gt;
#include &lt;stdio.h&gt;
int main() {
  printf(&quot;WasmEdge version: %s\n&quot;, WasmEdge_VersionGet());
  return 0;
}
</code></pre>
</li>
<li>
<p>Compile the file with <code>gcc</code> or <code>clang</code>.</p>
<pre><code class="language-bash">gcc test.c -lwasmedge_c
</code></pre>
</li>
<li>
<p>Run and get the expected output.</p>
<pre><code class="language-bash">$ ./a.out
WasmEdge version: 0.9.1
</code></pre>
</li>
</ol>
<h2 id="wasmedge-basics-2"><a class="header" href="#wasmedge-basics-2">WasmEdge Basics</a></h2>
<p>In this part, we will introduce the utilities and concepts of WasmEdge shared library.</p>
<h3 id="version-2"><a class="header" href="#version-2">Version</a></h3>
<p>The <code>Version</code> related APIs provide developers to check for the WasmEdge shared library version.</p>
<pre><code class="language-c">#include &lt;wasmedge/wasmedge.h&gt;
printf(&quot;WasmEdge version: %s\n&quot;, WasmEdge_VersionGet());
printf(&quot;WasmEdge version major: %u\n&quot;, WasmEdge_VersionGetMajor());
printf(&quot;WasmEdge version minor: %u\n&quot;, WasmEdge_VersionGetMinor());
printf(&quot;WasmEdge version patch: %u\n&quot;, WasmEdge_VersionGetPatch());
</code></pre>
<h3 id="logging-settings-2"><a class="header" href="#logging-settings-2">Logging Settings</a></h3>
<p>The <code>WasmEdge_LogSetErrorLevel()</code> and <code>WasmEdge_LogSetDebugLevel()</code> APIs can set the logging system to debug level or error level. By default, the error level is set, and the debug info is hidden.</p>
<h3 id="value-types-2"><a class="header" href="#value-types-2">Value Types</a></h3>
<p>In WasmEdge, developers should convert the values to <code>WasmEdge_Value</code> objects through APIs for matching to the WASM value types.</p>
<ol>
<li>
<p>Number types: <code>i32</code>, <code>i64</code>, <code>f32</code>, <code>f64</code>, and <code>v128</code> for the <code>SIMD</code> proposal</p>
<pre><code class="language-c">WasmEdge_Value Val;
Val = WasmEdge_ValueGenI32(123456);
printf(&quot;%d\n&quot;, WasmEdge_ValueGetI32(Val));
/* Will print &quot;123456&quot; */
Val = WasmEdge_ValueGenI64(1234567890123LL);
printf(&quot;%ld\n&quot;, WasmEdge_ValueGetI64(Val));
/* Will print &quot;1234567890123&quot; */
Val = WasmEdge_ValueGenF32(123.456f);
printf(&quot;%f\n&quot;, WasmEdge_ValueGetF32(Val));
/* Will print &quot;123.456001&quot; */
Val = WasmEdge_ValueGenF64(123456.123456789);
printf(&quot;%.10f\n&quot;, WasmEdge_ValueGetF64(Val));
/* Will print &quot;123456.1234567890&quot; */
</code></pre>
</li>
<li>
<p>Reference types: <code>funcref</code> and <code>externref</code> for the <code>Reference-Types</code> proposal</p>
<pre><code class="language-c">WasmEdge_Value Val;
void *Ptr;
bool IsNull;
uint32_t Num = 10;
/* Genreate a externref to NULL. */
Val = WasmEdge_ValueGenNullRef(WasmEdge_RefType_ExternRef);
IsNull = WasmEdge_ValueIsNullRef(Val);
/* The `IsNull` will be `TRUE`. */
Ptr = WasmEdge_ValueGetExternRef(Val);
/* The `Ptr` will be `NULL`. */

/* Genreate a funcref with function index 20. */
Val = WasmEdge_ValueGenFuncRef(20);
uint32_t FuncIdx = WasmEdge_ValueGetFuncIdx(Val);
/* The `FuncIdx` will be 20. */

/* Genreate a externref to `Num`. */
Val = WasmEdge_ValueGenExternRef(&amp;Num);
Ptr = WasmEdge_ValueGetExternRef(Val);
/* The `Ptr` will be `&amp;Num`. */
printf(&quot;%u\n&quot;, *(uint32_t *)Ptr);
/* Will print &quot;10&quot; */
Num += 55;
printf(&quot;%u\n&quot;, *(uint32_t *)Ptr);
/* Will print &quot;65&quot; */
</code></pre>
</li>
</ol>
<h3 id="strings-2"><a class="header" href="#strings-2">Strings</a></h3>
<p>The <code>WasmEdge_String</code> object is for the instance names when invoking a WASM function or finding the contexts of instances.</p>
<ol>
<li>
<p>Create a <code>WasmEdge_String</code> from a C string (<code>const char *</code> with NULL termination) or a buffer with length.</p>
<p>The content of the C string or buffer will be copied into the <code>WasmEdge_String</code> object.</p>
<pre><code class="language-c">char Buf[4] = {50, 55, 60, 65};
WasmEdge_String Str1 = WasmEdge_StringCreateByCString(&quot;test&quot;);
WasmEdge_String Str2 = WasmEdge_StringCreateByBuffer(Buf, 4);
/* The objects should be deleted by `WasmEdge_StringDelete()`. */
WasmEdge_StringDelete(Str1);
WasmEdge_StringDelete(Str2);
</code></pre>
</li>
<li>
<p>Wrap a <code>WasmEdge_String</code> to a buffer with length.</p>
<p>The content will not be copied, and the caller should guarantee the life cycle of the input buffer.</p>
<pre><code class="language-c">const char CStr[] = &quot;test&quot;;
WasmEdge_String Str = WasmEdge_StringWrap(CStr, 4);
/* The object should __NOT__ be deleted by `WasmEdge_StringDelete()`. */
</code></pre>
</li>
<li>
<p>String comparison</p>
<pre><code class="language-c">const char CStr[] = &quot;abcd&quot;;
char Buf[4] = {0x61, 0x62, 0x63, 0x64};
WasmEdge_String Str1 = WasmEdge_StringWrap(CStr, 4);
WasmEdge_String Str2 = WasmEdge_StringCreateByBuffer(Buf, 4);
bool IsEq = WasmEdge_StringIsEqual(Str1, Str2);
/* The `IsEq` will be `TRUE`. */
WasmEdge_StringDelete(Str2);
</code></pre>
</li>
<li>
<p>Convert to C string</p>
<pre><code class="language-c">char Buf[256];
WasmEdge_String Str = WasmEdge_StringCreateByCString(&quot;test_wasmedge_string&quot;);
uint32_t StrLength = WasmEdge_StringCopy(Str, Buf, sizeof(Buf));
/* StrLength will be 20 */
printf(&quot;String: %s\n&quot;, Buf);
/* Will print &quot;test_wasmedge_string&quot;. */
</code></pre>
</li>
</ol>
<h3 id="results-2"><a class="header" href="#results-2">Results</a></h3>
<p>The <code>WasmEdge_Result</code> object specifies the execution status.
APIs about WASM execution will return the <code>WasmEdge_Result</code> to denote the status.</p>
<pre><code class="language-c">WasmEdge_Result Res = WasmEdge_Result_Success;
bool IsSucceeded = WasmEdge_ResultOK(Res);
/* The `IsSucceeded` will be `TRUE`. */
uint32_t Code = WasmEdge_ResultGetCode(Res);
/* The `Code` will be 0. */
const char *Msg = WasmEdge_ResultGetMessage(Res);
/* The `Msg` will be &quot;success&quot;. */
</code></pre>
<h3 id="contexts-2"><a class="header" href="#contexts-2">Contexts</a></h3>
<p>The objects, such as <code>VM</code>, <code>Store</code>, and <code>Function</code>, are composed of <code>Context</code>s.
All of the contexts can be created by calling the corresponding creation APIs and should be destroyed by calling the corresponding deletion APIs. Developers have responsibilities to manage the contexts for memory management.</p>
<pre><code class="language-c">/* Create the configure context. */
WasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();
/* Delete the configure context. */
WasmEdge_ConfigureDelete(ConfCxt);
</code></pre>
<p>The details of other contexts will be introduced later.</p>
<h3 id="wasm-data-structures-2"><a class="header" href="#wasm-data-structures-2">WASM Data Structures</a></h3>
<p>The WASM data structures are used for creating instances or can be queried from instance contexts.
The details of instances creation will be introduced in the <a href="sdk/c/0.9.1/ref.html#instances">Instances</a>.</p>
<ol>
<li>
<p>Limit</p>
<p>The <code>WasmEdge_Limit</code> struct is defined in the header:</p>
<pre><code class="language-c">/// Struct of WASM limit.
typedef struct WasmEdge_Limit {
  /// Boolean to describe has max value or not.
  bool HasMax;
  /// Minimum value.
  uint32_t Min;
  /// Maximum value. Will be ignored if the `HasMax` is false.
  uint32_t Max;
} WasmEdge_Limit;
</code></pre>
<p>Developers can initialize the struct by assigning it's value, and the <code>Max</code> value is needed to be larger or equal to the <code>Min</code> value.
The API <code>WasmEdge_LimitIsEqual()</code> is provided to compare with 2 <code>WasmEdge_Limit</code> structs.</p>
</li>
<li>
<p>Function type context</p>
<p>The <code>Function Type</code> context is used for the <code>Function</code> creation, checking the value types of a <code>Function</code> instance, or getting the function type with function name from VM. Developers can use the <code>Function Type</code> context APIs to get the parameter or return value types information.</p>
<pre><code class="language-c">enum WasmEdge_ValType ParamList[2] = { WasmEdge_ValType_I32, WasmEdge_ValType_I64 };
enum WasmEdge_ValType ReturnList[1] = { WasmEdge_ValType_FuncRef };
WasmEdge_FunctionTypeContext *FuncTypeCxt = WasmEdge_FunctionTypeCreate(ParamList, 2, ReturnList, 1);

enum WasmEdge_ValType Buf[16];
uint32_t ParamLen = WasmEdge_FunctionTypeGetParametersLength(FuncTypeCxt);
/* `ParamLen` will be 2. */
uint32_t GotParamLen = WasmEdge_FunctionTypeGetParameters(FuncTypeCxt, Buf, 16);
/* `GotParamLen` will be 2, and `Buf[0]` and `Buf[1]` will be the same as `ParamList`. */
uint32_t ReturnLen = WasmEdge_FunctionTypeGetReturnsLength(FuncTypeCxt);
/* `ReturnLen` will be 1. */
uint32_t GotReturnLen = WasmEdge_FunctionTypeGetReturns(FuncTypeCxt, Buf, 16);
/* `GotReturnLen` will be 1, and `Buf[0]` will be the same as `ReturnList`. */

WasmEdge_FunctionTypeDelete(FuncTypeCxt);
</code></pre>
</li>
<li>
<p>Table type context</p>
<p>The <code>Table Type</code> context is used for <code>Table</code> instance creation or getting information from <code>Table</code> instances.</p>
<pre><code class="language-c">WasmEdge_Limit TabLim = {.HasMax = true, .Min = 10, .Max = 20};
WasmEdge_TableTypeContext *TabTypeCxt = WasmEdge_TableTypeCreate(WasmEdge_RefType_ExternRef, TabLim);

enum WasmEdge_RefType GotRefType = WasmEdge_TableTypeGetRefType(TabTypeCxt);
/* `GotRefType` will be WasmEdge_RefType_ExternRef. */
WasmEdge_Limit GotTabLim = WasmEdge_TableTypeGetLimit(TabTypeCxt);
/* `GotTabLim` will be the same value as `TabLim`. */

WasmEdge_TableTypeDelete(TabTypeCxt);
</code></pre>
</li>
<li>
<p>Memory type context</p>
<p>The <code>Memory Type</code> context is used for <code>Memory</code> instance creation or getting information from <code>Memory</code> instances.</p>
<pre><code class="language-c">WasmEdge_Limit MemLim = {.HasMax = true, .Min = 10, .Max = 20};
WasmEdge_MemoryTypeContext *MemTypeCxt = WasmEdge_MemoryTypeCreate(MemLim);

WasmEdge_Limit GotMemLim = WasmEdge_MemoryTypeGetLimit(MemTypeCxt);
/* `GotMemLim` will be the same value as `MemLim`. */

WasmEdge_MemoryTypeDelete(MemTypeCxt)
</code></pre>
</li>
<li>
<p>Global type context</p>
<p>The <code>Global Type</code> context is used for <code>Global</code> instance creation or getting information from <code>Global</code> instances.</p>
<pre><code class="language-c">WasmEdge_GlobalTypeContext *GlobTypeCxt = WasmEdge_GlobalTypeCreate(WasmEdge_ValType_F64, WasmEdge_Mutability_Var);

WasmEdge_ValType GotValType = WasmEdge_GlobalTypeGetValType(GlobTypeCxt);
/* `GotValType` will be WasmEdge_ValType_F64. */
WasmEdge_Mutability GotValMut = WasmEdge_GlobalTypeGetMutability(GlobTypeCxt);
/* `GotValMut` will be WasmEdge_Mutability_Var. */

WasmEdge_GlobalTypeDelete(GlobTypeCxt);
</code></pre>
</li>
<li>
<p>Import type context</p>
<p>The <code>Import Type</code> context is used for getting the imports information from a <a href="sdk/c/0.9.1/ref.html#ast-module">AST Module</a>.
Developers can get the external type (<code>function</code>, <code>table</code>, <code>memory</code>, or <code>global</code>), import module name, and external name from an <code>Import Type</code> context.
The details about querying <code>Import Type</code> contexts will be introduced in the <a href="sdk/c/0.9.1/ref.html#ast-module">AST Module</a>.</p>
<pre><code class="language-c">WasmEdge_ASTModuleContext *ASTCxt = ...;
/* Assume that `ASTCxt` is returned by the `WasmEdge_LoaderContext` for the result of loading a WASM file. */
const WasmEdge_ImportTypeContext *ImpType = ...;
/* Assume that `ImpType` is queried from the `ASTCxt` for the import. */

enum WasmEdge_ExternalType ExtType = WasmEdge_ImportTypeGetExternalType(ImpType);
/*
 * The `ExtType` can be one of `WasmEdge_ExternalType_Function`, `WasmEdge_ExternalType_Table`,
 * `WasmEdge_ExternalType_Memory`, or `WasmEdge_ExternalType_Global`.
 */
WasmEdge_String ModName = WasmEdge_ImportTypeGetModuleName(ImpType);
WasmEdge_String ExtName = WasmEdge_ImportTypeGetExternalName(ImpType);
/* The `ModName` and `ExtName` should not be destroyed and the string buffers are binded into the `ASTCxt`. */
const WasmEdge_FunctionTypeContext *FuncTypeCxt = WasmEdge_ImportTypeGetFunctionType(ASTCxt, ImpType);
/* If the `ExtType` is not `WasmEdge_ExternalType_Function`, the `FuncTypeCxt` will be NULL. */
const WasmEdge_TableTypeContext *TabTypeCxt = WasmEdge_ImportTypeGetTableType(ASTCxt, ImpType);
/* If the `ExtType` is not `WasmEdge_ExternalType_Table`, the `TabTypeCxt` will be NULL. */
const WasmEdge_MemoryTypeContext *MemTypeCxt = WasmEdge_ImportTypeGetMemoryType(ASTCxt, ImpType);
/* If the `ExtType` is not `WasmEdge_ExternalType_Memory`, the `MemTypeCxt` will be NULL. */
const WasmEdge_GlobalTypeContext *GlobTypeCxt = WasmEdge_ImportTypeGetGlobalType(ASTCxt, ImpType);
/* If the `ExtType` is not `WasmEdge_ExternalType_Global`, the `GlobTypeCxt` will be NULL. */
</code></pre>
</li>
<li>
<p>Export type context</p>
<p>The <code>Export Type</code> context is used for getting the exports information from a <a href="sdk/c/0.9.1/ref.html#ast-module">AST Module</a>.
Developers can get the external type (<code>function</code>, <code>table</code>, <code>memory</code>, or <code>global</code>) and external name from an <code>Export Type</code> context.
The details about querying <code>Export Type</code> contexts will be introduced in the <a href="sdk/c/0.9.1/ref.html#ast-module">AST Module</a>.</p>
<pre><code class="language-c">WasmEdge_ASTModuleContext *ASTCxt = ...;
/* Assume that `ASTCxt` is returned by the `WasmEdge_LoaderContext` for the result of loading a WASM file. */
const WasmEdge_ExportTypeContext *ExpType = ...;
/* Assume that `ExpType` is queried from the `ASTCxt` for the export. */

enum WasmEdge_ExternalType ExtType = WasmEdge_ExportTypeGetExternalType(ExpType);
/*
 * The `ExtType` can be one of `WasmEdge_ExternalType_Function`, `WasmEdge_ExternalType_Table`,
 * `WasmEdge_ExternalType_Memory`, or `WasmEdge_ExternalType_Global`.
 */
WasmEdge_String ExtName = WasmEdge_ExportTypeGetExternalName(ExpType);
/* The `ExtName` should not be destroyed and the string buffer is binded into the `ASTCxt`. */
const WasmEdge_FunctionTypeContext *FuncTypeCxt = WasmEdge_ExportTypeGetFunctionType(ASTCxt, ExpType);
/* If the `ExtType` is not `WasmEdge_ExternalType_Function`, the `FuncTypeCxt` will be NULL. */
const WasmEdge_TableTypeContext *TabTypeCxt = WasmEdge_ExportTypeGetTableType(ASTCxt, ExpType);
/* If the `ExtType` is not `WasmEdge_ExternalType_Table`, the `TabTypeCxt` will be NULL. */
const WasmEdge_MemoryTypeContext *MemTypeCxt = WasmEdge_ExportTypeGetMemoryType(ASTCxt, ExpType);
/* If the `ExtType` is not `WasmEdge_ExternalType_Memory`, the `MemTypeCxt` will be NULL. */
const WasmEdge_GlobalTypeContext *GlobTypeCxt = WasmEdge_ExportTypeGetGlobalType(ASTCxt, ExpType);
/* If the `ExtType` is not `WasmEdge_ExternalType_Global`, the `GlobTypeCxt` will be NULL. */
</code></pre>
</li>
</ol>
<h3 id="async-2"><a class="header" href="#async-2">Async</a></h3>
<p>After calling the <a href="sdk/c/0.9.1/ref.html#asynchronous-execution">asynchronous execution APIs</a>, developers will get the <code>WasmEdge_Async</code> object.
Developers own the object and should call the <code>WasmEdge_AsyncDelete()</code> API to destroy it.</p>
<ol>
<li>
<p>Wait for the asynchronous execution</p>
<p>Developers can wait the execution until finished:</p>
<pre><code class="language-c">WasmEdge_Async *Async = ...; /* Ignored. Asynchronous execute a function. */
/* Blocking and waiting for the execution. */
WasmEdge_AsyncWait(Async);
WasmEdge_AsyncDelete(Async);
</code></pre>
<p>Or developers can wait for a time limit.
If the time limit exceeded, developers can choose to cancel the execution.
For the interruptible execution in AOT mode, developers should set <code>TRUE</code> thourgh the <code>WasmEdge_ConfigureCompilerSetInterruptible()</code> API into the configure context for the AOT compiler.</p>
<pre><code class="language-c">WasmEdge_Async *Async = ...; /* Ignored. Asynchronous execute a function. */
/* Blocking and waiting for the execution for 1 second. */
bool IsEnd = WasmEdge_AsyncWaitFor(Async, 1000);
if (IsEnd) {
  /* The execution finished. Developers can get the result. */
  WasmEdge_Result Res = WasmEdge_AsyncGet(/* ... Ignored */);
} else {
  /* The time limit exceeded. Developers can keep waiting or cancel the execution. */
  WasmEdge_AsyncCancel(Async);
  WasmEdge_Result Res = WasmEdge_AsyncGet(Async, 0, NULL);
  /* The result error code will be `WasmEdge_ErrCode_Interrupted`. */
}
WasmEdge_AsyncDelete(Async);
</code></pre>
</li>
<li>
<p>Get the execution result of the asynchronous execution</p>
<p>Developers can use the <code>WasmEdge_AsyncGetReturnsLength()</code> API to get the return value list length.
This function will block and wait for the execution. If the execution has finished, this function will return the length immediately. If the execution failed, this function will return <code>0</code>.
This function can help the developers to create the buffer to get the return values. If developers have already known the buffer length, they can skip this function and use the <code>WasmEdge_AsyncGet()</code> API to get the result.</p>
<pre><code class="language-c">WasmEdge_Async *Async = ...; /* Ignored. Asynchronous execute a function. */
/* Blocking and waiting for the execution and get the return value list length. */
uint32_t Arity = WasmEdge_AsyncGetReturnsLength(Async);
WasmEdge_AsyncDelete(Async);
</code></pre>
<p>The <code>WasmEdge_AsyncGet()</code> API will block and wait for the execution. If the execution has finished, this function will fill the return values into the buffer and return the execution result immediately.</p>
<pre><code class="language-c">WasmEdge_Async *Async = ...; /* Ignored. Asynchronous execute a function. */
/* Blocking and waiting for the execution and get the return values. */
const uint32_t BUF_LEN = 256;
WasmEdge_Value Buf[BUF_LEN];
WasmEdge_Result Res = WasmEdge_AsyncGet(Async, Buf, BUF_LEN);
WasmEdge_AsyncDelete(Async);
</code></pre>
</li>
</ol>
<h3 id="configurations-2"><a class="header" href="#configurations-2">Configurations</a></h3>
<p>The configuration context, <code>WasmEdge_ConfigureContext</code>, manages the configurations for <code>Loader</code>, <code>Validator</code>, <code>Executor</code>, <code>VM</code>, and <code>Compiler</code>.
Developers can adjust the settings about the proposals, VM host pre-registrations (such as <code>WASI</code>), and AOT compiler options, and then apply the <code>Configure</code> context to create other runtime contexts.</p>
<ol>
<li>
<p>Proposals</p>
<p>WasmEdge supports turning on or off the WebAssembly proposals.
This configuration is effective in any contexts created with the <code>Configure</code> context.</p>
<pre><code class="language-c">enum WasmEdge_Proposal {
  WasmEdge_Proposal_ImportExportMutGlobals = 0,
  WasmEdge_Proposal_NonTrapFloatToIntConversions,
  WasmEdge_Proposal_SignExtensionOperators,
  WasmEdge_Proposal_MultiValue,
  WasmEdge_Proposal_BulkMemoryOperations,
  WasmEdge_Proposal_ReferenceTypes,
  WasmEdge_Proposal_SIMD,
  WasmEdge_Proposal_TailCall,
  WasmEdge_Proposal_MultiMemories,
  WasmEdge_Proposal_Annotations,
  WasmEdge_Proposal_Memory64,
  WasmEdge_Proposal_ExceptionHandling,
  WasmEdge_Proposal_Threads,
  WasmEdge_Proposal_FunctionReferences
};
</code></pre>
<p>Developers can add or remove the proposals into the <code>Configure</code> context.</p>
<pre><code class="language-c">/* 
 * By default, the following proposals have turned on initially:
 * * Import/Export of mutable globals
 * * Non-trapping float-to-int conversions
 * * Sign-extension operators
 * * Multi-value returns
 * * Bulk memory operations
 * * Reference types
 * * Fixed-width SIMD
 */
WasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();
WasmEdge_ConfigureAddProposal(ConfCxt, WasmEdge_Proposal_MultiMemories);
WasmEdge_ConfigureRemoveProposal(ConfCxt, WasmEdge_Proposal_ReferenceTypes);
bool IsBulkMem = WasmEdge_ConfigureHasProposal(ConfCxt, WasmEdge_Proposal_BulkMemoryOperations);
/* The `IsBulkMem` will be `TRUE`. */
WasmEdge_ConfigureDelete(ConfCxt);
</code></pre>
</li>
<li>
<p>Host registrations</p>
<p>This configuration is used for the <code>VM</code> context to turn on the <code>WASI</code> or <code>wasmedge_process</code> supports and only effective in <code>VM</code> contexts.</p>
<pre><code class="language-c">enum WasmEdge_HostRegistration {
  WasmEdge_HostRegistration_Wasi = 0,
  WasmEdge_HostRegistration_WasmEdge_Process
};
</code></pre>
<p>The details will be introduced in the <a href="sdk/c/0.9.1/ref.html#preregistrations">preregistrations of VM context</a>.</p>
<pre><code class="language-c">WasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();
bool IsHostWasi = WasmEdge_ConfigureHasHostRegistration(ConfCxt, WasmEdge_HostRegistration_Wasi);
/* The `IsHostWasi` will be `FALSE`. */
WasmEdge_ConfigureAddHostRegistration(ConfCxt, WasmEdge_HostRegistration_Wasi);
IsHostWasi = WasmEdge_ConfigureHasHostRegistration(ConfCxt, WasmEdge_HostRegistration_Wasi);
/* The `IsHostWasi` will be `TRUE`. */
WasmEdge_ConfigureDelete(ConfCxt);
</code></pre>
</li>
<li>
<p>Maximum memory pages</p>
<p>Developers can limit the page size of memory instances by this configuration.
When growing the page size of memory instances in WASM execution and exceeding the limited size, the page growing will fail.
This configuration is only effective in the <code>Executor</code> and <code>VM</code> contexts.</p>
<pre><code class="language-c">WasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();
uint32_t PageSize = WasmEdge_ConfigureGetMaxMemoryPage(ConfCxt);
/* By default, the maximum memory page size is 65536. */
WasmEdge_ConfigureSetMaxMemoryPage(ConfCxt, 1024);
/* Limit the memory size of each memory instance with not larger than 1024 pages (64 MiB). */
PageSize = WasmEdge_ConfigureGetMaxMemoryPage(ConfCxt);
/* The `PageSize` will be 1024. */
WasmEdge_ConfigureDelete(ConfCxt);
</code></pre>
</li>
<li>
<p>AOT compiler options</p>
<p>The AOT compiler options configure the behavior about optimization level, output format, dump IR, and generic binary.</p>
<pre><code class="language-c">enum WasmEdge_CompilerOptimizationLevel {
  /// Disable as many optimizations as possible.
  WasmEdge_CompilerOptimizationLevel_O0 = 0,
  /// Optimize quickly without destroying debuggability.
  WasmEdge_CompilerOptimizationLevel_O1,
  /// Optimize for fast execution as much as possible without triggering
  /// significant incremental compile time or code size growth.
  WasmEdge_CompilerOptimizationLevel_O2,
  /// Optimize for fast execution as much as possible.
  WasmEdge_CompilerOptimizationLevel_O3,
  /// Optimize for small code size as much as possible without triggering
  /// significant incremental compile time or execution time slowdowns.
  WasmEdge_CompilerOptimizationLevel_Os,
  /// Optimize for small code size as much as possible.
  WasmEdge_CompilerOptimizationLevel_Oz
};

enum WasmEdge_CompilerOutputFormat {
  /// Native dynamic library format.
  WasmEdge_CompilerOutputFormat_Native = 0,
  /// WebAssembly with AOT compiled codes in custom section.
  WasmEdge_CompilerOutputFormat_Wasm
};
</code></pre>
<p>These configurations are only effective in <code>Compiler</code> contexts.</p>
<pre><code class="language-c">WasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();
/* By default, the optimization level is O3. */
WasmEdge_ConfigureCompilerSetOptimizationLevel(ConfCxt, WasmEdge_CompilerOptimizationLevel_O2);
/* By default, the output format is universal WASM. */
WasmEdge_ConfigureCompilerSetOutputFormat(ConfCxt, WasmEdge_CompilerOutputFormat_Native);
/* By default, the dump IR is `FALSE`. */
WasmEdge_ConfigureCompilerSetDumpIR(ConfCxt, TRUE);
/* By default, the generic binary is `FALSE`. */
WasmEdge_ConfigureCompilerSetGenericBinary(ConfCxt, TRUE);
/* By default, the interruptible is `FALSE`.
/* Set this option to `TRUE` to support the interruptible execution in AOT mode. */
WasmEdge_ConfigureCompilerSetInterruptible(ConfCxt, TRUE);
WasmEdge_ConfigureDelete(ConfCxt);
</code></pre>
</li>
<li>
<p>Statistics options</p>
<p>The statistics options configure the behavior about instruction counting, cost measuring, and time measuring in both runtime and AOT compiler.
These configurations are effective in <code>Compiler</code>, <code>VM</code>, and <code>Executor</code> contexts.</p>
<pre><code class="language-c">WasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();
/* By default, the intruction counting is `FALSE` when running a compiled-WASM or a pure-WASM. */
WasmEdge_ConfigureStatisticsSetInstructionCounting(ConfCxt, TRUE);
/* By default, the cost measurement is `FALSE` when running a compiled-WASM or a pure-WASM. */
WasmEdge_ConfigureStatisticsSetCostMeasuring(ConfCxt, TRUE);
/* By default, the time measurement is `FALSE` when running a compiled-WASM or a pure-WASM. */
WasmEdge_ConfigureStatisticsSetTimeMeasuring(ConfCxt, TRUE);
WasmEdge_ConfigureDelete(ConfCxt);
</code></pre>
</li>
</ol>
<h3 id="statistics-2"><a class="header" href="#statistics-2">Statistics</a></h3>
<p>The statistics context, <code>WasmEdge_StatisticsContext</code>, provides the instruction counter, cost summation, and cost limitation at runtime.</p>
<p>Before using statistics, the statistics configuration must be set. Otherwise, the return values of calling statistics are undefined behaviour.</p>
<ol>
<li>
<p>Instruction counter</p>
<p>The instruction counter can help developers to profile the performance of WASM running.
Developers can retrieve the <code>Statistics</code> context from the <code>VM</code> context, or create a new one for the <code>Executor</code> creation.
The details will be introduced in the next partitions.</p>
<pre><code class="language-c">WasmEdge_StatisticsContext *StatCxt = WasmEdge_StatisticsCreate();
/* ....
 * After running the WASM functions with the `Statistics` context
 */
uint32_t Count = WasmEdge_StatisticsGetInstrCount(StatCxt);
double IPS = WasmEdge_StatisticsGetInstrPerSecond(StatCxt);
WasmEdge_StatisticsDelete(StatCxt);
</code></pre>
</li>
<li>
<p>Cost table</p>
<p>The cost table is to accumulate the cost of instructions with their weights.
Developers can set the cost table array (the indices are the byte code value of instructions, and the values are the cost of instructions) into the <code>Statistics</code> context.
If the cost limit value is set, the execution will return the <code>cost limit exceeded</code> error immediately when exceeds the cost limit in runtime.</p>
<pre><code class="language-c">WasmEdge_StatisticsContext *StatCxt = WasmEdge_StatisticsCreate();
uint64_t CostTable[16] = {
  0, 0,
  10, /* 0x02: Block */
  11, /* 0x03: Loop */
  12, /* 0x04: If */
  12, /* 0x05: Else */
  0, 0, 0, 0, 0, 0, 
  20, /* 0x0C: Br */
  21, /* 0x0D: Br_if */
  22, /* 0x0E: Br_table */
  0
};
/* Developers can set the costs of each instruction. The value not covered will be 0. */
WasmEdge_StatisticsSetCostTable(StatCxt, CostTable, 16);
WasmEdge_StatisticsSetCostLimit(StatCxt, 5000000);
/* ....
 * After running the WASM functions with the `Statistics` context
 */
uint64_t Cost = WasmEdge_StatisticsGetTotalCost(StatCxt);
WasmEdge_StatisticsDelete(StatCxt);
</code></pre>
</li>
</ol>
<h2 id="wasmedge-vm-2"><a class="header" href="#wasmedge-vm-2">WasmEdge VM</a></h2>
<p>In this partition, we will introduce the functions of <code>WasmEdge_VMContext</code> object and show examples of executing WASM functions.</p>
<h3 id="wasm-execution-example-with-vm-context-2"><a class="header" href="#wasm-execution-example-with-vm-context-2">WASM Execution Example With VM Context</a></h3>
<p>The following shows the example of running the WASM for getting the Fibonacci.
This example uses the <a href="https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/examples/wasm/fibonacci.wasm">fibonacci.wasm</a>, and the corresponding WAT file is at <a href="https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/examples/wasm/fibonacci.wat">fibonacci.wat</a>.</p>
<pre><code class="language-wasm">(module
 (export &quot;fib&quot; (func $fib))
 (func $fib (param $n i32) (result i32)
  (if
   (i32.lt_s (get_local $n)(i32.const 2))
   (return (i32.const 1))
  )
  (return
   (i32.add
    (call $fib (i32.sub (get_local $n)(i32.const 2)))
    (call $fib (i32.sub (get_local $n)(i32.const 1)))
   )
  )
 )
)
</code></pre>
<ol>
<li>
<p>Run WASM functions rapidly</p>
<p>Assume that the WASM file <a href="https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/examples/wasm/fibonacci.wasm"><code>fibonacci.wasm</code></a> is copied into the current directory, and the C file <code>test.c</code> is as following:</p>
<pre><code class="language-c">#include &lt;wasmedge/wasmedge.h&gt;
#include &lt;stdio.h&gt;
int main() {
  /* Create the configure context and add the WASI support. */
  /* This step is not necessary unless you need WASI support. */
  WasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();
  WasmEdge_ConfigureAddHostRegistration(ConfCxt, WasmEdge_HostRegistration_Wasi);
  /* The configure and store context to the VM creation can be NULL. */
  WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(ConfCxt, NULL);

  /* The parameters and returns arrays. */
  WasmEdge_Value Params[1] = { WasmEdge_ValueGenI32(5) };
  WasmEdge_Value Returns[1];
  /* Function name. */
  WasmEdge_String FuncName = WasmEdge_StringCreateByCString(&quot;fib&quot;);
  /* Run the WASM function from file. */
  WasmEdge_Result Res = WasmEdge_VMRunWasmFromFile(VMCxt, &quot;fibonacci.wasm&quot;, FuncName, Params, 1, Returns, 1);
  /* 
   * Developers can run the WASM binary from buffer with the `WasmEdge_VMRunWasmFromBuffer()` API,
   * or from `WasmEdge_ASTModuleContext` object with the `WasmEdge_VMRunWasmFromASTModule()` API.
   */

  if (WasmEdge_ResultOK(Res)) {
    printf(&quot;Get the result: %d\n&quot;, WasmEdge_ValueGetI32(Returns[0]));
  } else {
    printf(&quot;Error message: %s\n&quot;, WasmEdge_ResultGetMessage(Res));
  }

  /* Resources deallocations. */
  WasmEdge_VMDelete(VMCxt);
  WasmEdge_ConfigureDelete(ConfCxt);
  WasmEdge_StringDelete(FuncName);
  return 0;
}
</code></pre>
<p>Then you can compile and run: (the 5th Fibonacci number is 8 in 0-based index)</p>
<pre><code class="language-bash">$ gcc test.c -lwasmedge_c
$ ./a.out
Get the result: 8
</code></pre>
</li>
<li>
<p>Instantiate and run WASM functions manually</p>
<p>Besides the above example, developers can run the WASM functions step-by-step with <code>VM</code> context APIs:</p>
<pre><code class="language-c">#include &lt;wasmedge/wasmedge.h&gt;
#include &lt;stdio.h&gt;
int main() {
  /* Create the configure context and add the WASI support. */
  /* This step is not necessary unless you need the WASI support. */
  WasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();
  WasmEdge_ConfigureAddHostRegistration(ConfCxt, WasmEdge_HostRegistration_Wasi);
  /* The configure and store context to the VM creation can be NULL. */
  WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(ConfCxt, NULL);

  /* The parameters and returns arrays. */
  WasmEdge_Value Params[1] = { WasmEdge_ValueGenI32(10) };
  WasmEdge_Value Returns[1];
  /* Function name. */
  WasmEdge_String FuncName = WasmEdge_StringCreateByCString(&quot;fib&quot;);
  /* Result. */
  WasmEdge_Result Res;
  
  /* Step 1: Load WASM file. */
  Res = WasmEdge_VMLoadWasmFromFile(VMCxt, &quot;fibonacci.wasm&quot;);
  /* 
   * Developers can load the WASM binary from buffer with the `WasmEdge_VMLoadWasmFromBuffer()` API,
   * or from `WasmEdge_ASTModuleContext` object with the `WasmEdge_VMLoadWasmFromASTModule()` API.
   */
  if (!WasmEdge_ResultOK(Res)) {
    printf(&quot;Loading phase failed: %s\n&quot;, WasmEdge_ResultGetMessage(Res));
    return 1;
  }
  /* Step 2: Validate the WASM module. */
  Res = WasmEdge_VMValidate(VMCxt);
  if (!WasmEdge_ResultOK(Res)) {
    printf(&quot;Validation phase failed: %s\n&quot;, WasmEdge_ResultGetMessage(Res));
    return 1;
  }
  /* Step 3: Instantiate the WASM module. */
  Res = WasmEdge_VMInstantiate(VMCxt);
  /* 
   * Developers can load, validate, and instantiate another WASM module to replace the
   * instantiated one. In this case, the old module will be cleared, but the registered
   * modules are still kept.
   */
  if (!WasmEdge_ResultOK(Res)) {
    printf(&quot;Instantiation phase failed: %s\n&quot;, WasmEdge_ResultGetMessage(Res));
    return 1;
  }
  /* Step 4: Execute WASM functions. You can execute functions repeatedly after instantiation. */
  Res = WasmEdge_VMExecute(VMCxt, FuncName, Params, 1, Returns, 1);
  if (WasmEdge_ResultOK(Res)) {
    printf(&quot;Get the result: %d\n&quot;, WasmEdge_ValueGetI32(Returns[0]));
  } else {
    printf(&quot;Execution phase failed: %s\n&quot;, WasmEdge_ResultGetMessage(Res));
  }

  /* Resources deallocations. */
  WasmEdge_VMDelete(VMCxt);
  WasmEdge_ConfigureDelete(ConfCxt);
  WasmEdge_StringDelete(FuncName);
  return 0;
}
</code></pre>
<p>Then you can compile and run: (the 10th Fibonacci number is 89 in 0-based index)</p>
<pre><code class="language-bash">$ gcc test.c -lwasmedge_c
$ ./a.out
Get the result: 89
</code></pre>
<p>The following graph explains the status of the <code>VM</code> context.</p>
<pre><code class="language-text">                       |========================|
              |-------&gt;|      VM: Initiated     |
              |        |========================|
              |                    |
              |                 LoadWasm
              |                    |
              |                    v
              |        |========================|
              |--------|       VM: Loaded       |&lt;-------|
              |        |========================|        |
              |              |            ^              |
              |         Validate          |              |
          Cleanup            |          LoadWasm         |
              |              v            |            LoadWasm
              |        |========================|        |
              |--------|      VM: Validated     |        |
              |        |========================|        |
              |              |            ^              |
              |      Instantiate          |              |
              |              |          RegisterModule   |
              |              v            |              |
              |        |========================|        |
              |--------|    VM: Instantiated    |--------|
                       |========================|
                             |            ^
                             |            |
                             --------------
                Instantiate, Execute, ExecuteRegistered
</code></pre>
<p>The status of the <code>VM</code> context would be <code>Inited</code> when created.
After loading WASM successfully, the status will be <code>Loaded</code>.
After validating WASM successfully, the status will be <code>Validated</code>.
After instantiating WASM successfully, the status will be <code>Instantiated</code>, and developers can invoke functions.
Developers can register WASM or import objects in any status, but they should instantiate WASM again.
Developers can also load WASM in any status, and they should validate and instantiate the WASM module before function invocation.
When in the <code>Instantiated</code> status, developers can instantiate the WASM module again to reset the old WASM runtime structures.</p>
</li>
</ol>
<h3 id="vm-creations-2"><a class="header" href="#vm-creations-2">VM Creations</a></h3>
<p>The <code>VM</code> creation API accepts the <code>Configure</code> context and the <code>Store</code> context.
If developers only need the default settings, just pass <code>NULL</code> to the creation API.
The details of the <code>Store</code> context will be introduced in <a href="sdk/c/0.9.1/ref.html#store">Store</a>.</p>
<pre><code class="language-c">WasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();
WasmEdge_StoreContext *StoreCxt = WasmEdge_StoreCreate();
WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(ConfCxt, StoreCxt);
/* The caller should guarantee the life cycle if the store context. */
WasmEdge_StatisticsContext *StatCxt = WasmEdge_VMGetStatisticsContext(VMCxt);
/* The VM context already contains the statistics context and can be retrieved by this API. */
/* 
 * Note that the retrieved store and statistics contexts from the VM contexts by VM APIs
 * should __NOT__ be destroyed and owned by the VM contexts.
 */
WasmEdge_VMDelete(VMCxt);
WasmEdge_StoreDelete(StoreCxt);
WasmEdge_ConfigureDelete(ConfCxt);
</code></pre>
<h3 id="preregistrations-2"><a class="header" href="#preregistrations-2">Preregistrations</a></h3>
<p>WasmEdge provides the following built-in pre-registrations.</p>
<ol>
<li>
<p><a href="https://github.com/WebAssembly/WASI">WASI (WebAssembly System Interface)</a></p>
<p>Developers can turn on the WASI support for VM in the <code>Configure</code> context.</p>
<pre><code class="language-c">WasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();
WasmEdge_ConfigureAddHostRegistration(ConfCxt, WasmEdge_HostRegistration_Wasi);
WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(ConfCxt, NULL);
/* The following API can retrieve the pre-registration import objects from the VM context. */
/* This API will return `NULL` if the corresponding pre-registration is not set into the configuration. */
WasmEdge_ImportObjectContext *WasiObject =
  WasmEdge_VMGetImportModuleContext(VMCxt, WasmEdge_HostRegistration_Wasi);
/* Initialize the WASI. */
WasmEdge_ImportObjectInitWASI(WasiObject, /* ... ignored */ );
WasmEdge_VMDelete(VMCxt);
WasmEdge_ConfigureDelete(ConfCxt);
</code></pre>
<p>And also can create the WASI import object from API. The details will be introduced in the <a href="sdk/c/0.9.1/ref.html#host-functions">Host Functions</a> and the <a href="sdk/c/0.9.1/ref.html#host-module-registrations">Host Module Registrations</a>.</p>
</li>
<li>
<p><a href="https://crates.io/crates/wasmedge_process_interface">WasmEdge_Process</a></p>
<p>This pre-registration is for the process interface for WasmEdge on <code>Rust</code> sources.
After turning on this pre-registration, the VM will support the <code>wasmedge_process</code> host functions.</p>
<pre><code class="language-c">WasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();
WasmEdge_ConfigureAddHostRegistration(ConfCxt, WasmEdge_HostRegistration_WasmEdge_Process);
WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(ConfCxt, NULL);
/* The following API can retrieve the pre-registration import objects from the VM context. */
/* This API will return `NULL` if the corresponding pre-registration is not set into the configuration. */
WasmEdge_ImportObjectContext *ProcObject =
  WasmEdge_VMGetImportModuleContext(VMCxt, WasmEdge_HostRegistration_WasmEdge_Process);
/* Initialize the WasmEdge_Process. */
WasmEdge_ImportObjectInitWasmEdgeProcess(ProcObject, /* ... ignored */ );
WasmEdge_VMDelete(VMCxt);
WasmEdge_ConfigureDelete(ConfCxt);
</code></pre>
<p>And also can create the WasmEdge_Process import object from API. The details will be introduced in the <a href="sdk/c/0.9.1/ref.html#host-functions">Host Functions</a> and the <a href="sdk/c/0.9.1/ref.html#host-module-registrations">Host Module Registrations</a>.</p>
</li>
</ol>
<h3 id="host-module-registrations-2"><a class="header" href="#host-module-registrations-2">Host Module Registrations</a></h3>
<p><a href="https://webassembly.github.io/spec/core/exec/runtime.html#syntax-hostfunc">Host functions</a> are functions outside WebAssembly and passed to WASM modules as imports.
In WasmEdge, the host functions are composed into host modules as <code>WasmEdge_ImportObjectContext</code> objects with module names.
Please refer to the <a href="sdk/c/0.9.1/ref.html#host-functions">Host Functions in WasmEdge Runtime</a> for the details.
In this chapter, we show the example for registering the host modules into a <code>VM</code> context.</p>
<pre><code class="language-c">WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(NULL, NULL);
WasmEdge_ImportObjectContext *WasiObject =
  WasmEdge_ImportObjectCreateWASI( /* ... ignored ... */ );
/* You can also create and register the WASI host modules by this API. */
WasmEdge_Result Res = WasmEdge_VMRegisterModuleFromImport(VMCxt, WasiObject);
/* The result status should be checked. */
WasmEdge_ImportObjectDelete(WasiObject);
/* The created import objects should be deleted. */
WasmEdge_VMDelete(VMCxt);
</code></pre>
<h3 id="wasm-registrations-and-executions-2"><a class="header" href="#wasm-registrations-and-executions-2">WASM Registrations And Executions</a></h3>
<p>In WebAssembly, the instances in WASM modules can be exported and can be imported by other WASM modules.
WasmEdge VM provides APIs for developers to register and export any WASM modules, and execute the functions or host functions in the registered WASM modules.</p>
<ol>
<li>
<p>Register the WASM modules with exported module names</p>
<p>Unless the import objects have already contained the module names, every WASM module should be named uniquely when registering.
Assume that the WASM file <a href="https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/examples/wasm/fibonacci.wasm"><code>fibonacci.wasm</code></a> is copied into the current directory.</p>
<pre><code class="language-c">WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(NULL, NULL);
WasmEdge_String ModName = WasmEdge_StringCreateByCString(&quot;mod&quot;);
WasmEdge_Result Res = WasmEdge_VMRegisterModuleFromFile(VMCxt, ModName, &quot;fibonacci.wasm&quot;);
/* 
 * Developers can register the WASM module from buffer with the `WasmEdge_VMRegisterModuleFromBuffer()` API,
 * or from `WasmEdge_ASTModuleContext` object with the `WasmEdge_VMRegisterModuleFromASTModule()` API.
 */
/* 
 * The result status should be checked.
 * The error will occur if the WASM module instantiation failed or the module name conflicts.
 */
WasmEdge_StringDelete(ModName);
WasmEdge_VMDelete(VMCxt);
</code></pre>
</li>
<li>
<p>Execute the functions in registered WASM modules</p>
<p>Assume that the C file <code>test.c</code> is as follows:</p>
<pre><code class="language-c">#include &lt;wasmedge/wasmedge.h&gt;
#include &lt;stdio.h&gt;
int main() {
  WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(NULL, NULL);

  /* The parameters and returns arrays. */
  WasmEdge_Value Params[1] = { WasmEdge_ValueGenI32(20) };
  WasmEdge_Value Returns[1];
  /* Names. */
  WasmEdge_String ModName = WasmEdge_StringCreateByCString(&quot;mod&quot;);
  WasmEdge_String FuncName = WasmEdge_StringCreateByCString(&quot;fib&quot;);
  /* Result. */
  WasmEdge_Result Res;

  /* Register the WASM module into VM. */
  Res = WasmEdge_VMRegisterModuleFromFile(VMCxt, ModName, &quot;fibonacci.wasm&quot;);
  /* 
  * Developers can register the WASM module from buffer with the `WasmEdge_VMRegisterModuleFromBuffer()` API,
  * or from `WasmEdge_ASTModuleContext` object with the `WasmEdge_VMRegisterModuleFromASTModule()` API.
  */
  if (!WasmEdge_ResultOK(Res)) {
    printf(&quot;WASM registration failed: %s\n&quot;, WasmEdge_ResultGetMessage(Res));
    return 1;
  }
  /* 
  * The function &quot;fib&quot; in the &quot;fibonacci.wasm&quot; was exported with the module name &quot;mod&quot;.
  * As the same as host functions, other modules can import the function `&quot;mod&quot; &quot;fib&quot;`.
  */

  /* 
  * Execute WASM functions in registered modules.
  * Unlike the execution of functions, the registered functions can be invoked without
  * `WasmEdge_VMInstantiate()` because the WASM module was instantiated when registering.
  * Developers can also invoke the host functions directly with this API.
  */
  Res = WasmEdge_VMExecuteRegistered(VMCxt, ModName, FuncName, Params, 1, Returns, 1);
  if (WasmEdge_ResultOK(Res)) {
    printf(&quot;Get the result: %d\n&quot;, WasmEdge_ValueGetI32(Returns[0]));
  } else {
    printf(&quot;Execution phase failed: %s\n&quot;, WasmEdge_ResultGetMessage(Res));
  }
  WasmEdge_StringDelete(ModName);
  WasmEdge_StringDelete(FuncName);
  WasmEdge_VMDelete(VMCxt);
  return 0;
}
</code></pre>
<p>Then you can compile and run: (the 20th Fibonacci number is 89 in 0-based index)</p>
<pre><code class="language-bash">$ gcc test.c -lwasmedge_c
$ ./a.out
Get the result: 10946
</code></pre>
</li>
</ol>
<h3 id="asynchronous-execution-2"><a class="header" href="#asynchronous-execution-2">Asynchronous Execution</a></h3>
<ol>
<li>
<p>Asynchronously run WASM functions rapidly</p>
<p>Assume that the WASM file <a href="https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/examples/wasm/fibonacci.wasm"><code>fibonacci.wasm</code></a> is copied into the current directory, and the C file <code>test.c</code> is as following:</p>
<pre><code class="language-c">#include &lt;wasmedge/wasmedge.h&gt;
#include &lt;stdio.h&gt;
int main() {
  /* Create the VM context. */
  WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(NULL, NULL);

  /* The parameters and returns arrays. */
  WasmEdge_Value Params[1] = { WasmEdge_ValueGenI32(20) };
  WasmEdge_Value Returns[1];
  /* Function name. */
  WasmEdge_String FuncName = WasmEdge_StringCreateByCString(&quot;fib&quot;);
  /* Asynchronously run the WASM function from file and get the `WasmEdge_Async` object. */
  WasmEdge_Async *Async = WasmEdge_VMAsyncRunWasmFromFile(VMCxt, &quot;fibonacci.wasm&quot;, FuncName, Params, 1);
  /* 
   * Developers can run the WASM binary from buffer with the `WasmEdge_VMAsyncRunWasmFromBuffer()` API,
   * or from `WasmEdge_ASTModuleContext` object with the `WasmEdge_VMAsyncRunWasmFromASTModule()` API.
   */

  /* Wait for the execution. */
  WasmEdge_AsyncWait(Async);
  /*
   * Developers can also use the `WasmEdge_AsyncGetReturnsLength()` or `WasmEdge_AsyncGet()` APIs
   * to wait for the asynchronous execution. These APIs will wait until the execution finished.
   */

  /* Check the return values length. */
  uint32_t Arity = WasmEdge_AsyncGetReturnsLength(Async);
  /* The `Arity` should be 1. Developers can skip this step if they have known the return arity. */

  /* Get the result. */
  WasmEdge_Result Res = WasmEdge_AsyncGet(Async, Returns, Arity);

  if (WasmEdge_ResultOK(Res)) {
    printf(&quot;Get the result: %d\n&quot;, WasmEdge_ValueGetI32(Returns[0]));
  } else {
    printf(&quot;Error message: %s\n&quot;, WasmEdge_ResultGetMessage(Res));
  }

  /* Resources deallocations. */
  WasmEdge_AsyncDelete(Async);
  WasmEdge_VMDelete(VMCxt);
  WasmEdge_StringDelete(FuncName);
  return 0;
}
</code></pre>
<p>Then you can compile and run: (the 20th Fibonacci number is 10946 in 0-based index)</p>
<pre><code class="language-bash">$ gcc test.c -lwasmedge_c
$ ./a.out
Get the result: 10946
</code></pre>
</li>
<li>
<p>Instantiate and asynchronously run WASM functions manually</p>
<p>Besides the above example, developers can run the WASM functions step-by-step with <code>VM</code> context APIs:</p>
<pre><code class="language-c">#include &lt;wasmedge/wasmedge.h&gt;
#include &lt;stdio.h&gt;
int main() {
  /* Create the VM context. */
  WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(NULL, NULL);

  /* The parameters and returns arrays. */
  WasmEdge_Value Params[1] = { WasmEdge_ValueGenI32(25) };
  WasmEdge_Value Returns[1];
  /* Function name. */
  WasmEdge_String FuncName = WasmEdge_StringCreateByCString(&quot;fib&quot;);
  /* Result. */
  WasmEdge_Result Res;
  
  /* Step 1: Load WASM file. */
  Res = WasmEdge_VMLoadWasmFromFile(VMCxt, &quot;fibonacci.wasm&quot;);
  /* 
   * Developers can load the WASM binary from buffer with the `WasmEdge_VMLoadWasmFromBuffer()` API,
   * or from `WasmEdge_ASTModuleContext` object with the `WasmEdge_VMLoadWasmFromASTModule()` API.
   */
  if (!WasmEdge_ResultOK(Res)) {
    printf(&quot;Loading phase failed: %s\n&quot;, WasmEdge_ResultGetMessage(Res));
    return 1;
  }
  /* Step 2: Validate the WASM module. */
  Res = WasmEdge_VMValidate(VMCxt);
  if (!WasmEdge_ResultOK(Res)) {
    printf(&quot;Validation phase failed: %s\n&quot;, WasmEdge_ResultGetMessage(Res));
    return 1;
  }
  /* Step 3: Instantiate the WASM module. */
  Res = WasmEdge_VMInstantiate(VMCxt);
  /* 
   * Developers can load, validate, and instantiate another WASM module to replace the
   * instantiated one. In this case, the old module will be cleared, but the registered
   * modules are still kept.
   */
  if (!WasmEdge_ResultOK(Res)) {
    printf(&quot;Instantiation phase failed: %s\n&quot;, WasmEdge_ResultGetMessage(Res));
    return 1;
  }
  /* Step 4: Asynchronously execute the WASM function and get the `WasmEdge_Async` object. */
  WasmEdge_Async *Async = WasmEdge_VMAsyncExecute(VMCxt, FuncName, Params, 1);
  /* 
   * Developers can execute functions repeatedly after instantiation.
   * For invoking the registered functions, you can use the `WasmEdge_VMAsyncExecuteRegistered()` API.
   */

  /* Wait and check the return values length. */
  uint32_t Arity = WasmEdge_AsyncGetReturnsLength(Async);
  /* The `Arity` should be 1. Developers can skip this step if they have known the return arity. */

  /* Get the result. */
  Res = WasmEdge_AsyncGet(Async, Returns, Arity);
  if (WasmEdge_ResultOK(Res)) {
    printf(&quot;Get the result: %d\n&quot;, WasmEdge_ValueGetI32(Returns[0]));
  } else {
    printf(&quot;Execution phase failed: %s\n&quot;, WasmEdge_ResultGetMessage(Res));
  }

  /* Resources deallocations. */
  WasmEdge_AsyncDelete(Async);
  WasmEdge_VMDelete(VMCxt);
  WasmEdge_StringDelete(FuncName);
}
</code></pre>
<p>Then you can compile and run: (the 25th Fibonacci number is 121393 in 0-based index)</p>
<pre><code class="language-bash">$ gcc test.c -lwasmedge_c
$ ./a.out
Get the result: 121393
</code></pre>
</li>
</ol>
<h3 id="instance-tracing-2"><a class="header" href="#instance-tracing-2">Instance Tracing</a></h3>
<p>Sometimes the developers may have requirements to get the instances of the WASM runtime.
The <code>VM</code> context supplies the APIs to retrieve the instances.</p>
<ol>
<li>
<p>Store</p>
<p>If the <code>VM</code> context is created without assigning a <code>Store</code> context, the <code>VM</code> context will allocate and own a <code>Store</code> context.</p>
<pre><code class="language-c">WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(NULL, NULL);
WasmEdge_StoreContext *StoreCxt = WasmEdge_VMGetStoreContext(VMCxt);
/* The object should __NOT__ be deleted by `WasmEdge_StoreDelete()`. */
WasmEdge_VMDelete(VMCxt);
</code></pre>
<p>Developers can also create the <code>VM</code> context with a <code>Store</code> context.
In this case, developers should guarantee the life cycle of the <code>Store</code> context.
Please refer to the <a href="sdk/c/0.9.1/ref.html#store">Store Contexts</a> for the details about the <code>Store</code> context APIs.</p>
<pre><code class="language-c">WasmEdge_StoreContext *StoreCxt = WasmEdge_StoreCreate();
WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(NULL, StoreCxt);
WasmEdge_StoreContext *StoreCxtMock = WasmEdge_VMGetStoreContext(VMCxt);
/* The `StoreCxt` and the `StoreCxtMock` are the same. */
WasmEdge_VMDelete(VMCxt);
WasmEdge_StoreDelete(StoreCxt);
</code></pre>
</li>
<li>
<p>List exported functions</p>
<p>After the WASM module instantiation, developers can use the <code>WasmEdge_VMExecute()</code> API to invoke the exported WASM functions. For this purpose, developers may need information about the exported WASM function list.
Please refer to the <a href="sdk/c/0.9.1/ref.html#instances">Instances in runtime</a> for the details about the function types.
Assume that the WASM file <a href="https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/examples/wasm/fibonacci.wasm"><code>fibonacci.wasm</code></a> is copied into the current directory, and the C file <code>test.c</code> is as following:</p>
<pre><code class="language-c">#include &lt;wasmedge/wasmedge.h&gt;
#include &lt;stdio.h&gt;
int main() {
  WasmEdge_StoreContext *StoreCxt = WasmEdge_StoreCreate();
  WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(NULL, StoreCxt);

  WasmEdge_VMLoadWasmFromFile(VMCxt, &quot;fibonacci.wasm&quot;);
  WasmEdge_VMValidate(VMCxt);
  WasmEdge_VMInstantiate(VMCxt);

  /* List the exported functions. */
  /* Get the number of exported functions. */
  uint32_t FuncNum = WasmEdge_VMGetFunctionListLength(VMCxt);
  /* Create the name buffers and the function type buffers. */
  const uint32_t BUF_LEN = 256;
  WasmEdge_String FuncNames[BUF_LEN];
  WasmEdge_FunctionTypeContext *FuncTypes[BUF_LEN];
  /* 
   * Get the export function list.
   * If the function list length is larger than the buffer length, the overflowed data will be discarded.
   * The `FuncNames` and `FuncTypes` can be NULL if developers don't need them.
   */
  uint32_t RealFuncNum = WasmEdge_VMGetFunctionList(VMCxt, FuncNames, FuncTypes, BUF_LEN);

  for (uint32_t I = 0; I &lt; RealFuncNum &amp;&amp; I &lt; BUF_LEN; I++) {
    char Buf[BUF_LEN];
    uint32_t Size = WasmEdge_StringCopy(FuncNames[I], Buf, sizeof(Buf));
    printf(&quot;Get exported function string length: %u, name: %s\n&quot;, Size, Buf);
    /* 
     * The function names should be __NOT__ destroyed.
     * The returned function type contexts should __NOT__ be destroyed.
     */
  }
  return 0;
}
</code></pre>
<p>Then you can compile and run: (the only exported function in <code>fibonacci.wasm</code> is <code>fib</code>)</p>
<pre><code class="language-bash">$ gcc test.c -lwasmedge_c
$ ./a.out
Get exported function string length: 3, name: fib
</code></pre>
<p>If developers want to get the exported function names in the registered WASM modules, please retrieve the <code>Store</code> context from the <code>VM</code> context and refer to the APIs of <a href="sdk/c/0.9.1/ref.html#store">Store Contexts</a> to list the registered functions by the module name.</p>
</li>
<li>
<p>Get function types</p>
<p>The <code>VM</code> context provides APIs to find the function type by function name.
Please refer to the <a href="sdk/c/0.9.1/ref.html#instances">Instances in runtime</a> for the details about the function types.</p>
<pre><code class="language-c">/* 
 * ...
 * Assume that a WASM module is instantiated in `VMCxt`.
 */
WasmEdge_String FuncName = WasmEdge_StringCreateByCString(&quot;fib&quot;);
const WasmEdge_FunctionTypeContext *FuncType = WasmEdge_VMGetFunctionType(VMCxt, FuncName);
/* 
 * Developers can get the function types of functions in the registered modules
 * via the `WasmEdge_VMGetFunctionTypeRegistered()` API with the module name.
 * If the function is not found, these APIs will return `NULL`.
 * The returned function type contexts should __NOT__ be destroyed.
 */
WasmEdge_StringDelete(FuncName);
</code></pre>
</li>
</ol>
<h2 id="wasmedge-runtime-2"><a class="header" href="#wasmedge-runtime-2">WasmEdge Runtime</a></h2>
<p>In this partition, we will introduce the objects of WasmEdge runtime manually.</p>
<h3 id="wasm-execution-example-step-by-step-2"><a class="header" href="#wasm-execution-example-step-by-step-2">WASM Execution Example Step-By-Step</a></h3>
<p>Besides the WASM execution through the <a href="sdk/c/0.9.1/ref.html#wasmedge-vm"><code>VM</code> context</a>, developers can execute the WASM functions or instantiate WASM modules step-by-step with the <code>Loader</code>, <code>Validator</code>, <code>Executor</code>, and <code>Store</code> contexts.
Assume that the WASM file <a href="https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/examples/wasm/fibonacci.wasm"><code>fibonacci.wasm</code></a> is copied into the current directory, and the C file <code>test.c</code> is as following:</p>
<pre><code class="language-c">#include &lt;wasmedge/wasmedge.h&gt;
#include &lt;stdio.h&gt;
int main() {
  /* Create the configure context. This step is not necessary because we didn't adjust any setting. */
  WasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();
  /* Create the statistics context. This step is not necessary if the statistics in runtime is not needed. */
  WasmEdge_StatisticsContext *StatCxt = WasmEdge_StatisticsCreate();
  /* Create the store context. The store context is the WASM runtime structure core. */
  WasmEdge_StoreContext *StoreCxt = WasmEdge_StoreCreate();
  /* Result. */
  WasmEdge_Result Res;

  /* Create the loader context. The configure context can be NULL. */
  WasmEdge_LoaderContext *LoadCxt = WasmEdge_LoaderCreate(ConfCxt);
  /* Create the validator context. The configure context can be NULL. */
  WasmEdge_ValidatorContext *ValidCxt = WasmEdge_ValidatorCreate(ConfCxt);
  /* Create the executor context. The configure context and the statistics context can be NULL. */
  WasmEdge_ExecutorContext *ExecCxt = WasmEdge_ExecutorCreate(ConfCxt, StatCxt);

  /* Load the WASM file or the compiled-WASM file and convert into the AST module context. */
  WasmEdge_ASTModuleContext *ASTCxt = NULL;
  Res = WasmEdge_LoaderParseFromFile(LoadCxt, &amp;ASTCxt, &quot;fibonacci.wasm&quot;);
  if (!WasmEdge_ResultOK(Res)) {
    printf(&quot;Loading phase failed: %s\n&quot;, WasmEdge_ResultGetMessage(Res));
    return 1;
  }
  /* Validate the WASM module. */
  Res = WasmEdge_ValidatorValidate(ValidCxt, ASTCxt);
  if (!WasmEdge_ResultOK(Res)) {
    printf(&quot;Validation phase failed: %s\n&quot;, WasmEdge_ResultGetMessage(Res));
    return 1;
  }
  /* Instantiate the WASM module into store context. */
  Res = WasmEdge_ExecutorInstantiate(ExecCxt, StoreCxt, ASTCxt);
  if (!WasmEdge_ResultOK(Res)) {
    printf(&quot;Instantiation phase failed: %s\n&quot;, WasmEdge_ResultGetMessage(Res));
    return 1;
  }

  /* Try to list the exported functions of the instantiated WASM module. */
  uint32_t FuncNum = WasmEdge_StoreListFunctionLength(StoreCxt);
  /* Create the name buffers. */
  const uint32_t BUF_LEN = 256;
  WasmEdge_String FuncNames[BUF_LEN];
  /* If the list length is larger than the buffer length, the overflowed data will be discarded. */
  uint32_t RealFuncNum = WasmEdge_StoreListFunction(StoreCxt, FuncNames, BUF_LEN);
  for (uint32_t I = 0; I &lt; RealFuncNum &amp;&amp; I &lt; BUF_LEN; I++) {
    char Buf[BUF_LEN];
    uint32_t Size = WasmEdge_StringCopy(FuncNames[I], Buf, sizeof(Buf));
    printf(&quot;Get exported function string length: %u, name: %s\n&quot;, Size, Buf);
    /* The function names should __NOT__ be destroyed. */
  }

  /* The parameters and returns arrays. */
  WasmEdge_Value Params[1] = { WasmEdge_ValueGenI32(18) };
  WasmEdge_Value Returns[1];
  /* Function name. */
  WasmEdge_String FuncName = WasmEdge_StringCreateByCString(&quot;fib&quot;);
  /* Invoke the WASM fnction. */
  Res = WasmEdge_ExecutorInvoke(ExecCxt, StoreCxt, FuncName, Params, 1, Returns, 1);
  if (WasmEdge_ResultOK(Res)) {
    printf(&quot;Get the result: %d\n&quot;, WasmEdge_ValueGetI32(Returns[0]));
  } else {
    printf(&quot;Execution phase failed: %s\n&quot;, WasmEdge_ResultGetMessage(Res));
  }

  /* Resources deallocations. */
  WasmEdge_StringDelete(FuncName);
  WasmEdge_ASTModuleDelete(ASTCxt);
  WasmEdge_LoaderDelete(LoadCxt);
  WasmEdge_ValidatorDelete(ValidCxt);
  WasmEdge_ExecutorDelete(ExecCxt);
  WasmEdge_ConfigureDelete(ConfCxt);
  WasmEdge_StoreDelete(StoreCxt);
  WasmEdge_StatisticsDelete(StatCxt);
  return 0;
}
</code></pre>
<p>Then you can compile and run: (the 18th Fibonacci number is 4181 in 0-based index)</p>
<pre><code class="language-bash">$ gcc test.c -lwasmedge_c
$ ./a.out
Get exported function string length: 3, name: fib
Get the result: 4181
</code></pre>
<h3 id="loader-2"><a class="header" href="#loader-2">Loader</a></h3>
<p>The <code>Loader</code> context loads the WASM binary from files or buffers.
Both the WASM and the compiled-WASM from the <a href="sdk/c/0.9.1/ref.html#wasmedge-aot-compiler">WasmEdge AOT Compiler</a> are supported.</p>
<pre><code class="language-c">uint8_t Buf[4096];
/* ... Read the WASM code to the buffer. */
uint32_t FileSize = ...;
/* The `FileSize` is the length of the WASM code. */

/* Developers can adjust settings in the configure context. */
WasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();
/* Create the loader context. The configure context can be NULL. */
WasmEdge_LoaderContext *LoadCxt = WasmEdge_LoaderCreate(ConfCxt);

WasmEdge_ASTModuleContext *ASTCxt = NULL;
WasmEdge_Result Res;

/* Load WASM or compiled-WASM from the file. */
Res = WasmEdge_LoaderParseFromFile(LoadCxt, &amp;ASTCxt, &quot;fibonacci.wasm&quot;);
if (!WasmEdge_ResultOK(Res)) {
  printf(&quot;Loading phase failed: %s\n&quot;, WasmEdge_ResultGetMessage(Res));
}
/* The output AST module context should be destroyed. */
WasmEdge_ASTModuleDelete(ASTCxt);

/* Load WASM or compiled-WASM from the buffer. */
Res = WasmEdge_LoaderParseFromBuffer(LoadCxt, &amp;ASTCxt, Buf, FileSize);
if (!WasmEdge_ResultOK(Res)) {
  printf(&quot;Loading phase failed: %s\n&quot;, WasmEdge_ResultGetMessage(Res));
}
/* The output AST module context should be destroyed. */
WasmEdge_ASTModuleDelete(ASTCxt);

WasmEdge_LoaderDelete(LoadCxt);
WasmEdge_ConfigureDelete(ConfCxt);
</code></pre>
<h3 id="validator-2"><a class="header" href="#validator-2">Validator</a></h3>
<p>The <code>Validator</code> context can validate the WASM module.
Every WASM module should be validated before instantiation.</p>
<pre><code class="language-c">/* 
 * ...
 * Assume that the `ASTCxt` is the output AST module context from the loader context.
 * Assume that the `ConfCxt` is the configure context.
 */
/* Create the validator context. The configure context can be NULL. */
WasmEdge_ValidatorContext *ValidCxt = WasmEdge_ValidatorCreate(ConfCxt);
WasmEdge_Result Res = WasmEdge_ValidatorValidate(ValidCxt, ASTCxt);
if (!WasmEdge_ResultOK(Res)) {
  printf(&quot;Validation phase failed: %s\n&quot;, WasmEdge_ResultGetMessage(Res));
}
WasmEdge_ValidatorDelete(ValidCxt);
</code></pre>
<h3 id="executor-2"><a class="header" href="#executor-2">Executor</a></h3>
<p>The <code>Executor</code> context is the executor for both WASM and compiled-WASM.
This object should work base on the <code>Store</code> context. For the details of the <code>Store</code> context, please refer to the <a href="sdk/c/0.9.1/ref.html#store">next chapter</a>.</p>
<ol>
<li>
<p>Register modules</p>
<p>As the same of <a href="sdk/c/0.9.1/ref.html#host-module-registrations">registering host modules</a> or <a href="sdk/c/0.9.1/ref.html#wasm-registrations-and-executions">importing WASM modules</a> in <code>VM</code> context, developers can register <code>Import Object</code> or <code>AST module</code> contexts into the <code>Store</code> context by the <code>Executor</code> APIs.
For the details of import objects, please refer to the <a href="sdk/c/0.9.1/ref.html#host-functions">Host Functions</a>.</p>
<pre><code class="language-c">/* 
* ...
* Assume that the `ASTCxt` is the output AST module context from the loader context
* and has passed the validation.
* Assume that the `ConfCxt` is the configure context.
*/
/* Create the statistics context. This step is not necessary. */
WasmEdge_StatisticsContext *StatCxt = WasmEdge_StatisticsCreate();
/* Create the executor context. The configure and the statistics contexts can be NULL. */
WasmEdge_ExecutorContext *ExecCxt = WasmEdge_ExecutorCreate(ConfCxt, StatCxt);
/* Create the store context. The store context is the WASM runtime structure core. */
WasmEdge_StoreContext *StoreCxt = WasmEdge_StoreCreate();
/* Result. */
WasmEdge_Result Res;

/* Register the WASM module into store with the export module name &quot;mod&quot;. */
WasmEdge_String ModName = WasmEdge_StringCreateByCString(&quot;mod&quot;);
Res = WasmEdge_ExecutorRegisterModule(ExecCxt, StoreCxt, ASTCxt, ModName);
if (!WasmEdge_ResultOK(Res)) {
  printf(&quot;WASM registration failed: %s\n&quot;, WasmEdge_ResultGetMessage(Res));
}
WasmEdge_StringDelete(ModName);

/* 
 * Assume that the `ImpCxt` is the import object context for host functions.
 */
WasmEdge_ImportObjectContext *ImpCxt = ...;
/* The import module context has already contained the export module name. */
Res = WasmEdge_ExecutorRegisterImport(ExecCxt, StoreCxt, ImpCxt);
if (!WasmEdge_ResultOK(Res)) {
  printf(&quot;Import object registration failed: %s\n&quot;, WasmEdge_ResultGetMessage(Res));
}

WasmEdge_ImportObjectDelete(ImpCxt);
WasmEdge_ExecutorDelete(ExecCxt);
WasmEdge_StatisticsDelete(StatCxt);
WasmEdge_StoreDelete(StoreCxt);
</code></pre>
</li>
<li>
<p>Instantiate modules</p>
<p>WASM or compiled-WASM modules should be instantiated before the function invocation.
Note that developers can only instantiate one module into the <code>Store</code> context, and in that case, the old instantiated module will be cleaned.
Before instantiating a WASM module, please check the <a href="https://webassembly.github.io/spec/core/syntax/modules.html#syntax-import">import section</a> for ensuring the imports are registered into the <code>Store</code> context.</p>
<pre><code class="language-c">/* 
* ...
* Assume that the `ASTCxt` is the output AST module context from the loader context
* and has passed the validation.
* Assume that the `ConfCxt` is the configure context.
*/
/* Create the statistics context. This step is not necessary. */
WasmEdge_StatisticsContext *StatCxt = WasmEdge_StatisticsCreate();
/* Create the executor context. The configure and the statistics contexts can be NULL. */
WasmEdge_ExecutorContext *ExecCxt = WasmEdge_ExecutorCreate(ConfCxt, StatCxt);
/* Create the store context. The store context is the WASM runtime structure core. */
WasmEdge_StoreContext *StoreCxt = WasmEdge_StoreCreate();

/* Instantiate the WASM module. */
WasmEdge_Result Res = WasmEdge_ExecutorInstantiate(ExecCxt, StoreCxt, ASTCxt);
if (!WasmEdge_ResultOK(Res)) {
  printf(&quot;WASM instantiation failed: %s\n&quot;, WasmEdge_ResultGetMessage(Res));
}

WasmEdge_ExecutorDelete(ExecCxt);
WasmEdge_StatisticsDelete(StatCxt);
WasmEdge_StoreDelete(StoreCxt);
</code></pre>
</li>
<li>
<p>Invoke functions</p>
<p>As the same as function invocation via the <code>VM</code> context, developers can invoke the functions of the instantiated or registered modules.
The APIs, <code>WasmEdge_ExecutorInvoke()</code> and <code>WasmEdge_ExecutorInvokeRegistered()</code>, are similar as the APIs of the <code>VM</code> context.
Please refer to the <a href="sdk/c/0.9.1/ref.html#wasm-execution-example-with-vm-context">VM context workflows</a> for details.</p>
</li>
</ol>
<h3 id="ast-module-2"><a class="header" href="#ast-module-2">AST Module</a></h3>
<p>The <code>AST Module</code> context presents the loaded structure from a WASM file or buffer. Developer will get this object after loading a WASM file or buffer from <a href="sdk/c/0.9.1/ref.html#loader">Loader</a>.
Before instantiation, developers can also query the imports and exports of an <code>AST Module</code> context.</p>
<pre><code class="language-c">WasmEdge_ASTModuleContext *ASTCxt = ...;
/* Assume that a WASM is loaded into an AST module context. */

/* Create the import type context buffers. */
const uint32_t BUF_LEN = 256;
const WasmEdge_ImportTypeContext *ImpTypes[BUF_LEN];
uint32_t ImportNum = WasmEdge_ASTModuleListImportsLength(ASTCxt);
/* If the list length is larger than the buffer length, the overflowed data will be discarded. */
uint32_t RealImportNum = WasmEdge_ASTModuleListImports(ASTCxt, ImpTypes, BUF_LEN);
for (uint32_t I = 0; I &lt; RealImportNum &amp;&amp; I &lt; BUF_LEN; I++) {
  /* Working with the import type `ImpTypes[I]` ... */
}

/* Create the export type context buffers. */
const WasmEdge_ExportTypeContext *ExpTypes[BUF_LEN];
uint32_t ExportNum = WasmEdge_ASTModuleListExportsLength(ASTCxt);
/* If the list length is larger than the buffer length, the overflowed data will be discarded. */
uint32_t RealExportNum = WasmEdge_ASTModuleListExports(ASTCxt, ExpTypes, BUF_LEN);
for (uint32_t I = 0; I &lt; RealExportNum &amp;&amp; I &lt; BUF_LEN; I++) {
  /* Working with the export type `ExpTypes[I]` ... */
}

WasmEdge_ASTModuleDelete(ASTCxt);
/* After deletion of `ASTCxt`, all data queried from the `ASTCxt` should not be accessed. */
</code></pre>
<h3 id="store-2"><a class="header" href="#store-2">Store</a></h3>
<p><a href="https://webassembly.github.io/spec/core/exec/runtime.html#store">Store</a> is the runtime structure for the representation of all instances of <code>Function</code>s, <code>Table</code>s, <code>Memory</code>s, and <code>Global</code>s that have been allocated during the lifetime of the abstract machine.
The <code>Store</code> context in WasmEdge provides APIs to list the exported instances with their names or find the instances by exported names. For adding instances into <code>Store</code> contexts, please instantiate or register WASM modules or <code>Import Object</code> contexts via the <code>Executor</code> context.</p>
<ol>
<li>
<p>List instances</p>
<pre><code class="language-c">WasmEdge_StoreContext *StoreCxt = WasmEdge_StoreCreate();
/* ... Instantiate a WASM module via the executor context. */
...

/* Try to list the exported functions of the instantiated WASM module. */
/* Take the function instances for example here. */
uint32_t FuncNum = WasmEdge_StoreListFunctionLength(StoreCxt);
/* Create the name buffers. */
const uint32_t BUF_LEN = 256;
WasmEdge_String FuncNames[BUF_LEN];
/* If the list length is larger than the buffer length, the overflowed data will be discarded. */
uint32_t RealFuncNum = WasmEdge_StoreListFunction(StoreCxt, FuncNames, BUF_LEN);
for (uint32_t I = 0; I &lt; RealFuncNum &amp;&amp; I &lt; BUF_LEN; I++) {
  /* Working with the function name `FuncNames[I]` ... */
  /* The function names should __NOT__ be destroyed. */
}
</code></pre>
<p>Developers can list the function instance exported names of the registered modules via the <code>WasmEdge_StoreListFunctionRegisteredLength()</code> and the <code>WasmEdge_StoreListFunctionRegistered()</code> APIs with the module name.</p>
</li>
<li>
<p>Find instances</p>
<pre><code class="language-c">WasmEdge_StoreContext *StoreCxt = WasmEdge_StoreCreate();
/* ... Instantiate a WASM module via the executor context. */
...

/* Try to find the exported instance of the instantiated WASM module. */
/* Take the function instances for example here. */
/* Function name. */
WasmEdge_String FuncName = WasmEdge_StringCreateByCString(&quot;fib&quot;);
WasmEdge_FunctionInstanceContext *FuncCxt = WasmEdge_StoreFindFunction(StoreCxt, FuncName);
/* `FuncCxt` will be `NULL` if the function not found. */
/* The returned instance is owned by the store context and should __NOT__ be destroyed. */
WasmEdge_StringDelete(FuncName);
</code></pre>
<p>Developers can retrieve the exported function instances of the registered modules via the <code>WasmEdge_StoreFindFunctionRegistered()</code> API with the module name.</p>
</li>
<li>
<p>List registered modules</p>
<p>With the module names, developers can list the exported instances of the registered modules with their names.</p>
<pre><code class="language-c">WasmEdge_StoreContext *StoreCxt = WasmEdge_StoreCreate();
/* ... Register a WASM module via the executor context. */
...

/* Try to list the registered WASM modules. */
uint32_t ModNum = WasmEdge_StoreListModuleLength(StoreCxt);
/* Create the name buffers. */
const uint32_t BUF_LEN = 256;
WasmEdge_String ModNames[BUF_LEN];
/* If the list length is larger than the buffer length, the overflowed data will be discarded. */
uint32_t RealModNum = WasmEdge_StoreListModule(StoreCxt, ModNames, BUF_LEN);
for (uint32_t I = 0; I &lt; RealModNum &amp;&amp; I &lt; BUF_LEN; I++) {
  /* Working with the module name `ModNames[I]` ... */
  /* The module names should __NOT__ be destroyed. */
}
</code></pre>
</li>
</ol>
<h3 id="instances-2"><a class="header" href="#instances-2">Instances</a></h3>
<p>The instances are the runtime structures of WASM. Developers can retrieve the instances from the <code>Store</code> contexts.
The <code>Store</code> contexts will allocate instances when a WASM module or <code>Import Object</code> is registered or instantiated through the <code>Executor</code>.
A single instance can be allocated by its creation function. Developers can construct instances into an <code>Import Object</code> for registration. Please refer to the <a href="sdk/c/0.9.1/ref.html#host-functions">Host Functions</a> for details.
The instances created by their creation functions should be destroyed, EXCEPT they are added into an <code>Import Object</code> context.</p>
<ol>
<li>
<p>Function instance</p>
<p><a href="https://webassembly.github.io/spec/core/exec/runtime.html#syntax-hostfunc">Host functions</a> are functions outside WebAssembly and passed to WASM modules as imports.
In WasmEdge, developers can create the <code>Function</code> contexts for host functions and add them into an <code>Import Object</code> context for registering into a <code>VM</code> or a <code>Store</code>.
For both host functions and the functions get from <code>Store</code>, developers can retrieve the <code>Function Type</code> from the <code>Function</code> contexts.
For the details of the <code>Host Function</code> guide, please refer to the <a href="sdk/c/0.9.1/ref.html#host-functions">next chapter</a>.</p>
<pre><code class="language-c">/* Retrieve the function instance from the store context. */
WasmEdge_FunctionInstanceContext *FuncCxt = ...;
WasmEdge_FunctionTypeContext *FuncTypeCxt = WasmEdge_FunctionInstanceGetFunctionType(FuncCxt);
/* The `FuncTypeCxt` is owned by the `FuncCxt` and should __NOT__ be destroyed. */
</code></pre>
</li>
<li>
<p>Table instance</p>
<p>In WasmEdge, developers can create the <code>Table</code> contexts and add them into an <code>Import Object</code> context for registering into a <code>VM</code> or a <code>Store</code>.
The <code>Table</code> contexts supply APIs to control the data in table instances.</p>
<pre><code class="language-c">WasmEdge_Limit TabLimit = {.HasMax = true, .Min = 10, .Max = 20};
/* Create the table type with limit and the `FuncRef` element type. */
WasmEdge_TableTypeContext *TabTypeCxt = WasmEdge_TableTypeCreate(WasmEdge_RefType_FuncRef, TabLimit);
/* Create the table instance with table type. */
WasmEdge_TableInstanceContext *HostTable = WasmEdge_TableInstanceCreate(TabTypeCxt);
/* Delete the table type. */
WasmEdge_TableTypeDelete(TabTypeCxt);
WasmEdge_Result Res;
WasmEdge_Value Data;

TabTypeCxt = WasmEdge_TableInstanceGetTableType(HostTable);
/* The `TabTypeCxt` got from table instance is owned by the `HostTable` and should __NOT__ be destroyed. */
enum WasmEdge_RefType RefType = WasmEdge_TableTypeGetRefType(TabTypeCxt);
/* `RefType` will be `WasmEdge_RefType_FuncRef`. */
Data = WasmEdge_ValueGenFuncRef(5);
Res = WasmEdge_TableInstanceSetData(HostTable, Data, 3);
/* Set the function index 5 to the table[3]. */
/*
 * This will get an &quot;out of bounds table access&quot; error
 * because the position (13) is out of the table size (10):
 *   Res = WasmEdge_TableInstanceSetData(HostTable, Data, 13);
 */
Res = WasmEdge_TableInstanceGetData(HostTable, &amp;Data, 3);
/* Get the FuncRef value of the table[3]. */
/*
 * This will get an &quot;out of bounds table access&quot; error
 * because the position (13) is out of the table size (10):
 *   Res = WasmEdge_TableInstanceGetData(HostTable, &amp;Data, 13);
 */

uint32_t Size = WasmEdge_TableInstanceGetSize(HostTable);
/* `Size` will be 10. */
Res = WasmEdge_TableInstanceGrow(HostTable, 6);
/* Grow the table size of 6, the table size will be 16. */
/*
 * This will get an &quot;out of bounds table access&quot; error because
 * the size (16 + 6) will reach the table limit(20):
 *   Res = WasmEdge_TableInstanceGrow(HostTable, 6);
 */

WasmEdge_TableInstanceDelete(HostTable);
</code></pre>
</li>
<li>
<p>Memory instance</p>
<p>In WasmEdge, developers can create the <code>Memory</code> contexts and add them into an <code>Import Object</code> context for registering into a <code>VM</code> or a <code>Store</code>.
The <code>Memory</code> contexts supply APIs to control the data in memory instances.</p>
<pre><code class="language-c">WasmEdge_Limit MemLimit = {.HasMax = true, .Min = 1, .Max = 5};
/* Create the memory type with limit. The memory page size is 64KiB. */
WasmEdge_MemoryTypeContext *MemTypeCxt = WasmEdge_MemoryTypeCreate(MemLimit);
/* Create the memory instance with memory type. */
WasmEdge_MemoryInstanceContext *HostMemory = WasmEdge_MemoryInstanceCreate(MemTypeCxt);
/* Delete the memory type. */
WasmEdge_MemoryTypeDelete(MemTypeCxt);
WasmEdge_Result Res;
uint8_t Buf[256];

Buf[0] = 0xAA;
Buf[1] = 0xBB;
Buf[2] = 0xCC;
Res = WasmEdge_MemoryInstanceSetData(HostMemory, Buf, 0x1000, 3);
/* Set the data[0:2] to the memory[4096:4098]. */
/*
 * This will get an &quot;out of bounds memory access&quot; error
 * because [65535:65537] is out of 1 page size (65536):
 *   Res = WasmEdge_MemoryInstanceSetData(HostMemory, Buf, 0xFFFF, 3);
 */
Buf[0] = 0;
Buf[1] = 0;
Buf[2] = 0;
Res = WasmEdge_MemoryInstanceGetData(HostMemory, Buf, 0x1000, 3);
/* Get the memory[4096:4098]. Buf[0:2] will be `{0xAA, 0xBB, 0xCC}`. */
/*
 * This will get an &quot;out of bounds memory access&quot; error
 * because [65535:65537] is out of 1 page size (65536):
 *   Res = WasmEdge_MemoryInstanceSetData(HostMemory, Buf, 0xFFFF, 3);
 */

uint32_t PageSize = WasmEdge_MemoryInstanceGetPageSize(HostMemory);
/* `PageSize` will be 1. */
Res = WasmEdge_MemoryInstanceGrowPage(HostMemory, 2);
/* Grow the page size of 2, the page size of the memory instance will be 3. */
/*
 * This will get an &quot;out of bounds memory access&quot; error because
 * the page size (3 + 3) will reach the memory limit(5):
 *   Res = WasmEdge_MemoryInstanceGrowPage(HostMemory, 3);
 */

WasmEdge_MemoryInstanceDelete(HostMemory);
</code></pre>
</li>
<li>
<p>Global instance</p>
<p>In WasmEdge, developers can create the <code>Global</code> contexts and add them into an <code>Import Object</code> context for registering into a <code>VM</code> or a <code>Store</code>.
The <code>Global</code> contexts supply APIs to control the value in global instances.</p>
<pre><code class="language-c">WasmEdge_Value Val = WasmEdge_ValueGenI64(1000);
/* Create the global type with value type and mutation. */
WasmEdge_GlobalTypeContext *GlobTypeCxt = WasmEdge_GlobalTypeCreate(WasmEdge_ValType_I64, WasmEdge_Mutability_Var);
/* Create the global instance with value and global type. */
WasmEdge_GlobalInstanceContext *HostGlobal = WasmEdge_GlobalInstanceCreate(GlobTypeCxt, Val);
/* Delete the global type. */
WasmEdge_GlobalTypeDelete(GlobTypeCxt);
WasmEdge_Result Res;

GlobTypeCxt = WasmEdge_GlobalInstanceGetGlobalType(HostGlobal);
/* The `GlobTypeCxt` got from global instance is owned by the `HostGlobal` and should __NOT__ be destroyed. */
enum WasmEdge_ValType ValType = WasmEdge_GlobalTypeGetValType(GlobTypeCxt);
/* `ValType` will be `WasmEdge_ValType_I64`. */
enum WasmEdge_Mutability ValMut = WasmEdge_GlobalTypeGetMutability(GlobTypeCxt);
/* `ValMut` will be `WasmEdge_Mutability_Var`. */

WasmEdge_GlobalInstanceSetValue(HostGlobal, WasmEdge_ValueGenI64(888));
/* 
 * Set the value u64(888) to the global.
 * This function will do nothing if the value type mismatched or
 * the global mutability is `WasmEdge_Mutability_Const`.
 */
WasmEdge_Value GlobVal = WasmEdge_GlobalInstanceGetValue(HostGlobal);
/* Get the value (888 now) of the global context. */

WasmEdge_GlobalInstanceDelete(HostGlobal);
</code></pre>
</li>
</ol>
<h3 id="host-functions-4"><a class="header" href="#host-functions-4">Host Functions</a></h3>
<p><a href="https://webassembly.github.io/spec/core/exec/runtime.html#syntax-hostfunc">Host functions</a> are functions outside WebAssembly and passed to WASM modules as imports.
In WasmEdge, developers can create the <code>Function</code>, <code>Memory</code>, <code>Table</code>, and <code>Global</code> contexts and add them into an <code>Import Object</code> context for registering into a <code>VM</code> or a <code>Store</code>.</p>
<ol>
<li>
<p>Host function allocation</p>
<p>Developers can define C functions with the following function signature as the host function body:</p>
<pre><code class="language-c">typedef WasmEdge_Result (*WasmEdge_HostFunc_t)(
  void *Data,
  WasmEdge_MemoryInstanceContext *MemCxt,
  const WasmEdge_Value *Params,
  WasmEdge_Value *Returns);
</code></pre>
<p>The example of an <code>add</code> host function to add 2 <code>i32</code> values:</p>
<pre><code class="language-c">WasmEdge_Result Add(void *, WasmEdge_MemoryInstanceContext *,
                    const WasmEdge_Value *In, WasmEdge_Value *Out) {
  /*
  * Params: {i32, i32}
  * Returns: {i32}
  * Developers should take care about the function type.
  */ 
  /* Retrieve the value 1. */
  int32_t Val1 = WasmEdge_ValueGetI32(In[0]);
  /* Retrieve the value 2. */
  int32_t Val2 = WasmEdge_ValueGetI32(In[1]);
  /* Output value 1 is Val1 + Val2. */
  Out[0] = WasmEdge_ValueGenI32(Val1 + Val2);
  /* Return the status of success. */
  return WasmEdge_Result_Success;
}
</code></pre>
<p>Then developers can create <code>Function</code> context with the host function body and function type:</p>
<pre><code class="language-c">enum WasmEdge_ValType ParamList[2] = { WasmEdge_ValType_I32, WasmEdge_ValType_I32 };
enum WasmEdge_ValType ReturnList[1] = { WasmEdge_ValType_I32 };
/* Create a function type: {i32, i32} -&gt; {i32}. */
HostFType = WasmEdge_FunctionTypeCreate(ParamList, 2, ReturnList, 1);
/* 
 * Create a function context with the function type and host function body.
 * The `Cost` parameter can be 0 if developers do not need the cost measuring.
 */
WasmEdge_FunctionInstanceContext *HostFunc = WasmEdge_FunctionInstanceCreate(HostFType, Add, NULL, 0);
/*
 * The third parameter is the pointer to the additional data.
 * Developers should guarantee the life cycle of the data, and it can be
 * `NULL` if the external data is not needed.
 */

/* If the function instance is not added into an import object context, it should be deleted. */
WasmEdge_FunctionInstanceDelete(HostFunc);
</code></pre>
</li>
<li>
<p>Import object context</p>
<p>The <code>Import Object</code> context holds an exporting module name and the instances. Developers can add the <code>Function</code>, <code>Memory</code>, <code>Table</code>, and <code>Global</code> instances with their exporting names.</p>
<pre><code class="language-c">/* Host function body definition. */
WasmEdge_Result Add(void *Data, WasmEdge_MemoryInstanceContext *MemCxt,
                    const WasmEdge_Value *In, WasmEdge_Value *Out) {
  int32_t Val1 = WasmEdge_ValueGetI32(In[0]);
  int32_t Val2 = WasmEdge_ValueGetI32(In[1]);
  Out[0] = WasmEdge_ValueGenI32(Val1 + Val2);
  return WasmEdge_Result_Success;
}

/* Create the import object. */
WasmEdge_String ExportName = WasmEdge_StringCreateByCString(&quot;module&quot;);
WasmEdge_ImportObjectContext *ImpObj = WasmEdge_ImportObjectCreate(ExportName);
WasmEdge_StringDelete(ExportName);

/* Create and add a function instance into the import object. */
enum WasmEdge_ValType ParamList[2] = { WasmEdge_ValType_I32, WasmEdge_ValType_I32 };
enum WasmEdge_ValType ReturnList[1] = { WasmEdge_ValType_I32 };
WasmEdge_FunctionTypeContext *HostFType = 
  WasmEdge_FunctionTypeCreate(ParamList, 2, ReturnList, 1);
WasmEdge_FunctionInstanceContext *HostFunc =
  WasmEdge_FunctionInstanceCreate(HostFType, Add, NULL, 0);
/*
 * The third parameter is the pointer to the additional data object.
 * Developers should guarantee the life cycle of the data, and it can be
 * `NULL` if the external data is not needed.
 */
WasmEdge_FunctionTypeDelete(HostFType);
WasmEdge_String FuncName = WasmEdge_StringCreateByCString(&quot;add&quot;);
WasmEdge_ImportObjectAddFunction(ImpObj, FuncName, HostFunc);
WasmEdge_StringDelete(FuncName);

/* Create and add a table instance into the import object. */
WasmEdge_Limit TableLimit = {.HasMax = true, .Min = 10, .Max = 20};
WasmEdge_TableTypeContext *HostTType = 
  WasmEdge_TableTypeCreate(WasmEdge_RefType_FuncRef, TableLimit);
WasmEdge_TableInstanceContext *HostTable = WasmEdge_TableInstanceCreate(HostTType);
WasmEdge_TableTypeDelete(HostTType);
WasmEdge_String TableName = WasmEdge_StringCreateByCString(&quot;table&quot;);
WasmEdge_ImportObjectAddTable(ImpObj, TableName, HostTable);
WasmEdge_StringDelete(TableName);

/* Create and add a memory instance into the import object. */
WasmEdge_Limit MemoryLimit = {.HasMax = true, .Min = 1, .Max = 2};
WasmEdge_MemoryTypeContext *HostMType = WasmEdge_MemoryTypeCreate(MemoryLimit);
WasmEdge_MemoryInstanceContext *HostMemory = WasmEdge_MemoryInstanceCreate(HostMType);
WasmEdge_MemoryTypeDelete(HostMType);
WasmEdge_String MemoryName = WasmEdge_StringCreateByCString(&quot;memory&quot;);
WasmEdge_ImportObjectAddMemory(ImpObj, MemoryName, HostMemory);
WasmEdge_StringDelete(MemoryName);

/* Create and add a global instance into the import object. */
WasmEdge_GlobalTypeContext *HostGType =
  WasmEdge_GlobalTypeCreate(WasmEdge_ValType_I32, WasmEdge_Mutability_Var);
WasmEdge_GlobalInstanceContext *HostGlobal =
  WasmEdge_GlobalInstanceCreate(HostGType, WasmEdge_ValueGenI32(666));
WasmEdge_GlobalTypeDelete(HostGType);
WasmEdge_String GlobalName = WasmEdge_StringCreateByCString(&quot;global&quot;);
WasmEdge_ImportObjectAddGlobal(ImpObj, GlobalName, HostGlobal);
WasmEdge_StringDelete(GlobalName);

/*
 * The import objects should be deleted.
 * Developers should __NOT__ destroy the instances added into the import object contexts.
 */
WasmEdge_ImportObjectDelete(ImpObj);
</code></pre>
</li>
<li>
<p>Specified import object</p>
<p><code>WasmEdge_ImportObjectCreateWASI()</code> API can create and initialize the <code>WASI</code> import object.
<code>WasmEdge_ImportObjectCreateWasmEdgeProcess()</code> API can create and initialize the <code>wasmedge_process</code> import object.
Developers can create these import object contexts and register them into the <code>Store</code> or <code>VM</code> contexts rather than adjust the settings in the <code>Configure</code> contexts.</p>
<pre><code class="language-c">WasmEdge_ImportObjectContext *WasiObj = WasmEdge_ImportObjectCreateWASI( /* ... ignored */ );
WasmEdge_ImportObjectContext *ProcObj = WasmEdge_ImportObjectCreateWasmEdgeProcess( /* ... ignored */ );
WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(NULL, NULL);
/* Register the WASI and WasmEdge_Process into the VM context. */
WasmEdge_VMRegisterModuleFromImport(VMCxt, WasiObj);
WasmEdge_VMRegisterModuleFromImport(VMCxt, ProcObj);
/* Get the WASI exit code. */
uint32_t ExitCode = WasmEdge_ImportObjectWASIGetExitCode(WasiObj);
/*
 * The `ExitCode` will be EXIT_SUCCESS if the execution has no error.
 * Otherwise, it will return with the related exit code.
 */
WasmEdge_VMDelete(VMCxt);
/* The import objects should be deleted. */
WasmEdge_ImportObjectDelete(WasiObj);
WasmEdge_ImportObjectDelete(ProcObj);
</code></pre>
</li>
<li>
<p>Example</p>
<p>Assume that a simple WASM from the WAT as following:</p>
<pre><code class="language-wasm">(module
  (type $t0 (func (param i32 i32) (result i32)))
  (import &quot;extern&quot; &quot;func-add&quot; (func $f-add (type $t0)))
  (func (export &quot;addTwo&quot;) (param i32 i32) (result i32)
    local.get 0
    local.get 1
    call $f-add)
)
</code></pre>
<p>And the <code>test.c</code> as following:</p>
<pre><code class="language-c">#include &lt;wasmedge/wasmedge.h&gt;
#include &lt;stdio.h&gt;

/* Host function body definition. */
WasmEdge_Result Add(void *Data, WasmEdge_MemoryInstanceContext *MemCxt,
                    const WasmEdge_Value *In, WasmEdge_Value *Out) {
  int32_t Val1 = WasmEdge_ValueGetI32(In[0]);
  int32_t Val2 = WasmEdge_ValueGetI32(In[1]);
  printf(&quot;Host function \&quot;Add\&quot;: %d + %d\n&quot;, Val1, Val2);
  Out[0] = WasmEdge_ValueGenI32(Val1 + Val2);
  return WasmEdge_Result_Success;
}

int main() {
  /* Create the VM context. */
  WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(NULL, NULL);

  /* The WASM module buffer. */
  uint8_t WASM[] = {
    /* WASM header */
    0x00, 0x61, 0x73, 0x6D, 0x01, 0x00, 0x00, 0x00,
    /* Type section */
    0x01, 0x07, 0x01,
    /* function type {i32, i32} -&gt; {i32} */
    0x60, 0x02, 0x7F, 0x7F, 0x01, 0x7F,
    /* Import section */
    0x02, 0x13, 0x01,
    /* module name: &quot;extern&quot; */
    0x06, 0x65, 0x78, 0x74, 0x65, 0x72, 0x6E,
    /* extern name: &quot;func-add&quot; */
    0x08, 0x66, 0x75, 0x6E, 0x63, 0x2D, 0x61, 0x64, 0x64,
    /* import desc: func 0 */
    0x00, 0x00,
    /* Function section */
    0x03, 0x02, 0x01, 0x00,
    /* Export section */
    0x07, 0x0A, 0x01,
    /* export name: &quot;addTwo&quot; */
    0x06, 0x61, 0x64, 0x64, 0x54, 0x77, 0x6F,
    /* export desc: func 0 */
    0x00, 0x01,
    /* Code section */
    0x0A, 0x0A, 0x01,
    /* code body */
    0x08, 0x00, 0x20, 0x00, 0x20, 0x01, 0x10, 0x00, 0x0B
  };

  /* Create the import object. */
  WasmEdge_String ExportName = WasmEdge_StringCreateByCString(&quot;extern&quot;);
  WasmEdge_ImportObjectContext *ImpObj = WasmEdge_ImportObjectCreate(ExportName);
  enum WasmEdge_ValType ParamList[2] = { WasmEdge_ValType_I32, WasmEdge_ValType_I32 };
  enum WasmEdge_ValType ReturnList[1] = { WasmEdge_ValType_I32 };
  WasmEdge_FunctionTypeContext *HostFType = WasmEdge_FunctionTypeCreate(ParamList, 2, ReturnList, 1);
  WasmEdge_FunctionInstanceContext *HostFunc = WasmEdge_FunctionInstanceCreate(HostFType, Add, NULL, 0);
  WasmEdge_FunctionTypeDelete(HostFType);
  WasmEdge_String HostFuncName = WasmEdge_StringCreateByCString(&quot;func-add&quot;);
  WasmEdge_ImportObjectAddFunction(ImpObj, HostFuncName, HostFunc);
  WasmEdge_StringDelete(HostFuncName);

  WasmEdge_VMRegisterModuleFromImport(VMCxt, ImpObj);

  /* The parameters and returns arrays. */
  WasmEdge_Value Params[2] = { WasmEdge_ValueGenI32(1234), WasmEdge_ValueGenI32(5678) };
  WasmEdge_Value Returns[1];
  /* Function name. */
  WasmEdge_String FuncName = WasmEdge_StringCreateByCString(&quot;addTwo&quot;);
  /* Run the WASM function from file. */
  WasmEdge_Result Res = WasmEdge_VMRunWasmFromBuffer(
    VMCxt, WASM, sizeof(WASM), FuncName, Params, 2, Returns, 1);

  if (WasmEdge_ResultOK(Res)) {
    printf(&quot;Get the result: %d\n&quot;, WasmEdge_ValueGetI32(Returns[0]));
  } else {
    printf(&quot;Error message: %s\n&quot;, WasmEdge_ResultGetMessage(Res));
  }

  /* Resources deallocations. */
  WasmEdge_VMDelete(VMCxt);
  WasmEdge_StringDelete(FuncName);
  WasmEdge_ImportObjectDelete(ImpObj);
  return 0;
}
</code></pre>
<p>Then you can compile and run: (the result of 1234 + 5678 is 6912)</p>
<pre><code class="language-bash">$ gcc test.c -lwasmedge_c
$ ./a.out
Host function &quot;Add&quot;: 1234 + 5678
Get the result: 6912
</code></pre>
</li>
<li>
<p>Host Data Example</p>
<p>Developers can set a external data object to the function context, and access to the object in the function body.
Assume that a simple WASM from the WAT as following:</p>
<pre><code class="language-wasm">(module
  (type $t0 (func (param i32 i32) (result i32)))
  (import &quot;extern&quot; &quot;func-add&quot; (func $f-add (type $t0)))
  (func (export &quot;addTwo&quot;) (param i32 i32) (result i32)
    local.get 0
    local.get 1
    call $f-add)
)
</code></pre>
<p>And the <code>test.c</code> as following:</p>
<pre><code class="language-c">#include &lt;wasmedge/wasmedge.h&gt;
#include &lt;stdio.h&gt;

/* Host function body definition. */
WasmEdge_Result Add(void *Data, WasmEdge_MemoryInstanceContext *MemCxt,
                    const WasmEdge_Value *In, WasmEdge_Value *Out) {
  int32_t Val1 = WasmEdge_ValueGetI32(In[0]);
  int32_t Val2 = WasmEdge_ValueGetI32(In[1]);
  printf(&quot;Host function \&quot;Add\&quot;: %d + %d\n&quot;, Val1, Val2);
  Out[0] = WasmEdge_ValueGenI32(Val1 + Val2);
  /* Also set the result to the data. */
  int32_t *DataPtr = (int32_t *)Data;
  *DataPtr = Val1 + Val2;
  return WasmEdge_Result_Success;
}

int main() {
  /* Create the VM context. */
  WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(NULL, NULL);

  /* The WASM module buffer. */
  uint8_t WASM[] = {
    /* WASM header */
    0x00, 0x61, 0x73, 0x6D, 0x01, 0x00, 0x00, 0x00,
    /* Type section */
    0x01, 0x07, 0x01,
    /* function type {i32, i32} -&gt; {i32} */
    0x60, 0x02, 0x7F, 0x7F, 0x01, 0x7F,
    /* Import section */
    0x02, 0x13, 0x01,
    /* module name: &quot;extern&quot; */
    0x06, 0x65, 0x78, 0x74, 0x65, 0x72, 0x6E,
    /* extern name: &quot;func-add&quot; */
    0x08, 0x66, 0x75, 0x6E, 0x63, 0x2D, 0x61, 0x64, 0x64,
    /* import desc: func 0 */
    0x00, 0x00,
    /* Function section */
    0x03, 0x02, 0x01, 0x00,
    /* Export section */
    0x07, 0x0A, 0x01,
    /* export name: &quot;addTwo&quot; */
    0x06, 0x61, 0x64, 0x64, 0x54, 0x77, 0x6F,
    /* export desc: func 0 */
    0x00, 0x01,
    /* Code section */
    0x0A, 0x0A, 0x01,
    /* code body */
    0x08, 0x00, 0x20, 0x00, 0x20, 0x01, 0x10, 0x00, 0x0B
  };

  /* The external data object: an integer. */
  int32_t Data;

  /* Create the import object. */
  WasmEdge_String ExportName = WasmEdge_StringCreateByCString(&quot;extern&quot;);
  WasmEdge_ImportObjectContext *ImpObj = WasmEdge_ImportObjectCreate(ExportName);
  enum WasmEdge_ValType ParamList[2] = { WasmEdge_ValType_I32, WasmEdge_ValType_I32 };
  enum WasmEdge_ValType ReturnList[1] = { WasmEdge_ValType_I32 };
  WasmEdge_FunctionTypeContext *HostFType = WasmEdge_FunctionTypeCreate(ParamList, 2, ReturnList, 1);
  WasmEdge_FunctionInstanceContext *HostFunc = WasmEdge_FunctionInstanceCreate(HostFType, Add, &amp;Data, 0);
  WasmEdge_FunctionTypeDelete(HostFType);
  WasmEdge_String HostFuncName = WasmEdge_StringCreateByCString(&quot;func-add&quot;);
  WasmEdge_ImportObjectAddFunction(ImpObj, HostFuncName, HostFunc);
  WasmEdge_StringDelete(HostFuncName);

  WasmEdge_VMRegisterModuleFromImport(VMCxt, ImpObj);

  /* The parameters and returns arrays. */
  WasmEdge_Value Params[2] = { WasmEdge_ValueGenI32(1234), WasmEdge_ValueGenI32(5678) };
  WasmEdge_Value Returns[1];
  /* Function name. */
  WasmEdge_String FuncName = WasmEdge_StringCreateByCString(&quot;addTwo&quot;);
  /* Run the WASM function from file. */
  WasmEdge_Result Res = WasmEdge_VMRunWasmFromBuffer(
    VMCxt, WASM, sizeof(WASM), FuncName, Params, 2, Returns, 1);

  if (WasmEdge_ResultOK(Res)) {
    printf(&quot;Get the result: %d\n&quot;, WasmEdge_ValueGetI32(Returns[0]));
  } else {
    printf(&quot;Error message: %s\n&quot;, WasmEdge_ResultGetMessage(Res));
  }
  printf(&quot;Data value: %d\n&quot;, Data);

  /* Resources deallocations. */
  WasmEdge_VMDelete(VMCxt);
  WasmEdge_StringDelete(FuncName);
  WasmEdge_ImportObjectDelete(ImpObj);
  return 0;
}
</code></pre>
<p>Then you can compile and run: (the result of 1234 + 5678 is 6912)</p>
<pre><code class="language-bash">$ gcc test.c -lwasmedge_c
$ ./a.out
Host function &quot;Add&quot;: 1234 + 5678
Get the result: 6912
Data value: 6912
</code></pre>
</li>
</ol>
<h2 id="wasmedge-aot-compiler-2"><a class="header" href="#wasmedge-aot-compiler-2">WasmEdge AOT Compiler</a></h2>
<p>In this partition, we will introduce the WasmEdge AOT compiler and the options.</p>
<p>WasmEdge runs the WASM files in interpreter mode, and WasmEdge also supports the AOT (ahead-of-time) mode running without modifying any code.
The WasmEdge AOT (ahead-of-time) compiler compiles the WASM files for running in AOT mode which is much faster than interpreter mode. Developers can compile the WASM files into the compiled-WASM files in shared library format for universal WASM format for the AOT mode execution.</p>
<h3 id="compilation-example-2"><a class="header" href="#compilation-example-2">Compilation Example</a></h3>
<p>Assume that the WASM file <a href="https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/examples/wasm/fibonacci.wasm"><code>fibonacci.wasm</code></a> is copied into the current directory, and the C file <code>test.c</code> is as following:</p>
<pre><code class="language-c">#include &lt;wasmedge/wasmedge.h&gt;
#include &lt;stdio.h&gt;
int main() {
  /* Create the configure context. */
  WasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();
  /* ... Adjust settings in the configure context. */
  /* Result. */
  WasmEdge_Result Res;

  /* Create the compiler context. The configure context can be NULL. */
  WasmEdge_CompilerContext *CompilerCxt = WasmEdge_CompilerCreate(ConfCxt);
  /* Compile the WASM file with input and output paths. */
  Res = WasmEdge_CompilerCompile(CompilerCxt, &quot;fibonacci.wasm&quot;, &quot;fibonacci.wasm.so&quot;);
  if (!WasmEdge_ResultOK(Res)) {
      printf(&quot;Compilation failed: %s\n&quot;, WasmEdge_ResultGetMessage(Res));
      return 1;
  }

  WasmEdge_CompilerDelete(CompilerCxt);
  WasmEdge_ConfigureDelete(ConfCxt);
  return 0;
}
</code></pre>
<p>Then you can compile and run (the output file is &quot;fibonacci.wasm.so&quot;):</p>
<pre><code class="language-bash">$ gcc test.c -lwasmedge_c
$ ./a.out
[2021-07-02 11:08:08.651] [info] compile start
[2021-07-02 11:08:08.653] [info] verify start
[2021-07-02 11:08:08.653] [info] optimize start
[2021-07-02 11:08:08.670] [info] codegen start
[2021-07-02 11:08:08.706] [info] compile done
</code></pre>
<h3 id="compiler-options-2"><a class="header" href="#compiler-options-2">Compiler Options</a></h3>
<p>Developers can set options for AOT compilers such as optimization level and output format:</p>
<pre><code class="language-c">/// AOT compiler optimization level enumeration.
enum WasmEdge_CompilerOptimizationLevel {
  /// Disable as many optimizations as possible.
  WasmEdge_CompilerOptimizationLevel_O0 = 0,
  /// Optimize quickly without destroying debuggability.
  WasmEdge_CompilerOptimizationLevel_O1,
  /// Optimize for fast execution as much as possible without triggering
  /// significant incremental compile time or code size growth.
  WasmEdge_CompilerOptimizationLevel_O2,
  /// Optimize for fast execution as much as possible.
  WasmEdge_CompilerOptimizationLevel_O3,
  /// Optimize for small code size as much as possible without triggering
  /// significant incremental compile time or execution time slowdowns.
  WasmEdge_CompilerOptimizationLevel_Os,
  /// Optimize for small code size as much as possible.
  WasmEdge_CompilerOptimizationLevel_Oz
};

/// AOT compiler output binary format enumeration.
enum WasmEdge_CompilerOutputFormat {
  /// Native dynamic library format.
  WasmEdge_CompilerOutputFormat_Native = 0,
  /// WebAssembly with AOT compiled codes in custom sections.
  WasmEdge_CompilerOutputFormat_Wasm
};
</code></pre>
<p>Please refer to the <a href="sdk/c/0.9.1/ref.html#configurations">AOT compiler options configuration</a> for details.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="upgrade-to-wasmedge-0100"><a class="header" href="#upgrade-to-wasmedge-0100">Upgrade to WasmEdge 0.10.0</a></h1>
<p>Due to the WasmEdge C API breaking changes, this document shows the guideline of programming with WasmEdge C API to upgrade from the <code>0.9.1</code> to the <code>0.10.0</code> version.</p>
<h2 id="concepts-1"><a class="header" href="#concepts-1">Concepts</a></h2>
<ol>
<li>
<p>Merged the <code>WasmEdge_ImportObjectContext</code> into the <code>WasmEdge_ModuleInstanceContext</code>.</p>
<p>The <code>WasmEdge_ImportObjectContext</code> which is for the host functions is merged into <code>WasmEdge_ModuleInstanceContext</code>.
Developers can use the related APIs to construct host modules.</p>
<ul>
<li><code>WasmEdge_ImportObjectCreate()</code> is changed to <code>WasmEdge_ModuleInstanceCreate()</code>.</li>
<li><code>WasmEdge_ImportObjectDelete()</code> is changed to <code>WasmEdge_ModuleInstanceDelete()</code>.</li>
<li><code>WasmEdge_ImportObjectAddFunction()</code> is changed to <code>WasmEdge_ModuleInstanceAddFunction()</code>.</li>
<li><code>WasmEdge_ImportObjectAddTable()</code> is changed to <code>WasmEdge_ModuleInstanceAddTable()</code>.</li>
<li><code>WasmEdge_ImportObjectAddMemory()</code> is changed to <code>WasmEdge_ModuleInstanceAddMemory()</code>.</li>
<li><code>WasmEdge_ImportObjectAddGlobal()</code> is changed to <code>WasmEdge_ModuleInstanceAddGlobal()</code>.</li>
<li><code>WasmEdge_ImportObjectCreateWASI()</code> is changed to <code>WasmEdge_ModuleInstanceCreateWASI()</code>.</li>
<li><code>WasmEdge_ImportObjectCreateWasmEdgeProcess()</code> is changed to <code>WasmEdge_ModuleInstanceCreateWasmEdgeProcess()</code>.</li>
<li><code>WasmEdge_ImportObjectInitWASI()</code> is changed to <code>WasmEdge_ModuleInstanceInitWASI()</code>.</li>
<li><code>WasmEdge_ImportObjectInitWasmEdgeProcess()</code> is changed to <code>WasmEdge_ModuleInstanceInitWasmEdgeProcess()</code>.</li>
</ul>
<p>For the new host function examples, please refer to <a href="sdk/c/0.9.1/upgrade_to_0.10.0.html#host-functions">the example below</a>.</p>
</li>
<li>
<p>Used the pointer to <code>WasmEdge_FunctionInstanceContext</code> instead of the index in the <code>FuncRef</code> value type.</p>
<p>For the better performance and security, the <code>FuncRef</code> related APIs used the <code>const WasmEdge_FunctionInstanceContext *</code> for the parameters and returns.</p>
<ul>
<li><code>WasmEdge_ValueGenFuncRef()</code> is changed to use the <code>const WasmEdge_FunctionInstanceContext *</code> as it's argument.</li>
<li><code>WasmEdge_ValueGetFuncRef()</code> is changed to return the <code>const WasmEdge_FunctionInstanceContext *</code>.</li>
</ul>
</li>
<li>
<p>Supported multiple anonymous WASM module instantiation.</p>
<p>In the version before <code>0.9.1</code>, WasmEdge only supports 1 anonymous WASM module to be instantiated at one time. If developers instantiate a new WASM module, the old one will be replaced.
After the <code>0.10.0</code> version, developers can instantiate multiple anonymous WASM module by <code>Executor</code> and get the <code>Module</code> instance. But for the source code using the <code>VM</code> APIs, the behavior is not changed.
For the new examples of instantiating multiple anonymous WASM modules, please refer to <a href="sdk/c/0.9.1/upgrade_to_0.10.0.html#wasmedge-executor-changes">the example below</a>.</p>
</li>
<li>
<p>Behavior changed of <code>WasmEdge_StoreContext</code>.</p>
<p>The <code>Function</code>, <code>Table</code>, <code>Memory</code>, and <code>Global</code> instances retrievement from the <code>Store</code> is moved to the <code>Module</code> instance. The <code>Store</code> only manage the module linking when instantiation and the named module searching after the <code>0.10.0</code> version.</p>
<ul>
<li><code>WasmEdge_StoreListFunctionLength()</code> and <code>WasmEdge_StoreListFunctionRegisteredLength()</code> is replaced by <code>WasmEdge_ModuleInstanceListFunctionLength()</code>.</li>
<li><code>WasmEdge_StoreListTableLength()</code> and <code>WasmEdge_StoreListTableRegisteredLength()</code> is replaced by <code>WasmEdge_ModuleInstanceListTableLength()</code>.</li>
<li><code>WasmEdge_StoreListMemoryLength()</code> and <code>WasmEdge_StoreListMemoryRegisteredLength()</code> is replaced by <code>WasmEdge_ModuleInstanceListMemoryLength()</code>.</li>
<li><code>WasmEdge_StoreListGlobalLength()</code> and <code>WasmEdge_StoreListGlobalRegisteredLength()</code> is replaced by <code>WasmEdge_ModuleInstanceListGlobalLength()</code>.</li>
<li><code>WasmEdge_StoreListFunction()</code> and <code>WasmEdge_StoreListFunctionRegistered()</code> is replaced by <code>WasmEdge_ModuleInstanceListFunction()</code>.</li>
<li><code>WasmEdge_StoreListTable()</code> and <code>WasmEdge_StoreListTableRegistered()</code> is replaced by <code>WasmEdge_ModuleInstanceListTable()</code>.</li>
<li><code>WasmEdge_StoreListMemory()</code> and <code>WasmEdge_StoreListMemoryRegistered()</code> is replaced by <code>WasmEdge_ModuleInstanceListMemory()</code>.</li>
<li><code>WasmEdge_StoreListGlobal()</code> and <code>WasmEdge_StoreListGlobalRegistered()</code> is replaced by <code>WasmEdge_ModuleInstanceListGlobal()</code>.</li>
<li><code>WasmEdge_StoreFindFunction()</code> and <code>WasmEdge_StoreFindFunctionRegistered()</code> is replaced by <code>WasmEdge_ModuleInstanceFindFunction()</code>.</li>
<li><code>WasmEdge_StoreFindTable()</code> and <code>WasmEdge_StoreFindTableRegistered()</code> is replaced by <code>WasmEdge_ModuleInstanceFindTable()</code>.</li>
<li><code>WasmEdge_StoreFindMemory()</code> and <code>WasmEdge_StoreFindMemoryRegistered()</code> is replaced by <code>WasmEdge_ModuleInstanceFindMemory()</code>.</li>
<li><code>WasmEdge_StoreFindGlobal()</code> and <code>WasmEdge_StoreFindGlobalRegistered()</code> is replaced by <code>WasmEdge_ModuleInstanceFindGlobal()</code>.</li>
</ul>
<p>For the new examples of retrieving instances, please refer to <a href="sdk/c/0.9.1/upgrade_to_0.10.0.html#instances-retrievement">the example below</a>.</p>
</li>
<li>
<p>The <code>WasmEdge_ModuleInstanceContext</code>-based resource management.</p>
<p>Except the creation of <code>Module</code> instance for the host functons, the <code>Executor</code> will output a <code>Module</code> instance after instantiation. No matter the anonymous or named modules, developers have the responsibility to destroy them by <code>WasmEdge_ModuleInstanceDelete()</code> API.
The <code>Store</code> will link to the named <code>Module</code> instance after registering. After the destroyment of a <code>Module</code> instance, the <code>Store</code> will unlink to that automatically; after the destroyment of the <code>Store</code>, the all <code>Module</code> instances the <code>Store</code> linked to will unlink to that <code>Store</code> automatically.</p>
</li>
</ol>
<h2 id="wasmedge-vm-changes"><a class="header" href="#wasmedge-vm-changes">WasmEdge VM changes</a></h2>
<p>The <code>VM</code> APIs are basically not changed, except the <code>ImportObject</code> related APIs.</p>
<p>The following is the example of WASI initialization in WasmEdge <code>0.9.1</code> C API:</p>
<pre><code class="language-c">WasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();
WasmEdge_ConfigureAddHostRegistration(ConfCxt, WasmEdge_HostRegistration_Wasi);
WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(ConfCxt, NULL);
/* The following API can retrieve the pre-registration import objects from the VM context. */
/* This API will return `NULL` if the corresponding pre-registration is not set into the configuration. */
WasmEdge_ImportObjectContext *WasiObject =
    WasmEdge_VMGetImportModuleContext(VMCxt, WasmEdge_HostRegistration_Wasi);
/* Initialize the WASI. */
WasmEdge_ImportObjectInitWASI(WasiObject, /* ... ignored */ );

/* ... */

WasmEdge_VMDelete(VMCxt);
WasmEdge_ConfigureDelete(ConfCxt);
</code></pre>
<p>Developers can change to use the WasmEdge <code>0.10.0</code> C API as follows, with only replacing the <code>WasmEdge_ImportObjectContext</code> into <code>WasmEdge_ModuleInstanceContext</code>:</p>
<pre><code class="language-c">WasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();
WasmEdge_ConfigureAddHostRegistration(ConfCxt, WasmEdge_HostRegistration_Wasi);
WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(ConfCxt, NULL);
/* The following API can retrieve the pre-registration module instances from the VM context. */
/* This API will return `NULL` if the corresponding pre-registration is not set into the configuration. */
WasmEdge_ModuleInstanceContext *WasiModule =
    WasmEdge_VMGetImportModuleContext(VMCxt, WasmEdge_HostRegistration_Wasi);
/* Initialize the WASI. */
WasmEdge_ModuleInstanceInitWASI(WasiModule, /* ... ignored */ );

/* ... */

WasmEdge_VMDelete(VMCxt);
WasmEdge_ConfigureDelete(ConfCxt);
</code></pre>
<p>The <code>VM</code> provides a new API for getting the current instantiated anonymous <code>Module</code> instance.
For example, if developer want to get the exported <code>Global</code> instance:</p>
<pre><code class="language-c">/* Assume that a WASM module is instantiated in `VMCxt`, and exports the &quot;global_i32&quot;. */
WasmEdge_StoreContext *StoreCxt = WasmEdge_VMGetStoreContext(VMCxt);
WasmEdge_String GlobName = WasmEdge_StringCreateByCString(&quot;global_i32&quot;);
WasmEdge_GlobalInstanceContext *GlobCxt = WasmEdge_StoreFindGlobal(StoreCxt, GlobName);
WasmEdge_StringDelete(GlobName);
</code></pre>
<p>After the WasmEdge <code>0.10.0</code> C API, developers can use the <code>WasmEdge_VMGetActiveModule()</code> to get the module instance:</p>
<pre><code class="language-c">/* Assume that a WASM module is instantiated in `VMCxt`, and exports the &quot;global_i32&quot;. */
const WasmEdge_ModuleInstanceContext *ModCxt = WasmEdge_VMGetActiveModule(VMCxt);
/* The example of retrieving the global instance. */
WasmEdge_String GlobName = WasmEdge_StringCreateByCString(&quot;global_i32&quot;);
WasmEdge_GlobalInstanceContext *GlobCxt = WasmEdge_ModuleInstanceFindGlobal(ModCxt, GlobName);
WasmEdge_StringDelete(GlobName);
</code></pre>
<h2 id="wasmedge-executor-changes"><a class="header" href="#wasmedge-executor-changes">WasmEdge Executor changes</a></h2>
<p><code>Executor</code> helps to instantiate a WASM module, register a WASM module into <code>Store</code> with module name, register the host modules with host functions, or invoke functions.</p>
<ol>
<li>
<p>WASM module instantiation</p>
<p>In WasmEdge <code>0.9.1</code> version, developers can instantiate a WASM module by the <code>Executor</code> API:</p>
<pre><code class="language-c">WasmEdge_ASTModuleContext *ASTCxt;
/*
 * Assume that `ASTCxt` is a loaded WASM from file or buffer and has passed the validation.
 * Assume that `ExecCxt` is a `WasmEdge_ExecutorContext`.
 * Assume that `StoreCxt` is a `WasmEdge_StoreContext`.
 */
WasmEdge_Result Res = WasmEdge_ExecutorInstantiate(ExecCxt, StoreCxt, ASTCxt);
if (!WasmEdge_ResultOK(Res)) {
  printf(&quot;Instantiation phase failed: %s\n&quot;, WasmEdge_ResultGetMessage(Res));
}
</code></pre>
<p>Then the WASM module is instantiated into an anonymous module instance and handled by the <code>Store</code>.
If a new WASM module is instantiated by this API, the old instantiated module instance will be cleaned.
After the WasmEdge <code>0.10.0</code> version, the instantiated anonymous module will be outputed and handled by caller, and not only 1 anonymous module instance can be instantiated.
Developers have the responsibility to destroy the outputed module instances.</p>
<pre><code class="language-c">WasmEdge_ASTModuleContext *ASTCxt1, *ASTCxt2;
/*
 * Assume that `ASTCxt1` and `ASTCxt2` are loaded WASMs from different files or buffers,
 * and have both passed the validation.
 * Assume that `ExecCxt` is a `WasmEdge_ExecutorContext`.
 * Assume that `StoreCxt` is a `WasmEdge_StoreContext`.
 */
WasmEdge_ModuleInstanceContext *ModCxt1 = NULL;
WasmEdge_ModuleInstanceContext *ModCxt2 = NULL;
WasmEdge_Result Res = WasmEdge_ExecutorInstantiate(ExecCxt, &amp;ModCxt1, StoreCxt, ASTCxt1);
if (!WasmEdge_ResultOK(Res)) {
  printf(&quot;Instantiation phase failed: %s\n&quot;, WasmEdge_ResultGetMessage(Res));
}
Res = WasmEdge_ExecutorInstantiate(ExecCxt, &amp;ModCxt2, StoreCxt, ASTCxt2);
if (!WasmEdge_ResultOK(Res)) {
  printf(&quot;Instantiation phase failed: %s\n&quot;, WasmEdge_ResultGetMessage(Res));
}
</code></pre>
</li>
<li>
<p>WASM module registration with module name</p>
<p>When instantiating and registering a WASM module with module name, developers can use the <code>WasmEdge_ExecutorRegisterModule()</code> API before WasmEdge <code>0.9.1</code>.</p>
<pre><code class="language-c">WasmEdge_ASTModuleContext *ASTCxt;
/*
 * Assume that `ASTCxt` is a loaded WASM from file or buffer and has passed the validation.
 * Assume that `ExecCxt` is a `WasmEdge_ExecutorContext`.
 * Assume that `StoreCxt` is a `WasmEdge_StoreContext`.
 */

/* Register the WASM module into store with the export module name &quot;mod&quot;. */
WasmEdge_String ModName = WasmEdge_StringCreateByCString(&quot;mod&quot;);
Res = WasmEdge_ExecutorRegisterModule(ExecCxt, StoreCxt, ASTCxt, ModName);
WasmEdge_StringDelete(ModName);
if (!WasmEdge_ResultOK(Res)) {
  printf(&quot;WASM registration failed: %s\n&quot;, WasmEdge_ResultGetMessage(Res));
}
</code></pre>
<p>The same feature is implemented in WasmEdge <code>0.10.0</code>, but in different API <code>WasmEdge_ExecutorRegister()</code>:</p>
<pre><code class="language-c">WasmEdge_ASTModuleContext *ASTCxt;
/*
 * Assume that `ASTCxt` is a loaded WASM from file or buffer and has passed the validation.
 * Assume that `ExecCxt` is a `WasmEdge_ExecutorContext`.
 * Assume that `StoreCxt` is a `WasmEdge_StoreContext`.
 */

/* Register the WASM module into store with the export module name &quot;mod&quot;. */
WasmEdge_String ModName = WasmEdge_StringCreateByCString(&quot;mod&quot;);
/* The output module instance. */
WasmEdge_ModuleInstanceContext *ModCxt = NULL;
Res = WasmEdge_ExecutorRegister(ExecCxt, &amp;ModCxt, StoreCxt, ASTCxt, ModName);
WasmEdge_StringDelete(ModName);
if (!WasmEdge_ResultOK(Res)) {
  printf(&quot;WASM registration failed: %s\n&quot;, WasmEdge_ResultGetMessage(Res));
}
</code></pre>
<p>Developers have the responsibility to destroy the outputed module instances.</p>
</li>
<li>
<p>Host module registration</p>
<p>In WasmEdge <code>0.9.1</code>, developers can create a <code>WasmEdge_ImportObjectContext</code> and register into <code>Store</code>.</p>
<pre><code class="language-c">/* Create the import object with the export module name. */
WasmEdge_String ModName = WasmEdge_StringCreateByCString(&quot;module&quot;);
WasmEdge_ImportObjectContext *ImpObj = WasmEdge_ImportObjectCreate(ModName);
WasmEdge_StringDelete(ModName);
/*
 * ...
 * Add the host functions, tables, memories, and globals into the import object.
 */
/* The import module context has already contained the export module name. */
Res = WasmEdge_ExecutorRegisterImport(ExecCxt, StoreCxt, ImpObj);
if (!WasmEdge_ResultOK(Res)) {
  printf(&quot;Import object registration failed: %s\n&quot;, WasmEdge_ResultGetMessage(Res));
}
</code></pre>
<p>After WasmEdge <code>0.10.0</code>, developers should use the <code>WasmEdge_ModuleInstanceContext</code> instead:</p>
<pre><code class="language-c">/* Create the module instance with the export module name. */
WasmEdge_String ModName = WasmEdge_StringCreateByCString(&quot;module&quot;);
WasmEdge_ModuleInstanceContext *ModCxt = WasmEdge_ModuleInstanceCreate(ModName);
WasmEdge_StringDelete(ModName);
/*
 * ...
 * Add the host functions, tables, memories, and globals into the module instance.
 */
/* The module instance context has already contained the export module name. */
Res = WasmEdge_ExecutorRegisterImport(ExecCxt, StoreCxt, ModCxt);
if (!WasmEdge_ResultOK(Res)) {
  printf(&quot;Module instance registration failed: %s\n&quot;, WasmEdge_ResultGetMessage(Res));
}
</code></pre>
<p>Developers have the responsibility to destroy the created module instances.</p>
</li>
<li>
<p>WASM function invocation</p>
<p>This example uses the <a href="https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/examples/wasm/fibonacci.wasm">fibonacci.wasm</a>, and the corresponding WAT file is at <a href="https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/examples/wasm/fibonacci.wat">fibonacci.wat</a>.
In WasmEdge <code>0.9.1</code> version, developers can invoke a WASM function with the export function name:</p>
<pre><code class="language-c">/* Create the store context. The store context holds the instances. */
WasmEdge_StoreContext *StoreCxt = WasmEdge_StoreCreate();
/* Result. */
WasmEdge_Result Res;

/* Create the loader context. The configure context can be NULL. */
WasmEdge_LoaderContext *LoadCxt = WasmEdge_LoaderCreate(NULL);
/* Create the validator context. The configure context can be NULL. */
WasmEdge_ValidatorContext *ValidCxt = WasmEdge_ValidatorCreate(NULL);
/* Create the executor context. The configure context and the statistics context can be NULL. */
WasmEdge_ExecutorContext *ExecCxt = WasmEdge_ExecutorCreate(NULL, NULL);

/* Load the WASM file or the compiled-WASM file and convert into the AST module context. */
WasmEdge_ASTModuleContext *ASTCxt = NULL;
Res = WasmEdge_LoaderParseFromFile(LoadCxt, &amp;ASTCxt, &quot;fibonacci.wasm&quot;);
if (!WasmEdge_ResultOK(Res)) {
  printf(&quot;Loading phase failed: %s\n&quot;, WasmEdge_ResultGetMessage(Res));
  return -1;
}
/* Validate the WASM module. */
Res = WasmEdge_ValidatorValidate(ValidCxt, ASTCxt);
if (!WasmEdge_ResultOK(Res)) {
  printf(&quot;Validation phase failed: %s\n&quot;, WasmEdge_ResultGetMessage(Res));
  return -1;
}
/* Instantiate the WASM module into the store context. */
Res = WasmEdge_ExecutorInstantiate(ExecCxt, StoreCxt, ASTCxt);
if (!WasmEdge_ResultOK(Res)) {
  printf(&quot;Instantiation phase failed: %s\n&quot;, WasmEdge_ResultGetMessage(Res));
  return -1;
}
/* Invoke the function which is exported with the function name &quot;fib&quot;. */
WasmEdge_String FuncName = WasmEdge_StringCreateByCString(&quot;fib&quot;);
WasmEdge_Value Params[1] = { WasmEdge_ValueGenI32(18) };
WasmEdge_Value Returns[1];
Res = WasmEdge_ExecutorInvoke(ExecCxt, StoreCxt, FuncName, Params, 1, Returns, 1);
if (WasmEdge_ResultOK(Res)) {
  printf(&quot;Get the result: %d\n&quot;, WasmEdge_ValueGetI32(Returns[0]));
} else {
  printf(&quot;Execution phase failed: %s\n&quot;, WasmEdge_ResultGetMessage(Res));
  return -1;
}

WasmEdge_ASTModuleDelete(ASTCxt);
WasmEdge_LoaderDelete(LoadCxt);
WasmEdge_ValidatorDelete(ValidCxt);
WasmEdge_ExecutorDelete(ExecCxt);
WasmEdge_StoreDelete(StoreCxt);
</code></pre>
<p>After the WasmEdge <code>0.10.0</code>, developers should retrieve the <code>Function</code> instance by function name first.</p>
<pre><code class="language-c">/*
 * ...
 * Ignore the unchanged steps before validation. Please refer to the sample code above.
 */
WasmEdge_ModuleInstanceContext *ModCxt = NULL;
/* Instantiate the WASM module. */
Res = WasmEdge_ExecutorInstantiate(ExecCxt, &amp;ModCxt1, StoreCxt, ASTCxt);
if (!WasmEdge_ResultOK(Res)) {
  printf(&quot;Instantiation phase failed: %s\n&quot;, WasmEdge_ResultGetMessage(Res));
  return -1;
}
/* Retrieve the function instance by name. */
WasmEdge_String FuncName = WasmEdge_StringCreateByCString(&quot;fib&quot;);
WasmEdge_FunctionInstanceContext *FuncCxt = WasmEdge_ModuleInstanceFindFunction(ModCxt, FuncName);
WasmEdge_StringDelete(FuncName);
/* Invoke the function. */
WasmEdge_Value Params[1] = { WasmEdge_ValueGenI32(18) };
WasmEdge_Value Returns[1];
Res = WasmEdge_ExecutorInvoke(ExecCxt, FuncCxt, Params, 1, Returns, 1);
if (WasmEdge_ResultOK(Res)) {
  printf(&quot;Get the result: %d\n&quot;, WasmEdge_ValueGetI32(Returns[0]));
} else {
  printf(&quot;Execution phase failed: %s\n&quot;, WasmEdge_ResultGetMessage(Res));
  return -1;
}

WasmEdge_ModuleInstanceDelete(ModCxt);
WasmEdge_ASTModuleDelete(ASTCxt);
WasmEdge_LoaderDelete(LoadCxt);
WasmEdge_ValidatorDelete(ValidCxt);
WasmEdge_ExecutorDelete(ExecCxt);
WasmEdge_StoreDelete(StoreCxt);
</code></pre>
</li>
</ol>
<h2 id="instances-retrievement"><a class="header" href="#instances-retrievement">Instances retrievement</a></h2>
<p>This example uses the <a href="https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/examples/wasm/fibonacci.wasm">fibonacci.wasm</a>, and the corresponding WAT file is at <a href="https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/examples/wasm/fibonacci.wat">fibonacci.wat</a>.</p>
<p>Before the WasmEdge <code>0.9.1</code> versions, developers can retrieve all exported instances of named or anonymous modules from <code>Store</code>:</p>
<pre><code class="language-c">/* Create the store context. The store context holds the instances. */
WasmEdge_StoreContext *StoreCxt = WasmEdge_StoreCreate();
/* Result. */
WasmEdge_Result Res;

/* Create the loader context. The configure context can be NULL. */
WasmEdge_LoaderContext *LoadCxt = WasmEdge_LoaderCreate(NULL);
/* Create the validator context. The configure context can be NULL. */
WasmEdge_ValidatorContext *ValidCxt = WasmEdge_ValidatorCreate(NULL);
/* Create the executor context. The configure context and the statistics context can be NULL. */
WasmEdge_ExecutorContext *ExecCxt = WasmEdge_ExecutorCreate(NULL, NULL);

/* Load the WASM file or the compiled-WASM file and convert into the AST module context. */
WasmEdge_ASTModuleContext *ASTCxt = NULL;
Res = WasmEdge_LoaderParseFromFile(LoadCxt, &amp;ASTCxt, &quot;fibonacci.wasm&quot;);
if (!WasmEdge_ResultOK(Res)) {
  printf(&quot;Loading phase failed: %s\n&quot;, WasmEdge_ResultGetMessage(Res));
  return -1;
}
/* Validate the WASM module. */
Res = WasmEdge_ValidatorValidate(ValidCxt, ASTCxt);
if (!WasmEdge_ResultOK(Res)) {
  printf(&quot;Validation phase failed: %s\n&quot;, WasmEdge_ResultGetMessage(Res));
  return -1;
}
/* Example: register and instantiate the WASM module with the module name &quot;module_fib&quot;. */
WasmEdge_String ModName = WasmEdge_StringCreateByCString(&quot;module_fib&quot;);
Res = WasmEdge_ExecutorRegisterModule(ExecCxt, StoreCxt, ASTCxt, ModName);
if (!WasmEdge_ResultOK(Res)) {
  printf(&quot;Instantiation phase failed: %s\n&quot;, WasmEdge_ResultGetMessage(Res));
  return -1;
}
/* Example: Instantiate the WASM module into the store context. */
Res = WasmEdge_ExecutorInstantiate(ExecCxt, StoreCxt, ASTCxt);
if (!WasmEdge_ResultOK(Res)) {
  printf(&quot;Instantiation phase failed: %s\n&quot;, WasmEdge_ResultGetMessage(Res));
  return -1;
}
WasmEdge_StringDelete(ModName);

/* Now, developers can retrieve the exported instances from the store. */
/* Take the exported functions as example. This WASM exports the function &quot;fib&quot;. */
WasmEdge_String FuncName = WasmEdge_StringCreateByCString(&quot;fib&quot;);
WasmEdge_FunctionInstanceContext *FoundFuncCxt;
/* Find the function &quot;fib&quot; from the instantiated anonymous module. */
FoundFuncCxt = WasmEdge_StoreFindFunction(StoreCxt, FuncName);
/* Find the function &quot;fib&quot; from the registered module &quot;module_fib&quot;. */
ModName = WasmEdge_StringCreateByCString(&quot;module_fib&quot;);
FoundFuncCxt = WasmEdge_StoreFindFunctionRegistered(StoreCxt, ModName, FuncName);
WasmEdge_StringDelete(ModName);
WasmEdge_StringDelete(FuncName);

WasmEdge_ASTModuleDelete(ASTCxt);
WasmEdge_LoaderDelete(LoadCxt);
WasmEdge_ValidatorDelete(ValidCxt);
WasmEdge_ExecutorDelete(ExecCxt);
WasmEdge_StoreDelete(StoreCxt);
</code></pre>
<p>After the WasmEdge <code>0.10.0</code>, developers can instantiate several anonymous <code>Module</code> instances, and should retrieve the exported instances from named or anonymous <code>Module</code> instances:</p>
<pre><code class="language-c">/* Create the store context. The store context is the object to link the modules for imports and exports. */
WasmEdge_StoreContext *StoreCxt = WasmEdge_StoreCreate();
/* Result. */
WasmEdge_Result Res;

/* Create the loader context. The configure context can be NULL. */
WasmEdge_LoaderContext *LoadCxt = WasmEdge_LoaderCreate(NULL);
/* Create the validator context. The configure context can be NULL. */
WasmEdge_ValidatorContext *ValidCxt = WasmEdge_ValidatorCreate(NULL);
/* Create the executor context. The configure context and the statistics context can be NULL. */
WasmEdge_ExecutorContext *ExecCxt = WasmEdge_ExecutorCreate(NULL, NULL);

/* Load the WASM file or the compiled-WASM file and convert into the AST module context. */
WasmEdge_ASTModuleContext *ASTCxt = NULL;
Res = WasmEdge_LoaderParseFromFile(LoadCxt, &amp;ASTCxt, &quot;fibonacci.wasm&quot;);
if (!WasmEdge_ResultOK(Res)) {
  printf(&quot;Loading phase failed: %s\n&quot;, WasmEdge_ResultGetMessage(Res));
  return -1;
}
/* Validate the WASM module. */
Res = WasmEdge_ValidatorValidate(ValidCxt, ASTCxt);
if (!WasmEdge_ResultOK(Res)) {
  printf(&quot;Validation phase failed: %s\n&quot;, WasmEdge_ResultGetMessage(Res));
  return -1;
}
/* Example: register and instantiate the WASM module with the module name &quot;module_fib&quot;. */
WasmEdge_ModuleInstanceContext *NamedModCxt = NULL;
WasmEdge_String ModName = WasmEdge_StringCreateByCString(&quot;module_fib&quot;);
Res = WasmEdge_ExecutorRegister(ExecCxt, &amp;NamedModCxt, StoreCxt, ASTCxt, ModName);
if (!WasmEdge_ResultOK(Res)) {
  printf(&quot;Instantiation phase failed: %s\n&quot;, WasmEdge_ResultGetMessage(Res));
  return -1;
}
/* Example: Instantiate the WASM module and get the output module instance. */
WasmEdge_ModuleInstanceContext *ModCxt = NULL;
Res = WasmEdge_ExecutorInstantiate(ExecCxt, &amp;ModCxt, StoreCxt, ASTCxt);
if (!WasmEdge_ResultOK(Res)) {
  printf(&quot;Instantiation phase failed: %s\n&quot;, WasmEdge_ResultGetMessage(Res));
  return -1;
}
WasmEdge_StringDelete(ModName);

/* Now, developers can retrieve the exported instances from the module instaces. */
/* Take the exported functions as example. This WASM exports the function &quot;fib&quot;. */
WasmEdge_String FuncName = WasmEdge_StringCreateByCString(&quot;fib&quot;);
WasmEdge_FunctionInstanceContext *FoundFuncCxt;
/* Find the function &quot;fib&quot; from the instantiated anonymous module. */
FoundFuncCxt = WasmEdge_ModuleInstanceFindFunction(ModCxt, FuncName);
/* Find the function &quot;fib&quot; from the registered module &quot;module_fib&quot;. */
FoundFuncCxt = WasmEdge_ModuleInstanceFindFunction(NamedModCxt, FuncName);
/* Or developers can get the named module instance from the store: */
ModName = WasmEdge_StringCreateByCString(&quot;module_fib&quot;);
const WasmEdge_ModuleInstanceContext *ModCxtGot = WasmEdge_StoreFindModule(StoreCxt, ModName);
WasmEdge_StringDelete(ModName);
FoundFuncCxt = WasmEdge_ModuleInstanceFindFunction(ModCxtGot, FuncName);
WasmEdge_StringDelete(FuncName);

WasmEdge_ModuleInstanceDelete(NamedModCxt);
WasmEdge_ModuleInstanceDelete(ModCxt);
WasmEdge_ASTModuleDelete(ASTCxt);
WasmEdge_LoaderDelete(LoadCxt);
WasmEdge_ValidatorDelete(ValidCxt);
WasmEdge_ExecutorDelete(ExecCxt);
WasmEdge_StoreDelete(StoreCxt);
</code></pre>
<h2 id="host-functions-5"><a class="header" href="#host-functions-5">Host functions</a></h2>
<p>The difference of host functions are the replacement of <code>WasmEdge_ImportObjectContext</code>.</p>
<pre><code class="language-c">/* Host function body definition. */
WasmEdge_Result Add(void *Data, WasmEdge_MemoryInstanceContext *MemCxt,
                    const WasmEdge_Value *In, WasmEdge_Value *Out) {
  int32_t Val1 = WasmEdge_ValueGetI32(In[0]);
  int32_t Val2 = WasmEdge_ValueGetI32(In[1]);
  Out[0] = WasmEdge_ValueGenI32(Val1 + Val2);
  return WasmEdge_Result_Success;
}

/* Create the import object. */
WasmEdge_String ExportName = WasmEdge_StringCreateByCString(&quot;module&quot;);
WasmEdge_ImportObjectContext *ImpObj = WasmEdge_ImportObjectCreate(ExportName);
WasmEdge_StringDelete(ExportName);

/* Create and add a function instance into the import object. */
enum WasmEdge_ValType ParamList[2] = { WasmEdge_ValType_I32, WasmEdge_ValType_I32 };
enum WasmEdge_ValType ReturnList[1] = { WasmEdge_ValType_I32 };
WasmEdge_FunctionTypeContext *HostFType = 
    WasmEdge_FunctionTypeCreate(ParamList, 2, ReturnList, 1);
WasmEdge_FunctionInstanceContext *HostFunc =
    WasmEdge_FunctionInstanceCreate(HostFType, Add, NULL, 0);
/*
 * The third parameter is the pointer to the additional data object.
 * Developers should guarantee the life cycle of the data, and it can be
 * `NULL` if the external data is not needed.
 */
WasmEdge_FunctionTypeDelete(HostFType);
WasmEdge_String FuncName = WasmEdge_StringCreateByCString(&quot;add&quot;);
WasmEdge_ImportObjectAddFunction(ImpObj, FuncName, HostFunc);
WasmEdge_StringDelete(FuncName);

/*
 * The import objects should be deleted.
 * Developers should __NOT__ destroy the instances added into the import object contexts.
 */
WasmEdge_ImportObjectDelete(ImpObj);
</code></pre>
<p>Developers can use the <code>WasmEdge_ModuleInstanceContext</code> to upgrade to WasmEdge <code>0.10.0</code> easily.</p>
<pre><code class="language-c">/* Host function body definition. */
WasmEdge_Result Add(void *Data, WasmEdge_MemoryInstanceContext *MemCxt,
                    const WasmEdge_Value *In, WasmEdge_Value *Out) {
  int32_t Val1 = WasmEdge_ValueGetI32(In[0]);
  int32_t Val2 = WasmEdge_ValueGetI32(In[1]);
  Out[0] = WasmEdge_ValueGenI32(Val1 + Val2);
  return WasmEdge_Result_Success;
}

/* Create a module instance. */
WasmEdge_String ExportName = WasmEdge_StringCreateByCString(&quot;module&quot;);
WasmEdge_ModuleInstanceContext *HostModCxt = WasmEdge_ModuleInstanceCreate(ExportName);
WasmEdge_StringDelete(ExportName);

/* Create and add a function instance into the module instance. */
enum WasmEdge_ValType ParamList[2] = { WasmEdge_ValType_I32, WasmEdge_ValType_I32 };
enum WasmEdge_ValType ReturnList[1] = { WasmEdge_ValType_I32 };
WasmEdge_FunctionTypeContext *HostFType = 
    WasmEdge_FunctionTypeCreate(ParamList, 2, ReturnList, 1);
WasmEdge_FunctionInstanceContext *HostFunc =
    WasmEdge_FunctionInstanceCreate(HostFType, Add, NULL, 0);
/*
 * The third parameter is the pointer to the additional data object.
 * Developers should guarantee the life cycle of the data, and it can be
 * `NULL` if the external data is not needed.
 */
WasmEdge_FunctionTypeDelete(HostFType);
WasmEdge_String FuncName = WasmEdge_StringCreateByCString(&quot;add&quot;);
WasmEdge_ModuleInstanceAddFunction(HostModCxt, FuncName, HostFunc);
WasmEdge_StringDelete(FuncName);

/*
 * The module instance should be deleted.
 * Developers should __NOT__ destroy the instances added into the module instance contexts.
 */
WasmEdge_ModuleInstanceDelete(HostModCxt);
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="wasmedge-go-sdk"><a class="header" href="#wasmedge-go-sdk">WasmEdge Go SDK</a></h1>
<p>The followings are the guide to work with the WasmEdge Go API. You can embed the WasmEdge into your go application through the WasmEdge Go API.</p>
<h2 id="getting-started-1"><a class="header" href="#getting-started-1">Getting Started</a></h2>
<p>The WasmEdge-go requires golang version &gt;= 1.16. Please check your golang version before installation. You can <a href="https://golang.org/dl/">download golang here</a>.</p>
<pre><code class="language-bash">$ go version
go version go1.16.5 linux/amd64
</code></pre>
<p>Meantime, please make sure you have installed <a href="sdk/../quick_start/install.html">the WasmEdge shared library</a> with the same <code>WasmEdge-go</code> release version.</p>
<pre><code class="language-bash">curl -sSf https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/utils/install.sh | bash -s -- -v 0.11.1
</code></pre>
<p>If you need the <code>TensorFlow</code> or <code>Image</code> extension for <code>WasmEdge-go</code>, please install the <code>WasmEdge</code> with extensions:</p>
<pre><code class="language-bash">curl -sSf https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/utils/install.sh | bash -s -- -v 0.11.1 -e tensorflow,image
</code></pre>
<p>Noticed that the <code>TensorFlow</code> and <code>Image</code> extensions are only for the <code>Linux</code> platforms.</p>
<p>Install the <code>WasmEdge-go</code> package and build in your Go project directory:</p>
<pre><code class="language-bash">go get github.com/second-state/WasmEdge-go/wasmedge@v0.11.1
go build
</code></pre>
<h2 id="wasmedge-go-extensions"><a class="header" href="#wasmedge-go-extensions">WasmEdge-go Extensions</a></h2>
<p>By default, the <code>WasmEdge-go</code> only turns on the basic runtime.</p>
<p><code>WasmEdge-go</code> has the following extensions:</p>
<ul>
<li>
<p>TensorFlow</p>
<ul>
<li>
<p>This extension supports the host functions in <a href="https://github.com/second-state/WasmEdge-tensorflow">WasmEdge-tensorflow</a>.</p>
</li>
<li>
<p>To install the <code>tensorflow</code> extension, please use the <code>-e tensorflow</code> flag in the WasmEdge installer command.</p>
</li>
<li>
<p>For using this extension, the tag <code>tensorflow</code> when building is required:</p>
<pre><code class="language-bash">go build -tags tensorflow
</code></pre>
</li>
</ul>
</li>
<li>
<p>Image</p>
<ul>
<li>
<p>This extension supports the host functions in <a href="https://github.com/second-state/WasmEdge-image">WasmEdge-image</a>.</p>
</li>
<li>
<p>To install the <code>image</code> extension, please use the <code>-e image</code> flag in the WasmEdge installer command.</p>
</li>
<li>
<p>For using this extension, the tag <code>image</code> when building is required:</p>
<pre><code class="language-bash">go build -tags image
</code></pre>
</li>
</ul>
</li>
</ul>
<p>You can also turn on the multiple extensions when building:</p>
<pre><code class="language-bash">go build -tags image,tensorflow
</code></pre>
<p>For examples, please refer to the <a href="https://github.com/second-state/WasmEdge-go-examples/">example repository</a>.</p>
<h3 id="wasmedge-aot-compiler-in-go"><a class="header" href="#wasmedge-aot-compiler-in-go">WasmEdge AOT Compiler in Go</a></h3>
<p>The <a href="https://github.com/second-state/WasmEdge-go-examples/tree/master/go_WasmAOT">go_WasmAOT example</a> demonstrates how to compile a WASM file into a native binary (AOT compile) from within a Go application.</p>
<h2 id="examples-2"><a class="header" href="#examples-2">Examples</a></h2>
<ul>
<li><a href="sdk/go/app.html">Embed a standalone Wasm app</a></li>
<li><a href="sdk/go/function.html">Embed a Wasm function</a></li>
<li><a href="sdk/go/memory.html">Pass complex parameters to Wasm functions</a></li>
<li><a href="sdk/go/tensorflow.html">Embed a Tensorflow inference function</a></li>
<li><a href="sdk/go/bindgen.html">Embed a bindgen function</a></li>
</ul>
<h2 id="api-references-1"><a class="header" href="#api-references-1">API References</a></h2>
<ul>
<li><a href="sdk/go/ref.html">v0.10.1</a></li>
<li><a href="sdk/go/0.9.1/ref.html">v0.9.1</a>
<ul>
<li><a href="sdk/go/0.9.1/upgrade_to_0.10.0.html">Upgrade to v0.10.0</a></li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="embed-a-standalone-wasm-app"><a class="header" href="#embed-a-standalone-wasm-app">Embed a standalone WASM app</a></h1>
<p>The WasmEdge Go SDK can <a href="https://github.com/second-state/WasmEdge-go-examples/tree/master/go_ReadFile">embed standalone WebAssembly applications</a> — ie a Rust application with a <code>main()</code> function compiled into WebAssembly.</p>
<p>Our <a href="https://github.com/second-state/WasmEdge-go-examples/tree/master/go_ReadFile/rust_readfile">demo Rust application</a> reads from a file. Note that the WebAssembly program's input and output data are now passed by the STDIN and STDOUT.</p>
<pre><pre class="playground"><code class="language-rust">use std::env;
use std::fs::File;
use std::io::{self, BufRead};

fn main() {
  // Get the argv.
  let args: Vec&lt;String&gt; = env::args().collect();
  if args.len() &lt;= 1 {
    println!(&quot;Rust: ERROR - No input file name.&quot;);
    return;
  }

  // Open the file.
  println!(&quot;Rust: Opening input file \&quot;{}\&quot;...&quot;, args[1]);
  let file = match File::open(&amp;args[1]) {
    Err(why) =&gt; {
      println!(&quot;Rust: ERROR - Open file \&quot;{}\&quot; failed: {}&quot;, args[1], why);
      return;
    },
    Ok(file) =&gt; file,
  };

  // Read lines.
  let reader = io::BufReader::new(file);
  let mut texts:Vec&lt;String&gt; = Vec::new();
  for line in reader.lines() {
    if let Ok(text) = line {
      texts.push(text);
    }
  }
  println!(&quot;Rust: Read input file \&quot;{}\&quot; succeeded.&quot;, args[1]);

  // Get stdin to print lines.
  println!(&quot;Rust: Please input the line number to print the line of file.&quot;);
  let stdin = io::stdin();
  for line in stdin.lock().lines() {
    let input = line.unwrap();
    match input.parse::&lt;usize&gt;() {
      Ok(n) =&gt; if n &gt; 0 &amp;&amp; n &lt;= texts.len() {
        println!(&quot;{}&quot;, texts[n - 1]);
      } else {
        println!(&quot;Rust: ERROR - Line \&quot;{}\&quot; is out of range.&quot;, n);
      },
      Err(e) =&gt; println!(&quot;Rust: ERROR - Input \&quot;{}\&quot; is not an integer: {}&quot;, input, e),
    }
  }
  println!(&quot;Rust: Process end.&quot;);
}
</code></pre></pre>
<p>Compile the application into WebAssembly.</p>
<pre><code class="language-bash">cd rust_readfile
cargo build --target wasm32-wasi
# The output file will be target/wasm32-wasi/debug/rust_readfile.wasm
</code></pre>
<p>The Go source code to run the WebAssembly function in WasmEdge is as follows.</p>
<pre><code class="language-go">package main

import (
  &quot;os&quot;
  &quot;github.com/second-state/WasmEdge-go/wasmedge&quot;
)

func main() {
  wasmedge.SetLogErrorLevel()

  var conf = wasmedge.NewConfigure(wasmedge.REFERENCE_TYPES)
  conf.AddConfig(wasmedge.WASI)
  var vm = wasmedge.NewVMWithConfig(conf)
  var wasi = vm.GetImportModule(wasmedge.WASI)
  wasi.InitWasi(
    os.Args[1:],     // The args
    os.Environ(),    // The envs
    []string{&quot;.:.&quot;}, // The mapping directories
  )

  // Instantiate wasm. _start refers to the main() function
  vm.RunWasmFile(os.Args[1], &quot;_start&quot;)

  vm.Release()
  conf.Release()
}
</code></pre>
<p>Next, let's build the Go application with the WasmEdge Go SDK.</p>
<pre><code class="language-bash">go get github.com/second-state/WasmEdge-go/wasmedge@v0.11.1
go build
</code></pre>
<p>Run the Golang application.</p>
<pre><code class="language-bash">$ ./read_file rust_readfile/target/wasm32-wasi/debug/rust_readfile.wasm file.txt
Rust: Opening input file &quot;file.txt&quot;...
Rust: Read input file &quot;file.txt&quot; succeeded.
Rust: Please input the line number to print the line of file.
# Input &quot;5&quot; and press Enter.
5
# The output will be the 5th line of `file.txt`:
abcDEF___!@#$%^
# To terminate the program, send the EOF (Ctrl + D).
^D
# The output will print the terminate message:
Rust: Process end.
</code></pre>
<p>More examples can be found at <a href="https://github.com/second-state/WasmEdge-go-examples">the WasmEdge-go-examples GitHub repo.</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="embed-a-wasm-function"><a class="header" href="#embed-a-wasm-function">Embed a Wasm function</a></h1>
<p>The WasmEdge Go SDK allows WebAssembly functions to be embedded into a Go host app. You can use the Go SDK API to pass call parameters to the embedded WebAssembly functions, and then capture the return values.
However, the WebAssembly spec only supports a few simple data types out of the box. It <a href="https://medium.com/wasm/strings-in-webassembly-wasm-57a05c1ea333">does not support</a> types such as string and array. In order to pass rich types in Go to WebAssembly, we could hand-code memory pointers (<a href="sdk/go/memory.html">see here</a>), or use an automated tool to manage the data exchange.</p>
<p>The <a href="https://github.com/second-state/wasmedge-bindgen">wasmedge-bindgen</a> project provides Rust macros for functions to accept and return complex data types, and then for Go functions to call such Rust functions running in WasmEdge.
The full source code for the demo in this chapter is <a href="https://github.com/second-state/WasmEdge-go-examples/tree/master/wasmedge-bindgen/go_BindgenFuncs">available here</a>.</p>
<h2 id="rust-function-compiled-into-webassembly"><a class="header" href="#rust-function-compiled-into-webassembly">Rust function compiled into WebAssembly</a></h2>
<p>In the <a href="https://github.com/second-state/WasmEdge-go-examples/tree/master/wasmedge-bindgen/go_BindgenFuncs/rust_bindgen_funcs">Rust project</a>, all you need is to annotate <a href="https://github.com/second-state/WasmEdge-go-examples/blob/master/wasmedge-bindgen/go_BindgenFuncs/rust_bindgen_funcs/src/lib.rs">your functions</a> with a <code>[wasmedge_bindgen]</code> macro.
Those annotated functions will be automatically instrumented by the Rust compiler and turned into WebAssembly functions that can be called from the bindgen related functions of WasmEdge GO SDK.
In the example below, we have several Rust functions that take complex call parameters and return complex values.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use wasmedge_bindgen::*;
use wasmedge_bindgen_macro::*;
use num_integer::lcm;
use sha3::{Digest, Sha3_256, Keccak256};
use serde::{Serialize, Deserialize};

#[derive(Serialize, Deserialize, Debug)]
struct Point {
  x: f32,
  y: f32
}

#[derive(Serialize, Deserialize, Debug)]
struct Line {
  points: Vec&lt;Point&gt;,
  valid: bool,
  length: f32,
  desc: String
}

#[wasmedge_bindgen]
pub fn create_line(p1: String, p2: String, desc: String) -&gt; Result&lt;Vec&lt;u8&gt;, String&gt; {
  let point1: Point = serde_json::from_str(p1.as_str()).unwrap();
  let point2: Point = serde_json::from_str(p2.as_str()).unwrap();
  let length = ((point1.x - point2.x) * (point1.x - point2.x) + (point1.y - point2.y) * (point1.y - point2.y)).sqrt();

  let valid = if length == 0.0 { false } else { true };

  let line = Line { points: vec![point1, point2], valid: valid, length: length, desc: desc };

  return Ok(serde_json::to_vec(&amp;line).unwrap());
}

#[wasmedge_bindgen]
pub fn say(s: String) -&gt; Result&lt;Vec&lt;u8&gt;, String&gt; {
  let r = String::from(&quot;hello &quot;);
  return Ok((r + s.as_str()).as_bytes().to_vec());
}

#[wasmedge_bindgen]
pub fn obfusticate(s: String) -&gt; Result&lt;Vec&lt;u8&gt;, String&gt; {
  let r: String = (&amp;s).chars().map(|c| {
    match c {
      'A' ..= 'M' | 'a' ..= 'm' =&gt; ((c as u8) + 13) as char,
      'N' ..= 'Z' | 'n' ..= 'z' =&gt; ((c as u8) - 13) as char,
      _ =&gt; c
    }
  }).collect();
  Ok(r.as_bytes().to_vec())
}

#[wasmedge_bindgen]
pub fn lowest_common_multiple(a: i32, b: i32) -&gt; Result&lt;Vec&lt;u8&gt;, String&gt; {
  let r = lcm(a, b);
  return Ok(r.to_string().as_bytes().to_vec());
}

#[wasmedge_bindgen]
pub fn sha3_digest(v: Vec&lt;u8&gt;) -&gt; Result&lt;Vec&lt;u8&gt;, String&gt; {
  return Ok(Sha3_256::digest(&amp;v).as_slice().to_vec());
}

#[wasmedge_bindgen]
pub fn keccak_digest(s: Vec&lt;u8&gt;) -&gt; Result&lt;Vec&lt;u8&gt;, String&gt; {
  return Ok(Keccak256::digest(&amp;s).as_slice().to_vec());
}
<span class="boring">}
</span></code></pre></pre>
<p>You can build the WebAssembly bytecode file using standard <code>Cargo</code> commands.</p>
<pre><code class="language-bash">cd rust_bindgen_funcs
cargo build --target wasm32-wasi --release
# The output WASM will be target/wasm32-wasi/release/rust_bindgen_funcs_lib.wasm.
cp target/wasm32-wasi/release/rust_bindgen_funcs_lib.wasm ../
cd ../
</code></pre>
<h2 id="go-host-application"><a class="header" href="#go-host-application">Go host application</a></h2>
<p>In the <a href="https://github.com/second-state/WasmEdge-go-examples/blob/master/wasmedge-bindgen/go_BindgenFuncs/bindgen_funcs.go">Go host application</a>, you can create and set up the WasmEdge VM using the WasmEdge Go SDK.
However, instead of calling <code>vm.Instantiate()</code>, you should now call <code>bindgen.Instantiate(vm)</code> to instantiate the VM and return a <code>bindgen</code> object.</p>
<pre><code class="language-go">func main() {
  // Expected Args[0]: program name (./bindgen_funcs)
  // Expected Args[1]: wasm file (rust_bindgen_funcs_lib.wasm))

  wasmedge.SetLogErrorLevel()
  var conf = wasmedge.NewConfigure(wasmedge.WASI)
  var vm = wasmedge.NewVMWithConfig(conf)
  var wasi = vm.GetImportModule(wasmedge.WASI)
  wasi.InitWasi(
    os.Args[1:],     // The args
    os.Environ(),    // The envs
    []string{&quot;.:.&quot;}, // The mapping preopens
  )
  vm.LoadWasmFile(os.Args[1])
  vm.Validate()

  // Instantiate the bindgen and vm
  bg := bindgen.Instantiate(vm)
</code></pre>
<p>Next, you can call any <code>[wasmedge_bindgen]</code> annotated functions in the VM via the <code>bindgen</code> object.</p>
<pre><code class="language-go">  // create_line: string, string, string -&gt; string (inputs are JSON stringified) 
  res, err := bg.Execute(&quot;create_line&quot;, &quot;{\&quot;x\&quot;:2.5,\&quot;y\&quot;:7.8}&quot;, &quot;{\&quot;x\&quot;:2.5,\&quot;y\&quot;:5.8}&quot;, &quot;A thin red line&quot;)
  if err == nil {
    fmt.Println(&quot;Run bindgen -- create_line:&quot;, string(res))
  } else {
    fmt.Println(&quot;Run bindgen -- create_line FAILED&quot;, err)
  }

  // say: string -&gt; string
  res, err = bg.Execute(&quot;say&quot;, &quot;bindgen funcs test&quot;)
  if err == nil {
    fmt.Println(&quot;Run bindgen -- say:&quot;, string(res))
  } else {
    fmt.Println(&quot;Run bindgen -- say FAILED&quot;)
  }

  // obfusticate: string -&gt; string
  res, err = bg.Execute(&quot;obfusticate&quot;, &quot;A quick brown fox jumps over the lazy dog&quot;)
  if err == nil {
    fmt.Println(&quot;Run bindgen -- obfusticate:&quot;, string(res))
  } else {
    fmt.Println(&quot;Run bindgen -- obfusticate FAILED&quot;)
  }

  // lowest_common_multiple: i32, i32 -&gt; i32
  res, err = bg.Execute(&quot;lowest_common_multiple&quot;, int32(123), int32(2))
  if err == nil {
    num, _ := strconv.ParseInt(string(res), 10, 32)
    fmt.Println(&quot;Run bindgen -- lowest_common_multiple:&quot;, num)
  } else {
    fmt.Println(&quot;Run bindgen -- lowest_common_multiple FAILED&quot;)
  }

  // sha3_digest: array -&gt; array
  res, err = bg.Execute(&quot;sha3_digest&quot;, []byte(&quot;This is an important message&quot;))
  if err == nil {
    fmt.Println(&quot;Run bindgen -- sha3_digest:&quot;, res)
  } else {
    fmt.Println(&quot;Run bindgen -- sha3_digest FAILED&quot;)
  }

  // keccak_digest: array -&gt; array
  res, err = bg.Execute(&quot;keccak_digest&quot;, []byte(&quot;This is an important message&quot;))
  if err == nil {
    fmt.Println(&quot;Run bindgen -- keccak_digest:&quot;, res)
  } else {
    fmt.Println(&quot;Run bindgen -- keccak_digest FAILED&quot;)
  }

  bg.Release()
  vm.Release()
  conf.Release()
}
</code></pre>
<p>Finally, you can build and run the Go host application.</p>
<pre><code class="language-bash">go get github.com/second-state/WasmEdge-go/wasmedge@v0.11.1
go build
./bindgen_funcs rust_bindgen_funcs_lib.wasm
</code></pre>
<p>The standard output of this example will be the following.</p>
<pre><code class="language-bash">Run bindgen -- create_line: {&quot;points&quot;:[{&quot;x&quot;:1.5,&quot;y&quot;:3.8},{&quot;x&quot;:2.5,&quot;y&quot;:5.8}],&quot;valid&quot;:true,&quot;length&quot;:2.2360682,&quot;desc&quot;:&quot;A thin red line&quot;}
Run bindgen -- say: hello bindgen funcs test
Run bindgen -- obfusticate: N dhvpx oebja sbk whzcf bire gur ynml qbt
Run bindgen -- lowest_common_multiple: 246
Run bindgen -- sha3_digest: [87 27 231 209 189 105 251 49 159 10 211 250 15 159 154 181 43 218 26 141 56 199 25 45 60 10 20 163 54 211 195 203]
Run bindgen -- keccak_digest: [126 194 241 200 151 116 227 33 216 99 159 22 107 3 177 169 216 191 114 156 174 193 32 159 246 228 245 133 52 75 55 27]
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pass-complex-parameters-to-wasm-functions"><a class="header" href="#pass-complex-parameters-to-wasm-functions">Pass complex parameters to Wasm functions</a></h1>
<p>An issue with the WebAssembly spec is that it only supports a very limited number of data types. If you want to embed a WebAssembly function with complex call parameters or return values, you will need to manage memory pointers both on Go SDK and WebAssembly function sides.
Such complex call parameters and return values include dynamic memory structures such as strings and byte arrays.
In this section, we will discuss several examples.</p>
<ul>
<li><a href="sdk/go/memory.html#pass-strings-to-rust-functions">Pass strings to Rust functions</a></li>
<li><a href="sdk/go/memory.html#pass-strings-to-tinygo-functions">Pass strings to TinyGo functions</a></li>
<li><a href="sdk/go/memory.html#pass-bytes-to-rust-functions">Pass bytes to Rust functions</a></li>
<li><a href="sdk/go/memory.html#pass-bytes-to-tinygo-functions">Pass bytes to TinyGo functions</a></li>
</ul>
<h2 id="pass-strings-to-rust-functions"><a class="header" href="#pass-strings-to-rust-functions">Pass strings to Rust functions</a></h2>
<p>In <a href="https://github.com/second-state/WasmEdge-go-examples/tree/master/go_MemoryGreet">this example</a>, we will demonstrate how to call <a href="https://github.com/second-state/WasmEdge-go-examples/blob/master/go_MemoryGreet/rust_memory_greet/src/lib.rs">a Rust-based WebAssembly function</a> from a Go app.
Specially, we will discuss how to pass string data.</p>
<blockquote>
<p>An alternative approach to pass and return complex values to Rust functions in WebAssembly is to use the <code>wasmedge_bindgen</code> compiler tool. You can <a href="sdk/go/bindgen.html">learn more here</a>.</p>
</blockquote>
<p>The Rust function takes a memory pointer for the string, and constructs the Rust string itself.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::ffi::{CStr, CString};
use std::mem;
use std::os::raw::{c_char, c_void};

#[no_mangle]
pub extern fn allocate(size: usize) -&gt; *mut c_void {
  let mut buffer = Vec::with_capacity(size);
  let pointer = buffer.as_mut_ptr();
  mem::forget(buffer);

  pointer as *mut c_void
}

#[no_mangle]
pub extern fn deallocate(pointer: *mut c_void, capacity: usize) {
  unsafe {
    let _ = Vec::from_raw_parts(pointer, 0, capacity);
  }
}

#[no_mangle]
pub extern fn greet(subject: *mut c_char) -&gt; *mut c_char {
  let subject = unsafe { CStr::from_ptr(subject).to_bytes().to_vec() };
  let mut output = b&quot;Hello, &quot;.to_vec();
  output.extend(&amp;subject);
  output.extend(&amp;[b'!']);

  unsafe { CString::from_vec_unchecked(output) }.into_raw()
}
<span class="boring">}
</span></code></pre></pre>
<p>Use standard Rust compiler tools to compile the Rust source code into a WebAssembly bytecode application.</p>
<pre><code class="language-bash">cd rust_memory_greet
cargo build --target wasm32-wasi
# The output WASM will be `target/wasm32-wasi/debug/rust_memory_greet_lib.wasm`.
</code></pre>
<p>The <a href="https://github.com/second-state/WasmEdge-go-examples/blob/master/go_MemoryGreet/greet_memory.go">Go SDK application</a> must call <code>allocate</code> from the WasmEdge VM to get a pointer to the string parameter.
It will then call the <code>greet</code> function in Rust with the pointer.
After the function returns, the Go application will call <code>deallocate</code> to free the memory space.</p>
<pre><code class="language-go">package main

import (
  &quot;fmt&quot;
  &quot;os&quot;
  &quot;strings&quot;

  &quot;github.com/second-state/WasmEdge-go/wasmedge&quot;
)

func main() {
  wasmedge.SetLogErrorLevel()
  conf := wasmedge.NewConfigure(wasmedge.WASI)
  vm := wasmedge.NewVMWithConfig(conf)

  wasi := vm.GetImportModule(wasmedge.WASI)
  wasi.InitWasi(
    os.Args[1:],
    os.Environ(),
    []string{&quot;.:.&quot;},
  )

  err := vm.LoadWasmFile(os.Args[1])
  if err != nil {
    fmt.Println(&quot;failed to load wasm&quot;)
  }
  vm.Validate()
  vm.Instantiate()

  subject := &quot;WasmEdge&quot;
  lengthOfSubject := len(subject)

  // Allocate memory for the subject, and get a pointer to it.
  // Include a byte for the NULL terminator we add below.
  allocateResult, _ := vm.Execute(&quot;allocate&quot;, int32(lengthOfSubject + 1))
  inputPointer := allocateResult[0].(int32)

  // Write the subject into the memory.
  mod := vm.GetActiveModule()
  mem := mod.FindMemory(&quot;memory&quot;)
  memData, _ := mem.GetData(uint(inputPointer), uint(lengthOfSubject+1))
  copy(memData, subject)

  // C-string terminates by NULL.
  memData[lengthOfSubject] = 0

  // Run the `greet` function. Given the pointer to the subject.
  greetResult, _ := vm.Execute(&quot;greet&quot;, inputPointer)
  outputPointer := greetResult[0].(int32)

  pageSize := mem.GetPageSize()
  // Read the result of the `greet` function.
  memData, _ = mem.GetData(uint(0), uint(pageSize * 65536))
  nth := 0
  var output strings.Builder

  for {
    if memData[int(outputPointer) + nth] == 0 {
      break
    }

    output.WriteByte(memData[int(outputPointer) + nth])
    nth++
  }

  lengthOfOutput := nth

  fmt.Println(output.String())

  // Deallocate the subject, and the output.
  vm.Execute(&quot;deallocate&quot;, inputPointer, int32(lengthOfSubject+1))
  vm.Execute(&quot;deallocate&quot;, outputPointer, int32(lengthOfOutput+1))

  vm.Release()
  conf.Release()
}
</code></pre>
<p>To build the Go SDK example, run the following commands.</p>
<pre><code class="language-bash">go get github.com/second-state/WasmEdge-go/wasmedge@v0.11.1
go build greet_memory.go
</code></pre>
<p>Now you can use the Go application to run the WebAssembly plug-in compiled from Rust.</p>
<pre><code class="language-bash">$ ./greet_memory rust_memory_greet_lib.wasm
Hello, WasmEdge!
</code></pre>
<h2 id="pass-strings-to-tinygo-functions"><a class="header" href="#pass-strings-to-tinygo-functions">Pass strings to TinyGo functions</a></h2>
<p>In <a href="https://github.com/second-state/WasmEdge-go-examples/tree/master/go_MemoryGreetTinyGo">this example</a>, we will demonstrate how to call <a href="https://github.com/second-state/WasmEdge-go-examples/blob/master/go_MemoryGreetTinyGo/greet.go">a TinyGo-based WebAssembly function</a> from a Go app.</p>
<p>The TinyGo function takes a memory pointer for the string, and constructs the TinyGo string itself.</p>
<blockquote>
<p>The empty <code>main()</code> is needed to the compiled WebAssembly program to set up WASI properly.</p>
</blockquote>
<pre><code class="language-go">package main

import (
  &quot;strings&quot;
  &quot;unsafe&quot;
)

func main() {}

// export greet
func greet(subject *int32) *byte {
  nth := 0
  var subjectStr strings.Builder
  pointer := uintptr(unsafe.Pointer(subject))
  for {
    s := *(*int32)(unsafe.Pointer(pointer + uintptr(nth)))
    if s == 0 {
      break;
    }

    subjectStr.WriteByte(byte(s))
    nth++
  }

  output := subjectStr.String()
  output = &quot;Hello, &quot; + output + &quot;!&quot;

  return &amp;(([]byte)(output)[0])
}
</code></pre>
<p>Use the TinyGo compiler tools to compile the Go source code into a WebAssembly bytecode application.</p>
<pre><code class="language-bash">tinygo build -o greet.wasm -target wasi greet.go
</code></pre>
<p>The <a href="https://github.com/second-state/WasmEdge-go-examples/blob/master/go_MemoryGreetTinyGo/greet_memory.go">Go SDK application</a> must call <code>malloc</code> from the WasmEdge VM to get a pointer to the string parameter.
It will then call the <code>greet</code> function in TinyGo with the pointer.
After the function returns, the Go application will call <code>free</code> to free the memory space.</p>
<pre><code class="language-go">package main

import (
  &quot;fmt&quot;
  &quot;os&quot;
  &quot;strings&quot;

  &quot;github.com/second-state/WasmEdge-go/wasmedge&quot;
)

func main() {
  wasmedge.SetLogErrorLevel()
  conf := wasmedge.NewConfigure(wasmedge.WASI)
  vm := wasmedge.NewVMWithConfig(conf)

  wasi := vm.GetImportModule(wasmedge.WASI)
  wasi.InitWasi(
    os.Args[1:],
    os.Environ(),
    []string{&quot;.:.&quot;},
  )

  err := vm.LoadWasmFile(os.Args[1])
  if err != nil {
    fmt.Println(&quot;failed to load wasm&quot;)
  }
  vm.Validate()
  vm.Instantiate()

  subject := &quot;WasmEdge&quot;
  lengthOfSubject := len(subject)

  // Allocate memory for the subject, and get a pointer to it.
  // Include a byte for the NULL terminator we add below.
  allocateResult, _ := vm.Execute(&quot;malloc&quot;, int32(lengthOfSubject+1))
  inputPointer := allocateResult[0].(int32)

  // Write the subject into the memory.
  mod := vm.GetActiveModule()
  mem := mod.FindMemory(&quot;memory&quot;)
  memData, _ := mem.GetData(uint(inputPointer), uint(lengthOfSubject+1))
  copy(memData, subject)

  // C-string terminates by NULL.
  memData[lengthOfSubject] = 0

  // Run the `greet` function. Given the pointer to the subject.
  greetResult, _ := vm.Execute(&quot;greet&quot;, inputPointer)
  outputPointer := greetResult[0].(int32)

  pageSize := mem.GetPageSize()
  // Read the result of the `greet` function.
  memData, _ = mem.GetData(uint(0), uint(pageSize * 65536))
  nth := 0
  var output strings.Builder

  for {
    if memData[int(outputPointer) + nth] == 0 {
      break
    }

    output.WriteByte(memData[int(outputPointer) + nth])
    nth++
  }

  fmt.Println(output.String())

  // Deallocate the subject, and the output.
  vm.Execute(&quot;free&quot;, inputPointer)
  vm.Execute(&quot;free&quot;, outputPointer)

  vm.Release()
  conf.Release()
}
</code></pre>
<p>To build the Go SDK example, run the following commands.</p>
<pre><code class="language-bash">go get github.com/second-state/WasmEdge-go/wasmedge@v0.11.1
go build greet_memory.go
</code></pre>
<p>Now you can use the Go application to run the WebAssembly plug-in compiled from TinyGo.</p>
<pre><code class="language-bash">$ ./greet_memory greet.wasm
Hello, WasmEdge!
</code></pre>
<h2 id="pass-bytes-to-rust-functions"><a class="header" href="#pass-bytes-to-rust-functions">Pass bytes to Rust functions</a></h2>
<p>In <a href="https://github.com/second-state/WasmEdge-go-examples/tree/master/go_AccessMemory">this example</a>, we will demonstrate how to call <a href="https://github.com/second-state/WasmEdge-go-examples/blob/master/go_AccessMemory/rust_access_memory/src/lib.rs">Rust-based WebAssembly functions</a> and pass arrays to and from a Go app.</p>
<blockquote>
<p>An alternative approach to pass and return complex values to Rust functions in WebAssembly is to use the <code>wasmedge_bindgen</code> compiler tool. You can <a href="sdk/go/bindgen.html">learn more here</a>.</p>
</blockquote>
<p>The <code>fib_array()</code> function takes a array as a call parameter and fill it with a fibonacci sequence of numbers. Alternatively, the <code>fib_array_return_memory()</code> function returns a array of fibonacci sequence of numbers.</p>
<p>For the array in the call parameter, the Rust function <code>fib_array()</code> takes a memory pointer and constructs the Rust <code>Vec</code> using <code>from_raw_parts</code>. For the array return value, the Rust function <code>fib_array_return_memory()</code> simply returns the pointer.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::mem;
use std::os::raw::{c_void, c_int};

#[no_mangle]
pub extern fn allocate(size: usize) -&gt; *mut c_void {
  let mut buffer = Vec::with_capacity(size);
  let pointer = buffer.as_mut_ptr();
  mem::forget(buffer);

  pointer as *mut c_void
}

#[no_mangle]
pub extern fn deallocate(pointer: *mut c_void, capacity: usize) {
  unsafe {
    let _ = Vec::from_raw_parts(pointer, 0, capacity);
  }
}

#[no_mangle]
pub extern fn fib_array(n: i32, p: *mut c_int) -&gt; i32 {
  unsafe {
    let mut arr = Vec::&lt;i32&gt;::from_raw_parts(p, 0, (4*n) as usize);
    for i in 0..n {
      if i &lt; 2 {
        arr.push(i);
      } else {
        arr.push(arr[(i - 1) as usize] + arr[(i - 2) as usize]);
      }
    }
    let r = arr[(n - 1) as usize];
    mem::forget(arr);
    r
  }
}

#[no_mangle]
pub extern fn fib_array_return_memory(n: i32) -&gt; *mut c_int {
  let mut arr = Vec::with_capacity((4 * n) as usize);
  let pointer = arr.as_mut_ptr();
  for i in 0..n {
    if i &lt; 2 {
      arr.push(i);
    } else {
      arr.push(arr[(i - 1) as usize] + arr[(i - 2) as usize]);
    }
  }
  mem::forget(arr);
  pointer
}
<span class="boring">}
</span></code></pre></pre>
<p>Use standard Rust compiler tools to compile the Rust source code into a WebAssembly bytecode application.</p>
<pre><code class="language-bash">cd rust_access_memory
cargo build --target wasm32-wasi
# The output WASM will be target/wasm32-wasi/debug/rust_access_memory_lib.wasm.
</code></pre>
<p>The <a href="https://github.com/second-state/WasmEdge-go-examples/blob/master/go_AccessMemory/run.go">Go SDK application</a> must call <code>allocate</code> from the WasmEdge VM to get a pointer to the array.
It will then call the <code>fib_array()</code> function in Rust and pass in the pointer.
After the functions return, the Go application will use the WasmEdge <code>store</code> API to construct an array from the pointer in the call parameter (<code>fib_array()</code>) or in the return value (<code>fib_array_return_memory()</code>).
The Go app will eventually call <code>deallocate</code> to free the memory space.</p>
<pre><code class="language-go">package main

import (
  &quot;fmt&quot;
  &quot;os&quot;
  &quot;unsafe&quot;

  &quot;github.com/second-state/WasmEdge-go/wasmedge&quot;
)

func main() {
  wasmedge.SetLogErrorLevel()
  conf := wasmedge.NewConfigure(wasmedge.WASI)
  vm := wasmedge.NewVMWithConfig(conf)

  wasi := vm.GetImportModule(wasmedge.WASI)
  wasi.InitWasi(
    os.Args[1:],
    os.Environ(),
    []string{&quot;.:.&quot;},
  )

  err := vm.LoadWasmFile(os.Args[1])
  if err != nil {
    fmt.Println(&quot;failed to load wasm&quot;)
  }
  vm.Validate()
  vm.Instantiate()

  n := int32(10)

  p, err := vm.Execute(&quot;allocate&quot;, 4 * n)
  if err != nil {
    fmt.Println(&quot;allocate failed:&quot;, err)
  }

  fib, err := vm.Execute(&quot;fib_array&quot;, n, p[0])
  if err != nil {
    fmt.Println(&quot;fib_rray failed:&quot;, err)
  } else {
    fmt.Println(&quot;fib_array() returned:&quot;, fib[0])
    fmt.Printf(&quot;fib_array memory at: %p\n&quot;, unsafe.Pointer((uintptr)(p[0].(int32))))
    mod := vm.GetActiveModule()
    mem := mod.FindMemory(&quot;memory&quot;)
    if mem != nil {
      // int32 occupies 4 bytes
      fibArray, err := mem.GetData(uint(p[0].(int32)), uint(n * 4))
      if err == nil &amp;&amp; fibArray != nil {
        fmt.Println(&quot;fibArray:&quot;, fibArray)
      }
    }
  }

  fibP, err := vm.Execute(&quot;fib_array_return_memory&quot;, n)
  if err != nil {
    fmt.Println(&quot;fib_array_return_memory failed:&quot;, err)
  } else {
    fmt.Printf(&quot;fib_array_return_memory memory at: %p\n&quot;, unsafe.Pointer((uintptr)(fibP[0].(int32))))
    mod := vm.GetActiveModule()
    mem := mod.FindMemory(&quot;memory&quot;)
    if mem != nil {
      // int32 occupies 4 bytes
      fibArrayReturnMemory, err := mem.GetData(uint(fibP[0].(int32)), uint(n * 4))
      if err == nil &amp;&amp; fibArrayReturnMemory != nil {
        fmt.Println(&quot;fibArrayReturnMemory:&quot;, fibArrayReturnMemory)
      }
    }
  }

  _, err = vm.Execute(&quot;deallocate&quot;, p[0].(int32), 4 * n)
  if err != nil {
    fmt.Println(&quot;free failed:&quot;, err)
  }


  exitcode := wasi.WasiGetExitCode()
  if exitcode != 0 {
    fmt.Println(&quot;Go: Running wasm failed, exit code:&quot;, exitcode)
  }

  vm.Release()
  conf.Release()
}
</code></pre>
<p>To build the Go SDK example, run the following commands.</p>
<pre><code class="language-bash">go get github.com/second-state/WasmEdge-go/wasmedge@v0.11.1
go build run.go
</code></pre>
<p>Now you can use the Go application to run the WebAssembly plug-in compiled from Rust.</p>
<pre><code class="language-bash">$ ./run rust_access_memory_lib.wasm
fib_array() returned: 34
fib_array memory at: 0x102d80
fibArray: [0 0 0 0 1 0 0 0 1 0 0 0 2 0 0 0 3 0 0 0 5 0 0 0 8 0 0 0 13 0 0 0 21 0 0 0 34 0 0 0]
fib_array_return_memory memory at: 0x105430
fibArrayReturnMemory: [0 0 0 0 1 0 0 0 1 0 0 0 2 0 0 0 3 0 0 0 5 0 0 0 8 0 0 0 13 0 0 0 21 0 0 0 34 0 0 0]
</code></pre>
<h2 id="pass-bytes-to-tinygo-functions"><a class="header" href="#pass-bytes-to-tinygo-functions">Pass bytes to TinyGo functions</a></h2>
<p>In <a href="https://github.com/second-state/WasmEdge-go-examples/tree/master/go_AccessMemoryTinyGo">this example</a>, we will demonstrate how to call <a href="https://github.com/second-state/WasmEdge-go-examples/blob/master/go_AccessMemoryTinyGo/fib.go">TinyGo-based WebAssembly functions</a> and pass arrays to and from a Go app.</p>
<p>The <code>fibArray</code> function takes a array as a call parameter and fill it with
a fibonacci sequence of numbers. Alternatively, the <code>fibArrayReturnMemory</code> function returns
a array of fibonacci sequence of numbers.</p>
<pre><code class="language-go">package main

import (
  &quot;fmt&quot;
  &quot;unsafe&quot;
)

func main() {
  println(&quot;in main&quot;)
  n := int32(10)
  arr := make([]int32, n)
  arrP := &amp;arr[0]
  fmt.Printf(&quot;call fibArray(%d, %p) = %d\n&quot;, n, arrP, fibArray(n, arrP))
  fmt.Printf(&quot;call fibArrayReturnMemory(%d) return %p\n&quot;, n, fibArrayReturnMemory(n))
}

// export fibArray
func fibArray(n int32, p *int32) int32 {
  arr := unsafe.Slice(p, n)
  for i := int32(0); i &lt; n; i++ {
    switch {
    case i &lt; 2:
      arr[i] = i
    default:
      arr[i] = arr[i-1] + arr[i-2]
    }
  }
  return arr[n-1]
}

// export fibArrayReturnMemory
func fibArrayReturnMemory(n int32) *int32 {
  arr := make([]int32, n)
  for i := int32(0); i &lt; n; i++ {
    switch {
    case i &lt; 2:
      arr[i] = i
    default:
      arr[i] = arr[i-1] + arr[i-2]
    }
  }
  return &amp;arr[0]
}
</code></pre>
<p>Use the TinyGo compiler tools to compile the Go source code into a WebAssembly bytecode application.</p>
<pre><code class="language-bash">tinygo build -o fib.wasm -target wasi fib.go
</code></pre>
<p>The <a href="https://github.com/second-state/WasmEdge-go-examples/blob/master/go_AccessMemoryTinyGo/run.go">Go SDK application</a> must call <code>malloc</code> from the WasmEdge VM to get a pointer to the array.
It will then call the <code>fibArray()</code> function in TinyGo with the pointer.
After the functions return, the Go app uses the WasmEdge SDK's <code>store</code> API to construct an array from the pointer in the call parameter (<code>fibArray()</code>) or in the return value (<code>fibArrayReturnMemory()</code>).
The Go application will eventually call <code>free</code> to free the memory space.</p>
<pre><code class="language-go">package main

import (
  &quot;fmt&quot;
  &quot;os&quot;
  &quot;unsafe&quot;

  &quot;github.com/second-state/WasmEdge-go/wasmedge&quot;
)

func main() {
  wasmedge.SetLogErrorLevel()
  conf := wasmedge.NewConfigure(wasmedge.WASI)
  vm := wasmedge.NewVMWithConfig(conf)

  wasi := vm.GetImportModule(wasmedge.WASI)
  wasi.InitWasi(
    os.Args[1:],
    os.Environ(),
    []string{&quot;.:.&quot;},
  )

  err := vm.LoadWasmFile(os.Args[1])
  if err != nil {
    fmt.Println(&quot;failed to load wasm&quot;)
  }
  vm.Validate()
  vm.Instantiate()

  n := int32(10)

  p, err := vm.Execute(&quot;malloc&quot;, n)
  if err != nil {
    fmt.Println(&quot;malloc failed:&quot;, err)
  }

  fib, err := vm.Execute(&quot;fibArray&quot;, n, p[0])
  if err != nil {
    fmt.Println(&quot;fibArray failed:&quot;, err)
  } else {
    fmt.Println(&quot;fibArray() returned:&quot;, fib[0])
    fmt.Printf(&quot;fibArray memory at: %p\n&quot;, unsafe.Pointer((uintptr)(p[0].(int32))))
    mod := vm.GetActiveModule()
    mem := mod.FindMemory(&quot;memory&quot;)
    if mem != nil {
      // int32 occupies 4 bytes
      fibArray, err := mem.GetData(uint(p[0].(int32)), uint(n * 4))
      if err == nil &amp;&amp; fibArray != nil {
        fmt.Println(&quot;fibArray:&quot;, fibArray)
      }
    }
  }

  fibP, err := vm.Execute(&quot;fibArrayReturnMemory&quot;, n)
  if err != nil {
    fmt.Println(&quot;fibArrayReturnMemory failed:&quot;, err)
  } else {
    fmt.Printf(&quot;fibArrayReturnMemory memory at: %p\n&quot;, unsafe.Pointer((uintptr)(fibP[0].(int32))))
    mod := vm.GetActiveModule()
    mem := mod.FindMemory(&quot;memory&quot;)
    if mem != nil {
      // int32 occupies 4 bytes
      fibArrayReturnMemory, err := mem.GetData(uint(fibP[0].(int32)), uint(n * 4))
      if err == nil &amp;&amp; fibArrayReturnMemory != nil {
        fmt.Println(&quot;fibArrayReturnMemory:&quot;, fibArrayReturnMemory)
      }
    }
  }

  _, err = vm.Execute(&quot;free&quot;, p...)
  if err != nil {
    fmt.Println(&quot;free failed:&quot;, err)
  }

  exitcode := wasi.WasiGetExitCode()
  if exitcode != 0 {
    fmt.Println(&quot;Go: Running wasm failed, exit code:&quot;, exitcode)
  }

  vm.Release()
  conf.Release()
}
</code></pre>
<p>To build the Go SDK example, run the following commands.</p>
<pre><code class="language-bash">go get github.com/second-state/WasmEdge-go/wasmedge@v0.11.1
go build run.go
</code></pre>
<p>Now you can use the Go application to run the WebAssembly plug-in compiled from TinyGo.</p>
<pre><code class="language-bash">$ ./run fib.wasm
fibArray() returned: 34
fibArray memory at: 0x14d3c
fibArray: [0 0 0 0 1 0 0 0 1 0 0 0 2 0 0 0 3 0 0 0 5 0 0 0 8 0 0 0 13 0 0 0 21 0 0 0 34 0 0 0]
fibArrayReturnMemory memory at: 0x14d4c
fibArrayReturnMemory: [0 0 0 0 1 0 0 0 1 0 0 0 2 0 0 0 3 0 0 0 5 0 0 0 8 0 0 0 13 0 0 0 21 0 0 0 34 0 0 0]
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tensorflow-2"><a class="header" href="#tensorflow-2">Tensorflow</a></h1>
<p>In this section, we will show you how to create a Tensorflow inference function in Rust for image classification, and then embed it into a Go application. The project source code is <a href="https://github.com/second-state/WasmEdge-go-examples/tree/master/wasmedge-bindgen/go_TfliteFood">available here</a>.</p>
<h2 id="rust-function-compiled-into-webassembly-1"><a class="header" href="#rust-function-compiled-into-webassembly-1">Rust function compiled into WebAssembly</a></h2>
<p>The Rust function for image classification is <a href="https://github.com/second-state/WasmEdge-go-examples/blob/master/wasmedge-bindgen/go_TfliteFood/rust_tflite_food/src/lib.rs">available here</a>.
It utilizes the <a href="sdk/go/../../write_wasm/rust/tensorflow.html">WasmEdge Tensorflow extension API</a> as well as the <a href="sdk/go/function.html">wasmedge_bindgen</a> for passing call parameters.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[wasmedge_bindgen]
fn infer(image_data: Vec&lt;u8&gt;) -&gt; Result&lt;Vec&lt;u8&gt;, String&gt; {
  ... ...
  let flat_img = image::imageops::thumbnail(&amp;img, 192, 192);

  let model_data: &amp;[u8] = include_bytes!(&quot;lite-model_aiy_vision_classifier_food_V1_1.tflite&quot;);
  let labels = include_str!(&quot;aiy_food_V1_labelmap.txt&quot;);

  let mut session = wasmedge_tensorflow_interface::Session::new(
    model_data,
    wasmedge_tensorflow_interface::ModelType::TensorFlowLite,
  );
  session
    .add_input(&quot;input&quot;, &amp;flat_img, &amp;[1, 192, 192, 3])
    .run();
  let res_vec: Vec&lt;u8&gt; = session.get_output(&quot;MobilenetV1/Predictions/Softmax&quot;);
  ... ...
}
<span class="boring">}
</span></code></pre></pre>
<p>You can use the standard <code>Cargo</code> command to build it into a WebAssembly function.</p>
<pre><code class="language-bash">cd rust_tflite_food
cargo build --target wasm32-wasi --release
cp target/wasm32-wasi/release/rust_tflite_food_lib.wasm ../
cd ../
</code></pre>
<p>You can use our AOT compiler <code>wasmedgec</code> to instrument the WebAssembly file to make it run much faster. <a href="sdk/go/../../quick_start/run_in_aot_mode.html">Learn more</a>.</p>
<pre><code class="language-bash">wasmedgec rust_tflite_food_lib.wasm rust_tflite_food_lib.wasm
</code></pre>
<h2 id="go-host-app"><a class="header" href="#go-host-app">Go host app</a></h2>
<p>The <a href="https://github.com/second-state/WasmEdge-go-examples/blob/master/wasmedge-bindgen/go_TfliteFood/tflite_food.go">Go host app</a> source code shows how to instantiate a WasmEdge runtime with the Tensorflow extension, and how to pass the image data to the Rust function in WasmEdge to run the inference.</p>
<pre><code class="language-go">func main() {
  // Expected Args[0]: program name (./tflite_food)
  // Expected Args[1]: wasm file (rust_tflite_food_lib.wasm)
  // Expected Args[2]: input image name (food.jpg)

  wasmedge.SetLogErrorLevel()

  // Set Tensorflow not to print debug info
  os.Setenv(&quot;TF_CPP_MIN_LOG_LEVEL&quot;, &quot;3&quot;)
  os.Setenv(&quot;TF_CPP_MIN_VLOG_LEVEL&quot;, &quot;3&quot;)

  var conf = wasmedge.NewConfigure(wasmedge.WASI)
  var vm = wasmedge.NewVMWithConfig(conf)
  var wasi = vm.GetImportModule(wasmedge.WASI)
  wasi.InitWasi(
    os.Args[1:],     // The args
    os.Environ(),    // The envs
    []string{&quot;.:.&quot;}, // The mapping preopens
  )

  // Register WasmEdge-tensorflow
  var tfmod = wasmedge.NewTensorflowModule()
  var tflitemod = wasmedge.NewTensorflowLiteModule()
  vm.RegisterModule(tfmod)
  vm.RegisterModule(tflitemod)

  // Load and validate the wasm
  vm.LoadWasmFile(os.Args[1])
  vm.Validate()

  // Instantiate the bindgen and vm
  bg := bindgen.Instantiate(vm)

  img, _ := ioutil.ReadFile(os.Args[2])
  if res, err := bg.Execute(&quot;infer&quot;, img); err != nil {
    fmt.Println(err)
  } else {
    fmt.Println(string(res))
  }

  bg.Release()
  vm.Release()
  conf.Release()
  tfmod.Release()
  tflitemod.Release()
}
</code></pre>
<h2 id="build-and-run"><a class="header" href="#build-and-run">Build and run</a></h2>
<blockquote>
<p>You must have WasmEdge with its tensorflow extension installed on your machine. <a href="sdk/go/../../quick_start/install.html">Checkout the install guide</a> for details.</p>
</blockquote>
<p>The following command builds the Go host application with the WasmEdge Go SDK and its tensorflow extension.</p>
<pre><code class="language-bash">go get github.com/second-state/WasmEdge-go/wasmedge@v0.11.1
go build -tags tensorflow
</code></pre>
<p>Now you can run the Go application. It calls the WebAssembly function in WasmEdge to run inference on the input image.</p>
<pre><code class="language-bash">./tflite_food rust_tflite_food_lib.wasm food.jpg
</code></pre>
<p>The results are as follows.</p>
<pre><code class="language-bash">Go: Args: [./tflite_food rust_tflite_food_lib.wasm food.jpg]
It is very likely a Hot dog in the picture
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="embed-a-bindgen-function"><a class="header" href="#embed-a-bindgen-function">Embed a bindgen function</a></h1>
<p>In <a href="https://github.com/second-state/WasmEdge-go-examples/tree/master/go_BindgenFuncs">this example</a>, we will demonstrate how to call a few simple WebAssembly functions from a Go app. The <a href="https://github.com/second-state/WasmEdge-go-examples/blob/master/go_BindgenFuncs/rust_bindgen_funcs/src/lib.rs">functions</a> are written in Rust, and require complex call parameters and return values. The <code>#[wasmedge_bindgen]</code> macro is needed for the compiler tools to auto-generate the correct code to pass call parameters from Go to WebAssembly.</p>
<p>The WebAssembly spec only supports a few simple data types out of the box. It <a href="https://medium.com/wasm/strings-in-webassembly-wasm-57a05c1ea333">does not support</a> types such as string and array. In order to pass rich types in Go to WebAssembly, the compiler needs to convert them to simple integers. For example, it converts a string into an integer memory address and an integer length. The <code>wasmedge_bindgen</code> tool does this conversion automatically.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use num_integer::lcm;
use serde::{Deserialize, Serialize};
use sha3::{Digest, Keccak256, Sha3_256};
#[allow(unused_imports)]
use wasmedge_bindgen::*;
use wasmedge_bindgen_macro::*;

#[derive(Serialize, Deserialize, Debug)]
struct Point {
    x: f32,
    y: f32,
}

#[derive(Serialize, Deserialize, Debug)]
struct Line {
    points: Vec&lt;Point&gt;,
    valid: bool,
    length: f32,
    desc: String,
}

#[wasmedge_bindgen]
pub fn create_line(p1: String, p2: String, desc: String) -&gt; String {
    let point1: Point = serde_json::from_str(&amp;p1).unwrap();
    let point2: Point = serde_json::from_str(&amp;p2).unwrap();
    let length = ((point1.x - point2.x) * (point1.x - point2.x)
        + (point1.y - point2.y) * (point1.y - point2.y))
        .sqrt();

    let valid = if length == 0.0 { false } else { true };

    let line = Line {
        points: vec![point1, point2],
        valid: valid,
        length: length,
        desc: desc,
    };

    return serde_json::to_string(&amp;line).unwrap();
}

#[wasmedge_bindgen]
pub fn say(s: String) -&gt; String {
    let r = String::from(&quot;hello &quot;);
    return r + &amp;s;
}

#[wasmedge_bindgen]
pub fn obfusticate(s: String) -&gt; String {
    (&amp;s).chars()
        .map(|c| match c {
            'A'..='M' | 'a'..='m' =&gt; ((c as u8) + 13) as char,
            'N'..='Z' | 'n'..='z' =&gt; ((c as u8) - 13) as char,
            _ =&gt; c,
        })
        .collect()
}

#[wasmedge_bindgen]
pub fn lowest_common_multiple(a: i32, b: i32) -&gt; i32 {
    let r = lcm(a, b);
    return r;
}

#[wasmedge_bindgen]
pub fn sha3_digest(v: Vec&lt;u8&gt;) -&gt; Vec&lt;u8&gt; {
    return Sha3_256::digest(&amp;v).as_slice().to_vec();
}

#[wasmedge_bindgen]
pub fn keccak_digest(s: Vec&lt;u8&gt;) -&gt; Vec&lt;u8&gt; {
    return Keccak256::digest(&amp;s).as_slice().to_vec();
}
<span class="boring">}
</span></code></pre></pre>
<p>First, we will compile the Rust source code into WebAssembly bytecode functions.</p>
<pre><code class="language-bash">$ cd rust_bindgen_funcs
$ cargo build --release --target wasm32-wasi
# The output WASM will be target/wasm32-wasi/release/rust_bindgen_funcs_lib.wasm
</code></pre>
<p>The <a href="https://github.com/second-state/WasmEdge-go-examples/blob/master/go_BindgenFuncs/bindgen_funcs.go">Go source code</a> to run the WebAssembly function in WasmEdge is as follows. The <code>Execute()</code> function calls the WebAssembly function and passes the call parameters using the <code>#[wasmedge_bindgen]</code> convention.</p>
<pre><code class="language-go">package main

import (
  &quot;fmt&quot;
  &quot;os&quot;

  &quot;github.com/second-state/WasmEdge-go/wasmedge&quot;
  bindgen &quot;github.com/second-state/wasmedge-bindgen/host/go&quot;
)

func main() {
  // Expected Args[0]: program name (./bindgen_funcs)
  // Expected Args[1]: wasm or wasm-so file (rust_bindgen_funcs_lib.wasm))

  // Set not to print debug info
  wasmedge.SetLogErrorLevel()

  // Create configure
  var conf = wasmedge.NewConfigure(wasmedge.WASI)

  // Create VM with configure
  var vm = wasmedge.NewVMWithConfig(conf)

  // Init WASI
  var wasi = vm.GetImportModule(wasmedge.WASI)
  wasi.InitWasi(
    os.Args[1:],     // The args
    os.Environ(),    // The envs
    []string{&quot;.:.&quot;}, // The mapping preopens
  )

  vm.LoadWasmFile(os.Args[1])
  vm.Validate()
  // Instantiate the bindgen and vm
  bg := bindgen.New(vm)
  bg.Instantiate()

  // Run bindgen functions
  var res []interface{}
  var err error
  // create_line: array, array, array -&gt; array (inputs are JSON stringified)
  res, _, err = bg.Execute(&quot;create_line&quot;, &quot;{\&quot;x\&quot;:1.5,\&quot;y\&quot;:3.8}&quot;, &quot;{\&quot;x\&quot;:2.5,\&quot;y\&quot;:5.8}&quot;, &quot;A thin red line&quot;)
  if err == nil {
    fmt.Println(&quot;Run bindgen -- create_line:&quot;, res[0].(string))
  } else {
    fmt.Println(&quot;Run bindgen -- create_line FAILED&quot;)
  }
  // say: array -&gt; array
  res, _, err = bg.Execute(&quot;say&quot;, &quot;bindgen funcs test&quot;)
  if err == nil {
    fmt.Println(&quot;Run bindgen -- say:&quot;, res[0].(string))
  } else {
    fmt.Println(&quot;Run bindgen -- say FAILED&quot;)
  }
  // obfusticate: array -&gt; array
  res, _, err = bg.Execute(&quot;obfusticate&quot;, &quot;A quick brown fox jumps over the lazy dog&quot;)
  if err == nil {
    fmt.Println(&quot;Run bindgen -- obfusticate:&quot;, res[0].(string))
  } else {
    fmt.Println(&quot;Run bindgen -- obfusticate FAILED&quot;)
  }
  // lowest_common_multiple: i32, i32 -&gt; i32
  res, _, err = bg.Execute(&quot;lowest_common_multiple&quot;, int32(123), int32(2))
  if err == nil {
    fmt.Println(&quot;Run bindgen -- lowest_common_multiple:&quot;, res[0].(int32))
  } else {
    fmt.Println(&quot;Run bindgen -- lowest_common_multiple FAILED&quot;)
  }
  // sha3_digest: array -&gt; array
  res, _, err = bg.Execute(&quot;sha3_digest&quot;, []byte(&quot;This is an important message&quot;))
  if err == nil {
    fmt.Println(&quot;Run bindgen -- sha3_digest:&quot;, res[0].([]byte))
  } else {
    fmt.Println(&quot;Run bindgen -- sha3_digest FAILED&quot;)
  }
  // keccak_digest: array -&gt; array
  res, _, err = bg.Execute(&quot;keccak_digest&quot;, []byte(&quot;This is an important message&quot;))
  if err == nil {
    fmt.Println(&quot;Run bindgen -- keccak_digest:&quot;, res[0].([]byte))
  } else {
    fmt.Println(&quot;Run bindgen -- keccak_digest FAILED&quot;)
  }

  bg.Release()
  conf.Release()
}
</code></pre>
<p>Next, let's build the Go application with the WasmEdge Go SDK.</p>
<pre><code class="language-bash">go get github.com/second-state/WasmEdge-go/wasmedge@v0.11.1
go build
</code></pre>
<p>Run the Go application and it will run the WebAssembly functions embedded in the WasmEdge runtime.</p>
<pre><code class="language-bash">$ ./bindgen_funcs rust_bindgen_funcs/target/wasm32-wasi/release/rust_bindgen_funcs_lib.wasm
Run bindgen -- create_line: {&quot;points&quot;:[{&quot;x&quot;:1.5,&quot;y&quot;:3.8},{&quot;x&quot;:2.5,&quot;y&quot;:5.8}],&quot;valid&quot;:true,&quot;length&quot;:2.2360682,&quot;desc&quot;:&quot;A thin red line&quot;}
Run bindgen -- say: hello bindgen funcs test
Run bindgen -- obfusticate: N dhvpx oebja sbk whzcf bire gur ynml qbt
Run bindgen -- lowest_common_multiple: 246
Run bindgen -- sha3_digest: [87 27 231 209 189 105 251 49 159 10 211 250 15 159 154 181 43 218 26 141 56 199 25 45 60 10 20 163 54 211 195 203]
Run bindgen -- keccak_digest: [126 194 241 200 151 116 227 33 216 99 159 22 107 3 177 169 216 191 114 156 174 193 32 159 246 228 245 133 52 75 55 27]
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="wasmedge-go-v0110-api-references"><a class="header" href="#wasmedge-go-v0110-api-references">WasmEdge Go v0.11.0 API references</a></h1>
<p>The followings are the guides to working with the WasmEdge-Go SDK.</p>
<p><strong>This document is for the <code>v0.11.0</code> version. For the older <code>v0.10.1</code> version, please refer to the <a href="sdk/go/0.10.1/ref.html">document here</a>.</strong></p>
<p><strong>Developers can refer to <a href="sdk/go/0.10.1/upgrade_to_0.11.0.html">here to upgrade to v0.11.0</a>.</strong></p>
<h2 id="table-of-contents-4"><a class="header" href="#table-of-contents-4">Table of Contents</a></h2>
<ul>
<li><a href="sdk/go/ref.html#getting-started">Getting Started</a>
<ul>
<li><a href="sdk/go/ref.html#wasmedge-installation">WasmEdge Installation</a></li>
<li><a href="sdk/go/ref.html#get-wasmedge-go">Get WasmEdge-go</a></li>
<li><a href="sdk/go/ref.html#wasmedge-go-extensions">WasmEdge-go Extensions</a></li>
<li><a href="sdk/go/ref.html#example-repository">Example repository</a></li>
</ul>
</li>
<li><a href="sdk/go/ref.html#wasmedge-go-basics">WasmEdge-go Basics</a>
<ul>
<li><a href="sdk/go/ref.html#version">Version</a></li>
<li><a href="sdk/go/ref.html#logging-settings">Logging Settings</a></li>
<li><a href="sdk/go/ref.html#value-types">Value Types</a></li>
<li><a href="sdk/go/ref.html#results">Results</a></li>
<li><a href="sdk/go/ref.html#contexts-and-their-life-cycles">Contexts And Their Life Cycles</a></li>
<li><a href="sdk/go/ref.html#wasm-data-structures">WASM data structures</a></li>
<li><a href="sdk/go/ref.html#async">Async</a></li>
<li><a href="sdk/go/ref.html#configurations">Configurations</a></li>
<li><a href="sdk/go/ref.html#statistics">Statistics</a></li>
<li><a href="sdk/go/ref.html#tools-driver">Tools driver</a></li>
</ul>
</li>
<li><a href="sdk/go/ref.html#wasmedge-vm">WasmEdge VM</a>
<ul>
<li><a href="sdk/go/ref.html#wasm-execution-example-with-vm-object">WASM Execution Example With VM Object</a></li>
<li><a href="sdk/go/ref.html#vm-creations">VM Creations</a></li>
<li><a href="sdk/go/ref.html#preregistrations">Preregistrations</a></li>
<li><a href="sdk/go/ref.html#host-module-registrations">Host Module Registrations</a></li>
<li><a href="sdk/go/ref.html#wasm-registrations-and-executions">WASM Registrations And Executions</a></li>
<li><a href="sdk/go/ref.html#asynchronous-execution">Asynchronous execution</a></li>
<li><a href="sdk/go/ref.html#instance-tracing">Instance Tracing</a></li>
</ul>
</li>
<li><a href="sdk/go/ref.html#wasmedge-runtime">WasmEdge Runtime</a>
<ul>
<li><a href="sdk/go/ref.html#wasm-execution-example-step-by-step">WASM Execution Example Step-By-Step</a></li>
<li><a href="sdk/go/ref.html#loader">Loader</a></li>
<li><a href="sdk/go/ref.html#validator">Validator</a></li>
<li><a href="sdk/go/ref.html#executor">Executor</a></li>
<li><a href="sdk/go/ref.html#ast-module">AST Module</a></li>
<li><a href="sdk/go/ref.html#store">Store</a></li>
<li><a href="sdk/go/ref.html#instances">Instances</a></li>
<li><a href="sdk/go/ref.html#host-functions">Host Functions</a></li>
</ul>
</li>
<li><a href="sdk/go/ref.html#wasmedge-aot-compiler">WasmEdge AOT Compiler</a>
<ul>
<li><a href="sdk/go/ref.html#compilation-example">Compilation Example</a></li>
<li><a href="sdk/go/ref.html#compiler-options">Compiler Options</a></li>
</ul>
</li>
</ul>
<h2 id="getting-started-2"><a class="header" href="#getting-started-2">Getting Started</a></h2>
<p>The WasmEdge-go requires golang version &gt;= 1.16. Please check your golang version before installation. Developers can <a href="https://golang.org/dl/">download golang here</a>.</p>
<pre><code class="language-bash">$ go version
go version go1.16.5 linux/amd64
</code></pre>
<h3 id="wasmedge-installation-3"><a class="header" href="#wasmedge-installation-3">WasmEdge Installation</a></h3>
<p>Developers must <a href="sdk/go/../../quick_start/install.html">install the WasmEdge shared library</a> with the same <code>WasmEdge-go</code> release or pre-release version.</p>
<pre><code class="language-bash">curl -sSf https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/utils/install.sh | bash -s -- -v 0.11.0
</code></pre>
<p>For the developers need the <code>TensorFlow</code> or <code>Image</code> extension for <code>WasmEdge-go</code>, please install the <code>WasmEdge</code> with extensions:</p>
<pre><code class="language-bash">curl -sSf https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/utils/install.sh | bash -s -- -e tf,image -v 0.11.0
</code></pre>
<p>Noticed that the <code>TensorFlow</code> and <code>Image</code> extensions are only for the <code>Linux</code> platforms.
After installation, developers can use the <code>source</code> command to update the include and linking searching path.</p>
<h3 id="get-wasmedge-go"><a class="header" href="#get-wasmedge-go">Get WasmEdge-go</a></h3>
<p>After the WasmEdge installation, developers can get the <code>WasmEdge-go</code> package and build it in your Go project directory.</p>
<pre><code class="language-bash">go get github.com/second-state/WasmEdge-go/wasmedge@v0.11.0
go build
</code></pre>
<blockquote>
<p>The WasmEdge-Go version number should match the installed WasmEdge version.</p>
</blockquote>
<h3 id="wasmedge-go-extensions-1"><a class="header" href="#wasmedge-go-extensions-1">WasmEdge-go Extensions</a></h3>
<p>By default, the <code>WasmEdge-go</code> only turns on the basic runtime.</p>
<p><code>WasmEdge-go</code> has the following extensions (on the Linux platforms only):</p>
<ul>
<li>
<p>Tensorflow</p>
<ul>
<li>
<p>This extension supports the host functions in <a href="https://github.com/second-state/WasmEdge-tensorflow">WasmEdge-tensorflow</a>.</p>
</li>
<li>
<p>The <code>TensorFlow</code> and <code>TensorFlow-Lite</code> extension when installing <code>WasmEdge</code> is required. Please install <code>WasmEdge</code> with the <code>-e tensorflow</code> command.</p>
</li>
<li>
<p>For using this extension, the tag <code>tensorflow</code> when building is required:</p>
<pre><code class="language-bash">go build -tags tensorflow
</code></pre>
</li>
</ul>
</li>
<li>
<p>Tensorflow-Lite</p>
<ul>
<li>
<p>This extension supports the host functions in <a href="https://github.com/second-state/WasmEdge-tensorflow">WasmEdge-tensorflow</a> with only <code>TensorFlow-Lite</code>.</p>
</li>
<li>
<p>The <code>TensorFlow-Lite</code> extension when installing <code>WasmEdge</code> is required. Please install <code>WasmEdge</code> with the <code>-e tensorflow</code> command.</p>
</li>
<li>
<p><strong>THIS TAG CANNOT BE USED WITH THE <code>tensorflow</code> TAG.</strong></p>
</li>
<li>
<p>For using this extension, the tag <code>tensorflow</code> when building is required:</p>
<pre><code class="language-bash">go build -tags tensorflowlite
</code></pre>
</li>
</ul>
</li>
<li>
<p>Image</p>
<ul>
<li>
<p>This extension supports the host functions in <a href="https://github.com/second-state/WasmEdge-image">WasmEdge-image</a>.</p>
</li>
<li>
<p>The <code>Image</code> extension when installing <code>WasmEdge</code> is required. Please install <code>WasmEdge</code> with the <code>-e image</code> command.</p>
</li>
<li>
<p>For using this extension, the tag <code>image</code> when building is required:</p>
<pre><code class="language-bash">go build -tags image
</code></pre>
</li>
</ul>
</li>
</ul>
<p>Users can also turn on the multiple extensions when building:</p>
<pre><code class="language-bash">go build -tags image,tensorflow
</code></pre>
<h3 id="example-repository"><a class="header" href="#example-repository">Example Repository</a></h3>
<p>Developers can refer to <a href="https://github.com/second-state/WasmEdge-go-examples/">the example repository</a> for the WasmEdge-Go examples.</p>
<h2 id="wasmedge-go-basics"><a class="header" href="#wasmedge-go-basics">WasmEdge-go Basics</a></h2>
<p>In this partition, we will introduce the utilities and concepts of WasmEdge-go APIs and data structures.</p>
<h3 id="version-3"><a class="header" href="#version-3">Version</a></h3>
<p>The <code>Version</code> related APIs provide developers to check for the installed WasmEdge shared library version.</p>
<pre><code class="language-go">import &quot;github.com/second-state/WasmEdge-go/wasmedge&quot;

verstr := wasmedge.GetVersion() // Will be `string` of WasmEdge version.
vermajor := wasmedge.GetVersionMajor() // Will be `uint` of WasmEdge major version number.
verminor := wasmedge.GetVersionMinor() // Will be `uint` of WasmEdge minor version number.
verpatch := wasmedge.GetVersionPatch() // Will be `uint` of WasmEdge patch version number.
</code></pre>
<h3 id="logging-settings-3"><a class="header" href="#logging-settings-3">Logging Settings</a></h3>
<p>The <code>wasmedge.SetLogErrorLevel()</code> and <code>wasmedge.SetLogDebugLevel()</code> APIs can set the logging system to debug level or error level. By default, the error level is set, and the debug info is hidden.</p>
<h3 id="value-types-3"><a class="header" href="#value-types-3">Value Types</a></h3>
<p>In WasmEdge-go, the APIs will automatically do the conversion for the built-in types, and implement the data structure for the reference types.</p>
<ol>
<li>
<p>Number types: <code>i32</code>, <code>i64</code>, <code>f32</code>, and <code>f64</code></p>
<ul>
<li>Convert the <code>uint32</code> and <code>int32</code> to <code>i32</code> automatically when passing a value into WASM.</li>
<li>Convert the <code>uint64</code> and <code>int64</code> to <code>i64</code> automatically when passing a value into WASM.</li>
<li>Convert the <code>uint</code> and <code>int</code> to <code>i32</code> automatically when passing a value into WASM in 32-bit system.</li>
<li>Convert the <code>uint</code> and <code>int</code> to <code>i64</code> automatically when passing a value into WASM in 64-bit system.</li>
<li>Convert the <code>float32</code> to <code>f32</code> automatically when passing a value into WASM.</li>
<li>Convert the <code>float64</code> to <code>f64</code> automatically when passing a value into WASM.</li>
<li>Convert the <code>i32</code> from WASM to <code>int32</code> when getting a result.</li>
<li>Convert the <code>i64</code> from WASM to <code>int64</code> when getting a result.</li>
<li>Convert the <code>f32</code> from WASM to <code>float32</code> when getting a result.</li>
<li>Convert the <code>f64</code> from WASM to <code>float64</code> when getting a result.</li>
</ul>
</li>
<li>
<p>Number type: <code>v128</code> for the <code>SIMD</code> proposal</p>
<p>Developers should use the <code>wasmedge.NewV128()</code> to generate a <code>v128</code> value, and use the <code>wasmedge.GetV128()</code> to get the value.</p>
<pre><code class="language-go">val := wasmedge.NewV128(uint64(1234), uint64(5678))
high, low := val.GetVal()
// `high` will be uint64(1234), `low` will be uint64(5678)
</code></pre>
</li>
<li>
<p>Reference types: <code>FuncRef</code> and <code>ExternRef</code> for the <code>Reference-Types</code> proposal</p>
<pre><code class="language-go">var funccxt *wasmedge.Function = ... // Create or get function object.
funcref := wasmedge.NewFuncRef(funccxt)
// Create a `FuncRef` with the function object.

num := 1234
// `num` is a `int`.
externref := wasmedge.NewExternRef(&amp;num)
// Create an `ExternRef` which reference to the `num`.
num = 5678
// Modify the `num` to 5678.
numref := externref.GetRef().(*int)
// Get the original reference from the `ExternRef`.
fmt.Println(*numref)
// Will print `5678`.
numref.Release()
// Should call the `Release` method.
</code></pre>
</li>
</ol>
<h3 id="results-3"><a class="header" href="#results-3">Results</a></h3>
<p>The <code>Result</code> object specifies the execution status. Developers can use the <code>Error()</code> function to get the error message.</p>
<pre><code class="language-go">// Assume that `vm` is a `wasmedge.VM` object.
res, err = vm.Execute(...) // Ignore the detail of parameters.
// Assume that `res, err` are the return values for executing a function with `vm`.
if err != nil {
  fmt.Println(&quot;Error message:&quot;, err.Error())
  category := err.GetErrorCategory()
  // The `category` will be `wasmedge.ErrCategory_WASM`.
}

userdef_err := wasmedge.NewResult(wasmedge.ErrCategory_UserLevel, 123456)
// Generate the user-defined error with code.
code := userdef_err.GetCode()
// The `Code` will be 123456.
</code></pre>
<h3 id="contexts-and-their-life-cycles"><a class="header" href="#contexts-and-their-life-cycles">Contexts And Their Life Cycles</a></h3>
<p>The objects, such as <code>VM</code>, <code>Store</code>, and <code>Function</code>, etc., are composed of <code>Context</code>s in the WasmEdge shared library.
All of the contexts can be created by calling the corresponding <code>New</code> APIs, developers should also call the corresponding <code>Release</code> functions of the contexts to release the resources.
Noticed that it's not necessary to call the <code>Release</code> functions for the contexts which are retrieved from other contexts but not created from the <code>New</code> APIs.</p>
<pre><code class="language-go">// Create a Configure.
conf := wasmedge.NewConfigure()
// Release the `conf` immediately.
conf.Release()
</code></pre>
<p>The details of other contexts will be introduced later.</p>
<h3 id="wasm-data-structures-3"><a class="header" href="#wasm-data-structures-3">WASM Data Structures</a></h3>
<p>The WASM data structures are used for creating instances or can be queried from instance contexts.
The details of instances creation will be introduced in the <a href="sdk/go/ref.html#instances">Instances</a>.</p>
<ol>
<li>
<p>Limit</p>
<p>The <code>Limit</code> struct presents the minimum and maximum value data structure.</p>
<pre><code class="language-go">lim1 := wasmedge.NewLimit(12)
fmt.Println(lim1.HasMax())
// Will print `false`.
fmt.Println(lim1.GetMin())
// Will print `12`.

lim2 := wasmedge.NewLimitWithMax(15, 50)
fmt.Println(lim2.HasMax())
// Will print `true`.
fmt.Println(lim2.GetMin())
// Will print `15`.
fmt.Println(lim2.GetMax())
// Will print `50`.
</code></pre>
<p>For the thread proposal, the <code>Limit</code> struct also supports the shared memory description.</p>
<pre><code class="language-go">lim3 := wasmedge.NewLimitShared(20)
fmt.Println(lim3.HasMax())
// Will print `false`.
fmt.Println(lim3.IsShared())
// Will print `true`.
fmt.Println(lim3.GetMin())
// Will print `20`.

lim4 := wasmedge.NewLimitSharedWithMax(30, 40)
fmt.Println(lim4.HasMax())
// Will print `true`.
fmt.Println(lim4.IsShared())
// Will print `true`.
fmt.Println(lim4.GetMin())
// Will print `30`.
fmt.Println(lim4.GetMax())
// Will print `40`.
</code></pre>
</li>
<li>
<p>Function type context</p>
<p>The <code>FunctionType</code> is an object holds the function type context and used for the <code>Function</code> creation, checking the value types of a <code>Function</code> instance, or getting the function type with function name from VM.
Developers can use the <code>FunctionType</code> APIs to get the parameter or return value types information.</p>
<pre><code class="language-go">functype := wasmedge.NewFunctionType(
  []wasmedge.ValType{
    wasmedge.ValType_ExternRef,
    wasmedge.ValType_I32,
    wasmedge.ValType_I64,
  }, []wasmedge.ValType{
    wasmedge.ValType_F32,
    wasmedge.ValType_F64,
  })

plen := functype.GetParametersLength()
// `plen` will be 3.
rlen := functype.GetReturnsLength()
// `rlen` will be 2.
plist := functype.GetParameters()
// `plist` will be `[]wasmedge.ValType{wasmedge.ValType_ExternRef, wasmedge.ValType_I32, wasmedge.ValType_I64}`.
rlist := functype.GetReturns()
// `rlist` will be `[]wasmedge.ValType{wasmedge.ValType_F32, wasmedge.ValType_F64}`.

functype.Release()
</code></pre>
</li>
<li>
<p>Table type context</p>
<p>The <code>TableType</code> is an object holds the table type context and used for <code>Table</code> instance creation or getting information from <code>Table</code> instances.</p>
<pre><code class="language-go">lim := wasmedge.NewLimit(12)
tabtype := wasmedge.NewTableType(wasmedge.RefType_ExternRef, lim)

rtype := tabtype.GetRefType()
// `rtype` will be `wasmedge.RefType_ExternRef`.
getlim := tabtype.GetLimit()
// `getlim` will be the same value as `lim`.

tabtype.Release()
</code></pre>
</li>
<li>
<p>Memory type context</p>
<p>The <code>MemoryType</code> is an object holds the memory type context and used for <code>Memory</code> instance creation or getting information from <code>Memory</code> instances.</p>
<pre><code class="language-go">lim := wasmedge.NewLimit(1)
memtype := wasmedge.NewMemoryType(lim)

getlim := memtype.GetLimit()
// `getlim` will be the same value as `lim`.

memtype.Release()
</code></pre>
</li>
<li>
<p>Global type context</p>
<p>The <code>GlobalType</code> is an object holds the global type context and used for <code>Global</code> instance creation or getting information from <code>Global</code> instances.</p>
<pre><code class="language-go">globtype := wasmedge.NewGlobalType(wasmedge.ValType_F64, wasmedge.ValMut_Var)

vtype := globtype.GetValType()
// `vtype` will be `wasmedge.ValType_F64`.
vmut := globtype.GetMutability()
// `vmut` will be `wasmedge.ValMut_Var`.

globtype.Release()
</code></pre>
</li>
<li>
<p>Import type context</p>
<p>The <code>ImportType</code> is an object holds the import type context and used for getting the imports information from a <a href="sdk/go/ref.html#ast-module">AST Module</a>.
Developers can get the external type (<code>function</code>, <code>table</code>, <code>memory</code>, or <code>global</code>), import module name, and external name from an <code>ImportType</code> object.
The details about querying <code>ImportType</code> objects will be introduced in the <a href="sdk/go/ref.html#ast-module">AST Module</a>.</p>
<pre><code class="language-go">var ast *wasmedge.AST = ...
// Assume that `ast` is returned by the `Loader` for the result of loading a WASM file.
imptypelist := ast.ListImports()
// Assume that `imptypelist` is an array listed from the `ast` for the imports.

for i, imptype := range imptypelist {
  exttype := imptype.GetExternalType()
  // The `exttype` must be one of `wasmedge.ExternType_Function`, `wasmedge.ExternType_Table`,
  // wasmedge.ExternType_Memory`, or `wasmedge.ExternType_Global`.

  modname := imptype.GetModuleName()
  extname := imptype.GetExternalName()
  // Get the module name and external name of the imports.

  extval := imptype.GetExternalValue()
  // The `extval` is the type of `interface{}` which indicates one of `*wasmedge.FunctionType`,
  // `*wasmedge.TableType`, `*wasmedge.MemoryType`, or `*wasmedge.GlobalType`.
}
</code></pre>
</li>
<li>
<p>Export type context</p>
<p>The <code>ExportType</code> is an object holds the export type context is used for getting the exports information from a <a href="sdk/go/ref.html#ast-module">AST Module</a>.
Developers can get the external type (<code>function</code>, <code>table</code>, <code>memory</code>, or <code>global</code>) and external name from an <code>Export Type</code> context.
The details about querying <code>ExportType</code> objects will be introduced in the <a href="sdk/go/ref.html#ast-module">AST Module</a>.</p>
<pre><code class="language-go">var ast *wasmedge.AST = ...
// Assume that `ast` is returned by the `Loader` for the result of loading a WASM file.
exptypelist := ast.ListExports()
// Assume that `exptypelist` is an array listed from the `ast` for the exports.

for i, exptype := range exptypelist {
  exttype := exptype.GetExternalType()
  // The `exttype` must be one of `wasmedge.ExternType_Function`, `wasmedge.ExternType_Table`,
  // wasmedge.ExternType_Memory`, or `wasmedge.ExternType_Global`.

  extname := exptype.GetExternalName()
  // Get the external name of the exports.

  extval := exptype.GetExternalValue()
  // The `extval` is the type of `interface{}` which indicates one of `*wasmedge.FunctionType`,
  // `*wasmedge.TableType`, `*wasmedge.MemoryType`, or `*wasmedge.GlobalType`.
}
</code></pre>
</li>
</ol>
<h3 id="async-3"><a class="header" href="#async-3">Async</a></h3>
<p>After calling the <a href="sdk/go/ref.html#asynchronous-execution">asynchronous execution APIs</a>, developers will get the <code>wasmedge.Async</code> object.
Developers own the object and should call the <code>(*Async).Release()</code> API to release it.</p>
<ol>
<li>
<p>Get the execution result of the asynchronous execution</p>
<p>Developers can use the <code>(*Async).GetResult()</code> API to block and wait for getting the return values.
This function will block and wait for the execution. If the execution has finished, this function will return immediately. If the execution failed, this function will return an error.</p>
<pre><code class="language-go">async := ... // Ignored. Asynchronous execute a function.

// Blocking and waiting for the execution and get the return values.
res, err := async.GetResult()
async.Release()
</code></pre>
</li>
<li>
<p>Wait for the asynchronous execution with timeout settings</p>
<p>Besides waiting until the end of execution, developers can set the timeout to wait for.</p>
<pre><code class="language-go">async := ... // Ignored. Asynchronous execute a function.

// Blocking and waiting for the execution with the timeout(ms). 
isend := async.WaitFor(1000)
if isend {
  res, err := async.GetResult()
  // ...
} else {
  async.Cancel()
  _, err := async.GetResult()
  // The error message in `err` will be &quot;execution interrupted&quot;.
}
async.Release()
</code></pre>
</li>
</ol>
<h3 id="configurations-3"><a class="header" href="#configurations-3">Configurations</a></h3>
<p>The configuration object, <code>wasmedge.Configure</code>, manages the configurations for <code>Loader</code>, <code>Validator</code>, <code>Executor</code>, <code>VM</code>, and <code>Compiler</code>.
Developers can adjust the settings about the proposals, VM host pre-registrations (such as <code>WASI</code>), and AOT compiler options, and then apply the <code>Configure</code> object to create other runtime objects.</p>
<ol>
<li>
<p>Proposals</p>
<p>WasmEdge supports turning on or off the WebAssembly proposals.
This configuration is effective in any contexts created with the <code>Configure</code> object.</p>
<pre><code class="language-go">const (
  IMPORT_EXPORT_MUT_GLOBALS         = Proposal(C.WasmEdge_Proposal_ImportExportMutGlobals)
  NON_TRAP_FLOAT_TO_INT_CONVERSIONS = Proposal(C.WasmEdge_Proposal_NonTrapFloatToIntConversions)
  SIGN_EXTENSION_OPERATORS          = Proposal(C.WasmEdge_Proposal_SignExtensionOperators)
  MULTI_VALUE                       = Proposal(C.WasmEdge_Proposal_MultiValue)
  BULK_MEMORY_OPERATIONS            = Proposal(C.WasmEdge_Proposal_BulkMemoryOperations)
  REFERENCE_TYPES                   = Proposal(C.WasmEdge_Proposal_ReferenceTypes)
  SIMD                              = Proposal(C.WasmEdge_Proposal_SIMD)
  TAIL_CALL                         = Proposal(C.WasmEdge_Proposal_TailCall)
  ANNOTATIONS                       = Proposal(C.WasmEdge_Proposal_Annotations)
  MEMORY64                          = Proposal(C.WasmEdge_Proposal_Memory64)
  EXCEPTION_HANDLING                = Proposal(C.WasmEdge_Proposal_ExceptionHandling)
  EXTENDED_CONST                    = Proposal(C.WasmEdge_Proposal_ExtendedConst)
  THREADS                           = Proposal(C.WasmEdge_Proposal_Threads)
  FUNCTION_REFERENCES               = Proposal(C.WasmEdge_Proposal_FunctionReferences)
)
</code></pre>
<p>Developers can add or remove the proposals into the <code>Configure</code> object.</p>
<pre><code class="language-go">// By default, the following proposals have turned on initially:
// * IMPORT_EXPORT_MUT_GLOBALS
// * NON_TRAP_FLOAT_TO_INT_CONVERSIONS
// * SIGN_EXTENSION_OPERATORS
// * MULTI_VALUE
// * BULK_MEMORY_OPERATIONS
// * REFERENCE_TYPES
// * SIMD
// For the current WasmEdge version, the following proposals are supported:
// * TAIL_CALL
// * MULTI_MEMORIES
// * THREADS
// * EXTENDED_CONST
conf := wasmedge.NewConfigure()
// Developers can also pass the proposals as parameters:
// conf := wasmedge.NewConfigure(wasmedge.SIMD, wasmedge.BULK_MEMORY_OPERATIONS)
conf.AddConfig(wasmedge.SIMD)
conf.RemoveConfig(wasmedge.REFERENCE_TYPES)
is_bulkmem := conf.HasConfig(wasmedge.BULK_MEMORY_OPERATIONS)
// The `is_bulkmem` will be `true`.
conf.Release()
</code></pre>
</li>
<li>
<p>Host registrations</p>
<p>This configuration is used for the <code>VM</code> context to turn on the <code>WASI</code> or <code>wasmedge_process</code> supports and only effective in <code>VM</code> objects.</p>
<pre><code class="language-go">const (
  WASI                        = HostRegistration(C.WasmEdge_HostRegistration_Wasi)
  WasmEdge_PROCESS            = HostRegistration(C.WasmEdge_HostRegistration_WasmEdge_Process)
  WasiNN                      = HostRegistration(C.WasmEdge_HostRegistration_WasiNN)
  WasiCrypto_Common           = HostRegistration(C.WasmEdge_HostRegistration_WasiCrypto_Common)
  WasiCrypto_AsymmetricCommon = HostRegistration(C.WasmEdge_HostRegistration_WasiCrypto_AsymmetricCommon)
  WasiCrypto_Kx               = HostRegistration(C.WasmEdge_HostRegistration_WasiCrypto_Kx)
  WasiCrypto_Signatures       = HostRegistration(C.WasmEdge_HostRegistration_WasiCrypto_Signatures)
  WasiCrypto_Symmetric        = HostRegistration(C.WasmEdge_HostRegistration_WasiCrypto_Symmetric)
)
</code></pre>
<p>The details will be introduced in the <a href="sdk/go/ref.html#preregistrations">preregistrations of VM context</a>.</p>
<pre><code class="language-go">conf := wasmedge.NewConfigure()
// Developers can also pass the proposals as parameters:
// conf := wasmedge.NewConfigure(wasmedge.WASI)
conf.AddConfig(wasmedge.WASI)
conf.Release()
</code></pre>
</li>
<li>
<p>Maximum memory pages</p>
<p>Developers can limit the page size of memory instances by this configuration.
When growing the page size of memory instances in WASM execution and exceeding the limited size, the page growing will fail.
This configuration is only effective in the <code>Executor</code> and <code>VM</code> objects.</p>
<pre><code class="language-go">conf := wasmedge.NewConfigure()

pagesize := conf.GetMaxMemoryPage()
// By default, the maximum memory page size in each memory instances is 65536.
conf.SetMaxMemoryPage(1234)
pagesize := conf.GetMaxMemoryPage()
// `pagesize` will be 1234.

conf.Release()
</code></pre>
</li>
<li>
<p>AOT compiler options</p>
<p>The AOT compiler options configure the behavior about optimization level, output format, dump IR, and generic binary.</p>
<pre><code class="language-go">const (
  // Disable as many optimizations as possible.
  CompilerOptLevel_O0 = CompilerOptimizationLevel(C.WasmEdge_CompilerOptimizationLevel_O0)
  // Optimize quickly without destroying debuggability.
  CompilerOptLevel_O1 = CompilerOptimizationLevel(C.WasmEdge_CompilerOptimizationLevel_O1)
  // Optimize for fast execution as much as possible without triggering significant incremental compile time or code size growth.
  CompilerOptLevel_O2 = CompilerOptimizationLevel(C.WasmEdge_CompilerOptimizationLevel_O2)
  // Optimize for fast execution as much as possible.
  CompilerOptLevel_O3 = CompilerOptimizationLevel(C.WasmEdge_CompilerOptimizationLevel_O3)
  // Optimize for small code size as much as possible without triggering significant incremental compile time or execution time slowdowns.
  CompilerOptLevel_Os = CompilerOptimizationLevel(C.WasmEdge_CompilerOptimizationLevel_Os)
  // Optimize for small code size as much as possible.
  CompilerOptLevel_Oz = CompilerOptimizationLevel(C.WasmEdge_CompilerOptimizationLevel_Oz)
)

const (
  // Native dynamic library format.
  CompilerOutputFormat_Native = CompilerOutputFormat(C.WasmEdge_CompilerOutputFormat_Native)
  // WebAssembly with AOT compiled codes in custom section.
  CompilerOutputFormat_Wasm = CompilerOutputFormat(C.WasmEdge_CompilerOutputFormat_Wasm)
)
</code></pre>
<p>These configurations are only effective in <code>Compiler</code> contexts.</p>
<pre><code class="language-go">conf := wasmedge.NewConfigure()

// By default, the optimization level is O3.
conf.SetCompilerOptimizationLevel(wasmedge.CompilerOptLevel_O2)
// By default, the output format is universal WASM.
conf.SetCompilerOutputFormat(wasmedge.CompilerOutputFormat_Native)
// By default, the dump IR is `false`.
conf.SetCompilerDumpIR(true)
// By default, the generic binary is `false`.
conf.SetCompilerGenericBinary(true)

conf.Release()
</code></pre>
</li>
<li>
<p>Statistics options</p>
<p>The statistics options configure the behavior about instruction counting, cost measuring, and time measuring in both runtime and AOT compiler.
These configurations are effective in <code>Compiler</code>, <code>VM</code>, and <code>Executor</code> objects.</p>
<pre><code class="language-go">conf := wasmedge.NewConfigure()

// By default, the intruction counting is `false` when running a compiled-WASM or a pure-WASM.
conf.SetStatisticsInstructionCounting(true)
// By default, the cost measurement is `false` when running a compiled-WASM or a pure-WASM.
conf.SetStatisticsTimeMeasuring(true)
// By default, the time measurement is `false` when running a compiled-WASM or a pure-WASM.
conf.SetStatisticsCostMeasuring(true)

conf.Release()
</code></pre>
</li>
</ol>
<h3 id="statistics-3"><a class="header" href="#statistics-3">Statistics</a></h3>
<p>The statistics object, <code>wasmedge.Statistics</code>, provides the instruction counter, cost summation, and cost limitation at runtime.</p>
<p>Before using statistics, the statistics configuration must be set. Otherwise, the return values of calling statistics are undefined behaviour.</p>
<ol>
<li>
<p>Instruction counter</p>
<p>The instruction counter can help developers to profile the performance of WASM running.
Developers can retrieve the <code>Statistics</code> object from the <code>VM</code> object, or create a new one for the <code>Executor</code> creation.
The details will be introduced in the next partitions.</p>
<pre><code class="language-go">stat := wasmedge.NewStatistics()
// ... After running the WASM functions with the `Statistics` object

count := stat.GetInstrCount()
ips := stat.GetInstrPerSecond()
stat.Release()
</code></pre>
</li>
<li>
<p>Cost table</p>
<p>The cost table is to accumulate the cost of instructions with their weights.
Developers can set the cost table array (the indices are the byte code value of instructions, and the values are the cost of instructions) into the <code>Statistics</code> object.
If the cost limit value is set, the execution will return the <code>cost limit exceeded</code> error immediately when exceeds the cost limit in runtime.</p>
<pre><code class="language-c">stat := wasmedge.NewStatistics()

costtable := []uint64{
  0, 0,
  10, /* 0x02: Block */
  11, /* 0x03: Loop */
  12, /* 0x04: If */
  12, /* 0x05: Else */
  0, 0, 0, 0, 0, 0,
  20, /* 0x0C: Br */
  21, /* 0x0D: Br_if */
  22, /* 0x0E: Br_table */
  0,
}
// Developers can set the costs of each instruction. The value not covered will be 0.

WasmEdge_StatisticsSetCostTable(StatCxt, CostTable, 16);
stat.SetCostTable()
stat.SetCostLimit(5000000)

// ... After running the WASM functions with the `Statistics` object
cost := stat.GetTotalCost()
stat.Release()
</code></pre>
</li>
</ol>
<h3 id="tools-driver-2"><a class="header" href="#tools-driver-2">Tools Driver</a></h3>
<p>Besides executing the <code>wasmedge</code> and <code>wasmedgec</code> CLI tools, developers can trigger the WasmEdge CLI tools in WasmEdge-Go.
The API arguments are the same as the command line arguments of the CLI tools.</p>
<pre><code class="language-go">package main

import (
  &quot;os&quot;
  &quot;github.com/second-state/WasmEdge-go/wasmedge&quot;
)

func main() {
  wasmedge.RunWasmEdgeCLI(os.Args)
}
</code></pre>
<pre><code class="language-go">package main

import (
  &quot;os&quot;
  &quot;github.com/second-state/WasmEdge-go/wasmedge&quot;
)

func main() {
  wasmedge.RunWasmEdgeAOTCompilerCLI(os.Args)
}
</code></pre>
<h2 id="wasmedge-vm-3"><a class="header" href="#wasmedge-vm-3">WasmEdge VM</a></h2>
<p>In this partition, we will introduce the functions of <code>wasmedge.VM</code> object and show examples of executing WASM functions.</p>
<h3 id="wasm-execution-example-with-vm-object"><a class="header" href="#wasm-execution-example-with-vm-object">WASM Execution Example With VM Object</a></h3>
<p>The following shows the example of running the WASM for getting the Fibonacci.
This example uses the <a href="https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/examples/wasm/fibonacci.wasm">fibonacci.wasm</a>, and the corresponding WAT file is at <a href="https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/examples/wasm/fibonacci.wat">fibonacci.wat</a>.</p>
<pre><code class="language-wasm">(module
  (export &quot;fib&quot; (func $fib))
  (func $fib (param $n i32) (result i32)
    (if
      (i32.lt_s (get_local $n)(i32.const 2))
      (return (i32.const 1))
    )
    (return
      (i32.add
        (call $fib (i32.sub (get_local $n)(i32.const 2)))
        (call $fib (i32.sub (get_local $n)(i32.const 1)))
      )
    )
  )
)
</code></pre>
<ol>
<li>
<p>Run WASM functions rapidly</p>
<p>Create a new Go project first:</p>
<pre><code class="language-bash">mkdir wasmedge_test &amp;&amp; cd wasmedge_test
go mod init wasmedge_test
</code></pre>
<p>Assume that the WASM file <a href="https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/examples/wasm/fibonacci.wasm"><code>fibonacci.wasm</code></a> is copied into the current <code>wasmedge_test</code> directory, and create and edit the Go file <code>main.go</code> as following:</p>
<pre><code class="language-go">package main

import (
  &quot;fmt&quot;

  &quot;github.com/second-state/WasmEdge-go/wasmedge&quot;
)

func main() {
  // Set the logging level.
  wasmedge.SetLogErrorLevel()

  // Create the configure context and add the WASI support.
  // This step is not necessary unless you need WASI support.
  conf := wasmedge.NewConfigure(wasmedge.WASI)
  // Create VM with the configure.
  vm := wasmedge.NewVMWithConfig(conf)

  res, err := vm.RunWasmFile(&quot;fibonacci.wasm&quot;, &quot;fib&quot;, uint32(21))
  if err == nil {
    fmt.Println(&quot;Get fibonacci[21]:&quot;, res[0].(int32))
  } else {
    fmt.Println(&quot;Run failed:&quot;, err.Error())
  }

  vm.Release()
  conf.Release()
}
</code></pre>
<p>Then you can build and run the Golang application with the WasmEdge Golang SDK: (the 21 Fibonacci number is 17711 in 0-based index)</p>
<pre><code class="language-bash">$ go get github.com/second-state/WasmEdge-go/wasmedge@v0.11.0
$ go build
$ ./wasmedge_test
Get fibonacci[21]: 17711
</code></pre>
</li>
<li>
<p>Instantiate and run WASM functions manually</p>
<p>Besides the above example, developers can run the WASM functions step-by-step with <code>VM</code> object APIs:</p>
<pre><code class="language-go">package main

import (
  &quot;fmt&quot;

  &quot;github.com/second-state/WasmEdge-go/wasmedge&quot;
)

func main() {
  // Set the logging level.
  wasmedge.SetLogErrorLevel()

  // Create VM.
  vm := wasmedge.NewVM()
  var err error
  var res []interface{}

  // Step 1: Load WASM file.
  err = vm.LoadWasmFile(&quot;fibonacci.wasm&quot;)
  if err != nil {
    fmt.Println(&quot;Load WASM from file FAILED:&quot;, err.Error())
    return
  }

  // Step 2: Validate the WASM module.
  err = vm.Validate()
  if err != nil {
    fmt.Println(&quot;Validation FAILED:&quot;, err.Error())
    return
  }

  // Step 3: Instantiate the WASM module.
  err = vm.Instantiate()
  // Developers can load, validate, and instantiate another WASM module
  // to replace the instantiated one. In this case, the old module will
  // be cleared, but the registered modules are still kept.
  if err != nil {
    fmt.Println(&quot;Instantiation FAILED:&quot;, err.Error())
    return
  }

  // Step 4: Execute WASM functions. Parameters: (funcname, args...)
  res, err = vm.Execute(&quot;fib&quot;, uint32(25))
  // Developers can execute functions repeatedly after instantiation.
  if err == nil {
    fmt.Println(&quot;Get fibonacci[25]:&quot;, res[0].(int32))
  } else {
    fmt.Println(&quot;Run failed:&quot;, err.Error())
  }

  vm.Release()
}
</code></pre>
<p>Then you can build and run: (the 25th Fibonacci number is 121393 in 0-based index)</p>
<pre><code class="language-bash">$ go build
$ ./wasmedge_test
Get fibonacci[25]: 121393
</code></pre>
<p>The following graph explains the status of the <code>VM</code> object.</p>
<pre><code class="language-text">                       |========================|
              |-------&gt;|      VM: Initiated     |
              |        |========================|
              |                    |
              |                 LoadWasm
              |                    |
              |                    v
              |        |========================|
              |--------|       VM: Loaded       |&lt;-------|
              |        |========================|        |
              |              |            ^              |
              |         Validate          |              |
          Cleanup            |          LoadWasm         |
              |              v            |            LoadWasm
              |        |========================|        |
              |--------|      VM: Validated     |        |
              |        |========================|        |
              |              |            ^              |
              |      Instantiate          |              |
              |              |          RegisterModule   |
              |              v            |              |
              |        |========================|        |
              |--------|    VM: Instantiated    |--------|
                       |========================|
                             |            ^
                             |            |
                             --------------
                Instantiate, Execute, ExecuteRegistered,
                ExecuteBindgen, ExecuteBindgenRegistered
</code></pre>
<p>The status of the <code>VM</code> context would be <code>Inited</code> when created.
After loading WASM successfully, the status will be <code>Loaded</code>.
After validating WASM successfully, the status will be <code>Validated</code>.
After instantiating WASM successfully, the status will be <code>Instantiated</code>, and developers can invoke functions.
Developers can register WASM or import objects in any status, but they should instantiate WASM again.
Developers can also load WASM in any status, and they should validate and instantiate the WASM module before function invocation.
When in the <code>Instantiated</code> status, developers can instantiate the WASM module again to reset the old WASM runtime structures.</p>
</li>
</ol>
<h3 id="vm-creations-3"><a class="header" href="#vm-creations-3">VM Creations</a></h3>
<p>The <code>VM</code> creation APIs accepts the <code>Configure</code> object and the <code>Store</code> object.
Noticed that if the <code>VM</code> created with the outside <code>Store</code> object, the <code>VM</code> will execute WASM on that <code>Store</code> object. If the <code>Store</code> object is set into multiple <code>VM</code> objects, it may causes data conflict when in execution.
The details of the <code>Store</code> object will be introduced in <a href="sdk/go/ref.html#store">Store</a>.</p>
<pre><code class="language-go">conf := wasmedge.NewConfigure()
store := wasmedge.NewStore()

// Create a VM with default configure and store.
vm := wasmedge.NewVM()
vm.Release()

// Create a VM with the specified configure and default store.
vm = wasmedge.NewVMWithConfig(conf)
vm.Release()

// Create a VM with the default configure and specified store.
vm = wasmedge.NewVMWithStore(store)
vm.Release()

// Create a VM with the specified configure and store.
vm = wasmedge.NewVMWithConfigAndStore(conf, store)
vm.Release()

conf.Release()
store.Release()
</code></pre>
<h3 id="preregistrations-3"><a class="header" href="#preregistrations-3">Preregistrations</a></h3>
<p>WasmEdge provides the following built-in pre-registrations.</p>
<ol>
<li>
<p><a href="https://github.com/WebAssembly/WASI">WASI (WebAssembly System Interface)</a></p>
<p>Developers can turn on the WASI support for VM in the <code>Configure</code> object.</p>
<pre><code class="language-go">conf := wasmedge.NewConfigure(wasmedge.WASI)
// Or you can set the `wasmedge.WASI` into the configure object through `(*Configure).AddConfig`.
vm := wasmedge.NewVMWithConfig(conf)
vm.Release()

// The following API can retrieve the pre-registration import objects from the VM object.
// This API will return `nil` if the corresponding pre-registration is not set into the configuration.
wasiconf := conf.GetImportModule(wasmedge.WASI)
// Initialize the WASI.
wasiconf.InitWasi(/* ... ignored */)

conf.Release()
</code></pre>
<p>And also can create the WASI import object from API. The details will be introduced in the <a href="sdk/go/ref.html#host-functions">Host Functions</a> and the <a href="sdk/go/ref.html#host-module-registrations">Host Module Registrations</a>.</p>
</li>
<li>
<p><a href="https://crates.io/crates/wasmedge_process_interface">WasmEdge_Process</a></p>
<p>This pre-registration is for the process interface for WasmEdge on <code>Rust</code> sources.
After turning on this pre-registration, the VM will support the <code>wasmedge_process</code> plugin.</p>
<pre><code class="language-go">conf := wasmedge.NewConfigure(wasmedge.WasmEdge_PROCESS)
vm := wasmedge.NewVMWithConfig(conf)
vm.Release()

// The following API can retrieve the pre-registration import objects from the VM object.
// This API will return `nil` if the corresponding pre-registration is not set into the configuration.
procconf := conf.GetImportModule(wasmedge.WasmEdge_PROCESS)
// Initialize the WasmEdge_Process.
procconf.InitWasmEdgeProcess(/* ... ignored */)

conf.Release()
</code></pre>
<p>And also can create the WasmEdge_Process import object from API. The details will be introduced in the <a href="sdk/go/ref.html#host-functions">Host Functions</a> and the <a href="sdk/go/ref.html#host-module-registrations">Host Module Registrations</a>.</p>
</li>
<li>
<p><a href="https://github.com/WebAssembly/wasi-nn">WASI-NN proposal</a></p>
<p>Developers can turn on the WASI-NN proposal support for VM in the <code>Configure</code> object.</p>
<blockquote>
<p>Note: Please check that the <a href="sdk/go/../../../write_wasm/rust/wasinn.html">dependencies and prerequests</a> are satisfied.</p>
</blockquote>
<pre><code class="language-go">conf := wasmedge.NewConfigure(wasmedge.WasiNN)
vm := wasmedge.NewVMWithConfig(conf)
vm.Release()

// The following API can retrieve the pre-registration import objects from the VM object.
// This API will return `nil` if the corresponding pre-registration is not set into the configuration.
nnmodule := conf.GetImportModule(wasmedge.WasiNN)
conf.Release()
</code></pre>
<p>And also can create the WASI-NN module instance from API. The details will be introduced in the <a href="sdk/go/ref.html#host-functions">Host Functions</a> and the <a href="sdk/go/ref.html#host-module-registrations">Host Module Registrations</a>.</p>
</li>
<li>
<p><a href="https://github.com/WebAssembly/wasi-crypto">WASI-Crypto proposal</a></p>
<p>Developers can turn on the WASI-Crypto proposal support for VM in the <code>Configure</code> object.</p>
<blockquote>
<p>Note: Please check that the <a href="sdk/go/../../../write_wasm/rust/wasicrypto.html">dependencies and prerequests</a> are satisfied.</p>
</blockquote>
<pre><code class="language-go">conf := wasmedge.NewConfigure(wasmedge.WasiCrypto_Common, wasmedge.WasiCrypto_AsymmetricCommon, wasmedge.WasiCrypto_Kx, wasmedge.WasiCrypto_Signatures, wasmedge.WasiCrypto_Symmetric)
vm := wasmedge.NewVMWithConfig(conf)
vm.Release()

// The following API can retrieve the pre-registration import objects from the VM object.
// This API will return `nil` if the corresponding pre-registration is not set into the configuration.
nnmodule := conf.GetImportModule(wasmedge.WasiCrypto_Common)
conf.Release()
</code></pre>
<p>And also can create the WASI-Crypto module instance from API. The details will be introduced in the <a href="sdk/go/ref.html#host-functions">Host Functions</a> and the <a href="sdk/go/ref.html#host-module-registrations">Host Module Registrations</a>.</p>
</li>
</ol>
<h3 id="host-module-registrations-3"><a class="header" href="#host-module-registrations-3">Host Module Registrations</a></h3>
<p><a href="https://webassembly.github.io/spec/core/exec/runtime.html#syntax-hostfunc">Host functions</a> are functions outside WebAssembly and passed to WASM modules as imports.
In WasmEdge-go, the host functions are composed into host modules as <code>Module</code> objects with module names.
Please refer to the <a href="sdk/go/ref.html#host-functions">Host Functions in WasmEdge Runtime</a> for the details.
In this chapter, we show the example for registering the host modules into a <code>VM</code> object.</p>
<pre><code class="language-go">vm := wasmedge.NewVM()
// You can also create and register the WASI host modules by this API.
wasiobj := wasmedge.NewWasiModule(/* ... ignored ... */)

res := vm.RegisterModule(wasiobj)
// The result status should be checked.

vm.Release()
// The created import objects should be released.
wasiobj.Release()
</code></pre>
<h3 id="wasm-registrations-and-executions-3"><a class="header" href="#wasm-registrations-and-executions-3">WASM Registrations And Executions</a></h3>
<p>In WebAssembly, the instances in WASM modules can be exported and can be imported by other WASM modules.
WasmEdge VM provides APIs for developers to register and export any WASM modules, and execute the functions or host functions in the registered WASM modules.</p>
<ol>
<li>
<p>Register the WASM modules with exported module names</p>
<p>Unless the import objects have already contained the module names, every WASM module should be named uniquely when registering. The following shows the example.</p>
<p>Create a new Go project first:</p>
<pre><code class="language-bash">mkdir wasmedge_test &amp;&amp; cd wasmedge_test
go mod init wasmedge_test
</code></pre>
<p>Assume that the WASM file <a href="https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/examples/wasm/fibonacci.wasm"><code>fibonacci.wasm</code></a> is copied into the current directory.
Then create and edit the Go file <code>main.go</code> as following:</p>
<pre><code class="language-go">package main

import &quot;github.com/second-state/WasmEdge-go/wasmedge&quot;

func main() {
  // Create VM.
  vm := wasmedge.NewVM()

  var err error
  err = vm.RegisterWasmFile(&quot;module_name&quot;, &quot;fibonacci.wasm&quot;)
  // Developers can register the WASM module from `[]byte` with the
  // `(*VM).RegisterWasmBuffer` function, or from `AST` object with
  // the `(*VM).RegisterAST` function.
  // The result status should be checked. The error will occur if the
  // WASM module instantiation failed or the module name conflicts.

  vm.Release()
}
</code></pre>
</li>
<li>
<p>Execute the functions in registered WASM modules</p>
<p>Edit the Go file <code>main.go</code> as following:</p>
<pre><code class="language-go">package main

import (
  &quot;fmt&quot;

  &quot;github.com/second-state/WasmEdge-go/wasmedge&quot;
)

func main() {
  // Create VM.
  vm := wasmedge.NewVM()

  var res []interface{}
  var err error
  // Register the WASM module from file into VM with the module name &quot;mod&quot;.
  err = vm.RegisterWasmFile(&quot;mod&quot;, &quot;fibonacci.wasm&quot;)
  // Developers can register the WASM module from `[]byte` with the
  // `(*VM).RegisterWasmBuffer` function, or from `AST` object with
  // the `(*VM).RegisterAST` function.
  if err != nil {
    fmt.Println(&quot;WASM registration failed:&quot;, err.Error())
    return
  }
  // The function &quot;fib&quot; in the &quot;fibonacci.wasm&quot; was exported with the module
  // name &quot;mod&quot;. As the same as host functions, other modules can import the
  // function `&quot;mod&quot; &quot;fib&quot;`.

  // Execute WASM functions in registered modules.
  // Unlike the execution of functions, the registered functions can be
  // invoked without `(*VM).Instantiate` because the WASM module was
  // instantiated when registering.
  // Developers can also invoke the host functions directly with this API.
  res, err = vm.ExecuteRegistered(&quot;mod&quot;, &quot;fib&quot;, int32(25))
  if err == nil {
    fmt.Println(&quot;Get fibonacci[25]:&quot;, res[0].(int32))
  } else {
    fmt.Println(&quot;Run failed:&quot;, err.Error())
  }

  vm.Release()
}
</code></pre>
<p>Then you can build and run: (the 25th Fibonacci number is 121393 in 0-based index)</p>
<pre><code class="language-bash">$ go get github.com/second-state/WasmEdge-go/wasmedge@v0.11.0
$ go build
$ ./wasmedge_test
Get fibonacci[25]: 121393
</code></pre>
</li>
</ol>
<h3 id="asynchronous-execution-3"><a class="header" href="#asynchronous-execution-3">Asynchronous Execution</a></h3>
<ol>
<li>
<p>Asynchronously run WASM functions rapidly</p>
<p>Assume that a new Go project is created as following:</p>
<pre><code class="language-bash">mkdir wasmedge_test &amp;&amp; cd wasmedge_test
go mod init wasmedge_test
</code></pre>
<p>Then assume that the WASM file <a href="https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/examples/wasm/fibonacci.wasm"><code>fibonacci.wasm</code></a> is copied into the current directory, and create and edit a Go file <code>main.go</code>:</p>
<pre><code class="language-go">package main

import (
  &quot;fmt&quot;

  &quot;github.com/second-state/WasmEdge-go/wasmedge&quot;
)

func main() {
  // Create VM.
  vm := wasmedge.NewVM()

  // Asynchronously run the WASM function from file and get the `wasmedge.Async` object.
  async := vm.AsyncRunWasmFile(&quot;fibonacci.wasm&quot;, &quot;fib&quot;, uint32(20))

  // Block and wait for the execution and get the results.
  res, err := async.GetResult()
  if err == nil {
    fmt.Println(&quot;Get the result:&quot;, res[0].(int32))
  } else {
    fmt.Println(&quot;Error message:&quot;, err.Error())
  }
  async.Release()
  vm.Release()
}
</code></pre>
<p>Then you can build and run: (the 20th Fibonacci number is 10946 in 0-based index)</p>
<pre><code class="language-bash">$ go get github.com/second-state/WasmEdge-go/wasmedge@v0.11.0
$ go build
$ ./wasmedge_test
Get the result: 10946
</code></pre>
</li>
<li>
<p>Instantiate and asynchronously run WASM functions manually</p>
<p>Besides the above example, developers can run the WASM functions step-by-step with <code>VM</code> context APIs:</p>
<pre><code class="language-go">package main

import (
  &quot;fmt&quot;

  &quot;github.com/second-state/WasmEdge-go/wasmedge&quot;
)

func main() {
  var err error
  var res []interface{}

  // Create VM.
  vm := wasmedge.NewVM()

  // Step 1: Load WASM file.
  // Developers can load the WASM binary from buffer with the `(*VM).LoadWasmBuffer()` API,
  // or from `wasmedge.AST` object with the `(*VM).LoadWasmAST()` API.
  err := vm.LoadWasmFile(&quot;fibonacci.wasm&quot;)
  if err != nil {
    fmt.Println(&quot;Load WASM from file FAILED:&quot;, err.Error())
    return
  }

  // Step 2: Validate the WASM module.
  err = vm.Validate()
  if err != nil {
    fmt.Println(&quot;Validation FAILED:&quot;, err.Error())
    return
  }

  // Step 3: Instantiate the WASM module.
  err = vm.Instantiate()
  if err != nil {
    fmt.Println(&quot;Instantiation FAILED:&quot;, err.Error())
    return
  }

  // Step 4: Asynchronously execute the WASM function and get the `wasmedge.Async` object.
  async := vm.AsyncExecute(&quot;fib&quot;, uint32(25))

  // Block and wait for the execution and get the results.
  res, err := async.GetResult()
  if err == nil {
    fmt.Println(&quot;Get the result:&quot;, res[0].(int32))
  } else {
    fmt.Println(&quot;Error message:&quot;, err.Error())
  }
  async.Release()
  vm.Release()
}
</code></pre>
<p>Then you can build and run: (the 25th Fibonacci number is 121393 in 0-based index)</p>
<pre><code class="language-bash">$ go get github.com/second-state/WasmEdge-go/wasmedge@v0.11.0
$ go build
$ ./wasmedge_test
Get the result: 121393
</code></pre>
</li>
</ol>
<h3 id="instance-tracing-3"><a class="header" href="#instance-tracing-3">Instance Tracing</a></h3>
<p>Sometimes the developers may have requirements to get the instances of the WASM runtime.
The <code>VM</code> object supplies the APIs to retrieve the instances.</p>
<ol>
<li>
<p>Store</p>
<p>If the <code>VM</code> object is created without assigning a <code>Store</code> object, the <code>VM</code> context will allocate and own a <code>Store</code>.</p>
<pre><code class="language-go">vm := wasmedge.NewVM()
store := vm.GetStore()
// The object should __NOT__ be deleted by calling `(*Store).Release`.
vm.Release()
</code></pre>
<p>Developers can also create the <code>VM</code> object with a <code>Store</code> object.
In this case, developers should guarantee that the <code>Store</code> object cannot be released before the <code>VM</code> object.
Please refer to the <a href="sdk/go/ref.html#store">Store Objects</a> for the details about the <code>Store</code> APIs.</p>
<pre><code class="language-go">store := wasmedge.NewStore()
vm := wasmedge.NewVMWithStore(store)

storemock := vm.GetStore()
// The internal store context of the `store` and the `storemock` are the same.

vm.Release()
store.Release()
</code></pre>
</li>
<li>
<p>List exported functions</p>
<p>After the WASM module instantiation, developers can use the <code>(*VM).Execute</code> function to invoke the exported WASM functions. For this purpose, developers may need information about the exported WASM function list.
Please refer to the <a href="sdk/go/ref.html#instances">Instances in runtime</a> for the details about the function types.</p>
<p>Assume that a new Go project is created as following:</p>
<pre><code class="language-bash">mkdir wasmedge_test &amp;&amp; cd wasmedge_test
go mod init wasmedge_test
</code></pre>
<p>Then assume that the WASM file <a href="https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/examples/wasm/fibonacci.wasm"><code>fibonacci.wasm</code></a> is copied into the current directory, and create and edit a Go file <code>main.go</code>:</p>
<pre><code class="language-go">package main

import (
  &quot;fmt&quot;

  &quot;github.com/second-state/WasmEdge-go/wasmedge&quot;
)

func main() {
  // Create VM.
  vm := wasmedge.NewVM()

  // Step 1: Load WASM file.
  err := vm.LoadWasmFile(&quot;fibonacci.wasm&quot;)
  if err != nil {
    fmt.Println(&quot;Load WASM from file FAILED:&quot;, err.Error())
    return
  }

  // Step 2: Validate the WASM module.
  err = vm.Validate()
  if err != nil {
    fmt.Println(&quot;Validation FAILED:&quot;, err.Error())
    return
  }

  // Step 3: Instantiate the WASM module.
  err = vm.Instantiate()
  if err != nil {
    fmt.Println(&quot;Instantiation FAILED:&quot;, err.Error())
    return
  }

  // List the exported functions for the names and function types.
  funcnames, functypes := vm.GetFunctionList()
  for _, fname := range funcnames {
    fmt.Println(&quot;Exported function name:&quot;, fname)
  }
  for _, ftype := range functypes {
    // `ftype` is the `FunctionType` object of the same index in the `funcnames` array.
    // Developers should __NOT__ call the `ftype.Release()`.
  }

  vm.Release()
}
</code></pre>
<p>Then you can build and run: (the only exported function in <code>fibonacci.wasm</code> is <code>fib</code>)</p>
<pre><code class="language-bash">$ go get github.com/second-state/WasmEdge-go/wasmedge@v0.11.0
$ go build
$ ./wasmedge_test
Exported function name: fib
</code></pre>
<p>If developers want to get the exported function names in the registered WASM modules, please retrieve the <code>Store</code> object from the <code>VM</code> object and refer to the APIs of <a href="sdk/go/ref.html#store">Store Contexts</a> to list the registered functions by the module name.</p>
</li>
<li>
<p>Get function types</p>
<p>The <code>VM</code> object provides APIs to find the function type by function name.
Please refer to the <a href="sdk/go/ref.html#instances">Instances in runtime</a> for the details about the function types.</p>
<pre><code class="language-go">// Assume that a WASM module is instantiated in `vm` which is a `wasmedge.VM` object.
functype := vm.GetFunctionType(&quot;fib&quot;)
// Developers can get the function types of functions in the registered modules via the 
// `(*VM).GetFunctionTypeRegistered` API with the functon name and the module name.
// If the function is not found, these APIs will return `nil`.
// Developers should __NOT__ call the `(*FunctionType).Release` function of the returned object.
</code></pre>
</li>
<li>
<p>Get the active module</p>
<p>After the WASM module instantiation, an anonymous module is instantiated and owned by the <code>VM</code> object.
Developers may need to retrieve it to get the instances beyond the module.
Then developers can use the <code>(*VM).GetActiveModule()</code> API to get that anonymous module instance.
Please refer to the <a href="sdk/go/ref.html#instances">Module instance</a> for the details about the module instance APIs.</p>
<pre><code class="language-go">// Assume that a WASM module is instantiated in `vm` which is a `wasmedge.VM` object.
mod := vm.GetActiveModule()
// If there's no WASM module instantiated, this API will return `nil`.
// Developers should __NOT__ call the `(*Module).Release` function of the returned module instance.
</code></pre>
</li>
<li>
<p>Get the components</p>
<p>The <code>VM</code> object is composed by the <code>Loader</code>, <code>Validator</code>, and <code>Executor</code> objects.
For the developers who want to use these objects without creating another instances, these APIs can help developers to get them from the <code>VM</code> object.
The get objects are owned by the <code>VM</code> object, and developers should not call their release functions.</p>
<pre><code class="language-go">loader := vm.GetLoader()
// Developers should __NOT__ call the `(*Loader).Release` function of the returned object.
validator := vm.GetValidator()
// Developers should __NOT__ call the `(*Validator).Release` function of the returned object.
executor := vm.GetExecutor()
// Developers should __NOT__ call the `(*Executor).Release` function of the returned object.
</code></pre>
</li>
</ol>
<h2 id="wasmedge-runtime-3"><a class="header" href="#wasmedge-runtime-3">WasmEdge Runtime</a></h2>
<p>In this partition, we will introduce the objects of WasmEdge runtime manually.</p>
<h3 id="wasm-execution-example-step-by-step-3"><a class="header" href="#wasm-execution-example-step-by-step-3">WASM Execution Example Step-By-Step</a></h3>
<p>Besides the WASM execution through the <a href="sdk/go/ref.html#wasmedge-vm"><code>VM</code> object</a> rapidly, developers can execute the WASM functions or instantiate WASM modules step-by-step with the <code>Loader</code>, <code>Validator</code>, <code>Executor</code>, and <code>Store</code> objects.</p>
<p>Assume that a new Go project is created as following:</p>
<pre><code class="language-bash">mkdir wasmedge_test &amp;&amp; cd wasmedge_test
go mod init wasmedge_test
</code></pre>
<p>Then assume that the WASM file <a href="https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/examples/wasm/fibonacci.wasm"><code>fibonacci.wasm</code></a> is copied into the current directory, and create and edit a Go file <code>main.go</code>:</p>
<pre><code class="language-go">package main

import (
  &quot;fmt&quot;

  &quot;github.com/second-state/WasmEdge-go/wasmedge&quot;
)

func main() {
  // Set the logging level to debug to print the statistics info.
  wasmedge.SetLogDebugLevel()
  // Create the configure object. This is not necessary if developers use the default configuration.
  conf := wasmedge.NewConfigure()
  // Turn on the runtime instruction counting and time measuring.
  conf.SetStatisticsInstructionCounting(true)
  conf.SetStatisticsTimeMeasuring(true)
  // Create the statistics object. This is not necessary if the statistics in runtime is not needed.
  stat := wasmedge.NewStatistics()
  // Create the store object. The store object is the WASM runtime structure core.
  store := wasmedge.NewStore()

  var err error
  var res []interface{}
  var ast *wasmedge.AST
  var mod *wasmedge.Module

  // Create the loader object.
  // For loader creation with default configuration, you can use `wasmedge.NewLoader()` instead.
  loader := wasmedge.NewLoaderWithConfig(conf)
  // Create the validator object.
  // For validator creation with default configuration, you can use `wasmedge.NewValidator()` instead.
  validator := wasmedge.NewValidatorWithConfig(conf)
  // Create the executor object.
  // For executor creation with default configuration and without statistics, you can use `wasmedge.NewExecutor()` instead.
  executor := wasmedge.NewExecutorWithConfigAndStatistics(conf, stat)

  // Load the WASM file or the compiled-WASM file and convert into the AST module object.
  ast, err = loader.LoadFile(&quot;fibonacci.wasm&quot;)
  if err != nil {
    fmt.Println(&quot;Load WASM from file FAILED:&quot;, err.Error())
    return
  }
  // Validate the WASM module.
  err = validator.Validate(ast)
  if err != nil {
    fmt.Println(&quot;Validation FAILED:&quot;, err.Error())
    return
  }
  // Instantiate the WASM module and get the output module instance.
  mod, err = executor.Instantiate(store, ast)
  if err != nil {
    fmt.Println(&quot;Instantiation FAILED:&quot;, err.Error())
    return
  }

  // Try to list the exported functions of the instantiated WASM module.
  funcnames := mod.ListFunction()
  for _, fname := range funcnames {
    fmt.Println(&quot;Exported function name:&quot;, fname)
  }

  // Invoke the WASM function.
  funcinst := mod.FindFunction(&quot;fib&quot;)
  if funcinst == nil {
    fmt.Println(&quot;Run FAILED: Function name `fib` not found&quot;)
    return
  }
  res, err = executor.Invoke(store, funcinst, int32(30))
  if err == nil {
    fmt.Println(&quot;Get fibonacci[30]:&quot;, res[0].(int32))
  } else {
    fmt.Println(&quot;Run FAILED:&quot;, err.Error())
  }

  // Resources deallocations.
  conf.Release()
  stat.Release()
  ast.Release()
  loader.Release()
  validator.Release()
  executor.Release()
  store.Release()
  mod.Release()
}
</code></pre>
<p>Then you can build and run: (the 18th Fibonacci number is 1346269 in 30-based index)</p>
<pre><code class="language-bash">$ go get github.com/second-state/WasmEdge-go/wasmedge@v0.11.0
$ go build
$ ./wasmedge_test
Exported function name: fib
[2021-11-24 18:53:01.451] [debug]  Execution succeeded.
[2021-11-24 18:53:01.452] [debug]
 ====================  Statistics  ====================
 Total execution time: 556372295 ns
 Wasm instructions execution time: 556372295 ns
 Host functions execution time: 0 ns
 Executed wasm instructions count: 28271634
 Gas costs: 0
 Instructions per second: 50814237
Get fibonacci[30]: 1346269
</code></pre>
<h3 id="loader-3"><a class="header" href="#loader-3">Loader</a></h3>
<p>The <code>Loader</code> object loads the WASM binary from files or buffers.
Both the WASM and the compiled-WASM from the <a href="sdk/go/ref.html#wasmedge-aot-compiler">WasmEdge AOT Compiler</a> are supported.</p>
<pre><code class="language-go">var buf []byte
// ... Read the WASM code to the `buf`.

// Developers can adjust settings in the configure object.
conf := wasmedge.NewConfigure()
// Create the loader object.
// For loader creation with default configuration, you can use `wasmedge.NewLoader()` instead.
loader := wasmedge.NewLoaderWithConfig(conf)
conf.Release()

// Load WASM or compiled-WASM from the file.
ast, err := loader.LoadFile(&quot;fibonacci.wasm&quot;)
if err != nil {
  fmt.Println(&quot;Load WASM from file FAILED:&quot;, err.Error())
} else {
  // The output AST object should be released.
  ast.Release()
}

// Load WASM or compiled-WASM from the buffer
ast, err = loader.LoadBuffer(buf)
if err != nil {
  fmt.Println(&quot;Load WASM from buffer FAILED:&quot;, err.Error())
} else {
  // The output AST object should be released.
  ast.Release()   
}

loader.Release()
</code></pre>
<h3 id="validator-3"><a class="header" href="#validator-3">Validator</a></h3>
<p>The <code>Validator</code> object can validate the WASM module.
Every WASM module should be validated before instantiation.</p>
<pre><code class="language-go">// ...
// Assume that the `ast` is the output `*wasmedge.AST` object from the loader context.
// Assume that the `conf` is the `*wasmedge.Configure` object.

// Create the validator context.
// For validator creation with default configuration, you can use `wasmedge.NewValidator()` instead.
validator := wasmedge.NewValidatorWithConfig(conf)

err := validator.Validate(ast)
if err != nil {
  fmt.Println(&quot;Validation FAILED:&quot;, err.Error())
}

validator.Release()
</code></pre>
<h3 id="executor-3"><a class="header" href="#executor-3">Executor</a></h3>
<p>The <code>Executor</code> object is the executor for both WASM and compiled-WASM.
This object should work base on the <code>Store</code> object. For the details of the <code>Store</code> object, please refer to the <a href="sdk/go/ref.html#store">next chapter</a>.</p>
<ol>
<li>
<p>Instantiate and register an <code>AST</code> object as a named <code>Module</code> instance</p>
<p>As the same of <a href="sdk/go/ref.html#host-module-registrations">registering host modules</a> or <a href="sdk/go/ref.html#wasm-registrations-and-executions">importing WASM modules</a> in <code>VM</code> objects, developers can instantiate and register an <code>AST</code> objects into the <code>Store</code> context as a named <code>Module</code> instance by the <code>Executor</code> APIs.
After the registration, the result <code>Module</code> instance is exported with the given module name and can be linked when instantiating another module.
For the details about the <code>Module</code> instances APIs, please refer to the <a href="sdk/go/ref.html#instances">Instances</a>.</p>
<pre><code class="language-go">// ...
// Assume that the `ast` is the output `*wasmedge.AST` object from the loader
// and has passed the validation.
// Assume that the `conf` is the `*wasmedge.Configure` object.

// Create the statistics object. This step is not necessary if the statistics
// is not needed.
stat := wasmedge.NewStatistics()
// Create the executor object.
// For executor creation with default configuration and without statistics,
// you can use `wasmedge.NewExecutor()` instead.
executor := wasmedge.NewExecutorWithConfigAndStatistics(conf, stat)
// Create the store object. The store is the WASM runtime structure core.
store := wasmedge.NewStore()

// Register the loaded WASM `ast` into store with the export module name &quot;mod&quot;.
mod, res := executor.Register(store, ast, &quot;mod&quot;)
if err != nil {
  fmt.Println(&quot;WASM registration FAILED:&quot;, err.Error())
  return
}

// ...

// Resources deallocations.
executor.Release()
stat.Release()
store.Release()
mod.Release()
</code></pre>
</li>
<li>
<p>Register an existing <code>Module</code> instance and export the module name</p>
<p>Besides instantiating and registering an <code>AST</code> object, developers can register an existing <code>Module</code> instance into the store with exporting the module name (which is in the <code>Module</code> instance already).
This case occurs when developers create a <code>Module</code> instance for the host functions and want to register it for linking.
For the details about the construction of host functions in <code>Module</code> instances, please refer to the <a href="sdk/go/ref.html#host-functions">Host Functions</a>.</p>
<pre><code class="language-go">// ...
// Assume that the `ast` is the output `*wasmedge.AST` object from the loader
// and has passed the validation.
// Assume that the `conf` is the `*wasmedge.Configure` object.

// Create the statistics object. This step is not necessary if the statistics
// is not needed.
stat := wasmedge.NewStatistics()
// Create the executor object.
// For executor creation with default configuration and without statistics,
// you can use `wasmedge.NewExecutor()` instead.
executor := wasmedge.NewExecutorWithConfigAndStatistics(conf, stat)
// Create the store object. The store is the WASM runtime structure core.
store := wasmedge.NewStore()

// Create a module instance for host functions.
mod := wasmedge.NewModule(&quot;mod&quot;)
// ...
// Create and add the host functions, tables, memories, and globals into the module instance.
// ...

// Register the module instance into store with the exported module name.
// The export module name is in the module instance already.
res := executor.RegisterImport(store, mod)
if err != nil {
  fmt.Println(&quot;WASM registration FAILED:&quot;, err.Error())
  return
}

// ...

// Resources deallocations.
executor.Release()
stat.Release()
store.Release()
mod.Release()
</code></pre>
</li>
<li>
<p>Instantiate an <code>AST</code> object to an anonymous <code>Module</code> instance</p>
<p>WASM or compiled-WASM modules should be instantiated before the function invocation.
Before instantiating a WASM module, please check the <a href="https://webassembly.github.io/spec/core/syntax/modules.html#syntax-import">import section</a> for ensuring the imports are registered into the <code>Store</code> object for linking.</p>
<pre><code class="language-go">// ...
// Assume that the `ast` is the output `*wasmedge.AST` object from the loader
// and has passed the validation.
// Assume that the `conf` is the `*wasmedge.Configure` object.

// Create the statistics object. This step is not necessary if the statistics
// is not needed.
stat := wasmedge.NewStatistics()
// Create the executor object.
// For executor creation with default configuration and without statistics,
// you can use `wasmedge.NewExecutor()` instead.
executor := wasmedge.NewExecutorWithConfigAndStatistics(conf, stat)
// Create the store object. The store is the WASM runtime structure core.
store := wasmedge.NewStore()

// Instantiate the WASM module.
mod, err := executor.Instantiate(stpre, ast)
if err != nil {
  fmt.Println(&quot;WASM instantiation FAILED:&quot;, err.Error())
  return
}

executor.Release()
stat.Release()
store.Release()
mod.Release()
</code></pre>
</li>
<li>
<p>Invoke functions</p>
<p>After registering or instantiating and get the result <code>Module</code> instance, developers can retrieve the exported <code>Function</code> instances from the <code>Module</code> instance for invocation.
For the details about the <code>Module</code> instances APIs, please refer to the <a href="sdk/go/ref.html#instances">Instances</a>.
Please refer to the <a href="sdk/go/ref.html#wasm-execution-example-step-by-step">example above</a> for the <code>Function</code> instance invocation with the <code>(*Executor).Invoke</code> API.</p>
</li>
</ol>
<h3 id="ast-module-3"><a class="header" href="#ast-module-3">AST Module</a></h3>
<p>The <code>AST</code> object presents the loaded structure from a WASM file or buffer. Developer will get this object after loading a WASM file or buffer from <a href="sdk/go/ref.html#loader">Loader</a>.
Before instantiation, developers can also query the imports and exports of an <code>AST</code> object.</p>
<pre><code class="language-go">ast := ...
// Assume that a WASM is loaded into an `*wasmedge.AST` object from loader.

// List the imports.
imports := ast.ListImports()
for _, import := range imports {
  fmt.Println(&quot;Import:&quot;, import.GetModuleName(), import.GetExternalName())
}

// List the exports.
exports := ast.ListExports()
for _, export := range exports {
  fmt.Println(&quot;Export:&quot;, export.GetExternalName())
}

ast.Release()
</code></pre>
<h3 id="store-3"><a class="header" href="#store-3">Store</a></h3>
<p><a href="https://webassembly.github.io/spec/core/exec/runtime.html#store">Store</a> is the runtime structure for the representation of all global state that can be manipulated by WebAssembly programs.
The <code>Store</code> object in WasmEdge is an object to provide the instance exporting and importing when instantiating WASM modules.
Developers can retrieve the named modules from the <code>Store</code> context.</p>
<pre><code class="language-go">store := wasmedge.NewStore()

// ...
// Register a WASM module via the executor object.
// ...

// Try to list the registered WASM modules.
modnames := store.ListModule()
// ...

// Find named module by name.
mod := store.FindModule(&quot;module&quot;)
// If the module with name not found, the `mod` will be `nil`.

store.Release()
</code></pre>
<h3 id="instances-3"><a class="header" href="#instances-3">Instances</a></h3>
<p>The instances are the runtime structures of WASM. Developers can retrieve the <code>Module</code> instances from the <code>Store</code> contexts, and retrieve the other instances from the <code>Module</code> instances.
A single instance can be allocated by its creation function. Developers can construct instances into an <code>Module</code> instance for registration. Please refer to the <a href="sdk/go/ref.html#host-functions">Host Functions</a> for details.
The instances created by their creation functions should be destroyed by developers, EXCEPT they are added into an <code>Module</code> instance.</p>
<ol>
<li>
<p>Module instance</p>
<p>After instantiating or registering an <code>AST</code> object, developers will get a <code>Module</code> instance as the result, and have the responsibility to release it when not in use.
A <code>Module</code> instance can also be created for the host module. Please refer to the <a href="sdk/go/ref.html#host-functions">host function</a> for the details.
<code>Module</code> instance provides APIs to list and find the exported instances in the module.</p>
<pre><code class="language-go">// ...
// Instantiate a WASM module via the executor object and get the `mod` as the output module instance.
// ...

// List the exported instance of the instantiated WASM module.
// Take the function instances for example here.
funcnames := mod.ListFunction()

// Try to find the exported instance of the instantiated WASM module.
// Take the function instances for example here.
funcinst := mod.FindFunction(&quot;fib&quot;)
// `funcinst` will be `nil` if the function not found.
// The returned instance is owned by the module instance and should __NOT__ be released.
</code></pre>
</li>
<li>
<p>Function instance</p>
<p><a href="https://webassembly.github.io/spec/core/exec/runtime.html#syntax-hostfunc">Host functions</a> are functions outside WebAssembly and passed to WASM modules as imports.
In WasmEdge, developers can create the <code>Function</code> objects for host functions and add them into an <code>Module</code> instance for registering into a <code>VM</code> or a <code>Store</code>.
Developers can retrieve the <code>Function Type</code> from the <code>Function</code> objects through the API.
For the details of the <code>Host Function</code> guide, please refer to the <a href="sdk/go/ref.html#host-functions">next chapter</a>.</p>
<pre><code class="language-go">funcobj := ...
// `funcobj` is the `*wasmedge.Function` retrieved from the module instance.
functype := funcobj.GetFunctionType()
// The `funcobj` retrieved from the module instance should __NOT__ be released.
// The `functype` retrieved from the `funcobj` should __NOT__ be released.

// For the function object creation, please refer to the `Host Function` guide.
</code></pre>
</li>
<li>
<p>Table instance</p>
<p>In WasmEdge, developers can create the <code>Table</code> objects and add them into an <code>ImportObject</code> object for registering into a <code>VM</code> or a <code>Store</code>.
The <code>Table</code> objects supply APIs to control the data in table instances.</p>
<pre><code class="language-go">lim := wasmedge.NewLimitWithMax(10, 20)
// Create the table type with limit and the `FuncRef` element type.
tabtype := wasmedge.NewTableType(wasmedge.RefType_FuncRef, lim)
// Create the table instance with table type.
tabinst := wasmedge.NewTable(tabtype)
// Delete the table type.
tabtype.Release()

gottabtype := tabinst.GetTableType()
// The `gottabtype` got from table instance is owned by the `tabinst`
// and should __NOT__ be released.
reftype := gottabtype.GetRefType()
// The `reftype` will be `wasmedge.RefType_FuncRef`.

var gotdata interface{}
data := wasmedge.NewFuncRef(5)
err := tabinst.SetData(data, 3)
// Set the function index 5 to the table[3].

// The following line will get an &quot;out of bounds table access&quot; error
// because the position (13) is out of the table size (10):
//   err = tabinst.SetData(data, 13)

gotdata, err = tabinst.GetData(3)
// Get the FuncRef value of the table[3].

// The following line will get an &quot;out of bounds table access&quot; error
// because the position (13) is out of the table size (10):
//   gotdata, err = tabinst.GetData(13)

tabsize := tabinst.GetSize()
// `tabsize` will be 10.
err = tabinst.Grow(6)
// Grow the table size of 6, the table size will be 16.

// The following line will get an &quot;out of bounds table access&quot; error
// because the size (16 + 6) will reach the table limit (20):
//   err = tabinst.Grow(6)

tabinst.Release()
</code></pre>
</li>
<li>
<p>Memory instance</p>
<p>In WasmEdge, developers can create the <code>Memory</code> objects and add them into an <code>ImportObject</code> object for registering into a <code>VM</code> or a <code>Store</code>.
The <code>Memory</code> objects supply APIs to control the data in memory instances.</p>
<pre><code class="language-go">lim := wasmedge.NewLimitWithMax(1, 5)
// Create the memory type with limit. The memory page size is 64KiB.
memtype := wasmedge.NewMemoryType(lim)
// Create the memory instance with memory type.
meminst := wasmedge.NewMemory(memtype)
// Delete the memory type.
memtype.Release()

data := []byte(&quot;A quick brown fox jumps over the lazy dog&quot;)
err := meminst.SetData(data, 0x1000, 10)
// Set the data[0:9] to the memory[4096:4105].

// The following line will get an &quot;out of bounds memory access&quot; error
// because [65535:65544] is out of 1 page size (65536):
//   err = meminst.SetData(data, 0xFFFF, 10)

var gotdata []byte
gotdata, err = meminst.GetData(0x1000, 10)
// Get the memory[4096:4105]. The `gotdata` will be `[]byte(&quot;A quick br&quot;).
// The following line will get an &quot;out of bounds memory access&quot; error
// because [65535:65544] is out of 1 page size (65536):
//   gotdata, err = meminst.Getdata(0xFFFF, 10)

pagesize := meminst.GetPageSize()
// `pagesize` will be 1.
err = meminst.GrowPage(2)
// Grow the page size of 2, the page size of the memory instance will be 3.

// The following line will get an &quot;out of bounds memory access&quot; error
// because the size (3 + 3) will reach the memory limit (5):
//   err = meminst.GetPageSize(3)

meminst.Release()
</code></pre>
</li>
<li>
<p>Global instance</p>
<p>In WasmEdge, developers can create the <code>Global</code> objects and add them into an <code>ImportObject</code> object for registering into a <code>VM</code> or a <code>Store</code>.
The <code>Global</code> objects supply APIs to control the value in global instances.</p>
<pre><code class="language-go">// Create the global type with value type and mutation.
globtype := wasmedge.NewGlobalType(wasmedge.ValType_I64, wasmedge.ValMut_Var)
// Create the global instance with value and global type.
globinst := wasmedge.NewGlobal(globtype, uint64(1000))
// Delete the global type.
globtype.Release()

gotglobtype := globinst.GetGlobalType()
// The `gotglobtype` got from global instance is owned by the `globinst`
// and should __NOT__ be released.
valtype := gotglobtype.GetValType()
// The `valtype` will be `wasmedge.ValType_I64`.
valmut := gotglobtype.GetMutability()
// The `valmut` will be `wasmedge.ValMut_Var`.

globinst.SetValue(uint64(888))
// Set the value u64(888) to the global.
// This function will do nothing if the value type mismatched or the
// global mutability is `wasmedge.ValMut_Const`.
gotval := globinst.GetValue()
// The `gotbal` will be `interface{}` which the type is `uint64` and
// the value is 888.

globinst.Release()
</code></pre>
</li>
</ol>
<h3 id="host-functions-6"><a class="header" href="#host-functions-6">Host Functions</a></h3>
<p><a href="https://webassembly.github.io/spec/core/exec/runtime.html#syntax-hostfunc">Host functions</a> are functions outside WebAssembly and passed to WASM modules as imports.
In WasmEdge-go, developers can create the <code>Function</code>, <code>Memory</code>, <code>Table</code>, and <code>Global</code> objects and add them into an <code>ImportObject</code> object for registering into a <code>VM</code> or a <code>Store</code>.</p>
<ol>
<li>
<p>Host function allocation</p>
<p>Developers can define Go functions with the following function signature as the host function body:</p>
<pre><code class="language-go">type hostFunctionSignature func(
    data interface{}, callframe *CallingFrame, params []interface{}) ([]interface{}, Result)
</code></pre>
<p>The example of an <code>add</code> host function to add 2 <code>i32</code> values:</p>
<pre><code class="language-go">func host_add(data interface{}, callframe *wasmedge.CallingFrame, params []interface{}) ([]interface{}, wasmedge.Result) {
  // add: i32, i32 -&gt; i32
  res := params[0].(int32) + params[1].(int32)

  // Set the returns
  returns := make([]interface{}, 1)
  returns[0] = res

  // Return
  return returns, wasmedge.Result_Success
}
</code></pre>
<p>Then developers can create <code>Function</code> object with the host function body and function type:</p>
<pre><code class="language-go">// Create a function type: {i32, i32} -&gt; {i32}.
functype := wasmedge.NewFunctionType(
  []wasmedge.ValType{wasmedge.ValType_I32, wasmedge.ValType_I32},
  []wasmedge.ValType{wasmedge.ValType_I32},
)

// Create a function context with the function type and host function body.
// The third parameter is the pointer to the additional data.
// Developers should guarantee the life cycle of the data, and it can be
// `nil` if the external data is not needed.
// The last parameter can be 0 if developers do not need the cost measuring.
func_add := wasmedge.NewFunction(functype, host_add, nil, 0)

// If the function object is not added into an module instance object, it should be released.
func_add.Release()
functype.Release()
</code></pre>
</li>
<li>
<p>Calling frame object</p>
<p>The <code>wasmedge.CallingFrame</code> is the object to provide developers to access the module instance of the <a href="https://webassembly.github.io/spec/core/exec/runtime.html#activations-and-frames">frame on the top of the calling stack</a>.
According to the <a href="https://webassembly.github.io/spec/core/exec/instructions.html#function-calls">WASM spec</a>, a frame with the module instance is pushed into the stack when invoking a function.
Therefore, the host functions can access the module instance of the top frame to retrieve the memory instances to read/write data.</p>
<pre><code class="language-go">import (
  &quot;encoding/binary&quot;
  &quot;fmt&quot;
)

// Host function body definition.
func LoadOffset(data interface{}, callframe *wasmedge.CallingFrame, params []interface{}) ([]interface{}, wasmedge.Result) {
  // Function type: {i32} -&gt; {}
  offset := params[0].(int32)

  // Get the 0th memory instance of the module of the top frame on the stack.
  mem := callframe.GetMemoryByIndex(0)

  data, err := mem.GetData(uint(offset), 4)
  if err != nil {
    return nil, err
  }
  fmt.Println(&quot;u32 at memory[{}]: {}&quot;, offset, binary.LittleEndian.Uint32(data))
  return nil, wasmedge.Result_Success
}
</code></pre>
<p>Besides using the <code>(*CallingFrame).GetMemoryByIndex()</code> API to get the memory instance by index in the module instance, developers can use the <code>(*CallingFrame).GetModule()</code> to get the module instance directly.
Therefore, developers can retrieve the exported contexts by the <code>wasmedge.Module</code> APIs.
And also, developers can use the <code>(*CallingFrame).GetExecutor()</code> API to get the currently used executor context.</p>
</li>
<li>
<p>User-defined error code of the host functions</p>
<p>In host functions, WasmEdge-Go provides <code>wasmedge.Result_Success</code> to return success, <code>wasmedge.Result_Terminate</code> to terminate the WASM execution, and <code>wasmedge.Result_Fail</code> to return fail.
WasmEdge-Go also provides the usage of returning the user-specified codes.
Developers can use the <code>wasmedge.NewResult()</code> API to generate the <code>wasmedge.Result</code> struct with error code, and use the <code>(*result).GetCode()</code> API to get the error code.</p>
<blockquote>
<p>Notice: The error code only supports 24-bit integer (0 ~ 16777216 in <code>uint32</code>). The values larger than 24-bit will be truncated.</p>
</blockquote>
<p>Create a new Go project first:</p>
<pre><code class="language-bash">mkdir wasmedge_test &amp;&amp; cd wasmedge_test
go mod init wasmedge_test
</code></pre>
<p>Assume that a simple WASM from the WAT is as following:</p>
<pre><code class="language-wasm">(module
  (type $t0 (func (param i32)))
  (import &quot;extern&quot; &quot;trap&quot; (func $f-trap (type $t0)))
  (func (export &quot;trap&quot;) (param i32)
    local.get 0
    call $f-trap)
)
</code></pre>
<p>And the <code>main.go</code> is as following:</p>
<pre><code class="language-go">package main

import (
  &quot;fmt&quot;

  &quot;github.com/second-state/WasmEdge-go/wasmedge&quot;
)

// Host function body definition.
func host_trap(data interface{}, callframe *wasmedge.CallingFrame, params []interface{}) ([]interface{}, wasmedge.Result) {
  // add: i32, i32 -&gt; i32
  res := params[0].(int32) + params[1].(int32)

  // Set the returns
  returns := make([]interface{}, 1)
  returns[0] = res

  // Return
  return returns, wasmedge.Result_Success
}

func main() {
  // Create the VM object.
  vm := wasmedge.NewVM()

  // The WASM module buffer.
  wasmbuf := []byte{
    /* WASM header */
    0x00, 0x61, 0x73, 0x6D, 0x01, 0x00, 0x00, 0x00,
    /* Type section */
    0x01, 0x05, 0x01,
    /* function type {i32} -&gt; {} */
    0x60, 0x01, 0x7F, 0x00,
    /* Import section */
    0x02, 0x0F, 0x01,
    /* module name: &quot;extern&quot; */
    0x06, 0x65, 0x78, 0x74, 0x65, 0x72, 0x6E,
    /* extern name: &quot;trap&quot; */
    0x04, 0x74, 0x72, 0x61, 0x70,
    /* import desc: func 0 */
    0x00, 0x00,
    /* Function section */
    0x03, 0x02, 0x01, 0x00,
    /* Export section */
    0x07, 0x08, 0x01,
    /* export name: &quot;trap&quot; */
    0x04, 0x74, 0x72, 0x61, 0x70,
    /* export desc: func 0 */
    0x00, 0x01,
    /* Code section */
    0x0A, 0x08, 0x01,
    /* code body */
    0x06, 0x00, 0x20, 0x00, 0x10, 0x00, 0x0B,
  }

  // Create the module instance with the module name &quot;extern&quot;.
  impmod := wasmedge.NewModule(&quot;extern&quot;)

  // Create and add a function instance into the module instance with export name &quot;func-add&quot;.
  functype := wasmedge.NewFunctionType([]wasmedge.ValType{wasmedge.ValType_I32}, []wasmedge.ValType{})
  hostfunc := wasmedge.NewFunction(functype, host_trap, nil, 0)
  functype.Release()
  impmod.AddFunction(&quot;trap&quot;, hostfunc)

  // Register the module instance into VM.
  vm.RegisterImport(impmod)

  _, err := vm.RunWasmBuffer(wasmbuf, &quot;trap&quot;, uint32(5566))
  if err != nil {
    fmt.Println(&quot;Get the error code:&quot;, err.GetCode())
  }

  impmod.Release()
  vm.Release()
}
</code></pre>
<p>Then you can build and run the Golang application with the WasmEdge Golang SDK:</p>
<pre><code class="language-bash">$ go get github.com/second-state/WasmEdge-go/wasmedge@v0.11.0
$ go build
$ ./wasmedge_test
[2022-08-26 15:06:40.384] [error] user defined failed: user defined error code, Code: 0x15be
[2022-08-26 15:06:40.384] [error]     When executing function name: &quot;trap&quot;
Get the error code: 5566
</code></pre>
</li>
<li>
<p>Construct a module instance with host instances</p>
<p>Besides creating a <code>Module</code> instance by registering or instantiating a WASM module, developers can create a <code>Module</code> instance with a module name and add the <code>Function</code>, <code>Memory</code>, <code>Table</code>, and <code>Global</code> instances into it with their exporting names.</p>
<pre><code class="language-go">// Host function body definition.
func host_add(data interface{}, callframe *wasmedge.CallingFrame, params []interface{}) ([]interface{}, wasmedge.Result) {
  // add: i32, i32 -&gt; i32
  res := params[0].(int32) + params[1].(int32)

  // Set the returns
  returns := make([]interface{}, 1)
  returns[0] = res

  // Return
  return returns, wasmedge.Result_Success
}

// Create a module instance with the module name &quot;module&quot;.
mod := wasmedge.NewModule(&quot;module&quot;)

// Create and add a function instance into the module instance with export name &quot;add&quot;.
functype := wasmedge.NewFunctionType(
  []wasmedge.ValType{wasmedge.ValType_I32, wasmedge.ValType_I32},
  []wasmedge.ValType{wasmedge.ValType_I32},
)
hostfunc := wasmedge.NewFunction(functype, host_add, nil, 0)
functype.Release()
mod.AddFunction(&quot;add&quot;, hostfunc)

// Create and add a table instance into the module instance with export name &quot;table&quot;.
tabtype := wasmedge.NewTableType(wasmedge.RefType_FuncRef ,wasmedge.NewLimitWithMax(10, 20))
hosttab := wasmedge.NewTable(tabtype)
tabtype.Release()
mod.AddTable(&quot;table&quot;, hosttab)

// Create and add a memory instance into the module instance with export name &quot;memory&quot;.
memtype := wasmedge.NewMemoryType(wasmedge.NewLimitWithMax(1, 2))
hostmem := wasmedge.NewMemory(memtype)
memtype.Release()
mod.AddMemory(&quot;memory&quot;, hostmem)

// Create and add a global instance into the module instance with export name &quot;global&quot;.
globtype := wasmedge.NewGlobalType(wasmedge.ValType_I32, wasmedge.ValMut_Var)
hostglob := wasmedge.NewGlobal(globtype, uint32(666))
globtype.Release()
mod.AddGlobal(&quot;global&quot;, hostglob)

// The module instances should be released.
// Developers should __NOT__ release the instances added into the module instance objects.
mod.Release()
</code></pre>
</li>
<li>
<p>Specified module instance</p>
<p><code>wasmedge.NewWasiModule()</code> API can create and initialize the <code>WASI</code> module instance.</p>
<p><code>wasmedge.NewWasiNNModule()</code> API can create and initialize the <code>wasi_ephemeral_nn</code> module instance for <code>WASI-NN</code> plugin.</p>
<p><code>wasmedge.NewWasiCryptoCommonModule()</code> API can create and initialize the <code>wasi_ephemeral_crypto_common</code> module instance for <code>WASI-Crypto</code> plugin.</p>
<p><code>wasmedge.NewWasiCryptoAsymmetricCommonModule()</code> API can create and initialize the <code>wasi_ephemeral_crypto_asymmetric_common</code> module instance for <code>WASI-Crypto</code> plugin.</p>
<p><code>wasmedge.NewWasiCryptoKxModule()</code> API can create and initialize the <code>wasi_ephemeral_crypto_kx</code> module instance for <code>WASI-Crypto</code> plugin.</p>
<p><code>wasmedge.NewWasiCryptoSignaturesModule()</code> API can create and initialize the <code>wasi_ephemeral_crypto_signatures</code> module instance for <code>WASI-Crypto</code> plugin.</p>
<p><code>wasmedge.NewWasiCryptoSymmetricModule()</code> API can create and initialize the <code>wasi_ephemeral_crypto_symmetric</code> module instance for <code>WASI-Crypto</code> plugin.</p>
<p><code>wasmedge.NewWasmEdgeProcessModule()</code> API can create and initialize the <code>wasmedge_process</code> module instance for <code>wasmedge_process</code> plugin.</p>
<p>Developers can create these module instance objects and register them into the <code>Store</code> or <code>VM</code> objects rather than adjust the settings in the <code>Configure</code> objects.</p>
<blockquote>
<p>Note: For the <code>WASI-NN</code> plugin, please check that the <a href="sdk/go/../../write_wasm/rust/wasinn.html#Prerequisites">dependencies and prerequests</a> are satisfied.
Note: For the <code>WASI-Crypto</code> plugin, please check that the <a href="sdk/go/../../write_wasm/rust/wasicrypto.html#Prerequisites">dependencies and prerequests</a> are satisfied. And the 5 modules are recommended to all be created and registered together.</p>
</blockquote>
<pre><code class="language-go">wasiobj := wasmedge.NewWasiModule(
  os.Args[1:],     // The args
  os.Environ(),    // The envs
  []string{&quot;.:.&quot;}, // The mapping preopens
)
procobj := wasmedge.NewWasmEdgeProcessModule(
  []string{&quot;ls&quot;, &quot;echo&quot;}, // The allowed commands
  false,                  // Not to allow all commands
)

// Register the WASI and WasmEdge_Process into the VM object.
vm := wasmedge.NewVM()
vm.RegisterImport(wasiobj)
vm.RegisterImport(procobj)

// ... Execute some WASM functions.

// Get the WASI exit code.
exitcode := wasiobj.WasiGetExitCode()
// The `exitcode` will be 0 if the WASI function &quot;_start&quot; execution has no error.
// Otherwise, it will return with the related exit code.

vm.Release()
// The import objects should be deleted.
wasiobj.Release()
procobj.Release()
</code></pre>
</li>
<li>
<p>Example</p>
<p>Assume that there is a simple WASM from the WAT as following:</p>
<pre><code class="language-wasm">(module
  (type $t0 (func (param i32 i32) (result i32)))
  (import &quot;extern&quot; &quot;func-add&quot; (func $f-add (type $t0)))
  (func (export &quot;addTwo&quot;) (param i32 i32) (result i32)
    local.get 0
    local.get 1
    call $f-add)
)
</code></pre>
<p>Assume that edit the Go file <code>main.go</code> above:</p>
<pre><code class="language-go">package main

import (
  &quot;fmt&quot;

  &quot;github.com/second-state/WasmEdge-go/wasmedge&quot;
)

// Host function body definition.
func host_add(data interface{}, callframe *wasmedge.CallingFrame, params []interface{}) ([]interface{}, wasmedge.Result) {
  // add: i32, i32 -&gt; i32
  res := params[0].(int32) + params[1].(int32)

  // Set the returns
  returns := make([]interface{}, 1)
  returns[0] = res

  // Return
  return returns, wasmedge.Result_Success
}

func main() {
  // Create the VM object.
  vm := wasmedge.NewVM()

  // The WASM module buffer.
  wasmbuf := []byte{
    /* WASM header */
    0x00, 0x61, 0x73, 0x6D, 0x01, 0x00, 0x00, 0x00,
    /* Type section */
    0x01, 0x07, 0x01,
    /* function type {i32, i32} -&gt; {i32} */
    0x60, 0x02, 0x7F, 0x7F, 0x01, 0x7F,
    /* Import section */
    0x02, 0x13, 0x01,
    /* module name: &quot;extern&quot; */
    0x06, 0x65, 0x78, 0x74, 0x65, 0x72, 0x6E,
    /* extern name: &quot;func-add&quot; */
    0x08, 0x66, 0x75, 0x6E, 0x63, 0x2D, 0x61, 0x64, 0x64,
    /* import desc: func 0 */
    0x00, 0x00,
    /* Function section */
    0x03, 0x02, 0x01, 0x00,
    /* Export section */
    0x07, 0x0A, 0x01,
    /* export name: &quot;addTwo&quot; */
    0x06, 0x61, 0x64, 0x64, 0x54, 0x77, 0x6F,
    /* export desc: func 0 */
    0x00, 0x01,
    /* Code section */
    0x0A, 0x0A, 0x01,
    /* code body */
    0x08, 0x00, 0x20, 0x00, 0x20, 0x01, 0x10, 0x00, 0x0B,
  }

  // Create the module instance with the module name &quot;extern&quot;.
  impmod := wasmedge.NewModule(&quot;extern&quot;)

  // Create and add a function instance into the module instance with export name &quot;func-add&quot;.
  functype := wasmedge.NewFunctionType(
    []wasmedge.ValType{wasmedge.ValType_I32, wasmedge.ValType_I32},
    []wasmedge.ValType{wasmedge.ValType_I32},
  )
  hostfunc := wasmedge.NewFunction(functype, host_add, nil, 0)
  functype.Release()
  impmod.AddFunction(&quot;func-add&quot;, hostfunc)

  // Register the module instance into VM.
  vm.RegisterImport(impmod)

  res, err := vm.RunWasmBuffer(wasmbuf, &quot;addTwo&quot;, uint32(1234), uint32(5678))
  if err == nil {
    fmt.Println(&quot;Get the result:&quot;, res[0].(int32))
  } else {
    fmt.Println(&quot;Error message:&quot;, err.Error())
  }

  impmod.Release()
  vm.Release()
}
</code></pre>
<p>Then you can build and run the Golang application with the WasmEdge Golang SDK:</p>
<pre><code class="language-bash">$ go get github.com/second-state/WasmEdge-go/wasmedge@v0.11.0
$ go build
$ ./wasmedge_test
Get the result: 6912
</code></pre>
</li>
<li>
<p>Host Data Example</p>
<p>Developers can set a external data object to the <code>Function</code> object, and access to the object in the function body.
Assume that edit the Go file <code>main.go</code> above:</p>
<pre><code class="language-go">package main

import (
  &quot;fmt&quot;

  &quot;github.com/second-state/WasmEdge-go/wasmedge&quot;
)

// Host function body definition.
func host_add(data interface{}, callframe *wasmedge.CallingFrame, params []interface{}) ([]interface{}, wasmedge.Result) {
  // add: i32, i32 -&gt; i32
  res := params[0].(int32) + params[1].(int32)

  // Set the returns
  returns := make([]interface{}, 1)
  returns[0] = res

  // Also set the result to the data.
  *data.(*int32) = res

  // Return
  return returns, wasmedge.Result_Success
}

func main() {
  // Create the VM object.
  vm := wasmedge.NewVM()

  // The WASM module buffer.
  wasmbuf := []byte{
    /* WASM header */
    0x00, 0x61, 0x73, 0x6D, 0x01, 0x00, 0x00, 0x00,
    /* Type section */
    0x01, 0x07, 0x01,
    /* function type {i32, i32} -&gt; {i32} */
    0x60, 0x02, 0x7F, 0x7F, 0x01, 0x7F,
    /* Import section */
    0x02, 0x13, 0x01,
    /* module name: &quot;extern&quot; */
    0x06, 0x65, 0x78, 0x74, 0x65, 0x72, 0x6E,
    /* extern name: &quot;func-add&quot; */
    0x08, 0x66, 0x75, 0x6E, 0x63, 0x2D, 0x61, 0x64, 0x64,
    /* import desc: func 0 */
    0x00, 0x00,
    /* Function section */
    0x03, 0x02, 0x01, 0x00,
    /* Export section */
    0x07, 0x0A, 0x01,
    /* export name: &quot;addTwo&quot; */
    0x06, 0x61, 0x64, 0x64, 0x54, 0x77, 0x6F,
    /* export desc: func 0 */
    0x00, 0x01,
    /* Code section */
    0x0A, 0x0A, 0x01,
    /* code body */
    0x08, 0x00, 0x20, 0x00, 0x20, 0x01, 0x10, 0x00, 0x0B,
  }

  // The additional data to set into the host function.
  var data int32 = 0

  // Create the module instance with the module name &quot;extern&quot;.
  impmod := wasmedge.NewImportObject(&quot;extern&quot;)

  // Create and add a function instance into the module instance with export name &quot;func-add&quot;.
  functype := wasmedge.NewFunctionType(
    []wasmedge.ValType{wasmedge.ValType_I32, wasmedge.ValType_I32},
    []wasmedge.ValType{wasmedge.ValType_I32},
  )
  hostfunc := wasmedge.NewFunction(functype, host_add, &amp;data, 0)
  functype.Release()
  impmod.AddFunction(&quot;func-add&quot;, hostfunc)

  // Register the module instance into VM.
  vm.RegisterImport(impmod)

  res, err := vm.RunWasmBuffer(wasmbuf, &quot;addTwo&quot;, uint32(1234), uint32(5678))
  if err == nil {
    fmt.Println(&quot;Get the result:&quot;, res[0].(int32))
  } else {
    fmt.Println(&quot;Error message:&quot;, err.Error())
  }
  fmt.Println(&quot;Data value:&quot;, data)

  impmod.Release()
  vm.Release()
}
</code></pre>
<p>Then you can build and run the Golang application with the WasmEdge Golang SDK:</p>
<pre><code class="language-bash">$ go get github.com/second-state/WasmEdge-go/wasmedge@v0.11.0
$ go build
$ ./wasmedge_test
Get the result: 6912
Data value: 6912
</code></pre>
</li>
</ol>
<h2 id="wasmedge-aot-compiler-3"><a class="header" href="#wasmedge-aot-compiler-3">WasmEdge AOT Compiler</a></h2>
<p>In this partition, we will introduce the WasmEdge AOT compiler and the options in Go.
WasmEdge runs the WASM files in interpreter mode, and WasmEdge also supports the AOT (ahead-of-time) mode running without modifying any code.
The WasmEdge AOT (ahead-of-time) compiler compiles the WASM files for running in AOT mode which is much faster than interpreter mode. Developers can compile the WASM files into the compiled-WASM files in shared library format for universal WASM format for the AOT mode execution.</p>
<h3 id="compilation-example-3"><a class="header" href="#compilation-example-3">Compilation Example</a></h3>
<p>The <a href="https://github.com/second-state/WasmEdge-go-examples/tree/master/go_WasmAOT">go_WasmAOT example</a> provide a tool for compiling a WASM file.</p>
<h3 id="compiler-options-3"><a class="header" href="#compiler-options-3">Compiler Options</a></h3>
<p>Developers can set options for AOT compilers such as optimization level and output format:</p>
<pre><code class="language-go">const (
  // Disable as many optimizations as possible.
  CompilerOptLevel_O0 = CompilerOptimizationLevel(C.WasmEdge_CompilerOptimizationLevel_O0)
  // Optimize quickly without destroying debuggability.
  CompilerOptLevel_O1 = CompilerOptimizationLevel(C.WasmEdge_CompilerOptimizationLevel_O1)
  // Optimize for fast execution as much as possible without triggering significant incremental compile time or code size growth.
  CompilerOptLevel_O2 = CompilerOptimizationLevel(C.WasmEdge_CompilerOptimizationLevel_O2)
  // Optimize for fast execution as much as possible.
  CompilerOptLevel_O3 = CompilerOptimizationLevel(C.WasmEdge_CompilerOptimizationLevel_O3)
  // Optimize for small code size as much as possible without triggering significant incremental compile time or execution time slowdowns.
  CompilerOptLevel_Os = CompilerOptimizationLevel(C.WasmEdge_CompilerOptimizationLevel_Os)
  // Optimize for small code size as much as possible.
  CompilerOptLevel_Oz = CompilerOptimizationLevel(C.WasmEdge_CompilerOptimizationLevel_Oz)
)

const (
  // Native dynamic library format.
  CompilerOutputFormat_Native = CompilerOutputFormat(C.WasmEdge_CompilerOutputFormat_Native)
  // WebAssembly with AOT compiled codes in custom section.
  CompilerOutputFormat_Wasm = CompilerOutputFormat(C.WasmEdge_CompilerOutputFormat_Wasm)
)
</code></pre>
<p>Please refer to the <a href="sdk/go/ref.html#configurations">AOT compiler options configuration</a> for details.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="wasmedge-go-v091-api-documentation"><a class="header" href="#wasmedge-go-v091-api-documentation">WasmEdge Go v0.9.1 API Documentation</a></h1>
<p>The followings are the guides to working with the WasmEdge-Go SDK at WasmEdge version <code>0.9.1</code> and WasmEdge-Go version <code>v0.9.2</code>.</p>
<p><strong>Please install WasmEdge 0.9.1 to use this Go package.</strong></p>
<p><strong>WasmEdge-Go v0.9.1 is retracted. Please use WasmEdge-Go v0.9.2 instead.</strong></p>
<p><strong>Developers can refer <a href="sdk/go/0.9.1/upgrade_to_0.10.0.html">here to upgrade to v0.10.0</a>.</strong></p>
<h2 id="table-of-contents-5"><a class="header" href="#table-of-contents-5">Table of Contents</a></h2>
<ul>
<li><a href="sdk/go/0.9.1/ref.html#getting-started">Getting Started</a>
<ul>
<li><a href="sdk/go/0.9.1/ref.html#wasmedge-installation">WasmEdge Installation</a></li>
<li><a href="sdk/go/0.9.1/ref.html#get-wasmedge-go">Get WasmEdge-go</a></li>
<li><a href="sdk/go/0.9.1/ref.html#wasmedge-go-extensions">WasmEdge-go Extensions</a></li>
<li><a href="sdk/go/0.9.1/ref.html#example-of-embedding-a-function-with-wasmedge-bindgen">Example of Embedding A Function with wasmedge-bindgen</a></li>
<li><a href="sdk/go/0.9.1/ref.html#example-of-embedding-a-full-wasi-program">Example of Embedding A Full WASI Program</a></li>
</ul>
</li>
<li><a href="sdk/go/0.9.1/ref.html#wasmedge-go-basics">WasmEdge-go Basics</a>
<ul>
<li><a href="sdk/go/0.9.1/ref.html#version">Version</a></li>
<li><a href="sdk/go/0.9.1/ref.html#logging-settings">Logging Settings</a></li>
<li><a href="sdk/go/0.9.1/ref.html#value-types">Value Types</a></li>
<li><a href="sdk/go/0.9.1/ref.html#results">Results</a></li>
<li><a href="sdk/go/0.9.1/ref.html#contexts-and-their-life-cycles">Contexts And Their Life Cycles</a></li>
<li><a href="sdk/go/0.9.1/ref.html#wasm-data-structures">WASM data structures</a></li>
<li><a href="sdk/go/0.9.1/ref.html#async">Async</a></li>
<li><a href="sdk/go/0.9.1/ref.html#configurations">Configurations</a></li>
<li><a href="sdk/go/0.9.1/ref.html#statistics">Statistics</a></li>
</ul>
</li>
<li><a href="sdk/go/0.9.1/ref.html#wasmedge-vm">WasmEdge VM</a>
<ul>
<li><a href="sdk/go/0.9.1/ref.html#wasm-execution-example-with-vm-object">WASM Execution Example With VM Object</a></li>
<li><a href="sdk/go/0.9.1/ref.html#vm-creations">VM Creations</a></li>
<li><a href="sdk/go/0.9.1/ref.html#preregistrations">Preregistrations</a></li>
<li><a href="sdk/go/0.9.1/ref.html#host-module-registrations">Host Module Registrations</a></li>
<li><a href="sdk/go/0.9.1/ref.html#wasm-registrations-and-executions">WASM Registrations And Executions</a></li>
<li><a href="sdk/go/0.9.1/ref.html#asynchronous-execution">Asynchronous execution</a></li>
<li><a href="sdk/go/0.9.1/ref.html#instance-tracing">Instance Tracing</a></li>
</ul>
</li>
<li><a href="sdk/go/0.9.1/ref.html#wasmedge-runtime">WasmEdge Runtime</a>
<ul>
<li><a href="sdk/go/0.9.1/ref.html#wasm-execution-example-step-by-step">WASM Execution Example Step-By-Step</a></li>
<li><a href="sdk/go/0.9.1/ref.html#loader">Loader</a></li>
<li><a href="sdk/go/0.9.1/ref.html#validator">Validator</a></li>
<li><a href="sdk/go/0.9.1/ref.html#executor">Executor</a></li>
<li><a href="sdk/go/0.9.1/ref.html#ast-module">AST Module</a></li>
<li><a href="sdk/go/0.9.1/ref.html#store">Store</a></li>
<li><a href="sdk/go/0.9.1/ref.html#instances">Instances</a></li>
<li><a href="sdk/go/0.9.1/ref.html#host-functions">Host Functions</a></li>
</ul>
</li>
<li><a href="sdk/go/0.9.1/ref.html#wasmedge-aot-compiler">WasmEdge AOT Compiler</a>
<ul>
<li><a href="sdk/go/0.9.1/ref.html#compilation-example">Compilation Example</a></li>
<li><a href="sdk/go/0.9.1/ref.html#compiler-options">Compiler Options</a></li>
</ul>
</li>
</ul>
<h2 id="getting-started-3"><a class="header" href="#getting-started-3">Getting Started</a></h2>
<p>The WasmEdge-go requires golang version &gt;= 1.15. Please check your golang version before installation. Developers can <a href="https://golang.org/dl/">download golang here</a>.</p>
<pre><code class="language-bash">$ go version
go version go1.16.5 linux/amd64
</code></pre>
<h3 id="wasmedge-installation-4"><a class="header" href="#wasmedge-installation-4">WasmEdge Installation</a></h3>
<p>Developers must <a href="sdk/go/0.9.1/../../../quick_start/install.html">install the WasmEdge shared library</a> with the same <code>WasmEdge-go</code> release or pre-release version.</p>
<pre><code class="language-bash">curl -sSf https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/utils/install.sh | bash -s -- -v 0.9.1
</code></pre>
<p>For the developers need the <code>TensorFlow</code> or <code>Image</code> extension for <code>WasmEdge-go</code>, please install the <code>WasmEdge</code> with extensions:</p>
<pre><code class="language-bash">curl -sSf https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/utils/install.sh | bash -s -- -e tf,image -v 0.9.1
</code></pre>
<p>Noticed that the <code>TensorFlow</code> and <code>Image</code> extensions are only for the <code>Linux</code> platforms.
After installation, developers can use the <code>source</code> command to update the include and linking searching path.</p>
<h3 id="get-wasmedge-go-1"><a class="header" href="#get-wasmedge-go-1">Get WasmEdge-go</a></h3>
<p>After the WasmEdge installation, developers can get the <code>WasmEdge-go</code> package and build it in your Go project directory.</p>
<pre><code class="language-bash">go get github.com/second-state/WasmEdge-go/wasmedge@v0.9.2
go build
</code></pre>
<h3 id="wasmedge-go-extensions-2"><a class="header" href="#wasmedge-go-extensions-2">WasmEdge-go Extensions</a></h3>
<p>By default, the <code>WasmEdge-go</code> only turns on the basic runtime.</p>
<p><code>WasmEdge-go</code> has the following extensions (on the Linux platforms only):</p>
<ul>
<li>
<p>Tensorflow</p>
<ul>
<li>
<p>This extension supports the host functions in <a href="https://github.com/second-state/WasmEdge-tensorflow">WasmEdge-tensorflow</a>.</p>
</li>
<li>
<p>The <code>TensorFlow</code> extension when installing <code>WasmEdge</code> is required. Please install <code>WasmEdge</code> with the <code>-e tensorflow</code> command.</p>
</li>
<li>
<p>For using this extension, the tag <code>tensorflow</code> when building is required:</p>
<pre><code class="language-bash">go build -tags tensorflow
</code></pre>
</li>
</ul>
</li>
<li>
<p>Image</p>
<ul>
<li>
<p>This extension supports the host functions in <a href="https://github.com/second-state/WasmEdge-image">WasmEdge-image</a>.</p>
</li>
<li>
<p>The <code>Image</code> extension when installing <code>WasmEdge</code> is required. Please install <code>WasmEdge</code> with the <code>-e image</code> command.</p>
</li>
<li>
<p>For using this extension, the tag <code>image</code> when building is required:</p>
<pre><code class="language-bash">go build -tags image
</code></pre>
</li>
</ul>
</li>
</ul>
<p>Users can also turn on the multiple extensions when building:</p>
<pre><code class="language-bash">go build -tags image,tensorflow
</code></pre>
<h3 id="example-of-embedding-a-function-with-wasmedge-bindgen"><a class="header" href="#example-of-embedding-a-function-with-wasmedge-bindgen">Example of Embedding A Function with wasmedge-bindgen</a></h3>
<p>In <a href="https://github.com/second-state/WasmEdge-go-examples/tree/master/wasmedge-bindgen/go_BindgenFuncs">this example</a>, we will demonstrate how to call a few simple WebAssembly functions with wasmedge-bindgen from a Golang app. The <a href="https://github.com/second-state/WasmEdge-go-examples/blob/master/wasmedge-bindgen/go_BindgenFuncs/rust_bindgen_funcs/src/lib.rs">functions</a> are written in Rust, and require complex call parameters and return values.</p>
<p>While the WebAssembly only supports a few simple data types out of the box. It <a href="https://medium.com/wasm/strings-in-webassembly-wasm-57a05c1ea333">does not support</a> types such as string and array. In order to pass rich types in Golang to WebAssembly, the compiler needs to convert them to simple integers. For example, it converts a string into an integer memory address and an integer length. The <code>#[wasmedge_bindgen]</code> macro does this conversion automatically, combining it with Golang's <code>wasmedge-bindgen</code> package to auto-generate the correct code to pass call parameters from Golang to WebAssembly.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use wasmedge_bindgen::*;
use wasmedge_bindgen_macro::*;
use num_integer::lcm;
use sha3::{Digest, Sha3_256, Keccak256};
use serde::{Serialize, Deserialize};

#[derive(Serialize, Deserialize, Debug)]
struct Point {
  x: f32,
  y: f32
}

#[derive(Serialize, Deserialize, Debug)]
struct Line {
  points: Vec&lt;Point&gt;,
  valid: bool,
  length: f32,
  desc: String
}

#[wasmedge_bindgen]
pub fn create_line(p1: String, p2: String, desc: String) -&gt; String {
  let point1: Point = serde_json::from_str(p1.as_str()).unwrap();
  let point2: Point = serde_json::from_str(p2.as_str()).unwrap();
  let length = ((point1.x - point2.x) * (point1.x - point2.x) + (point1.y - point2.y) * (point1.y - point2.y)).sqrt();

  let valid = if length == 0.0 { false } else { true };

  let line = Line { points: vec![point1, point2], valid: valid, length: length, desc: desc };

  return serde_json::to_string(&amp;line).unwrap();
}

#[wasmedge_bindgen]
pub fn say(s: String) -&gt; String {
  let r = String::from(&quot;hello &quot;);
  return r + s.as_str();
}

#[wasmedge_bindgen]
pub fn obfusticate(s: String) -&gt; String {
  (&amp;s).chars().map(|c| {
    match c {
      'A' ..= 'M' | 'a' ..= 'm' =&gt; ((c as u8) + 13) as char,
      'N' ..= 'Z' | 'n' ..= 'z' =&gt; ((c as u8) - 13) as char,
      _ =&gt; c
    }
  }).collect()
}

#[wasmedge_bindgen]
pub fn lowest_common_multiple(a: i32, b: i32) -&gt; i32 {
  return lcm(a, b);
}

#[wasmedge_bindgen]
pub fn sha3_digest(v: Vec&lt;u8&gt;) -&gt; Vec&lt;u8&gt; {
  return Sha3_256::digest(&amp;v).as_slice().to_vec();
}

#[wasmedge_bindgen]
pub fn keccak_digest(s: Vec&lt;u8&gt;) -&gt; Vec&lt;u8&gt; {
  return Keccak256::digest(&amp;s).as_slice().to_vec();
}
<span class="boring">}
</span></code></pre></pre>
<p>First, compile the Rust source code into WebAssembly bytecode functions.</p>
<pre><code class="language-bash">rustup target add wasm32-wasi
cd rust_bindgen_funcs
cargo build --target wasm32-wasi --release
# The output WASM will be target/wasm32-wasi/release/rust_bindgen_funcs_lib.wasm
</code></pre>
<p>The <a href="https://github.com/second-state/WasmEdge-go-examples/blob/master/wasmedge-bindgen/go_BindgenFuncs/bindgen_funcs.go">Golang source code</a> to run the WebAssembly function in WasmEdge is as follows. The <code>bg.Execute()</code> function calls the WebAssembly function and passes the parameters with the <code>wasmedge-bindgen</code> supporting.</p>
<pre><code class="language-go">package main

import (
  &quot;fmt&quot;
  &quot;os&quot;

  &quot;github.com/second-state/WasmEdge-go/wasmedge&quot;
  bindgen &quot;github.com/second-state/wasmedge-bindgen/host/go&quot;
)

func main() {
  // Expected Args[0]: program name (./bindgen_funcs)
  // Expected Args[1]: wasm file (rust_bindgen_funcs_lib.wasm))
  
  // Set not to print debug info
  wasmedge.SetLogErrorLevel()

  // Create configure
  var conf = wasmedge.NewConfigure(wasmedge.WASI)

  // Create VM with configure
  var vm = wasmedge.NewVMWithConfig(conf)

  // Init WASI
  var wasi = vm.GetImportObject(wasmedge.WASI)
  wasi.InitWasi(
    os.Args[1:],     // The args
    os.Environ(),    // The envs
    []string{&quot;.:.&quot;}, // The mapping preopens
  )

  // Load and validate the wasm
  vm.LoadWasmFile(os.Args[1])
  vm.Validate()

  // Instantiate the bindgen and vm
  bg := bindgen.Instantiate(vm)

  // create_line: string, string, string -&gt; string (inputs are JSON stringified)  
  res, err := bg.Execute(&quot;create_line&quot;, &quot;{\&quot;x\&quot;:2.5,\&quot;y\&quot;:7.8}&quot;, &quot;{\&quot;x\&quot;:2.5,\&quot;y\&quot;:5.8}&quot;, &quot;A thin red line&quot;)
  if err == nil {
    fmt.Println(&quot;Run bindgen -- create_line:&quot;, res[0].(string))
  } else {
    fmt.Println(&quot;Run bindgen -- create_line FAILED&quot;, err)
  }

  // say: string -&gt; string
  res, err = bg.Execute(&quot;say&quot;, &quot;bindgen funcs test&quot;)
  if err == nil {
    fmt.Println(&quot;Run bindgen -- say:&quot;, res[0].(string))
  } else {
    fmt.Println(&quot;Run bindgen -- say FAILED&quot;)
  }

  // obfusticate: string -&gt; string
  res, err = bg.Execute(&quot;obfusticate&quot;, &quot;A quick brown fox jumps over the lazy dog&quot;)
  if err == nil {
    fmt.Println(&quot;Run bindgen -- obfusticate:&quot;, res[0].(string))
  } else {
    fmt.Println(&quot;Run bindgen -- obfusticate FAILED&quot;)
  }

  // lowest_common_multiple: i32, i32 -&gt; i32
  res, err = bg.Execute(&quot;lowest_common_multiple&quot;, int32(123), int32(2))
  if err == nil {
    fmt.Println(&quot;Run bindgen -- lowest_common_multiple:&quot;, res[0].(int32))
  } else {
    fmt.Println(&quot;Run bindgen -- lowest_common_multiple FAILED&quot;)
  }

  // sha3_digest: array -&gt; array
  res, err = bg.Execute(&quot;sha3_digest&quot;, []byte(&quot;This is an important message&quot;))
  if err == nil {
    fmt.Println(&quot;Run bindgen -- sha3_digest:&quot;, res[0].([]byte))
  } else {
    fmt.Println(&quot;Run bindgen -- sha3_digest FAILED&quot;)
  }

  // keccak_digest: array -&gt; array
  res, err = bg.Execute(&quot;keccak_digest&quot;, []byte(&quot;This is an important message&quot;))
  if err == nil {
    fmt.Println(&quot;Run bindgen -- keccak_digest:&quot;, res[0].([]byte))
  } else {
    fmt.Println(&quot;Run bindgen -- keccak_digest FAILED&quot;)
  }

  bg.Release()
  vm.Release()
  conf.Release()
}
</code></pre>
<p>Next, build the Golang application with the WasmEdge Golang SDK.</p>
<pre><code class="language-bash">go get github.com/second-state/WasmEdge-go/wasmedge@v0.9.2
go get github.com/second-state/wasmedge-bindgen@v0.1.12
go build
</code></pre>
<p>Run the Golang application and it will run the WebAssembly functions embedded in the WasmEdge runtime.</p>
<pre><code class="language-bash">$ ./bindgen_funcs rust_bindgen_funcs/target/wasm32-wasi/release/rust_bindgen_funcs_lib.wasm
Run bindgen -- create_line: {&quot;points&quot;:[{&quot;x&quot;:2.5,&quot;y&quot;:7.8},{&quot;x&quot;:2.5,&quot;y&quot;:5.8}],&quot;valid&quot;:true,&quot;length&quot;:2.0,&quot;desc&quot;:&quot;A thin red line&quot;}
Run bindgen -- say: hello bindgen funcs test
Run bindgen -- obfusticate: N dhvpx oebja sbk whzcf bire gur ynml qbt
Run bindgen -- lowest_common_multiple: 246
Run bindgen -- sha3_digest: [87 27 231 209 189 105 251 49 159 10 211 250 15 159 154 181 43 218 26 141 56 199 25 45 60 10 20 163 54 211 195 203]
Run bindgen -- keccak_digest: [126 194 241 200 151 116 227 33 216 99 159 22 107 3 177 169 216 191 114 156 174 193 32 159 246 228 245 133 52 75 55 27]
</code></pre>
<h3 id="example-of-embedding-a-full-wasi-program"><a class="header" href="#example-of-embedding-a-full-wasi-program">Example of Embedding A Full WASI Program</a></h3>
<p>Note: You can use the latest Rust compiler to create a standalone WasmEdge application with a <code>main.rs</code> functions and then embed it into a Golang application.</p>
<p>Besides functions, the WasmEdge Golang SDK can also <a href="https://github.com/second-state/WasmEdge-go-examples/tree/master/go_ReadFile">embed standalone WebAssembly applications</a> — i.e. a Rust application with a <code>main()</code> function compiled into WebAssembly.</p>
<p>Our <a href="https://github.com/second-state/WasmEdge-go-examples/tree/master/go_ReadFile/rust_readfile">demo Rust application</a> reads from a file.</p>
<pre><pre class="playground"><code class="language-rust">use std::env;
use std::fs::File;
use std::io::{self, BufRead};

fn main() {
  // Get the argv.
  let args: Vec&lt;String&gt; = env::args().collect();
  if args.len() &lt;= 1 {
    println!(&quot;Rust: ERROR - No input file name.&quot;);
    return;
  }

  // Open the file.
  println!(&quot;Rust: Opening input file \&quot;{}\&quot;...&quot;, args[1]);
  let file = match File::open(&amp;args[1]) {
    Err(why) =&gt; {
      println!(&quot;Rust: ERROR - Open file \&quot;{}\&quot; failed: {}&quot;, args[1], why);
      return;
    },
    Ok(file) =&gt; file,
  };

  // Read lines.
  let reader = io::BufReader::new(file);
  let mut texts:Vec&lt;String&gt; = Vec::new();
  for line in reader.lines() {
    if let Ok(text) = line {
      texts.push(text);
    }
  }
  println!(&quot;Rust: Read input file \&quot;{}\&quot; succeeded.&quot;, args[1]);

  // Get stdin to print lines.
  println!(&quot;Rust: Please input the line number to print the line of file.&quot;);
  let stdin = io::stdin();
  for line in stdin.lock().lines() {
    let input = line.unwrap();
    match input.parse::&lt;usize&gt;() {
      Ok(n) =&gt; if n &gt; 0 &amp;&amp; n &lt;= texts.len() {
        println!(&quot;{}&quot;, texts[n - 1]);
      } else {
        println!(&quot;Rust: ERROR - Line \&quot;{}\&quot; is out of range.&quot;, n);
      },
      Err(e) =&gt; println!(&quot;Rust: ERROR - Input \&quot;{}\&quot; is not an integer: {}&quot;, input, e),
    }
  }
  println!(&quot;Rust: Process end.&quot;);
}
</code></pre></pre>
<p>Use the <code>rustwasmc</code> tool to compile the application into WebAssembly.</p>
<pre><code class="language-bash">cd rust_readfile
rustwasmc build
# The output file will be at `pkg/rust_readfile.wasm`.
</code></pre>
<p>Or you can compile the application into WebAssembly directly by <code>cargo</code>:</p>
<pre><code class="language-bash">cd rust_readfile
# Need to add the `wasm32-wasi` target.
rustup target add wasm32-wasi
cargo build --release --target=wasm32-wasi
# The output wasm will be at `target/wasm32-wasi/release/rust_readfile.wasm`.
</code></pre>
<p>The Golang source code to run the WebAssembly function in WasmEdge is as follows.</p>
<pre><code class="language-go">package main

import (
  &quot;os&quot;

  &quot;github.com/second-state/WasmEdge-go/wasmedge&quot;
)

func main() {
  wasmedge.SetLogErrorLevel()

  var conf = wasmedge.NewConfigure(wasmedge.REFERENCE_TYPES)
  conf.AddConfig(wasmedge.WASI)
  var vm = wasmedge.NewVMWithConfig(conf)
  var wasi = vm.GetImportObject(wasmedge.WASI)
  wasi.InitWasi(
    os.Args[1:],     // The args
    os.Environ(),    // The envs
    []string{&quot;.:.&quot;}, // The mapping directories
  )

  // Instantiate and run WASM &quot;_start&quot; function, which refers to the main() function
  vm.RunWasmFile(os.Args[1], &quot;_start&quot;)

  vm.Release()
  conf.Release()
}
</code></pre>
<p>Next, build the Golang application with the WasmEdge Golang SDK.</p>
<pre><code class="language-bash">go get github.com/second-state/WasmEdge-go/wasmedge@v0.9.2
go build
</code></pre>
<p>Run the Golang application.</p>
<pre><code class="language-bash">$ ./read_file rust_readfile/pkg/rust_readfile.wasm file.txt
Rust: Opening input file &quot;file.txt&quot;...
Rust: Read input file &quot;file.txt&quot; succeeded.
Rust: Please input the line number to print the line of file.
# Input &quot;5&quot; and press Enter.
5
# The output will be the 5th line of `file.txt`:
abcDEF___!@#$%^
# To terminate the program, send the EOF (Ctrl + D).
^D
# The output will print the terminate message:
Rust: Process end.
</code></pre>
<p>For more examples, please refer to the <a href="https://github.com/second-state/WasmEdge-go-examples/">example repository</a>.</p>
<h2 id="wasmedge-go-basics-1"><a class="header" href="#wasmedge-go-basics-1">WasmEdge-go Basics</a></h2>
<p>In this partition, we will introduce the utilities and concepts of WasmEdge-go APIs and data structures.</p>
<h3 id="version-4"><a class="header" href="#version-4">Version</a></h3>
<p>The <code>Version</code> related APIs provide developers to check for the installed WasmEdge shared library version.</p>
<pre><code class="language-go">import &quot;github.com/second-state/WasmEdge-go/wasmedge&quot;

verstr := wasmedge.GetVersion() // Will be `string` of WasmEdge version.
vermajor := wasmedge.GetVersionMajor() // Will be `uint` of WasmEdge major version number.
verminor := wasmedge.GetVersionMinor() // Will be `uint` of WasmEdge minor version number.
verpatch := wasmedge.GetVersionPatch() // Will be `uint` of WasmEdge patch version number.
</code></pre>
<h3 id="logging-settings-4"><a class="header" href="#logging-settings-4">Logging Settings</a></h3>
<p>The <code>wasmedge.SetLogErrorLevel()</code> and <code>wasmedge.SetLogDebugLevel()</code> APIs can set the logging system to debug level or error level. By default, the error level is set, and the debug info is hidden.</p>
<h3 id="value-types-4"><a class="header" href="#value-types-4">Value Types</a></h3>
<p>In WasmEdge-go, the APIs will automatically do the conversion for the built-in types, and implement the data structure for the reference types.</p>
<ol>
<li>
<p>Number types: <code>i32</code>, <code>i64</code>, <code>f32</code>, and <code>f64</code></p>
<ul>
<li>Convert the <code>uint32</code> and <code>int32</code> to <code>i32</code> automatically when passing a value into WASM.</li>
<li>Convert the <code>uint64</code> and <code>int64</code> to <code>i64</code> automatically when passing a value into WASM.</li>
<li>Convert the <code>uint</code> and <code>int</code> to <code>i32</code> automatically when passing a value into WASM in 32-bit system.</li>
<li>Convert the <code>uint</code> and <code>int</code> to <code>i64</code> automatically when passing a value into WASM in 64-bit system.</li>
<li>Convert the <code>float32</code> to <code>f32</code> automatically when passing a value into WASM.</li>
<li>Convert the <code>float64</code> to <code>f64</code> automatically when passing a value into WASM.</li>
<li>Convert the <code>i32</code> from WASM to <code>int32</code> when getting a result.</li>
<li>Convert the <code>i64</code> from WASM to <code>int64</code> when getting a result.</li>
<li>Convert the <code>f32</code> from WASM to <code>float32</code> when getting a result.</li>
<li>Convert the <code>f64</code> from WASM to <code>float64</code> when getting a result.</li>
</ul>
</li>
<li>
<p>Number type: <code>v128</code> for the <code>SIMD</code> proposal</p>
<p>Developers should use the <code>wasmedge.NewV128()</code> to generate a <code>v128</code> value, and use the <code>wasmedge.GetV128()</code> to get the value.</p>
<pre><code class="language-go">val := wasmedge.NewV128(uint64(1234), uint64(5678))
high, low := val.GetVal()
// `high` will be uint64(1234), `low` will be uint64(5678)
</code></pre>
</li>
<li>
<p>Reference types: <code>FuncRef</code> and <code>ExternRef</code> for the <code>Reference-Types</code> proposal</p>
<pre><code class="language-go">funcref := wasmedge.NewFuncRef(10)
// Create a `FuncRef` with function index 10.

num := 1234
// `num` is a `int`.
externref := wasmedge.NewExternRef(&amp;num)
// Create an `ExternRef` which reference to the `num`.
num = 5678
// Modify the `num` to 5678.
numref := externref.GetRef().(*int)
// Get the original reference from the `ExternRef`.
fmt.Println(*numref)
// Will print `5678`.
numref.Release()
// Should call the `Release` method.
</code></pre>
</li>
</ol>
<h3 id="results-4"><a class="header" href="#results-4">Results</a></h3>
<p>The <code>Result</code> object specifies the execution status. Developers can use the <code>Error()</code> function to get the error message.</p>
<pre><code class="language-go">// Assume that `vm` is a `wasmedge.VM` object.
res, err = vm.Execute(...) // Ignore the detail of parameters.
// Assume that `res, err` are the return values for executing a function with `vm`.
if err != nil {
  fmt.Println(&quot;Error message:&quot;, err.Error())
}
</code></pre>
<h3 id="contexts-and-their-life-cycles-1"><a class="header" href="#contexts-and-their-life-cycles-1">Contexts And Their Life Cycles</a></h3>
<p>The objects, such as <code>VM</code>, <code>Store</code>, and <code>Function</code>, etc., are composed of <code>Context</code>s in the WasmEdge shared library.
All of the contexts can be created by calling the corresponding <code>New</code> APIs, developers should also call the corresponding <code>Release</code> functions of the contexts to release the resources.
Noticed that it's not necessary to call the <code>Release</code> functions for the contexts which are retrieved from other contexts but not created from the <code>New</code> APIs.</p>
<pre><code class="language-go">// Create a Configure.
conf := wasmedge.NewConfigure()
// Release the `conf` immediately.
conf.Release()
</code></pre>
<p>The details of other contexts will be introduced later.</p>
<h3 id="wasm-data-structures-4"><a class="header" href="#wasm-data-structures-4">WASM Data Structures</a></h3>
<p>The WASM data structures are used for creating instances or can be queried from instance contexts.
The details of instances creation will be introduced in the <a href="sdk/go/0.9.1/ref.html#instances">Instances</a>.</p>
<ol>
<li>
<p>Limit</p>
<p>The <code>Limit</code> struct presents the minimum and maximum value data structure.</p>
<pre><code class="language-go">lim1 := wasmedge.NewLimit(12)
fmt.Println(lim1.HasMax())
// Will print `false`.
fmt.Println(lim1.GetMin())
// Will print `12`.

lim2 := wasmedge.NewLimitWithMax(15, 50)
fmt.Println(lim2.HasMax())
// Will print `true`.
fmt.Println(lim2.GetMin())
// Will print `15`.
fmt.Println(lim2.GetMax())
// Will print `50`.
</code></pre>
</li>
<li>
<p>Function type context</p>
<p>The <code>FunctionType</code> is an object holds the function type context and used for the <code>Function</code> creation, checking the value types of a <code>Function</code> instance, or getting the function type with function name from VM.
Developers can use the <code>FunctionType</code> APIs to get the parameter or return value types information.</p>
<pre><code class="language-go">functype := wasmedge.NewFunctionType(
  []wasmedge.ValType{
    wasmedge.ValType_ExternRef,
    wasmedge.ValType_I32,
    wasmedge.ValType_I64,
  }, []wasmedge.ValType{
    wasmedge.ValType_F32,
    wasmedge.ValType_F64,
  })

plen := functype.GetParametersLength()
// `plen` will be 3.
rlen := functype.GetReturnsLength()
// `rlen` will be 2.
plist := functype.GetParameters()
// `plist` will be `[]wasmedge.ValType{wasmedge.ValType_ExternRef, wasmedge.ValType_I32, wasmedge.ValType_I64}`.
rlist := functype.GetReturns()
// `rlist` will be `[]wasmedge.ValType{wasmedge.ValType_F32, wasmedge.ValType_F64}`.

functype.Release()
</code></pre>
</li>
<li>
<p>Table type context</p>
<p>The <code>TableType</code> is an object holds the table type context and used for <code>Table</code> instance creation or getting information from <code>Table</code> instances.</p>
<pre><code class="language-go">lim := wasmedge.NewLimit(12)
tabtype := wasmedge.NewTableType(wasmedge.RefType_ExternRef, lim)

rtype := tabtype.GetRefType()
// `rtype` will be `wasmedge.RefType_ExternRef`.
getlim := tabtype.GetLimit()
// `getlim` will be the same value as `lim`.

tabtype.Release()
</code></pre>
</li>
<li>
<p>Memory type context</p>
<p>The <code>MemoryType</code> is an object holds the memory type context and used for <code>Memory</code> instance creation or getting information from <code>Memory</code> instances.</p>
<pre><code class="language-go">lim := wasmedge.NewLimit(1)
memtype := wasmedge.NewMemoryType(lim)

getlim := memtype.GetLimit()
// `getlim` will be the same value as `lim`.

memtype.Release()
</code></pre>
</li>
<li>
<p>Global type context</p>
<p>The <code>GlobalType</code> is an object holds the global type context and used for <code>Global</code> instance creation or getting information from <code>Global</code> instances.</p>
<pre><code class="language-go">globtype := wasmedge.NewGlobalType(wasmedge.ValType_F64, wasmedge.ValMut_Var)

vtype := globtype.GetValType()
// `vtype` will be `wasmedge.ValType_F64`.
vmut := globtype.GetMutability()
// `vmut` will be `wasmedge.ValMut_Var`.

globtype.Release()
</code></pre>
</li>
<li>
<p>Import type context</p>
<p>The <code>ImportType</code> is an object holds the import type context and used for getting the imports information from a <a href="sdk/go/0.9.1/ref.html#ast-module">AST Module</a>.
Developers can get the external type (<code>function</code>, <code>table</code>, <code>memory</code>, or <code>global</code>), import module name, and external name from an <code>ImportType</code> object.
The details about querying <code>ImportType</code> objects will be introduced in the <a href="sdk/go/0.9.1/ref.html#ast-module">AST Module</a>.</p>
<pre><code class="language-go">var ast *wasmedge.AST = ...
// Assume that `ast` is returned by the `Loader` for the result of loading a WASM file.
imptypelist := ast.ListImports()
// Assume that `imptypelist` is an array listed from the `ast` for the imports.

for i, imptype := range imptypelist {
  exttype := imptype.GetExternalType()
  // The `exttype` must be one of `wasmedge.ExternType_Function`, `wasmedge.ExternType_Table`,
  // wasmedge.ExternType_Memory`, or `wasmedge.ExternType_Global`.

  modname := imptype.GetModuleName()
  extname := imptype.GetExternalName()
  // Get the module name and external name of the imports.

  extval := imptype.GetExternalValue()
  // The `extval` is the type of `interface{}` which indicates one of `*wasmedge.FunctionType`,
  // `*wasmedge.TableType`, `*wasmedge.MemoryType`, or `*wasmedge.GlobalType`.
}
</code></pre>
</li>
<li>
<p>Export type context</p>
<p>The <code>ExportType</code> is an object holds the export type context is used for getting the exports information from a <a href="sdk/go/0.9.1/ref.html#ast-module">AST Module</a>.
Developers can get the external type (<code>function</code>, <code>table</code>, <code>memory</code>, or <code>global</code>) and external name from an <code>Export Type</code> context.
The details about querying <code>ExportType</code> objects will be introduced in the <a href="sdk/go/0.9.1/ref.html#ast-module">AST Module</a>.</p>
<pre><code class="language-go">var ast *wasmedge.AST = ...
// Assume that `ast` is returned by the `Loader` for the result of loading a WASM file.
exptypelist := ast.ListExports()
// Assume that `exptypelist` is an array listed from the `ast` for the exports.

for i, exptype := range exptypelist {
  exttype := exptype.GetExternalType()
  // The `exttype` must be one of `wasmedge.ExternType_Function`, `wasmedge.ExternType_Table`,
  // wasmedge.ExternType_Memory`, or `wasmedge.ExternType_Global`.

  extname := exptype.GetExternalName()
  // Get the external name of the exports.

  extval := exptype.GetExternalValue()
  // The `extval` is the type of `interface{}` which indicates one of `*wasmedge.FunctionType`,
  // `*wasmedge.TableType`, `*wasmedge.MemoryType`, or `*wasmedge.GlobalType`.
}
</code></pre>
</li>
</ol>
<h3 id="async-4"><a class="header" href="#async-4">Async</a></h3>
<p>After calling the <a href="sdk/go/0.9.1/ref.html#asynchronous-execution">asynchronous execution APIs</a>, developers will get the <code>wasmedge.Async</code> object.
Developers own the object and should call the <code>(*Async).Release()</code> API to release it.</p>
<ol>
<li>
<p>Get the execution result of the asynchronous execution</p>
<p>Developers can use the <code>(*Async).GetResult()</code> API to block and wait for getting the return values.
This function will block and wait for the execution. If the execution has finished, this function will return immediately. If the execution failed, this function will return an error.</p>
<pre><code class="language-go">async := ... // Ignored. Asynchronous execute a function.

// Blocking and waiting for the execution and get the return values.
res, err := async.GetResult()
async.Release()
</code></pre>
</li>
<li>
<p>Wait for the asynchronous execution with timeout settings</p>
<p>Besides waiting until the end of execution, developers can set the timeout to wait for.</p>
<pre><code class="language-go">async := ... // Ignored. Asynchronous execute a function.

// Blocking and waiting for the execution with the timeout(ms). 
isend := async.WaitFor(1000)
if isend {
  res, err := async.GetResult()
  // ...
} else {
  async.Cancel()
  _, err := async.GetResult()
  // The error message in `err` will be &quot;execution interrupted&quot;.
}
async.Release()
</code></pre>
</li>
</ol>
<h3 id="configurations-4"><a class="header" href="#configurations-4">Configurations</a></h3>
<p>The configuration object, <code>wasmedge.Configure</code>, manages the configurations for <code>Loader</code>, <code>Validator</code>, <code>Executor</code>, <code>VM</code>, and <code>Compiler</code>.
Developers can adjust the settings about the proposals, VM host pre-registrations (such as <code>WASI</code>), and AOT compiler options, and then apply the <code>Configure</code> object to create other runtime objects.</p>
<ol>
<li>
<p>Proposals</p>
<p>WasmEdge supports turning on or off the WebAssembly proposals.
This configuration is effective in any contexts created with the <code>Configure</code> object.</p>
<pre><code class="language-go">const (
  IMPORT_EXPORT_MUT_GLOBALS         = Proposal(C.WasmEdge_Proposal_ImportExportMutGlobals)
  NON_TRAP_FLOAT_TO_INT_CONVERSIONS = Proposal(C.WasmEdge_Proposal_NonTrapFloatToIntConversions)
  SIGN_EXTENSION_OPERATORS          = Proposal(C.WasmEdge_Proposal_SignExtensionOperators)
  MULTI_VALUE                       = Proposal(C.WasmEdge_Proposal_MultiValue)
  BULK_MEMORY_OPERATIONS            = Proposal(C.WasmEdge_Proposal_BulkMemoryOperations)
  REFERENCE_TYPES                   = Proposal(C.WasmEdge_Proposal_ReferenceTypes)
  SIMD                              = Proposal(C.WasmEdge_Proposal_SIMD)
  TAIL_CALL                         = Proposal(C.WasmEdge_Proposal_TailCall)
  ANNOTATIONS                       = Proposal(C.WasmEdge_Proposal_Annotations)
  MEMORY64                          = Proposal(C.WasmEdge_Proposal_Memory64)
  THREADS                           = Proposal(C.WasmEdge_Proposal_Threads)
  EXCEPTION_HANDLING                = Proposal(C.WasmEdge_Proposal_ExceptionHandling)
  FUNCTION_REFERENCES               = Proposal(C.WasmEdge_Proposal_FunctionReferences)
)
</code></pre>
<p>Developers can add or remove the proposals into the <code>Configure</code> object.</p>
<pre><code class="language-go">// By default, the following proposals have turned on initially:
// * IMPORT_EXPORT_MUT_GLOBALS
// * NON_TRAP_FLOAT_TO_INT_CONVERSIONS
// * SIGN_EXTENSION_OPERATORS
// * MULTI_VALUE
// * BULK_MEMORY_OPERATIONS
// * REFERENCE_TYPES
// * SIMD
conf := wasmedge.NewConfigure()
// Developers can also pass the proposals as parameters:
// conf := wasmedge.NewConfigure(wasmedge.SIMD, wasmedge.BULK_MEMORY_OPERATIONS)
conf.AddConfig(wasmedge.SIMD)
conf.RemoveConfig(wasmedge.REFERENCE_TYPES)
is_bulkmem := conf.HasConfig(wasmedge.BULK_MEMORY_OPERATIONS)
// The `is_bulkmem` will be `true`.
conf.Release()
</code></pre>
</li>
<li>
<p>Host registrations</p>
<p>This configuration is used for the <code>VM</code> context to turn on the <code>WASI</code> or <code>wasmedge_process</code> supports and only effective in <code>VM</code> objects.</p>
<pre><code class="language-go">const (
  WASI             = HostRegistration(C.WasmEdge_HostRegistration_Wasi)
  WasmEdge_PROCESS = HostRegistration(C.WasmEdge_HostRegistration_WasmEdge_Process)
)
</code></pre>
<p>The details will be introduced in the <a href="sdk/go/0.9.1/ref.html#preregistrations">preregistrations of VM context</a>.</p>
<pre><code class="language-go">conf := wasmedge.NewConfigure()
// Developers can also pass the proposals as parameters:
// conf := wasmedge.NewConfigure(wasmedge.WASI)
conf.AddConfig(wasmedge.WASI)
conf.Release()
</code></pre>
</li>
<li>
<p>Maximum memory pages</p>
<p>Developers can limit the page size of memory instances by this configuration.
When growing the page size of memory instances in WASM execution and exceeding the limited size, the page growing will fail.
This configuration is only effective in the <code>Executor</code> and <code>VM</code> objects.</p>
<pre><code class="language-go">conf := wasmedge.NewConfigure()

pagesize := conf.GetMaxMemoryPage()
// By default, the maximum memory page size in each memory instances is 65536.
conf.SetMaxMemoryPage(1234)
pagesize := conf.GetMaxMemoryPage()
// `pagesize` will be 1234.

conf.Release()
</code></pre>
</li>
<li>
<p>AOT compiler options</p>
<p>The AOT compiler options configure the behavior about optimization level, output format, dump IR, and generic binary.</p>
<pre><code class="language-go">const (
  // Disable as many optimizations as possible.
  CompilerOptLevel_O0 = CompilerOptimizationLevel(C.WasmEdge_CompilerOptimizationLevel_O0)
  // Optimize quickly without destroying debuggability.
  CompilerOptLevel_O1 = CompilerOptimizationLevel(C.WasmEdge_CompilerOptimizationLevel_O1)
  // Optimize for fast execution as much as possible without triggering significant incremental compile time or code size growth.
  CompilerOptLevel_O2 = CompilerOptimizationLevel(C.WasmEdge_CompilerOptimizationLevel_O2)
  // Optimize for fast execution as much as possible.
  CompilerOptLevel_O3 = CompilerOptimizationLevel(C.WasmEdge_CompilerOptimizationLevel_O3)
  // Optimize for small code size as much as possible without triggering significant incremental compile time or execution time slowdowns.
  CompilerOptLevel_Os = CompilerOptimizationLevel(C.WasmEdge_CompilerOptimizationLevel_Os)
  // Optimize for small code size as much as possible.
  CompilerOptLevel_Oz = CompilerOptimizationLevel(C.WasmEdge_CompilerOptimizationLevel_Oz)
)

const (
  // Native dynamic library format.
  CompilerOutputFormat_Native = CompilerOutputFormat(C.WasmEdge_CompilerOutputFormat_Native)
  // WebAssembly with AOT compiled codes in custom section.
  CompilerOutputFormat_Wasm = CompilerOutputFormat(C.WasmEdge_CompilerOutputFormat_Wasm)
)
</code></pre>
<p>These configurations are only effective in <code>Compiler</code> contexts.</p>
<pre><code class="language-go">conf := wasmedge.NewConfigure()

// By default, the optimization level is O3.
conf.SetCompilerOptimizationLevel(wasmedge.CompilerOptLevel_O2)
// By default, the output format is universal WASM.
conf.SetCompilerOutputFormat(wasmedge.CompilerOutputFormat_Native)
// By default, the dump IR is `false`.
conf.SetCompilerDumpIR(true)
// By default, the generic binary is `false`.
conf.SetCompilerGenericBinary(true)

conf.Release()
</code></pre>
</li>
<li>
<p>Statistics options</p>
<p>The statistics options configure the behavior about instruction counting, cost measuring, and time measuring in both runtime and AOT compiler.
These configurations are effective in <code>Compiler</code>, <code>VM</code>, and <code>Executor</code> objects.</p>
<pre><code class="language-go">conf := wasmedge.NewConfigure()

// By default, the intruction counting is `false` when running a compiled-WASM or a pure-WASM.
conf.SetStatisticsInstructionCounting(true)
// By default, the cost measurement is `false` when running a compiled-WASM or a pure-WASM.
conf.SetStatisticsTimeMeasuring(true)
// By default, the time measurement is `false` when running a compiled-WASM or a pure-WASM.
conf.SetStatisticsCostMeasuring(true)

conf.Release()
</code></pre>
</li>
</ol>
<h3 id="statistics-4"><a class="header" href="#statistics-4">Statistics</a></h3>
<p>The statistics object, <code>wasmedge.Statistics</code>, provides the instruction counter, cost summation, and cost limitation at runtime.</p>
<p>Before using statistics, the statistics configuration must be set. Otherwise, the return values of calling statistics are undefined behaviour.</p>
<ol>
<li>
<p>Instruction counter</p>
<p>The instruction counter can help developers to profile the performance of WASM running.
Developers can retrieve the <code>Statistics</code> object from the <code>VM</code> object, or create a new one for the <code>Executor</code> creation.
The details will be introduced in the next partitions.</p>
<pre><code class="language-go">stat := wasmedge.NewStatistics()
// ... After running the WASM functions with the `Statistics` object

count := stat.GetInstrCount()
ips := stat.GetInstrPerSecond()
stat.Release()
</code></pre>
</li>
<li>
<p>Cost table</p>
<p>The cost table is to accumulate the cost of instructions with their weights.
Developers can set the cost table array (the indices are the byte code value of instructions, and the values are the cost of instructions) into the <code>Statistics</code> object.
If the cost limit value is set, the execution will return the <code>cost limit exceeded</code> error immediately when exceeds the cost limit in runtime.</p>
<pre><code class="language-c">stat := wasmedge.NewStatistics()

costtable := []uint64{
  0, 0,
  10, /* 0x02: Block */
  11, /* 0x03: Loop */
  12, /* 0x04: If */
  12, /* 0x05: Else */
  0, 0, 0, 0, 0, 0,
  20, /* 0x0C: Br */
  21, /* 0x0D: Br_if */
  22, /* 0x0E: Br_table */
  0,
}
// Developers can set the costs of each instruction. The value not covered will be 0.

WasmEdge_StatisticsSetCostTable(StatCxt, CostTable, 16);
stat.SetCostTable()
stat.SetCostLimit(5000000)

// ... After running the WASM functions with the `Statistics` object
cost := stat.GetTotalCost()
stat.Release()
</code></pre>
</li>
</ol>
<h2 id="wasmedge-vm-4"><a class="header" href="#wasmedge-vm-4">WasmEdge VM</a></h2>
<p>In this partition, we will introduce the functions of <code>wasmedge.VM</code> object and show examples of executing WASM functions.</p>
<h3 id="wasm-execution-example-with-vm-object-1"><a class="header" href="#wasm-execution-example-with-vm-object-1">WASM Execution Example With VM Object</a></h3>
<p>The following shows the example of running the WASM for getting the Fibonacci.
This example uses the <a href="https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/examples/wasm/fibonacci.wasm">fibonacci.wasm</a>, and the corresponding WAT file is at <a href="https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/examples/wasm/fibonacci.wat">fibonacci.wat</a>.</p>
<pre><code class="language-wasm">(module
 (export &quot;fib&quot; (func $fib))
 (func $fib (param $n i32) (result i32)
  (if
   (i32.lt_s (get_local $n)(i32.const 2))
   (return (i32.const 1))
  )
  (return
   (i32.add
    (call $fib (i32.sub (get_local $n)(i32.const 2)))
    (call $fib (i32.sub (get_local $n)(i32.const 1)))
   )
  )
 )
)
</code></pre>
<ol>
<li>
<p>Run WASM functions rapidly</p>
<p>Create a new Go project first:</p>
<pre><code class="language-bash">mkdir wasmedge_test &amp;&amp; cd wasmedge_test
go mod init wasmedge_test
</code></pre>
<p>Assume that the WASM file <a href="https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/examples/wasm/fibonacci.wasm"><code>fibonacci.wasm</code></a> is copied into the current <code>wasmedge_test</code> directory, and create and edit the Go file <code>main.go</code> as following:</p>
<pre><code class="language-go">package main

import (
  &quot;fmt&quot;

  &quot;github.com/second-state/WasmEdge-go/wasmedge&quot;
)

func main() {
  // Set the logging level.
  wasmedge.SetLogErrorLevel()

  // Create the configure context and add the WASI support.
  // This step is not necessary unless you need WASI support.
  conf := wasmedge.NewConfigure(wasmedge.WASI)
  // Create VM with the configure.
  vm := wasmedge.NewVMWithConfig(conf)

  res, err := vm.RunWasmFile(&quot;fibonacci.wasm&quot;, &quot;fib&quot;, uint32(21))
  if err == nil {
    fmt.Println(&quot;Get fibonacci[21]:&quot;, res[0].(int32))
  } else {
    fmt.Println(&quot;Run failed:&quot;, err.Error())
  }

  vm.Release()
  conf.Release()
}
</code></pre>
<p>Then you can build and run the Golang application with the WasmEdge Golang SDK: (the 21 Fibonacci number is 17711 in 0-based index)</p>
<pre><code class="language-bash">$ go get github.com/second-state/WasmEdge-go/wasmedge@v0.9.2
$ go build
$ ./wasmedge_test
Get fibonacci[21]: 17711
</code></pre>
</li>
<li>
<p>Instantiate and run WASM functions manually</p>
<p>Besides the above example, developers can run the WASM functions step-by-step with <code>VM</code> object APIs:</p>
<pre><code class="language-go">package main

import (
  &quot;fmt&quot;

  &quot;github.com/second-state/WasmEdge-go/wasmedge&quot;
)

func main() {
  // Set the logging level.
  wasmedge.SetLogErrorLevel()

  // Create VM.
  vm := wasmedge.NewVM()
  var err error
  var res []interface{}

  // Step 1: Load WASM file.
  err = vm.LoadWasmFile(&quot;fibonacci.wasm&quot;)
  if err != nil {
    fmt.Println(&quot;Load WASM from file FAILED:&quot;, err.Error())
    return
  }

  // Step 2: Validate the WASM module.
  err = vm.Validate()
  if err != nil {
    fmt.Println(&quot;Validation FAILED:&quot;, err.Error())
    return
  }

  // Step 3: Instantiate the WASM module.
  err = vm.Instantiate()
  // Developers can load, validate, and instantiate another WASM module
  // to replace the instantiated one. In this case, the old module will
  // be cleared, but the registered modules are still kept.
  if err != nil {
    fmt.Println(&quot;Instantiation FAILED:&quot;, err.Error())
    return
  }

  // Step 4: Execute WASM functions. Parameters: (funcname, args...)
  res, err = vm.Execute(&quot;fib&quot;, uint32(25))
  // Developers can execute functions repeatedly after instantiation.
  if err == nil {
    fmt.Println(&quot;Get fibonacci[25]:&quot;, res[0].(int32))
  } else {
    fmt.Println(&quot;Run failed:&quot;, err.Error())
  }

  vm.Release()
}
</code></pre>
<p>Then you can build and run: (the 25th Fibonacci number is 121393 in 0-based index)</p>
<pre><code class="language-bash">$ go build
$ ./wasmedge_test
Get fibonacci[25]: 121393
</code></pre>
<p>The following graph explains the status of the <code>VM</code> object.</p>
<pre><code class="language-text">                       |========================|
              |-------&gt;|      VM: Initiated     |
              |        |========================|
              |                    |
              |                 LoadWasm
              |                    |
              |                    v
              |        |========================|
              |--------|       VM: Loaded       |&lt;-------|
              |        |========================|        |
              |              |            ^              |
              |         Validate          |              |
          Cleanup            |          LoadWasm         |
              |              v            |            LoadWasm
              |        |========================|        |
              |--------|      VM: Validated     |        |
              |        |========================|        |
              |              |            ^              |
              |      Instantiate          |              |
              |              |          RegisterModule   |
              |              v            |              |
              |        |========================|        |
              |--------|    VM: Instantiated    |--------|
                       |========================|
                             |            ^
                             |            |
                             --------------
                Instantiate, Execute, ExecuteRegistered,
                ExecuteBindgen, ExecuteBindgenRegistered
</code></pre>
<p>The status of the <code>VM</code> context would be <code>Inited</code> when created.
After loading WASM successfully, the status will be <code>Loaded</code>.
After validating WASM successfully, the status will be <code>Validated</code>.
After instantiating WASM successfully, the status will be <code>Instantiated</code>, and developers can invoke functions.
Developers can register WASM or import objects in any status, but they should instantiate WASM again.
Developers can also load WASM in any status, and they should validate and instantiate the WASM module before function invocation.
When in the <code>Instantiated</code> status, developers can instantiate the WASM module again to reset the old WASM runtime structures.</p>
</li>
</ol>
<h3 id="vm-creations-4"><a class="header" href="#vm-creations-4">VM Creations</a></h3>
<p>The <code>VM</code> creation APIs accepts the <code>Configure</code> object and the <code>Store</code> object.
Noticed that if the <code>VM</code> created with the outside <code>Store</code> object, the <code>VM</code> will execute WASM on that <code>Store</code> object. If the <code>Store</code> object is set into multiple <code>VM</code> objects, it may causes data conflict when in execution.
The details of the <code>Store</code> object will be introduced in <a href="sdk/go/0.9.1/ref.html#store">Store</a>.</p>
<pre><code class="language-go">conf := wasmedge.NewConfigure()
store := wasmedge.NewStore()

// Create a VM with default configure and store.
vm := wasmedge.NewVM()
vm.Release()

// Create a VM with the specified configure and default store.
vm = wasmedge.NewVMWithConfig(conf)
vm.Release()

// Create a VM with the default configure and specified store.
vm = wasmedge.NewVMWithStore(store)
vm.Release()

// Create a VM with the specified configure and store.
vm = wasmedge.NewVMWithConfigAndStore(conf, store)
vm.Release()

conf.Release()
store.Release()
</code></pre>
<h3 id="preregistrations-4"><a class="header" href="#preregistrations-4">Preregistrations</a></h3>
<p>WasmEdge provides the following built-in pre-registrations.</p>
<ol>
<li>
<p><a href="https://github.com/WebAssembly/WASI">WASI (WebAssembly System Interface)</a></p>
<p>Developers can turn on the WASI support for VM in the <code>Configure</code> object.</p>
<pre><code class="language-go">conf := wasmedge.NewConfigure(wasmedge.WASI)
// Or you can set the `wasmedge.WASI` into the configure object through `(*Configure).AddConfig`.
vm := wasmedge.NewVMWithConfig(conf)
vm.Release()

// The following API can retrieve the pre-registration import objects from the VM object.
// This API will return `nil` if the corresponding pre-registration is not set into the configuration.
wasiconf := conf.GetImportObject(wasmedge.WASI)
// Initialize the WASI.
wasiconf.InitWasi(/* ... ignored */)

conf.Release()
</code></pre>
<p>And also can create the WASI import object from API. The details will be introduced in the <a href="sdk/go/0.9.1/ref.html#host-functions">Host Functions</a> and the <a href="sdk/go/0.9.1/ref.html#host-module-registrations">Host Module Registrations</a>.</p>
</li>
<li>
<p><a href="https://crates.io/crates/wasmedge_process_interface">WasmEdge_Process</a></p>
<p>This pre-registration is for the process interface for WasmEdge on <code>Rust</code> sources.
After turning on this pre-registration, the VM will support the <code>wasmedge_process</code> host functions.</p>
<pre><code class="language-go">conf := wasmedge.NewConfigure(wasmedge.WasmEdge_PROCESS)
vm := wasmedge.NewVMWithConfig(conf)
vm.Release()

// The following API can retrieve the pre-registration import objects from the VM object.
// This API will return `nil` if the corresponding pre-registration is not set into the configuration.
procconf := conf.GetImportObject(wasmedge.WasmEdge_PROCESS)
// Initialize the WasmEdge_Process.
procconf.InitWasmEdgeProcess(/* ... ignored */)

conf.Release()
</code></pre>
<p>And also can create the WasmEdge_Process import object from API. The details will be introduced in the <a href="sdk/go/0.9.1/ref.html#host-functions">Host Functions</a> and the <a href="sdk/go/0.9.1/ref.html#host-module-registrations">Host Module Registrations</a>.</p>
</li>
</ol>
<h3 id="host-module-registrations-4"><a class="header" href="#host-module-registrations-4">Host Module Registrations</a></h3>
<p><a href="https://webassembly.github.io/spec/core/exec/runtime.html#syntax-hostfunc">Host functions</a> are functions outside WebAssembly and passed to WASM modules as imports.
In WasmEdge-go, the host functions are composed into host modules as <code>ImportObject</code> objects with module names.
Please refer to the <a href="sdk/go/0.9.1/ref.html#host-functions">Host Functions in WasmEdge Runtime</a> for the details.
In this chapter, we show the example for registering the host modules into a <code>VM</code> object.</p>
<pre><code class="language-go">vm := wasmedge.NewVM()
// You can also create and register the WASI host modules by this API.
wasiobj := wasmedge.NewWasiImportObject(/* ... ignored ... */)

res := vm.RegisterImport(wasiobj)
// The result status should be checked.

vm.Release()
// The created import objects should be released.
wasiobj.Release()
</code></pre>
<h3 id="wasm-registrations-and-executions-4"><a class="header" href="#wasm-registrations-and-executions-4">WASM Registrations And Executions</a></h3>
<p>In WebAssembly, the instances in WASM modules can be exported and can be imported by other WASM modules.
WasmEdge VM provides APIs for developers to register and export any WASM modules, and execute the functions or host functions in the registered WASM modules.</p>
<ol>
<li>
<p>Register the WASM modules with exported module names</p>
<p>Unless the import objects have already contained the module names, every WASM module should be named uniquely when registering. The following shows the example.</p>
<p>Create a new Go project first:</p>
<pre><code class="language-bash">mkdir wasmedge_test &amp;&amp; cd wasmedge_test
go mod init wasmedge_test
</code></pre>
<p>Assume that the WASM file <a href="https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/examples/wasm/fibonacci.wasm"><code>fibonacci.wasm</code></a> is copied into the current directory.
Then create and edit the Go file <code>main.go</code> as following:</p>
<pre><code class="language-go">package main

import &quot;github.com/second-state/WasmEdge-go/wasmedge&quot;

func main() {
  // Create VM.
  vm := wasmedge.NewVM()

  var err error
  err = vm.RegisterWasmFile(&quot;module_name&quot;, &quot;fibonacci.wasm&quot;)
  // Developers can register the WASM module from `[]byte` with the
  // `(*VM).RegisterWasmBuffer` function, or from `AST` object with
  // the `(*VM).RegisterAST` function.
  // The result status should be checked. The error will occur if the
  // WASM module instantiation failed or the module name conflicts.

  vm.Release()
}
</code></pre>
</li>
<li>
<p>Execute the functions in registered WASM modules</p>
<p>Edit the Go file <code>main.go</code> as following:</p>
<pre><code class="language-go">package main

import (
  &quot;fmt&quot;

  &quot;github.com/second-state/WasmEdge-go/wasmedge&quot;
)

func main() {
  // Create VM.
  vm := wasmedge.NewVM()

  var res []interface{}
  var err error
  // Register the WASM module from file into VM with the module name &quot;mod&quot;.
  err = vm.RegisterWasmFile(&quot;mod&quot;, &quot;fibonacci.wasm&quot;)
  // Developers can register the WASM module from `[]byte` with the
  // `(*VM).RegisterWasmBuffer` function, or from `AST` object with
  // the `(*VM).RegisterAST` function.
  if err != nil {
    fmt.Println(&quot;WASM registration failed:&quot;, err.Error())
    return
  }
  // The function &quot;fib&quot; in the &quot;fibonacci.wasm&quot; was exported with the module
  // name &quot;mod&quot;. As the same as host functions, other modules can import the
  // function `&quot;mod&quot; &quot;fib&quot;`.

  // Execute WASM functions in registered modules.
  // Unlike the execution of functions, the registered functions can be
  // invoked without `(*VM).Instantiate` because the WASM module was
  // instantiated when registering.
  // Developers can also invoke the host functions directly with this API.
  res, err = vm.ExecuteRegistered(&quot;mod&quot;, &quot;fib&quot;, int32(25))
  if err == nil {
    fmt.Println(&quot;Get fibonacci[25]:&quot;, res[0].(int32))
  } else {
    fmt.Println(&quot;Run failed:&quot;, err.Error())
  }

  vm.Release()
}
</code></pre>
<p>Then you can build and run: (the 25th Fibonacci number is 121393 in 0-based index)</p>
<pre><code class="language-bash">$ go get github.com/second-state/WasmEdge-go/wasmedge@v0.9.2
$ go build
$ ./wasmedge_test
Get fibonacci[25]: 121393
</code></pre>
</li>
</ol>
<h3 id="asynchronous-execution-4"><a class="header" href="#asynchronous-execution-4">Asynchronous Execution</a></h3>
<ol>
<li>
<p>Asynchronously run WASM functions rapidly</p>
<p>Assume that a new Go project is created as following:</p>
<pre><code class="language-bash">mkdir wasmedge_test &amp;&amp; cd wasmedge_test
go mod init wasmedge_test
</code></pre>
<p>Then assume that the WASM file <a href="https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/examples/wasm/fibonacci.wasm"><code>fibonacci.wasm</code></a> is copied into the current directory, and create and edit a Go file <code>main.go</code>:</p>
<pre><code class="language-go">package main

import (
  &quot;fmt&quot;

  &quot;github.com/second-state/WasmEdge-go/wasmedge&quot;
)

func main() {
  // Create VM.
  vm := wasmedge.NewVM()

  // Asynchronously run the WASM function from file and get the `wasmedge.Async` object.
  async := vm.AsyncRunWasmFile(&quot;fibonacci.wasm&quot;, &quot;fib&quot;, uint32(20))

  // Block and wait for the execution and get the results.
  res, err := async.GetResult()
  if err == nil {
    fmt.Println(&quot;Get the result:&quot;, res[0].(int32))
  } else {
    fmt.Println(&quot;Error message:&quot;, err.Error())
  }
  async.Release()
  vm.Release()
}
</code></pre>
<p>Then you can build and run: (the 20th Fibonacci number is 10946 in 0-based index)</p>
<pre><code class="language-bash">$ go get github.com/second-state/WasmEdge-go/wasmedge@v0.9.2
$ go build
$ ./wasmedge_test
Get the result: 10946
</code></pre>
</li>
<li>
<p>Instantiate and asynchronously run WASM functions manually</p>
<p>Besides the above example, developers can run the WASM functions step-by-step with <code>VM</code> context APIs:</p>
<pre><code class="language-go">package main

import (
  &quot;fmt&quot;

  &quot;github.com/second-state/WasmEdge-go/wasmedge&quot;
)

func main() {
  var err error
  var res []interface{}

  // Create VM.
  vm := wasmedge.NewVM()

  // Step 1: Load WASM file.
  // Developers can load the WASM binary from buffer with the `(*VM).LoadWasmBuffer()` API,
  // or from `wasmedge.AST` object with the `(*VM).LoadWasmAST()` API.
  err := vm.LoadWasmFile(&quot;fibonacci.wasm&quot;)
  if err != nil {
    fmt.Println(&quot;Load WASM from file FAILED:&quot;, err.Error())
    return
  }

  // Step 2: Validate the WASM module.
  err = vm.Validate()
  if err != nil {
    fmt.Println(&quot;Validation FAILED:&quot;, err.Error())
    return
  }

  // Step 3: Instantiate the WASM module.
  err = vm.Instantiate()
  if err != nil {
    fmt.Println(&quot;Instantiation FAILED:&quot;, err.Error())
    return
  }

  // Step 4: Asynchronously execute the WASM function and get the `wasmedge.Async` object.
  async := vm.AsyncExecute(&quot;fib&quot;, uint32(25))

  // Block and wait for the execution and get the results.
  res, err := async.GetResult()
  if err == nil {
    fmt.Println(&quot;Get the result:&quot;, res[0].(int32))
  } else {
    fmt.Println(&quot;Error message:&quot;, err.Error())
  }
  async.Release()
  vm.Release()
}
</code></pre>
<p>Then you can build and run: (the 25th Fibonacci number is 121393 in 0-based index)</p>
<pre><code class="language-bash">$ go get github.com/second-state/WasmEdge-go/wasmedge@v0.9.2
$ go build
$ ./wasmedge_test
Get the result: 121393
</code></pre>
</li>
</ol>
<h3 id="instance-tracing-4"><a class="header" href="#instance-tracing-4">Instance Tracing</a></h3>
<p>Sometimes the developers may have requirements to get the instances of the WASM runtime.
The <code>VM</code> object supplies the APIs to retrieve the instances.</p>
<ol>
<li>
<p>Store</p>
<p>If the <code>VM</code> object is created without assigning a <code>Store</code> object, the <code>VM</code> context will allocate and own a <code>Store</code>.</p>
<pre><code class="language-go">vm := wasmedge.NewVM()
store := vm.GetStore()
// The object should __NOT__ be deleted by calling `(*Store).Release`.
vm.Release()
</code></pre>
<p>Developers can also create the <code>VM</code> object with a <code>Store</code> object.
In this case, developers should guarantee that the <code>Store</code> object cannot be released before the <code>VM</code> object.
Please refer to the <a href="sdk/go/0.9.1/ref.html#store">Store Objects</a> for the details about the <code>Store</code> APIs.</p>
<pre><code class="language-go">store := wasmedge.NewStore()
vm := wasmedge.NewVMWithStore(store)

storemock := vm.GetStore()
// The internal store context of the `store` and the `storemock` are the same.

vm.Release()
store.Release()
</code></pre>
</li>
<li>
<p>List exported functions</p>
<p>After the WASM module instantiation, developers can use the <code>(*VM).Execute</code> function to invoke the exported WASM functions. For this purpose, developers may need information about the exported WASM function list.
Please refer to the <a href="sdk/go/0.9.1/ref.html#instances">Instances in runtime</a> for the details about the function types.</p>
<p>Assume that a new Go project is created as following:</p>
<pre><code class="language-bash">mkdir wasmedge_test &amp;&amp; cd wasmedge_test
go mod init wasmedge_test
</code></pre>
<p>Then assume that the WASM file <a href="https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/examples/wasm/fibonacci.wasm"><code>fibonacci.wasm</code></a> is copied into the current directory, and create and edit a Go file <code>main.go</code>:</p>
<pre><code class="language-go">package main

import (
  &quot;fmt&quot;

  &quot;github.com/second-state/WasmEdge-go/wasmedge&quot;
)

func main() {
  // Create VM.
  vm := wasmedge.NewVM()

  // Step 1: Load WASM file.
  err := vm.LoadWasmFile(&quot;fibonacci.wasm&quot;)
  if err != nil {
    fmt.Println(&quot;Load WASM from file FAILED:&quot;, err.Error())
    return
  }

  // Step 2: Validate the WASM module.
  err = vm.Validate()
  if err != nil {
    fmt.Println(&quot;Validation FAILED:&quot;, err.Error())
    return
  }

  // Step 3: Instantiate the WASM module.
  err = vm.Instantiate()
  if err != nil {
    fmt.Println(&quot;Instantiation FAILED:&quot;, err.Error())
    return
  }

  // List the exported functions for the names and function types.
  funcnames, functypes := vm.GetFunctionList()
  for _, fname := range funcnames {
    fmt.Println(&quot;Exported function name:&quot;, fname)
  }
  for _, ftype := range functypes {
    // `ftype` is the `FunctionType` object of the same index in the `funcnames` array.
    // Developers should __NOT__ call the `ftype.Release()`.
  }

  vm.Release()
}
</code></pre>
<p>Then you can build and run: (the only exported function in <code>fibonacci.wasm</code> is <code>fib</code>)</p>
<pre><code class="language-bash">$ go get github.com/second-state/WasmEdge-go/wasmedge@v0.9.2
$ go build
$ ./wasmedge_test
Exported function name: fib
</code></pre>
<p>If developers want to get the exported function names in the registered WASM modules, please retrieve the <code>Store</code> object from the <code>VM</code> object and refer to the APIs of <a href="sdk/go/0.9.1/ref.html#store">Store Contexts</a> to list the registered functions by the module name.</p>
</li>
<li>
<p>Get function types</p>
<p>The <code>VM</code> object provides APIs to find the function type by function name.
Please refer to the <a href="sdk/go/0.9.1/ref.html#instances">Instances in runtime</a> for the details about the function types.</p>
<pre><code class="language-go">// Assume that a WASM module is instantiated in `vm` which is a `wasmedge.VM` object.
functype := vm.GetFunctionType(&quot;fib&quot;)
// Developers can get the function types of functions in the registered modules via the 
// `(*VM).GetFunctionTypeRegistered` API with the functon name and the module name.
// If the function is not found, these APIs will return `nil`.
// Developers should __NOT__ call the `(*FunctionType).Release` function of the returned object.
</code></pre>
</li>
</ol>
<h2 id="wasmedge-runtime-4"><a class="header" href="#wasmedge-runtime-4">WasmEdge Runtime</a></h2>
<p>In this partition, we will introduce the objects of WasmEdge runtime manually.</p>
<h3 id="wasm-execution-example-step-by-step-4"><a class="header" href="#wasm-execution-example-step-by-step-4">WASM Execution Example Step-By-Step</a></h3>
<p>Besides the WASM execution through the <a href="sdk/go/0.9.1/ref.html#wasmedge-vm"><code>VM</code> object</a> rapidly, developers can execute the WASM functions or instantiate WASM modules step-by-step with the <code>Loader</code>, <code>Validator</code>, <code>Executor</code>, and <code>Store</code> objects.</p>
<p>Assume that a new Go project is created as following:</p>
<pre><code class="language-bash">mkdir wasmedge_test &amp;&amp; cd wasmedge_test
go mod init wasmedge_test
</code></pre>
<p>Then assume that the WASM file <a href="https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/examples/wasm/fibonacci.wasm"><code>fibonacci.wasm</code></a> is copied into the current directory, and create and edit a Go file <code>main.go</code>:</p>
<pre><code class="language-go">package main

import (
  &quot;fmt&quot;

  &quot;github.com/second-state/WasmEdge-go/wasmedge&quot;
)

func main() {
  // Set the logging level to debug to print the statistics info.
  wasmedge.SetLogDebugLevel()
  // Create the configure object. This is not necessary if developers use the default configuration.
  conf := wasmedge.NewConfigure()
  // Turn on the runtime instruction counting and time measuring.
  conf.SetStatisticsInstructionCounting(true)
  conf.SetStatisticsTimeMeasuring(true)
  // Create the statistics object. This is not necessary if the statistics in runtime is not needed.
  stat := wasmedge.NewStatistics()
  // Create the store object. The store object is the WASM runtime structure core.
  store := wasmedge.NewStore()

  var err error
  var res []interface{}
  var ast *wasmedge.AST

  // Create the loader object.
  // For loader creation with default configuration, you can use `wasmedge.NewLoader()` instead.
  loader := wasmedge.NewLoaderWithConfig(conf)
  // Create the validator object.
  // For validator creation with default configuration, you can use `wasmedge.NewValidator()` instead.
  validator := wasmedge.NewValidatorWithConfig(conf)
  // Create the executor object.
  // For executor creation with default configuration and without statistics, you can use `wasmedge.NewExecutor()` instead.
  executor := wasmedge.NewExecutorWithConfigAndStatistics(conf, stat)

  // Load the WASM file or the compiled-WASM file and convert into the AST module object.
  ast, err = loader.LoadFile(&quot;fibonacci.wasm&quot;)
  if err != nil {
    fmt.Println(&quot;Load WASM from file FAILED:&quot;, err.Error())
    return
  }
  // Validate the WASM module.
  err = validator.Validate(ast)
  if err != nil {
    fmt.Println(&quot;Validation FAILED:&quot;, err.Error())
    return
  }
  // Instantiate the WASM module into the Store object.
  err = executor.Instantiate(store, ast)
  if err != nil {
    fmt.Println(&quot;Instantiation FAILED:&quot;, err.Error())
    return
  }

  // Try to list the exported functions of the instantiated WASM module.
  funcnames := store.ListFunction()
  for _, fname := range funcnames {
    fmt.Println(&quot;Exported function name:&quot;, fname)
  }

  // Invoke the WASM function.
  res, err = executor.Invoke(store, &quot;fib&quot;, int32(30))
  if err == nil {
    fmt.Println(&quot;Get fibonacci[30]:&quot;, res[0].(int32))
  } else {
    fmt.Println(&quot;Run failed:&quot;, err.Error())
  }

  // Resources deallocations.
  conf.Release()
  stat.Release()
  ast.Release()
  loader.Release()
  validator.Release()
  executor.Release()
  store.Release()
}
</code></pre>
<p>Then you can build and run: (the 18th Fibonacci number is 1346269 in 30-based index)</p>
<pre><code class="language-bash">$ go get github.com/second-state/WasmEdge-go/wasmedge@v0.9.2
$ go build
$ ./wasmedge_test
Exported function name: fib
[2021-11-24 18:53:01.451] [debug]  Execution succeeded.
[2021-11-24 18:53:01.452] [debug]
 ====================  Statistics  ====================
 Total execution time: 556372295 ns
 Wasm instructions execution time: 556372295 ns
 Host functions execution time: 0 ns
 Executed wasm instructions count: 28271634
 Gas costs: 0
 Instructions per second: 50814237
Get fibonacci[30]: 1346269
</code></pre>
<h3 id="loader-4"><a class="header" href="#loader-4">Loader</a></h3>
<p>The <code>Loader</code> object loads the WASM binary from files or buffers.
Both the WASM and the compiled-WASM from the <a href="sdk/go/0.9.1/ref.html#wasmedge-aot-compiler">WasmEdge AOT Compiler</a> are supported.</p>
<pre><code class="language-go">var buf []byte
// ... Read the WASM code to the `buf`.

// Developers can adjust settings in the configure object.
conf := wasmedge.NewConfigure()
// Create the loader object.
// For loader creation with default configuration, you can use `wasmedge.NewLoader()` instead.
loader := wasmedge.NewLoaderWithConfig(conf)
conf.Release()

// Load WASM or compiled-WASM from the file.
ast, err := loader.LoadFile(&quot;fibonacci.wasm&quot;)
if err != nil {
  fmt.Println(&quot;Load WASM from file FAILED:&quot;, err.Error())
} else {
  // The output AST object should be released.
  ast.Release()
}

// Load WASM or compiled-WASM from the buffer
ast, err = loader.LoadBuffer(buf)
if err != nil {
  fmt.Println(&quot;Load WASM from buffer FAILED:&quot;, err.Error())
} else {
  // The output AST object should be released.
  ast.Release()   
}

loader.Release()
</code></pre>
<h3 id="validator-4"><a class="header" href="#validator-4">Validator</a></h3>
<p>The <code>Validator</code> object can validate the WASM module.
Every WASM module should be validated before instantiation.</p>
<pre><code class="language-go">// ...
// Assume that the `ast` is the output `*wasmedge.AST` object from the loader context.
// Assume that the `conf` is the `*wasmedge.Configure` object.

// Create the validator context.
// For validator creation with default configuration, you can use `wasmedge.NewValidator()` instead.
validator := wasmedge.NewValidatorWithConfig(conf)

err := validator.Validate(ast)
if err != nil {
  fmt.Println(&quot;Validation FAILED:&quot;, err.Error())
}

validator.Release()
</code></pre>
<h3 id="executor-4"><a class="header" href="#executor-4">Executor</a></h3>
<p>The <code>Executor</code> object is the executor for both WASM and compiled-WASM.
This object should work base on the <code>Store</code> object. For the details of the <code>Store</code> object, please refer to the <a href="sdk/go/0.9.1/ref.html#store">next chapter</a>.</p>
<ol>
<li>
<p>Register modules</p>
<p>As the same of <a href="sdk/go/0.9.1/ref.html#host-module-registrations">registering host modules</a> or <a href="sdk/go/0.9.1/ref.html#wasm-registrations-and-executions">importing WASM modules</a> in <code>VM</code> objects, developers can register <code>ImportObject</code> or <code>AST</code> objects into the <code>Store</code> object by the <code>Executor</code> APIs.
For the details of import objects, please refer to the <a href="sdk/go/0.9.1/ref.html#host-functions">Host Functions</a>).</p>
<pre><code class="language-go">// ...
// Assume that the `ast` is the output `*wasmedge.AST` object from the loader
// and has passed the validation.
// Assume that the `conf` is the `*wasmedge.Configure` object.

// Create the statistics object. This step is not necessary if the statistics
// is not needed.
stat := wasmedge.NewStatistics()
// Create the executor object.
// For executor creation with default configuration and without statistics,
// you can use `wasmedge.NewExecutor()` instead.
executor := wasmedge.NewExecutorWithConfigAndStatistics(conf, stat)
// Create the store object. The store is the WASM runtime structure core.
store := wasmedge.NewStore()

// Register the loaded WASM `ast` into store with the export module name &quot;mod&quot;.
res := executor.RegisterModule(store, ast, &quot;mod&quot;)
if err != nil {
  fmt.Println(&quot;WASM registration FAILED:&quot;, err.Error())
  return
}

// Assume that the `impobj` is the `*wasmedge.ImportObject` for host functions.
impobj := ...
err = executor.RegisterImport(store, impobj)
if err != nil {
  fmt.Println(&quot;Import object registration FAILED:&quot;, err.Error())
  return
}

executor.Release()
stat.Release()
store.Release()
impobj.Release()
</code></pre>
</li>
<li>
<p>Instantiate modules</p>
<p>WASM or compiled-WASM modules should be instantiated before the function invocation.
Note that developers can only instantiate one module into the <code>Store</code> object, and in that case, the old instantiated module will be cleaned.
Before instantiating a WASM module, please check the <a href="https://webassembly.github.io/spec/core/syntax/modules.html#syntax-import">import section</a> for ensuring the imports are registered into the <code>Store</code> object.</p>
<pre><code class="language-go">// ...
// Assume that the `ast` is the output `*wasmedge.AST` object from the loader
// and has passed the validation.
// Assume that the `conf` is the `*wasmedge.Configure` object.

// Create the statistics object. This step is not necessary if the statistics
// is not needed.
stat := wasmedge.NewStatistics()
// Create the executor object.
// For executor creation with default configuration and without statistics,
// you can use `wasmedge.NewExecutor()` instead.
executor := wasmedge.NewExecutorWithConfigAndStatistics(conf, stat)
// Create the store object. The store is the WASM runtime structure core.
store := wasmedge.NewStore()

// Instantiate the WASM module.
err := executor.Instantiate(stpre, ast)
if err != nil {
  fmt.Println(&quot;WASM instantiation FAILED:&quot;, err.Error())
  return
}

executor.Release()
stat.Release()
store.Release()
</code></pre>
</li>
<li>
<p>Invoke functions</p>
<p>As the same as function invocation via the <code>VM</code> object, developers can invoke the functions of the instantiated or registered modules.
The APIs, <code>(*Executor).Invoke</code> and <code>(*Executor).InvokeRegistered</code>, are similar as the APIs of the <code>VM</code> object.
Please refer to the <a href="sdk/go/0.9.1/ref.html#wasm-execution-example-with-vm-object">VM context workflows</a> for details.</p>
</li>
</ol>
<h3 id="ast-module-4"><a class="header" href="#ast-module-4">AST Module</a></h3>
<p>The <code>AST</code> object presents the loaded structure from a WASM file or buffer. Developer will get this object after loading a WASM file or buffer from <a href="sdk/go/0.9.1/ref.html#loader">Loader</a>.
Before instantiation, developers can also query the imports and exports of an <code>AST</code> object.</p>
<pre><code class="language-go">ast := ...
// Assume that a WASM is loaded into an `*wasmedge.AST` object from loader.

// List the imports.
imports := ast.ListImports()
for _, import := range imports {
  fmt.Println(&quot;Import:&quot;, import.GetModuleName(), import.GetExternalName())
}

// List the exports.
exports := ast.ListExports()
for _, export := range exports {
  fmt.Println(&quot;Export:&quot;, export.GetExternalName())
}

ast.Release()
</code></pre>
<h3 id="store-4"><a class="header" href="#store-4">Store</a></h3>
<p><a href="https://webassembly.github.io/spec/core/exec/runtime.html#store">Store</a> is the runtime structure for the representation of all instances of <code>Function</code>s, <code>Table</code>s, <code>Memory</code>s, and <code>Global</code>s that have been allocated during the lifetime of the abstract machine.
The <code>Store</code> object in WasmEdge-go provides APIs to list the exported instances with their names or find the instances by exported names. For adding instances into <code>Store</code> objects, please instantiate or register WASM modules or <code>ImportObject</code> objects via the <code>Executor</code> APIs.</p>
<ol>
<li>
<p>List instances</p>
<pre><code class="language-go">store := wasmedge.NewStore()
// ...
// Instantiate a WASM module via the `*wasmedge.Executor` object.
// ...

// Try to list the exported functions of the instantiated WASM module.
// Take the function instances for example here.
funcnames := store.ListFunction()
for _, name := range funcnames {
  fmt.Println(&quot;Exported function name:&quot;, name)
}

store.Release()
</code></pre>
<p>Developers can list the function instance exported names of the registered modules via the <code>(*Store).ListFunctionRegistered()</code> API with the module name.</p>
</li>
<li>
<p>Find instances</p>
<pre><code class="language-go">store := wasmedge.NewStore()
// ...
// Instantiate a WASM module via the `*wasmedge.Executor` object.
// ...

// Try to find the exported functions of the instantiated WASM module.
// Take the function instances for example here.
funcobj := store.FindFunction(&quot;fib&quot;)
// `funcobj` will be `nil` if the function not found.

store.Release()
</code></pre>
<p>Developers can retrieve the exported function instances of the registered modules via the <code>(*Store).FindFunctionRegistered</code> API with the module name.</p>
</li>
<li>
<p>List registered modules</p>
<p>With the module names, developers can list the exported instances of the registered modules with their names.</p>
<pre><code class="language-go">store := wasmedge.NewStore()
// ...
// Instantiate a WASM module via the `*wasmedge.Executor` object.
// ...

// Try to list the registered WASM modules.
modnames := store.ListModule()
for _, name := range modnames {
  fmt.Println(&quot;Registered module names:&quot;, name)
}

store.Release()
</code></pre>
</li>
</ol>
<h3 id="instances-4"><a class="header" href="#instances-4">Instances</a></h3>
<p>The instances are the runtime structures of WASM. Developers can retrieve the instances from the <code>Store</code> objects.
The <code>Store</code> objects will allocate instances when a WASM module or an <code>ImportObject</code> is registered or instantiated through the <code>Executor</code>.
A single instance can be allocated by its creation function. Developers can construct instances into an <code>ImportObject</code> for registration. Please refer to the <a href="sdk/go/0.9.1/ref.html#host-functions">Host Functions</a> for details.
The instances created by their creation functions should be destroyed, EXCEPT they are added into an <code>ImportObject</code> object.</p>
<ol>
<li>
<p>Function instance</p>
<p><a href="https://webassembly.github.io/spec/core/exec/runtime.html#syntax-hostfunc">Host functions</a> are functions outside WebAssembly and passed to WASM modules as imports.
In WasmEdge, developers can create the <code>Function</code> objects for host functions and add them into an <code>ImportObject</code> object for registering into a <code>VM</code> or a <code>Store</code>.
For both host functions and the functions get from <code>Store</code>, developers can retrieve the <code>FunctionType</code> from the <code>Function</code> objects.
For the details of the <code>Host Function</code> guide, please refer to the <a href="sdk/go/0.9.1/ref.html#host-functions">next chapter</a>.</p>
<pre><code class="language-go">funcinst := ...
// `funcobj` is the `*wasmedge.Function` retrieved from the store object.
functype := funcobj.GetFunctionType()
// The `funcobj` retrieved from the store object should __NOT__ be released.
// The `functype` retrieved from the `funcobj` should __NOT__ be released.
</code></pre>
</li>
<li>
<p>Table instance</p>
<p>In WasmEdge, developers can create the <code>Table</code> objects and add them into an <code>ImportObject</code> object for registering into a <code>VM</code> or a <code>Store</code>.
The <code>Table</code> objects supply APIs to control the data in table instances.</p>
<pre><code class="language-go">lim := wasmedge.NewLimitWithMax(10, 20)
// Create the table type with limit and the `FuncRef` element type.
tabtype := wasmedge.NewTableType(wasmedge.RefType_FuncRef, lim)
// Create the table instance with table type.
tabinst := wasmedge.NewTable(tabtype)
// Delete the table type.
tabtype.Release()

gottabtype := tabinst.GetTableType()
// The `gottabtype` got from table instance is owned by the `tabinst`
// and should __NOT__ be released.
reftype := gottabtype.GetRefType()
// The `reftype` will be `wasmedge.RefType_FuncRef`.

var gotdata interface{}
data := wasmedge.NewFuncRef(5)
err := tabinst.SetData(data, 3)
// Set the function index 5 to the table[3].

// The following line will get an &quot;out of bounds table access&quot; error
// because the position (13) is out of the table size (10):
//   err = tabinst.SetData(data, 13)

gotdata, err = tabinst.GetData(3)
// Get the FuncRef value of the table[3].

// The following line will get an &quot;out of bounds table access&quot; error
// because the position (13) is out of the table size (10):
//   gotdata, err = tabinst.GetData(13)

tabsize := tabinst.GetSize()
// `tabsize` will be 10.
err = tabinst.Grow(6)
// Grow the table size of 6, the table size will be 16.

// The following line will get an &quot;out of bounds table access&quot; error
// because the size (16 + 6) will reach the table limit (20):
//   err = tabinst.Grow(6)

tabinst.Release()
</code></pre>
</li>
<li>
<p>Memory instance</p>
<p>In WasmEdge, developers can create the <code>Memory</code> objects and add them into an <code>ImportObject</code> object for registering into a <code>VM</code> or a <code>Store</code>.
The <code>Memory</code> objects supply APIs to control the data in memory instances.</p>
<pre><code class="language-go">lim := wasmedge.NewLimitWithMax(1, 5)
// Create the memory type with limit. The memory page size is 64KiB.
memtype := wasmedge.NewMemoryType(lim)
// Create the memory instance with memory type.
meminst := wasmedge.NewMemory(memtype)
// Delete the memory type.
memtype.Release()

data := []byte(&quot;A quick brown fox jumps over the lazy dog&quot;)
err := meminst.SetData(data, 0x1000, 10)
// Set the data[0:9] to the memory[4096:4105].

// The following line will get an &quot;out of bounds memory access&quot; error
// because [65535:65544] is out of 1 page size (65536):
//   err = meminst.SetData(data, 0xFFFF, 10)

var gotdata []byte
gotdata, err = meminst.GetData(0x1000, 10)
// Get the memory[4096:4105]. The `gotdata` will be `[]byte(&quot;A quick br&quot;).
// The following line will get an &quot;out of bounds memory access&quot; error
// because [65535:65544] is out of 1 page size (65536):
//   gotdata, err = meminst.Getdata(0xFFFF, 10)

pagesize := meminst.GetPageSize()
// `pagesize` will be 1.
err = meminst.GrowPage(2)
// Grow the page size of 2, the page size of the memory instance will be 3.

// The following line will get an &quot;out of bounds memory access&quot; error
// because the size (3 + 3) will reach the memory limit (5):
//   err = meminst.GetPageSize(3)

meminst.Release()
</code></pre>
</li>
<li>
<p>Global instance</p>
<p>In WasmEdge, developers can create the <code>Global</code> objects and add them into an <code>ImportObject</code> object for registering into a <code>VM</code> or a <code>Store</code>.
The <code>Global</code> objects supply APIs to control the value in global instances.</p>
<pre><code class="language-go">// Create the global type with value type and mutation.
globtype := wasmedge.NewGlobalType(wasmedge.ValType_I64, wasmedge.ValMut_Var)
// Create the global instance with value and global type.
globinst := wasmedge.NewGlobal(globtype, uint64(1000))
// Delete the global type.
globtype.Release()

gotglobtype := globinst.GetGlobalType()
// The `gotglobtype` got from global instance is owned by the `globinst`
// and should __NOT__ be released.
valtype := gotglobtype.GetValType()
// The `valtype` will be `wasmedge.ValType_I64`.
valmut := gotglobtype.GetMutability()
// The `valmut` will be `wasmedge.ValMut_Var`.

globinst.SetValue(uint64(888))
// Set the value u64(888) to the global.
// This function will do nothing if the value type mismatched or the
// global mutability is `wasmedge.ValMut_Const`.
gotval := globinst.GetValue()
// The `gotbal` will be `interface{}` which the type is `uint64` and
// the value is 888.

globinst.Release()
</code></pre>
</li>
</ol>
<h3 id="host-functions-7"><a class="header" href="#host-functions-7">Host Functions</a></h3>
<p><a href="https://webassembly.github.io/spec/core/exec/runtime.html#syntax-hostfunc">Host functions</a> are functions outside WebAssembly and passed to WASM modules as imports.
In WasmEdge-go, developers can create the <code>Function</code>, <code>Memory</code>, <code>Table</code>, and <code>Global</code> objects and add them into an <code>ImportObject</code> object for registering into a <code>VM</code> or a <code>Store</code>.</p>
<ol>
<li>
<p>Host function allocation</p>
<p>Developers can define Go functions with the following function signature as the host function body:</p>
<pre><code class="language-go">type hostFunctionSignature func(
    data interface{}, mem *Memory, params []interface{}) ([]interface{}, Result)
</code></pre>
<p>The example of an <code>add</code> host function to add 2 <code>i32</code> values:</p>
<pre><code class="language-go">func host_add(data interface{}, mem *wasmedge.Memory, params []interface{}) ([]interface{}, wasmedge.Result) {
  // add: i32, i32 -&gt; i32
  res := params[0].(int32) + params[1].(int32)

  // Set the returns
  returns := make([]interface{}, 1)
  returns[0] = res

  // Return
  return returns, wasmedge.Result_Success
}
</code></pre>
<p>Then developers can create <code>Function</code> object with the host function body and function type:</p>
<pre><code class="language-go">// Create a function type: {i32, i32} -&gt; {i32}.
functype := wasmedge.NewFunctionType(
  []wasmedge.ValType{wasmedge.ValType_I32, wasmedge.ValType_I32},
  []wasmedge.ValType{wasmedge.ValType_I32},
)

// Create a function context with the function type and host function body.
// The third parameter is the pointer to the additional data.
// Developers should guarantee the life cycle of the data, and it can be
// `nil` if the external data is not needed.
// The last parameter can be 0 if developers do not need the cost measuring.
func_add := wasmedge.NewFunction(functype, host_add, nil, 0)

// If the function object is not added into an import object object, it should be released.
func_add.Release()
functype.Release()
</code></pre>
</li>
<li>
<p>Import object object</p>
<p>The <code>ImportObject</code> object holds an exporting module name and the instances. Developers can add the <code>Function</code>, <code>Memory</code>, <code>Table</code>, and <code>Global</code> instances with their exporting names.</p>
<pre><code class="language-go">// Host function body definition.
func host_add(data interface{}, mem *wasmedge.Memory, params []interface{}) ([]interface{}, wasmedge.Result) {
  // add: i32, i32 -&gt; i32
  res := params[0].(int32) + params[1].(int32)

  // Set the returns
  returns := make([]interface{}, 1)
  returns[0] = res

  // Return
  return returns, wasmedge.Result_Success
}

// Create the import object with the module name &quot;module&quot;.
impobj := wasmedge.NewImportObject(&quot;module&quot;)

// Create and add a function instance into the import object with export name &quot;add&quot;.
functype := wasmedge.NewFunctionType(
  []wasmedge.ValType{wasmedge.ValType_I32, wasmedge.ValType_I32},
  []wasmedge.ValType{wasmedge.ValType_I32},
)
hostfunc := wasmedge.NewFunction(functype, host_add, nil, 0)
functype.Release()
impobj.AddFunction(&quot;add&quot;, hostfunc)

// Create and add a table instance into the import object with export name &quot;table&quot;.
tabtype := wasmedge.NewTableType(wasmedge.RefType_FuncRef ,wasmedge.NewLimitWithMax(10, 20))
hosttab := wasmedge.NewTable(tabtype)
tabtype.Release()
impobj.AddTable(&quot;table&quot;, hosttab)

// Create and add a memory instance into the import object with export name &quot;memory&quot;.
memtype := wasmedge.NewMemoryType(wasmedge.NewLimitWithMax(1, 2))
hostmem := wasmedge.NewMemory(memtype)
memtype.Release()
impobj.AddMemory(&quot;memory&quot;, hostmem)

// Create and add a global instance into the import object with export name &quot;global&quot;.
globtype := wasmedge.NewGlobalType(wasmedge.ValType_I32, wasmedge.ValMut_Var)
hostglob := wasmedge.NewGlobal(globtype, uint32(666))
globtype.Release()
impobj.AddGlobal(&quot;global&quot;, hostglob)

// The import objects should be released.
// Developers should __NOT__ release the instances added into the import object objects.
impobj.Release()
</code></pre>
</li>
<li>
<p>Specified import object</p>
<p><code>wasmedge.NewWasiImportObject()</code> API can create and initialize the <code>WASI</code> import object.
<code>wasmedge.NewWasmEdgeProcessImportObject()</code> API can create and initialize the <code>wasmedge_process</code> import object.
Developers can create these import object objects and register them into the <code>Store</code> or <code>VM</code> objects rather than adjust the settings in the <code>Configure</code> objects.</p>
<pre><code class="language-go">wasiobj := wasmedge.NewWasiImportObject(
  os.Args[1:],     // The args
  os.Environ(),    // The envs
  []string{&quot;.:.&quot;}, // The mapping preopens
)
procobj := wasmedge.NewWasmEdgeProcessImportObject(
  []string{&quot;ls&quot;, &quot;echo&quot;}, // The allowed commands
  false,                  // Not to allow all commands
)

// Register the WASI and WasmEdge_Process into the VM object.
vm := wasmedge.NewVM()
vm.RegisterImport(wasiobj)
vm.RegisterImport(procobj)

// ... Execute some WASM functions.

// Get the WASI exit code.
exitcode := wasiobj.WasiGetExitCode()
// The `exitcode` will be 0 if the WASI function &quot;_start&quot; execution has no error.
// Otherwise, it will return with the related exit code.

vm.Release()
// The import objects should be deleted.
wasiobj.Release()
procobj.Release()
</code></pre>
</li>
<li>
<p>Example</p>
<p>Create a new Go project first:</p>
<pre><code class="language-bash">mkdir wasmedge_test &amp;&amp; cd wasmedge_test
go mod init wasmedge_test
</code></pre>
<p>Assume that there is a simple WASM from the WAT as following:</p>
<pre><code class="language-wasm">(module
  (type $t0 (func (param i32 i32) (result i32)))
  (import &quot;extern&quot; &quot;func-add&quot; (func $f-add (type $t0)))
  (func (export &quot;addTwo&quot;) (param i32 i32) (result i32)
    local.get 0
    local.get 1
    call $f-add)
)
</code></pre>
<p>Create and edit the Go file <code>main.go</code> as following:</p>
<pre><code class="language-go">package main

import (
  &quot;fmt&quot;

  &quot;github.com/second-state/WasmEdge-go/wasmedge&quot;
)

// Host function body definition.
func host_add(data interface{}, mem *wasmedge.Memory, params []interface{}) ([]interface{}, wasmedge.Result) {
  // add: i32, i32 -&gt; i32
  res := params[0].(int32) + params[1].(int32)

  // Set the returns
  returns := make([]interface{}, 1)
  returns[0] = res

  // Return
  return returns, wasmedge.Result_Success
}

func main() {
  // Create the VM object.
  vm := wasmedge.NewVM()

  // The WASM module buffer.
  wasmbuf := []byte{
    /* WASM header */
    0x00, 0x61, 0x73, 0x6D, 0x01, 0x00, 0x00, 0x00,
    /* Type section */
    0x01, 0x07, 0x01,
    /* function type {i32, i32} -&gt; {i32} */
    0x60, 0x02, 0x7F, 0x7F, 0x01, 0x7F,
    /* Import section */
    0x02, 0x13, 0x01,
    /* module name: &quot;extern&quot; */
    0x06, 0x65, 0x78, 0x74, 0x65, 0x72, 0x6E,
    /* extern name: &quot;func-add&quot; */
    0x08, 0x66, 0x75, 0x6E, 0x63, 0x2D, 0x61, 0x64, 0x64,
    /* import desc: func 0 */
    0x00, 0x00,
    /* Function section */
    0x03, 0x02, 0x01, 0x00,
    /* Export section */
    0x07, 0x0A, 0x01,
    /* export name: &quot;addTwo&quot; */
    0x06, 0x61, 0x64, 0x64, 0x54, 0x77, 0x6F,
    /* export desc: func 0 */
    0x00, 0x01,
    /* Code section */
    0x0A, 0x0A, 0x01,
    /* code body */
    0x08, 0x00, 0x20, 0x00, 0x20, 0x01, 0x10, 0x00, 0x0B,
  }

  // Create the import object with the module name &quot;extern&quot;.
  impobj := wasmedge.NewImportObject(&quot;extern&quot;)

  // Create and add a function instance into the import object with export name &quot;func-add&quot;.
  functype := wasmedge.NewFunctionType(
    []wasmedge.ValType{wasmedge.ValType_I32, wasmedge.ValType_I32},
    []wasmedge.ValType{wasmedge.ValType_I32},
  )
  hostfunc := wasmedge.NewFunction(functype, host_add, nil, 0)
  functype.Release()
  impobj.AddFunction(&quot;func-add&quot;, hostfunc)

  // Register the import object into VM.
  vm.RegisterImport(impobj)

  res, err := vm.RunWasmBuffer(wasmbuf, &quot;addTwo&quot;, uint32(1234), uint32(5678))
  if err == nil {
    fmt.Println(&quot;Get the result:&quot;, res[0].(int32))
  } else {
    fmt.Println(&quot;Error message:&quot;, err.Error())
  }

  impobj.Release()
  vm.Release()
}
</code></pre>
<p>Then you can build and run the Golang application with the WasmEdge Golang SDK:</p>
<pre><code class="language-bash">$ go get github.com/second-state/WasmEdge-go/wasmedge@v0.9.2
$ go build
$ ./wasmedge_test
Get the result: 6912
</code></pre>
</li>
<li>
<p>Host Data Example</p>
<p>Developers can set a external data object to the function object, and access to the object in the function body.
Assume that edit the Go file <code>main.go</code> above:</p>
<pre><code class="language-go">package main

import (
  &quot;fmt&quot;

  &quot;github.com/second-state/WasmEdge-go/wasmedge&quot;
)

// Host function body definition.
func host_add(data interface{}, mem *wasmedge.Memory, params []interface{}) ([]interface{}, wasmedge.Result) {
  // add: i32, i32 -&gt; i32
  res := params[0].(int32) + params[1].(int32)

  // Set the returns
  returns := make([]interface{}, 1)
  returns[0] = res

  // Also set the result to the data.
  *data.(*int32) = res

  // Return
  return returns, wasmedge.Result_Success
}

func main() {
  // Create the VM object.
  vm := wasmedge.NewVM()

  // The WASM module buffer.
  wasmbuf := []byte{
    /* WASM header */
    0x00, 0x61, 0x73, 0x6D, 0x01, 0x00, 0x00, 0x00,
    /* Type section */
    0x01, 0x07, 0x01,
    /* function type {i32, i32} -&gt; {i32} */
    0x60, 0x02, 0x7F, 0x7F, 0x01, 0x7F,
    /* Import section */
    0x02, 0x13, 0x01,
    /* module name: &quot;extern&quot; */
    0x06, 0x65, 0x78, 0x74, 0x65, 0x72, 0x6E,
    /* extern name: &quot;func-add&quot; */
    0x08, 0x66, 0x75, 0x6E, 0x63, 0x2D, 0x61, 0x64, 0x64,
    /* import desc: func 0 */
    0x00, 0x00,
    /* Function section */
    0x03, 0x02, 0x01, 0x00,
    /* Export section */
    0x07, 0x0A, 0x01,
    /* export name: &quot;addTwo&quot; */
    0x06, 0x61, 0x64, 0x64, 0x54, 0x77, 0x6F,
    /* export desc: func 0 */
    0x00, 0x01,
    /* Code section */
    0x0A, 0x0A, 0x01,
    /* code body */
    0x08, 0x00, 0x20, 0x00, 0x20, 0x01, 0x10, 0x00, 0x0B,
  }

  // The additional data to set into the host function.
  var data int32 = 0

  // Create the import object with the module name &quot;extern&quot;.
  impobj := wasmedge.NewImportObject(&quot;extern&quot;)

  // Create and add a function instance into the import object with export name &quot;func-add&quot;.
  functype := wasmedge.NewFunctionType(
    []wasmedge.ValType{wasmedge.ValType_I32, wasmedge.ValType_I32},
    []wasmedge.ValType{wasmedge.ValType_I32},
  )
  hostfunc := wasmedge.NewFunction(functype, host_add, &amp;data, 0)
  functype.Release()
  impobj.AddFunction(&quot;func-add&quot;, hostfunc)

  // Register the import object into VM.
  vm.RegisterImport(impobj)

  res, err := vm.RunWasmBuffer(wasmbuf, &quot;addTwo&quot;, uint32(1234), uint32(5678))
  if err == nil {
    fmt.Println(&quot;Get the result:&quot;, res[0].(int32))
  } else {
    fmt.Println(&quot;Error message:&quot;, err.Error())
  }
  fmt.Println(&quot;Data value:&quot;, data)

  impobj.Release()
  vm.Release()
}
</code></pre>
<p>Then you can build and run the Golang application with the WasmEdge Golang SDK:</p>
<pre><code class="language-bash">$ go get github.com/second-state/WasmEdge-go/wasmedge@v0.9.2
$ go build
$ ./wasmedge_test
Get the result: 6912
Data value: 6912
</code></pre>
</li>
</ol>
<h2 id="wasmedge-aot-compiler-4"><a class="header" href="#wasmedge-aot-compiler-4">WasmEdge AOT Compiler</a></h2>
<p>In this partition, we will introduce the WasmEdge AOT compiler and the options in Go.
WasmEdge runs the WASM files in interpreter mode, and WasmEdge also supports the AOT (ahead-of-time) mode running without modifying any code.
The WasmEdge AOT (ahead-of-time) compiler compiles the WASM files for running in AOT mode which is much faster than interpreter mode. Developers can compile the WASM files into the compiled-WASM files in shared library format for universal WASM format for the AOT mode execution.</p>
<h3 id="compilation-example-4"><a class="header" href="#compilation-example-4">Compilation Example</a></h3>
<p>The <a href="https://github.com/second-state/WasmEdge-go-examples/tree/master/go_WasmAOT">go_WasmAOT example</a> provide a tool for compiling a WASM file.</p>
<h3 id="compiler-options-4"><a class="header" href="#compiler-options-4">Compiler Options</a></h3>
<p>Developers can set options for AOT compilers such as optimization level and output format:</p>
<pre><code class="language-go">const (
  // Disable as many optimizations as possible.
  CompilerOptLevel_O0 = CompilerOptimizationLevel(C.WasmEdge_CompilerOptimizationLevel_O0)
  // Optimize quickly without destroying debuggability.
  CompilerOptLevel_O1 = CompilerOptimizationLevel(C.WasmEdge_CompilerOptimizationLevel_O1)
  // Optimize for fast execution as much as possible without triggering significant incremental compile time or code size growth.
  CompilerOptLevel_O2 = CompilerOptimizationLevel(C.WasmEdge_CompilerOptimizationLevel_O2)
  // Optimize for fast execution as much as possible.
  CompilerOptLevel_O3 = CompilerOptimizationLevel(C.WasmEdge_CompilerOptimizationLevel_O3)
  // Optimize for small code size as much as possible without triggering significant incremental compile time or execution time slowdowns.
  CompilerOptLevel_Os = CompilerOptimizationLevel(C.WasmEdge_CompilerOptimizationLevel_Os)
  // Optimize for small code size as much as possible.
  CompilerOptLevel_Oz = CompilerOptimizationLevel(C.WasmEdge_CompilerOptimizationLevel_Oz)
)

const (
  // Native dynamic library format.
  CompilerOutputFormat_Native = CompilerOutputFormat(C.WasmEdge_CompilerOutputFormat_Native)
  // WebAssembly with AOT compiled codes in custom section.
  CompilerOutputFormat_Wasm = CompilerOutputFormat(C.WasmEdge_CompilerOutputFormat_Wasm)
)
</code></pre>
<p>Please refer to the <a href="sdk/go/0.9.1/ref.html#configurations">AOT compiler options configuration</a> for details.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="upgrade-to-wasmedge-go-v0100"><a class="header" href="#upgrade-to-wasmedge-go-v0100">Upgrade to WasmEdge-Go v0.10.0</a></h1>
<p>Due to the WasmEdge-Go API breaking changes, this document shows the guideline of programming with WasmEdge-Go API to upgrade from the <code>v0.9.2</code> to the <code>v0.10.0</code> version.</p>
<p><strong>Due to the <code>v0.9.1</code> is retracted, we use the version <code>v0.9.2</code> here.</strong></p>
<h2 id="concepts-2"><a class="header" href="#concepts-2">Concepts</a></h2>
<ol>
<li>
<p>Merged the <code>ImportObject</code> into the <code>Module</code>.</p>
<p>The <code>ImportObject</code> struct which is for the host functions is merged into <code>Module</code>.
Developers can use the related APIs to construct host modules.</p>
<ul>
<li><code>wasmedge.NewImportObject()</code> is changed to <code>wasmedge.NewModule()</code>.</li>
<li><code>(*wasmedge.ImportObject).Release()</code> is changed to <code>(*wasmedge.Module).Release()</code>.</li>
<li><code>(*wasmedge.ImportObject).AddFunction()</code> is changed to <code>(*wasmedge.Module).AddFunction()</code>.</li>
<li><code>(*wasmedge.ImportObject).AddTable()</code> is changed to <code>(*wasmedge.Module).AddTable()</code>.</li>
<li><code>(*wasmedge.ImportObject).AddMemory()</code> is changed to <code>(*wasmedge.Module).AddMemory()</code>.</li>
<li><code>(*wasmedge.ImportObject).AddGlobal()</code> is changed to <code>(*wasmedge.Module).AddGlobal()</code>.</li>
<li><code>(*wasmedge.ImportObject).NewWasiImportObject()</code> is changed to <code>(*wasmedge.Module).NewWasiModule()</code>.</li>
<li><code>(*wasmedge.ImportObject).NewWasmEdgeProcessImportObject()</code> is changed to <code>(*wasmedge.Module).NewWasmEdgeProcessModule()</code>.</li>
<li><code>(*wasmedge.ImportObject).InitWASI()</code> is changed to <code>(*wasmedge.Module).InitWASI()</code>.</li>
<li><code>(*wasmedge.ImportObject).InitWasmEdgeProcess()</code> is changed to <code>(*wasmedge.Module).InitWasmEdgeProcess()</code>.</li>
<li><code>(*wasmedge.ImportObject).WasiGetExitCode()</code> is changed to <code>(*wasmedge.Module).WasiGetExitCode</code>.</li>
<li><code>(*wasmedge.VM).RegisterImport()</code> is changed to <code>(*wasmedge.VM).RegisterModule()</code>.</li>
<li><code>(*wasmedge.VM).GetImportObject()</code> is changed to <code>(*wasmedge.VM).GetImportModule()</code>.</li>
</ul>
<p>For the new host function examples, please refer to <a href="sdk/go/0.9.1/upgrade_to_0.10.0.html#host-functions">the example below</a>.</p>
</li>
<li>
<p>Used the pointer to <code>Function</code> instead of the index in the <code>FuncRef</code> value type.</p>
<p>For the better performance and security, the <code>FuncRef</code> related APIs used the <code>*wasmedge.Function</code> for the parameters and returns.</p>
<ul>
<li><code>wasmedge.NewFuncRef()</code> is changed to use the <code>*Function</code> as it's argument.</li>
<li>Added <code>(wasmedge.FuncRef).GetRef()</code> to retrieve the <code>*Function</code>.</li>
</ul>
</li>
<li>
<p>Supported multiple anonymous WASM module instantiation.</p>
<p>In the version before <code>v0.9.2</code>, WasmEdge only supports 1 anonymous WASM module to be instantiated at one time. If developers instantiate a new WASM module, the old one will be replaced.
After the <code>v0.10.0</code> version, developers can instantiate multiple anonymous WASM module by <code>Executor</code> and get the <code>Module</code> instance. But for the source code using the <code>VM</code> APIs, the behavior is not changed.
For the new examples of instantiating multiple anonymous WASM modules, please refer to <a href="sdk/go/0.9.1/upgrade_to_0.10.0.html#wasmedge-executor-changes">the example below</a>.</p>
</li>
<li>
<p>Behavior changed of <code>Store</code>.</p>
<p>The <code>Function</code>, <code>Table</code>, <code>Memory</code>, and <code>Global</code> instances retrievement from the <code>Store</code> is moved to the <code>Module</code> instance. The <code>Store</code> only manage the module linking when instantiation and the named module searching after the <code>v0.10.0</code> version.</p>
<ul>
<li><code>(*wasmedge.Store).ListFunction()</code> and <code>(*wasmedge.Store).ListFunctionRegistered()</code> is replaced by <code>(*wasmedge.Module).ListFunction()</code>.</li>
<li><code>(*wasmedge.Store).ListTable()</code> and <code>(*wasmedge.Store).ListTableRegistered()</code> is replaced by <code>(*wasmedge.Module).ListTable()</code>.</li>
<li><code>(*wasmedge.Store).ListMemory()</code> and <code>(*wasmedge.Store).ListMemoryRegistered()</code> is replaced by <code>(*wasmedge.Module).ListMemory()</code>.</li>
<li><code>(*wasmedge.Store).ListGlobal()</code> and <code>(*wasmedge.Store).ListGlobalRegistered()</code> is replaced by <code>(*wasmedge.Module).ListGlobal()</code>.</li>
<li><code>(*wasmedge.Store).FindFunction()</code> and <code>(*wasmedge.Store).FindFunctionRegistered()</code> is replaced by <code>(*wasmedge.Module).FindFunction()</code>.</li>
<li><code>(*wasmedge.Store).FindTable()</code> and <code>(*wasmedge.Store).FindTableRegistered()</code> is replaced by <code>(*wasmedge.Module).FindTable()</code>.</li>
<li><code>(*wasmedge.Store).FindMemory()</code> and <code>(*wasmedge.Store).FindMemoryRegistered()</code> is replaced by <code>(*wasmedge.Module).FindMemory()</code>.</li>
<li><code>(*wasmedge.Store).FindGlobal()</code> and <code>(*wasmedge.Store).FindGlobalRegistered()</code> is replaced by <code>(*wasmedge.Module).FindGlobal()</code>.</li>
</ul>
<p>For the new examples of retrieving instances, please refer to <a href="sdk/go/0.9.1/upgrade_to_0.10.0.html#instances-retrievement">the example below</a>.</p>
</li>
<li>
<p>The <code>Module</code>-based resource management.</p>
<p>Except the creation of <code>Module</code> instance for the host functons, the <code>Executor</code> will output a <code>Module</code> instance after instantiation. No matter the anonymous or named modules, developers have the responsibility to destroy them by <code>(*wasmedge.Module).Release()</code> API.
The <code>Store</code> will link to the named <code>Module</code> instance after registering. After the destroyment of a <code>Module</code> instance, the <code>Store</code> will unlink to that automatically; after the destroyment of the <code>Store</code>, the all <code>Module</code> instances the <code>Store</code> linked to will unlink to that <code>Store</code> automatically.</p>
</li>
</ol>
<h2 id="wasmedge-go-vm-changes"><a class="header" href="#wasmedge-go-vm-changes">WasmEdge-Go VM changes</a></h2>
<p>The <code>VM</code> APIs are basically not changed, except the <code>ImportObject</code> related APIs.</p>
<p>The following is the example of WASI initialization in WasmEdge-Go <code>v0.9.2</code>:</p>
<pre><code class="language-go">conf := wasmedge.NewConfigure(wasmedge.WASI)
vm := wasmedge.NewVMWithConfig(conf)

// The following API can retrieve the pre-registration import objects from the VM object.
// This API will return `nil` if the corresponding pre-registration is not set into the configuration.
wasiobj := vm.GetImportObject(wasmedge.WASI)
// Initialize the WASI.
wasiobj.InitWasi(
  os.Args[1:],     // The args
  os.Environ(),    // The envs
  []string{&quot;.:.&quot;}, // The mapping preopens
)

// ...

vm.Release()
conf.Release()
</code></pre>
<p>Developers can change to use the WasmEdge-Go <code>v0.10.0</code> as follows, with only replacing the <code>ImportObject</code> into <code>Module</code>:</p>
<pre><code class="language-go">conf := wasmedge.NewConfigure(wasmedge.WASI)
vm := wasmedge.NewVMWithConfig(conf)

// The following API can retrieve the pre-registration module instances from the VM object.
// This API will return `nil` if the corresponding pre-registration is not set into the configuration.
wasiobj := vm.GetImportModule(wasmedge.WASI)
// Initialize the WASI.
wasiobj.InitWasi(
  os.Args[1:],     // The args
  os.Environ(),    // The envs
  []string{&quot;.:.&quot;}, // The mapping preopens
)

// ...

vm.Release()
conf.Release()
</code></pre>
<p>The <code>VM</code> provides a new API for getting the current instantiated anonymous <code>Module</code> instance.
For example, if developer want to get the exported <code>Global</code> instance:</p>
<pre><code class="language-go">// Assume that a WASM module is instantiated in `vm`, and exports the &quot;global_i32&quot;.
store := vm.GetStore()

globinst := store.FindGlobal(&quot;global_i32&quot;)
</code></pre>
<p>After the WasmEdge-Go <code>v0.10.0</code>, developers can use the <code>(*wasmedge.VM).GetActiveModule()</code> to get the module instance:</p>
<pre><code class="language-go">// Assume that a WASM module is instantiated in `vm`, and exports the &quot;global_i32&quot;.
mod := vm.GetActiveModule()

// The example of retrieving the global instance.
globinst := mod.FindGlobal(&quot;global_i32&quot;)
</code></pre>
<h2 id="wasmedge-executor-changes-1"><a class="header" href="#wasmedge-executor-changes-1">WasmEdge Executor changes</a></h2>
<p><code>Executor</code> helps to instantiate a WASM module, register a WASM module into <code>Store</code> with module name, register the host modules with host functions, or invoke functions.</p>
<ol>
<li>
<p>WASM module instantiation</p>
<p>In WasmEdge-Go <code>v0.9.2</code> version, developers can instantiate a WASM module by the <code>Executor</code> API:</p>
<pre><code class="language-go">var ast *wasmedge.AST
// Assume that `ast` is a loaded WASM from file or buffer and has passed the validation.
// Assume that `executor` is a `*wasmedge.Executor`.
// Assume that `store` is a `*wasmedge.Store`.
err := executor.Instantiate(store, ast)
if err != nil {
  fmt.Println(&quot;Instantiation FAILED:&quot;, err.Error())
}
</code></pre>
<p>Then the WASM module is instantiated into an anonymous module instance and handled by the <code>Store</code>.
If a new WASM module is instantiated by this API, the old instantiated module instance will be cleaned.
After the WasmEdge-Go <code>v0.10.0</code> version, the instantiated anonymous module will be outputed and handled by caller, and not only 1 anonymous module instance can be instantiated.
Developers have the responsibility to release the outputed module instances.</p>
<pre><code class="language-go">var ast1 *wasmedge.AST
var ast2 *wasmedge.AST
// Assume that `ast1` and `ast2` are loaded WASMs from different files or buffers,
// and have both passed the validation.
// Assume that `executor` is a `*wasmedge.Executor`.
// Assume that `store` is a `*wasmedge.Store`.
mod1, err1 := executor.Instantiate(store, ast1)
if err1 != nil {
  fmt.Println(&quot;Instantiation FAILED:&quot;, err1.Error())
}
mod2, err2 := executor.Instantiate(store, ast2)
if err2 != nil {
  fmt.Println(&quot;Instantiation FAILED:&quot;, err2.Error())
}
mod1.Release()
mod2.Release()
</code></pre>
</li>
<li>
<p>WASM module registration with module name</p>
<p>When instantiating and registering a WASM module with module name, developers can use the <code>(*wasmedge.Executor).RegisterModule()</code> API before WasmEdge-Go <code>v0.9.2</code>.</p>
<pre><code class="language-go">var ast *wasmedge.AST
// Assume that `ast` is a loaded WASM from file or buffer and has passed the validation.
// Assume that `executor` is a `*wasmedge.Executor`.
// Assume that `store` is a `*wasmedge.Store`.

// Register the WASM module into store with the export module name &quot;mod&quot;.
err := executor.RegisterModule(store, ast, &quot;mod&quot;)
if err != nil {
  fmt.Println(&quot;WASM registration FAILED:&quot;, err.Error())
}
</code></pre>
<p>The same feature is implemented in WasmEdge-Go <code>v0.10.0</code>, but in different API <code>(*wasmedge.Executor).Register()</code>:</p>
<pre><code class="language-go">var ast *wasmedge.AST
// Assume that `ast` is a loaded WASM from file or buffer and has passed the validation.
// Assume that `executor` is a `*wasmedge.Executor`.
// Assume that `store` is a `*wasmedge.Store`.

// Register the WASM module into store with the export module name &quot;mod&quot;.
mod, err := executor.Register(store, ast, &quot;mod&quot;)
if err != nil {
  fmt.Println(&quot;WASM registration FAILED:&quot;, err.Error())
}
mod.Release()
</code></pre>
<p>Developers have the responsibility to release the outputed module instances.</p>
</li>
<li>
<p>Host module registration</p>
<p>In WasmEdge-Go <code>v0.9.2</code>, developers can create an <code>ImportObject</code> and register into <code>Store</code>.</p>
<pre><code class="language-go">// Create the import object with the export module name.
impobj := wasmedge.NewImportObject(&quot;module&quot;)

// ...
// Add the host functions, tables, memories, and globals into the import object.

// The import object has already contained the export module name.
err := executor.RegisterImport(store, impobj)
if err != nil {
  fmt.Println(&quot;Import object registration FAILED:&quot;, err.Error())
}
</code></pre>
<p>After WasmEdge-Go <code>v0.10.0</code>, developers should use the <code>Module</code> instance instead:</p>
<pre><code class="language-go">// Create the module instance with the export module name.
impmod := wasmedge.NewModule(&quot;module&quot;)

// ...
// Add the host functions, tables, memories, and globals into the module instance.

// The module instance has already contained the export module name.
err := executor.RegisterImport(store, impmod)
if err != nil {
  fmt.Println(&quot;Module instance registration FAILED:&quot;, err.Error())
}
</code></pre>
<p>Developers have the responsibility to release the created module instances.</p>
</li>
<li>
<p>WASM function invocation</p>
<p>This example uses the <a href="https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/examples/wasm/fibonacci.wasm">fibonacci.wasm</a>, and the corresponding WAT file is at <a href="https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/examples/wasm/fibonacci.wat">fibonacci.wat</a>.
In WasmEdge-Go <code>v0.9.2</code> version, developers can invoke a WASM function with the export function name:</p>
<pre><code class="language-go">// Create the store object. The store object holds the instances.
store := wasmedge.NewStore()
// Error.
var err error
// AST object.
var ast *wasmedge.AST
// Return values.
var res []interface{}

// Create the loader object.
loader := wasmedge.NewLoader()
// Create the validator object.
validator := wasmedge.NewValidator()
// Create the executor object.
executor := wasmedge.NewExecutor()

// Load the WASM file or the compiled-WASM file and convert into the AST object.
ast, err = loader.LoadFile(&quot;fibonacci.wasm&quot;)
if err != nil {
  fmt.Println(&quot;Load WASM from file FAILED:&quot;, err.Error())
  return
}
// Validate the WASM module.
err = validator.Validate(ast)
if err != nil {
  fmt.Println(&quot;Validation FAILED:&quot;, err.Error())
  return
}
// Instantiate the WASM module into the Store object.
err = executor.Instantiate(store, ast)
if err != nil {
  fmt.Println(&quot;Instantiation FAILED:&quot;, err.Error())
  return
}
// Invoke the function which is exported with the function name &quot;fib&quot;.
res, err = executor.Invoke(store, &quot;fib&quot;, int32(30))
if err == nil {
  fmt.Println(&quot;Get fibonacci[30]:&quot;, res[0].(int32))
} else {
  fmt.Println(&quot;Run failed:&quot;, err.Error())
}

ast.Release()
loader.Release()
validator.Release()
executor.Release()
store.Release()
</code></pre>
<p>After the WasmEdge-Go <code>v0.10.0</code>, developers should retrieve the <code>Function</code> instance by function name first.</p>
<pre><code class="language-go">// ...
// Ignore the unchanged steps before validation. Please refer to the sample code above.

var mod *wasmedge.Module
// Instantiate the WASM module and get the output module instance.
mod, err = executor.Instantiate(store, ast)
if err != nil {
  fmt.Println(&quot;Instantiation FAILED:&quot;, err.Error())
  return
}
// Retrieve the function instance by name.
funcinst := mod.FindFunction(&quot;fib&quot;)
if funcinst == nil {
  fmt.Println(&quot;Run FAILED: Function name `fib` not found&quot;)
  return
}
res, err = executor.Invoke(store, funcinst, int32(30))
if err == nil {
  fmt.Println(&quot;Get fibonacci[30]:&quot;, res[0].(int32))
} else {
  fmt.Println(&quot;Run FAILED:&quot;, err.Error())
}

ast.Release()
mod.Release()
loader.Release()
validator.Release()
executor.Release()
store.Release()
</code></pre>
</li>
</ol>
<h2 id="instances-retrievement-1"><a class="header" href="#instances-retrievement-1">Instances retrievement</a></h2>
<p>This example uses the <a href="https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/examples/wasm/fibonacci.wasm">fibonacci.wasm</a>, and the corresponding WAT file is at <a href="https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/examples/wasm/fibonacci.wat">fibonacci.wat</a>.</p>
<p>Before the WasmEdge-Go <code>v0.9.2</code> versions, developers can retrieve all exported instances of named or anonymous modules from <code>Store</code>:</p>
<pre><code class="language-go">// Create the store object. The store object holds the instances.
store := wasmedge.NewStore()
// Error.
var err error
// AST object.
var ast *wasmedge.AST

// Create the loader object.
loader := wasmedge.NewLoader()
// Create the validator object.
validator := wasmedge.NewValidator()
// Create the executor object.
executor := wasmedge.NewExecutor()

// Load the WASM file or the compiled-WASM file and convert into the AST object.
ast, err = loader.LoadFile(&quot;fibonacci.wasm&quot;)
if err != nil {
  fmt.Println(&quot;Load WASM from file FAILED:&quot;, err.Error())
  return
}
// Validate the WASM module.
err = validator.Validate(ast)
if err != nil {
  fmt.Println(&quot;Validation FAILED:&quot;, err.Error())
  return
}
// Example: register and instantiate the WASM module with the module name &quot;module_fib&quot;.
err = executor.RegisterModule(store, ast, &quot;module_fib&quot;)
if err != nil {
  fmt.Println(&quot;Instantiation FAILED:&quot;, err.Error())
  return
}
// Example: Instantiate the WASM module into the Store object.
err = executor.Instantiate(store, ast)
if err != nil {
  fmt.Println(&quot;Instantiation FAILED:&quot;, err.Error())
  return
}

// Now, developers can retrieve the exported instances from the store.
// Take the exported functions as example. This WASM exports the function &quot;fib&quot;.
// Find the function &quot;fib&quot; from the instantiated anonymous module.
func1 := store.FindFunction(&quot;fib&quot;)
// Find the function &quot;fib&quot; from the registered module &quot;module_fib&quot;.
func2 := store.FindFunctionRegistered(&quot;module_fib&quot;, &quot;fib&quot;)

ast.Release()
store.Release()
loader.Release()
validator.Release()
executor.Release()
</code></pre>
<p>After the WasmEdge-Go <code>v0.10.0</code>, developers can instantiate several anonymous <code>Module</code> instances, and should retrieve the exported instances from named or anonymous <code>Module</code> instances:</p>
<pre><code class="language-go">// Create the store object. The store is the object to link the modules for imports and exports.
store := wasmedge.NewStore()
// Error.
var err error
// AST object.
var ast *wasmedge.AST
// Module instances.
var namedmod *wasmedge.Module
var anonymousmod *wasmedge.Module

// Create the loader object.
loader := wasmedge.NewLoader()
// Create the validator object.
validator := wasmedge.NewValidator()
// Create the executor object.
executor := wasmedge.NewExecutor()

// Load the WASM file or the compiled-WASM file and convert into the AST object.
ast, err = loader.LoadFile(&quot;fibonacci.wasm&quot;)
if err != nil {
  fmt.Println(&quot;Load WASM from file FAILED:&quot;, err.Error())
  return
}
// Validate the WASM module.
err = validator.Validate(ast)
if err != nil {
  fmt.Println(&quot;Validation FAILED:&quot;, err.Error())
  return
}
// Example: register and instantiate the WASM module with the module name &quot;module_fib&quot;.
namedmod, err = executor.Register(store, ast, &quot;module_fib&quot;)
if err != nil {
  fmt.Println(&quot;Instantiation FAILED:&quot;, err.Error())
  return
}
// Example: Instantiate the WASM module and get the output module instance.
anonymousmod, err = executor.Instantiate(store, ast)
if err != nil {
  fmt.Println(&quot;Instantiation FAILED:&quot;, err.Error())
  return
}

// Now, developers can retrieve the exported instances from the module instaces.
// Take the exported functions as example. This WASM exports the function &quot;fib&quot;.
// Find the function &quot;fib&quot; from the instantiated anonymous module.
func1 := anonymousmod.FindFunction(&quot;fib&quot;)
// Find the function &quot;fib&quot; from the registered module &quot;module_fib&quot;.
func2 := namedmod.FindFunction(&quot;fib&quot;)
// Or developers can get the named module instance from the store:
gotmod := store.FindModule(&quot;module_fib&quot;)
func3 := gotmod.FindFunction(&quot;fib&quot;)

namedmod.Release()
anonymousmod.Release()
ast.Release()
store.Release()
loader.Release()
validator.Release()
executor.Release()
</code></pre>
<h2 id="host-functions-8"><a class="header" href="#host-functions-8">Host functions</a></h2>
<p>The difference of host functions are the replacement of <code>ImportObject</code> struct.</p>
<pre><code class="language-go">// Host function body definition.
func host_add(data interface{}, mem *wasmedge.Memory, params []interface{}) ([]interface{}, wasmedge.Result) {
  // add: i32, i32 -&gt; i32
  res := params[0].(int32) + params[1].(int32)

  // Set the returns
  returns := make([]interface{}, 1)
  returns[0] = res

  // Return
  return returns, wasmedge.Result_Success
}

// ...

// Create an import object with the module name &quot;module&quot;.
impobj := wasmedge.NewImportObject(&quot;module&quot;)

// Create and add a function instance into the import object with export name &quot;add&quot;.
functype := wasmedge.NewFunctionType(
  []wasmedge.ValType{wasmedge.ValType_I32, wasmedge.ValType_I32},
  []wasmedge.ValType{wasmedge.ValType_I32},
)
hostfunc := wasmedge.NewFunction(functype, host_add, nil, 0)
// The third parameter is the pointer to the additional data object.
// Developers should guarantee the life cycle of the data, and it can be `nil`
// if the external data is not needed.
functype.Release()
impobj.AddFunction(&quot;add&quot;, hostfunc)

// The import object should be released.
// Developers should __NOT__ release the instances added into the import objects.
impobj.Release()
</code></pre>
<p>Developers can use the <code>Module</code> struct to upgrade to WasmEdge <code>v0.10.0</code> easily.</p>
<pre><code class="language-go">// Host function body definition.
func host_add(data interface{}, mem *wasmedge.Memory, params []interface{}) ([]interface{}, wasmedge.Result) {
  // add: i32, i32 -&gt; i32
  res := params[0].(int32) + params[1].(int32)

  // Set the returns
  returns := make([]interface{}, 1)
  returns[0] = res

  // Return
  return returns, wasmedge.Result_Success
}

// ...

// Create a module instance with the module name &quot;module&quot;.
mod := wasmedge.NewModule(&quot;module&quot;)

// Create and add a function instance into the module instance with export name &quot;add&quot;.
functype := wasmedge.NewFunctionType(
  []wasmedge.ValType{wasmedge.ValType_I32, wasmedge.ValType_I32},
  []wasmedge.ValType{wasmedge.ValType_I32},
)
hostfunc := wasmedge.NewFunction(functype, host_add, nil, 0)
// The third parameter is the pointer to the additional data object.
// Developers should guarantee the life cycle of the data, and it can be `nil`
// if the external data is not needed.
functype.Release()
mod.AddFunction(&quot;add&quot;, hostfunc)

// The module instances should be released.
// Developers should __NOT__ release the instances added into the module instance objects.
mod.Release()
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="wasmedge-nodejs-sdk"><a class="header" href="#wasmedge-nodejs-sdk">WasmEdge Node.js SDK</a></h1>
<p>In this tutorial, we will show you how to incorporate the WebAssembly functions written in Rust into Node.js applications on the server via the WasmEdge Node.js SDK. This approach combines Rust's <strong>performance</strong>, WebAssembly's <strong>security and portability</strong>, and JavaScript's <strong>ease-of-use</strong>. A typical application works like this.</p>
<ul>
<li>The host application is a Node.js web application written in JavaScript. It makes WebAssembly function calls.</li>
<li>The WebAssembly application is written in Rust. It runs inside the WasmEdge Runtime, and is called from the Node.js web application.</li>
</ul>
<blockquote>
<p><a href="https://github.com/second-state/wasmedge-nodejs-starter/fork">Fork this Github repository</a> to start coding!</p>
</blockquote>
<h2 id="prerequisites-8"><a class="header" href="#prerequisites-8">Prerequisites</a></h2>
<p>To set up a high-performance Node.js environment with Rust and WebAssembly, you will need the following:</p>
<ul>
<li>A modern Linux distribution, such as Ubuntu Server 20.04 LTS</li>
<li><a href="https://www.rust-lang.org/tools/install">Rust language</a></li>
<li><a href="https://nodejs.org/en/download/package-manager/">Node.js</a></li>
<li><a href="sdk/../quick_start/install.html#install-wasmedge-for-nodejs">The WasmEdge Runtime</a> for Node.js</li>
<li><a href="sdk/../write_wasm/rust/bindgen.html">The rustwasmc compiler toolchain</a></li>
</ul>
<h3 id="docker"><a class="header" href="#docker">Docker</a></h3>
<p>The easiest way to get started is to use Docker to build a dev environment. Just <a href="https://github.com/second-state/wasmedge-nodejs-starter/">clone this template project</a> to your computer and run the following Docker commands.</p>
<pre><code class="language-bash"># Get the code
git clone https://github.com/second-state/wasmedge-nodejs-starter
cd wasmedge-nodejs-starter

# Run Docker container
docker pull wasmedge/appdev_x86_64:0.8.2
docker run -p 3000:3000 --rm -it -v $(pwd):/app wasmedge/appdev_x86_64:0.8.2

# In docker
cd /app
</code></pre>
<p>That's it! You are now ready to compile and run the code.</p>
<h3 id="manual-setup-without-docker"><a class="header" href="#manual-setup-without-docker">Manual setup without Docker</a></h3>
<p>The commands are as follows.</p>
<pre><code class="language-bash"># Install Rust
curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh
source $HOME/.cargo/env
rustup override set 1.50.0

# Install Node.js and npm
curl -sL https://deb.nodesource.com/setup_14.x |  bash
sudo apt-get install -y nodejs npm

# Install rustwasmc toolchain
npm install -g rustwasmc # Append --unsafe-perm if permission denied

# OS dependencies for WasmEdge
sudo apt-get update
sudo apt-get -y upgrade
sudo apt install -y build-essential curl wget git vim libboost-all-dev llvm-dev liblld-10-dev

# Install the nodejs addon for WasmEdge
npm install wasmedge-core
npm install wasmedge-extensions
</code></pre>
<blockquote>
<p>The WasmEdge Runtime depends on the latest version of <code>libstdc++</code>. Ubuntu 20.04 LTS already has the latest libraries. If you are running an older Linux distribution, you have <a href="sdk//articles/ubuntu-req-ssvm-20200715/">several options to upgrade</a>.</p>
</blockquote>
<p>Next, clone the example source code repository.</p>
<pre><code class="language-bash">git clone https://github.com/second-state/wasmedge-nodejs-starter
cd wasmedge-nodejs-starter
</code></pre>
<h2 id="hello-world-3"><a class="header" href="#hello-world-3">Hello World</a></h2>
<p>The first example is a hello world to show you how various parts of the application fit together.</p>
<h3 id="webassembly-program-in-rust"><a class="header" href="#webassembly-program-in-rust">WebAssembly program in Rust</a></h3>
<p>In this example, our Rust program appends the input string after “hello”. Below is the content of the Rust program <code>src/lib.rs</code>. You can define multiple external functions in this library file, and all of them will be available to the host JavaScript app via WebAssembly. Just remember to annotate each function with <code>#[wasm_bindgen]</code> so that <a href="https://github.com/second-state/rustwasmc">rustwasmc</a> knows to generate the correct JavaScript to Rust interface for it when you build it.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use wasm_bindgen::prelude::*;

#[wasm_bindgen]
pub fn say(s: String) -&gt; String {
  let r = String::from(&quot;hello &quot;);
  return r + &amp;s;
}
<span class="boring">}
</span></code></pre></pre>
<p>Next, you can compile the Rust source code into WebAssembly bytecode and generate the accompanying JavaScript module for the Node.js host environment.</p>
<pre><code class="language-bash">rustwasmc build
</code></pre>
<p>The result are files in the <code>pkg/</code> directory. the <code>.wasm</code> file is the WebAssembly bytecode program, and the <code>.js</code> files are for the JavaScript module.</p>
<h3 id="the-nodejs-host-application"><a class="header" href="#the-nodejs-host-application">The Node.js host application</a></h3>
<p>Next, go to the <code>node</code> folder and examine the JavaScript program <code>app.js</code>. With the generated <code>wasmedge_nodejs_starter_lib.js</code> module, it is very easy to write JavaScript to call WebAssembly functions. Below is the node application <code>app.js</code>. It simply imports the <code>say()</code> function from the generated module. The node application takes the <code>name</code> parameter from incoming an HTTP GET request, and responds with “hello <code>name</code>”.</p>
<pre><code class="language-javascript">const { say } = require('../pkg/wasmedge_nodejs_starter_lib.js');

const http = require('http');
const url = require('url');
const hostname = '127.0.0.1';
const port = 3000;

const server = http.createServer((req, res) =&gt; {
  const queryObject = url.parse(req.url,true).query;
  res.statusCode = 200;
  res.setHeader('Content-Type', 'text/plain');
  res.end(say(queryObject['name']));
});

server.listen(port, hostname, () =&gt; {
  console.log(`Server running at http://${hostname}:${port}/`);
});
</code></pre>
<p>Start the Node.js application server as follows.</p>
<pre><code class="language-bash">$ node node/app.js
Server running at http://127.0.0.1:3000/
</code></pre>
<p>Then, you can test it from another terminal window.</p>
<pre><code class="language-bash">$ curl http://127.0.0.1:3000/?name=Wasm
hello Wasm
</code></pre>
<h2 id="a-complete-web-application"><a class="header" href="#a-complete-web-application">A complete web application</a></h2>
<p>The next example shows a web application that computes the roots for quadratic equations. Please checkout the <a href="https://github.com/second-state/wasm-learning/tree/master/nodejs/quadratic">full source code here</a>.</p>
<p>The user enters the values for <code>a</code>, <code>b</code>, <code>c</code> on the web form, and the web application calls the web service at <code>/solve</code> to compute the roots for the quadratic equation.</p>
<pre><code class="language-src">a*X^2 + b*X + c = 0
</code></pre>
<p>The roots for <code>X</code> are displayed in the area below the input form.</p>
<p><img src="https://www.secondstate.io/articles/getting-started-with-rust-function-01.png" alt="getting-started-with-rust-function" /></p>
<p>The <a href="https://github.com/second-state/wasm-learning/blob/master/nodejs/quadratic/node/public/index.html">HTML file</a> contains the client side JavaScript to submit the web form to <code>/solve</code>, and put result into the <code>#roots</code> HTML element on the page.</p>
<pre><code class="language-javascript">$(function() {
  var options = {
    target: '#roots',
    url: &quot;/solve&quot;,
    type: &quot;post&quot;
  };
  $('#solve').ajaxForm(options);
});
</code></pre>
<p>The <a href="https://github.com/second-state/wasm-learning/blob/master/nodejs/quadratic/node/server.js">Node.js application</a> behind the <code>/solve</code> URL endpoint is as follows. It reads the data from the input form, passes them into the <code>solve</code> function as an array, and puts the return value in the HTTP response.</p>
<pre><code class="language-javascript">app.post('/solve', function (req, res) {
  var a = parseFloat(req.body.a);
  var b = parseFloat(req.body.b);
  var c = parseFloat(req.body.c);
  res.send(solve([a, b, c]))
})
</code></pre>
<p>The <a href="https://github.com/second-state/wasm-learning/blob/master/nodejs/quadratic/src/lib.rs"><code>solve</code> function is written in Rust</a> and runs inside the WasmEdge Runtime. While the call arguments in the JavaScript side is an array of values, the Rust function receives a JSON object that encapsulates the array. In the Rust code, we first decode the JSON, perform the computation, and return the result values in a JSON string.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[wasm_bindgen]
pub fn solve(params: &amp;str) -&gt; String {
  let ps: (f32, f32, f32) = serde_json::from_str(&amp;params).unwrap();
  let discriminant: f32 = (ps.1 * ps.1) - (4. * ps.0 * ps.2);
  let mut solution: (f32, f32) = (0., 0.);
  if discriminant &gt;= 0. {
    solution.0 = (((-1.) * ps.1) + discriminant.sqrt()) / (2. * ps.0);
    solution.1 = (((-1.) * ps.1) - discriminant.sqrt()) / (2. * ps.0);
    return serde_json::to_string(&amp;solution).unwrap();
  } else {
    return String::from(&quot;not real numbers&quot;);
  }
}
<span class="boring">}
</span></code></pre></pre>
<p>Let's try it.</p>
<pre><code class="language-bash">rustwasmc build
npm install express # The application requires the Express framework in Node.js

node node/server.js
</code></pre>
<p>From the web browser, go to <code>http://ip-addr:8080/</code> to access this application. Note: If you are using Docker, make sure that the Docker container port 8080 is mapped to the host port 8080.</p>
<p>That’s it for the quadratic equation example.</p>
<h2 id="more-examples"><a class="header" href="#more-examples">More examples</a></h2>
<p>Besides passing string values between Rust and JavaScript, the <code>rustwasmc</code> tool supports the following data types.</p>
<ul>
<li>Rust call parameters can be any combo of <code>i32</code>, <code>String</code>, <code>&amp;str</code>, <code>Vec&lt;u8&gt;</code>, and <code>&amp;[u8]</code></li>
<li>Return value can be <code>i32</code> or <code>String</code> or <code>Vec&lt;u8&gt;</code> or void</li>
<li>For complex data types, such as structs, you could use JSON strings to pass data.</li>
</ul>
<blockquote>
<p>With JSON support, you can call Rust functions with any number of input parameters and return any number of return values of any type.</p>
</blockquote>
<p>The Rust program <code>src/lib.rs</code> in the <a href="https://github.com/second-state/wasm-learning/tree/master/nodejs/functions">functions example</a> demonstrates  how to pass in call arguments in various supported types, and return values.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[wasm_bindgen]
pub fn obfusticate(s: String) -&gt; String {
  (&amp;s).chars().map(|c| {
    match c {
      'A' ..= 'M' | 'a' ..= 'm' =&gt; ((c as u8) + 13) as char,
      'N' ..= 'Z' | 'n' ..= 'z' =&gt; ((c as u8) - 13) as char,
      _ =&gt; c
    }
  }).collect()
}

#[wasm_bindgen]
pub fn lowest_common_denominator(a: i32, b: i32) -&gt; i32 {
  let r = lcm(a, b);
  return r;
}

#[wasm_bindgen]
pub fn sha3_digest(v: Vec&lt;u8&gt;) -&gt; Vec&lt;u8&gt; {
  return Sha3_256::digest(&amp;v).as_slice().to_vec();
}

#[wasm_bindgen]
pub fn keccak_digest(s: &amp;[u8]) -&gt; Vec&lt;u8&gt; {
  return Keccak256::digest(s).as_slice().to_vec();
}
<span class="boring">}
</span></code></pre></pre>
<p>Perhaps the most interesting is the <code>create_line()</code> function. It takes two JSON strings, each representing a <code>Point</code> struct, and returns a JSON string representing a <code>Line</code> struct. Notice that both the <code>Point</code> and <code>Line</code> structs are annotated with <code>Serialize</code> and <code>Deserialize</code> so that the Rust compiler automatically generates necessary code to support their conversion to and from JSON strings.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use wasm_bindgen::prelude::*;
use serde::{Serialize, Deserialize};

#[derive(Serialize, Deserialize, Debug)]
struct Point {
  x: f32, 
  y: f32
}

#[derive(Serialize, Deserialize, Debug)]
struct Line {
  points: Vec&lt;Point&gt;,
  valid: bool,
  length: f32,
  desc: String
}

#[wasm_bindgen]
pub fn create_line (p1: &amp;str, p2: &amp;str, desc: &amp;str) -&gt; String {
  let point1: Point = serde_json::from_str(p1).unwrap();
  let point2: Point = serde_json::from_str(p2).unwrap();
  let length = ((point1.x - point2.x) * (point1.x - point2.x) + (point1.y - point2.y) * (point1.y - point2.y)).sqrt();

  let valid = if length == 0.0 { false } else { true };
  let line = Line { points: vec![point1, point2], valid: valid, length: length, desc: desc.to_string() };
  return serde_json::to_string(&amp;line).unwrap();
}

#[wasm_bindgen]
pub fn say(s: &amp;str) -&gt; String {
  let r = String::from(&quot;hello &quot;);
  return r + s;
}
<span class="boring">}
</span></code></pre></pre>
<p>Next, let's examine the JavaScript program <a href="https://github.com/second-state/wasm-learning/blob/master/nodejs/functions/node/app.js"><code>app.js</code></a>. It shows how to call the Rust functions. As you can see <code>String</code> and <code>&amp;str</code> are simply strings in JavaScript, <code>i32</code> are numbers, and <code>Vec&lt;u8&gt;</code> or <code>&amp;[8]</code> are JavaScript <code>Uint8Array</code>. JavaScript objects need to go through <code>JSON.stringify()</code> or <code>JSON.parse()</code> before being passed into or returned from Rust functions.</p>
<pre><code class="language-javascript">const { say, obfusticate, lowest_common_denominator, sha3_digest, keccak_digest, create_line } = require('./functions_lib.js');

var util = require('util');
const encoder = new util.TextEncoder();
console.hex = (d) =&gt; console.log((Object(d).buffer instanceof ArrayBuffer ? new Uint8Array(d.buffer) : typeof d === 'string' ? (new util.TextEncoder('utf-8')).encode(d) : new Uint8ClampedArray(d)).reduce((p, c, i, a) =&gt; p + (i % 16 === 0 ? i.toString(16).padStart(6, 0) + '  ' : ' ') + c.toString(16).padStart(2, 0) + (i === a.length - 1 || i % 16 === 15 ?  ' '.repeat((15 - i % 16) * 3) + Array.from(a).splice(i - i % 16, 16).reduce((r, v) =&gt; r + (v &gt; 31 &amp;&amp; v &lt; 127 || v &gt; 159 ? String.fromCharCode(v) : '.'), '  ') + '\n' : ''), ''));

console.log( say(&quot;WasmEdge&quot;) );
console.log( obfusticate(&quot;A quick brown fox jumps over the lazy dog&quot;) );
console.log( lowest_common_denominator(123, 2) );
console.hex( sha3_digest(encoder.encode(&quot;This is an important message&quot;)) );
console.hex( keccak_digest(encoder.encode(&quot;This is an important message&quot;)) );

var p1 = {x:1.5, y:3.8};
var p2 = {x:2.5, y:5.8};
var line = JSON.parse(create_line(JSON.stringify(p1), JSON.stringify(p2), &quot;A thin red line&quot;));
console.log( line );
</code></pre>
<p>After running <code>rustwasmc</code> to build the Rust library, running <code>app.js</code> in Node.js environment produces the following output.</p>
<pre><code class="language-bash">$ rustwasmc build
... Building the wasm file and JS shim file in pkg/ ...

$ node node/app.js
hello WasmEdge
N dhvpx oebja sbk whzcf bire gur ynml qbt
246
000000  57 1b e7 d1 bd 69 fb 31 9f 0a d3 fa 0f 9f 9a b5  W.çÑ½iû1..Óú...µ
000010  2b da 1a 8d 38 c7 19 2d 3c 0a 14 a3 36 d3 c3 cb  +Ú..8Ç.-&lt;..£6ÓÃË

000000  7e c2 f1 c8 97 74 e3 21 d8 63 9f 16 6b 03 b1 a9  ~ÂñÈ.tã!Øc..k.±©
000010  d8 bf 72 9c ae c1 20 9f f6 e4 f5 85 34 4b 37 1b  Ø¿r.®Á .öäõ.4K7.

{ points: [ { x: 1.5, y: 3.8 }, { x: 2.5, y: 5.8 } ],
  valid: true,
  length: 2.2360682,
  desc: 'A thin red line' }  
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="wasmedge-rust-sdk"><a class="header" href="#wasmedge-rust-sdk">WasmEdge Rust SDK</a></h1>
<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->
<!-- code_chunk_output -->
<ul>
<li><a href="sdk/rust.html#wasmedge-rust-sdk">WasmEdge Rust SDK</a>
<ul>
<li><a href="sdk/rust.html#introduction">Introduction</a></li>
<li><a href="sdk/rust.html#versioning-table">Versioning Table</a></li>
<li><a href="sdk/rust.html#build">Build</a></li>
<li><a href="sdk/rust.html#wasmedge-sys-crate"><code>wasmedge-sys</code> crate</a></li>
<li><a href="sdk/rust.html#enable-wasmedge-plugins">Enable WasmEdge Plugins</a></li>
<li><a href="sdk/rust.html#docker-image">Docker image</a></li>
<li><a href="sdk/rust.html#examples">Examples</a>
<ul>
<li><a href="sdk/rust.html#wasmedge-sdk-examples"><code>wasmedge-sdk</code> Examples</a></li>
<li><a href="sdk/rust.html#wasmedge-sys-examples"><code>wasmedge-sys</code> Examples</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<!-- /code_chunk_output -->
<h2 id="introduction-1"><a class="header" href="#introduction-1">Introduction</a></h2>
<p><code>WasmEdge</code> supports embedding into Rust applications via WasmEdge Rust SDK. WasmEdge Rust SDK consists of three crates:</p>
<ul>
<li>
<p><a href="https://crates.io/crates/wasmedge-sdk">wasmedge-sdk</a> crate. It defines a group of safe, ergonomic high-level APIs, which are used to build up business applications.</p>
<ul>
<li><a href="https://wasmedge.github.io/WasmEdge/wasmedge_sdk/">API documentation</a></li>
</ul>
</li>
<li>
<p><a href="https://crates.io/crates/wasmedge-sys">wasmedge-sys</a> crate. It defines a group of low-level Rust APIs, which simply wrap WasmEdge C-API and provide the safe counterparts. It is not recommended to use it directly to build up application.</p>
<ul>
<li><a href="https://wasmedge.github.io/WasmEdge/wasmedge_sys/">API documentation</a></li>
</ul>
</li>
<li>
<p><a href="https://crates.io/crates/wasmedge-types">wasmedge-types</a> crate. The data structures that are commonly used in <code>wasmedge-sdk</code> and <code>wasmedge-sys</code> are defined in this crate.</p>
<ul>
<li><a href="https://wasmedge.github.io/WasmEdge/wasmedge_types/">API documentation</a></li>
</ul>
</li>
</ul>
<h2 id="versioning-table"><a class="header" href="#versioning-table">Versioning Table</a></h2>
<p>The following table provides the versioning information about each release of <code>wasmedge-sdk</code> crate and its dependencies.</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">wasmedge-sdk</th><th style="text-align: center">WasmEdge lib</th><th style="text-align: center">wasmedge-sys</th><th style="text-align: center">wasmedge-types</th><th style="text-align: center">wasmedge-macro</th></tr></thead><tbody>
<tr><td style="text-align: center">0.5.0</td><td style="text-align: center">0.11.1</td><td style="text-align: center">0.10</td><td style="text-align: center">0.3.0</td><td style="text-align: center">0.1.0</td></tr>
<tr><td style="text-align: center">0.4.0</td><td style="text-align: center">0.11.0</td><td style="text-align: center">0.9</td><td style="text-align: center">0.2.1</td><td style="text-align: center">-</td></tr>
<tr><td style="text-align: center">0.3.0</td><td style="text-align: center">0.10.1</td><td style="text-align: center">0.8</td><td style="text-align: center">0.2</td><td style="text-align: center">-</td></tr>
<tr><td style="text-align: center">0.1.0</td><td style="text-align: center">0.10.0</td><td style="text-align: center">0.7</td><td style="text-align: center">0.1</td><td style="text-align: center">-</td></tr>
</tbody></table>
</div>
<h2 id="build-1"><a class="header" href="#build-1">Build</a></h2>
<p>To use <code>wasmedge-sdk</code> in your project, you should finish the following two steps before building your project:</p>
<ul>
<li>
<p>First, deploy <code>WasmEdge</code> library on your local system.</p>
<p>You can reference the versioning table and download <code>WasmEdge</code> library from <a href="https://github.com/WasmEdge/WasmEdge/releases">WasmEdge Releases Page</a>. After download the <code>WasmEdge</code> library, you can choose one of the following three ways to specify the locations of the required files:</p>
<ul>
<li>
<p>By default location</p>
<p>For those who do not want to define environment variables, you can put the downloaded <code>WasmEdge</code> binary package in the default location <code>$HOME/.wasmedge/</code>. The directory structure of the default location should looks like below:</p>
<pre><code class="language-bash">// $HOME/.wasmedge/ on Ubuntu-20.04
.
├── bin
│   ├── wasmedge
│   └── wasmedgec
├── include
│   └── wasmedge
│       ├── enum.inc
│       ├── enum_configure.h
│       ├── enum_errcode.h
│       ├── enum_types.h
│       ├── int128.h
│       ├── version.h
│       └── wasmedge.h
└── lib64
    ├── libwasmedge.so
    └── wasmedge
        └── libwasmedgePluginWasmEdgeProcess.so

5 directories, 11 files
</code></pre>
<pre><code class="language-bash">// $HOME/.wasmedge/ on macOS-12
.
├── bin
│   ├── wasmedge
│   └── wasmedgec
├── include
│   └── wasmedge
│       ├── enum.inc
│       ├── enum_configure.h
│       ├── enum_errcode.h
│       ├── enum_types.h
│       ├── int128.h
│       ├── version.h
│       └── wasmedge.h
└── lib
    └── libwasmedge.dylib

4 directories, 10 files
</code></pre>
</li>
<li>
<p>By specifying <code>WASMEDGE_INCLUDE_DIR</code> and <code>WASMEDGE_LIB_DIR</code>.</p>
<p>If you choose to use <a href="https://github.com/WasmEdge/WasmEdge/blob/master/utils/install.sh">install.sh</a> to install WasmEdge Runtime on your local system, please use <code>WASMEDGE_INCLUDE_DIR</code> and <code>WASMEDGE_LIB_DIR</code> to specify the paths to the <code>include</code> and <code>lib</code> directories respectively.
For example, use the following commands to specify the paths after using <code>bash install.sh --path=$HOME/wasmedge-install</code> to install WasmEdge Runtime on Ubuntu 20.04:</p>
<pre><code class="language-bash">export WASMEDGE_INCLUDE_DIR=$HOME/wasmedge-install/include 
export WASMEDGE_LIB_DIR=$HOME/wasmedge-install/lib
</code></pre>
</li>
<li>
<p>By specifying <code>WASMEDGE_BUILD_DIR</code></p>
<p>You can choose this way if you'd like to use the latest code in the <code>master</code> branch of the <code>WasmEdge</code> github repo. For example,</p>
<ul>
<li>
<p>Suppose that you <code>git clone</code> WasmEdge repo in your local directory, for example, <code>~/workspace/me/WasmEdge</code>, and follow the <a href="sdk/../contribute/build_from_src/linux.html">instructions to build</a> WasmEdge native library. After that, you should find the generated <code>include</code> and <code>lib</code> directories in <code>~/workspace/me/WasmEdge/build</code>.</p>
</li>
<li>
<p>Then, set <code>WASMEDGE_BUILD_DIR</code> environment variable to specify the <code>build</code> directory.</p>
<pre><code class="language-bash">root@0a877562f39e:~/workspace/me/WasmEdge# export WASMEDGE_BUILD_DIR=/root/workspace/me/WasmEdge/build
</code></pre>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Second, after deploy the <code>WasmEdge</code> library on your local system, copy/paste the following code into the <code>Cargo.toml</code> file of your project. Now, you can use <code>cargo build</code> command to build your project.</p>
</li>
</ul>
<pre><code class="language-toml">[dependencies]
wasmedge-sdk = &quot;0.4&quot;
</code></pre>
<h2 id="wasmedge-sys-crate"><a class="header" href="#wasmedge-sys-crate"><code>wasmedge-sys</code> crate</a></h2>
<p><code>wasmedge-sys</code> serves as a wraper layer of <code>WasmEdge</code> C-API, and provides a group of safe low-level Rust interfaces.
For those who are interested in using <code>wasmedge-sys</code> in their projects, you should also deploy the <code>WasmEdge</code> library on your local system as described in the <a href="sdk/rust.html#build">wasmedge-sdk crate</a> section.
Then, copy/paste the following code in the <code>Cargo.toml</code> file of your project.
For details, please refer to <a href="https://github.com/WasmEdge/WasmEdge/blob/master/bindings/rust/wasmedge-sys/README.md">README</a>.</p>
<pre><code class="language-toml">[dependencies]
wasmedge-sys = &quot;0.9&quot;
</code></pre>
<h2 id="enable-wasmedge-plugins"><a class="header" href="#enable-wasmedge-plugins">Enable WasmEdge Plugins</a></h2>
<p>If you'd like to enable WasmEdge Plugins (currently, only available on Linux platform), please use <code>WASMEDGE_PLUGIN_PATH</code> environment variable to specify the path to the directory containing the plugins. For example, use the following commands to specify the path on Ubuntu 20.04:</p>
<pre><code class="language-bash">export WASMEDGE_PLUGIN_PATH=$HOME/.wasmedge/lib/wasmedge
</code></pre>
<h2 id="docker-image"><a class="header" href="#docker-image">Docker image</a></h2>
<p>For those who would like to dev in Docker environment, you can reference the <a href="sdk/../quick_start/use_docker.html">Use Docker</a> section of this book, which details how to use Docker for <code>WasmEdge</code> application development.</p>
<h2 id="examples-3"><a class="header" href="#examples-3">Examples</a></h2>
<p>For helping you get familiar with WasmEdge Rust bindings, the following quick examples demonstrate how to use the APIs defined in <code>wasmedge-sdk</code> and <code>wasmedge-sys</code>, respectively. In addition, we'll add more examples continuously. Please file issues <a href="https://github.com/WasmEdge/WasmEdge/issues">here</a> and let us know if you have any problems with the API usage.</p>
<h3 id="wasmedge-sdk-examples"><a class="header" href="#wasmedge-sdk-examples"><code>wasmedge-sdk</code> Examples</a></h3>
<ul>
<li>
<p><a href="sdk/rust/say_hello.html">[wasmedge-sdk] Hello World!</a></p>
</li>
<li>
<p><a href="sdk/rust/memory_manipulation.html">[wasmedge-sdk] Memory manipulation</a></p>
</li>
<li>
<p><a href="sdk/rust/table_and_funcref.html">[wasmedge-sdk] Table and FuncRef</a></p>
</li>
<li>
<p><a href="https://github.com/WasmEdge/WasmEdge/tree/master/bindings/rust/wasmedge-sdk/examples">More examples</a></p>
</li>
</ul>
<h3 id="wasmedge-sys-examples"><a class="header" href="#wasmedge-sys-examples"><code>wasmedge-sys</code> Examples</a></h3>
<ul>
<li>
<p><a href="sdk/rust/sys_run_host_func.html">[wasmedge-sys] Run a WebAssembly function with WasmEdge low-level APIs</a></p>
</li>
<li>
<p><a href="sdk/rust/concurrent_fib.html">[wasmedge-sys] Compute Fibonacci numbers concurrently</a></p>
</li>
<li>
<p><a href="sdk/rust/how_to_use_module_instance.html">[wasmedge-sys] The usage of WasmEdge module instances</a></p>
</li>
<li>
<p><a href="https://github.com/WasmEdge/WasmEdge/tree/master/bindings/rust/wasmedge-sys/examples">More examples</a></p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hello-world-4"><a class="header" href="#hello-world-4">Hello World</a></h1>
<p>In this example, we'll use a wasm module, in which a function <code>run</code> is exported and it will call a function <code>say_hello</code> from an import module named <code>env</code>. The imported function <code>say_hello</code> has no inputs and outputs, and only prints a greeting message out.</p>
<blockquote>
<p>The code in the following example is verified on</p>
<ul>
<li>wasmedge-sdk v0.5.0</li>
<li>wasmedge-sys v0.10.0</li>
<li>wasmedge-types v0.3.0</li>
</ul>
</blockquote>
<p>Let's start off by getting all imports right away so you can follow along</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// please add this feature if you're using rust of version &lt; 1.63
// #![feature(explicit_generic_args_with_impl_trait)]

#![feature(never_type)]

use wasmedge_sdk::{
    error::HostFuncError, host_function, params, wat2wasm, Caller, Executor, ImportObjectBuilder,
    Module, Store, WasmValue,
};

<span class="boring">}
</span></code></pre></pre>
<h2 id="step-1-define-a-native-function-and-create-an-importobject"><a class="header" href="#step-1-define-a-native-function-and-create-an-importobject">Step 1: Define a native function and Create an ImportObject</a></h2>
<p>First, let's define a native function named <code>say_hello_world</code> that prints out <code>Hello, World!</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[host_function]
fn say_hello(caller: &amp;Caller, _args: Vec&lt;WasmValue&gt;) -&gt; Result&lt;Vec&lt;WasmValue&gt;, HostFuncError&gt; {
    println!(&quot;Hello, world!&quot;);

    Ok(vec![])
}
<span class="boring">}
</span></code></pre></pre>
<p>To use the native function as an import function in the <code>WasmEdge</code> runtime, we need an <code>ImportObject</code>. <code>wasmedge-sdk</code> defines a <a href="https://wasmedge.github.io/WasmEdge/wasmedge_sdk/struct.ImportObjectBuilder.html">ImportObjectBuilder</a>, which provides a group of chaining methods used to create an <code>ImportObject</code>. Let's see how to do it.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// create an import module
let import = ImportObjectBuilder::new()
    .with_func::&lt;(), (), !&gt;(&quot;say_hello&quot;, say_hello, None)?
    .build(&quot;env&quot;)?;
<span class="boring">}
</span></code></pre></pre>
<p>Now, we have an import module named <code>env</code> which holds a host function <code>say_hello</code>. As you may notice, the names we used for the import module and the host function are exactly the same as the ones appearing in the wasm module. You can find the wasm module in <a href="sdk/rust/say_hello.html#step-2-load-a-wasm-module">Step 2</a>.</p>
<h2 id="step-2-load-a-wasm-module"><a class="header" href="#step-2-load-a-wasm-module">Step 2: Load a wasm module</a></h2>
<p>Now, let's load a wasm module. <code>wasmedge-sdk</code> defines two methods in <code>Module</code>:</p>
<ul>
<li>
<p><a href="https://wasmedge.github.io/WasmEdge/wasmedge_sdk/struct.Module.html#method.from_file">from_file</a> loads a wasm module from a file, and meanwhile, validates the loaded wasm module.</p>
</li>
<li>
<p><a href="https://wasmedge.github.io/WasmEdge/wasmedge_sdk/struct.Module.html#method.from_bytes">from_bytes</a> loads a wasm module from an array of in-memory bytes, and meanwhile, validates the loaded wasm module.</p>
</li>
</ul>
<p>Here we choose <code>Module::from_bytes</code> method to load our wasm module from an array of in-memory bytes.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let wasm_bytes = wat2wasm(
    br#&quot;
(module
    ;; First we define a type with no parameters and no results.
    (type $no_args_no_rets_t (func (param) (result)))

    ;; Then we declare that we want to import a function named &quot;env&quot; &quot;say_hello&quot; with
    ;; that type signature.
    (import &quot;env&quot; &quot;say_hello&quot; (func $say_hello (type $no_args_no_rets_t)))

    ;; Finally we create an entrypoint that calls our imported function.
    (func $run (type $no_args_no_rets_t)
    (call $say_hello))
    ;; And mark it as an exported function named &quot;run&quot;.
    (export &quot;run&quot; (func $run)))
&quot;#,
)?;

// loads a wasm module from the given in-memory bytes and returns a compiled module
let module = Module::from_bytes(None, &amp;wasm_bytes)?;
<span class="boring">}
</span></code></pre></pre>
<h2 id="step-3-register-import-module-and-compiled-module"><a class="header" href="#step-3-register-import-module-and-compiled-module">Step 3: Register import module and compiled module</a></h2>
<p>To register a compiled module, we need to check if it has dependency on some import modules. In the wasm module this statement <code>(import &quot;env&quot; &quot;say_hello&quot; (func $say_hello (type $no_args_no_rets_t)))</code> tells us that it depends on an import module named <code>env</code>. Therefore, we need to register the import module first before registering the compiled wasm module.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// loads a wasm module from the given in-memory bytes
let module = Module::from_bytes(None, &amp;wasm_bytes)?;

// create an executor
let mut executor = Executor::new(None, None)?;

// create a store
let mut store = Store::new()?;

// register the module into the store
store.register_import_module(&amp;mut executor, &amp;import)?;

// register the compiled module into the store and get an module instance
let extern_instance = store.register_named_module(&amp;mut executor, &quot;extern&quot;, &amp;module)?;
<span class="boring">}
</span></code></pre></pre>
<p>In the code above we use <a href="https://wasmedge.github.io/WasmEdge/wasmedge_sdk/struct.Executor.html">Executor</a> and <a href="https://wasmedge.github.io/WasmEdge/wasmedge_sdk/struct.Store.html">Store</a> to register the import module and the compiled module. <code>wasmedge-sdk</code> also provides alternative APIs to do the same thing:
<a href="https://wasmedge.github.io/WasmEdge/wasmedge_sdk/struct.Vm.html#method.register_import_module">Vm::register_import_module</a> and <a href="https://wasmedge.github.io/WasmEdge/wasmedge_sdk/struct.Vm.html#method.register_module_from_bytes">Vm::register_module_from_bytes</a>.</p>
<h2 id="step-4-run-the-exported-function"><a class="header" href="#step-4-run-the-exported-function">Step 4: Run the exported function</a></h2>
<p>Now we are ready to run the exported function.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// get the exported function &quot;run&quot;
let run = extern_instance
    .func(&quot;run&quot;)
    .ok_or_else(|| anyhow::Error::msg(&quot;Not found exported function named 'run'.&quot;))?;

// run host function
run.call(&amp;mut executor, params!())?;
<span class="boring">}
</span></code></pre></pre>
<p>In this example we created an instance of <code>Executor</code>, hence, we have two choices to call a <a href="https://wasmedge.github.io/WasmEdge/wasmedge_sdk/struct.Func.html">function instance</a>:</p>
<ul>
<li>
<p><a href="https://wasmedge.github.io/WasmEdge/wasmedge_sdk/struct.Func.html#method.call">Func::call</a></p>
</li>
<li>
<p><a href="https://wasmedge.github.io/WasmEdge/wasmedge_sdk/trait.Engine.html#tymethod.run_func">Executor::run_func</a></p>
</li>
</ul>
<p>Any one of these two methods requires that you have to get a <a href="https://wasmedge.github.io/WasmEdge/wasmedge_sdk/struct.Func.html">function instance</a>.</p>
<p>In addition, <a href="https://wasmedge.github.io/WasmEdge/wasmedge_sdk/struct.Vm.html">Vm</a> defines a group of methods which can invoke host function in different ways. For details, please reference <a href="https://wasmedge.github.io/WasmEdge/wasmedge_sdk/struct.Vm.html">Vm</a>.</p>
<p>The complete example can be found in <a href="https://github.com/WasmEdge/WasmEdge/blob/master/bindings/rust/wasmedge-sdk/examples/hello_world.rs">hello_world.rs</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="memory-manipulation"><a class="header" href="#memory-manipulation">Memory Manipulation</a></h1>
<p>In this example, we'll present how to manipulate the linear memory with the APIs defined in <a href="https://wasmedge.github.io/WasmEdge/wasmedge_sdk/struct.Memory.html">wasmedge_sdk::Memory</a>.</p>
<blockquote>
<p>The code in the following example is verified on</p>
<ul>
<li>wasmedge-sdk v0.5.0</li>
<li>wasmedge-sys v0.10.0</li>
<li>wasmedge-types v0.3.0</li>
</ul>
</blockquote>
<h2 id="wasm-module"><a class="header" href="#wasm-module">Wasm module</a></h2>
<p>Before talking about the code, let's first see the wasm module we use in this example. In the wasm module, a linear memory of 1-page (64KiB) size is defined; in addition, three functions are exported from this module: <code>get_at</code>, <code>set_at</code>, and <code>mem_size</code>.</p>
<pre><code class="language-wasm">(module
  (type $mem_size_t (func (result i32)))
  (type $get_at_t (func (param i32) (result i32)))
  (type $set_at_t (func (param i32) (param i32)))

  # A memory with initial size of 1 page
  (memory $mem 1)

  (func $get_at (type $get_at_t) (param $idx i32) (result i32)
    (i32.load (local.get $idx)))

  (func $set_at (type $set_at_t) (param $idx i32) (param $val i32)
    (i32.store (local.get $idx) (local.get $val)))

  (func $mem_size (type $mem_size_t) (result i32)
    (memory.size))
  
  # Exported functions
  (export &quot;get_at&quot; (func $get_at))
  (export &quot;set_at&quot; (func $set_at))
  (export &quot;mem_size&quot; (func $mem_size))
  (export &quot;memory&quot; (memory $mem)))
</code></pre>
<p>Next, we'll demonstrate how to manipulate the linear memory by calling the exported functions.</p>
<h2 id="load-and-register-module"><a class="header" href="#load-and-register-module">Load and Register Module</a></h2>
<p>Let's start off by getting all imports right away so you can follow along</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// please add this feature if you're using rust of version &lt; 1.63
// #![feature(explicit_generic_args_with_impl_trait)]

use wasmedge_sdk::{params, wat2wasm, Executor, Module, Store, WasmVal};
<span class="boring">}
</span></code></pre></pre>
<p>To load a <code>Module</code>, <code>wasmedge-sdk</code> defines two methods:</p>
<ul>
<li>
<p><a href="https://wasmedge.github.io/WasmEdge/wasmedge_sdk/struct.Module.html#method.from_file">from_file</a> loads a wasm module from a file, and meanwhile, validates the loaded wasm module.</p>
</li>
<li>
<p><a href="https://wasmedge.github.io/WasmEdge/wasmedge_sdk/struct.Module.html#method.from_bytes">from_bytes</a> loads a wasm module from an array of in-memory bytes, and meanwhile, validates the loaded wasm module.</p>
</li>
</ul>
<p>Here we use <code>Module::from_bytes</code> method to load our wasm module from an array of in-memory bytes.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let wasm_bytes = wat2wasm(
        r#&quot;
(module
  (type $mem_size_t (func (result i32)))
  (type $get_at_t (func (param i32) (result i32)))
  (type $set_at_t (func (param i32) (param i32)))

  (memory $mem 1)

  (func $get_at (type $get_at_t) (param $idx i32) (result i32)
    (i32.load (local.get $idx)))

  (func $set_at (type $set_at_t) (param $idx i32) (param $val i32)
    (i32.store (local.get $idx) (local.get $val)))

  (func $mem_size (type $mem_size_t) (result i32)
    (memory.size))

  (export &quot;get_at&quot; (func $get_at))
  (export &quot;set_at&quot; (func $set_at))
  (export &quot;mem_size&quot; (func $mem_size))
  (export &quot;memory&quot; (memory $mem)))
&quot;#
    .as_bytes(),
)?;

// loads a wasm module from the given in-memory bytes
let module = Module::from_bytes(None, &amp;wasm_bytes)?;
<span class="boring">}
</span></code></pre></pre>
<p>The module returned by <code>Module::from_bytes</code> is a compiled module, also called AST Module in WasmEdge terminology. To use it in WasmEdge runtime environment, we need to instantiate the AST module. We use <a href="https://wasmedge.github.io/WasmEdge/wasmedge_sdk/struct.Store.html#method.register_named_module">Store::register_named_module</a> API to achieve the goal.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// create an executor
let mut executor = Executor::new(None, None)?;

// create a store
let mut store = Store::new()?;

// register the module into the store
let extern_instance = store.register_named_module(&amp;mut executor, &quot;extern&quot;, &amp;module)?;
<span class="boring">}
</span></code></pre></pre>
<p>In the code above, we register the AST module into a <code>Store</code>, in which the module is instantiated, and as a result, a <a href="https://wasmedge.github.io/WasmEdge/wasmedge_sdk/struct.Instance.html">module instance</a> named <code>extern</code> is returned.</p>
<h2 id="memory"><a class="header" href="#memory">Memory</a></h2>
<p>In the previous section, we get an instance by registering a compiled module into the runtime environment. Now we retrieve the memory instance from the module instance, and make use of the APIs defined in <a href="https://wasmedge.github.io/WasmEdge/wasmedge_sdk/struct.Memory.html">Memory</a> to manipulate the linear memory.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// get the exported memory instance
let mut memory = extern_instance
    .memory(&quot;memory&quot;)
    .ok_or_else(|| anyhow::anyhow!(&quot;failed to get memory instance named 'memory'&quot;))?;

// check memory size
assert_eq!(memory.size(), 1);
assert_eq!(memory.data_size(), 65536);

// grow memory size
memory.grow(2)?;
assert_eq!(memory.size(), 3);
assert_eq!(memory.data_size(), 3 * 65536);

// get the exported functions: &quot;set_at&quot; and &quot;get_at&quot;
let set_at = extern_instance
    .func(&quot;set_at&quot;)
    .ok_or_else(|| anyhow::Error::msg(&quot;Not found exported function named 'set_at'.&quot;))?;
let get_at = extern_instance
    .func(&quot;get_at&quot;)
    .ok_or_else(|| anyhow::Error::msg(&quot;Not found exported function named 'get_at`.&quot;))?;

// call the exported function named &quot;set_at&quot;
let mem_addr = 0x2220;
let val = 0xFEFEFFE;
set_at.call(&amp;mut executor, params!(mem_addr, val))?;

// call the exported function named &quot;get_at&quot;
let returns = get_at.call(&amp;mut executor, params!(mem_addr))?;
assert_eq!(returns[0].to_i32(), val);

// call the exported function named &quot;set_at&quot;
let page_size = 0x1_0000;
let mem_addr = (page_size * 2) - std::mem::size_of_val(&amp;val) as i32;
let val = 0xFEA09;
set_at.call(&amp;mut executor, params!(mem_addr, val))?;

// call the exported function named &quot;get_at&quot;
let returns = get_at.call(&amp;mut executor, params!(mem_addr))?;
assert_eq!(returns[0].to_i32(), val);
<span class="boring">}
</span></code></pre></pre>
<p>The comments in the code explain the meaning of the code sample above, so we don't describe more.</p>
<p>The complete code of this example can be found in <a href="https://github.com/WasmEdge/WasmEdge/blob/master/bindings/rust/wasmedge-sdk/examples/memory.rs">memory.rs</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="table-and-funcref"><a class="header" href="#table-and-funcref">Table and FuncRef</a></h1>
<p>In this example, we'll present how to use <a href="https://wasmedge.github.io/WasmEdge/wasmedge_sdk/struct.Table.html">Table</a> and <a href="https://wasmedge.github.io/WasmEdge/wasmedge_sdk/struct.FuncRef.html">FuncRef</a> stored in a slot of a <code>Table</code> instance to implement indirect function invocation.</p>
<blockquote>
<p>The code in the following example is verified on</p>
<ul>
<li>wasmedge-sdk v0.5.0</li>
<li>wasmedge-sys v0.10.0</li>
<li>wasmedge-types v0.3.0</li>
</ul>
</blockquote>
<p>Let's start off by getting all imports right away so you can follow along</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// If the version of rust used is less than v1.63, please uncomment the follow attribute.
// #![feature(explicit_generic_args_with_impl_trait)]

#![feature(never_type)]

use wasmedge_sdk::{
    config::{CommonConfigOptions, ConfigBuilder},
    error::HostFuncError,
    host_function, params,
    types::Val,
    Caller, Executor, Func, ImportObjectBuilder, RefType, Store, Table, TableType, ValType,
    WasmVal, WasmValue,
};
<span class="boring">}
</span></code></pre></pre>
<h2 id="define-host-function"><a class="header" href="#define-host-function">Define host function</a></h2>
<p>In this example we defines a native function <code>real_add</code> that takes two numbers and returns their sum. This function will be registered as a host function into WasmEdge runtime environment</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[host_function]
fn real_add(_caller: &amp;Caller, input: Vec&lt;WasmValue&gt;) -&gt; Result&lt;Vec&lt;WasmValue&gt;, HostFuncError&gt; {
    println!(&quot;Rust: Entering Rust function real_add&quot;);

    if input.len() != 2 {
        return Err(HostFuncError::User(1));
    }

    let a = if input[0].ty() == ValType::I32 {
        input[0].to_i32()
    } else {
        return Err(HostFuncError::User(2));
    };

    let b = if input[1].ty() == ValType::I32 {
        input[1].to_i32()
    } else {
        return Err(HostFuncError::User(3));
    };

    let c = a + b;
    println!(&quot;Rust: calcuating in real_add c: {:?}&quot;, c);

    println!(&quot;Rust: Leaving Rust function real_add&quot;);
    Ok(vec![WasmValue::from_i32(c)])
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="register-table-instance"><a class="header" href="#register-table-instance">Register Table instance</a></h2>
<p>The first thing we need to do is to create a <code>Table</code> instance. After that, we register the table instance along with an import module into the WasmEdge runtime environment. Now let's see the code.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// create an executor
let config = ConfigBuilder::new(CommonConfigOptions::default()).build()?;
let mut executor = Executor::new(Some(&amp;config), None)?;

// create a store
let mut store = Store::new()?;

// create a table instance
let result = Table::new(TableType::new(RefType::FuncRef, 10, Some(20)));
assert!(result.is_ok());
let table = result.unwrap();

// create an import object
let import = ImportObjectBuilder::new()
    .with_table(&quot;my-table&quot;, table)?
    .build(&quot;extern&quot;)?;

// register the import object into the store
store.register_import_module(&amp;mut executor, &amp;import)?;
<span class="boring">}
</span></code></pre></pre>
<p>In the code snippet above, we create a <code>Table</code> instance with the initial size of <code>10</code> and the maximum size of 20. The element type of the <code>Table</code> instance is <code>reference to function</code>.</p>
<h2 id="store-a-function-reference-into-table"><a class="header" href="#store-a-function-reference-into-table">Store a function reference into Table</a></h2>
<p>In the previous steps, we defined a native function <code>real_add</code> and registered a <code>Table</code> instance named <code>my-table</code> into the runtime environment. Now we'll save a reference to <code>read_add</code> function to a slot of <code>my-table</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// get the imported module instance
let instance = store
    .module_instance(&quot;extern&quot;)
    .expect(&quot;Not found module instance named 'extern'&quot;);

// get the exported table instance
let mut table = instance
    .table(&quot;my-table&quot;)
    .expect(&quot;Not found table instance named 'my-table'&quot;);

// create a host function
let host_func = Func::wrap::&lt;(i32, i32), i32, !&gt;(Box::new(real_add), None)?;

// store the reference to host_func at the given index of the table instance
table.set(3, Val::FuncRef(Some(host_func.as_ref())))?;
<span class="boring">}
</span></code></pre></pre>
<p>We save the reference to <code>host_func</code> into the third slot of <code>my-table</code>. Next, we can retrieve the function reference from the table instance by index and call the function via its reference.</p>
<h2 id="call-native-function-via-funcref"><a class="header" href="#call-native-function-via-funcref">Call native function via <code>FuncRef</code></a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// retrieve the function reference at the given index of the table instance
let value = table.get(3)?;
if let Val::FuncRef(Some(func_ref)) = value {
    // get the function type by func_ref
    let func_ty = func_ref.ty()?;

    // arguments
    assert_eq!(func_ty.args_len(), 2);
    let param_tys = func_ty.args().unwrap();
    assert_eq!(param_tys, [ValType::I32, ValType::I32]);

    // returns
    assert_eq!(func_ty.returns_len(), 1);
    let return_tys = func_ty.returns().unwrap();
    assert_eq!(return_tys, [ValType::I32]);

    // call the function by func_ref
    let returns = func_ref.call(&amp;mut executor, params!(1, 2))?;
    assert_eq!(returns.len(), 1);
    assert_eq!(returns[0].to_i32(), 3);
}
<span class="boring">}
</span></code></pre></pre>
<p>The complete code of this example can be found in <a href="https://github.com/WasmEdge/WasmEdge/blob/master/bindings/rust/wasmedge-sdk/examples/table_and_funcref.rs">table_and_funcref.rs</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="run-a-webassembly-function-with-wasmedge-low-level-rust-apis"><a class="header" href="#run-a-webassembly-function-with-wasmedge-low-level-rust-apis">Run a WebAssembly function with WasmEdge low-level Rust APIs</a></h1>
<h2 id="overview"><a class="header" href="#overview">Overview</a></h2>
<p>This section demonstrates how to use the Rust APIs of the <code>wasmedge-sys</code> crate to run a host function.</p>
<p>As you may know, several mainstream programming languages, such as C/C++, Rust, Go, and Python, support compiling their programs into WebAssembly binary. In this demo, we'll introduce how to use the APIs defined in <code>Vm</code> of <code>wasmedge-sys</code> crate to call a WebAssembly function which could be coded in any programming language mentioned above.</p>
<blockquote>
<p>The code in the example is verified on</p>
<ul>
<li>wasmedge-sys v0.10.0</li>
<li>wasmedge-types v0.3.0</li>
</ul>
</blockquote>
<h2 id="example"><a class="header" href="#example">Example</a></h2>
<p>We use <code>fibonacci.wasm</code> in this demo, and the contents of the WebAssembly file are presented below. The statement, <code>(export &quot;fib&quot; (func $fib))</code>, declares an exported function named <code>fib</code>. This function computes a Fibonacci number with a given <code>i32</code> number as input. We'll use the function name later to achieve the goal of computing a Fibonacci number.</p>
<pre><code class="language-wasm">(module
  (export &quot;fib&quot; (func $fib))
  (func $fib (param $n i32) (result i32)
    (if
      (i32.lt_s
        (get_local $n)
        (i32.const 2)
      )
      (return
        (i32.const 1)
      )
    )
    (return
      (i32.add
        (call $fib
          (i32.sub
            (get_local $n)
            (i32.const 2)
          )
        )
        (call $fib
          (i32.sub
            (get_local $n)
            (i32.const 1)
          )
        )
      )
    )
  )
)
</code></pre>
<h3 id="step-1-create-a-wasmedge-ast-module"><a class="header" href="#step-1-create-a-wasmedge-ast-module">Step 1: Create a WasmEdge AST Module</a></h3>
<p>In this step,  we'll create a WasmEdge <code>AST Module</code> instance from a WebAssembly file.</p>
<ul>
<li>
<p>First, create a <code>Loader</code> context;</p>
</li>
<li>
<p>Then, load a specified WebAssebly file (&quot;fibonacci.wasm&quot;) via the <code>from_file</code> method of the <code>Loader</code> context. If the process is successful, then a WasmEdge <code>AST Module</code> instance is returned.</p>
</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use wasmedge_sys::Loader;
use std::path::PathBuf;

// create a Loader context
let loader = Loader::create(None).expect(&quot;fail to create a Loader context&quot;);

// load a wasm module from a specified wasm file, and return a WasmEdge AST Module instance
let path = PathBuf::from(&quot;fibonacci.wasm&quot;);
let module = loader.from_file(path).expect(&quot;fail to load the WebAssembly file&quot;);
<span class="boring">}
</span></code></pre></pre>
<h3 id="step-2-create-a-wasmedge-vm-context"><a class="header" href="#step-2-create-a-wasmedge-vm-context">Step 2: Create a WasmEdge <code>Vm</code> context</a></h3>
<p>In WasmEdge, a <code>Vm</code> defines a running environment, in which all varieties of instances and contexts are stored and maintained. In the demo code below, we explicitly create a WasmEdge <code>Store</code> context, and then use it as one of the inputs in the creation of a <code>Vm</code> context. If not specify a <code>Store</code> context explicitly, then <code>Vm</code> will create a store by itself.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use wasmedge_sys::{Config, Store, Vm};

// create a Config context
let config = Config::create().expect(&quot;fail to create a Config context&quot;);

// create a Store context
let mut store = Store::create().expect(&quot;fail to create a Store context&quot;);

// create a Vm context with the given Config and Store
let mut vm = Vm::create(Some(config), Some(&amp;mut store)).expect(&quot;fail to create a Vm context&quot;);
<span class="boring">}
</span></code></pre></pre>
<h3 id="step-3-invoke-the-fib-function"><a class="header" href="#step-3-invoke-the-fib-function">Step 3: Invoke the <code>fib</code> function</a></h3>
<p>In Step 1, we got a module that hosts the target <code>fib</code> function defined in the WebAssembly. Now, we can call the function via the <code>run_wasm_from_module</code> method of the <code>Vm</code> context by passing the exported function name, <code>fib</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use wasmedge_sys::WasmValue;

// run a function
let returns = vm.run_wasm_from_module(module, &quot;fib&quot;, [WasmValue::from_i32(5)]).expect(&quot;fail to run the target function in the module&quot;);

println!(&quot;The result of fib(5) is {}&quot;, returns[0].to_i32());
<span class="boring">}
</span></code></pre></pre>
<p>This is the final result printing on the screen:</p>
<pre><code class="language-bash">The result of fib(5) is 8
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="compute-fibonacci-numbers-concurrently"><a class="header" href="#compute-fibonacci-numbers-concurrently">Compute Fibonacci numbers concurrently</a></h1>
<h2 id="overview-1"><a class="header" href="#overview-1">Overview</a></h2>
<p>In this example, we will demonstrate how to use the objects and the APIs defined in <code>wasmedge-sys</code> to compute Fibonacci numbers concurrently. we creates two child threads, <code>thread_a</code> and <code>thread_b</code>, which are responsbile for compute <code>Fib(4)</code> and <code>Fib(5)</code> by calling the host function <code>fib</code>, respectively. After that, the main thread computes <code>Fib(6)</code> by adding the numbers returned by <code>thread_a</code> and <code>thread_b</code>.</p>
<blockquote>
<p>The code in the example is verified on</p>
<ul>
<li>wasmedge-sys v0.10.0</li>
<li>wasmedge-types v0.3.0</li>
</ul>
</blockquote>
<h3 id="step-1-create-a-vm-context-and-register-the-webassembly-module"><a class="header" href="#step-1-create-a-vm-context-and-register-the-webassembly-module">Step 1: create a Vm context and register the WebAssembly module</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// create a Config context
let mut config = Config::create()?;
config.bulk_memory_operations(true);

// create a Store context
let mut store = Store::create()?;

// create a Vm context with the given Config and Store
let mut vm = Vm::create(Some(config), Some(&amp;mut store))?;

// register a wasm module from a wasm file
let file = std::path::PathBuf::from(env!(&quot;WASMEDGE_DIR&quot;))
    .join(&quot;bindings/rust/wasmedge-sys/tests/data/fibonacci.wasm&quot;);
vm.register_wasm_from_file(&quot;extern&quot;, file)?;

<span class="boring">}
</span></code></pre></pre>
<h3 id="step-2-create-two-child-threads-to-compute-fib4-and-fib5-respectively"><a class="header" href="#step-2-create-two-child-threads-to-compute-fib4-and-fib5-respectively">Step 2: create two child threads to compute <code>Fib(4)</code> and <code>Fib(5)</code> respectively</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let vm = Arc::new(Mutex::new(vm));

// compute fib(4) by a child thread
let vm_cloned = Arc::clone(&amp;vm);
let handle_a = thread::spawn(move || {
    let vm_child_thread = vm_cloned.lock().expect(&quot;fail to lock vm&quot;);
    let returns = vm_child_thread
        .run_registered_function(&quot;extern&quot;, &quot;fib&quot;, [WasmValue::from_i32(4)])
        .expect(&quot;fail to compute fib(4)&quot;);

    let fib4 = returns[0].to_i32();
    println!(&quot;fib(4) by child thread: {}&quot;, fib4);

    fib4
});

// compute fib(5) by a child thread
let vm_cloned = Arc::clone(&amp;vm);
let handle_b = thread::spawn(move || {
    let vm_child_thread = vm_cloned.lock().expect(&quot;fail to lock vm&quot;);
    let returns = vm_child_thread
        .run_registered_function(&quot;extern&quot;, &quot;fib&quot;, [WasmValue::from_i32(5)])
        .expect(&quot;fail to compute fib(5)&quot;);

    let fib5 = returns[0].to_i32();
    println!(&quot;fib(5) by child thread: {}&quot;, fib5);

    fib5
});

<span class="boring">}
</span></code></pre></pre>
<h3 id="step3-get-the-returns-from-the-two-child-threads-and-compute-fib6"><a class="header" href="#step3-get-the-returns-from-the-two-child-threads-and-compute-fib6">Step3: Get the returns from the two child threads, and compute <code>Fib(6)</code></a></h3>
<pre><code class="language-Rust">let fib4 = handle_a.join().unwrap();
let fib5 = handle_b.join().unwrap();

// compute fib(6)
println!(&quot;fib(6) = fib(5) + fib(1) = {}&quot;, fib5 + fib4);
</code></pre>
<p>The final result of the code above should be printed on the screen like below:</p>
<pre><code class="language-bash">fib(4) by child thread: 5
fib(5) by child thread: 8
fib(6) = fib(5) + fib(1) = 13
</code></pre>
<p>The complete code in this demo can be found in <a href="https://github.com/WasmEdge/WasmEdge/blob/master/bindings/rust/wasmedge-sys/examples/threads.rs">threads.rs</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="introduction-to-wasmedge-module-instance"><a class="header" href="#introduction-to-wasmedge-module-instance">Introduction to WasmEdge module instance</a></h1>
<blockquote>
<p>The code in the following examples are verified on</p>
<ul>
<li>wasmedge-sys v0.10.0</li>
<li>wasmedge-types v0.3.0</li>
</ul>
</blockquote>
<h2 id="example-1"><a class="header" href="#example-1">Example 1</a></h2>
<p>In this example, we'll demonstrate how to use the APIs of <code>Vm</code> to</p>
<ul>
<li>
<p>Create Wasi and WasmEdgeProcess module instances implicitly by using a <code>Config</code> while creating a <code>Vm</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// create a Config context
let mut config = Config::create()?;
config.bulk_memory_operations(true);
assert!(config.bulk_memory_operations_enabled());
config.wasi(true);
assert!(config.wasi_enabled());
config.wasmedge_process(true);
assert!(config.wasmedge_process_enabled());

// create a Vm context with the given Config and Store
let mut vm = Vm::create(Some(config), None)?;

<span class="boring">}
</span></code></pre></pre>
</li>
<li>
<p>Retrieve the Wasi and WasmEdgeProcess module instances from the <code>Vm</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// get the default Wasi module
let wasi_instance = vm.wasi_module_mut()?;
assert_eq!(wasi_instance.name(), &quot;wasi_snapshot_preview1&quot;);
// get the default WasmEdgeProcess module instance
let wasmedge_process_instance = vm.wasmedge_process_module_mut()?;
assert_eq!(wasmedge_process_instance.name(), &quot;wasmedge_process&quot;);

<span class="boring">}
</span></code></pre></pre>
</li>
<li>
<p>Register an import module as a named module into the <code>Vm</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// create ImportModule instance
let module_name = &quot;extern_module&quot;;
let mut import = ImportModule::create(module_name)?;

// a function to import
#[sys_host_function]
fn real_add(_frame: &amp;CallingFrame, inputs: Vec&lt;WasmValue&gt;) -&gt; Result&lt;Vec&lt;WasmValue&gt;, u8&gt; {
    if inputs.len() != 2 {
        return Err(1);
    }

    let a = if inputs[0].ty() == ValType::I32 {
        inputs[0].to_i32()
    } else {
        return Err(2);
    };

    let b = if inputs[1].ty() == ValType::I32 {
        inputs[1].to_i32()
    } else {
        return Err(3);
    };

    let c = a + b;

    Ok(vec![WasmValue::from_i32(c)])
}

// add host function
let func_ty = FuncType::create(vec![ValType::I32; 2], vec![ValType::I32])?;
let host_func = Function::create(&amp;func_ty, Box::new(real_add), 0)?;
import.add_func(&quot;add&quot;, host_func);

// add table
let table_ty = TableType::create(RefType::FuncRef, 0..=u32::MAX)?;
let table = Table::create(&amp;table_ty)?;
import.add_table(&quot;table&quot;, table);

// add memory
let mem_ty = MemType::create(0..=u32::MAX)?;
let memory = Memory::create(&amp;mem_ty)?;
import.add_memory(&quot;mem&quot;, memory);

// add global
let ty = GlobalType::create(ValType::F32, Mutability::Const)?;
let global = Global::create(&amp;ty, WasmValue::from_f32(3.5))?;
import.add_global(&quot;global&quot;, global);

// register the import module as a named module
vm.register_wasm_from_import(ImportObject::Import(import))?;

<span class="boring">}
</span></code></pre></pre>
</li>
<li>
<p>Retrieve the internal <code>Store</code> instance from the <code>Vm</code>, and retrieve the named module instance from the <code>Store</code> instance.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut store = vm.store_mut()?;
let named_instance = store.module(module_name)?;
assert!(named_instance.get_func(&quot;add&quot;).is_ok());
assert!(named_instance.get_table(&quot;table&quot;).is_ok());
assert!(named_instance.get_memory(&quot;mem&quot;).is_ok());
assert!(named_instance.get_global(&quot;global&quot;).is_ok());

<span class="boring">}
</span></code></pre></pre>
</li>
<li>
<p>Register an active module into the <code>Vm</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// read the wasm bytes
let wasm_bytes = wat2wasm(
    br#&quot;
    (module
      (export &quot;fib&quot; (func $fib))
      (func $fib (param $n i32) (result i32)
        (if
          (i32.lt_s
            (get_local $n)
            (i32.const 2)
          )
          (return
            (i32.const 1)
          )
        )
        (return
          (i32.add
            (call $fib
              (i32.sub
                (get_local $n)
                (i32.const 2)
              )
            )
            (call $fib
              (i32.sub
                (get_local $n)
                (i32.const 1)
              )
            )
          )
        )
      )
    )
&quot;#,
)?;

// load a wasm module from a in-memory bytes, and the loaded wasm module works as an anoymous
// module (aka. active module in WasmEdge terminology)
vm.load_wasm_from_bytes(&amp;wasm_bytes)?;

// validate the loaded active module
vm.validate()?;

// instatiate the loaded active module
vm.instantiate()?;

// get the active module instance
let active_instance = vm.active_module()?;
assert!(active_instance.get_func(&quot;fib&quot;).is_ok());
    
<span class="boring">}
</span></code></pre></pre>
</li>
<li>
<p>Retrieve the active module from the <code>Vm</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// get the active module instance
let active_instance = vm.active_module()?;
assert!(active_instance.get_func(&quot;fib&quot;).is_ok());

<span class="boring">}
</span></code></pre></pre>
</li>
</ul>
<p>The complete code in this demo can be found on <a href="https://github.com/WasmEdge/WasmEdge/blob/master/bindings/rust/wasmedge-sys/examples/mdbook_example_module_instance.rs">WasmEdge Github</a>.</p>
<h2 id="example-2"><a class="header" href="#example-2">Example 2</a></h2>
<p>In this example, we'll demonstrate how to use the APIs of <code>Executor</code> to</p>
<ul>
<li>
<p>Create an <code>Executor</code> and a <code>Store</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// create an Executor context
let mut executor = Executor::create(None, None)?;

// create a Store context
let mut store = Store::create()?;

<span class="boring">}
</span></code></pre></pre>
</li>
<li>
<p>Register an import module into the <code>Executor</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// read the wasm bytes
let wasm_bytes = wat2wasm(
    br#&quot;
    (module
      (export &quot;fib&quot; (func $fib))
      (func $fib (param $n i32) (result i32)
        (if
          (i32.lt_s
            (get_local $n)
            (i32.const 2)
          )
          (return
            (i32.const 1)
          )
        )
        (return
          (i32.add
            (call $fib
              (i32.sub
                (get_local $n)
                (i32.const 2)
              )
            )
            (call $fib
              (i32.sub
                (get_local $n)
                (i32.const 1)
              )
            )
          )
        )
      )
    )
&quot;#,
)?;

// load module from a wasm file
let config = Config::create()?;
let loader = Loader::create(Some(config))?;
let module = loader.from_bytes(&amp;wasm_bytes)?;

// validate module
let config = Config::create()?;
let validator = Validator::create(Some(config))?;
validator.validate(&amp;module)?;

// register a wasm module into the store context
let module_name = &quot;extern&quot;;
let named_instance = executor.register_named_module(&amp;mut store, &amp;module, module_name)?;
assert!(named_instance.get_func(&quot;fib&quot;).is_ok());

<span class="boring">}
</span></code></pre></pre>
</li>
<li>
<p>Register an active module into the <code>Executor</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// read the wasm bytes
let wasm_bytes = wat2wasm(
    br#&quot;
    (module
      (export &quot;fib&quot; (func $fib))
      (func $fib (param $n i32) (result i32)
        (if
          (i32.lt_s
            (get_local $n)
            (i32.const 2)
          )
          (return
            (i32.const 1)
          )
        )
        (return
          (i32.add
            (call $fib
              (i32.sub
                (get_local $n)
                (i32.const 2)
              )
            )
            (call $fib
              (i32.sub
                (get_local $n)
                (i32.const 1)
              )
            )
          )
        )
      )
    )
&quot;#,
)?;

// load module from a wasm file
let config = Config::create()?;
let loader = Loader::create(Some(config))?;
let module = loader.from_bytes(&amp;wasm_bytes)?;

// validate module
let config = Config::create()?;
let validator = Validator::create(Some(config))?;
validator.validate(&amp;module)?;

// register a wasm module as an active module
let active_instance = executor.register_active_module(&amp;mut store, &amp;module)?;
assert!(active_instance.get_func(&quot;fib&quot;).is_ok());

<span class="boring">}
</span></code></pre></pre>
</li>
</ul>
<p>The complete code in this demo can be found in <a href="https://github.com/WasmEdge/WasmEdge/blob/master/bindings/rust/wasmedge-sys/examples/mdbook_example_module_instance.rs">mdbook_example_module_instance.rs</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="wasmedge-python-sdk"><a class="header" href="#wasmedge-python-sdk">WasmEdge Python SDK</a></h1>
<p>Coming soon, or you can <a href="https://github.com/WasmEdge/WasmEdge/pull/633">help out</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="wasmedge-command-line-tools"><a class="header" href="#wasmedge-command-line-tools">WasmEdge Command Line Tools</a></h1>
<p>After the <a href="quick_start/install.html">WasmEdge installataion</a>, the <code>wasmedge</code> and <code>wasmedgec</code> tools are installed.</p>
<p>Users can use these WasmEdge CLI tools to execute the WebAssembly files quickly.</p>
<ul>
<li>The <a href="cli/wasmedge.html"><code>wasmedge</code> CLI tool</a> is the WebAssembly runtime to execute the WASM files.</li>
<li>The <a href="cli/wasmedgec.html"><code>wasmedgec</code> CLI tool</a> is the ahead-of-time compiler to compile the WebAssembly file into native code.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="wasmedge-cli-1"><a class="header" href="#wasmedge-cli-1"><code>wasmedge</code> CLI</a></h1>
<p>After <a href="cli/../quick_start/install.html">installation</a>, users can execute the <code>wasmedge</code> tool with commands.</p>
<pre><code class="language-bash">$ wasmedge -v
wasmedge version 0.11.1
</code></pre>
<p>The usage of the <code>wasmedge</code> tool will be:</p>
<pre><code class="language-bash">$ wasmedge -h
USAGE
   wasmedge [OPTIONS] [--] WASM_OR_SO [ARG ...]

...
</code></pre>
<p>If users install the WasmEdge from the install script with the option <code>-e tf,image</code>, the WasmEdge CLI tools with TensorFlow and TensorFlow-Lite extensions will be installed.</p>
<ul>
<li><code>wasmedge-tensorflow</code> CLI tool
<ul>
<li>The <code>wasmedge</code> tool with TensorFlow, TensorFlow-Lite, and <code>wasmedge-image</code> extensions.</li>
<li>Only on <code>x86_64</code> and <code>aarch64</code> Linux platforms and <code>x86_64</code> MacOS.</li>
</ul>
</li>
<li><code>wasmedge-tensorflow-lite</code> CLI tool
<ul>
<li>The <code>wasmedge</code> tool with TensorFlow-Lite, and <code>wasmedge-image</code> extensions.</li>
<li>Only on <code>x86_64</code> and <code>aarch64</code> Linux platforms, Android, and <code>x86_64</code> MacOS.</li>
</ul>
</li>
</ul>
<p>The <code>wasmedge</code> CLI tool will execute the WebAssembly in ahead-of-time(AOT) mode if available in the input WASM file.
For the pure WASM, the <code>wasmedge</code> CLI tool will execute it in interpreter mode, which is much slower than AOT mode.
If you want to improve the performance, <a href="cli/wasmedgec.html">please refer here</a> to compile your WASM file.</p>
<h2 id="options"><a class="header" href="#options">Options</a></h2>
<p>The options of the <code>wasmedge</code> CLI tool are as follows.</p>
<ol>
<li><code>-v|--version</code>: Show the version information. Will ignore other arguments below.</li>
<li><code>-h|--help</code>: Show the help messages. Will ignore other arguments below.</li>
<li>(Optional) <code>--reactor</code>: Enable the reactor mode.
<ul>
<li>In the reactor mode, <code>wasmedge</code> runs a specified function exported by the WebAssembly program.</li>
<li>WasmEdge will execute the function which name should be given in <code>ARG[0]</code>.</li>
<li>If there's exported function which names <code>_initialize</code>, the function will be executed with the empty parameter at first.</li>
</ul>
</li>
<li>(Optional) <code>--dir</code>: Bind directories into WASI virtual filesystem.
<ul>
<li>Use <code>--dir guest_path:host_path</code> to bind the host path into the guest path in WASI virtual system.</li>
</ul>
</li>
<li>(Optional) <code>--env</code>: Assign the environment variables in WASI.
<ul>
<li>Use <code>--env ENV_NAME=VALUE</code> to assign the environment variable.</li>
</ul>
</li>
<li>(Optional) Statistics informations:
<ul>
<li>Use <code>--enable-time-measuring</code> to show the execution time.</li>
<li>Use <code>--enable-gas-measuring</code> to show the amount of used gas.</li>
<li>Use <code>--enable-instruction-count</code> to display the number of executed instructions.</li>
<li>Or use <code>--enable-all-statistics</code> to enable all of the statistics options.</li>
</ul>
</li>
<li>(Optional) Resource limitations:
<ul>
<li>Use <code>--time-limit MILLISECOND_TIME</code> to limit the execution time. Default value is <code>0</code> as no limitation.</li>
<li>Use <code>--gas-limit GAS_LIMIT</code> to limit the execution cost.</li>
<li>Use <code>--memory-page-limit PAGE_COUNT</code> to set the limitation of pages(as size of 64 KiB) in every memory instance.</li>
</ul>
</li>
<li>(Optional) WebAssembly proposals:
<ul>
<li>Use <code>--disable-import-export-mut-globals</code> to disable the <a href="https://github.com/WebAssembly/mutable-global">Import/Export of Mutable Globals</a> proposal (Default <code>ON</code>).</li>
<li>Use <code>--disable-non-trap-float-to-int</code> to disable the <a href="https://github.com/WebAssembly/nontrapping-float-to-int-conversions">Non-Trapping Float-to-Int Conversions</a> proposal (Default <code>ON</code>).</li>
<li>Use <code>--disable-sign-extension-operators</code> to disable the <a href="https://github.com/WebAssembly/sign-extension-ops">Sign-Extension Operators</a> proposal (Default <code>ON</code>).</li>
<li>Use <code>--disable-multi-value</code> to disable the <a href="https://github.com/WebAssembly/multi-value">Multi-value</a> proposal (Default <code>ON</code>).</li>
<li>Use <code>--disable-bulk-memory</code> to disable the <a href="https://github.com/WebAssembly/bulk-memory-operations">Bulk Memory Operations</a> proposal (Default <code>ON</code>).</li>
<li>Use <code>--disable-reference-types</code> to disable the <a href="https://github.com/WebAssembly/reference-types">Reference Types</a> proposal (Default <code>ON</code>).</li>
<li>Use <code>--disable-simd</code> to disable the <a href="https://github.com/webassembly/simd">Fixed-width SIMD</a> proposal (Default <code>ON</code>).</li>
<li>Use <code>--enable-multi-memory</code> to enable the <a href="https://github.com/WebAssembly/multi-memory">Multiple Memories</a> proposal (Default <code>OFF</code>).</li>
<li>Use <code>--enable-tail-call</code> to enable the <a href="https://github.com/WebAssembly/tail-call">Tail call</a> proposal (Default <code>OFF</code>).</li>
<li>Use <code>--enable-extended-const</code> to enable the <a href="https://github.com/WebAssembly/extended-const">Extended Constant Expressions</a> proposal (Default <code>OFF</code>).</li>
<li>Use <code>--enable-threads</code> to enable the <a href="https://github.com/webassembly/threads">Threads</a> proposal (Default <code>OFF</code>).</li>
<li>Use <code>--enable-all</code> to enable ALL proposals above.</li>
</ul>
</li>
<li>WASM file (<code>/path/to/wasm/file</code>).</li>
<li>(Optional) <code>ARG</code> command line arguments array.
<ul>
<li>In reactor mode, the first argument will be the function name, and the arguments after <code>ARG[0]</code> will be parameters of wasm function <code>ARG[0]</code>.</li>
<li>In command mode, the arguments will be the command line arguments of the WASI <code>_start</code> function. They are also known as command line arguments(<code>argv</code>) for a standalone C/C++ program.</li>
</ul>
</li>
</ol>
<h2 id="examples-4"><a class="header" href="#examples-4">Examples</a></h2>
<h3 id="call-a-webassembly-function-written-in-wat-1"><a class="header" href="#call-a-webassembly-function-written-in-wat-1">Call A WebAssembly Function Written in WAT</a></h3>
<p>We created the hand-written <a href="https://github.com/WasmEdge/WasmEdge/raw/master/examples/wasm/fibonacci.wat">fibonacci.wat</a> and used the <a href="https://webassembly.github.io/wabt/demo/wat2wasm/">wat2wasm</a> tool to convert it into the <a href="https://github.com/WasmEdge/WasmEdge/raw/master/examples/wasm/fibonacci.wasm">fibonacci.wasm</a> WebAssembly program.
It exported a <code>fib()</code> function which takes a single <code>i32</code> integer as the input parameter. We can execute <code>wasmedge</code> in reactor mode to invoke the exported function.</p>
<p>You can run:</p>
<pre><code class="language-bash">wasmedge --reactor fibonacci.wasm fib 10
</code></pre>
<p>The output will be:</p>
<pre><code class="language-bash">89
</code></pre>
<h3 id="call-a-webassembly-function-compiled-from-rust-1"><a class="header" href="#call-a-webassembly-function-compiled-from-rust-1">Call A WebAssembly Function Compiled From Rust</a></h3>
<p>The <a href="https://github.com/WasmEdge/WasmEdge/raw/master/examples/wasm/add.wasm">add.wasm</a> WebAssembly program contains an exported <code>add()</code> function, which is compiled from Rust.
Checkout its <a href="https://github.com/second-state/wasm-learning/tree/master/cli/add">Rust source code project here</a>.
We can execute <code>wasmedge</code> in reactor mode to invoke the <code>add()</code> function with two <code>i32</code> integer input parameters.</p>
<p>You can run:</p>
<pre><code class="language-bash">wasmedge --reactor add.wasm add 2 2
</code></pre>
<p>The output will be:</p>
<pre><code class="language-bash">4
</code></pre>
<h3 id="execute-a-standalone-webassembly-program-hello-world-1"><a class="header" href="#execute-a-standalone-webassembly-program-hello-world-1">Execute A Standalone WebAssembly Program: Hello world</a></h3>
<p>The <a href="https://github.com/WasmEdge/WasmEdge/raw/master/examples/wasm/hello.wasm">hello.wasm</a> WebAssembly program contains a <code>main()</code> function.
Checkout its <a href="https://github.com/second-state/wasm-learning/tree/master/cli/hello">Rust source code project here</a>.
It prints out <code>hello</code> followed by the command line arguments.</p>
<p>You can run:</p>
<pre><code class="language-bash">wasmedge hello.wasm second state
</code></pre>
<p>The output will be:</p>
<pre><code class="language-bash">hello
second
state
</code></pre>
<h3 id="execute-with-statistics-enabled"><a class="header" href="#execute-with-statistics-enabled">Execute With <code>statistics</code> Enabled</a></h3>
<p>The CLI supports <code>--enable-all-statistics</code> flags for the statistics and gas metering.</p>
<p>You can run:</p>
<pre><code class="language-bash">wasmedge --enable-all-statistics hello.wasm second state
</code></pre>
<p>The output will be:</p>
<pre><code class="language-bash">hello
second
state
[2021-12-09 16:03:33.261] [info] ====================  Statistics  ====================
[2021-12-09 16:03:33.261] [info]  Total execution time: 268266 ns
[2021-12-09 16:03:33.261] [info]  Wasm instructions execution time: 251610 ns
[2021-12-09 16:03:33.261] [info]  Host functions execution time: 16656 ns
[2021-12-09 16:03:33.261] [info]  Executed wasm instructions count: 20425
[2021-12-09 16:03:33.261] [info]  Gas costs: 20425
[2021-12-09 16:03:33.261] [info]  Instructions per second: 81177218
[2021-12-09 16:03:33.261] [info] =======================   End   ======================
</code></pre>
<h3 id="execute-with-gas-limit-enabled"><a class="header" href="#execute-with-gas-limit-enabled">Execute With <code>gas-limit</code> Enabled</a></h3>
<p>The CLI supports <code>--gas-limit</code> flags for controlling the execution costs.</p>
<p>For giving sufficient gas as the example, you can run:</p>
<pre><code class="language-bash">wasmedge --enable-all-statistics --gas-limit 20425 hello.wasm second state
</code></pre>
<p>The output will be:</p>
<pre><code class="language-bash">hello
second
state
[2021-12-09 16:03:33.261] [info] ====================  Statistics  ====================
[2021-12-09 16:03:33.261] [info]  Total execution time: 268266 ns
[2021-12-09 16:03:33.261] [info]  Wasm instructions execution time: 251610 ns
[2021-12-09 16:03:33.261] [info]  Host functions execution time: 16656 ns
[2021-12-09 16:03:33.261] [info]  Executed wasm instructions count: 20425
[2021-12-09 16:03:33.261] [info]  Gas costs: 20425
[2021-12-09 16:03:33.261] [info]  Instructions per second: 81177218
[2021-12-09 16:03:33.261] [info] =======================   End   ======================
</code></pre>
<p>For giving insufficient gas as the example, you can run:</p>
<pre><code class="language-bash">wasmedge --enable-all-statistics --gas-limit 20 hello.wasm second state
</code></pre>
<p>The output will be:</p>
<pre><code class="language-bash">[2021-12-23 15:19:06.690] [error] Cost exceeded limit. Force terminate the execution.
[2021-12-23 15:19:06.690] [error]     In instruction: ref.func (0xd2) , Bytecode offset: 0x00000000
[2021-12-23 15:19:06.690] [error]     At AST node: expression
[2021-12-23 15:19:06.690] [error]     At AST node: element segment
[2021-12-23 15:19:06.690] [error]     At AST node: element section
[2021-12-23 15:19:06.690] [error]     At AST node: module
[2021-12-23 15:19:06.690] [info] ====================  Statistics  ====================
[2021-12-23 15:19:06.690] [info]  Total execution time: 0 ns
[2021-12-23 15:19:06.690] [info]  Wasm instructions execution time: 0 ns
[2021-12-23 15:19:06.690] [info]  Host functions execution time: 0 ns
[2021-12-23 15:19:06.690] [info]  Executed wasm instructions count: 21
[2021-12-23 15:19:06.690] [info]  Gas costs: 20
</code></pre>
<h3 id="javascript-examples"><a class="header" href="#javascript-examples">JavaScript Examples</a></h3>
<p>It is possible to use WasmEdge as a high-performance, secure, extensible, easy to deploy, and <a href="https://github.com/second-state/wasmedge-containers-examples">Kubernetes-compliant</a> JavaScript runtime.</p>
<p>The <a href="https://github.com/WasmEdge/WasmEdge/raw/master/examples/js/qjs.wasm">qjs.wasm</a> program is a JavaScript interpreter compiled into WebAssembly.
The <a href="https://github.com/WasmEdge/WasmEdge/raw/master/examples/js/hello.js">hello.js</a> file is a very simple JavaScript program.</p>
<p>You can run:</p>
<pre><code class="language-bash">wasmedge --dir .:. qjs.wasm hello.js 1 2 3
</code></pre>
<p>The output will be:</p>
<pre><code class="language-bash">Hello 1 2 3
</code></pre>
<p>The <a href="https://github.com/WasmEdge/WasmEdge/raw/master/examples/wasm/js/qjs_tf.wasm">qjs_tf.wasm</a> is a JavaScript interpreter with <a href="https://www.secondstate.io/articles/wasi-tensorflow/">WasmEdge Tensorflow extension</a> compiled into WebAssembly.
To run <a href="https://github.com/WasmEdge/WasmEdge/raw/master/examples/wasm/js/qjs_tf.wasm">qjs_tf.wasm</a>, you must use the <code>wasmedge-tensorflow-lite</code> CLI tool, which is a build of WasmEdge with Tensorflow-Lite extension built-in.
You can download a full <a href="https://github.com/second-state/wasmedge-quickjs/tree/main/example_js/tensorflow_lite_demo">Tensorflow-based JavaScript example</a> to classify images.</p>
<pre><code class="language-bash"># Download the Tensorflow example
$ wget https://raw.githubusercontent.com/second-state/wasmedge-quickjs/main/example_js/tensorflow_lite_demo/aiy_food_V1_labelmap.txt
$ wget https://raw.githubusercontent.com/second-state/wasmedge-quickjs/main/example_js/tensorflow_lite_demo/food.jpg
$ wget https://raw.githubusercontent.com/second-state/wasmedge-quickjs/main/example_js/tensorflow_lite_demo/lite-model_aiy_vision_classifier_food_V1_1.tflite
$ wget https://raw.githubusercontent.com/second-state/wasmedge-quickjs/main/example_js/tensorflow_lite_demo/main.js

$ wasmedge-tensorflow-lite --dir .:. qjs_tf.wasm main.js
label: Hot dog
confidence: 0.8941176470588236
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="wasmedgec-cli-1"><a class="header" href="#wasmedgec-cli-1"><code>wasmedgec</code> CLI</a></h1>
<p>After <a href="cli/../quick_start/install.html">installation</a>, users can execute the <code>wasmedgec</code> tool with commands.</p>
<pre><code class="language-bash">$ wasmedgec -v
wasmedge version 0.11.1
</code></pre>
<p>The usage of the <code>wasmedge</code> tool will be:</p>
<pre><code class="language-bash">$ wasmedge -h
USAGE
   wasmedgec [OPTIONS] [--] WASM WASM_SO

...
</code></pre>
<p>The <code>wasmedgec</code> can compile WebAssembly into native machine code (i.e., the AOT compiler).
For the pure WebAssembly, the <code>wasmedge</code> tool will execute the WASM in interpreter mode.
After compiling with the <code>wasmedgec</code> AOT compiler, the <code>wasmedge</code> tool can execute the WASM in AOT mode which is much faster.</p>
<h2 id="options-1"><a class="header" href="#options-1">Options</a></h2>
<p>The options of the <code>wasmedgec</code> CLI tool are as follows.</p>
<ol>
<li><code>-v|--version</code>: Show the version information. Will ignore other arguments below.</li>
<li><code>-h|--help</code>: Show the help messages. Will ignore other arguments below.</li>
<li>(Optional) <code>--dump</code>: Dump the LLVM IR to <code>wasm.ll</code> and <code>wasm-opt.ll</code>.</li>
<li>(Optional) <code>--interruptible</code>: Generate the binary which supports interruptible execution.
<ul>
<li>By default, the AOT-compiled WASM not supports <a href="cli/../sdk/c/ref.html#async">interruptions in asynchronous executions</a>.</li>
</ul>
</li>
<li>(Optional) Statistics informations:
<ul>
<li>By default, the AOT-compiled WASM not supports all statistics even if the options are turned on when running the <code>wasmedge</code> tool.</li>
<li>Use <code>--enable-time-measuring</code> to generate code for enabling the statistics of time measuring in execution.</li>
<li>Use <code>--enable-gas-measuring</code> to generate code for enabling the statistics of gas measuring in execution.</li>
<li>Use <code>--enable-instruction-count</code> to generate code for enabling the statistics of counting WebAssembly instructions.</li>
<li>Or use <code>--enable-all-statistics</code> to generate code for enabling all of the statistics.</li>
</ul>
</li>
<li>(Optional) <code>--generic-binary</code>: Generate the generic binary of the current host CPU architecture.</li>
<li>(Optional) WebAssembly proposals:
<ul>
<li>Use <code>--disable-import-export-mut-globals</code> to disable the <a href="https://github.com/WebAssembly/mutable-global">Import/Export of Mutable Globals</a> proposal (Default <code>ON</code>).</li>
<li>Use <code>--disable-non-trap-float-to-int</code> to disable the <a href="https://github.com/WebAssembly/nontrapping-float-to-int-conversions">Non-Trapping Float-to-Int Conversions</a> proposal (Default <code>ON</code>).</li>
<li>Use <code>--disable-sign-extension-operators</code> to disable the <a href="https://github.com/WebAssembly/sign-extension-ops">Sign-Extension Operators</a> proposal (Default <code>ON</code>).</li>
<li>Use <code>--disable-multi-value</code> to disable the <a href="https://github.com/WebAssembly/multi-value">Multi-value</a> proposal (Default <code>ON</code>).</li>
<li>Use <code>--disable-bulk-memory</code> to disable the <a href="https://github.com/WebAssembly/bulk-memory-operations">Bulk Memory Operations</a> proposal (Default <code>ON</code>).</li>
<li>Use <code>--disable-reference-types</code> to disable the <a href="https://github.com/WebAssembly/reference-types">Reference Types</a> proposal (Default <code>ON</code>).</li>
<li>Use <code>--disable-simd</code> to disable the <a href="https://github.com/webassembly/simd">Fixed-width SIMD</a> proposal (Default <code>ON</code>).</li>
<li>Use <code>--enable-multi-memory</code> to enable the <a href="https://github.com/WebAssembly/multi-memory">Multiple Memories</a> proposal (Default <code>OFF</code>).</li>
<li>Use <code>--enable-tail-call</code> to enable the <a href="https://github.com/WebAssembly/tail-call">Tail call</a> proposal (Default <code>OFF</code>).</li>
<li>Use <code>--enable-extended-const</code> to enable the <a href="https://github.com/WebAssembly/extended-const">Extended Constant Expressions</a> proposal (Default <code>OFF</code>).</li>
<li>Use <code>--enable-threads</code> to enable the <a href="https://github.com/webassembly/threads">Threads</a> proposal (Default <code>OFF</code>).</li>
<li>Use <code>--enable-all</code> to enable ALL proposals above.</li>
</ul>
</li>
<li>(Optional) <code>--optimize</code>: Select the LLVM optimization level.
<ul>
<li>Use <code>--optimize LEVEL</code> to set the optimization level. The <code>LEVEL</code> should be one of <code>0</code>, <code>1</code>, <code>2</code>, <code>3</code>, <code>s</code>, or <code>z</code>.</li>
<li>The default value will be <code>2</code>, which means <code>O2</code>.</li>
</ul>
</li>
<li>Input WASM file (<code>/path/to/wasm/file</code>).</li>
<li>Output path (<code>/path/to/output/file</code>).
<ul>
<li>By default, the <code>wasmedgec</code> tool will output the <a href="cli/../quick_start/run_in_aot_mode.html#output-format-universal-wasm">universal WASM format</a>.</li>
<li>If the specific file extension (<code>.so</code> on Linux, <code>.dylib</code> on MacOS, and <code>.dll</code> on Windows) is assigned in the output path, the <code>wasmedgec</code> tool will output the <a href="cli/../quick_start/run_in_aot_mode.html#output-format-shared-library">shared library format</a>.</li>
</ul>
</li>
</ol>
<h2 id="example-1"><a class="header" href="#example-1">Example</a></h2>
<p>Take the <a href="https://github.com/WasmEdge/WasmEdge/raw/master/examples/wasm/fibonacci.wasm">fibonacci.wasm</a> for example.
It exported a <code>fib()</code> function which takes a single <code>i32</code> integer as the input parameter.</p>
<p>You can run:</p>
<pre><code class="language-bash">wasmedgec fibonacci.wasm fibonacci_aot.wasm
</code></pre>
<p>or:</p>
<pre><code class="language-bash">wasmedgec fibonacci.wasm fibonacci_aot.so # On Linux.
</code></pre>
<p>The output will be:</p>
<pre><code class="language-bash">[2022-09-09 14:22:10.540] [info] compile start
[2022-09-09 14:22:10.541] [info] verify start
[2022-09-09 14:22:10.542] [info] optimize start
[2022-09-09 14:22:10.547] [info] codegen start
[2022-09-09 14:22:10.552] [info] output start
[2022-09-09 14:22:10.600] [info] compile done
</code></pre>
<p>Then you can execute the output file with <code>wasmedge</code> and measure the execution time:</p>
<pre><code class="language-bash">time wasmedge --reactor fibonacci_aot.wasm fib 30
</code></pre>
<p>The output will be:</p>
<pre><code class="language-bash">1346269

real    0m0.029s
user    0m0.012s
sys     0m0.014s
</code></pre>
<p>Then you can compare it with the interpreter mode:</p>
<pre><code class="language-bash">time wasmedge --reactor fibonacci.wasm fib 30
</code></pre>
<p>The output shows that the AOT-compiled WASM is much faster than the interpreter mode:</p>
<pre><code class="language-bash">1346269

real    0m0.442s
user    0m0.427s
sys     0m0.012s
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="develop-wasmedge-plug-in"><a class="header" href="#develop-wasmedge-plug-in">Develop WasmEdge Plug-in</a></h1>
<p><strong>This chapter is WORK IN PROGRESS.</strong></p>
<p>WasmEdge provides a C++ based API for registering extension modules and host functions. While the WasmEdge language SDKs allow registering host functions from a host (wrapping) application, the plugin API allows such extensions to be incorporated into WasmEdge's own building and releasing process.</p>
<p>The C API for the plug-in mechanism is under development.
In the future, we will release the C API of plug-in mechanism and recommand developers to implement the plug-ins with C API.</p>
<h2 id="loadable-plug-in"><a class="header" href="#loadable-plug-in">Loadable Plug-in</a></h2>
<p>Loadable plugin is a standalone <code>.so</code>/<code>.dylib</code>/<code>.dll</code> file that WasmEdge can load during runtime environment, and provide modules to be imported.</p>
<p>Please <a href="https://github.com/WasmEdge/WasmEdge/tree/master/examples/plugin/get-string">refer to the plugin example code</a>.</p>
<h2 id="wasmedge-currently-released-plug-ins"><a class="header" href="#wasmedge-currently-released-plug-ins">WasmEdge Currently Released Plug-ins</a></h2>
<p>There are several plug-in releases with the WasmEdge official releases.
Please check the following table to check the release status and how to build from source with the plug-ins.</p>
<blockquote>
<p>The <code>WasmEdge-Process</code> plug-in is attached in the WasmEdge release tarballs.</p>
</blockquote>
<div class="table-wrapper"><table><thead><tr><th>Plug-in</th><th>Rust Crate</th><th>Released Platforms</th><th>Build Steps</th></tr></thead><tbody>
<tr><td>WasmEdge-Process</td><td><a href="https://crates.io/crates/wasmedge_process_interface">wasmedge_process_interface</a></td><td><code>manylinux2014 x86_64</code>, <code>manylinux2014 aarch64</code>, and <code>ubuntu 20.04 x86_64</code> (since <code>0.10.0</code>)</td><td><a href="contribute/build_from_src/linux.html">Default</a></td></tr>
<tr><td><a href="write_wasm/rust/wasicrypto.html#prerequisites">WASI-Crypto</a></td><td><a href="https://crates.io/crates/wasi-crypto">wasi-crypto</a></td><td><code>manylinux2014 x86_64</code>, <code>manylinux2014 aarch64</code>, and <code>ubuntu 20.04 x86_64</code> (since <code>0.10.1</code>)</td><td><a href="contribute/build_from_src/plugin_wasi_crypto.html">Build With WASI-Crypto</a></td></tr>
<tr><td><a href="write_wasm/rust/wasinn.html#get-wasmedge-with-wasi-nn-plug-in-openvino-backend">WASI-NN with OpenVINO backend</a></td><td><a href="https://crates.io/crates/wasi-nn">wasi-nn</a></td><td><code>ubuntu 20.04 x86_64</code> (since <code>0.10.1</code>)</td><td><a href="contribute/build_from_src/plugin_wasi_nn.html">Build With WASI-NN</a></td></tr>
<tr><td><a href="write_wasm/rust/wasinn.html#get-wasmedge-with-wasi-nn-plug-in-pytorch-backend">WASI-NN with PyTorch backend</a></td><td><a href="https://crates.io/crates/wasi-nn">wasi-nn</a></td><td><code>ubuntu 20.04 x86_64</code> (since <code>0.11.1</code>)</td><td><a href="contribute/build_from_src/plugin_wasi_nn.html">Build With WASI-NN</a></td></tr>
<tr><td><a href="write_wasm/rust/networking-https.html#prerequisites">WasmEdge-HttpsReq</a></td><td><a href="https://crates.io/crates/wasmedge_http_req">wasmedge_http_req</a></td><td><code>manylinux2014 x86_64</code>, and <code>manylinux2014 aarch64</code> (since <code>0.11.1</code>)</td><td><a href="contribute/build_from_src/plugin_wasmedge_httpsreq.html">Build With WasmEdge-HttpsReq</a></td></tr>
</tbody></table>
</div>
<blockquote>
<p>Due to the <code>OpenVINO</code> and <code>PyTorch</code> dependencies, we only release the WASI-NN plug-in on <code>Ubuntu 20.04 x86_64</code> now. We'll work with <code>manylinux2014</code> versions in the future.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="contribute-to-wasmedge"><a class="header" href="#contribute-to-wasmedge">Contribute to WasmEdge</a></h1>
<p>WasmEdge is developed in the open, and is constantly being improved by our <strong>users, contributors, and maintainers</strong>. It is because of you that we can bring great software to the community.</p>
<p>This guide provides information on filing issues and guidelines for open source contributors. <strong>Please leave comments / suggestions if you find something is missing or incorrect.</strong></p>
<p>WasmEdge follows the <a href="contribute/release_process.html">release process</a> to release the new versions.</p>
<p>For contributing to WasmEdge, you can follow the <a href="contribute/contribute.html">contribution guide</a> and <a href="contribute/build_from_src.html">build from source</a> first.</p>
<p>To understanding the architecture, you can refer to the <a href="contribute/internal.html">WasmEdge internal</a>.</p>
<p>If you are looking for ideas for contribution, <a href="contribute/wish_list.html">here is a wish list</a> of items we'd like to get some help with!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="wasmedge-release-process"><a class="header" href="#wasmedge-release-process">WasmEdge Release Process</a></h1>
<h2 id="create-the-releasing-process-issue-of-the-new-version"><a class="header" href="#create-the-releasing-process-issue-of-the-new-version">Create the releasing process issue of the new version</a></h2>
<ul>
<li><input disabled="" type="checkbox"/>
Keep adding the new features, issues, documents, and builds check list into the issue.</li>
<li><input disabled="" type="checkbox"/>
Add the GitHub project of the new version.</li>
</ul>
<h2 id="write-changelog"><a class="header" href="#write-changelog">Write Changelog</a></h2>
<ul>
<li><input disabled="" type="checkbox"/>
Make sure every change is written in the changelog.</li>
<li><input disabled="" type="checkbox"/>
Make sure the <code>Changelog.md</code> has the correct version number and the release date.</li>
<li><input disabled="" type="checkbox"/>
Copy the changelog of this version to <code>.CurrentChangelog.md</code>. (Our release CI will take this file as the release notes.)</li>
<li><input disabled="" type="checkbox"/>
Record the contributor lists.</li>
<li><input disabled="" type="checkbox"/>
Create a pull request, make sure the CI are all passed, and merge it.</li>
</ul>
<h2 id="create-the-alpha-pre-release"><a class="header" href="#create-the-alpha-pre-release">Create the Alpha Pre-Release</a></h2>
<ul>
<li><input disabled="" type="checkbox"/>
In this step, the main features are completed. No more major feature will be merged after the first Alpha pre-release.</li>
<li><input disabled="" type="checkbox"/>
Make sure that the features in the releasing process issue are completed.</li>
<li><input disabled="" type="checkbox"/>
Use git tag to create a new release tag <code>major.minor.patch-alpha.version</code>. And push this tag to GitHub.</li>
<li><input disabled="" type="checkbox"/>
Wait for the CI builds and pushes the release binaries and release notes to the GitHub release page.</li>
<li><input disabled="" type="checkbox"/>
Check the <code>Pre-release</code> checkbox and publish the pre-release.</li>
<li><input disabled="" type="checkbox"/>
This step will automatically close and turn into Beta or RC phase in about 3 days if there's no critical issues.</li>
</ul>
<h2 id="create-the-beta-pre-release"><a class="header" href="#create-the-beta-pre-release">Create the Beta Pre-Release</a></h2>
<ul>
<li><input disabled="" type="checkbox"/>
This step is for the issue fixing if needed. No more feature will be accepted.</li>
<li><input disabled="" type="checkbox"/>
Make sure that all the features in the releasing process issue are completed.</li>
<li><input disabled="" type="checkbox"/>
Use git tag to create a new release tag <code>major.minor.patch-beta.version</code>. And push this tag to GitHub.</li>
<li><input disabled="" type="checkbox"/>
Wait for the CI builds and pushes the release binaries and release notes to the GitHub release page.</li>
<li><input disabled="" type="checkbox"/>
Check the <code>Pre-release</code> checkbox and publish the pre-release.</li>
<li><input disabled="" type="checkbox"/>
This step will automatically close and turn into RC phase in about 3 days if there's no critical issues.</li>
</ul>
<h2 id="create-the-rc-pre-release"><a class="header" href="#create-the-rc-pre-release">Create the RC Pre-Release</a></h2>
<ul>
<li><input disabled="" type="checkbox"/>
In this step, the issue fixing is finished. The <code>RC</code> pre-releases are for the installation, bindings, and packages testing.</li>
<li><input disabled="" type="checkbox"/>
Make sure that all the issues in the releasing process issue are completed.</li>
<li><input disabled="" type="checkbox"/>
Update <code>WASMEDGE_CAPI_VERSION</code> in <code>CMakeLists.txt</code>.</li>
<li><input disabled="" type="checkbox"/>
Update <code>wasmedge_version</code> in <code>docs/book/en/book.toml</code>.</li>
<li><input disabled="" type="checkbox"/>
Use git tag to create a new release tag <code>major.minor.patch-rc.version</code>. And push this tag to GitHub.</li>
<li><input disabled="" type="checkbox"/>
Wait for the CI builds and pushes the release binaries and release notes to the GitHub release page.</li>
<li><input disabled="" type="checkbox"/>
Check the <code>Pre-release</code> checkbox and publish the pre-release.</li>
<li><input disabled="" type="checkbox"/>
This step will automatically close and announce the official release in about 3 days if there's no critical issues.</li>
</ul>
<h2 id="create-the-official-release"><a class="header" href="#create-the-official-release">Create the Official Release</a></h2>
<ul>
<li><input disabled="" type="checkbox"/>
Make sure the <code>Changelog.md</code> and <code>.CurrentChangelog.md</code> have the correct version number and the release date.</li>
<li><input disabled="" type="checkbox"/>
Use git tag to create a new release tag <code>major.minor.patch</code>. And push this tag to GitHub.</li>
<li><input disabled="" type="checkbox"/>
Wait for the CI builds and push the release binaries and release notes to the GitHub release page.</li>
<li><input disabled="" type="checkbox"/>
Publish the release.</li>
<li><input disabled="" type="checkbox"/>
Close the releasing process issue and the GitHub project.</li>
</ul>
<h2 id="update-the-extensions"><a class="header" href="#update-the-extensions">Update the Extensions</a></h2>
<p>The following projects will be updated with the <code>Alpha</code>, <code>Beta</code>, and <code>RC</code> pre-releases and the official release:</p>
<ul>
<li><input disabled="" type="checkbox"/>
<a href="https://github.com/second-state/WasmEdge-image">WasmEdge-Image</a></li>
<li><input disabled="" type="checkbox"/>
<a href="https://github.com/second-state/WasmEdge-tensorflow-deps">WasmEdge-TensorFlow-Deps</a></li>
<li><input disabled="" type="checkbox"/>
<a href="https://github.com/second-state/WasmEdge-tensorflow">WasmEdge-TensorFlow</a></li>
<li><input disabled="" type="checkbox"/>
<a href="https://github.com/second-state/WasmEdge-tensorflow-tools">WasmEdge-TensorFlow-Tools</a></li>
<li><input disabled="" type="checkbox"/>
<a href="https://github.com/second-state/WasmEdge-go">WasmEdge-Go SDK</a></li>
<li><input disabled="" type="checkbox"/>
<a href="https://github.com/second-state/wasmedge-core">WasmEdge-core NAPI package</a></li>
<li><input disabled="" type="checkbox"/>
<a href="https://github.com/second-state/wasmedge-extensions">WasmEdge-extensions NAPI package</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="contribution-steps"><a class="header" href="#contribution-steps">Contribution Steps</a></h1>
<h2 id="setup-development-environment"><a class="header" href="#setup-development-environment">Setup Development Environment</a></h2>
<p>The WasmEdge is developed on Ubuntu 20.04 to take advantage of advanced LLVM features for the AOT compiler. The WasmEdge team also builds and releases statically linked WasmEdge binaries for older Linux distributions.</p>
<p>Our development environment requires <code>libLLVM-12</code> and <code>&gt;=GLIBCXX_3.4.26</code>.</p>
<p>If you are using an operating system older than Ubuntu 20.04, please use our <a href="contribute/../quick_start/use_docker.html#docker-images-for-building-wasmedge">special docker image</a> to build WasmEdge. If you are looking for the pre-built binaries for the older operating system, we also provide several pre-built binaries based on <code>manylinux2014</code> distribution.</p>
<p>Build WasmEdge please refer to: <a href="contribute/build_from_src.html">Build WasmEdge from source</a>.</p>
<h2 id="contribution-workflow"><a class="header" href="#contribution-workflow">Contribution Workflow</a></h2>
<p>Pull requests are always welcome, even if they only contain small fixes like typos or a few lines of code. If there will be a significant effort, please document it as an issue and get a discussion going before starting to work on it.</p>
<p>Please submit a pull request broken down into small changes bit by bit. A pull request consisting of a lot features and code changes may be hard to review. It is recommended to submit pull requests in an incremental fashion.</p>
<blockquote>
<p>If you split your pull request into small changes, please make sure any of the changes that goes to master will not break anything. Otherwise, it can not be merged until this feature is complete.</p>
</blockquote>
<h3 id="fork-and-clone-the-repository"><a class="header" href="#fork-and-clone-the-repository">Fork and Clone the Repository</a></h3>
<p>Fork <a href="https://github.com/WasmEdge/WasmEdge">the WasmEdge repository</a> and clone the code to your local workspace</p>
<blockquote>
<p>The WasmEdge team builds lots of extensions of Server-side WebAssembly, see <a href="https://github.com/second-state/WasmEdge-tensorflow">TensorFlow</a>, <a href="https://github.com/second-state/WasmEdge-storage">Storage</a>, <a href="https://github.com/second-state/wasmedge_process_interface">Command interface</a>, <a href="https://github.com/second-state/WasmEdge-evmc">Ethereum</a>, <a href="https://github.com/ParaState/substrate-ssvm-node">Substrate</a>. If you want to contribute to the extensions, please go to those repositories.</p>
</blockquote>
<h3 id="branches-and-commits"><a class="header" href="#branches-and-commits">Branches and Commits</a></h3>
<p>Changes should be made on your own fork in a new branch. Pull requests should be rebased on the top of master.</p>
<p>The WasmEdge project adopts <a href="https://community.openhab.org/t/dco-check-signing-off-with-github-web-editor-explanation/83330">DCO</a> to manage all contributions. Please make sure you add your <code>sign-off-statement</code> through the <code>-s</code> or <code>--signoff</code> flag or the GitHub Web UI before committing the pull request message.</p>
<h3 id="develop-build-and-test"><a class="header" href="#develop-build-and-test">Develop, Build and Test</a></h3>
<p>Write code on the new branch in your fork, and <a href="contribute/build_from_src.html">build from source code</a> with the option <code>-DWASMEDGE_BUILD_TESTS=ON</code>.</p>
<p>Then you can use these tests to verify the correctness of WasmEdge binaries.</p>
<pre><code class="language-bash">cd &lt;path/to/wasmedge/build_folder&gt;
LD_LIBRARY_PATH=$(pwd)/lib/api ctest
</code></pre>
<h3 id="push-and-create-a-pull-request"><a class="header" href="#push-and-create-a-pull-request">Push and Create A Pull Request</a></h3>
<p>When ready for review, push your branch to your fork repository on github.</p>
<p>Then visit your fork at <a href="https://github.com/$user/WasmEdge">https://github.com/$user/WasmEdge</a> and click the <code>Compare &amp; Pull Request</code> button next to your branch to create a new pull request. Description of a pull request should refer to all the issues that it addresses. Remember to put a reference to issues (such as Closes #XXX and Fixes #XXX) in the comment so that the issues can be closed when the PR is merged. After creating a pull request, please check that the CI passes with your code changes.</p>
<p>Once your pull request has been opened it will be assigned to one or more reviewers. Those reviewers will do a thorough code review, looking for correctness, bugs, opportunities for improvement, documentation and comments, and coding style.</p>
<p>Commit changes made in response to review comments to the same branch on your fork.</p>
<h2 id="reporting-issues"><a class="header" href="#reporting-issues">Reporting issues</a></h2>
<p>It is a great way to contribute to WasmEdge by reporting an issue. Well-written and complete bug reports are always welcome! Please open an issue on Github.</p>
<p>Before opening any issue, please look up the existing <a href="https://github.com/WasmEdge/WasmEdge/issues">issues</a> to avoid submitting a duplication. If you find a match, you can &quot;subscribe&quot; to it to get notified on updates. If you have additional helpful information about the issue, please leave a comment.</p>
<p>When reporting issues, always include:</p>
<ul>
<li>Version of your system</li>
<li>Configuration files of WasmEdge</li>
</ul>
<p>Because the issues are open to the public, when submitting the log and configuration files, be sure to remove any sensitive information, e.g. user name, password, IP address, and company name. You can replace those parts with &quot;REDACTED&quot; or other strings like &quot;****&quot;.
Be sure to include the steps to reproduce the problem if applicable. It can help us understand and fix your issue faster.</p>
<h2 id="documenting"><a class="header" href="#documenting">Documenting</a></h2>
<p>Update the documentation if you are creating or changing features. Good documentation is as important as the code itself.
Documents are written with Markdown. See <a href="https://help.github.com/categories/writing-on-github/">Writing on GitHub</a> for more details.</p>
<h2 id="design-new-features"><a class="header" href="#design-new-features">Design new features</a></h2>
<p>You can propose new designs for existing WasmEdge features. You can also design entirely new features, please submit a proposal via the GitHub issues.</p>
<p>WasmEdge maintainers will review this proposal as soon as possible. This is necessary to ensure the overall architecture is consistent and to avoid duplicated work in the roadmap.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="build-wasmedge-from-source"><a class="header" href="#build-wasmedge-from-source">Build WasmEdge from source</a></h1>
<p>Please follow this guide to build and test WasmEdge from the source code.</p>
<ul>
<li><a href="contribute/build_from_src/linux.html">Linux</a></li>
<li><a href="contribute/build_from_src/macos.html">MacOS</a></li>
<li><a href="contribute/build_from_src/windows.html">Windows</a></li>
<li><a href="contribute/build_from_src/android.html">Android</a></li>
<li><a href="contribute/build_from_src/sel4.html">seL4</a></li>
<li><a href="contribute/build_from_src/raspberrypi.html">Raspberry Pi</a></li>
<li><a href="contribute/build_from_src/openwrt.html">OpenWrt</a></li>
<li><a href="contribute/build_from_src/openharmony.html">OpenHarmony</a></li>
</ul>
<blockquote>
<p>If you just want the latest builds from the <code>HEAD</code> of the <code>master</code> branch, and do not want to build it yourself, you can download the release package directly from our Github Action's CI artifact. <a href="https://github.com/WasmEdge/WasmEdge/actions/runs/1521549504#artifacts">Here is an example</a>.</p>
</blockquote>
<h2 id="what-will-be-built"><a class="header" href="#what-will-be-built">What Will Be Built</a></h2>
<p>WasmEdge provides various tools for enabling different runtime environments for optimal performance.
You can find that there are several wasmedge related tools:</p>
<ol>
<li><code>wasmedge</code> is the general wasm runtime.
<ul>
<li><code>wasmedge</code> executes a <code>WASM</code> file in the interpreter mode or a compiled <code>WASM</code> file in the ahead-of-time compilation mode.</li>
<li>To disable building all tools, you can set the CMake option <code>WASMEDGE_BUILD_TOOLS</code> to <code>OFF</code>.</li>
</ul>
</li>
<li><code>wasmedgec</code> is the ahead-of-time <code>WASM</code> compiler.
<ul>
<li><code>wasmedgec</code> compiles a general <code>WASM</code> file into a compiled <code>WASM</code> file.</li>
<li>To disable building the ahead-of-time compiler only, you can set the CMake option <code>WASMEDGE_BUILD_AOT_RUNTIME</code> to <code>OFF</code>.</li>
</ul>
</li>
<li><code>libwasmedge.so</code> is the WasmEdge C API shared library. (<code>libwasmedge.dylib</code> on MacOS and <code>wasmedge.dll</code> on Windows)
<ul>
<li><code>libwasmedge.so</code>, <code>libwasmedge.dylib</code>, or <code>wasmedge.dll</code> provides the C API for the ahead-of-time compiler and the WASM runtime.</li>
<li>The APIs related to the ahead-of-time compiler will always fail if the CMake option <code>WASMEDGE_BUILD_AOT_RUNTIME</code> is set as <code>OFF</code>.</li>
<li>To disable building just the shared library, you can set the CMake option <code>WASMEDGE_BUILD_SHARED_LIB</code> to <code>OFF</code>.</li>
</ul>
</li>
<li><code>ssvm-qitc</code> is for AI applications and supports the ONNC runtime for AI models in the ONNX format.
<ul>
<li>If you want to try <code>ssvm-qitc</code>, please refer to <a href="https://github.com/ONNC/onnc-wasm">ONNC-Wasm</a> project to set up the working environment and tryout several examples.</li>
<li>And here is our <a href="https://www.youtube.com/watch?v=cbiPuHMS-iQ">tutorial for ONNC-Wasm project(YouTube Video)</a>.</li>
</ul>
</li>
</ol>
<h2 id="cmake-building-options"><a class="header" href="#cmake-building-options">CMake Building Options</a></h2>
<p>Developers can set the CMake options to customize the WasmEdge building.</p>
<ol>
<li><code>WASMEDGE_BUILD_TESTS</code>: build the WasmEdge tests. Default is <code>OFF</code>.</li>
<li><code>WASMEDGE_BUILD_AOT_RUNTIME</code>: build with the Ahead-of-Time compiler supporting. Default is <code>ON</code>.</li>
<li><code>WASMEDGE_BUILD_SHARED_LIB</code>: build the WasmEdge shared library (<code>libwasmedge.so</code>, <code>libwasmedge.dylib</code>, or <code>wasmedge.dll</code>). Default is <code>ON</code>.
<ul>
<li>By default, the WasmEdge shared library will link to the LLVM shared library.</li>
</ul>
</li>
<li><code>WASMEDGE_BUILD_STATIC_LIB</code>: build the WasmEdge static library (<code>libwasmedge.a</code>, Linux and MacOS platforms, experimental). Default is <code>OFF</code>.
<ul>
<li>If this option is set as <code>ON</code>, the option <code>WASMEDGE_FORCE_DISABLE_LTO</code> will forcefully be set as <code>ON</code>.</li>
<li>If this option is set as <code>ON</code>, the <code>libz</code> and <code>libtinfo</code> on Linux platforms will be statically linked.</li>
</ul>
</li>
<li><code>WASMEDGE_BUILD_TOOLS</code>: build the <code>wasmedge</code> and <code>wasmedgec</code> tools. Default is <code>ON</code>.
<ul>
<li>The <code>wasmedge</code> and <code>wasmedgec</code> tools will link to the WasmEdge shared library by default.</li>
<li>If this option is set as <code>ON</code> and <code>WASMEDGE_BUILD_AOT_RUNTIME</code> is set as <code>OFF</code>, the <code>wasmedgec</code> tool for the AOT compiler will not be built.</li>
<li>If this option is set as <code>ON</code> but the option <code>WASMEDGE_LINK_TOOLS_STATIC</code> is set as <code>OFF</code>, the option <code>WASMEDGE_BUILD_SHARED_LIB</code> will forcefully be set as <code>ON</code>.</li>
<li>If this option and the option <code>WASMEDGE_LINK_TOOLS_STATIC</code> are both set as <code>ON</code>, the <code>WASMEDGE_LINK_LLVM_STATIC</code> and <code>WASMEDGE_BUILD_STATIC_LIB</code> will both be set as <code>ON</code>, and the <code>wasmedge</code> and <code>wasmedgec</code> tools will link to the WasmEdge static library instead. In this case, the plugins will not work in tools.</li>
</ul>
</li>
<li><code>WASMEDGE_BUILD_PLUGINS</code>: build the WasmEdge plugins. Default is <code>ON</code>.</li>
<li><code>WASMEDGE_BUILD_EXAMPLE</code>: build the WasmEdge examples. Default is <code>OFF</code>.</li>
<li><code>WASMEDGE_PLUGIN_WASI_NN_BACKEND</code>: build the WasmEdge WASI-NN plugin (Linux platforms only). Default is empty.
<ul>
<li>This option is useless if the option <code>WASMEDGE_BUILD_PLUGINS</code> is set as <code>OFF</code>.</li>
<li>To build the WASI-NN plugin with backend, please use <code>-DWASMEDGE_PLUGIN_WASI_NN_BACKEND=&lt;backend_name&gt;</code>.</li>
<li>To build the WASI-NN plugin with multiple backends, please use <code>-DWASMEDGE_PLUGIN_WASI_NN_BACKEND=&lt;backend_name1&gt;,&lt;backend_name2&gt;</code>.</li>
</ul>
</li>
<li><code>WASMEDGE_PLUGIN_WASI_CRYPTO</code>: build the WasmEdge WASI-Crypto plugin (Linux platforms only). Default is <code>OFF</code>.
<ul>
<li>This option is useless if the option <code>WASMEDGE_BUILD_PLUGINS</code> is set as <code>OFF</code>.</li>
</ul>
</li>
<li><code>WASMEDGE_FORCE_DISABLE_LTO</code>: forcefully turn off the link time optimization. Default is <code>OFF</code>.</li>
<li><code>WASMEDGE_LINK_LLVM_STATIC</code>: link the LLVM and lld libraries statically (Linux and MacOS platforms only, experimental). Default is <code>OFF</code>.</li>
<li><code>WASMEDGE_LINK_TOOLS_STATIC</code>: make the <code>wasmedge</code> and <code>wasmedgec</code> tools to link the WasmEdge library and LLVM libraries statically (Linux and MacOS platforms only, experimental). Default is <code>OFF</code>.
<ul>
<li>If the option <code>WASMEDGE_BUILD_TOOLS</code> and this option are both set as <code>ON</code>, the <code>WASMEDGE_LINK_LLVM_STATIC</code> will be set as <code>ON</code>.</li>
</ul>
</li>
</ol>
<h2 id="build-wasmedge-with-plug-ins"><a class="header" href="#build-wasmedge-with-plug-ins">Build WasmEdge with Plug-ins</a></h2>
<p>Developers can follow the steps to build WasmEdge with plug-ins from source.</p>
<ul>
<li><a href="contribute/build_from_src/plugin_wasi_nn.html">WASI-NN (OpenVINO and PyTorch backends)</a></li>
<li><a href="contribute/build_from_src/plugin_wasi_crypto.html">WASI-Crypto</a></li>
<li><a href="contribute/build_from_src/plugin_wasmedge_httpsreq.html">WasmEdge-HttpsReq</a></li>
</ul>
<h2 id="run-tests"><a class="header" href="#run-tests">Run Tests</a></h2>
<p>The tests are only available when the build option <code>WASMEDGE_BUILD_TESTS</code> is set to <code>ON</code>.</p>
<p>Users can use these tests to verify the correctness of WasmEdge binaries built.</p>
<pre><code class="language-bash">cd &lt;path/to/wasmedge/build_folder&gt;
LD_LIBRARY_PATH=$(pwd)/lib/api ctest
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="build-wasmedge-on-linux"><a class="header" href="#build-wasmedge-on-linux">Build WasmEdge on Linux</a></h1>
<h2 id="get-the-source-code"><a class="header" href="#get-the-source-code">Get the Source Code</a></h2>
<pre><code class="language-bash">git clone https://github.com/WasmEdge/WasmEdge.git
cd WasmEdge
</code></pre>
<h2 id="prepare-the-environment"><a class="header" href="#prepare-the-environment">Prepare the Environment</a></h2>
<h3 id="docker-images"><a class="header" href="#docker-images">Docker Images</a></h3>
<p>The easiest way to setup the environment is using the WasmEdge docker images.</p>
<p>You can use the following commands to get our latest docker image <a href="https://hub.docker.com/search?q=wasmedge">from dockerhub</a>:</p>
<pre><code class="language-bash">docker pull wasmedge/wasmedge # Pulls the latest - wasmedge/wasmedge:latest
</code></pre>
<p>Or you can pull with the <a href="contribute/build_from_src/../../quick_start/use_docker.html#docker-images-for-building-wasmedge">available tags</a>.</p>
<h3 id="install-dependencies-on-ubuntu-2004-manually"><a class="header" href="#install-dependencies-on-ubuntu-2004-manually">Install Dependencies on Ubuntu 20.04 Manually</a></h3>
<p>For the developers who don't want to use docker, they can setup the environment on Ubuntu Manually.</p>
<p>Please check that these dependencies are satisfied.</p>
<ul>
<li>LLVM 12.0.0 (&gt;= 10.0.0)</li>
<li>GCC 11.1.0 (&gt;= 9.4.0)</li>
</ul>
<pre><code class="language-bash"># Tools and libraries
sudo apt install -y \
   software-properties-common \
   cmake \
   libboost-all-dev

# And you will need to install llvm for the AOT runtime
sudo apt install -y \
   llvm-12-dev \
   liblld-12-dev

# WasmEdge supports both clang++ and g++ compilers.
# You can choose one of them to build this project.
# If you prefer GCC, then:
sudo apt install -y gcc g++
# Or if you prefer clang, then:
sudo apt install -y clang-12
</code></pre>
<h3 id="support-for-legacy-operating-systems"><a class="header" href="#support-for-legacy-operating-systems">Support for Legacy Operating Systems</a></h3>
<p>Our development environment requires <code>libLLVM-12</code> and <code>&gt;=GLIBCXX_3.4.33</code>.</p>
<p>If users are using operating systems older than Ubuntu 20.04, please use our special docker image to build WasmEdge.
If you are looking for the pre-built binaries for the older operating system, we also provide several pre-built binaries based on <code>manylinux*</code> distributions.</p>
<div class="table-wrapper"><table><thead><tr><th>Docker Image</th><th>Base Image</th><th>Provided Requirements</th></tr></thead><tbody>
<tr><td><code>wasmedge/wasmedge:manylinux2014_x86_64</code></td><td>CentOS 7.9</td><td>GLIBC &lt;= 2.17</br>CXXABI &lt;= 1.3.7</br>GLIBCXX &lt;= 3.4.19</br>GCC &lt;= 4.8.0</td></tr>
<tr><td><code>wasmedge/wasmedge:manylinux2014_aarch64</code></td><td>CentOS 7.9</td><td>GLIBC &lt;= 2.17</br>CXXABI &lt;= 1.3.7</br>GLIBCXX &lt;= 3.4.19</br>GCC &lt;= 4.8.0</td></tr>
</tbody></table>
</div>
<h2 id="build-wasmedge"><a class="header" href="#build-wasmedge">Build WasmEdge</a></h2>
<p>Please refer to <a href="contribute/build_from_src/../build_from_src.html#cmake-building-options">here</a> for the descriptions of all CMake options.</p>
<pre><code class="language-bash"># After pulling our wasmedge docker image
docker run -it --rm \
    -v &lt;path/to/your/wasmedge/source/folder&gt;:/root/wasmedge \
    wasmedge/wasmedge:latest
# In docker
cd /root/wasmedge
# If you don't use docker then you need to run only the following commands in the cloned repository root
mkdir -p build &amp;&amp; cd build
cmake -DCMAKE_BUILD_TYPE=Release -DWASMEDGE_BUILD_TESTS=ON .. &amp;&amp; make -j
</code></pre>
<h2 id="run-tests-1"><a class="header" href="#run-tests-1">Run Tests</a></h2>
<p>The following tests are available only when the build option <code>WASMEDGE_BUILD_TESTS</code> is set to <code>ON</code>.</p>
<p>Users can use these tests to verify the correctness of WasmEdge binaries.</p>
<pre><code class="language-bash"># In docker
cd &lt;path/to/wasmedge/build_folder&gt;
LD_LIBRARY_PATH=$(pwd)/lib/api ctest
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="build-wasmedge-on-macos"><a class="header" href="#build-wasmedge-on-macos">Build WasmEdge on MacOS</a></h1>
<p>Currently, WasmEdge project on MacOS supports both Intel and M1 models. However, we only test and develop on <code>Catalina</code>, <code>Big Sur</code>, and <code>Monterey</code>.</p>
<ul>
<li>Model:
<ul>
<li>Intel</li>
<li>M1</li>
</ul>
</li>
<li>Operating System
<ul>
<li>Monterey</li>
<li>Big Sur</li>
<li>Catalina</li>
</ul>
</li>
</ul>
<p>If you would like to develop WasmEdge on MacOS, please follow this guide to build and test from source code.</p>
<h2 id="get-source-code"><a class="header" href="#get-source-code">Get Source Code</a></h2>
<pre><code class="language-bash">git clone https://github.com/WasmEdge/WasmEdge.git
cd WasmEdge
</code></pre>
<h2 id="requirements-and-dependencies"><a class="header" href="#requirements-and-dependencies">Requirements and Dependencies</a></h2>
<p>WasmEdge will try to use the latest LLVM release to create our nightly build.
If you want to build from source, you may need to install these dependencies by yourself.</p>
<ul>
<li>LLVM 14.0.1 (&gt;= 10.0.0)</li>
</ul>
<pre><code class="language-bash"># Tools and libraries
brew install boost cmake ninja llvm
export LLVM_DIR=&quot;/usr/local/opt/llvm/lib/cmake&quot;
export CC=clang
export CXX=clang++
</code></pre>
<h2 id="build-wasmedge-1"><a class="header" href="#build-wasmedge-1">Build WasmEdge</a></h2>
<p>Please refer to <a href="contribute/build_from_src/../build_from_src.html#cmake-building-options">here</a> for the descriptions of all CMake options.</p>
<pre><code class="language-bash">cmake -Bbuild -GNinja -DWASMEDGE_BUILD_TESTS=ON .
cmake --build build
</code></pre>
<p>If you don't want to dynamically link LLVM on MacOS, you can set the option <code>WASMEDGE_LINK_LLVM_STATIC</code> to <code>ON</code>.</p>
<h2 id="run-tests-2"><a class="header" href="#run-tests-2">Run Tests</a></h2>
<p>The following tests are available only when the build option <code>WASMEDGE_BUILD_TESTS</code> is set to <code>ON</code>.</p>
<p>Users can use these tests to verify the correctness of WasmEdge binaries.</p>
<pre><code class="language-bash">cd build
DYLD_LIBRARY_PATH=$(pwd)/lib/api ctest
</code></pre>
<h2 id="known-issues"><a class="header" href="#known-issues">Known issues</a></h2>
<p>The following tests can not pass on macos, we are investigating these issues:</p>
<ul>
<li>wasmedgeWasiSocketTests</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="build-wasmedge-on-windows-10"><a class="header" href="#build-wasmedge-on-windows-10">Build WasmEdge on Windows 10</a></h1>
<p>You can also find the details <a href="https://github.com/WasmEdge/WasmEdge/blob/master/.github/workflows/reusable-build-on-windows.yml#L37-L48">here</a>.</p>
<h2 id="get-source-code-1"><a class="header" href="#get-source-code-1">Get Source Code</a></h2>
<pre><code class="language-bash">git clone https://github.com/WasmEdge/WasmEdge.git
cd WasmEdge
</code></pre>
<h2 id="requirements-and-dependencies-1"><a class="header" href="#requirements-and-dependencies-1">Requirements and Dependencies</a></h2>
<p>WasmEdge requires LLVM 13 and you may need to install these following dependencies by yourself.</p>
<ul>
<li>Chocolatey, we use it to install <code>cmake</code>, <code>ninja</code>, and <code>vswhere</code>.</li>
<li>Windows SDK 19041</li>
<li>LLVM 13.0.1, you can find the pre-built files <a href="https://github.com/WasmEdge/llvm-windows/releases">here</a> or you can just follow the <code>instructions/commands</code> to download automatically.</li>
</ul>
<pre><code class="language-powershell"># Install the required tools
choco install cmake ninja vswhere

$vsPath = (vswhere -latest -property installationPath)
Import-Module (Join-Path $vsPath &quot;Common7\Tools\Microsoft.VisualStudio.DevShell.dll&quot;)
Enter-VsDevShell -VsInstallPath $vsPath -SkipAutomaticLocation -DevCmdArguments &quot;-arch=x64 -host_arch=x64 -winsdk=10.0.19041.0&quot;

# Download our pre-built LLVM 13 binary
$llvm = &quot;LLVM-13.0.1-win64.zip&quot;
curl -sLO https://github.com/WasmEdge/llvm-windows/releases/download/llvmorg-13.0.1/LLVM-13.0.1-win64.zip -o $llvm
Expand-Archive -Path $llvm

# Set LLVM environment
$llvm_dir = &quot;$pwd\\LLVM-13.0.1-win64\\LLVM-13.0.1-win64\\lib\\cmake\\llvm&quot;
$Env:CC = &quot;clang-cl&quot;
$Env:CXX = &quot;clang-cl&quot;
</code></pre>
<h2 id="build-wasmedge-2"><a class="header" href="#build-wasmedge-2">Build WasmEdge</a></h2>
<pre><code class="language-bash">$vsPath = (vswhere -latest -property installationPath)
Import-Module (Join-Path $vsPath &quot;Common7\Tools\Microsoft.VisualStudio.DevShell.dll&quot;)
Enter-VsDevShell -VsInstallPath $vsPath -SkipAutomaticLocation -DevCmdArguments &quot;-arch=x64 -host_arch=x64 -winsdk=10.0.19041.0&quot;

cmake -Bbuild -GNinja -DCMAKE_SYSTEM_VERSION=10.0.19041.0 -DCMAKE_MSVC_RUNTIME_LIBRARY=MultiThreadedDLL &quot;-DLLVM_DIR=$llvm_dir&quot; -DWASMEDGE_BUILD_TESTS=ON -DWASMEDGE_BUILD_PACKAGE=&quot;ZIP&quot; .
cmake --build build
</code></pre>
<h2 id="run-tests-3"><a class="header" href="#run-tests-3">Run Tests</a></h2>
<p>The following tests are available only when the build option <code>WASMEDGE_BUILD_TESTS</code> was set to <code>ON</code>.</p>
<p>Users can use these tests to verify the correctness of WasmEdge binaries.</p>
<pre><code class="language-bash">$vsPath = (vswhere -latest -property installationPath)
Import-Module (Join-Path $vsPath &quot;Common7\Tools\Microsoft.VisualStudio.DevShell.dll&quot;)
Enter-VsDevShell -VsInstallPath $vsPath -SkipAutomaticLocation -DevCmdArguments &quot;-arch=x64 -host_arch=x64 -winsdk=10.0.19041.0&quot;

$Env:PATH += &quot;;$pwd\\build\\lib\\api&quot;
cd build
ctest --output-on-failure
cd -
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="build-wasmedge-for-android"><a class="header" href="#build-wasmedge-for-android">Build WasmEdge for Android</a></h1>
<p>The WasmEdge Runtime releases come with pre-built binaries for the Android OS. Why WasmEdge on Android?</p>
<ul>
<li>Native speed &amp; sandbox safety for Android apps</li>
<li>Support multiple dev languages — eg C, <a href="contribute/build_from_src/../../write_wasm/rust.html">Rust</a>, <a href="contribute/build_from_src/../../write_wasm/swift.html">Swift</a>, <a href="contribute/build_from_src/../../write_wasm/go.html">Go</a> &amp; <a href="contribute/build_from_src/../../write_wasm/js.html">JS</a></li>
<li><a href="contribute/build_from_src/../../sdk.html">Embed 3rd party functions</a> in your android app</li>
<li><a href="contribute/build_from_src/../../use_cases/kubernetes.html">Kubernetes managed</a> android apps</li>
</ul>
<p>However, the WasmEdge installer does not support Android. The user must download the release files to a computer, and then use the <code>adb</code> tool to transfer the files to an Android device or simulator. We will show you how to do that.</p>
<ul>
<li><a href="contribute/build_from_src/android/cli.html">WasmEdge CLI tools for Android</a></li>
<li><a href="contribute/build_from_src/android/ndk.html">Call WasmEdge functions from an NDK native app</a></li>
<li><a href="contribute/build_from_src/android/apk.html">Call WasmEdge functions from an Android APK app</a></li>
</ul>
<h2 id="build-from-source-for-android-platforms"><a class="header" href="#build-from-source-for-android-platforms">Build from source for Android platforms</a></h2>
<p>Please follow this guide to build and test WasmEdge from source code with Android NDK.</p>
<blockquote>
<p>In current state, we only support the runtime for the interpreter mode.</p>
</blockquote>
<h2 id="prepare-the-environment-1"><a class="header" href="#prepare-the-environment-1">Prepare the Environment</a></h2>
<p>We recommand developers to <a href="contribute/build_from_src/linux.html##prepare-the-environment">use our Docker images</a> and follow the steps to prepare the building environment.</p>
<ul>
<li>Download and extract the <a href="https://developer.android.com/ndk/downloads">Android NDK 23b</a>.</li>
<li>Check the cmake for <a href="https://cmake.org/download/">CMake 3.21</a> or greater version.</li>
<li>Download and install the <a href="https://developer.android.com/studio/releases/platform-tools">ADB platform tools</a>.
<ul>
<li>If you use the debian or ubuntu Linux distributions, you can install the ADB platform tools via <code>apt</code>.</li>
</ul>
</li>
<li>An Android device which is <a href="https://developer.android.com/studio/debug/dev-options">enabled developer options and USB debugging</a> and with at least Android 6.0 or higher system version.</li>
</ul>
<h2 id="build-wasmedge-for-android-platforms"><a class="header" href="#build-wasmedge-for-android-platforms">Build WasmEdge for Android platforms</a></h2>
<p>Get the WasmEdge source code.</p>
<pre><code class="language-bash">git clone https://github.com/WasmEdge/WasmEdge.git
cd WasmEdge
</code></pre>
<p>Add the Android NDK path into the environment variable.</p>
<pre><code class="language-bash">export ANDROID_NDK_HOME=path/to/you/ndk/dir
</code></pre>
<p>Run the build script in WasmEdge source code. This script will automatically build the WasmEdge for Android, and the results are in the <code>build</code> folder.</p>
<pre><code class="language-bash">./utils/android/standalone/build_for_android.sh
</code></pre>
<h2 id="test-the-wasmedge-cli-on-android-platforms"><a class="header" href="#test-the-wasmedge-cli-on-android-platforms">Test the WasmEdge CLI on Android platforms</a></h2>
<h3 id="push-the-wasmedge-cli-and-related-test-data-onto-android-platforms"><a class="header" href="#push-the-wasmedge-cli-and-related-test-data-onto-android-platforms">Push the WasmEdge CLI and related test data onto Android platforms</a></h3>
<ol>
<li>
<p>Connect the device by using a USB cable or Wi-Fi. Then you can check the attached devices via the <code>adb devices</code> command.</p>
<pre><code class="language-bash">$ adb devices
List of devices attached
0a388e93      device
</code></pre>
</li>
<li>
<p>Use the <code>adb push</code> command to push the entire <code>build/tools/wasmedge</code> folder into the <code>/data/local/tmp</code> folder on your Android device.</p>
<pre><code class="language-bash">cp -r examples build/tools/wasmedge/examples
cd build
adb push ./tools/wasmedge /data/local/tmp
</code></pre>
</li>
</ol>
<h3 id="run-wasmedge-cli-on-android-platforms"><a class="header" href="#run-wasmedge-cli-on-android-platforms">Run WasmEdge CLI on Android platforms</a></h3>
<ol>
<li>Please use the <code>adb shell</code> command to access into the Android device.</li>
<li>Follow the steps to test the WasmEdge CLI on the Android device.</li>
</ol>
<pre><code class="language-bash">$ cd /data/local/tmp/wasmedge/examples
$ ../wasmedge hello.wasm 1 2 3
hello
1
2
3

$ ../wasmedge --reactor add.wasm add 2 2
4

$ ../wasmedge --reactor fibonacci.wasm fib 8
34

$ ../wasmedge --reactor factorial.wasm fac 12
479001600

$ cd js
$ ./../wasmedge --dir .:. qjs.wasm hello.js 1 2 3
Hello 1 2 3
</code></pre>
<h2 id="notice"><a class="header" href="#notice">Notice</a></h2>
<ul>
<li>For the Android 10 or greater versions, SELinux will disallow the untrusted applications' <code>exec()</code> system call to execute the binaries in <code>home</code> or <code>/data/local/tmp</code> folder.</li>
<li>The Android SELinux policy will disallow the untrusted applications to access the <code>/data/local/tmp</code> folder.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="wasmedge-cli-tools-for-android"><a class="header" href="#wasmedge-cli-tools-for-android">WasmEdge CLI tools for Android</a></h1>
<p>In this section, we will show you how to use WasmEdge CLI tools on Android devices. We will showcase a full WasmEdge demo to perform image classification (Tensorflow-based AI inference) on an Android device.</p>
<h2 id="install-android-version-of-wasmedge-tensorflow-tools"><a class="header" href="#install-android-version-of-wasmedge-tensorflow-tools">Install Android version of WasmEdge-TensorFlow-Tools</a></h2>
<p>First, install WasmEdge-TensorFlow-Tools pre-release on your Android device. It works with the Android version of TensorFlow-Lite dynamic shared library.</p>
<h3 id="preparation"><a class="header" href="#preparation">Preparation</a></h3>
<h4 id="android-developer-options"><a class="header" href="#android-developer-options">Android developer options</a></h4>
<p>Currently, WasmEdge only supports the arm64-v8a architecture on Android devices. You need an arm64-v8a Android simulator or a physical device with <a href="https://developer.android.com/studio/debug/dev-options">developer options turned on</a>. WasmEdge requires Android 6.0 and above.</p>
<h4 id="android-development-cli"><a class="header" href="#android-development-cli">Android development CLI</a></h4>
<p>In Ubuntu Linux, you can use the <code>apt-get</code> command to install Android debugging and testing tool <code>adb</code>. Using the <code>adb shell</code> command on the Ubuntu dev machine, you can open a CLI shell to execute commands on the connected Android device.</p>
<pre><code class="language-bash">$ sudo apt-get install adb
$ adb devices
* daemon not running; starting now at tcp:5037
* daemon started successfully
List of devices attached
c657c643 device
$ adb shell
sirius:/ $
</code></pre>
<h3 id="install-wasmedge-tensorflow-tools-packages"><a class="header" href="#install-wasmedge-tensorflow-tools-packages">Install WasmEdge-TensorFlow-Tools packages</a></h3>
<p>Use the following commands on your Ubuntu dev machine to download the WasmEdge-TensorFlow-Tools pre-release packages.</p>
<pre><code class="language-bash">$ wget https://github.com/second-state/WasmEdge-tensorflow-tools/releases/download/0.11.1/WasmEdge-tensorflow-tools-0.11.1-android_aarch64.tar.gz
$ mkdir WasmEdge-tensorflow-tools &amp;&amp; tar zxvf WasmEdge-tensorflow-tools-0.11.1-android_aarch64.tar.gz -C WasmEdge-tensorflow-tools
show-tflite-tensor
wasmedge-tensorflow-lite
</code></pre>
<h3 id="install-android-version-of-the-tensorflow-lite-shared-library"><a class="header" href="#install-android-version-of-the-tensorflow-lite-shared-library">Install Android version of the TensorFlow-Lite shared library</a></h3>
<p>We provide an Android compatible version of TensorFlow-Lite dynamic shared library in the WasmEdge-Tensorflow-deps package. Download the package to your Ubuntu dev machine as follows.</p>
<pre><code class="language-bash">$ wget https://github.com/second-state/WasmEdge-tensorflow-deps/releases/download/0.11.1/WasmEdge-tensorflow-deps-TFLite-0.11.1-android_aarch64.tar.gz
$ tar zxvf WasmEdge-tensorflow-deps-TFLite-0.11.1-android_aarch64.tar.gz -C WasmEdge-tensorflow-tools
libtensorflowlite_c.so
</code></pre>
<p>Next use the <code>adb</code> tool to push the downloaded WasmEdge-TensorFlow packages onto a connected Android device.</p>
<pre><code class="language-bash">adb push WasmEdge-tensorflow-tools /data/local/tmp
</code></pre>
<h2 id="try-it-out"><a class="header" href="#try-it-out">Try it out</a></h2>
<h3 id="sample-application"><a class="header" href="#sample-application">Sample application</a></h3>
<p>In this example, we will demonstrate a standard <a href="https://github.com/second-state/wasm-learning/tree/master/rust/birds_v1">WasmEdge Tensorflow-Lite sample application</a>. It can recognize and classify the bird type from a JPG or PNG picture of a bird. The explanation of the source code can be <a href="contribute/build_from_src/android/../../../write_wasm/rust/tensorflow.html">found here</a>.</p>
<pre><code class="language-bash">git clone https://github.com/second-state/wasm-learning.git
cd wasm-learning/rust/birds_v1
</code></pre>
<p>Use the <code>cargo</code> command to build a Wasm bytecode file from the Rust source code. The Wasm file is located at <code>target/wasm32-wasi/release/birds_v1.wasm</code>.</p>
<pre><code class="language-bash">rustup target add wasm32-wasi
cargo build --release --target=wasm32-wasi
</code></pre>
<p>Push the Wasm bytecode file, tensorflow lite model file, and the test bird picture file onto the Android device using <code>adb</code>.</p>
<pre><code class="language-bash">adb push target/wasm32-wasi/release/birds_v1.wasm /data/local/tmp/WasmEdge-tensorflow-tools
adb push lite-model_aiy_vision_classifier_birds_V1_3.tflite /data/local/tmp/WasmEdge-tensorflow-tools
adb push bird.jpg /data/local/tmp/WasmEdge-tensorflow-tools
</code></pre>
<h3 id="run-the-wasmedge-tensorflow-tools"><a class="header" href="#run-the-wasmedge-tensorflow-tools">Run the WasmEdge-TensorFlow-Tools</a></h3>
<p>Type <code>adb shell</code> from the Ubuntu CLI to open a command shell for the connected Android device. Confirm that the tools, programs, and test image are all available on the Android device under the <code>/data/local/tmp/WasmEdge-tensorflow-tools</code> folder.</p>
<pre><code class="language-bash">$ adb shell
sirius:/ $ cd /data/local/tmp/WasmEdge-tensorflow-tools
sirius:/data/local/tmp/WasmEdge-tensorflow-tools $ ls
bird.jpg               lite-model_aiy_vision_classifier_birds_V1_3.tflite
birds_v1.wasm          show-tflite-tensor
libtensorflowlite_c.so wasmedge-tensorflow-lite
</code></pre>
<p>Load the TensorFlow-Lite dynamic shared library, and use the <code>show-tflite-tensor</code> CLI tool to examine the Tensorflow Lite model file.</p>
<pre><code class="language-bash">sirius:/data/local/tmp/WasmEdge-tensorflow-tools $ export LD_LIBRARY_PATH=.:$LD_LIBRARY_PATH
sirius:/data/local/tmp/WasmEdge-tensorflow-tools $ chmod 777 show-tflite-tensor
sirius:/data/local/tmp/WasmEdge-tensorflow-tools $ ./show-tflite-tensor lite-model_aiy_vision_classifier_birds_V1_3.tflite
INFO: Initialized TensorFlow Lite runtime.
Input tensor nums: 1
    Input tensor name: module/hub_input/images_uint8
        dimensions: [1 , 224 , 224 , 3]
        data type: UInt8
        tensor byte size: 150528
Output tensor nums: 1
    Output tensor name: module/prediction
        dimensions: [1 , 965]
        data type: UInt8
        tensor byte size: 965
</code></pre>
<p>Use the extended WasmEdge Runtime in <code>wasmedge-tensorflow-lite</code> to execute the compiled Wasm program on the Android device. It loads the Tensorflow Lite model and bird image, and outputs the bird classification and its confidence.</p>
<pre><code class="language-bash">sirius:/data/local/tmp/WasmEdge-tensorflow-tools $ chmod 777 wasmedge-tensorflow-lite
sirius:/data/local/tmp/WasmEdge-tensorflow-tools $ ./wasmedge-tensorflow-lite --dir .:. birds_v1.wasm lite-model_aiy_vision_classifier_birds_V1_3.tflite bird.jpg
INFO: Initialized TensorFlow Lite runtime.
166 : 0.84705883
</code></pre>
<p>The result shows that the bird type is in <a href="https://github.com/second-state/wasm-learning/blob/master/rust/birds_v1/aiy_birds_V1_labels.txt#L166">line 166 of the label file</a> (Sicalis flaveola) and the confidence level is 84.7%.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="call-wasmedge-functions-from-an-ndk-native-app"><a class="header" href="#call-wasmedge-functions-from-an-ndk-native-app">Call WasmEdge functions from an NDK native app</a></h1>
<p>In this section, we will demonstrate how to build an Android native application using C and the Android SDK. The native application uses the WasmEdge C SDK to embed the WasmEdge Runtime, and call WASM functions through WasmEdge.</p>
<h2 id="prerequisite-5"><a class="header" href="#prerequisite-5">Prerequisite</a></h2>
<h3 id="android"><a class="header" href="#android">Android</a></h3>
<p>Currently, WasmEdge only supports the arm64-v8a architecture on Android devices. You need an arm64-v8a Android simulator or a physical device with <a href="https://developer.android.com/studio/debug/dev-options">developer options turned on</a>. WasmEdge requires Android 6.0 and above.</p>
<h3 id="android-development-cli-1"><a class="header" href="#android-development-cli-1">Android development CLI</a></h3>
<p>In Ubuntu Linux, you can use the <code>apt-get</code> command to install Android debugging and testing tool <code>adb</code>. Using the <code>adb shell</code> command on the Ubuntu dev machine, you can open a CLI shell to execute commands on the connected Android device.</p>
<pre><code class="language-bash">sudo apt-get install adb
</code></pre>
<h3 id="android-ndk"><a class="header" href="#android-ndk">Android NDK</a></h3>
<p>To compile programs with the wasmedge-tensorflow c api, you need to install the <a href="https://developer.android.google.cn/ndk/downloads">Android NDK</a>. In this example, we use the latest LTS version (r23b).</p>
<h2 id="review-of-source-code"><a class="header" href="#review-of-source-code">Review of source code</a></h2>
<p>The <a href="https://github.com/second-state/wasm-learning/blob/master/android/test.c"><code>test.c</code></a> uses the wasmedge-tensorflow c api to run a WebAssembly function. The WebAssembly file <code>birds_v1.wasm</code> is compiled from Rust source code and <a href="contribute/build_from_src/android/../../../write_wasm/rust/tensorflow.html">explained here</a>.</p>
<pre><code class="language-c">#include &lt;wasmedge/wasmedge.h&gt;
#include &lt;wasmedge/wasmedge-image.h&gt;
#include &lt;wasmedge/wasmedge-tensorflowlite.h&gt;

#include &lt;stdio.h&gt;

int main(int argc, char *argv[]) {
  /*
   * argv[0]: ./a.out
   * argv[1]: WASM file
   * argv[2]: tflite model file
   * argv[3]: image file
   * Usage: ./a.out birds_v1.wasm lite-model_aiy_vision_classifier_birds_V1_3.tflite bird.jpg
   */

  /* Create the VM context. */
  WasmEdge_ConfigureContext *ConfCxt = WasmEdge_ConfigureCreate();
  WasmEdge_ConfigureAddHostRegistration(ConfCxt, WasmEdge_HostRegistration_Wasi);
  WasmEdge_VMContext *VMCxt = WasmEdge_VMCreate(ConfCxt, NULL);
  WasmEdge_ConfigureDelete(ConfCxt);
  
  /* Create the image and TFLite import objects. */
  WasmEdge_ImportObjectContext *ImageImpObj = WasmEdge_Image_ImportObjectCreate();
  WasmEdge_ImportObjectContext *TFLiteImpObj = WasmEdge_TensorflowLite_ImportObjectCreate();
  WasmEdge_ImportObjectContext *TFDummyImpObj = WasmEdge_Tensorflow_ImportObjectCreateDummy();

  /* Register into VM. */
  WasmEdge_VMRegisterModuleFromImport(VMCxt, ImageImpObj);
  WasmEdge_VMRegisterModuleFromImport(VMCxt, TFLiteImpObj);
  WasmEdge_VMRegisterModuleFromImport(VMCxt, TFDummyImpObj);

  /* Init WASI. */
  const char *Preopens[] = {&quot;.:.&quot;};
  const char *Args[] = {argv[1], argv[2], argv[3]};
  WasmEdge_ImportObjectContext *WASIImpObj = WasmEdge_VMGetImportModuleContext(VMCxt, WasmEdge_HostRegistration_Wasi);
  WasmEdge_ImportObjectInitWASI(WASIImpObj, Args, 3, NULL, 0, Preopens, 1);

  /* Run WASM file. */
  WasmEdge_String FuncName = WasmEdge_StringCreateByCString(&quot;_start&quot;);
  WasmEdge_Result Res = WasmEdge_VMRunWasmFromFile(VMCxt, argv[1], FuncName, NULL, 0, NULL, 0);
  WasmEdge_StringDelete(FuncName);

  /* Check the result. */
  if (!WasmEdge_ResultOK(Res)) {
    printf(&quot;Run WASM failed: %s\n&quot;, WasmEdge_ResultGetMessage(Res));
    return -1;
  }

  WasmEdge_ImportObjectDelete(ImageImpObj);
  WasmEdge_ImportObjectDelete(TFLiteImpObj);
  WasmEdge_ImportObjectDelete(TFDummyImpObj);
  WasmEdge_VMDelete(VMCxt);
  return 0;
}
</code></pre>
<h2 id="build-2"><a class="header" href="#build-2">Build</a></h2>
<h3 id="install-dependencies"><a class="header" href="#install-dependencies">Install dependencies</a></h3>
<p>Use the following commands to download WasmEdge for Android on your Ubuntu dev machine.</p>
<pre><code class="language-bash">wget https://github.com/WasmEdge/WasmEdge/releases/download/0.11.1/WasmEdge-0.11.1-android_aarch64.tar.gz
wget https://github.com/second-state/WasmEdge-image/releases/download/0.11.1/WasmEdge-image-0.11.1-android_aarch64.tar.gz
wget https://github.com/second-state/WasmEdge-tensorflow/releases/download/0.11.1/WasmEdge-tensorflowlite-0.11.1-android_aarch64.tar.gz
wget https://github.com/second-state/WasmEdge-tensorflow-deps/releases/download/0.11.1/WasmEdge-tensorflow-deps-TFLite-0.11.1-android_aarch64.tar.gz
tar -zxf WasmEdge-0.11.1-android_aarch64.tar.gz
tar -zxf WasmEdge-image-0.11.1-android_aarch64.tar.gz -C WasmEdge-0.11.1-Android/
tar -zxf WasmEdge-tensorflowlite-0.11.1-android_aarch64.tar.gz -C WasmEdge-0.11.1-Android/
tar -zxf WasmEdge-tensorflow-deps-TFLite-0.11.1-android_aarch64.tar.gz -C WasmEdge-0.11.1-Android/lib/
</code></pre>
<h3 id="compile"><a class="header" href="#compile">Compile</a></h3>
<p>The following command compiles the C program to <code>a.out</code> on your Ubunu dev machine.</p>
<pre><code class="language-bash">(/path/to/ndk)/toolchains/llvm/prebuilt/(HostPlatform)/bin/aarch64-linux-(AndroidApiVersion)-clang test.c -I./WasmEdge-0.11.1-Android/include -L./WasmEdge-0.11.1-Android/lib -lwasmedge-image_c -lwasmedge-tensorflowlite_c -ltensorflowlite_c -lwasmedge
</code></pre>
<h2 id="run-3"><a class="header" href="#run-3">Run</a></h2>
<h3 id="push-files-onto-android"><a class="header" href="#push-files-onto-android">Push files onto Android</a></h3>
<p>Install the compiled program, Tensorflow Lite model file, test image file, as well as WasmEdge shared library files for Android, onto the Android device using <code>adb</code> from your Ubuntu dev machine.</p>
<pre><code class="language-bash">adb push a.out /data/local/tmp
adb push birds_v1.wasm /data/local/tmp
adb push lite-model_aiy_vision_classifier_birds_V1_3.tflite /data/local/tmp
adb push bird.jpg /data/local/tmp
adb push ./WasmEdge-0.11.1-Android/lib /data/local/tmp
</code></pre>
<h3 id="run-the-example"><a class="header" href="#run-the-example">Run the example</a></h3>
<p>Now you can run the compiled C program on the Android device via a remote shell command. Run <code>adb shell</code> from your Ubuntu dev machine.</p>
<pre><code class="language-bash">$ adb shell
sirius:/ $ cd /data/local/tmp
sirius:/data/local/tmp $ export LD_LIBRARY_PATH=/data/local/tmp/lib:$LD_LIBRARY_PATH
sirius:/data/local/tmp $ ./a.out birds_v1.wasm lite-model_aiy_vision_classifier_birds_V1_3.tflite bird.jpg
INFO: Initialized TensorFlow Lite runtime.
166 : 0.84705883
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="call-wasmedge-functions-from-an-android-apk-app"><a class="header" href="#call-wasmedge-functions-from-an-android-apk-app">Call WasmEdge functions from an Android APK app</a></h1>
<p>In this section, we will show you how to build a &quot;regular&quot; Android app (i.e., an APK file that can be installed on an Android device). The APK app embeds a WasmEdge Runtime. It can call WebAssembly functions through the embedded WasmEdge. The benefit is that developers can safely embed high-performance functions written in several different languages (e.g., Rust, JS, Grain, TinyGo etc) into a Kotlin application.</p>
<h2 id="quickstart"><a class="header" href="#quickstart">Quickstart</a></h2>
<p>The demo project is <a href="https://github.com/WasmEdge/WasmEdge/tree/master/utils/android/app">available here</a>. You can build the project using the Gradle tool or using the Android Stuido IDE.</p>
<h3 id="building-project-with-gradle"><a class="header" href="#building-project-with-gradle">Building Project with Gradle</a></h3>
<ol>
<li>Setup environment variable <code>ANDROID_HOME=path/to/your/android/sdk</code></li>
<li>Run Command <code>./gradlew assembleRelease</code></li>
<li>Sign your APK file with <code>apksigner</code>. The apk file is at <code>./app/build/outputs/apk/release</code>. The <code>apksigner</code> utility is at <code>$ANDROID_HOME/build-tools/$VERSION/apksigner</code>.</li>
</ol>
<h3 id="building-project-with-android-studio"><a class="header" href="#building-project-with-android-studio">Building Project with Android Studio</a></h3>
<p>Open this folder with <a href="https://developer.android.com/studio">Android Studio</a> 2020.3.1 or later.</p>
<p>For Release APK, click <code>Menu -&gt; Build -&gt; Generate Signed Bundle/APK</code>, select APK, setup keystore configuration and wait for build finished.</p>
<h2 id="review-of-the-source-code"><a class="header" href="#review-of-the-source-code">Review of the source code</a></h2>
<p>The Android UI app is written in Kotlin, and it uses JNI (Java Native Interface) to load a C shared library, which in turn embeds WasmEdge.</p>
<h3 id="android-ui"><a class="header" href="#android-ui">Android UI</a></h3>
<p>The Android UI application is <a href="https://github.com/WasmEdge/WasmEdge/blob/master/utils/android/app/app/src/main/java/org/wasmedge/example_app/MainActivity.kt">located here</a>. It is written in Kotlin using the Android SDK.</p>
<pre><code class="language-java">class MainActivity : AppCompatActivity() {
  lateinit var lib: NativeLib

  override fun onCreate(savedInstanceState: Bundle?) {
    super.onCreate(savedInstanceState)
    setContentView(R.layout.activity_main)

    val tv = findViewById&lt;TextView&gt;(R.id.tv_text)

    lib = NativeLib(this)

    Thread {
      val lines = Vector&lt;String&gt;()
      val idxArr = arrayOf(20, 25, 28, 30, 32)
      for (idx: Int in idxArr) {
        lines.add(&quot;running fib(${idx}) ...&quot;)
        runOnUiThread {
          tv.text = lines.joinToString(&quot;\n&quot;)
        }
        val begin = System.currentTimeMillis()
        val retVal = lib.wasmFibonacci(idx)
        val end = System.currentTimeMillis()
        lines.removeLast()
        lines.add(&quot;fib(${idx}) -&gt; ${retVal}, ${end - begin}ms&quot;)
        runOnUiThread {
          tv.text = lines.joinToString(&quot;\n&quot;)
        }
      }
    }.start()
  }
}
</code></pre>
<h3 id="the-native-library"><a class="header" href="#the-native-library">The native library</a></h3>
<p>The Android UI app calls a <code>NativeLib</code> Kotlin object to access WasmEdge functions. The <code>NativeLib</code> source code is <a href="https://github.com/WasmEdge/WasmEdge/blob/master/utils/android/app/lib/src/main/java/org/wasmedge/native_lib/NativeLib.kt">available here</a>. It uses JNI (Java Native Interface) to load a C shared library called <code>wasmedge_lib</code>. It then calls the <code>nativeWasmFibonacci</code> function in <code>wasmedge_lib</code> to execute the <code>fibonacci.wasm</code> WebAssembly bytecode.</p>
<pre><code class="language-java">class NativeLib(ctx : Context) {
  private external fun nativeWasmFibonacci(imageBytes : ByteArray, idx : Int ) : Int

  companion object {
    init {
      System.loadLibrary(&quot;wasmedge_lib&quot;)
    }
  }

  private var fibonacciWasmImageBytes : ByteArray = ctx.assets.open(&quot;fibonacci.wasm&quot;).readBytes()

  fun wasmFibonacci(idx : Int) : Int{
    return nativeWasmFibonacci(fibonacciWasmImageBytes, idx)
  }
}
</code></pre>
<h3 id="the-c-shared-library"><a class="header" href="#the-c-shared-library">The C shared library</a></h3>
<p>The C shared library source code <code>wasmedge_lib.cpp</code> is <a href="https://github.com/WasmEdge/WasmEdge/blob/master/utils/android/app/lib/src/main/cpp/wasmedge_lib.cpp">available here</a>. It uses the WasmEdge C SDK to embed a WasmEdge VM and execute the WebAssembly function.</p>
<pre><code class="language-c">extern &quot;C&quot; JNIEXPORT jint JNICALL
Java_org_wasmedge_native_1lib_NativeLib_nativeWasmFibonacci(
    JNIEnv *env, jobject, jbyteArray image_bytes, jint idx) {
  jsize buffer_size = env-&gt;GetArrayLength(image_bytes);
  jbyte *buffer = env-&gt;GetByteArrayElements(image_bytes, nullptr);

  WasmEdge_ConfigureContext *conf = WasmEdge_ConfigureCreate();
  WasmEdge_ConfigureAddHostRegistration(conf, WasmEdge_HostRegistration_Wasi);

  WasmEdge_VMContext *vm_ctx = WasmEdge_VMCreate(conf, nullptr);

  const WasmEdge_String &amp;func_name = WasmEdge_StringCreateByCString(&quot;fib&quot;);
  std::array&lt;WasmEdge_Value, 1&gt; params{WasmEdge_ValueGenI32(idx)};
  std::array&lt;WasmEdge_Value, 1&gt; ret_val{};

  const WasmEdge_Result &amp;res = WasmEdge_VMRunWasmFromBuffer(
      vm_ctx, (uint8_t *)buffer, buffer_size, func_name, params.data(),
      params.size(), ret_val.data(), ret_val.size());

  WasmEdge_VMDelete(vm_ctx);
  WasmEdge_ConfigureDelete(conf);
  WasmEdge_StringDelete(func_name);

  env-&gt;ReleaseByteArrayElements(image_bytes, buffer, 0);
  if (!WasmEdge_ResultOK(res)) {
    return -1;
  }
  return WasmEdge_ValueGetI32(ret_val[0]);
}
</code></pre>
<h3 id="the-webassembly-function"><a class="header" href="#the-webassembly-function">The WebAssembly function</a></h3>
<p>The <code>factorial.wat</code> is a <a href="https://github.com/WasmEdge/WasmEdge/blob/master/examples/wasm/fibonacci.wat">handwritten WebAssembly script</a> to compute factorial numbers. It is compiled into WebAssembly using the <a href="https://github.com/WebAssembly/wabt">WABT tool</a>.</p>
<h3 id="build-dependencies"><a class="header" href="#build-dependencies">Build dependencies</a></h3>
<p>Android Studio and Gradle use CMake to build the C shared library. The <a href="https://github.com/WasmEdge/WasmEdge/blob/master/utils/android/app/lib/src/main/cpp/CMakeLists.txt">CMakeLists.txt file</a> builds the WasmEdge source into Android shared library files and embeds them into the final APK application. In this case, there is no seperate step to install WasmEdge share libraries onto the Android device.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="build-wasmedge-for-sel4"><a class="header" href="#build-wasmedge-for-sel4">Build WasmEdge for seL4</a></h1>
<p><a href="https://youtu.be/2Qu-Trtkspk">Video demo</a> | <a href="https://github.com/second-state/wasmedge-seL4/runs/3982081148?check_suite_focus=true">Build logs</a> | <a href="https://github.com/second-state/wasmedge-seL4/actions/runs/1374510169">Build artifact</a></p>
<p>In this article, we demonstrate how to run WasmEdge on the seL4 RTOS, there are two parts:</p>
<ol>
<li>Guest Linux OS on seL4: This is the controller of WasmEdge runtime, which will send wasm program to WasmEdge runner that is a agent on seL4 to execute.</li>
<li>WasmEdge runner on seL4: This is the wasm program runtime, which will execute the given wasm program from Guest Linux OS.</li>
</ol>
<p>The figure below illustrates the architecture of the system.</p>
<p><img src="contribute/build_from_src/wasmedge-sel4.png" alt="wasmedge-sel4" /></p>
<p>This demo is based on the seL4 simulator on Linux.</p>
<h2 id="getting-started-4"><a class="header" href="#getting-started-4">Getting Started</a></h2>
<h3 id="system-requirements"><a class="header" href="#system-requirements">System requirements</a></h3>
<p>Hardware:</p>
<ul>
<li>at least 4GB of RAM</li>
<li>at least 20GB of disk storage (the wasmedge_sel4 directory will contain over 11 GB of data after the following installation completes)</li>
</ul>
<p>Software: Ubuntu 20.04 with dev tools packages (ep. Python) installed. We recommend the <a href="https://github.com/actions/virtual-environments/blob/main/images/linux/Ubuntu2004-README.md">GitHub Actions Ubuntu 20.04 VM</a> (See a list of <a href="https://github.com/actions/virtual-environments/blob/main/images/linux/Ubuntu2004-README.md#installed-apt-packages">installed apt packages</a>). Or, you could use our Docker image (see the <a href="https://github.com/second-state/wasmedge-seL4/blob/main/docs/Dockerfile.sel4_build">Dockerfile</a>).</p>
<pre><code class="language-bash">$ docker pull wasmedge/sel4_build
$ docker run --rm -v $(pwd):/app -it wasmedge/sel4_build
(docker) root#
</code></pre>
<blockquote>
<p>If you do not want to build the seL4 system simulator yourself, you can download the <a href="https://github.com/second-state/wasmedge-seL4/actions/runs/1374510169">build artifact</a> from our GitHub Actions, and skip directly to <a href="contribute/build_from_src/sel4.html#boot-wasmedge-sel4">Boot wasmedge-seL4</a></p>
</blockquote>
<h3 id="automatic-installation-all-in-one-script"><a class="header" href="#automatic-installation-all-in-one-script">Automatic installation: all-in-one script</a></h3>
<p>Use our all-in-one build script:</p>
<pre><code class="language-bash">wget -qO- https://raw.githubusercontent.com/second-state/wasmedge-seL4/main/build.sh | bash
</code></pre>
<p>And this will clone and build our wasmedge on seL4 to an image.</p>
<p>After finishing the build script, you will have a folder <code>sel4_wasmedge</code>.</p>
<p>If this automatic installation completed successfully, skip over the manual installation information and proceed to <a href="https://github.com/second-state/wasmedge-seL4#boot-wasmedge-sel4">boot wasmedge-sel4</a></p>
<h3 id="manual-installation-managing-memory-usage"><a class="header" href="#manual-installation-managing-memory-usage">Manual installation: managing memory usage</a></h3>
<p>The above all-in-one script will work in most cases. However, if your system resources were stressed and you encountered an error such as <code>ninja: build stopped: subcommand failed</code> please note that you can decrease the parallelization of the install by explicitly passing in a <code>-j</code> parameter to the <code>ninja</code> command (on the last line of the <code>build.sh</code> file). You see, Ninja runs the most amount of parallel processes by default and so the following procedure is a way to explicitly set/reduce parallelization.</p>
<p>Manually fetch the `wasmedge-sel4 repository.</p>
<pre><code class="language-bash">cd ~
git clone https://github.com/second-state/wasmedge-seL4.git
cd wasmedge-seL4
</code></pre>
<p>Manually edit the <code>build.sh</code> file.</p>
<pre><code class="language-bash">vi build.sh
</code></pre>
<p>Add the following <code>-j</code> parameter to the last line of the file i.e.</p>
<pre><code class="language-bash">ninja -j 2
</code></pre>
<p>Make the <code>build.sh</code> file executable.</p>
<pre><code class="language-bash">sudo chmod a+x build.sh
</code></pre>
<p>Run the edited `build.sh file.</p>
<pre><code class="language-bash">./build.sh
</code></pre>
<p>Once this manual installation is complete, follow along with the following steps; boot wasmedge-sel4</p>
<h3 id="boot-wasmedge-sel4"><a class="header" href="#boot-wasmedge-sel4">Boot wasmedge-seL4</a></h3>
<pre><code class="language-bash">cd sel4_wasmedge/build
./simulate
</code></pre>
<p>Expected output:</p>
<pre><code class="language-bash">$ ./simulate: qemu-system-aarch64 -machine virt,virtualization=on,highmem=off,secure=off -cpu cortex-a53 -nographic  -m size=2048  -kernel images/capdl-loader-image-arm-qemu-arm-virt
ELF-loader started on CPU: ARM Ltd. Cortex-A53 r0p4
  paddr=[6abd8000..750cf0af]
No DTB passed in from boot loader.
Looking for DTB in CPIO archive...found at 6ad18f58.
Loaded DTB from 6ad18f58.
   paddr=[60243000..60244fff]
ELF-loading image 'kernel' to 60000000
  paddr=[60000000..60242fff]
  vaddr=[ff8060000000..ff8060242fff]
  virt_entry=ff8060000000
ELF-loading image 'capdl-loader' to 60245000
  paddr=[60245000..6a7ddfff]
  vaddr=[400000..a998fff]
  virt_entry=408f38
Enabling hypervisor MMU and paging
Jumping to kernel-image entry point...

Bootstrapping kernel
Warning: Could not infer GIC interrupt target ID, assuming 0.
Booting all finished, dropped to user space
&lt;&lt;seL4(CPU 0) [decodeUntypedInvocation/205 T0xff80bf85d400 &quot;rootserver&quot; @4006f8]: Untyped Retype: Insufficient memory (1 * 2097152 bytes needed, 0 bytes available).&gt;&gt;
Loading Linux: 'linux' dtb: 'linux-dtb'

...(omitted)...

Starting syslogd: OK
Starting klogd: OK
Running sysctl: OK
Initializing random number generator... [    3.512482] random: dd: uninitialized urandom read (512 bytes read)
done.
Starting network: OK
[    4.086059] connection: loading out-of-tree module taints kernel.
[    4.114686] Event Bar (dev-0) initalised
[    4.123771] 2 Dataports (dev-0) initalised
[    4.130626] Event Bar (dev-1) initalised
[    4.136096] 2 Dataports (dev-1) initalised

Welcome to Buildroot
buildroot login:
</code></pre>
<h3 id="login-on-guest-linux"><a class="header" href="#login-on-guest-linux">Login on guest linux</a></h3>
<p>Enter <code>root</code> to login</p>
<pre><code class="language-bash">buildroot login: root
</code></pre>
<p>Expected output:</p>
<pre><code class="language-bash">buildroot login: root
#
</code></pre>
<h3 id="execute-wasm-examples"><a class="header" href="#execute-wasm-examples">Execute wasm examples</a></h3>
<h4 id="example-a-nbody-cwasm"><a class="header" href="#example-a-nbody-cwasm">Example A: nbody-c.wasm</a></h4>
<p>Run nbody simulation.</p>
<pre><code class="language-bash">wasmedge_emit /usr/bin/nbody-c.wasm 10
</code></pre>
<p>Expected output:</p>
<pre><code class="language-bash">[1900-01-00 00:00:00.000] [info] executing wasm file
-0.169075164
-0.169073022
[1900-01-00 00:00:00.000] [info] execution success, exit code:0
</code></pre>
<h4 id="example-b-hellowasm"><a class="header" href="#example-b-hellowasm">Example B: hello.wasm</a></h4>
<p>Run an easy application to print <code>hello, sel4</code> and a simple calculation.</p>
<pre><code class="language-bash">wasmedge_emit /usr/bin/hello.wasm
</code></pre>
<p>Expected output:</p>
<pre><code class="language-bash">[1900-01-00 00:00:00.000] [info] executing wasm file
hello, sel4
1+2-3*4 = -9
[1900-01-00 00:00:00.000] [info] execution success, exit code:0
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="build-wasmedge-for-open-harmony"><a class="header" href="#build-wasmedge-for-open-harmony">Build WasmEdge for Open Harmony</a></h1>
<p>WIP. For Chinese speakers, please <a href="https://github.com/WasmEdge/WasmEdge/blob/master/utils/ohos/README-zh.md">check out this instruction</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="build-wasmedge-for-raspberry-pi-34"><a class="header" href="#build-wasmedge-for-raspberry-pi-34">Build WasmEdge for Raspberry Pi 3/4</a></h1>
<p>Raspberry Pi uses 64-bit processors starting from the 3 Model B. So WasmEdge can be executed on Raspberry Pi as well. You can choose any 64-bit Linux distribution, such as Raspbian, Ubuntu or Manjaro for ARM. This document has been tested on the Manjaro for ARM distribution and the hardware is the Raspberry Pi 3 Model B.</p>
<p>The installation steps are no different from the <a href="contribute/build_from_src/../../quick_start/install.html">installation document</a>, and the execution is the same. Here's a video about installing WasmEdge and running a simple WebAssembly module to add two numbers up.</p>
<p><a href="https://asciinema.org/a/458453"><img src="https://asciinema.org/a/458453.svg" alt="asciicast" /></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="build-wasmedge-with-wasi-nn-plug-in"><a class="header" href="#build-wasmedge-with-wasi-nn-plug-in">Build WasmEdge With WASI-NN Plug-in</a></h1>
<h2 id="prerequisites-9"><a class="header" href="#prerequisites-9">Prerequisites</a></h2>
<p>Currently, WasmEdge used OpenVINO™ or PyTorch as the WASI-NN backend implementation. For using WASI-NN on WasmEdge, you need to install <a href="https://docs.openvino.ai/2021.4/openvino_docs_install_guides_installing_openvino_linux.html#">OpenVINO™</a>(2021) or <a href="https://pytorch.org/get-started/locally/">PyTorch 1.8.2 LTS</a> for the backend.</p>
<p>By default, we don't enable any WASI-NN backend in WasmEdge. Therefore developers should <a href="contribute/build_from_src/linux.html">build the WasmEdge from source</a> with the cmake option <code>WASMEDGE_PLUGIN_WASI_NN_BACKEND</code> to enable the backends.</p>
<h2 id="build-wasmedge-with-wasi-nn-openvino-backend"><a class="header" href="#build-wasmedge-with-wasi-nn-openvino-backend">Build WasmEdge with WASI-NN OpenVINO Backend</a></h2>
<p>For choosing and installing OpenVINO™ on <code>Ubuntu 20.04</code> for the backend, we recommend the following commands:</p>
<pre><code class="language-bash">export OPENVINO_VERSION=&quot;2021.4.582&quot;
export OPENVINO_YEAR=&quot;2021&quot;
curl -sSL https://apt.repos.intel.com/openvino/$OPENVINO_YEAR/GPG-PUB-KEY-INTEL-OPENVINO-$OPENVINO_YEAR | sudo gpg --dearmor &gt; /usr/share/keyrings/GPG-PUB-KEY-INTEL-OPENVINO-$OPENVINO_YEAR.gpg
echo &quot;deb [signed-by=/usr/share/keyrings/GPG-PUB-KEY-INTEL-OPENVINO-$OPENVINO_YEAR.gpg] https://apt.repos.intel.com/openvino/$OPENVINO_YEAR all main&quot; | sudo tee /etc/apt/sources.list.d/intel-openvino-$OPENVINO_YEAR.list
sudo apt update
sudo apt install -y intel-openvino-runtime-ubuntu20-$OPENVINO_VERSION
source /opt/intel/openvino_2021/bin/setupvars.sh
ldconfig
</code></pre>
<p>Then build and install WasmEdge from source:</p>
<pre><code class="language-bash">cd &lt;path/to/your/wasmedge/source/folder&gt;
mkdir -p build &amp;&amp; cd build
cmake -DCMAKE_BUILD_TYPE=Release -DWASMEDGE_PLUGIN_WASI_NN_BACKEND=&quot;OpenVINO&quot; .. &amp;&amp; make -j
# For the WASI-NN plugin, you should install this project.
cmake --install .
</code></pre>
<blockquote>
<p>If the built <code>wasmedge</code> CLI tool cannot find the WASI-NN plug-in, you can set the <code>WASMEDGE_PLUGIN_PATH</code> environment variable to the plug-in installation path (<code>/usr/local/lib/wasmedge/</code>, or the built plug-in path <code>build/plugins/wasi_nn/</code>) to try to fix this issue.</p>
</blockquote>
<p>Then you will have an executable <code>wasmedge</code> runtime under <code>/usr/local/bin</code> and the WASI-NN with OpenVINO backend plug-in under <code>/usr/local/lib/wasmedge/libwasmedgePluginWasiNN.so</code> after installation.</p>
<h2 id="build-wasmedge-with-wasi-nn-pytorch-backend"><a class="header" href="#build-wasmedge-with-wasi-nn-pytorch-backend">Build WasmEdge with WASI-NN PyTorch Backend</a></h2>
<p>For choosing and installing PyTorch on <code>Ubuntu 20.04</code> for the backend, we recommend the following commands:</p>
<pre><code class="language-bash">export PYTORCH_VERSION=&quot;1.8.2&quot;
curl -s -L -O --remote-name-all https://download.pytorch.org/libtorch/lts/1.8/cpu/libtorch-cxx11-abi-shared-with-deps-${PYTORCH_VERSION}%2Bcpu.zip
unzip -q &quot;libtorch-cxx11-abi-shared-with-deps-${PYTORCH_VERSION}%2Bcpu.zip&quot;
rm -f &quot;libtorch-cxx11-abi-shared-with-deps-${PYTORCH_VERSION}%2Bcpu.zip&quot;
</code></pre>
<p>For the legacy operating system such as <code>CentOS 7.6</code>, please use the <code>pre-cxx11-abi</code> version of <code>libtorch</code> instead:</p>
<pre><code class="language-bash">export PYTORCH_VERSION=&quot;1.8.2&quot;
curl -s -L -O --remote-name-all https://download.pytorch.org/libtorch/lts/1.8/cpu/libtorch-shared-with-deps-${PYTORCH_VERSION}%2Bcpu.zip
unzip -q &quot;libtorch-shared-with-deps-${PYTORCH_VERSION}%2Bcpu.zip&quot;
rm -f &quot;libtorch-shared-with-deps-${PYTORCH_VERSION}%2Bcpu.zip&quot;
export LD_LIBRARY_PATH=$(pwd)/libtorch/lib:${LD_LIBRARY_PATH}
export Torch_DIR=$(pwd)/libtorch
</code></pre>
<p>The PyTorch library will be extracted in the current directory <code>./libtorch</code>.</p>
<p>Then build and install WasmEdge from source:</p>
<pre><code class="language-bash">cd &lt;path/to/your/wasmedge/source/folder&gt;
mkdir -p build &amp;&amp; cd build
cmake -DCMAKE_BUILD_TYPE=Release -DWASMEDGE_PLUGIN_WASI_NN_BACKEND=&quot;PyTorch&quot; .. &amp;&amp; make -j
# For the WASI-NN plugin, you should install this project.
cmake --install .
</code></pre>
<blockquote>
<p>If the built <code>wasmedge</code> CLI tool cannot find the WASI-NN plug-in, you can set the <code>WASMEDGE_PLUGIN_PATH</code> environment variable to the plug-in installation path (<code>/usr/local/lib/wasmedge/</code>, or the built plug-in path <code>build/plugins/wasi_nn/</code>) to try to fix this issue.</p>
</blockquote>
<p>Then you will have an executable <code>wasmedge</code> runtime under <code>/usr/local/bin</code> and the WASI-NN with OpenVINO backend plug-in under <code>/usr/local/lib/wasmedge/libwasmedgePluginWasiNN.so</code> after installation.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="build-wasmedge-with-wasi-crypto-plug-in"><a class="header" href="#build-wasmedge-with-wasi-crypto-plug-in">Build WasmEdge With WASI-Crypto Plug-in</a></h1>
<h2 id="prerequisites-10"><a class="header" href="#prerequisites-10">Prerequisites</a></h2>
<p>Currently, WasmEdge used <code>OpenSSL 1.1</code> or <code>3.0</code> for the WASI-Crypto implementation.</p>
<p>For installing <code>OpenSSL 1.1</code> development package on <code>Ubuntu 20.04</code>, we recommend the following commands:</p>
<pre><code class="language-bash">sudo apt update
sudo apt install -y libssl-dev
</code></pre>
<p>For legacy systems such as <code>CensOS 7.6</code>, or if you want to build <code>OpenSSL 1.1</code> from source, you can refer to the following commands:</p>
<pre><code class="language-bash"># Download and extract the OpenSSL source to the current directory.
curl -s -L -O --remote-name-all https://www.openssl.org/source/openssl-1.1.1n.tar.gz
echo &quot;40dceb51a4f6a5275bde0e6bf20ef4b91bfc32ed57c0552e2e8e15463372b17a openssl-1.1.1n.tar.gz&quot; | sha256sum -c
tar -xf openssl-1.1.1n.tar.gz
cd ./openssl-1.1.1n
# OpenSSL configure need newer perl.
curl -s -L -O --remote-name-all https://www.cpan.org/src/5.0/perl-5.34.0.tar.gz
tar -xf perl-5.34.0.tar.gz
cd perl-5.34.0
mkdir localperl
./Configure -des -Dprefix=$(pwd)/localperl/
make -j
make install
export PATH=&quot;$(pwd)/localperl/bin/:$PATH&quot;
cd ..
# Configure by previous perl.
mkdir openssl
./perl-5.34.0/localperl/bin/perl ./config --prefix=$(pwd)/openssl --openssldir=$(pwd)/openssl
make -j
make test
make install
cd ..
# The OpenSSL installation directory is at `$(pwd)/openssl-1.1.1n/openssl`.
# Then you can use the `-DOPENSSL_ROOT_DIR=` option of cmake to assign the directory.
</code></pre>
<blockquote>
<p>We'll soon update this chapter to use <code>OpenSSL 3.0</code>.</p>
</blockquote>
<h2 id="build-wasmedge-with-wasi-crypto-plug-in-1"><a class="header" href="#build-wasmedge-with-wasi-crypto-plug-in-1">Build WasmEdge with WASI-Crypto Plug-in</a></h2>
<p>To enable the WasmEdge WASI-Crypto, developers need to <a href="contribute/build_from_src/linux.html">building the WasmEdge from source</a> with the cmake option <code>-DWASMEDGE_PLUGIN_WASI_CRYPTO=ON</code>.</p>
<pre><code class="language-bash">cd &lt;path/to/your/wasmedge/source/folder&gt;
mkdir -p build &amp;&amp; cd build
# For using self-get OpenSSL, you can assign the cmake option `-DOPENSSL_ROOT_DIR=&lt;path/to/openssl&gt;`.
cmake -DCMAKE_BUILD_TYPE=Release -DWASMEDGE_PLUGIN_WASI_CRYPTO=On .. &amp;&amp; make -j
# For the WASI-Crypto plugin, you should install this project.
cmake --install .
</code></pre>
<blockquote>
<p>If the built <code>wasmedge</code> CLI tool cannot find the WASI-Crypto plug-in, you can set the <code>WASMEDGE_PLUGIN_PATH</code> environment variable to the plug-in installation path (<code>/usr/local/lib/wasmedge/</code>, or the built plug-in path <code>build/plugins/wasi_crypto/</code>) to try to fix this issue.</p>
</blockquote>
<p>Then you will have an executable <code>wasmedge</code> runtime under <code>/usr/local/bin</code> and the WASI-Crypto plug-in under <code>/usr/local/lib/wasmedge/libwasmedgePluginWasiCrypto.so</code> after installation.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="build-wasmedge-with-wasmedge-httpsreq-plug-in"><a class="header" href="#build-wasmedge-with-wasmedge-httpsreq-plug-in">Build WasmEdge With WasmEdge-HttpsReq Plug-in</a></h1>
<h2 id="prerequisites-11"><a class="header" href="#prerequisites-11">Prerequisites</a></h2>
<p>Currently, WasmEdge used <code>OpenSSL 1.1</code> or <code>3.0</code> for the the dependency of WasmEdge-HttpsReq.</p>
<p>For installing <code>OpenSSL 1.1</code> development package on <code>Ubuntu 20.04</code>, we recommend the following commands:</p>
<pre><code class="language-bash">sudo apt update
sudo apt install -y libssl-dev
</code></pre>
<p>For legacy systems such as <code>CensOS 7.6</code>, or if you want to build <code>OpenSSL 1.1</code> from source, you can refer to the following commands:</p>
<pre><code class="language-bash"># Download and extract the OpenSSL source to the current directory.
curl -s -L -O --remote-name-all https://www.openssl.org/source/openssl-1.1.1n.tar.gz
echo &quot;40dceb51a4f6a5275bde0e6bf20ef4b91bfc32ed57c0552e2e8e15463372b17a openssl-1.1.1n.tar.gz&quot; | sha256sum -c
tar -xf openssl-1.1.1n.tar.gz
cd ./openssl-1.1.1n
# OpenSSL configure need newer perl.
curl -s -L -O --remote-name-all https://www.cpan.org/src/5.0/perl-5.34.0.tar.gz
tar -xf perl-5.34.0.tar.gz
cd perl-5.34.0
mkdir localperl
./Configure -des -Dprefix=$(pwd)/localperl/
make -j
make install
export PATH=&quot;$(pwd)/localperl/bin/:$PATH&quot;
cd ..
# Configure by previous perl.
mkdir openssl
./perl-5.34.0/localperl/bin/perl ./config --prefix=$(pwd)/openssl --openssldir=$(pwd)/openssl
make -j
make test
make install
cd ..
# The OpenSSL installation directory is at `$(pwd)/openssl-1.1.1n/openssl`.
# Then you can use the `-DOPENSSL_ROOT_DIR=` option of cmake to assign the directory.
</code></pre>
<blockquote>
<p>We'll soon update this chapter to use <code>OpenSSL 3.0</code>.</p>
</blockquote>
<h2 id="build-wasmedge-with-wasmedge-httpsreq-plug-in-1"><a class="header" href="#build-wasmedge-with-wasmedge-httpsreq-plug-in-1">Build WasmEdge with WasmEdge-HttpsReq Plug-in</a></h2>
<p>To enable the WasmEdge WasmEdge-HttpsReq, developers need to <a href="contribute/build_from_src/linux.html">building the WasmEdge from source</a> with the cmake option <code>-DWASMEDGE_PLUGIN_HTTPSREQ=On</code>.</p>
<pre><code class="language-bash">cd &lt;path/to/your/wasmedge/source/folder&gt;
mkdir -p build &amp;&amp; cd build
# For using self-get OpenSSL, you can assign the cmake option `-DOPENSSL_ROOT_DIR=&lt;path/to/openssl&gt;`.
cmake -DCMAKE_BUILD_TYPE=Release -DWASMEDGE_PLUGIN_HTTPSREQ=On .. &amp;&amp; make -j
# For the WasmEdge-HttpsReq plugin, you should install this project.
cmake --install .
</code></pre>
<blockquote>
<p>If the built <code>wasmedge</code> CLI tool cannot find the WasmEdge-HttpsReq plug-in, you can set the <code>WASMEDGE_PLUGIN_PATH</code> environment variable to the plug-in installation path (<code>/usr/local/lib/wasmedge/</code>, or the built plug-in path <code>build/plugins/wasmedge_httpsreq/</code>) to try to fix this issue.</p>
</blockquote>
<p>Then you will have an executable <code>wasmedge</code> runtime under <code>/usr/local/bin</code> and the WasmEdge-HttpsReq plug-in under <code>/usr/local/lib/wasmedge/libwasmedgePluginHttpsReq.so</code> after installation.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="wasmedge-internal"><a class="header" href="#wasmedge-internal">WasmEdge Internal</a></h1>
<p>Work in progress.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="wasmedge-release-process-1"><a class="header" href="#wasmedge-release-process-1">WasmEdge Release Process</a></h1>
<h2 id="create-the-releasing-process-issue-of-the-new-version-1"><a class="header" href="#create-the-releasing-process-issue-of-the-new-version-1">Create the releasing process issue of the new version</a></h2>
<ul>
<li><input disabled="" type="checkbox"/>
Keep adding the new features, issues, documents, and builds check list into the issue.</li>
<li><input disabled="" type="checkbox"/>
Add the GitHub project of the new version.</li>
</ul>
<h2 id="write-changelog-1"><a class="header" href="#write-changelog-1">Write Changelog</a></h2>
<ul>
<li><input disabled="" type="checkbox"/>
Make sure every change is written in the changelog.</li>
<li><input disabled="" type="checkbox"/>
Make sure the <code>Changelog.md</code> has the correct version number and the release date.</li>
<li><input disabled="" type="checkbox"/>
Copy the changelog of this version to <code>.CurrentChangelog.md</code>. (Our release CI will take this file as the release notes.)</li>
<li><input disabled="" type="checkbox"/>
Record the contributor lists.</li>
<li><input disabled="" type="checkbox"/>
Create a pull request, make sure the CI are all passed, and merge it.</li>
</ul>
<h2 id="create-the-alpha-pre-release-1"><a class="header" href="#create-the-alpha-pre-release-1">Create the Alpha Pre-Release</a></h2>
<ul>
<li><input disabled="" type="checkbox"/>
In this step, the main features are completed. No more major feature will be merged after the first Alpha pre-release.</li>
<li><input disabled="" type="checkbox"/>
Make sure that the features in the releasing process issue are completed.</li>
<li><input disabled="" type="checkbox"/>
Use git tag to create a new release tag <code>major.minor.patch-alpha.version</code>. And push this tag to GitHub.</li>
<li><input disabled="" type="checkbox"/>
Wait for the CI builds and pushes the release binaries and release notes to the GitHub release page.</li>
<li><input disabled="" type="checkbox"/>
Check the <code>Pre-release</code> checkbox and publish the pre-release.</li>
<li><input disabled="" type="checkbox"/>
This step will automatically close and turn into Beta or RC phase in about 3 days if there's no critical issues.</li>
</ul>
<h2 id="create-the-beta-pre-release-1"><a class="header" href="#create-the-beta-pre-release-1">Create the Beta Pre-Release</a></h2>
<ul>
<li><input disabled="" type="checkbox"/>
This step is for the issue fixing if needed. No more feature will be accepted.</li>
<li><input disabled="" type="checkbox"/>
Make sure that all the features in the releasing process issue are completed.</li>
<li><input disabled="" type="checkbox"/>
Use git tag to create a new release tag <code>major.minor.patch-beta.version</code>. And push this tag to GitHub.</li>
<li><input disabled="" type="checkbox"/>
Wait for the CI builds and pushes the release binaries and release notes to the GitHub release page.</li>
<li><input disabled="" type="checkbox"/>
Check the <code>Pre-release</code> checkbox and publish the pre-release.</li>
<li><input disabled="" type="checkbox"/>
This step will automatically close and turn into RC phase in about 3 days if there's no critical issues.</li>
</ul>
<h2 id="create-the-rc-pre-release-1"><a class="header" href="#create-the-rc-pre-release-1">Create the RC Pre-Release</a></h2>
<ul>
<li><input disabled="" type="checkbox"/>
In this step, the issue fixing is finished. The <code>RC</code> pre-releases are for the installation, bindings, and packages testing.</li>
<li><input disabled="" type="checkbox"/>
Make sure that all the issues in the releasing process issue are completed.</li>
<li><input disabled="" type="checkbox"/>
Update <code>WASMEDGE_CAPI_VERSION</code> in <code>CMakeLists.txt</code>.</li>
<li><input disabled="" type="checkbox"/>
Update <code>wasmedge_version</code> in <code>docs/book/en/book.toml</code>.</li>
<li><input disabled="" type="checkbox"/>
Use git tag to create a new release tag <code>major.minor.patch-rc.version</code>. And push this tag to GitHub.</li>
<li><input disabled="" type="checkbox"/>
Wait for the CI builds and pushes the release binaries and release notes to the GitHub release page.</li>
<li><input disabled="" type="checkbox"/>
Check the <code>Pre-release</code> checkbox and publish the pre-release.</li>
<li><input disabled="" type="checkbox"/>
This step will automatically close and announce the official release in about 3 days if there's no critical issues.</li>
</ul>
<h2 id="create-the-official-release-1"><a class="header" href="#create-the-official-release-1">Create the Official Release</a></h2>
<ul>
<li><input disabled="" type="checkbox"/>
Make sure the <code>Changelog.md</code> and <code>.CurrentChangelog.md</code> have the correct version number and the release date.</li>
<li><input disabled="" type="checkbox"/>
Use git tag to create a new release tag <code>major.minor.patch</code>. And push this tag to GitHub.</li>
<li><input disabled="" type="checkbox"/>
Wait for the CI builds and push the release binaries and release notes to the GitHub release page.</li>
<li><input disabled="" type="checkbox"/>
Publish the release.</li>
<li><input disabled="" type="checkbox"/>
Close the releasing process issue and the GitHub project.</li>
</ul>
<h2 id="update-the-extensions-1"><a class="header" href="#update-the-extensions-1">Update the Extensions</a></h2>
<p>The following projects will be updated with the <code>Alpha</code>, <code>Beta</code>, and <code>RC</code> pre-releases and the official release:</p>
<ul>
<li><input disabled="" type="checkbox"/>
<a href="https://github.com/second-state/WasmEdge-image">WasmEdge-Image</a></li>
<li><input disabled="" type="checkbox"/>
<a href="https://github.com/second-state/WasmEdge-tensorflow-deps">WasmEdge-TensorFlow-Deps</a></li>
<li><input disabled="" type="checkbox"/>
<a href="https://github.com/second-state/WasmEdge-tensorflow">WasmEdge-TensorFlow</a></li>
<li><input disabled="" type="checkbox"/>
<a href="https://github.com/second-state/WasmEdge-tensorflow-tools">WasmEdge-TensorFlow-Tools</a></li>
<li><input disabled="" type="checkbox"/>
<a href="https://github.com/second-state/WasmEdge-go">WasmEdge-Go SDK</a></li>
<li><input disabled="" type="checkbox"/>
<a href="https://github.com/second-state/wasmedge-core">WasmEdge-core NAPI package</a></li>
<li><input disabled="" type="checkbox"/>
<a href="https://github.com/second-state/wasmedge-extensions">WasmEdge-extensions NAPI package</a></li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
    </body>
</html>
