<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>WasmEdge Runtime</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        <!-- Global site tag (gtag.js) - Google Analytics -->
        <script async src="https://www.googletagmanager.com/gtag/js?id=G-NGPCK7VF2L"></script>
        <script>
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
        
          gtag('config', 'G-NGPCK7VF2L');
        </script>

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item "><a href="index.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item "><a href="quick_start.html"><strong aria-hidden="true">2.</strong> Quick Start</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="quick_start/install.html"><strong aria-hidden="true">2.1.</strong> Installation And Uninstallation</a></li><li class="chapter-item "><a href="quick_start/use_docker.html"><strong aria-hidden="true">2.2.</strong> Using WasmEdge in Docker</a></li><li class="chapter-item "><a href="quick_start/run_cli.html"><strong aria-hidden="true">2.3.</strong> Running WASM with WasmEdge CLI</a></li><li class="chapter-item "><a href="quick_start/run_in_aot_mode.html"><strong aria-hidden="true">2.4.</strong> Execution in AOT Mode</a></li></ol></li><li class="chapter-item "><a href="features.html"><strong aria-hidden="true">3.</strong> WasmEdge Features</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="features/proposals.html"><strong aria-hidden="true">3.1.</strong> Supported WASM And WASI Proposals</a></li><li class="chapter-item "><a href="features/proprietary_extend.html"><strong aria-hidden="true">3.2.</strong> WasmEdge Proprietary extensions</a></li><li class="chapter-item "><a href="features/integrations.html"><strong aria-hidden="true">3.3.</strong> Integrations</a></li><li class="chapter-item "><a href="features/platforms.html"><strong aria-hidden="true">3.4.</strong> Supported Platforms</a></li><li class="chapter-item "><a href="features/comparison.html"><strong aria-hidden="true">3.5.</strong> Comparison</a></li></ol></li><li class="chapter-item "><a href="use_cases.html"><strong aria-hidden="true">4.</strong> WasmEdge Use Cases</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="use_cases/server_side_render.html"><strong aria-hidden="true">4.1.</strong> Server-Side Rendering Modern Web UI</a></li><li class="chapter-item "><a href="use_cases/microservice.html"><strong aria-hidden="true">4.2.</strong> Microservices</a></li><li class="chapter-item "><a href="use_cases/serverless_faas.html"><strong aria-hidden="true">4.3.</strong> Serverless Function-As-A-Service in Public Clouds</a></li><li class="chapter-item "><a href="use_cases/serverless_saas.html"><strong aria-hidden="true">4.4.</strong> Serverless Software-As-A-Service Functions</a></li><li class="chapter-item "><a href="use_cases/smart_device.html"><strong aria-hidden="true">4.5.</strong> Smart devices</a></li><li class="chapter-item "><a href="use_cases/js_or_dsl_runtime.html"><strong aria-hidden="true">4.6.</strong> JavaScript or Domain Specific Language Runtime</a></li><li class="chapter-item "><a href="use_cases/kubernetes.html"><strong aria-hidden="true">4.7.</strong> WasmEdge in Kubernetes</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="use_cases/kubernetes/quickstart.html"><strong aria-hidden="true">4.7.1.</strong> Quick start</a></li><li class="chapter-item "><a href="use_cases/kubernetes/demo.html"><strong aria-hidden="true">4.7.2.</strong> Demo apps</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="use_cases/kubernetes/demo/wasi.html"><strong aria-hidden="true">4.7.2.1.</strong> Simple example</a></li><li class="chapter-item "><a href="use_cases/kubernetes/demo/server.html"><strong aria-hidden="true">4.7.2.2.</strong> HTTP service</a></li></ol></li><li class="chapter-item "><a href="use_cases/kubernetes/container.html"><strong aria-hidden="true">4.7.3.</strong> Container runtimes</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="use_cases/kubernetes/container/crun.html"><strong aria-hidden="true">4.7.3.1.</strong> crun</a></li><li class="chapter-item "><a href="use_cases/kubernetes/container/runc.html"><strong aria-hidden="true">4.7.3.2.</strong> runc</a></li><li class="chapter-item "><a href="use_cases/kubernetes/container/youki.html"><strong aria-hidden="true">4.7.3.3.</strong> youki</a></li></ol></li><li class="chapter-item "><a href="use_cases/kubernetes/cri.html"><strong aria-hidden="true">4.7.4.</strong> CRI runtimes</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="use_cases/kubernetes/cri/crio.html"><strong aria-hidden="true">4.7.4.1.</strong> CRI-O</a></li><li class="chapter-item "><a href="use_cases/kubernetes/cri/containerd.html"><strong aria-hidden="true">4.7.4.2.</strong> containerd</a></li></ol></li><li class="chapter-item "><a href="use_cases/kubernetes/kubernetes.html"><strong aria-hidden="true">4.7.5.</strong> Kubernetes</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="use_cases/kubernetes/kubernetes/kubernetes-crio.html"><strong aria-hidden="true">4.7.5.1.</strong> Kubernetes + CRI-O</a></li><li class="chapter-item "><a href="use_cases/kubernetes/kubernetes/kubernetes-containerd.html"><strong aria-hidden="true">4.7.5.2.</strong> Kubernetes + containerd</a></li><li class="chapter-item "><a href="use_cases/kubernetes/kubernetes/kind.html"><strong aria-hidden="true">4.7.5.3.</strong> KinD</a></li><li class="chapter-item "><a href="use_cases/kubernetes/kubernetes/kubeedge.html"><strong aria-hidden="true">4.7.5.4.</strong> KubeEdge</a></li><li class="chapter-item "><a href="use_cases/kubernetes/kubernetes/superedge.html"><strong aria-hidden="true">4.7.5.5.</strong> SuperEdge</a></li><li class="chapter-item "><a href="use_cases/kubernetes/kubernetes/openyurt.html"><strong aria-hidden="true">4.7.5.6.</strong> OpenYurt</a></li><li class="chapter-item "><a href="use_cases/kubernetes/kubernetes/knative.html"><strong aria-hidden="true">4.7.5.7.</strong> Knative</a></li><li class="chapter-item "><a href="use_cases/kubernetes/kubernetes/Kwasm.html"><strong aria-hidden="true">4.7.5.8.</strong> Kwasm</a></li></ol></li><li class="chapter-item "><a href="use_cases/kubernetes/docker.html"><strong aria-hidden="true">4.7.6.</strong> Docker</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="use_cases/kubernetes/docker/lxc.html"><strong aria-hidden="true">4.7.6.1.</strong> Slim container</a></li><li class="chapter-item "><a href="use_cases/kubernetes/docker/containerd.html"><strong aria-hidden="true">4.7.6.2.</strong> containerd integration</a></li></ol></li></ol></li><li class="chapter-item "><a href="use_cases/frameworks.html"><strong aria-hidden="true">4.8.</strong> App Frameworks & Platforms</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="use_cases/frameworks/mesh.html"><strong aria-hidden="true">4.8.1.</strong> Service mesh & runtimes</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="use_cases/frameworks/mesh/dapr.html"><strong aria-hidden="true">4.8.1.1.</strong> Dapr</a></li><li class="chapter-item "><a href="use_cases/frameworks/mesh/mosn.html"><strong aria-hidden="true">4.8.1.2.</strong> MOSN</a></li><li class="chapter-item "><a href="use_cases/frameworks/mesh/wasm-nginx-module.html"><strong aria-hidden="true">4.8.1.3.</strong> Nginx</a></li><li class="chapter-item "><a href="use_cases/frameworks/mesh/eventmesh.html"><strong aria-hidden="true">4.8.1.4.</strong> Apache EventMesh</a></li></ol></li><li class="chapter-item "><a href="use_cases/frameworks/app.html"><strong aria-hidden="true">4.8.2.</strong> Application frameworks</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="use_cases/frameworks/app/yomo.html"><strong aria-hidden="true">4.8.2.1.</strong> YoMo</a></li><li class="chapter-item "><a href="use_cases/frameworks/app/reactr.html"><strong aria-hidden="true">4.8.2.2.</strong> Reactr</a></li></ol></li><li class="chapter-item "><a href="use_cases/frameworks/serverless.html"><strong aria-hidden="true">4.8.3.</strong> Serverless platforms</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="use_cases/frameworks/serverless/vercel.html"><strong aria-hidden="true">4.8.3.1.</strong> Vercel</a></li><li class="chapter-item "><a href="use_cases/frameworks/serverless/netlify.html"><strong aria-hidden="true">4.8.3.2.</strong> Netlify</a></li><li class="chapter-item "><a href="use_cases/frameworks/serverless/aws.html"><strong aria-hidden="true">4.8.3.3.</strong> AWS</a></li><li class="chapter-item "><a href="use_cases/frameworks/serverless/tencent.html"><strong aria-hidden="true">4.8.3.4.</strong> Tencent</a></li><li class="chapter-item "><a href="use_cases/frameworks/serverless/secondstate.html"><strong aria-hidden="true">4.8.3.5.</strong> Second State</a></li></ol></li></ol></li></ol></li><li class="chapter-item "><a href="write_wasm.html"><strong aria-hidden="true">5.</strong> Write a WebAssembly Application</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="write_wasm/c.html"><strong aria-hidden="true">5.1.</strong> C</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="write_wasm/c/quickstart.html"><strong aria-hidden="true">5.1.1.</strong> Getting Started</a></li><li class="chapter-item "><a href="write_wasm/c/simd.html"><strong aria-hidden="true">5.1.2.</strong> simd</a></li></ol></li><li class="chapter-item "><a href="write_wasm/rust.html"><strong aria-hidden="true">5.2.</strong> Rust</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="write_wasm/rust/bindgen.html"><strong aria-hidden="true">5.2.1.</strong> Bindgen of Rust Functions</a></li><li class="chapter-item "><a href="write_wasm/rust/wasi.html"><strong aria-hidden="true">5.2.2.</strong> Access OS Services</a></li><li class="chapter-item "><a href="write_wasm/rust/tensorflow.html"><strong aria-hidden="true">5.2.3.</strong> TensorFlow</a></li><li class="chapter-item "><a href="write_wasm/rust/wasinn.html"><strong aria-hidden="true">5.2.4.</strong> Neural Network for WASI</a></li><li class="chapter-item "><a href="write_wasm/rust/wasicrypto.html"><strong aria-hidden="true">5.2.5.</strong> Crypto for WASI</a></li><li class="chapter-item "><a href="write_wasm/rust/networking.html"><strong aria-hidden="true">5.2.6.</strong> Simple HTTP Client & Server</a></li><li class="chapter-item "><a href="write_wasm/rust/networking-https.html"><strong aria-hidden="true">5.2.7.</strong> Simple HTTPS Client & Server</a></li><li class="chapter-item "><a href="write_wasm/rust/networking-nonblocking.html"><strong aria-hidden="true">5.2.8.</strong> Non-Blocking Network Apps</a></li><li class="chapter-item "><a href="write_wasm/rust/ssr.html"><strong aria-hidden="true">5.2.9.</strong> Server-Side Rendering</a></li><li class="chapter-item "><a href="write_wasm/rust/command.html"><strong aria-hidden="true">5.2.10.</strong> Command Interface</a></li></ol></li><li class="chapter-item "><a href="write_wasm/js.html"><strong aria-hidden="true">5.3.</strong> JavaScript</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="write_wasm/js/quickstart.html"><strong aria-hidden="true">5.3.1.</strong> Getting Started</a></li><li class="chapter-item "><a href="write_wasm/js/nodejs.html"><strong aria-hidden="true">5.3.2.</strong> Node.js Compatibility</a></li><li class="chapter-item "><a href="write_wasm/js/networking.html"><strong aria-hidden="true">5.3.3.</strong> Networking Apps</a></li><li class="chapter-item "><a href="write_wasm/js/ssr.html"><strong aria-hidden="true">5.3.4.</strong> React SSR</a></li><li class="chapter-item "><a href="write_wasm/js/tensorflow.html"><strong aria-hidden="true">5.3.5.</strong> TensorFlow</a></li><li class="chapter-item "><a href="write_wasm/js/es6.html"><strong aria-hidden="true">5.3.6.</strong> ES6 Modules</a></li><li class="chapter-item "><a href="write_wasm/js/npm.html"><strong aria-hidden="true">5.3.7.</strong> Node.js & NPM Modules</a></li><li class="chapter-item "><a href="write_wasm/js/modules.html"><strong aria-hidden="true">5.3.8.</strong> Built-in Modules</a></li><li class="chapter-item "><a href="write_wasm/js/rust.html"><strong aria-hidden="true">5.3.9.</strong> Native JS API in Rust</a></li></ol></li><li class="chapter-item "><a href="write_wasm/go.html"><strong aria-hidden="true">5.4.</strong> Go</a></li><li class="chapter-item "><a href="write_wasm/swift.html"><strong aria-hidden="true">5.5.</strong> Swift</a></li><li class="chapter-item "><a href="write_wasm/as.html"><strong aria-hidden="true">5.6.</strong> AssemblyScript</a></li><li class="chapter-item "><a href="write_wasm/kotlin.html"><strong aria-hidden="true">5.7.</strong> Kotlin</a></li><li class="chapter-item "><a href="write_wasm/grain.html"><strong aria-hidden="true">5.8.</strong> Grain</a></li><li class="chapter-item "><a href="write_wasm/python.html"><strong aria-hidden="true">5.9.</strong> Python</a></li></ol></li><li class="chapter-item "><a href="sdk.html"><strong aria-hidden="true">6.</strong> Use WasmEdge Library</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="sdk/c.html"><strong aria-hidden="true">6.1.</strong> C SDK</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="sdk/c/library.html"><strong aria-hidden="true">6.1.1.</strong> Use the WasmEdge C Library</a></li><li class="chapter-item "><a href="sdk/c/hostfunction.html"><strong aria-hidden="true">6.1.2.</strong> Host Function Implementation</a></li><li class="chapter-item "><a href="sdk/c/externref.html"><strong aria-hidden="true">6.1.3.</strong> ExternRef Example</a></li><li class="chapter-item "><a href="sdk/c/multimodule.html"><strong aria-hidden="true">6.1.4.</strong> Multiple Module Example</a></li><li class="chapter-item "><a href="sdk/c/ref.html"><strong aria-hidden="true">6.1.5.</strong> 0.12.0 API references</a></li><li class="chapter-item "><a href="sdk/c/0.11.2/ref.html"><strong aria-hidden="true">6.1.6.</strong> 0.11.2 API references</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="sdk/c/0.11.2/upgrade_to_0.12.0.html"><strong aria-hidden="true">6.1.6.1.</strong> Upgrade to 0.12.0</a></li></ol></li><li class="chapter-item "><a href="sdk/c/0.10.1/ref.html"><strong aria-hidden="true">6.1.7.</strong> 0.10.1 API references</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="sdk/c/0.10.1/upgrade_to_0.11.0.html"><strong aria-hidden="true">6.1.7.1.</strong> Upgrade to 0.11.0</a></li></ol></li><li class="chapter-item "><a href="sdk/c/0.9.1/ref.html"><strong aria-hidden="true">6.1.8.</strong> 0.9.1 API references</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="sdk/c/0.9.1/upgrade_to_0.10.0.html"><strong aria-hidden="true">6.1.8.1.</strong> Upgrade to 0.10.0</a></li></ol></li></ol></li><li class="chapter-item "><a href="sdk/go.html"><strong aria-hidden="true">6.2.</strong> Go SDK</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="sdk/go/app.html"><strong aria-hidden="true">6.2.1.</strong> Embed WASM apps</a></li><li class="chapter-item "><a href="sdk/go/function.html"><strong aria-hidden="true">6.2.2.</strong> Embed WASM funcs</a></li><li class="chapter-item "><a href="sdk/go/memory.html"><strong aria-hidden="true">6.2.3.</strong> Pass complex data</a></li><li class="chapter-item "><a href="sdk/go/tensorflow.html"><strong aria-hidden="true">6.2.4.</strong> Tensorflow</a></li><li class="chapter-item "><a href="sdk/go/bindgen.html"><strong aria-hidden="true">6.2.5.</strong> Embed bindgen funcs</a></li><li class="chapter-item "><a href="sdk/go/ref.html"><strong aria-hidden="true">6.2.6.</strong> v0.12.0 API references</a></li><li class="chapter-item "><a href="sdk/go/0.11.2/ref.html"><strong aria-hidden="true">6.2.7.</strong> v0.11.2 API references</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="sdk/go/0.11.2/upgrade_to_0.12.0.html"><strong aria-hidden="true">6.2.7.1.</strong> Upgrade to 0.12.0</a></li></ol></li><li class="chapter-item "><a href="sdk/go/0.10.1/ref.html"><strong aria-hidden="true">6.2.8.</strong> v0.10.1 API references</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="sdk/go/0.10.1/upgrade_to_0.11.0.html"><strong aria-hidden="true">6.2.8.1.</strong> Upgrade to v0.11.0</a></li></ol></li><li class="chapter-item "><a href="sdk/go/0.9.1/ref.html"><strong aria-hidden="true">6.2.9.</strong> v0.9.1 API references</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="sdk/go/0.9.1/upgrade_to_0.10.0.html"><strong aria-hidden="true">6.2.9.1.</strong> Upgrade to v0.10.0</a></li></ol></li></ol></li><li class="chapter-item "><a href="sdk/node.html"><strong aria-hidden="true">6.3.</strong> Node.js SDK</a></li><li class="chapter-item "><a href="sdk/rust.html"><strong aria-hidden="true">6.4.</strong> Rust SDK</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="sdk/rust/say_hello.html"><strong aria-hidden="true">6.4.1.</strong> Hello World!</a></li><li class="chapter-item "><a href="sdk/rust/memory_manipulation.html"><strong aria-hidden="true">6.4.2.</strong> Memory Manipulation</a></li><li class="chapter-item "><a href="sdk/rust/table_and_funcref.html"><strong aria-hidden="true">6.4.3.</strong> Table and FuncRef</a></li><li class="chapter-item "><a href="sdk/rust/sys_run_host_func.html"><strong aria-hidden="true">6.4.4.</strong> Run a WebAssembly function with WasmEdge low-level APIs</a></li><li class="chapter-item "><a href="sdk/rust/concurrent_fib.html"><strong aria-hidden="true">6.4.5.</strong> Compute Fibonacci numbers concurrently</a></li><li class="chapter-item "><a href="sdk/rust/how_to_use_module_instance.html"><strong aria-hidden="true">6.4.6.</strong> Usage of WasmEdge module instances</a></li></ol></li><li class="chapter-item "><a href="sdk/python.html"><strong aria-hidden="true">6.5.</strong> Python SDK</a></li></ol></li><li class="chapter-item "><a href="cli.html"><strong aria-hidden="true">7.</strong> Use WasmEdge CLI</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="cli/wasmedge.html"><strong aria-hidden="true">7.1.</strong> wasmedge WASM Runner</a></li><li class="chapter-item "><a href="cli/wasmedge_compile.html"><strong aria-hidden="true">7.2.</strong> wasmedgec AOT Compiler</a></li><li class="chapter-item "><a href="cli/wasmedge_tool.html"><strong aria-hidden="true">7.3.</strong> wasmedge run WASM Runner</a></li></ol></li><li class="chapter-item "><a href="plugin.html"><strong aria-hidden="true">8.</strong> Develop WasmEdge Plug-in</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="develop_plugin/c.html"><strong aria-hidden="true">8.1.</strong> Develop Plug-in in C API</a></li><li class="chapter-item "><a href="develop_plugin/cpp.html"><strong aria-hidden="true">8.2.</strong> Develop Plug-in in C++</a></li></ol></li><li class="chapter-item "><a href="contribute.html"><strong aria-hidden="true">9.</strong> Contribute to WasmEdge</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="contribute/release_process.html"><strong aria-hidden="true">9.1.</strong> Release Process</a></li><li class="chapter-item "><a href="contribute/contribute.html"><strong aria-hidden="true">9.2.</strong> Contribute Steps</a></li><li class="chapter-item "><a href="contribute/build_from_src.html"><strong aria-hidden="true">9.3.</strong> Build WasmEdge from source</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="contribute/build_from_src/linux.html"><strong aria-hidden="true">9.3.1.</strong> Build on Linux</a></li><li class="chapter-item "><a href="contribute/build_from_src/macos.html"><strong aria-hidden="true">9.3.2.</strong> Build on MacOS</a></li><li class="chapter-item "><a href="contribute/build_from_src/windows.html"><strong aria-hidden="true">9.3.3.</strong> Build on Windows</a></li><li class="chapter-item "><a href="contribute/build_from_src/android.html"><strong aria-hidden="true">9.3.4.</strong> Build for Android</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="contribute/build_from_src/android/cli.html"><strong aria-hidden="true">9.3.4.1.</strong> CLI tools</a></li><li class="chapter-item "><a href="contribute/build_from_src/android/ndk.html"><strong aria-hidden="true">9.3.4.2.</strong> NDK native app</a></li><li class="chapter-item "><a href="contribute/build_from_src/android/apk.html"><strong aria-hidden="true">9.3.4.3.</strong> APK app</a></li></ol></li><li class="chapter-item "><a href="contribute/build_from_src/sel4.html"><strong aria-hidden="true">9.3.5.</strong> Build for seL4</a></li><li class="chapter-item "><a href="contribute/build_from_src/openharmony.html"><strong aria-hidden="true">9.3.6.</strong> Build for OpenHarmony</a></li><li class="chapter-item "><a href="contribute/build_from_src/raspberrypi.html"><strong aria-hidden="true">9.3.7.</strong> Build for Raspberry Pi</a></li><li class="chapter-item "><a href="contribute/build_from_src/openwrt.html"><strong aria-hidden="true">9.3.8.</strong> Build for OpenWrt</a></li><li class="chapter-item "><a href="contribute/build_from_src/plugin_wasi_crypto.html"><strong aria-hidden="true">9.3.9.</strong> Build with WASI-Crypto Plug-in</a></li><li class="chapter-item "><a href="contribute/build_from_src/plugin_wasi_logging.html"><strong aria-hidden="true">9.3.10.</strong> Build with WASI-Logging Plug-in</a></li><li class="chapter-item "><a href="contribute/build_from_src/plugin_wasi_nn.html"><strong aria-hidden="true">9.3.11.</strong> Build with WASI-NN Plug-in</a></li><li class="chapter-item "><a href="contribute/build_from_src/plugin_wasmedge_process.html"><strong aria-hidden="true">9.3.12.</strong> Build with WasmEdge-process Plug-in</a></li></ol></li><li class="chapter-item "><a href="contribute/installer.html"><strong aria-hidden="true">9.4.</strong> WasmEdge Installer Guide</a></li><li class="chapter-item "><a href="contribute/internal.html"><strong aria-hidden="true">9.5.</strong> WasmEdge Internal</a></li><li class="chapter-item "><a href="contribute/wish_list.html"><strong aria-hidden="true">9.6.</strong> Wish List</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">WasmEdge Runtime</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/WasmEdge/WasmEdge" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<blockquote>
<p>This Part has been moved to<a href="https://wasmedge.org/docs/develop/overview">https://wasmedge.org/docs/develop/overview</a>. Please use our new docs.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="quick-start"><a class="header" href="#quick-start">Quick Start</a></h1>
<blockquote>
<p>This part has been moved to <a href="https://wasmedge.org/docs/category/getting-started-with-wasmedge">https://wasmedge.org/docs/category/getting-started-with-wasmedge</a>. Please use our new docs.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="wasmedge-installation-and-uninstallation"><a class="header" href="#wasmedge-installation-and-uninstallation">WasmEdge Installation And Uninstallation</a></h1>
<blockquote>
<p>This part has been moved to <a href="https://wasmedge.org/docs/start/install">https://wasmedge.org/docs/start/install</a>. Please use our new docs.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="using-wasmedge-in-docker"><a class="header" href="#using-wasmedge-in-docker">Using WasmEdge in Docker</a></h1>
<blockquote>
<p>This part has been moved to <a href="https://wasmedge.org/docs/develop/deploy/kubernetes/docker-slim">https://wasmedge.org/docs/develop/deploy/kubernetes/docker-slim</a>. Please use our new docs.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="running-wasm-with-wasmedge-cli"><a class="header" href="#running-wasm-with-wasmedge-cli">Running WASM with WasmEdge CLI</a></h1>
<blockquote>
<p>This part has been moved to <a href="https://wasmedge.org/docs/start/build-and-run/cli">https://wasmedge.org/docs/start/build-and-run/cli</a>. Please use our new docs.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="execution-in-aot-mode"><a class="header" href="#execution-in-aot-mode">Execution in AOT Mode</a></h1>
<blockquote>
<p>This part has been moved to <a href="https://wasmedge.org/docs/start/build-and-run/aot">https://wasmedge.org/docs/start/build-and-run/aot</a>. Please use our new docs.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="wasmedge-features"><a class="header" href="#wasmedge-features">WasmEdge Features</a></h1>
<blockquote>
<p>This Part has been moved to<a href="https://wasmedge.org/docs/start/wasmedge/features">https://wasmedge.org/docs/start/wasmedge/features</a>. Please use our new docs.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="supported-wasm-and-wasi-proposals"><a class="header" href="#supported-wasm-and-wasi-proposals">Supported WASM And WASI Proposals</a></h1>
<blockquote>
<p>This part has been moved to <a href="https://wasmedge.org/docs/start/wasmedge/extensions/proposals">https://wasmedge.org/docs/start/wasmedge/extensions/proposals</a>. Please use our new docs.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="wasmedge-proprietary-extensions"><a class="header" href="#wasmedge-proprietary-extensions">WasmEdge Proprietary Extensions</a></h1>
<blockquote>
<p>This part has been moved to <a href="https://wasmedge.org/docs/develop/wasmedge/extensions/unique_extensions">https://wasmedge.org/docs/develop/wasmedge/extensions/unique_extensions</a>. Please use our new docs.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="wasmedge-integrations"><a class="header" href="#wasmedge-integrations">WasmEdge Integrations</a></h1>
<blockquote>
<p>This part has been moved to <a href="https://wasmedge.org/docs/start/wasmedge/integrations">https://wasmedge.org/docs/start/wasmedge/integrations</a>. Please use our new docs.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="supported-platforms"><a class="header" href="#supported-platforms">Supported Platforms</a></h1>
<blockquote>
<p>This part has been moved to <a href="https://wasmedge.org/docs/start/wasmedge/features#cross-platform">https://wasmedge.org/docs/start/wasmedge/features#cross-platform</a>. Please use our new docs.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="comparison"><a class="header" href="#comparison">Comparison</a></h1>
<p>// TODO: TBD in New Docs - @adithyaakrishna</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="wasmedge-use-cases"><a class="header" href="#wasmedge-use-cases">WasmEdge Use Cases</a></h1>
<blockquote>
<p>This part has been moved to <a href="https://wasmedge.org/docs/start/usage/use-cases">https://wasmedge.org/docs/start/usage/use-cases</a>. Please use our new docs.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="server-side-rendering-modern-web-ui"><a class="header" href="#server-side-rendering-modern-web-ui">Server Side Rendering Modern Web UI</a></h1>
<p>Traditional web applications follows the client-server model. In the past era of application servers, the entire UI is dynamically generated from the server. The browser is simply a thin client that displays the rendered web pages at real time. However, as the browser becomes more capable and sophisticated, the client can now take on more workload to improve application UX, performance, and security.</p>
<p>That gives rise to the era of Jamstack. There is now a clear separation between frontend and backend services. The frontend is a static web site (HTML + JavaScript + WebAssembly) generated from UI frameworks such as React.js, Vue.js, Yew or Percy, and the backend consists of microservices. Yet, as Jamstack gains popularity, the diversity of clients (both browsers and apps) makes it very difficult to achieve great performance across all use cases.</p>
<p>The solution is server-side rendering (SSR). That is to have edge servers run the &quot;client side&quot; UI code (ie the React generated JavaScript OR Percy generated WebAssembly), and send back the rendered HTML DOM objects to the browser. In this case, the edge server must execute the exact same code (i.e. <a href="use_cases/../write_wasm/js.html">JavaScript</a> and WebAssembly) as the browser to render the UI. That is called isomorphic Jamstack applications. The WasmEdge runtime provides a lightweight, high performance, OCI complaint, and polyglot container to run all kinds of SSR functions on edge servers.</p>
<ul>
<li><a href="use_cases/../write_wasm/js/ssr.html">React JS SSR function</a></li>
<li>Vue JS SSR function (coming soon)</li>
<li>Yew Rust compiled to WebAssembly SSR function (coming soon)</li>
<li><a href="use_cases/../write_wasm/rust/ssr.html">Percy Rust compiled to WebAssembly SSR function</a></li>
</ul>
<p>We also exploring ways to render more complex UI and interactions on WasmEdge-based edge servers, and then stream the rendered results to the client application. Potential examples include</p>
<ul>
<li>Render Unity3D animations on the edge server (based on <a href="https://docs.unity3d.com/2020.1/Documentation/Manual/webgl-gettingstarted.html">WebAssembly rendering of Unity3D</a>)</li>
<li>Render interactive video (generated from AI) on the edge server</li>
</ul>
<p>Of course, the edge cloud could grow well beyond SSR for UI components. It could also host high-performance microservices for business logic and serverless functions. Read on to the next chapter.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="microservices"><a class="header" href="#microservices">Microservices</a></h1>
<p>The edge cloud can run application logic microservices very close to the client device.</p>
<ul>
<li>The microservices could be stateless computational tasks, such as <a href="use_cases/../write_wasm/rust/tensorflow.html">AI inference</a> and <a href="use_cases/frameworks/app/yomo.html">stream data analysis</a>, which offload computation from the client.</li>
<li>The microservices could also <a href="https://github.com/second-state/wasmedge-anna-rs">interact with data cache services</a> that sync with backend databases.</li>
</ul>
<p>The edge cloud has advantages such as low latency, high security, and high performance. Operationally, WasmEdge can be embedded into cloud-native infrastructure via its SDKs in <a href="use_cases/../sdk/c.html">C</a>, <a href="use_cases/../sdk/go.html">Go</a> and <a href="use_cases/../sdk/rust.html">Rust</a>. It is also an OCI compliant runtime that can be directly <a href="use_cases/kubernetes/cri.html">managed by container tools</a> as a lightweight and high-performance alternative to Linux containers. The following application frameworks have been tested to work with WasmEdge-based microservices.</p>
<h2 id="dapr-distributed-application-runtime"><a class="header" href="#dapr-distributed-application-runtime">Dapr (Distributed Application Runtime)</a></h2>
<ul>
<li><a href="use_cases/frameworks/mesh/dapr.html">Tutorial</a></li>
<li><a href="https://github.com/second-state/dapr-wasm">Code template</a></li>
</ul>
<h2 id="service-mesh-work-in-progress"><a class="header" href="#service-mesh-work-in-progress">Service mesh (work in progress)</a></h2>
<ul>
<li>Linkerd</li>
<li>MOSN</li>
<li>Envoy</li>
</ul>
<h2 id="orchestration-and-management"><a class="header" href="#orchestration-and-management">Orchestration and management</a></h2>
<ul>
<li><a href="use_cases/kubernetes.html">Kubernetes</a></li>
<li><a href="use_cases/kubernetes/kubernetes/kubeedge.html">KubeEdge</a></li>
<li><a href="use_cases/kubernetes/kubernetes/superedge.html">SuperEdge</a></li>
<li><a href="use_cases/kubernetes/kubernetes/openyurt.html">OpenYurt</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="serverless-function-as-a-service-in-public-clouds"><a class="header" href="#serverless-function-as-a-service-in-public-clouds">Serverless Function-As-A-Service in Public Clouds</a></h1>
<p>WasmEdge works with existing serverless or Jamstack platforms to provide a high-performance, portable and secure runtime for functions. It offers significant benefits even when it runs inside Docker or microVMs on those platforms.</p>
<h2 id="aws-lambda"><a class="header" href="#aws-lambda">AWS Lambda</a></h2>
<ul>
<li><a href="https://www.cncf.io/blog/2021/08/25/webassembly-serverless-functions-in-aws-lambda/">Tutorial</a></li>
<li><a href="https://github.com/second-state/aws-lambda-wasm-runtime">Code template</a></li>
</ul>
<h2 id="tencent-serverless-functions"><a class="header" href="#tencent-serverless-functions">Tencent Serverless Functions</a></h2>
<ul>
<li><a href="https://my.oschina.net/u/4532842/blog/5172639">Tutorial in Chinese</a></li>
<li><a href="https://github.com/second-state/tencent-scf-wasm-runtime">Code template</a></li>
</ul>
<h2 id="vercel-serverless-functions"><a class="header" href="#vercel-serverless-functions">Vercel Serverless Functions</a></h2>
<ul>
<li><a href="https://www.secondstate.io/articles/vercel-wasmedge-webassembly-rust/">Tutorial</a></li>
<li><a href="https://github.com/second-state/vercel-wasm-runtime">Code template</a></li>
</ul>
<h2 id="netlify-functions"><a class="header" href="#netlify-functions">Netlify Functions</a></h2>
<ul>
<li><a href="https://www.secondstate.io/articles/netlify-wasmedge-webassembly-rust-serverless/">Tutorial</a></li>
<li><a href="https://github.com/second-state/netlify-wasm-runtime">Code template</a></li>
</ul>
<h2 id="second-state-functions"><a class="header" href="#second-state-functions">Second State Functions</a></h2>
<ul>
<li><a href="https://www.secondstate.io/faas/">Tutorials</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="serverless-software-as-a-service-functions"><a class="header" href="#serverless-software-as-a-service-functions">Serverless Software-As-A-Service Functions</a></h1>
<p>WasmEdge can support customized SaaS extensions or applications using serverless functions instead of traditional network APIs. That dramatically improves SaaS users' and developers' productivity.</p>
<ul>
<li>WasmEdge could be embedded into SaaS products to execute user-defined functions. In this scenario, the WasmEdge function API replaces the SaaS web API. The embedded WasmEdge functions are much faster, safer, and easier to use than RPC functions over the web.</li>
<li>Edge servers could provide WasmEdge-based containers to interact with existing SaaS or PaaS APIs without requiring the user to run his own servers (eg callback servers). The serverless API services can be co-located in the same networks as the SaaS to provide optimal performance and security.</li>
</ul>
<p>The examples below showcase how WasmEdge-based serverless functions connect together SaaS APIs from different services, and process data flows across those SaaS APIs according each user's business logic.</p>
<h2 id="slack"><a class="header" href="#slack">Slack</a></h2>
<ul>
<li><a href="http://reactor.secondstate.info/en/docs/user_guideline.html">Build a serverless chatbot for Slack</a></li>
</ul>
<h2 id="lark"><a class="header" href="#lark">Lark</a></h2>
<p>It is also known as <code>飞书</code> aka the Chinese Slack. It is created by Byte Dance, the parent company of Tiktok.</p>
<ul>
<li><a href="http://reactor.secondstate.info/en/docs/user_guideline.html">Build a serverless chatbot for Lark</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="wasmedge-on-smart-devices"><a class="header" href="#wasmedge-on-smart-devices">WasmEdge On Smart Devices</a></h1>
<p>Smart device apps could embed WasmEdge as a middleware runtime to render interactive content on the UI, connect to native device drivers, and access specialized hardware features (i.e, the GPU for AI inference). The benefits of the WasmEdge runtime over native-compiled machine code include security, safety, portability, manageability, OTA upgradability, and developer productivity. WasmEdge runs on the following device OSes.</p>
<ul>
<li><a href="use_cases/../contribute/build_from_src/android.html">Android</a></li>
<li><a href="use_cases/../contribute/build_from_src/openharmony.html">OpenHarmony</a></li>
<li><a href="use_cases/../contribute/build_from_src/raspberrypi.html">Raspberry Pi</a></li>
<li><a href="use_cases/../contribute/build_from_src/sel4.html">The seL4 RTOS</a></li>
</ul>
<p>With WasmEdge on both the device and the edge server, we can support <a href="use_cases/server_side_render.html">isomorphic Server-Side Rendering (SSR)</a> and <a href="use_cases/microservice.html">microservices</a> for rich-client mobile applications that is both portable and upgradable.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="javascript-or-domain-specific-language-runtime"><a class="header" href="#javascript-or-domain-specific-language-runtime">JavaScript or Domain Specific Language Runtime</a></h1>
<p>In order for WebAssembly to be widely adopted by developers as a runtime, it must support &quot;easy&quot; languages like JavaScript. Or, better yet, through its advanced compiler toolchain, WasmEdge could support high performance DSLs (Domain Specific Languages), which are low code solutions designed for specific tasks.</p>
<h2 id="javascript"><a class="header" href="#javascript">JavaScript</a></h2>
<p>WasmEdge can act as a cloud-native JavaScript runtime by embedding a JS execution engine or interpreter. It is faster and lighter than running a JS engine inside Docker. WasmEdge supports JS APIs to access native extension libraries such as network sockets, tensorflow, and user-defined shared libraries. It also allows embedding JS into other high-performance languages (eg, Rust) or using Rust / C to implement JS functions.</p>
<ul>
<li>Tutorials
<ul>
<li><a href="https://www.secondstate.io/articles/run-javascript-in-webassembly-with-wasmedge/">Run JavaScript</a></li>
<li><a href="https://www.secondstate.io/articles/embed-javascript-in-rust/">Embed JavaScript in Rust</a></li>
<li><a href="https://www.secondstate.io/articles/embed-rust-in-javascript/">Create JavaScript API using Rust functions</a></li>
<li><a href="https://www.secondstate.io/articles/call-native-functions-from-javascript/">Call C native shared library functions from JavaScript</a></li>
</ul>
</li>
<li><a href="use_cases/../write_wasm/js.html">Examples</a></li>
<li><a href="https://github.com/second-state/wasmedge-quickjs">WasmEdge’s embedded QuickJS engine</a></li>
</ul>
<h2 id="dsl-for-image-classification"><a class="header" href="#dsl-for-image-classification">DSL for image classification</a></h2>
<p>The image classification DSL is a YAML format that allows the user to specify a tensorflow model and its parameters. WasmEdge takes an image as the input of the DSL and outputs the detected item name / label.</p>
<ul>
<li>Example: <a href="https://github.com/second-state/wasm-learning/blob/master/cli/classify_yml/config/food.yml">Run a YAML to detect food items in an image</a></li>
</ul>
<h2 id="dsl-for-chatbots"><a class="header" href="#dsl-for-chatbots">DSL for chatbots</a></h2>
<p>A chatbot DSL function takes an input string and responds with a reply string. The DSL specifies the internal state transitions of the chatbot, as well as AI models for language understanding. This work is in progress.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="wasmedge-in-kubernetes"><a class="header" href="#wasmedge-in-kubernetes">WasmEdge in Kubernetes</a></h1>
<p>Developers can leverage container tools such as Kubernetes, Docker and CRI-O to deploy, manage, and run lightweight WebAssembly applications. In this chapter, we will demonstrate how Kubernetes ecosystem tools work with WasmEdge WebAssembly applications.</p>
<p>Compared with Linux containers, <a href="https://www.infoq.com/articles/arm-vs-x86-cloud-performance/">WebAssembly could be 100x faster at startup</a>, have a much smaller memory and disk footprint, and have a better-defined safety sandbox. However, the trade-off is that WebAssembly requires its own language SDKs, and compiler toolchains, making it a more constrained developer environment than Linux containers. WebAssembly is increasingly used in Edge Computing scenarios where it is difficult to deploy Linux containers or when the application performance is vital.</p>
<p>One of the great advantages of Linux application containers is the rich ecosystem of tools. The good news is that you can use the exact same tools to manage WebAssembly applications, enabling Linux containers and WebAssembly apps to run side-by-side in the same system.</p>
<p><img src="use_cases/kubernetes.png" alt="kubernetes" /></p>
<p>The contents of this chapter are organized by the approaches for integrating WasmEdge into container toolchains.</p>
<ul>
<li>The <a href="use_cases/kubernetes/docker/lxc.html">slimmed Linux container tailored for WasmEdge</a> offers the easiest option (but with performance trade-offs) to integrate WasmEdge applications into any container tooling system.</li>
<li>The most important integration approach is to replace the underlying OCI runtime of the toolchain stack with a WasmEdge-enabled <code>crun</code> runtime.
<ul>
<li><a href="use_cases/kubernetes/quickstart.html">Quick start</a> provides simple and scripted tutorials to run WasmEdge-based applications as container images in Kubernetes.</li>
<li><a href="use_cases/kubernetes/demo.html">Demo apps</a> discusses the two demo WasmEdge applications we will run in Kubernetes clusters. Those applications are compiled from Rust source code, packaged as OCI images, and uploaded to Docker Hub.</li>
<li><a href="use_cases/kubernetes/container.html">Container runtimes</a> covers how to configure low level container runtimes, such as crun, to load and run WebAssembly OCI images.</li>
<li><a href="use_cases/kubernetes/cri.html">CRI runtimes</a> covers how to configure and use high level container runtimes, such as CRI-O and containerd, to load and run WebAssembly OCI images on top of low level container runtimes.</li>
<li><a href="use_cases/kubernetes/kubernetes.html">Kubernetes</a> covers how to configure and use Kubernetes and Kubernetes variations, such as KubeEdge and SuperEdge, to load and run WebAssembly OCI images on top of CRI runtimes.</li>
</ul>
</li>
<li>If you cannot replace the OCI runtime in your toolchain with WasmEdge-enabled <code>crun</code>, you can use a <a href="use_cases/kubernetes/docker/containerd.html">containerd shim</a> to start and run a WasmEdge application without any intrusive change.</li>
</ul>
<p>The goal is to load and run WebAssembly OCI images side by side with Linux OCI images (e.g., today's Docker containers) across the entire Kubernetes stack.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="quick-start-1"><a class="header" href="#quick-start-1">Quick start</a></h1>
<p>We have created Ubuntu-based scripts for you to quickly get started with the following combination of runtimes in a standard Kubernetes setup.</p>
<div class="table-wrapper"><table><thead><tr><th>CRI (high level) runtime</th><th>OCI (low level) runtime</th><th></th></tr></thead><tbody>
<tr><td>CRI-O</td><td>crun + WasmEdge</td><td><a href="https://github.com/second-state/wasmedge-containers-examples/blob/main/.github/workflows/kubernetes-crio.yml">Script</a></td></tr>
<tr><td>containerd</td><td>crun + WasmEdge</td><td><a href="https://github.com/second-state/wasmedge-containers-examples/blob/main/.github/workflows/kubernetes-containerd.yml">Script</a></td></tr>
</tbody></table>
</div>
<h2 id="cri-o-and-crun"><a class="header" href="#cri-o-and-crun">CRI-O and crun</a></h2>
<p>You can use the CRI-O <a href="https://github.com/second-state/wasmedge-containers-examples/blob/main/crio/install.sh">install.sh</a> script to install CRI-O and <code>crun</code> on Ubuntu 20.04.</p>
<pre><code class="language-bash">wget -qO- https://raw.githubusercontent.com/second-state/wasmedge-containers-examples/main/crio/install.sh | bash
</code></pre>
<p>Next, install Kubernetes using the <a href="https://github.com/second-state/wasmedge-containers-examples/blob/main/kubernetes_crio/install.sh">following script</a>.</p>
<pre><code class="language-bash">wget -qO- https://raw.githubusercontent.com/second-state/wasmedge-containers-examples/main/kubernetes_crio/install.sh | bash
</code></pre>
<p>The <a href="https://github.com/second-state/wasmedge-containers-examples/blob/main/kubernetes_crio/simple_wasi_application.sh">simple_wasi_application.sh</a> script shows how to pull <a href="use_cases/kubernetes/demo/wasi.html">a WebAssembly application</a> from Docker Hub, and then run it as a containerized application in Kubernetes.</p>
<pre><code class="language-bash">wget -qO- https://raw.githubusercontent.com/second-state/wasmedge-containers-examples/main/kubernetes_crio/simple_wasi_application.sh | bash
</code></pre>
<p>You should see results from the WebAssembly program printed in the console log. <a href="https://github.com/second-state/wasmedge-containers-examples/runs/4186005677?check_suite_focus=true#step:6:3007">Here is an example</a>.</p>
<h2 id="containerd-and-crun"><a class="header" href="#containerd-and-crun">containerd and crun</a></h2>
<p>You can use the containerd <a href="https://github.com/second-state/wasmedge-containers-examples/blob/main/containerd/install.sh">install.sh</a> script to install <code>containerd</code> and <code>crun</code> on Ubuntu 20.04.</p>
<pre><code class="language-bash">wget -qO- https://raw.githubusercontent.com/second-state/wasmedge-containers-examples/main/containerd/install.sh | bash
</code></pre>
<p>Next, install Kubernetes using the <a href="https://github.com/second-state/wasmedge-containers-examples/blob/main/kubernetes_containerd/install.sh">following script</a>.</p>
<pre><code class="language-bash">wget -qO- https://raw.githubusercontent.com/second-state/wasmedge-containers-examples/main/kubernetes_containerd/install.sh | bash
</code></pre>
<p>The <a href="https://github.com/second-state/wasmedge-containers-examples/blob/main/kubernetes_containerd/simple_wasi_application.sh">simple_wasi_application.sh</a> script shows how to pull <a href="use_cases/kubernetes/demo/wasi.html">a WebAssembly application</a> from Docker Hub, and then run it as a containerized application in Kubernetes.</p>
<pre><code class="language-bash">wget -qO- https://raw.githubusercontent.com/second-state/wasmedge-containers-examples/main/kubernetes_containerd/simple_wasi_application.sh | bash
</code></pre>
<p>You should see results from the WebAssembly program printed in the console log. <a href="https://github.com/second-state/wasmedge-containers-examples/runs/4577789181?check_suite_focus=true#step:6:3010">Here is an example</a>.</p>
<p>Read on to the rest of this chapter to learn how exactly those runtimes are configured.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="demo-apps"><a class="header" href="#demo-apps">Demo apps</a></h1>
<p>In this chapter, we will cover two demo apps. We will build them from Rust source code, build OCI images around them, and then publish the images to Docker Hub.</p>
<p>If you have not done so, please</p>
<ul>
<li><a href="https://www.rust-lang.org/tools/install">Install Rust</a></li>
<li><a href="https://hub.docker.com/">Register for Docker Hub</a></li>
</ul>
<p>Next, explore the examples</p>
<ul>
<li><a href="use_cases/kubernetes/demo/wasi.html">A simple WASI example</a></li>
<li><a href="use_cases/kubernetes/demo/server.html">A HTTP server example</a></li>
</ul>
<p>Since we have already built and published those demo apps on Docker Hub, you could also just go straight to the container runtime sections to use these images.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="a-simple-webassembly-example"><a class="header" href="#a-simple-webassembly-example">A simple WebAssembly example</a></h1>
<p>In this article, I will show you how to build a container image for a WebAssembly application. It can then be started and managed by Kubernetes ecosystem tools, such as CRI-O, Docker, crun, and Kubernetes.</p>
<h2 id="prerequisites"><a class="header" href="#prerequisites">Prerequisites</a></h2>
<blockquote>
<p>If you simply want a wasm bytecode file to test as a container image, you can skip the building process and just <a href="https://github.com/second-state/wasm-learning/blob/master/cli/wasi/wasi_example_main.wasm">download the wasm file here</a>.</p>
</blockquote>
<p>If you have not done so already, follow these simple instructions to <a href="https://www.rust-lang.org/tools/install">install Rust</a>.</p>
<h2 id="download-example-code"><a class="header" href="#download-example-code">Download example code</a></h2>
<pre><code class="language-bash">git clone https://github.com/second-state/wasm-learning
cd wasm-learning/cli/wasi
</code></pre>
<h2 id="build-the-wasm-bytecode"><a class="header" href="#build-the-wasm-bytecode">Build the WASM bytecode</a></h2>
<pre><code class="language-bash">rustup target add wasm32-wasi
cargo build --target wasm32-wasi --release
</code></pre>
<p>The wasm bytecode application is in the <code>target/wasm32-wasi/release/wasi_example_main.wasm</code> file. You can now publish and use it as a container image.</p>
<h2 id="apply-executable-permission-on-the-wasm-bytecode"><a class="header" href="#apply-executable-permission-on-the-wasm-bytecode">Apply executable permission on the Wasm bytecode</a></h2>
<pre><code class="language-bash">chmod +x target/wasm32-wasi/release/wasi_example_main.wasm
</code></pre>
<h2 id="create-dockerfile"><a class="header" href="#create-dockerfile">Create Dockerfile</a></h2>
<p>Create a file called <code>Dockerfile</code> in the <code>target/wasm32-wasi/release/</code> folder with the following content:</p>
<pre><code class="language-dockerfile">FROM scratch
ADD wasi_example_main.wasm /
CMD [&quot;/wasi_example_main.wasm&quot;]
</code></pre>
<h2 id="create-container-image-with-annotations"><a class="header" href="#create-container-image-with-annotations">Create container image with annotations</a></h2>
<blockquote>
<p>Please note that adding self-defined annotation is still a new feature in buildah.</p>
</blockquote>
<p>The <code>crun</code> container runtime can start the above WebAssembly-based container image. But it requires the <code>module.wasm.image/variant=compat-smart</code> annotation on the container image to indicate that it is a WebAssembly application without a guest OS. You can find the details in <a href="https://github.com/containers/crun/blob/main/docs/wasm-wasi-example.md">Official crun repo</a>.</p>
<p>To add <code>module.wasm.image/variant=compat-smart</code> annotation in the container image, you will need the latest <a href="https://buildah.io/">buildah</a>. Currently, Docker does not support this feature. Please follow <a href="https://github.com/containers/buildah/blob/main/install.md">the install instructions of buildah</a> to build the latest buildah binary.</p>
<h3 id="build-and-install-the-latest-buildah-on-ubuntu"><a class="header" href="#build-and-install-the-latest-buildah-on-ubuntu">Build and install the latest buildah on Ubuntu</a></h3>
<p>On Ubuntu zesty and xenial, use these commands to prepare for buildah.</p>
<pre><code class="language-bash">sudo apt-get -y install software-properties-common

export OS=&quot;xUbuntu_20.04&quot;
sudo bash -c &quot;echo \&quot;deb https://download.opensuse.org/repositories/devel:/kubic:/libcontainers:/stable/$OS/ /\&quot; &gt; /etc/apt/sources.list.d/devel:kubic:libcontainers:stable.list&quot;
sudo bash -c &quot;curl -L https://download.opensuse.org/repositories/devel:/kubic:/libcontainers:/stable/$OS/Release.key | apt-key add -&quot;

sudo add-apt-repository -y ppa:alexlarsson/flatpak
sudo apt-get -y -qq update
sudo apt-get -y install bats git libapparmor-dev libdevmapper-dev libglib2.0-dev libgpgme-dev libseccomp-dev libselinux1-dev skopeo-containers go-md2man containers-common
sudo apt-get -y install golang-1.16 make
</code></pre>
<p>Then, follow these steps to build and install buildah on Ubuntu.</p>
<pre><code class="language-bash">mkdir -p ~/buildah
cd ~/buildah
export GOPATH=`pwd`
git clone https://github.com/containers/buildah ./src/github.com/containers/buildah
cd ./src/github.com/containers/buildah
PATH=/usr/lib/go-1.16/bin:$PATH make
cp bin/buildah /usr/bin/buildah
buildah --help
</code></pre>
<h3 id="create-and-publish-a-container-image-with-buildah"><a class="header" href="#create-and-publish-a-container-image-with-buildah">Create and publish a container image with buildah</a></h3>
<p>In the <code>target/wasm32-wasi/release/</code> folder, do the following.</p>
<pre><code class="language-bash">$ sudo buildah build --annotation &quot;module.wasm.image/variant=compat-smart&quot; -t wasm-wasi-example .
# make sure docker is install and running
# systemctl status docker
# to make sure regular user can use docker
# sudo usermod -aG docker $USER
# newgrp docker

# You may need to use docker login to create the `~/.docker/config.json` for auth.
$ sudo buildah push --authfile ~/.docker/config.json wasm-wasi-example docker://docker.io/wasmedge/example-wasi:latest
</code></pre>
<p>That's it! Now you can try to run it in <a href="use_cases/kubernetes/demo/../cri/crio.html#run-a-simple-webassembly-app">CRI-O</a> or <a href="use_cases/kubernetes/demo/../kubernetes/kubernetes-crio.html#a-simple-webassembly-app">Kubernetes</a>!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="http-server-example"><a class="header" href="#http-server-example">HTTP server example</a></h1>
<blockquote>
<p>This part has been moved to <a href="https://github.com/second-state/wasmedge-containers-examples/blob/main/http_server_wasi_app.md">https://github.com/second-state/wasmedge-containers-examples/blob/main/http_server_wasi_app.md</a>. Please use our new docs.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="container-runtimes"><a class="header" href="#container-runtimes">Container runtimes</a></h1>
<p>The container image can be started by any OCI-compliant container runtime, such as</p>
<ul>
<li><a href="use_cases/kubernetes/container/crun.html">crun</a>: a high performance and lightweight container runtime written in C</li>
<li><a href="use_cases/kubernetes/container/runc.html">runc</a>: a widely used container runtime written in Go</li>
<li><a href="use_cases/kubernetes/container/youki.html">youki</a>: a OCI-compatible container runtime implementation written in Rust</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="crun"><a class="header" href="#crun">crun</a></h1>
<blockquote>
<p>This part has been moved to  <a href="https://wasmedge.org/docs/develop/deploy/oci-runtime/crun">https://wasmedge.org/docs/develop/deploy/oci-runtime/crun</a>. Please use our new docs.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="runc"><a class="header" href="#runc">runc</a></h1>
<p>Coming soon, or you can <a href="https://github.com/WasmEdge/WasmEdge/issues/639">help out</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="youki"><a class="header" href="#youki">youki</a></h1>
<blockquote>
<p>This part has been moved to  <a href="https://wasmedge.org/docs/develop/deploy/oci-runtime/youki">https://wasmedge.org/docs/develop/deploy/oci-runtime/youki</a>. Please use our new docs.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cri-runtimes"><a class="header" href="#cri-runtimes">CRI runtimes</a></h1>
<p>The high-level container runtime, such as <a href="https://cri-o.io/">CRI-O</a> and <a href="https://containerd.io/">containerd</a>, pulls container images from registries (e.g., Docker Hub), manages them on disk, and launches a lower-level runtime to run container processes.
From this chapter, you can check out specific tutorials for CRI-O and containerd.</p>
<ul>
<li><a href="use_cases/kubernetes/cri/crio.html">CRI-O</a></li>
<li><a href="use_cases/kubernetes/cri/containerd.html">containerd</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cri-o"><a class="header" href="#cri-o">CRI-O</a></h1>
<p>This docs has moved to <a href="https://wasmedge.org/docs/develop/deploy/cri-runtime/cri-o-crun">https://wasmedge.org/docs/develop/deploy/cri-runtime/cri-o-crun</a>. Please use our new docs.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="containerd"><a class="header" href="#containerd">containerd</a></h1>
<p>This docs has moved to <a href="https://wasmedge.org/docs/develop/deploy/cri-runtime/containerd-crun">https://wasmedge.org/docs/develop/deploy/cri-runtime/containerd-crun</a>. Please use our new docs.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="kubernetes"><a class="header" href="#kubernetes">Kubernetes</a></h1>
<p>Most high-level container runtimes implement Kubernetes' CRI (Container Runtime Interface) spec so that they can be managed by Kubernetes tools. That means you can use Kubernetes tools to manage the WebAssembly app image in pods and namespaces.
Check out specific instructions for different flavors of Kubernetes setup in this chapter.</p>
<ul>
<li><a href="use_cases/kubernetes/kubernetes/kubernetes-crio.html">Kubernetes + CRI-O</a></li>
<li><a href="use_cases/kubernetes/kubernetes/kubernetes-containerd.html">Kubernetes + containerd</a></li>
<li><a href="use_cases/kubernetes/kubernetes/kind.html">KinD</a></li>
<li><a href="use_cases/kubernetes/kubernetes/kubeedge.html">KubeEdge</a></li>
<li><a href="use_cases/kubernetes/kubernetes/superedge.html">SuperEdge</a></li>
<li><a href="use_cases/kubernetes/kubernetes/openyurt.html">OpenYurt</a></li>
<li><a href="use_cases/kubernetes/kubernetes/knative.html">Knative</a></li>
<li><a href="use_cases/kubernetes/kubernetes/kwasm.html">Kwasm</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="kubernetes--cri-o"><a class="header" href="#kubernetes--cri-o">Kubernetes + CRI-O</a></h1>
<p>This doc has move to <a href="https://wasmedge.org/docs/develop/deploy/kubernetes/kubernetes-cri-o">https://wasmedge.org/docs/develop/deploy/kubernetes/kubernetes-cri-o</a>. Please use our new docs.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="kubernetes--containerd"><a class="header" href="#kubernetes--containerd">Kubernetes + containerd</a></h1>
<blockquote>
<p>This part has been moved to <a href="https://wasmedge.org/docs/develop/deploy/kubernetes/kubernetes-containerd-crun">https://wasmedge.org/docs/develop/deploy/kubernetes/kubernetes-containerd-crun</a>. Please use or new docs</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="kubernetes-in-docker-kind"><a class="header" href="#kubernetes-in-docker-kind">Kubernetes in Docker (KinD)</a></h1>
<blockquote>
<p>This part has been moved to  <a href="https://wasmedge.org/docs/develop/deploy/kubernetes/kind">https://wasmedge.org/docs/develop/deploy/kubernetes/kind</a>. Please use our new docs.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="create-a-crun-demo-for-kubeedge"><a class="header" href="#create-a-crun-demo-for-kubeedge">Create a crun demo for KubeEdge</a></h1>
<p>This docs has moved to <a href="https://wasmedge.org/docs/develop/deploy/kubernetes/kubedge">https://wasmedge.org/docs/develop/deploy/kubernetes/kubedge</a>. Please use our new docs.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="superedge"><a class="header" href="#superedge">SuperEdge</a></h1>
<blockquote>
<p>This part has been moved to  <a href="https://wasmedge.org/docs/develop/deploy/kubernetes/superedge">https://wasmedge.org/docs/develop/deploy/kubernetes/superedge</a>. Please use our new docs.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="openyurt--containerd--crun"><a class="header" href="#openyurt--containerd--crun">OpenYurt + containerd + crun</a></h1>
<p>This part has been moved to <a href="https://wasmedge.org/docs/develop/deploy/kubernetes/openyurt">https://wasmedge.org/docs/develop/deploy/kubernetes/openyurt</a>. Please use our new docs.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="knative"><a class="header" href="#knative">Knative</a></h1>
<blockquote>
<p>This part has been moved to  <a href="https://wasmedge.org/docs/develop/deploy/kubernetes/knative">https://wasmedge.org/docs/develop/deploy/kubernetes/knative</a>. Please use our new docs.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="kwasm"><a class="header" href="#kwasm">Kwasm</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="running-wasmedge-apps-with-the-docker-cli"><a class="header" href="#running-wasmedge-apps-with-the-docker-cli">Running WasmEdge apps with the Docker CLI</a></h1>
<p>The Docker CLI is a very popular developer tool. However, it is not easy to replace Docker's underlying OCI runtime (<code>runc</code>) with the WasmEdge-enabled <code>crun</code>. In this section, we will discuss two ways to run WasmEdge applications in Docker.</p>
<ul>
<li><a href="use_cases/kubernetes/docker/lxc.html">Wrap WasmEdge in a slim Linux container</a></li>
<li><a href="use_cases/kubernetes/docker/containerd.html">Use containerd shim</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="use-the-slim-linux-container"><a class="header" href="#use-the-slim-linux-container">Use the slim Linux container</a></h1>
<blockquote>
<p>This part has been moved to  <a href="https://wasmedge.org/docs/develop/deploy/using-wasmedge-in-docker">https://wasmedge.org/docs/develop/deploy/using-wasmedge-in-docker</a>. Please use our new docs.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="use-the-containerd-shim"><a class="header" href="#use-the-containerd-shim">Use the containerd shim</a></h1>
<p>As we discussed, wrapping WebAssembly inside a Docker Linux container results in performance and security penalties. However, we cannot easily replace the OCI runtime (<code>runc</code>) in the Docker toolchain as well. In this chapter, we will discuss another approach to start and run WebAssembly bytecode applications directly from the Docker CLI.</p>
<p>Coming soon</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="app-frameworks-and-platforms"><a class="header" href="#app-frameworks-and-platforms">App Frameworks and Platforms</a></h1>
<p>WasmEdge applications can be plugged into existing application frameworks or platforms. WasmEdge provides a safe and efficient extension mechanism for those frameworks.</p>
<p>In this chapter, we will introduce several such frameworks and platforms.</p>
<ul>
<li><a href="use_cases/frameworks/mesh.html">Service mesh and frameworks</a> support WasmEdge to run as containers for microservices. We will cover distributed application framework <a href="use_cases/frameworks/mesh/dapr.html">Dapr</a>, service mesh <a href="use_cases/frameworks/mesh/mosn.html">MOSN</a>, and event mesh <a href="use_cases/frameworks/mesh/eventmesh.html">Apache EventMesh</a>.</li>
<li><a href="use_cases/frameworks/app.html">Application frameworks</a> support WasmEdge as an embedded function or plug-in runtime. We will cover streaming data framework <a href="use_cases/frameworks/app/yomo.html">YoMo</a> and Go function schedulder / framework <a href="use_cases/frameworks/app/reactr.html">Reactr</a>.</li>
<li><a href="use_cases/frameworks/serverless.html">Serverless platforms</a> allows WasmEdge programs to run as serverless functions in their infrastructure. We will cover <a href="use_cases/frameworks/serverless/aws.html">AWS Lambda</a>, <a href="use_cases/frameworks/serverless/tencent.html">Tencent Serverless Cloud Functions</a>, <a href="use_cases/frameworks/serverless/vercel.html">Vercel Serverless Functions</a>, <a href="use_cases/frameworks/serverless/netlify.html">Netlify Functions</a>, and <a href="use_cases/frameworks/serverless/secondstate.html">Second State Functions</a>.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="service-mesh-and-distributed-runtimes"><a class="header" href="#service-mesh-and-distributed-runtimes">Service mesh and distributed runtimes</a></h1>
<blockquote>
<p>This part has been moved to <a href="https://wasmedge.org/docs/category/use-cases">https://wasmedge.org/docs/category/use-cases</a>. Please use our new docs.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="dapr"><a class="header" href="#dapr">Dapr</a></h1>
<p>In this article, I will demonstrate how to use WasmEdge as a sidecar application runtime for Dapr. There are two ways to do this:</p>
<ul>
<li><strong>Standalone WasmEdge</strong> is the <strong>recommended approach</strong> is to write a microservice using <a href="use_cases/frameworks/mesh/../../../write_wasm/rust/networking-nonblocking.html">Rust</a> or <a href="use_cases/frameworks/mesh/../../../write_wasm/js/networking.html">JavaScript</a>, and run it in WasmEdge. The WasmEdge application serves web requests and communicates with the sidecar via sockets using the Dapr API. In this case, we can <a href="use_cases/frameworks/mesh/../../kubernetes/quickstart.html">run WasmEdge as a managed container in k8s</a>.</li>
<li>Alternatively, Embedded WasmEdge is to create a simple microservice in Rust or Go to listen for web requests and communicate with the Dapr sidecar. It passes the request data to a WasmEdge runtime for processing. The business logic of the microservice is a WebAssembly function created and deployed by an application developer.</li>
</ul>
<blockquote>
<p>While the first approach (running the entire microservice in WasmEdge) is much preferred, we are still working on a fully fledged Dapr SDKs for WasmEdge. You can track their progress in GitHub issues -- <a href="https://github.com/WasmEdge/WasmEdge/issues/1571">Rust</a> and <a href="https://github.com/WasmEdge/WasmEdge/issues/1572">JavaScript</a>.</p>
</blockquote>
<h2 id="quick-start-2"><a class="header" href="#quick-start-2">Quick start</a></h2>
<p>First you need to install <a href="https://docs.dapr.io/getting-started/install-dapr-cli">Dapr</a> and <a href="use_cases/frameworks/mesh/../../../quick_start/install.html">WasmEdge</a>. <a href="https://golang.org/doc/install">Go</a> and <a href="https://www.rust-lang.org/tools/install">Rust</a> are optional for the standalone WasmEdge approach. However, they are required for the demo app since it showcases both standalone and embedded WasmEdge approaches.</p>
<p>Fork or clone the demo application from Github. You can use this repo as your own application template.</p>
<pre><code class="language-bash">git clone https://github.com/second-state/dapr-wasm
</code></pre>
<p>The demo has 4 Dapr sidecar applications. The <a href="https://github.com/second-state/dapr-wasm/tree/main/web-port">web-port</a> project provides a public web service for a static HTML page. This is the application’s UI. From the static HTML page, the user can select a microservice to turn an input image into grayscale. All 3 microsoervices below perform the same function. They are just implemented using different approaches.</p>
<ul>
<li><strong>Standalone WasmEdge approach:</strong> The <a href="https://github.com/second-state/dapr-wasm/tree/main/image-api-wasi-socket-rs">image-api-wasi-socket-rs</a> project provides a standalone WasmEdge sidecar microservice that takes the input image and returns the grayscale image. The microservice is written in Rust and compiled into WebAssembly bytecode to run in WasmEdge.</li>
<li>Embedded WasmEdge approach #1: The <a href="https://github.com/second-state/dapr-wasm/tree/main/image-api-rs">image-api-rs</a> project provides a simple Rust-based microservice. It embeds a <a href="https://github.com/second-state/dapr-wasm/tree/main/functions/grayscale">WasmEdge function</a> to turn an input image into a grayscale image.</li>
<li>Embedded WasmEdge approach #2: The <a href="https://github.com/second-state/dapr-wasm/tree/main/image-api-go">image-api-go</a> project provides a simple Go-based microservice. It embeds a <a href="https://github.com/second-state/dapr-wasm/tree/main/functions/grayscale">WasmEdge function</a> to turn an input image into a grayscale image.</li>
</ul>
<p>You can follow the instructions in the <a href="https://github.com/second-state/dapr-wasm/blob/main/README.md">README</a> to start the sidecar services. Here are commands to build the WebAssembly functions and start the sidecar services. The first set of commands deploy the static web page service and the standalone WasmEdge service written in Rust. It forms a complete application to turn an input image into grayscale.</p>
<pre><code class="language-bash"># Build and start the static HTML web page service for the UI and router for sending the uploaded image to the grayscale microservice
cd web-port
go build
./run_web.sh
cd ../

# Build the standalone image grayscale web service for WasmEdge
cd image-api-wasi-socket-rs
cargo build  --target wasm32-wasi
cd ../

# Run the microservice as a Dapr sidecar app
cd image-api-wasi-socket-rs
./run_api_wasi_socket_rs.sh
cd ../
</code></pre>
<p>The second set of commands create the alternative microservices for the embedded WasmEdge function.</p>
<pre><code class="language-bash"># Build the grayscale WebAssembly functions, and deploy them to the sidecar projects
cd functions/grayscale
./build.sh
cd ../../

# Build and start the Rust-based microservice for embedding the grayscale WasmEdge function
cd image-api-rs
cargo build --release
./run_api_rs.sh
cd ../

# Build and start the Go-based microservice for embedding the grayscale WasmEdge function
cd image-api-go
go build
./run_api_go.sh
cd ../
</code></pre>
<p>Finally, you should be able to see the web UI in your browser.</p>
<h2 id="recommended-the-standalone-wasmedge-microservice-in-rust"><a class="header" href="#recommended-the-standalone-wasmedge-microservice-in-rust">Recommended: The standalone WasmEdge microservice in Rust</a></h2>
<p>The <a href="https://github.com/second-state/dapr-wasm/blob/main/image-api-wasi-socket-rs/src/main.rs">standalone WasmEdge microservice</a> starts a non-blocking TCP server inside WasmEdge. The TCP server passes incoming requests to <code>handle_client()</code>, which passes HTTP requests to <code>handle_http()</code>, which calls <code>grayscale()</code> to process the image data in the request.</p>
<pre><pre class="playground"><code class="language-rust">fn main() -&gt; std::io::Result&lt;()&gt; {
    let port = std::env::var(&quot;PORT&quot;).unwrap_or(9005.to_string());
    println!(&quot;new connection at {}&quot;, port);
    let listener = TcpListener::bind(format!(&quot;127.0.0.1:{}&quot;, port))?;
    loop {
        let _ = handle_client(listener.accept()?.0);
    }
}

fn handle_client(mut stream: TcpStream) -&gt; std::io::Result&lt;()&gt; {
  ... ...
}

fn handle_http(req: Request&lt;Vec&lt;u8&gt;&gt;) -&gt; bytecodec::Result&lt;Response&lt;String&gt;&gt; {
  ... ...
}

fn grayscale(image: &amp;[u8]) -&gt; Vec&lt;u8&gt; {
    let detected = image::guess_format(&amp;image);
    let mut buf = vec![];
    if detected.is_err() {
        return buf;
    }
    
    let image_format_detected = detected.unwrap();
    let img = image::load_from_memory(&amp;image).unwrap();
    let filtered = img.grayscale();
    match image_format_detected {
        ImageFormat::Gif =&gt; {
            filtered.write_to(&amp;mut buf, ImageOutputFormat::Gif).unwrap();
        }
        _ =&gt; {
            filtered.write_to(&amp;mut buf, ImageOutputFormat::Png).unwrap();
        }
    };
    return buf;
}</code></pre></pre>
<blockquote>
<p>Work in progress: It will soon interact with the Dapr sidecar through the <a href="https://github.com/WasmEdge/WasmEdge/issues/1571">WasmEdge Dapr SDK in Rust</a>.</p>
</blockquote>
<p>Now, you can build the microservice. It is a simple matter of compiling from Rust to WebAssembly.</p>
<pre><code class="language-bash">cd image-api-wasi-socket-rs
cargo build  --target wasm32-wasi
</code></pre>
<p>Deploy the WasmEdge microservice in Dapr as follows.</p>
<pre><code class="language-bash">dapr run --app-id image-api-wasi-socket-rs \
         --app-protocol http \
         --app-port 9005 \
         --dapr-http-port 3503 \
         --components-path ../config \
         --log-level debug \
         wasmedge ./target/wasm32-wasi/debug/image-api-wasi-socket-rs.wasm
</code></pre>
<h2 id="alternative-the-embedded-wasmedge-microservices"><a class="header" href="#alternative-the-embedded-wasmedge-microservices">Alternative: The embedded WasmEdge microservices</a></h2>
<p>The embedded WasmEdge approach requires us to create a WebAssembly function for the business logic (image processing) first, and then embed it into simple Dapr microservices.</p>
<h3 id="rust-function-for-image-processing"><a class="header" href="#rust-function-for-image-processing">Rust function for image processing</a></h3>
<p>The <a href="https://github.com/second-state/dapr-wasm/blob/main/functions/grayscale/src/lib.rs">Rust function</a> is simple. It uses the <a href="use_cases/frameworks/mesh/../../../write_wasm/rust/bindgen.html">wasmedge_bindgen</a> macro to makes it easy to call the function from a Go or Rust host embedding the WebAssembly function. It takes and returns base64 encoded image data for the web.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[wasmedge_bindgen]
pub fn grayscale(image_data: String) -&gt; String {
    let image_bytes = image_data.split(&quot;,&quot;).map(|x| x.parse::&lt;u8&gt;().unwrap()).collect::&lt;Vec&lt;u8&gt;&gt;();
    return grayscale::grayscale_internal(&amp;image_bytes);
}
<span class="boring">}</span></code></pre></pre>
<p>The Rust function that actually performs the task is as follows.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn grayscale_internal(image_data: &amp;[u8]) -&gt; String {
    let image_format_detected: ImageFormat = image::guess_format(&amp;image_data).unwrap();
    let img = image::load_from_memory(&amp;image_data).unwrap();
    let filtered = img.grayscale();
    let mut buf = vec![];
    match image_format_detected {
        ImageFormat::Gif =&gt; {
            filtered.write_to(&amp;mut buf, ImageOutputFormat::Gif).unwrap();
        }
        _ =&gt; {
            filtered.write_to(&amp;mut buf, ImageOutputFormat::Png).unwrap();
        }
    };
    let mut base64_encoded = String::new();
    base64::encode_config_buf(&amp;buf, base64::STANDARD, &amp;mut base64_encoded);
    return base64_encoded.to_string();
}
<span class="boring">}</span></code></pre></pre>
<h3 id="the-go-host-wrapper-for-microservice"><a class="header" href="#the-go-host-wrapper-for-microservice">The Go host wrapper for microservice</a></h3>
<p>The <a href="https://github.com/second-state/dapr-wasm/tree/main/image-api-go">Go-based microservice</a> embeds the above imaging processing function in WasmEdge. The <a href="https://github.com/second-state/dapr-wasm/blob/main/image-api-go/image_api.go">microservice itself</a> is a web server and utilizes the Dapr Go SDK.</p>
<pre><code class="language-go">func main() {
  s := daprd.NewService(&quot;:9003&quot;)

  if err := s.AddServiceInvocationHandler(&quot;/api/image&quot;, imageHandlerWASI); err != nil {
    log.Fatalf(&quot;error adding invocation handler: %v&quot;, err)
  }

  if err := s.Start(); err != nil &amp;&amp; err != http.ErrServerClosed {
    log.Fatalf(&quot;error listening: %v&quot;, err)
  }
}
</code></pre>
<p>The <code>imageHandlerWASI()</code> function <a href="use_cases/frameworks/mesh/../../../sdk/go/function.html">starts a WasmEdge instance</a> and calls the image processing (grayscale) function in it via <a href="use_cases/frameworks/mesh/../../../write_wasm/rust/bindgen.html">wasmedge_bindgen</a>.</p>
<p>Build and deploy the Go microservice to Dapr as follows.</p>
<pre><code class="language-bash">cd image-api-go
go build
dapr run --app-id image-api-go \
         --app-protocol http \
         --app-port 9003 \
         --dapr-http-port 3501 \
         --log-level debug \
         --components-path ../config \
         ./image-api-go
</code></pre>
<h3 id="the-rust-host-wrapper-for-microservice"><a class="header" href="#the-rust-host-wrapper-for-microservice">The Rust host wrapper for microservice</a></h3>
<p>The <a href="https://github.com/second-state/dapr-wasm/tree/main/image-api-rs">Rust-based microservice</a> embeds the above imaging processing function in WasmEdge. The <a href="https://github.com/second-state/dapr-wasm/blob/main/image-api-rs/src/main.rs">microservice itself</a> is a Tokio and Warp based web server.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[tokio::main]
pub async fn run_server(port: u16) {
    pretty_env_logger::init();
    let home = warp::get().map(warp::reply);

    let image = warp::post()
        .and(warp::path(&quot;api&quot;))
        .and(warp::path(&quot;image&quot;))
        .and(warp::body::bytes())
        .map(|bytes: bytes::Bytes| {
            let v: Vec&lt;u8&gt; = bytes.iter().map(|&amp;x| x).collect();
            let res = image_process_wasmedge_sys(&amp;v);
            let _encoded = base64::encode(&amp;res);
            Response::builder()
                .header(&quot;content-type&quot;, &quot;image/png&quot;)
                .body(res)
        });

    let routes = home.or(image);
    let routes = routes.with(warp::cors().allow_any_origin());

    let log = warp::log(&quot;dapr_wasm&quot;);
    let routes = routes.with(log);
    warp::serve(routes).run((Ipv4Addr::UNSPECIFIED, port)).await
}
<span class="boring">}</span></code></pre></pre>
<p>The <code>image_process_wasmedge_sys()</code> function <a href="use_cases/frameworks/mesh/../../../sdk/rust/sys_run_host_func.html">starts a WasmEdge instance</a> and calls the image processing (grayscale) function in it via <a href="use_cases/frameworks/mesh/../../../write_wasm/rust/bindgen.html">wasmedge_bindgen</a>.</p>
<p>Build and deploy the Rust microservice to Dapr as follows.</p>
<pre><code class="language-bash">cd image-api-rs
cargo build --release
dapr stop image-api-rs

# Change this to your own path for WasmEdge
export LD_LIBRARY_PATH=/home/coder/.wasmedge/lib64/

dapr run --app-id image-api-rs \
         --app-protocol http \
         --app-port 9004 \
         --dapr-http-port 3502 \
         --components-path ../config \
         --log-level debug \
         ./target/release/image-api-rs
</code></pre>
<p>That's it! <a href="https://github.com/WasmEdge/WasmEdge/discussions">Let us know</a> your cool Dapr microservices in WebAssembly!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mosn"><a class="header" href="#mosn">MOSN</a></h1>
<p>Coming soon.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="wasm-nginx-module"><a class="header" href="#wasm-nginx-module">wasm-nginx-module</a></h1>
<blockquote>
<p>This part has been moved to <a href="https://wasmedge.org/docs/embed/use-case/wasm-nginx">https://wasmedge.org/docs/embed/use-case/wasm-nginx</a>. Please use our new docs.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="apache-eventmesh"><a class="header" href="#apache-eventmesh">Apache EventMesh</a></h1>
<p>Coming soon, or you can <a href="https://github.com/WasmEdge/WasmEdge/issues/632">help out</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="app-frameworks"><a class="header" href="#app-frameworks">App frameworks</a></h1>
<blockquote>
<p>This part has been moved to <a href="https://wasmedge.org/docs/category/use-cases">https://wasmedge.org/docs/category/use-cases</a>. Please use our new docs.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="yomo"><a class="header" href="#yomo">YoMo</a></h1>
<p><a href="https://yomo.run/">YoMo</a> is a programming framework enabling developers to build a distributed cloud system (Geo-Distributed Cloud System). YoMo's communication layer is made on top of the QUIC protocol, which brings high-speed data transmission. In addition, it has a built-in Streaming Serverless &quot;streaming function&quot;, which significantly improves the development experience of distributed cloud systems. The distributed cloud system built by YoMo provides an ultra-high-speed communication mechanism between near-field computing power and terminals. It has a wide range of use cases in Metaverse, VR/AR, IoT, etc.</p>
<blockquote>
<p>YoMo is written in the Go language. For streaming Serverless, Golang plugins and shared libraries are used to load users' code dynamically, which also have certain limitations for developers. Coupled with Serverless architecture's rigid demand for isolation, this makes WebAssembly an excellent choice for running user-defined functions.</p>
</blockquote>
<p>For example, in the process of real-time AI inference in AR/VR devices or smart factories, the camera sends real-time unstructured data to the computing node in the near-field MEC (multi-access edge computing) device through YoMo.  YoMo sends the AI computing result to the end device in real-time when the AI inference is completed. Thus, the hosted AI inference function will be automatically executed.</p>
<p>However, a challenge for YoMo is to incorporate and manage handler functions written by multiple outside developers in an edge computing node. It requires runtime isolation for those functions without sacrificing performance. Traditional software container solutions, such as Docker, are not up to the task. They are too heavy and slow to handle real-time tasks.</p>
<p>WebAssembly provides a lightweight and high-performance software container. It is ideally suited as a runtime for YoMo’s data processing handler functions.</p>
<p>In this article, we will show you how to create a Rust function for Tensorflow-based image classification, compile it into WebAssembly, and then use YoMo to run it as a stream data handler. We use <a href="https://wasmedge.org/">WasmEdge</a> as our WebAssembly runtime because it offers the highest performance and flexibility compared with other WebAssembly runtimes. It is the only WebAssembly VM that reliably supports Tensorflow. YoMo manages WasmEdge VM instances and the contained WebAssembly bytecode apps through <a href="use_cases/frameworks/app/../../../sdk/go.html">WasmEdge’s Golang API</a>.</p>
<blockquote>
<p>Source code: <a href="https://github.com/yomorun/yomo-wasmedge-tensorflow">https://github.com/yomorun/yomo-wasmedge-tensorflow</a></p>
</blockquote>
<p>Checkout <a href="https://www.youtube.com/watch?v=E0ltsn6cLIU">the WasmEdge image classification function in action in YoMo</a></p>
<h2 id="prerequisite"><a class="header" href="#prerequisite">Prerequisite</a></h2>
<p>Obviously, you will need to have <a href="https://golang.org/doc/install">Golang installed</a>, but I will assume you already did.</p>
<blockquote>
<p>Golang version should be newer than 1.15 for our example to work.</p>
</blockquote>
<p>You also need to install the YoMo CLI application. It orchestrates and coordinates data streaming and handler function invocations.</p>
<pre><code class="language-bash">$ go install github.com/yomorun/cli/yomo@latest
$ yomo version
YoMo CLI version: v0.1.3
</code></pre>
<p>Next, please install the WasmEdge and its Tensorflow shared libraries. <a href="https://wasmedge.org/">WasmEdge</a> is a leading WebAssembly runtime hosted by the CNCF. We will use it to embed and run WebAssembly programs from YoMo.</p>
<pre><code class="language-bash">curl -sSf https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/utils/install.sh | bash
</code></pre>
<p>Finally, since our demo WebAssembly functions are written in Rust, you will also need a <a href="https://www.rust-lang.org/tools/install">Rust compiler</a>.</p>
<p>For the rest of the demo, fork and clone the <a href="https://github.com/yomorun/yomo-wasmedge-tensorflow">source code repository</a>.</p>
<pre><code class="language-bash">git clone https://github.com/yomorun/yomo-wasmedge-tensorflow.git
</code></pre>
<h2 id="the-image-classification-function"><a class="header" href="#the-image-classification-function">The image classification function</a></h2>
<p>The <a href="https://github.com/yomorun/yomo-wasmedge-tensorflow/tree/main/flow/rust_mobilenet_food">image classification function</a> to process the YoMo image stream is written in Rust. It utilizes the WasmEdge Tensorflow API to process an input image.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[wasmedge_bindgen]
pub fn infer(image_data: Vec&lt;u8&gt;) -&gt; Result&lt;Vec&lt;u8&gt;, String&gt; {
  let start = Instant::now();

  // Load the TFLite model and its meta data (the text label for each recognized object number)
  let model_data: &amp;[u8] = include_bytes!(&quot;lite-model_aiy_vision_classifier_food_V1_1.tflite&quot;);
  let labels = include_str!(&quot;aiy_food_V1_labelmap.txt&quot;);

  // Pre-process the image to a format that can be used by this model
  let flat_img = wasmedge_tensorflow_interface::load_jpg_image_to_rgb8(&amp;image_data[..], 192, 192);
  println!(&quot;RUST: Loaded image in ... {:?}&quot;, start.elapsed());

  // Run the TFLite model using the WasmEdge Tensorflow API
  let mut session = wasmedge_tensorflow_interface::Session::new(&amp;model_data, wasmedge_tensorflow_interface::ModelType::TensorFlowLite);
  session.add_input(&quot;input&quot;, &amp;flat_img, &amp;[1, 192, 192, 3])
         .run();
  let res_vec: Vec&lt;u8&gt; = session.get_output(&quot;MobilenetV1/Predictions/Softmax&quot;);

  // Find the object index in res_vec that has the greatest probability
  // Translate the probability into a confidence level
  // Translate the object index into a label from the model meta data food_name
  let mut i = 0;
  let mut max_index: i32 = -1;
  let mut max_value: u8 = 0;
  while i &lt; res_vec.len() {
    let cur = res_vec[i];
    if cur &gt; max_value {
      max_value = cur;
      max_index = i as i32;
    }
    i += 1;
  }
  println!(&quot;RUST: index {}, prob {}&quot;, max_index, max_value);

  let confidence: String;
  if max_value &gt; 200 {
    confidence = &quot;is very likely&quot;.to_string();
  } else if max_value &gt; 125 {
    confidence = &quot;is likely&quot;.to_string();
  } else {
    confidence = &quot;could be&quot;.to_string();
  }

  let ret_str: String;
  if max_value &gt; 50 {
    let mut label_lines = labels.lines();
    for _i in 0..max_index {
      label_lines.next();
    }
    let food_name = label_lines.next().unwrap().to_string();
    ret_str = format!(
      &quot;It {} a &lt;a href='https://www.google.com/search?q={}'&gt;{}&lt;/a&gt; in the picture&quot;,
      confidence, food_name, food_name
    );
  } else {
    ret_str = &quot;It does not appears to be a food item in the picture.&quot;.to_string();
  }

  println!(
    &quot;RUST: Finished post-processing in ... {:?}&quot;,
    start.elapsed()
  );
  return Ok(ret_str.as_bytes().to_vec());
}
<span class="boring">}</span></code></pre></pre>
<p>You should add <code>wasm32-wasi</code> target to rust to compile this function into WebAssembly bytecode.</p>
<pre><code class="language-bash">rustup target add wasm32-wasi

cd flow/rust_mobilenet_food
cargo build --target wasm32-wasi --release
# The output WASM will be target/wasm32-wasi/release/rust_mobilenet_food_lib.wasm

# Copy the wasm bytecode file to the flow/ directory
cp target/wasm32-wasi/release/rust_mobilenet_food_lib.wasm ../
</code></pre>
<p>To release the best performance of WasmEdge, you should enable the AOT mode by compiling the <code>.wasm</code> file to the <code>.so</code>.</p>
<pre><code class="language-bash">wasmedge compile rust_mobilenet_food_lib.wasm rust_mobilenet_food_lib.so
</code></pre>
<h2 id="integration-with-yomo"><a class="header" href="#integration-with-yomo">Integration with YoMo</a></h2>
<p>On the YoMo side, we use the WasmEdge Golang API to start and run WasmEdge VM for the image classification function. The <a href="https://github.com/yomorun/yomo-wasmedge-tensorflow/blob/main/flow/app.go">app.go</a> file in the source code project is as follows.</p>
<pre><code class="language-go">package main

import (
  &quot;crypto/sha1&quot;
  &quot;fmt&quot;
  &quot;log&quot;
  &quot;os&quot;
  &quot;sync/atomic&quot;

  &quot;github.com/second-state/WasmEdge-go/wasmedge&quot;
  bindgen &quot;github.com/second-state/wasmedge-bindgen/host/go&quot;
  &quot;github.com/yomorun/yomo&quot;
)

var (
  counter uint64
)

const ImageDataKey = 0x10

func main() {
  // Connect to Zipper service
  sfn := yomo.NewStreamFunction(&quot;image-recognition&quot;, yomo.WithZipperAddr(&quot;localhost:9900&quot;))
  defer sfn.Close()

  // set only monitoring data
  sfn.SetObserveDataID(ImageDataKey)

  // set handler
  sfn.SetHandler(Handler)

  // start
  err := sfn.Connect()
  if err != nil {
    log.Print(&quot;❌ Connect to zipper failure: &quot;, err)
    os.Exit(1)
  }

  select {}
}

// Handler process the data in the stream
func Handler(img []byte) (byte, []byte) {
  // Initialize WasmEdge's VM
  vmConf, vm := initVM()
  bg := bindgen.Instantiate(vm)
  defer bg.Release()
  defer vm.Release()
  defer vmConf.Release()

  // recognize the image
  res, err := bg.Execute(&quot;infer&quot;, img)
  if err == nil {
    fmt.Println(&quot;GO: Run bindgen -- infer:&quot;, string(res))
  } else {
    fmt.Println(&quot;GO: Run bindgen -- infer FAILED&quot;)
  }

  // print logs
  hash := genSha1(img)
  log.Printf(&quot;✅ received image-%d hash %v, img_size=%d \n&quot;, atomic.AddUint64(&amp;counter, 1), hash, len(img))

  return 0x11, nil
}

// genSha1 generate the hash value of the image
func genSha1(buf []byte) string {
  h := sha1.New()
  h.Write(buf)
  return fmt.Sprintf(&quot;%x&quot;, h.Sum(nil))
}

// initVM initialize WasmEdge's VM
func initVM() (*wasmedge.Configure, *wasmedge.VM) {
  wasmedge.SetLogErrorLevel()
  // Set Tensorflow not to print debug info
  os.Setenv(&quot;TF_CPP_MIN_LOG_LEVEL&quot;, &quot;3&quot;)
  os.Setenv(&quot;TF_CPP_MIN_VLOG_LEVEL&quot;, &quot;3&quot;)

  // Create configure
  vmConf := wasmedge.NewConfigure(wasmedge.WASI)

  // Create VM with configure
  vm := wasmedge.NewVMWithConfig(vmConf)

  // Init WASI
  var wasi = vm.GetImportObject(wasmedge.WASI)
  wasi.InitWasi(
    os.Args[1:],     // The args
    os.Environ(),    // The envs
    []string{&quot;.:.&quot;}, // The mapping directories
  )

  // Register WasmEdge-tensorflow and WasmEdge-image
  var tfobj = wasmedge.NewTensorflowImportObject()
  var tfliteobj = wasmedge.NewTensorflowLiteImportObject()
  vm.RegisterImport(tfobj)
  vm.RegisterImport(tfliteobj)
  var imgobj = wasmedge.NewImageImportObject()
  vm.RegisterImport(imgobj)

  // Instantiate wasm
  vm.LoadWasmFile(&quot;rust_mobilenet_food_lib.so&quot;)
  vm.Validate()

  return vmConf, vm
}
</code></pre>
<h2 id="in-action"><a class="header" href="#in-action">In action</a></h2>
<p>Finally, we can start YoMo and see the entire data processing pipeline in action. Start the YoMo CLI application from the project folder. The <a href="https://github.com/yomorun/yomo-wasmedge-tensorflow/blob/main/zipper/workflow.yaml">yaml file</a> defines port YoMo should listen on and the workflow handler to trigger for incoming data.  Note that the flow name <code>image-recognition</code> matches the name in the aforementioned data handler <a href="https://github.com/yomorun/yomo-wasmedge-tensorflow/blob/main/flow/app.go">app.go</a>.</p>
<pre><code class="language-bash">yomo serve -c ./zipper/workflow.yaml
</code></pre>
<p>Start the handler function by running the aforementioned <a href="https://github.com/yomorun/yomo-wasmedge-tensorflow/blob/main/flow/app.go">app.go</a> program.</p>
<pre><code class="language-bash">cd flow
go run --tags &quot;tensorflow image&quot; app.go
</code></pre>
<p><a href="https://github.com/yomorun/yomo-wasmedge-tensorflow/blob/main/source/main.go">Start a simulated data source</a> by sending a video to YoMo. The video is a series of image frames. The WasmEdge function in <a href="https://github.com/yomorun/yomo-wasmedge-tensorflow/blob/main/flow/app.go">app.go</a> will be invoked against every image frame in the video.</p>
<pre><code class="language-bash"># Download a video file
wget -P source 'https://github.com/yomorun/yomo-wasmedge-tensorflow/releases/download/v0.1.0/hot-dog.mp4'

# Stream the video to YoMo
go run ./source/main.go ./source/hot-dog.mp4
</code></pre>
<p>You can see the output from the WasmEdge handler function in the console. It prints the names of the objects detected in each image frame in the video.</p>
<h2 id="whats-next"><a class="header" href="#whats-next">What's next</a></h2>
<p>In this article, we have seen how to use the WasmEdge Tensorflow API and Golang SDK in YoMo framework to process an image stream in near real-time.</p>
<p>In collaboration with YoMo, we will soon deploy WasmEdge in production in smart factories for a variety of assembly line tasks. WasmEdge is the software runtime for edge computing!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="reactr"><a class="header" href="#reactr">Reactr</a></h1>
<p><a href="https://github.com/suborbital/reactr">Reactr</a> is a fast, performant function scheduling library written in Go. Reactr is designed to be flexible, with the ability to run embedded in your Go applications and first-class support for WebAssembly.
Taking advantage of Go's superior concurrency capabilities, Reactr can manage and execute hundreds of WebAssembly runtime instances all at once, making a great framework for server-side applications.</p>
<p>Reactr allows you to run WebAssembly functions in Go, so does the <a href="use_cases/frameworks/app/../../../sdk/go.html">WasmEdge Go SDK</a>.
The unique feature of Reactr is that it provides a rich set of host functions in Go, which support access to networks and databases etc. Reactr then provides Rust (and Swift / AssemblyScript) APIs to call those host functions from within the WebAssembly function.</p>
<p>In this article, we will show you how to use WasmEdge together with Reactr to take advantage of the best of both worlds. WasmEdge is the <a href="use_cases/frameworks/app/../../../features.html">fastest and most extensible WebAssembly runtime</a>.
It is also the fastest in <a href="https://github.com/suborbital/reactr/runs/4476074960?check_suite_focus=true">Reactr's official test suite</a>.
We will show you how to run Rust functions compiled to WebAssembly as well as JavaScript programs in WasmEdge and Reactr.</p>
<blockquote>
<p>WasmEdge provides <a href="use_cases/frameworks/app/../../../write_wasm/js.html">advanced support for JavaScript</a> including <a href="use_cases/frameworks/app/../../../write_wasm/js/rust.html">mixing Rust with JavaScript</a> for improved performance.</p>
</blockquote>
<ul>
<li><a href="use_cases/frameworks/app/reactr.html#hello-world">Hello world</a></li>
<li><a href="use_cases/frameworks/app/reactr.html#database-query">Database query</a></li>
<li><a href="use_cases/frameworks/app/reactr.html#embed-javascript-in-go">Embed JavaScript in Go</a></li>
</ul>
<h2 id="prerequisites-1"><a class="header" href="#prerequisites-1">Prerequisites</a></h2>
<p>You need have <a href="https://www.rust-lang.org/tools/install">Rust</a>, <a href="https://go.dev/doc/install">Go</a>, and <a href="use_cases/frameworks/app/../../../quick_start/install.html">WasmEdge</a> installed on your system.
The GCC compiler (installed via the <code>build-essential</code> package) is also needed for WasmEdge.</p>
<pre><code class="language-bash">sudo apt-get update
sudo apt-get -y upgrade
sudo apt install build-essential

curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh
source $HOME/.cargo/env
rustup target add wasm32-wasi

curl -OL https://golang.org/dl/go1.17.5.linux-amd64.tar.gz
sudo tar -C /usr/local -xvf go1.17.5.linux-amd64.tar.gz
export PATH=$PATH:/usr/local/go/bin

wget -qO- https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/utils/install.sh | bash
source $HOME/.wasmedge/env
</code></pre>
<h2 id="hello-world"><a class="header" href="#hello-world">Hello world</a></h2>
<p>A simple <code>hello world</code> example for Reactr is <a href="https://github.com/second-state/wasm-learning/tree/master/reactr/hello">available here</a>.</p>
<h3 id="hello-world-rust-function-compiled-to-webassembly"><a class="header" href="#hello-world-rust-function-compiled-to-webassembly">Hello world: Rust function compiled to WebAssembly</a></h3>
<p>Let's first create <a href="https://github.com/second-state/wasm-learning/blob/master/reactr/hello/hello-echo/src/lib.rs">a simple Rust function</a> to echo hello.
The Rust function <code>HelloEcho::run()</code> is as follows. It will be exposed to the Go host application through Reactr.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use suborbital::runnable::*;

struct HelloEcho{}

impl Runnable for HelloEcho {
  fn run(&amp;self, input: Vec&lt;u8&gt;) -&gt; Result&lt;Vec&lt;u8&gt;, RunErr&gt; {
    let in_string = String::from_utf8(input).unwrap();
    Ok(format!(&quot;hello {}&quot;, in_string).as_bytes().to_vec())
  }
}
<span class="boring">}</span></code></pre></pre>
<p>Let's build the Rust function into a WebAssembly bytecode file.</p>
<pre><code class="language-bash">cd hello-echo
cargo build --target wasm32-wasi --release
cp target/wasm32-wasi/release/hello_echo.wasm ..
cd ..
</code></pre>
<h3 id="hello-world-go-host-application"><a class="header" href="#hello-world-go-host-application">Hello world: Go host application</a></h3>
<p>Next, lets look into the <a href="https://github.com/second-state/wasm-learning/blob/master/reactr/hello/main.go">Go host app</a> that executes the WebAssembly functions.
The <code>runBundle()</code> function executes the <code>run()</code> function in the <code>Runnable</code> struct once.</p>
<pre><code class="language-go">func runBundle() {
  r := rt.New()
  doWasm := r.Register(&quot;hello-echo&quot;, rwasm.NewRunner(&quot;./hello_echo.wasm&quot;))

  res, err := doWasm([]byte(&quot;wasmWorker!&quot;)).Then()
  if err != nil {
    fmt.Println(err)
    return
  }

  fmt.Println(string(res.([]byte)))
}
</code></pre>
<p>The <code>runGroup()</code> function executes the Rust-compiled WebAssembly <code>run()</code> function multiple times asynchronously in a group, and receives the results as they come in.</p>
<pre><code class="language-go">func runGroup() {
  r := rt.New()

  doWasm := r.Register(&quot;hello-echo&quot;, rwasm.NewRunner(&quot;./hello_echo.wasm&quot;))

  grp := rt.NewGroup()
  for i := 0; i &lt; 100000; i++ {
    grp.Add(doWasm([]byte(fmt.Sprintf(&quot;world %d&quot;, i))))
  }

  if err := grp.Wait(); err != nil {
    fmt.Println(err)
  }
}
</code></pre>
<p>Finally, let's run the Go host application and see the results printed to the console.</p>
<blockquote>
<p>You must use the <code>-tags wasmedge</code> flag to take advantage of the performance and extended WebAssembly APIs provided by WasmEdge.</p>
</blockquote>
<pre><code class="language-bash">go mod tidy
go run -tags wasmedge main.go
</code></pre>
<h2 id="database-query"><a class="header" href="#database-query">Database query</a></h2>
<p>In <a href="https://github.com/second-state/wasm-learning/tree/master/reactr/db">this example</a>, we will demonstrate how to use Reactr host functions and APIs to query a PostgreSQL database from your WebAssembly function.</p>
<h3 id="database-query-install-and-set-up-a-postgresql-database"><a class="header" href="#database-query-install-and-set-up-a-postgresql-database">Database query: Install and set up a PostgreSQL database</a></h3>
<p>We will start a PostgreSQL instance through Docker.</p>
<pre><code class="language-bash">docker pull postgres
docker run --name reactr-postgres -p 5432:5432 -e POSTGRES_PASSWORD=12345 -d postgres
</code></pre>
<p>Next, let's create a database and populate it with some sample data.</p>
<pre><code class="language-bash">$ docker run -it --rm --network host postgres psql -h 127.0.0.1 -U postgres
postgres=# CREATE DATABASE reactr;
postgres=# \c reactr;

# Create a table:
postgres=# CREATE TABLE users (
    uuid        varchar(100) CONSTRAINT firstkey PRIMARY KEY,
    email       varchar(50) NOT NULL,
    created_at  date,
    state       char(1),
    identifier  integer
);
</code></pre>
<p>Leave this running and start another terminal window to interact with this PostgreSQL server.</p>
<h3 id="database-query-rust-function-compiled-to-webassembly"><a class="header" href="#database-query-rust-function-compiled-to-webassembly">Database query: Rust function compiled to WebAssembly</a></h3>
<p>Let's create <a href="https://github.com/second-state/wasm-learning/blob/master/reactr/db/rs-db/src/lib.rs">a Rust function</a> to access the PostgreSQL database.
The Rust function <code>RsDbtest::run()</code> is as follows. It will be exposed to the Go host application through Reactr. It uses named queries such as <code>PGInsertUser</code> and <code>PGSelectUserWithUUID</code> to operate the database. Those queries are defined in the Go host application, and we will see them later.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use suborbital::runnable::*;
use suborbital::db;
use suborbital::util;
use suborbital::db::query;
use suborbital::log;
use uuid::Uuid;

struct RsDbtest{}

impl Runnable for RsDbtest {
  fn run(&amp;self, _: Vec&lt;u8&gt;) -&gt; Result&lt;Vec&lt;u8&gt;, RunErr&gt; {
    let uuid = Uuid::new_v4().to_string();

    let mut args: Vec&lt;query::QueryArg&gt; = Vec::new();
    args.push(query::QueryArg::new(&quot;uuid&quot;, uuid.as_str()));
    args.push(query::QueryArg::new(&quot;email&quot;, &quot;connor@suborbital.dev&quot;));

    match db::insert(&quot;PGInsertUser&quot;, args) {
      Ok(_) =&gt; log::info(&quot;insert successful&quot;),
      Err(e) =&gt; {
        return Err(RunErr::new(500, e.message.as_str()))
      }
    };

    let mut args2: Vec&lt;query::QueryArg&gt; = Vec::new();
    args2.push(query::QueryArg::new(&quot;uuid&quot;, uuid.as_str()));

    match db::update(&quot;PGUpdateUserWithUUID&quot;, args2.clone()) {
      Ok(rows) =&gt; log::info(format!(&quot;update: {}&quot;, util::to_string(rows).as_str()).as_str()),
      Err(e) =&gt; {
        return Err(RunErr::new(500, e.message.as_str()))
      }
    }

    match db::select(&quot;PGSelectUserWithUUID&quot;, args2.clone()) {
      Ok(result) =&gt; log::info(format!(&quot;select: {}&quot;, util::to_string(result).as_str()).as_str()),
      Err(e) =&gt; {
        return Err(RunErr::new(500, e.message.as_str()))
      }
    }

    match db::delete(&quot;PGDeleteUserWithUUID&quot;, args2.clone()) {
      Ok(rows) =&gt; log::info(format!(&quot;delete: {}&quot;, util::to_string(rows).as_str()).as_str()),
      Err(e) =&gt; {
        return Err(RunErr::new(500, e.message.as_str()))
      }
    }

    ... ...
  }
}
<span class="boring">}</span></code></pre></pre>
<p>Let's build the Rust function into a WebAssembly bytecode file.</p>
<pre><code class="language-bash">cd rs-db
cargo build --target wasm32-wasi --release
cp target/wasm32-wasi/release/rs_db.wasm ..
cd ..
</code></pre>
<h3 id="database-query-go-host-application"><a class="header" href="#database-query-go-host-application">Database query: Go host application</a></h3>
<p>The <a href="https://github.com/second-state/wasm-learning/blob/master/reactr/db/main.go">Go host app</a> first defines the SQL queries and gives each of them a name.
We will then pass those queries to the Reactr runtime as a configuration.</p>
<pre><code class="language-go">func main() {
  dbConnString, exists := os.LookupEnv(&quot;REACTR_DB_CONN_STRING&quot;)
  if !exists {
    fmt.Println(&quot;skipping as conn string env var not set&quot;)
    return
  }

  q1 := rcap.Query{
    Type:     rcap.QueryTypeInsert,
    Name:     &quot;PGInsertUser&quot;,
    VarCount: 2,
    Query: `
    INSERT INTO users (uuid, email, created_at, state, identifier)
    VALUES ($1, $2, NOW(), 'A', 12345)`,
  }

  q2 := rcap.Query{
    Type:     rcap.QueryTypeSelect,
    Name:     &quot;PGSelectUserWithUUID&quot;,
    VarCount: 1,
    Query: `
    SELECT * FROM users
    WHERE uuid = $1`,
  }

  q3 := rcap.Query{
    Type:     rcap.QueryTypeUpdate,
    Name:     &quot;PGUpdateUserWithUUID&quot;,
    VarCount: 1,
    Query: `
    UPDATE users SET state='B' WHERE uuid = $1`,
  }

  q4 := rcap.Query{
    Type:     rcap.QueryTypeDelete,
    Name:     &quot;PGDeleteUserWithUUID&quot;,
    VarCount: 1,
    Query: `
    DELETE FROM users WHERE uuid = $1`,
  }

  config := rcap.DefaultConfigWithDB(vlog.Default(), rcap.DBTypePostgres, dbConnString, []rcap.Query{q1, q2, q3, q4})

  r, err := rt.NewWithConfig(config)
  if err != nil {
    fmt.Println(err)
    return
  }

  ... ...
}
</code></pre>
<p>Then, we can run the WebAssembly function from Reactr.</p>
<pre><code class="language-go">func main() {
  ... ...

  doWasm := r.Register(&quot;rs-db&quot;, rwasm.NewRunner(&quot;./rs_db.wasm&quot;))

  res, err := doWasm(nil).Then()
  if err != nil {
    fmt.Println(err)
    return
  }

  fmt.Println(string(res.([]byte)))
}
</code></pre>
<p>Finally, let's run the Go host application and see the results printed to the console.</p>
<blockquote>
<p>You must use the <code>-tags wasmedge</code> flag to take advantage of the performance and extended WebAssembly APIs provided by WasmEdge.</p>
</blockquote>
<pre><code class="language-bash">export REACTR_DB_CONN_STRING='postgresql://postgres:12345@127.0.0.1:5432/reactr'
go mod tidy
go run -tags wasmedge main.go
</code></pre>
<h2 id="embed-javascript-in-go"><a class="header" href="#embed-javascript-in-go">Embed JavaScript in Go</a></h2>
<p>As we mentioned, a key feature of the WasmEdge Runtime is its advanced <a href="use_cases/frameworks/app/../../../write_wasm/js.html">JavaScript support</a>, which allows JavaScript programs to run in lightweight, high-performance, safe, multi-language, and <a href="use_cases/frameworks/app/../../kubernetes.html">Kubernetes-managed WasmEdge containers</a>.
A simple example of embedded JavaScript function in Reactr is <a href="https://github.com/second-state/wasm-learning/tree/master/reactr/quickjs">available here</a>.</p>
<h3 id="javascript-example"><a class="header" href="#javascript-example">JavaScript example</a></h3>
<p>The <a href="https://github.com/second-state/wasm-learning/tree/master/reactr/quickjs/hello.js">JavaScript example function</a> is very simple. It just returns a string value.</p>
<pre><code class="language-javascript">let h = 'hello';
let w = 'wasmedge';
`${h} ${w}`;
</code></pre>
<h3 id="javascript-example-go-host-application"><a class="header" href="#javascript-example-go-host-application">JavaScript example: Go host application</a></h3>
<p>The <a href="https://github.com/second-state/wasm-learning/tree/master/reactr/quickjs/main.go">Go host app</a> uses the Reactr API to run WasmEdge's standard JavaScript interpreter <a href="https://github.com/second-state/wasm-learning/blob/master/reactr/quickjs/rs_embed_js.wasm">rs_embed_js.wasm</a>. You can build your own version of JavaScript interpreter by modifying <a href="https://github.com/second-state/wasm-learning/tree/master/reactr/quickjs/rs-embed-js">this Rust project</a>.</p>
<blockquote>
<p>Learn more about how to embed <a href="https://github.com/second-state/wasmedge-quickjs/tree/main/examples/embed_js">JavaScript code in Rust</a>, and how to <a href="use_cases/frameworks/app/../../../write_wasm/js/rust.html">use Rust to implement JavaScript APIs</a> in WasmEdge.</p>
</blockquote>
<p>The Go host application just need to start the job for <code>rs_embed_js.wasm</code> and pass the JavaScript content to it. The Go application can then capture and print the return value from JavaScript.</p>
<pre><code class="language-go">func main() {
  r := rt.New()
  doWasm := r.Register(&quot;hello-quickjs&quot;, rwasm.NewRunner(&quot;./rs_embed_js.wasm&quot;))

  code, err := ioutil.ReadFile(os.Args[1])
  if err != nil {
    fmt.Print(err)
  }
  res, err := doWasm(code).Then()
  if err != nil {
    fmt.Println(err)
    return
  }

  fmt.Println(string(res.([]byte)))
}
</code></pre>
<p>Run the Go host application as follows.</p>
<pre><code class="language-bash">$ cd quickjs
$ go mod tidy
$ go run -tags wasmedge main.go hello.js
String(JsString(hello wasmedge))
</code></pre>
<p>The printed result shows the type information of the string in Rust and Go APIs. You can strip out this information by changing the Rust or Go applications.</p>
<h3 id="javascript-example-feature-examples"><a class="header" href="#javascript-example-feature-examples">JavaScript example: Feature examples</a></h3>
<p>WasmEdge supports many advanced JavaScript features. For the next step, you could try our <a href="https://github.com/second-state/wasmedge-quickjs/tree/main/example_js/react_ssr">React SSR example</a> to generate an HTML UI from a Reactr function!
You can just build the <code>dist/main.js</code> from the React SSR example, and copy it over to this example folder to see it in action!</p>
<pre><code class="language-bash">$ cd quickjs
# copy over the dist/main.js file from the react ssr example
$ go mod tidy
$ go run -tags wasmedge main.go main.js
&lt;div data-reactroot=&quot;&quot;&gt;&lt;div&gt;This is home&lt;/div&gt;&lt;div&gt;&lt;div&gt;This is page&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;
UnDefined
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="serverless-platforms"><a class="header" href="#serverless-platforms">Serverless platforms</a></h1>
<blockquote>
<p>This part has been moved to <a href="https://wasmedge.org/docs/category/use-cases">https://wasmedge.org/docs/category/use-cases</a>. Please use our new docs.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rust-and-webassembly-serverless-functions-in-vercel"><a class="header" href="#rust-and-webassembly-serverless-functions-in-vercel">Rust and WebAssembly Serverless functions in Vercel</a></h1>
<p>In this article, we will show you two serverless functions in Rust and WasmEdge deployed on Vercel. One is the image processing function, the other one is the TensorFlow inference function.</p>
<blockquote>
<p>For more insights on why WasmEdge on Vercel, please refer to the article <a href="https://www.secondstate.io/articles/vercel-wasmedge-webassembly-rust/">Rust and WebAssembly Serverless Functions in Vercel</a>.</p>
</blockquote>
<h2 id="prerequisite-1"><a class="header" href="#prerequisite-1">Prerequisite</a></h2>
<p>Since our demo WebAssembly functions are written in Rust, you will need a <a href="https://www.rust-lang.org/tools/install">Rust compiler</a>. Make sure that you install the <code>wasm32-wasi</code> compiler target as follows, in order to generate WebAssembly bytecode.</p>
<pre><code class="language-bash">rustup target add wasm32-wasi
</code></pre>
<p>The demo application front end is written in <a href="https://nextjs.org/">Next.js</a>, and deployed on Vercel. We will assume that you already have the basic knowledge of how to work with Vercel.</p>
<h2 id="example-1-image-processing"><a class="header" href="#example-1-image-processing">Example 1: Image processing</a></h2>
<p>Our first demo application allows users to upload an image and then invoke a serverless function to turn it into black and white. A <a href="https://vercel-wasm-runtime.vercel.app/">live demo</a> deployed on Vercel is available.</p>
<p>Fork the <a href="https://github.com/second-state/vercel-wasm-runtime">demo application’s GitHub repo</a> to get started. To deploy the application on Vercel, just <a href="https://vercel.com/docs/git#deploying-a-git-repository">import the Github repo</a> from <a href="https://vercel.com/docs/git/vercel-for-github">Vercel for Github</a> web page.</p>
<p>This repo is a standard Next.js application for the Vercel platform. The backend serverless function is in the <a href="https://github.com/second-state/vercel-wasm-runtime/tree/main/api/functions/image-grayscale"><code>api/functions/image_grayscale</code></a> folder. The <a href="https://github.com/second-state/vercel-wasm-runtime/blob/main/api/functions/image-grayscale/src/main.rs"><code>src/main.rs</code></a> file contains the Rust program’s source code. The Rust program reads image data from the <code>STDIN</code>, and then outputs the black-white image to the <code>STDOUT</code>.</p>
<pre><pre class="playground"><code class="language-rust">use hex;
use std::io::{self, Read};
use image::{ImageOutputFormat, ImageFormat};

fn main() {
  let mut buf = Vec::new();
  io::stdin().read_to_end(&amp;mut buf).unwrap();

  let image_format_detected: ImageFormat = image::guess_format(&amp;buf).unwrap();
  let img = image::load_from_memory(&amp;buf).unwrap();
  let filtered = img.grayscale();
  let mut buf = vec![];
  match image_format_detected {
    ImageFormat::Gif =&gt; {
      filtered.write_to(&amp;mut buf, ImageOutputFormat::Gif).unwrap();
    },
    _ =&gt; {
      filtered.write_to(&amp;mut buf, ImageOutputFormat::Png).unwrap();
    },
  };
  io::stdout().write_all(&amp;buf).unwrap();
  io::stdout().flush().unwrap();
}</code></pre></pre>
<p>You can use Rust’s <code>cargo</code> tool to build the Rust program into WebAssembly bytecode or native code.</p>
<pre><code class="language-bash">cd api/functions/image-grayscale/
cargo build --release --target wasm32-wasi 
</code></pre>
<p>Copy the build artifacts to the <code>api</code> folder.</p>
<pre><code class="language-bash">cp target/wasm32-wasi/release/grayscale.wasm ../../
</code></pre>
<blockquote>
<p>Vercel runs <a href="https://github.com/second-state/vercel-wasm-runtime/blob/main/api/pre.sh"><code>api/pre.sh</code></a> upon setting up the serverless environment. It installs the WasmEdge runtime, and then compiles each WebAssembly bytecode program into a native <code>so</code> library for faster execution.</p>
</blockquote>
<p>The <a href="https://github.com/second-state/vercel-wasm-runtime/blob/main/api/hello.js"><code>api/hello.js</code></a> file conforms Vercel serverless specification. It loads the WasmEdge runtime, starts the compiled WebAssembly program in WasmEdge, and passes the uploaded image data via <code>STDIN</code>. Notice <a href="https://github.com/second-state/vercel-wasm-runtime/blob/main/api/hello.js"><code>api/hello.js</code></a> runs the compiled <code>grayscale.so</code> file generated by <a href="https://github.com/second-state/vercel-wasm-runtime/blob/main/api/pre.sh"><code>api/pre.sh</code></a> for better performance.</p>
<pre><code class="language-javascript">const fs = require('fs');
const { spawn } = require('child_process');
const path = require('path');

module.exports = (req, res) =&gt; {
  const wasmedge = spawn(
      path.join(__dirname, 'wasmedge'), 
      [path.join(__dirname, 'grayscale.so')]);

  let d = [];
  wasmedge.stdout.on('data', (data) =&gt; {
    d.push(data);
  });

  wasmedge.on('close', (code) =&gt; {
    let buf = Buffer.concat(d);

    res.setHeader('Content-Type', req.headers['image-type']);
    res.send(buf);
  });

  wasmedge.stdin.write(req.body);
  wasmedge.stdin.end('');
}
</code></pre>
<p>That's it. <a href="https://vercel.com/docs/git#deploying-a-git-repository">Deploy the repo to Vercel</a> and you now have a Vercel Jamstack app with a high-performance Rust and WebAssembly based serverless backend.</p>
<h2 id="example-2-ai-inference"><a class="header" href="#example-2-ai-inference">Example 2: AI inference</a></h2>
<p>The <a href="https://vercel-wasm-runtime.vercel.app/">second demo</a> application allows users to upload an image and then invoke a serverless function to classify the main subject on the image.</p>
<p>It is in <a href="https://github.com/second-state/vercel-wasm-runtime">the same GitHub repo</a> as the previous example but in the <code>tensorflow</code> branch. Note: when you <a href="https://vercel.com/docs/git#deploying-a-git-repository">import this GitHub repo</a> on the Vercel website, it will create a <a href="https://vercel.com/docs/platform/deployments#preview">preview URL</a> for each branch. The <code>tensorflow</code> branch would have its own deployment URL.</p>
<p>The backend serverless function for image classification is in the <a href="https://github.com/second-state/vercel-wasm-runtime/tree/tensorflow/api/functions/image-classification"><code>api/functions/image-classification</code></a> folder in the <code>tensorflow</code> branch.  The <a href="https://github.com/second-state/vercel-wasm-runtime/blob/tensorflow/api/functions/image-classification/src/main.rs"><code>src/main.rs</code></a> file contains the Rust program’s source code. The Rust program reads image data from the <code>STDIN</code>, and then outputs the text output to the <code>STDOUT</code>. It utilizes the WasmEdge Tensorflow API to run the AI inference.</p>
<pre><pre class="playground"><code class="language-rust">pub fn main() {
  // Step 1: Load the TFLite model
  let model_data: &amp;[u8] = include_bytes!(&quot;models/mobilenet_v1_1.0_224/mobilenet_v1_1.0_224_quant.tflite&quot;);
  let labels = include_str!(&quot;models/mobilenet_v1_1.0_224/labels_mobilenet_quant_v1_224.txt&quot;);

  // Step 2: Read image from STDIN
  let mut buf = Vec::new();
  io::stdin().read_to_end(&amp;mut buf).unwrap();

  // Step 3: Resize the input image for the tensorflow model
  let flat_img = wasmedge_tensorflow_interface::load_jpg_image_to_rgb8(&amp;buf, 224, 224);

  // Step 4: AI inference
  let mut session = wasmedge_tensorflow_interface::Session::new(&amp;model_data, wasmedge_tensorflow_interface::ModelType::TensorFlowLite);
  session.add_input(&quot;input&quot;, &amp;flat_img, &amp;[1, 224, 224, 3])
         .run();
  let res_vec: Vec&lt;u8&gt; = session.get_output(&quot;MobilenetV1/Predictions/Reshape_1&quot;);

  // Step 5: Find the food label that responds to the highest probability in res_vec
  // ... ...
  let mut label_lines = labels.lines();
  for _i in 0..max_index {
    label_lines.next();
  }

  // Step 6: Generate the output text
  let class_name = label_lines.next().unwrap().to_string();
  if max_value &gt; 50 {
    println!(&quot;It {} a &lt;a href='https://www.google.com/search?q={}'&gt;{}&lt;/a&gt; in the picture&quot;, confidence.to_string(), class_name, class_name);
  } else {
    println!(&quot;It does not appears to be any food item in the picture.&quot;);
  }
}</code></pre></pre>
<p>You can use the <code>cargo</code> tool to build the Rust program into WebAssembly bytecode or native code.</p>
<pre><code class="language-bash">cd api/functions/image-classification/
cargo build --release --target wasm32-wasi
</code></pre>
<p>Copy the build artifacts to the <code>api</code> folder.</p>
<pre><code class="language-bash">cp target/wasm32-wasi/release/classify.wasm ../../
</code></pre>
<p>Again, the <a href="https://github.com/second-state/vercel-wasm-runtime/blob/tensorflow/api/pre.sh"><code>api/pre.sh</code></a> script installs WasmEdge runtime and its Tensorflow dependencies in this application. It also compiles the <code>classify.wasm</code> bytecode program to the <code>classify.so</code> native shared library at the time of deployment.</p>
<p>The <a href="https://github.com/second-state/vercel-wasm-runtime/blob/tensorflow/api/hello.js"><code>api/hello.js</code></a> file conforms Vercel serverless specification. It loads the WasmEdge runtime, starts the compiled WebAssembly program in WasmEdge, and passes the uploaded image data via <code>STDIN</code>. Notice <a href="https://github.com/second-state/vercel-wasm-runtime/blob/tensorflow/api/hello.js"><code>api/hello.js</code></a> runs the compiled <code>classify.so</code> file generated by <a href="https://github.com/second-state/vercel-wasm-runtime/blob/tensorflow/api/pre.sh"><code>api/pre.sh</code></a> for better performance.</p>
<pre><code class="language-javascript">const fs = require('fs');
const { spawn } = require('child_process');
const path = require('path');

module.exports = (req, res) =&gt; {
  const wasmedge = spawn(
    path.join(__dirname, 'wasmedge-tensorflow-lite'),
    [path.join(__dirname, 'classify.so')],
    {env: {'LD_LIBRARY_PATH': __dirname}}
  );

  let d = [];
  wasmedge.stdout.on('data', (data) =&gt; {
    d.push(data);
  });

  wasmedge.on('close', (code) =&gt; {
    res.setHeader('Content-Type', `text/plain`);
    res.send(d.join(''));
  });

  wasmedge.stdin.write(req.body);
  wasmedge.stdin.end('');
}
</code></pre>
<p>You can now <a href="https://vercel.com/docs/git#deploying-a-git-repository">deploy your forked repo to Vercel</a> and have a web app for subject classification.</p>
<p>Next, it's your turn to use <a href="https://github.com/second-state/vercel-wasm-runtime">the vercel-wasm-runtime repo</a> as a template to develop your own Rust serverless functions in Vercel. Looking forward to your great work.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="webassembly-serverless-functions-in-netlify"><a class="header" href="#webassembly-serverless-functions-in-netlify">WebAssembly Serverless Functions in Netlify</a></h1>
<p>In this article we will show you two serverless functions in Rust and WasmEdge deployed on Netlify. One is the image processing function, the other one is the TensorFlow inference function.</p>
<blockquote>
<p>For more insights on why WasmEdge on Netlify, please refer to the article <a href="https://www.secondstate.io/articles/netlify-wasmedge-webassembly-rust-serverless/">WebAssembly Serverless Functions in Netlify</a>.</p>
</blockquote>
<h2 id="prerequisite-2"><a class="header" href="#prerequisite-2">Prerequisite</a></h2>
<p>Since our demo WebAssembly functions are written in Rust, you will need a <a href="https://www.rust-lang.org/tools/install">Rust compiler</a>. Make sure that you install the <code>wasm32-wasi</code> compiler target as follows, in order to generate WebAssembly bytecode.</p>
<pre><code class="language-bash">rustup target add wasm32-wasi
</code></pre>
<p>The demo application front end is written in <a href="https://nextjs.org/">Next.js</a>, and deployed on Netlify. We will assume that you already have the basic knowledge of how to work with Next.js and Netlify.</p>
<h2 id="example-1-image-processing-1"><a class="header" href="#example-1-image-processing-1">Example 1: Image processing</a></h2>
<p>Our first demo application allows users to upload an image and then invoke a serverless function to turn it into black and white. A <a href="https://60fe22f9ff623f0007656040--reverent-hodgkin-dc1f51.netlify.app/">live demo</a> deployed on Netlify is available.</p>
<p>Fork the <a href="https://github.com/second-state/netlify-wasm-runtime">demo application’s GitHub repo</a> to get started. To deploy the application on Netlify, just <a href="https://www.netlify.com/blog/2016/09/29/a-step-by-step-guide-deploying-on-netlify/">add your github repo to Netlify</a>.</p>
<p>This repo is a standard Next.js application for the Netlify platform. The backend serverless function is in the <a href="https://github.com/second-state/netlify-wasm-runtime/tree/main/api/functions/image-grayscale"><code>api/functions/image_grayscale</code></a> folder. The <a href="https://github.com/second-state/netlify-wasm-runtime/blob/main/api/functions/image-grayscale/src/main.rs"><code>src/main.rs</code></a> file contains the Rust program’s source code. The Rust program reads image data from the <code>STDIN</code>, and then outputs the black-white image to the <code>STDOUT</code>.</p>
<pre><pre class="playground"><code class="language-rust">use hex;
use std::io::{self, Read};
use image::{ImageOutputFormat, ImageFormat};

fn main() {
  let mut buf = Vec::new();
  io::stdin().read_to_end(&amp;mut buf).unwrap();

  let image_format_detected: ImageFormat = image::guess_format(&amp;buf).unwrap();
  let img = image::load_from_memory(&amp;buf).unwrap();
  let filtered = img.grayscale();
  let mut buf = vec![];
  match image_format_detected {
    ImageFormat::Gif =&gt; {
      filtered.write_to(&amp;mut buf, ImageOutputFormat::Gif).unwrap();
    },
    _ =&gt; {
      filtered.write_to(&amp;mut buf, ImageOutputFormat::Png).unwrap();
    },
  };
  io::stdout().write_all(&amp;buf).unwrap();
  io::stdout().flush().unwrap();
}</code></pre></pre>
<p>You can use Rust’s <code>cargo</code> tool to build the Rust program into WebAssembly bytecode or native code.</p>
<pre><code class="language-bash">cd api/functions/image-grayscale/
cargo build --release --target wasm32-wasi 
</code></pre>
<p>Copy the build artifacts to the <code>api</code> folder.</p>
<pre><code class="language-bash">cp target/wasm32-wasi/release/grayscale.wasm ../../
</code></pre>
<blockquote>
<p>The Netlify function runs <a href="https://github.com/second-state/netlify-wasm-runtime/blob/main/api/pre.sh"><code>api/pre.sh</code></a> upon setting up the serverless environment. It installs the WasmEdge runtime, and then compiles each WebAssembly bytecode program into a native <code>so</code> library for faster execution.</p>
</blockquote>
<p>The <a href="https://github.com/second-state/netlify-wasm-runtime/blob/main/api/hello.js"><code>api/hello.js</code></a> script loads the WasmEdge runtime, starts the compiled WebAssembly program in WasmEdge, and passes the uploaded image data via <code>STDIN</code>. Notice <a href="https://github.com/second-state/netlify-wasm-runtime/blob/main/api/hello.js"><code>api/hello.js</code></a> runs the compiled <code>grayscale.so</code> file generated by <a href="https://github.com/second-state/netlify-wasm-runtime/blob/main/api/pre.sh"><code>api/pre.sh</code></a> for better performance.</p>
<pre><code class="language-javascript">const fs = require('fs');
const { spawn } = require('child_process');
const path = require('path');

module.exports = (req, res) =&gt; {
  const wasmedge = spawn(
      path.join(__dirname, 'wasmedge'), 
      [path.join(__dirname, 'grayscale.so')]);

  let d = [];
  wasmedge.stdout.on('data', (data) =&gt; {
    d.push(data);
  });

  wasmedge.on('close', (code) =&gt; {
    let buf = Buffer.concat(d);

    res.setHeader('Content-Type', req.headers['image-type']);
    res.send(buf);
  });

  wasmedge.stdin.write(req.body);
  wasmedge.stdin.end('');
}
</code></pre>
<p>That's it. <a href="https://www.netlify.com/blog/2016/09/29/a-step-by-step-guide-deploying-on-netlify/">Deploy the repo to Netlify</a> and you now have a Netlify Jamstack app with a high-performance Rust and WebAssembly based serverless backend.</p>
<h2 id="example-2-ai-inference-1"><a class="header" href="#example-2-ai-inference-1">Example 2: AI inference</a></h2>
<p>The <a href="https://60ff7e2d10fe590008db70a9--reverent-hodgkin-dc1f51.netlify.app/">second demo</a> application allows users to upload an image and then invoke a serverless function to classify the main subject on the image.</p>
<p>It is in <a href="https://github.com/second-state/netlify-wasm-runtime/tree/tensorflow">the same GitHub repo</a> as the previous example but in the <code>tensorflow</code> branch. The backend serverless function for image classification is in the <a href="https://github.com/second-state/netlify-wasm-runtime/tree/tensorflow/api/functions/image-classification"><code>api/functions/image-classification</code></a> folder in the <code>tensorflow</code> branch.  The <a href="https://github.com/second-state/netlify-wasm-runtime/blob/tensorflow/api/functions/image-classification/src/main.rs"><code>src/main.rs</code></a> file contains the Rust program’s source code. The Rust program reads image data from the <code>STDIN</code>, and then outputs the text output to the <code>STDOUT</code>. It utilizes the WasmEdge Tensorflow API to run the AI inference.</p>
<pre><pre class="playground"><code class="language-rust">pub fn main() {
  // Step 1: Load the TFLite model
  let model_data: &amp;[u8] = include_bytes!(&quot;models/mobilenet_v1_1.0_224/mobilenet_v1_1.0_224_quant.tflite&quot;);
  let labels = include_str!(&quot;models/mobilenet_v1_1.0_224/labels_mobilenet_quant_v1_224.txt&quot;);

  // Step 2: Read image from STDIN
  let mut buf = Vec::new();
  io::stdin().read_to_end(&amp;mut buf).unwrap();

  // Step 3: Resize the input image for the tensorflow model
  let flat_img = wasmedge_tensorflow_interface::load_jpg_image_to_rgb8(&amp;buf, 224, 224);

  // Step 4: AI inference
  let mut session = wasmedge_tensorflow_interface::Session::new(&amp;model_data, wasmedge_tensorflow_interface::ModelType::TensorFlowLite);
  session.add_input(&quot;input&quot;, &amp;flat_img, &amp;[1, 224, 224, 3])
         .run();
  let res_vec: Vec&lt;u8&gt; = session.get_output(&quot;MobilenetV1/Predictions/Reshape_1&quot;);

  // Step 5: Find the food label that responds to the highest probability in res_vec
  // ... ...
  let mut label_lines = labels.lines();
  for _i in 0..max_index {
    label_lines.next();
  }

  // Step 6: Generate the output text
  let class_name = label_lines.next().unwrap().to_string();
  if max_value &gt; 50 {
    println!(&quot;It {} a &lt;a href='https://www.google.com/search?q={}'&gt;{}&lt;/a&gt; in the picture&quot;, confidence.to_string(), class_name, class_name);
  } else {
    println!(&quot;It does not appears to be any food item in the picture.&quot;);
  }
}</code></pre></pre>
<p>You can use the <code>cargo</code> tool to build the Rust program into WebAssembly bytecode or native code.</p>
<pre><code class="language-bash">cd api/functions/image-classification/
cargo build --release --target wasm32-wasi
</code></pre>
<p>Copy the build artifacts to the <code>api</code> folder.</p>
<pre><code class="language-bash">cp target/wasm32-wasi/release/classify.wasm ../../
</code></pre>
<p>Again, the <a href="https://github.com/second-state/netlify-wasm-runtime/blob/tensorflow/api/pre.sh"><code>api/pre.sh</code></a> script installs WasmEdge runtime and its Tensorflow dependencies in this application. It also compiles the <code>classify.wasm</code> bytecode program to the <code>classify.so</code> native shared library at the time of deployment.</p>
<p>The <a href="https://github.com/second-state/netlify-wasm-runtime/blob/tensorflow/api/hello.js"><code>api/hello.js</code></a> script loads the WasmEdge runtime, starts the compiled WebAssembly program in WasmEdge, and passes the uploaded image data via <code>STDIN</code>. Notice <a href="https://github.com/second-state/netlify-wasm-runtime/blob/tensorflow/api/hello.js"><code>api/hello.js</code></a> runs the compiled <code>classify.so</code> file generated by <a href="https://github.com/second-state/netlify-wasm-runtime/blob/tensorflow/api/pre.sh"><code>api/pre.sh</code></a> for better performance.</p>
<pre><code class="language-javascript">const fs = require('fs');
const { spawn } = require('child_process');
const path = require('path');

module.exports = (req, res) =&gt; {
  const wasmedge = spawn(
    path.join(__dirname, 'wasmedge-tensorflow-lite'),
    [path.join(__dirname, 'classify.so')],
    {env: {'LD_LIBRARY_PATH': __dirname}}
  );

  let d = [];
  wasmedge.stdout.on('data', (data) =&gt; {
    d.push(data);
  });

  wasmedge.on('close', (code) =&gt; {
    res.setHeader('Content-Type', `text/plain`);
    res.send(d.join(''));
  });

  wasmedge.stdin.write(req.body);
  wasmedge.stdin.end('');
}
</code></pre>
<p>You can now <a href="https://www.netlify.com/blog/2016/09/29/a-step-by-step-guide-deploying-on-netlify/">deploy your forked repo to Netlify</a> and have a web app for subject classification.</p>
<p>Next, it's your turn to develop Rust serverless functions in Netlify using the <a href="https://github.com/second-state/netlify-wasm-runtime">netlify-wasm-runtime repo</a> as a template. Looking forward to your great work.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="webassembly-serverless-functions-in-aws-lambda"><a class="header" href="#webassembly-serverless-functions-in-aws-lambda">WebAssembly Serverless Functions in AWS Lambda</a></h1>
<p>In this article, we will show you two serverless functions in Rust and WasmEdge deployed on AWS Lambda. One is the image processing function, the other one is the TensorFlow inference function.</p>
<blockquote>
<p>For the insight on why WasmEdge on AWS Lambda, please refer to the article <a href="https://www.secondstate.io/articles/webassembly-serverless-functions-in-aws-lambda/">WebAssembly Serverless Functions in AWS Lambda</a></p>
</blockquote>
<h2 id="prerequisites-2"><a class="header" href="#prerequisites-2">Prerequisites</a></h2>
<p>Since our demo WebAssembly functions are written in Rust, you will need a <a href="https://www.rust-lang.org/tools/install">Rust compiler</a>. Make sure that you install the <code>wasm32-wasi</code> compiler target as follows, in order to generate WebAssembly bytecode.</p>
<pre><code class="language-bash">rustup target add wasm32-wasi
</code></pre>
<p>The demo application front end is written in <a href="https://nextjs.org/">Next.js</a>, and deployed on AWS Lambda. We will assume that you already have the basic knowledge of how to work with Next.js and Lambda.</p>
<h2 id="example-1-image-processing-2"><a class="header" href="#example-1-image-processing-2">Example 1: Image processing</a></h2>
<p>Our first demo application allows users to upload an image and then invoke a serverless function to turn it into black and white. A <a href="https://second-state.github.io/aws-lambda-wasm-runtime/">live demo</a> deployed through GitHub Pages is available.</p>
<p>Fork the <a href="https://github.com/second-state/aws-lambda-wasm-runtime">demo application’s GitHub repo</a> to get started. To deploy the application on AWS Lambda, follow the guide in the repository <a href="https://github.com/second-state/aws-lambda-wasm-runtime/blob/tensorflow/README.md">README</a>.</p>
<h3 id="create-the-function"><a class="header" href="#create-the-function">Create the function</a></h3>
<p>This repo is a standard Next.js application. The backend serverless function is in the <code>api/functions/image_grayscale</code> folder. The <code>src/main.rs</code> file contains the Rust program’s source code. The Rust program reads image data from the <code>STDIN</code>, and then outputs the black-white image to the <code>STDOUT</code>.</p>
<pre><pre class="playground"><code class="language-rust">use hex;
use std::io::{self, Read};
use image::{ImageOutputFormat, ImageFormat};

fn main() {
  let mut buf = Vec::new();
  io::stdin().read_to_end(&amp;mut buf).unwrap();

  let image_format_detected: ImageFormat = image::guess_format(&amp;buf).unwrap();
  let img = image::load_from_memory(&amp;buf).unwrap();
  let filtered = img.grayscale();
  let mut buf = vec![];
  match image_format_detected {
    ImageFormat::Gif =&gt; {
      filtered.write_to(&amp;mut buf, ImageOutputFormat::Gif).unwrap();
    },
    _ =&gt; {
      filtered.write_to(&amp;mut buf, ImageOutputFormat::Png).unwrap();
    },
  };
  io::stdout().write_all(&amp;buf).unwrap();
  io::stdout().flush().unwrap();
}</code></pre></pre>
<p>You can use Rust’s <code>cargo</code> tool to build the Rust program into WebAssembly bytecode or native code.</p>
<pre><code class="language-bash">cd api/functions/image-grayscale/
cargo build --release --target wasm32-wasi 
</code></pre>
<p>Copy the build artifacts to the <code>api</code> folder.</p>
<pre><code class="language-bash">cp target/wasm32-wasi/release/grayscale.wasm ../../
</code></pre>
<blockquote>
<p>When we build the docker image, <code>api/pre.sh</code> is executed. <code>pre.sh</code> installs the WasmEdge runtime, and then compiles each WebAssembly bytecode program into a native <code>so</code> library for faster execution.</p>
</blockquote>
<h3 id="create-the-service-script-to-load-the-function"><a class="header" href="#create-the-service-script-to-load-the-function">Create the service script to load the function</a></h3>
<p>The <a href="https://github.com/second-state/aws-lambda-wasm-runtime/blob/main/api/hello.js"><code>api/hello.js</code></a> script loads the WasmEdge runtime, starts the compiled WebAssembly program in WasmEdge, and passes the uploaded image data via <code>STDIN</code>. Notice that <a href="https://github.com/second-state/aws-lambda-wasm-runtime/blob/main/api/hello.js"><code>api/hello.js</code></a> runs the compiled <code>grayscale.so</code> file generated by <a href="https://github.com/second-state/aws-lambda-wasm-runtime/blob/main/api/pre.sh"><code>api/pre.sh</code></a> for better performance.</p>
<pre><code class="language-javascript">const { spawn } = require('child_process');
const path = require('path');

function _runWasm(reqBody) {
  return new Promise(resolve =&gt; {
    const wasmedge = spawn(path.join(__dirname, 'wasmedge'), [path.join(__dirname, 'grayscale.so')]);

    let d = [];
    wasmedge.stdout.on('data', (data) =&gt; {
      d.push(data);
    });

    wasmedge.on('close', (code) =&gt; {
      let buf = Buffer.concat(d);
      resolve(buf);
    });

    wasmedge.stdin.write(reqBody);
    wasmedge.stdin.end('');
  });
}
</code></pre>
<p>The <code>exports.handler</code> part of <code>hello.js</code> exports an async function handler, used to handle different events every time the serverless function is called. In this example, we simply process the image by calling the function above and return the result, but more complicated event-handling behavior may be defined based on your need. We also need to return some <code>Access-Control-Allow</code> headers to avoid <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS">Cross-Origin Resource Sharing (CORS)</a> errors when calling the serverless function from a browser. You can read more about CORS errors <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS/Errors">here</a> if you encounter them when replicating our example.</p>
<pre><code class="language-javascript">exports.handler = async function(event, context) {
  var typedArray = new Uint8Array(event.body.match(/[\da-f]{2}/gi).map(function (h) {
    return parseInt(h, 16);
  }));
  let buf = await _runWasm(typedArray);
  return {
    statusCode: 200,
    headers: {
      &quot;Access-Control-Allow-Headers&quot; : &quot;Content-Type,X-Amz-Date,Authorization,X-Api-Key,X-Amz-Security-Token&quot;,
      &quot;Access-Control-Allow-Origin&quot;: &quot;*&quot;,
      &quot;Access-Control-Allow-Methods&quot;: &quot;DELETE, GET, HEAD, OPTIONS, PATCH, POST, PUT&quot;
    },
    body: buf.toString('hex')
  };
}
</code></pre>
<h3 id="build-the-docker-image-for-lambda-deployment"><a class="header" href="#build-the-docker-image-for-lambda-deployment">Build the Docker image for Lambda deployment</a></h3>
<p>Now we have the WebAssembly bytecode function and the script to load and connect to the web request. In order to deploy them as a function service on AWS Lambda, you still need to package the whole thing into a Docker image.</p>
<p>We are not going to cover in detail about how to build the Docker image and deploy on AWS Lambda, as there are detailed steps in the <a href="https://github.com/second-state/aws-lambda-wasm-runtime/blob/tensorflow/README.md#deploy">Deploy section of the repository README</a>. However, we will highlight some lines in the <a href="https://github.com/second-state/aws-lambda-wasm-runtime/blob/tensorflow/api/Dockerfile"><code>Dockerfile</code></a> for you to avoid some pitfalls.</p>
<pre><code class="language-dockerfile">FROM public.ecr.aws/lambda/nodejs:14

# Change directory to /var/task
WORKDIR /var/task

RUN yum update -y &amp;&amp; yum install -y curl tar gzip

# Bundle and pre-compile the wasm files
COPY *.wasm ./
COPY pre.sh ./
RUN chmod +x pre.sh
RUN ./pre.sh

# Bundle the JS files
COPY *.js ./

CMD [ &quot;hello.handler&quot; ]
</code></pre>
<p>First, we are building the image from <a href="https://hub.docker.com/r/amazon/aws-lambda-nodejs">AWS Lambda's Node.js base image</a>. The advantage of using AWS Lambda's base image is that it includes the <a href="https://github.com/aws/aws-lambda-nodejs-runtime-interface-client">Lambda Runtime Interface Client (RIC)</a>, which we need to implement in our Docker image as it is required by AWS Lambda. The Amazon Linux uses <code>yum</code> as the package manager.</p>
<blockquote>
<p>These base images contain the Amazon Linux Base operating system, the runtime for a given language, dependencies and the Lambda Runtime Interface Client (RIC), which implements the Lambda <a href="https://docs.aws.amazon.com/lambda/latest/dg/runtimes-api.html">Runtime API</a>. The Lambda Runtime Interface Client allows your runtime to receive requests from and send requests to the Lambda service.</p>
</blockquote>
<p>Second, we need to put our function and all its dependencies in the <code>/var/task</code> directory. Files in other folders will not be executed by AWS Lambda.</p>
<p>Third, we need to define the default command when we start our container. <code>CMD [ &quot;hello.handler&quot; ]</code> means that we will call the <code>handler</code> function in <code>hello.js</code> whenever our serverless function is called. Recall that we have defined and exported the handler function in the previous steps through <code>exports.handler = ...</code> in <code>hello.js</code>.</p>
<h3 id="optional-test-the-docker-image-locally"><a class="header" href="#optional-test-the-docker-image-locally">Optional: test the Docker image locally</a></h3>
<p>Docker images built from AWS Lambda's base images can be tested locally following <a href="https://docs.aws.amazon.com/lambda/latest/dg/images-test.html">this guide</a>. Local testing requires <a href="https://github.com/aws/aws-lambda-runtime-interface-emulator">AWS Lambda Runtime Interface Emulator (RIE)</a>, which is already installed in all of AWS Lambda's base images. To test your image, first, start the Docker container by running:</p>
<pre><code class="language-bash">docker run -p 9000:8080  myfunction:latest 
</code></pre>
<p>This command sets a function endpoint on your local machine at <code>http://localhost:9000/2015-03-31/functions/function/invocations</code>.</p>
<p>Then, from a separate terminal window, run:</p>
<pre><code class="language-bash">curl -XPOST &quot;http://localhost:9000/2015-03-31/functions/function/invocations&quot; -d '{}'
</code></pre>
<p>And you should get your expected output in the terminal.</p>
<p>If you don't want to use a base image from AWS Lambda, you can also use your own base image and install RIC and/or RIE while building your Docker image. Just follow <strong>Create an image from an alternative base image</strong> section from <a href="https://docs.aws.amazon.com/lambda/latest/dg/images-create.html">this guide</a>.</p>
<p>That's it! After building your Docker image, you can deploy it to AWS Lambda following steps outlined in the repository <a href="https://github.com/second-state/aws-lambda-wasm-runtime/blob/tensorflow/README.md#deploy">README</a>. Now your serverless function is ready to rock!</p>
<h2 id="example-2-ai-inference-2"><a class="header" href="#example-2-ai-inference-2">Example 2: AI inference</a></h2>
<p>The <a href="https://github.com/second-state/aws-lambda-wasm-runtime/tree/tensorflow">second demo</a> application allows users to upload an image and then invoke a serverless function to classify the main subject on the image.</p>
<p>It is in <a href="https://github.com/second-state/aws-lambda-wasm-runtime/tree/tensorflow">the same GitHub repo</a> as the previous example but in the <code>tensorflow</code> branch. The backend serverless function for image classification is in the <code>api/functions/image-classification</code> folder in the <code>tensorflow</code> branch. The <code>src/main.rs</code> file contains the Rust program’s source code. The Rust program reads image data from the <code>STDIN</code>, and then outputs the text output to the <code>STDOUT</code>. It utilizes the WasmEdge Tensorflow API to run the AI inference.</p>
<pre><pre class="playground"><code class="language-rust">pub fn main() {
  // Step 1: Load the TFLite model
  let model_data: &amp;[u8] = include_bytes!(&quot;models/mobilenet_v1_1.0_224/mobilenet_v1_1.0_224_quant.tflite&quot;);
  let labels = include_str!(&quot;models/mobilenet_v1_1.0_224/labels_mobilenet_quant_v1_224.txt&quot;);

  // Step 2: Read image from STDIN
  let mut buf = Vec::new();
  io::stdin().read_to_end(&amp;mut buf).unwrap();

  // Step 3: Resize the input image for the tensorflow model
  let flat_img = wasmedge_tensorflow_interface::load_jpg_image_to_rgb8(&amp;buf, 224, 224);

  // Step 4: AI inference
  let mut session = wasmedge_tensorflow_interface::Session::new(&amp;model_data, wasmedge_tensorflow_interface::ModelType::TensorFlowLite);
  session.add_input(&quot;input&quot;, &amp;flat_img, &amp;[1, 224, 224, 3])
         .run();
  let res_vec: Vec&lt;u8&gt; = session.get_output(&quot;MobilenetV1/Predictions/Reshape_1&quot;);

  // Step 5: Find the food label that responds to the highest probability in res_vec
  // ... ...
  let mut label_lines = labels.lines();
  for _i in 0..max_index {
    label_lines.next();
  }

  // Step 6: Generate the output text
  let class_name = label_lines.next().unwrap().to_string();
  if max_value &gt; 50 {
    println!(&quot;It {} a &lt;a href='https://www.google.com/search?q={}'&gt;{}&lt;/a&gt; in the picture&quot;, confidence.to_string(), class_name, class_name);
  } else {
    println!(&quot;It does not appears to be any food item in the picture.&quot;);
  }
}</code></pre></pre>
<p>You can use the <code>cargo</code> tool to build the Rust program into WebAssembly bytecode or native code.</p>
<pre><code class="language-bash">cd api/functions/image-classification/
cargo build --release --target wasm32-wasi
</code></pre>
<p>Copy the build artifacts to the <code>api</code> folder.</p>
<pre><code class="language-bash">cp target/wasm32-wasi/release/classify.wasm ../../
</code></pre>
<p>Again, the <code>api/pre.sh</code> script installs WasmEdge runtime and its Tensorflow dependencies in this application. It also compiles the <code>classify.wasm</code> bytecode program to the <code>classify.so</code> native shared library at the time of deployment.</p>
<p>The <a href="https://github.com/second-state/aws-lambda-wasm-runtime/blob/tensorflow/api/hello.js"><code>api/hello.js</code></a> script loads the WasmEdge runtime, starts the compiled WebAssembly program in WasmEdge, and passes the uploaded image data via <code>STDIN</code>. Notice <a href="https://github.com/second-state/aws-lambda-wasm-runtime/blob/tensorflow/api/hello.js"><code>api/hello.js</code></a> runs the compiled <code>classify.so</code> file generated by <a href="https://github.com/second-state/aws-lambda-wasm-runtime/blob/tensorflow/api/pre.sh"><code>api/pre.sh</code></a> for better performance. The handler function is similar to our previous example, and is omitted here.</p>
<pre><code class="language-javascript">const { spawn } = require('child_process');
const path = require('path');

function _runWasm(reqBody) {
  return new Promise(resolve =&gt; {
    const wasmedge = spawn(
      path.join(__dirname, 'wasmedge-tensorflow-lite'),
      [path.join(__dirname, 'classify.so')],
      {env: {'LD_LIBRARY_PATH': __dirname}}
    );

    let d = [];
    wasmedge.stdout.on('data', (data) =&gt; {
      d.push(data);
    });

    wasmedge.on('close', (code) =&gt; {
      resolve(d.join(''));
    });

    wasmedge.stdin.write(reqBody);
    wasmedge.stdin.end('');
  });
}

exports.handler = ... // _runWasm(reqBody) is called in the handler
</code></pre>
<p>You can build your Docker image and deploy the function in the same way as outlined in the previous example. Now you have created a web app for subject classification!</p>
<p>Next, it's your turn to use the <a href="https://github.com/second-state/aws-lambda-wasm-runtime/tree/main">aws-lambda-wasm-runtime repo</a> as a template to develop Rust serverless function on AWS Lambda. Looking forward to your great work.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="webassembly-serverless-functions-on-tencent-cloud"><a class="header" href="#webassembly-serverless-functions-on-tencent-cloud">WebAssembly serverless functions on Tencent Cloud</a></h1>
<p>As the main users of Tencent Cloud are from China, so the tutorial is <a href="https://my.oschina.net/u/4532842/blog/5172639">written in Chinese</a>.</p>
<p>We also provide a code template for deploying serverless WebAssembly functions on Tencent Cloud, please check out <a href="https://github.com/second-state/tencent-scf-wasm-runtime">the tencent-scf-wasm-runtime repo</a>.</p>
<p>Fork the repo and start writing your own rust functions.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="second-state-functions-1"><a class="header" href="#second-state-functions-1">Second State Functions</a></h1>
<p>Second State Functions, powered by WasmEdge, supports the Rust language as a first class citizen.</p>
<p>It could</p>
<ul>
<li><a href="https://www.secondstate.io/articles/getting-started-with-function-as-a-service-in-rust/">Handle text-based input and output</a></li>
<li><a href="https://www.secondstate.io/articles/use-binary-data-as-function-input-and-output/">Use Binary data as function input and output</a></li>
<li><a href="https://www.secondstate.io/articles/use-binary-data-as-function-input-and-output/">Mix bytes and strings in function argument and return value</a></li>
<li><a href="https://www.secondstate.io/articles/internet-of-functions-webhooks/">Use webhooks as function input and output</a></li>
<li><a href="https://www.secondstate.io/articles/internet-of-functions-http-proxy/">Access internet resources via a <code>http_proxy</code> API</a></li>
<li><a href="https://www.secondstate.io/articles/wasi-tensorflow/">Running TensorFlow models at native speed via the WasmEdge TensorFlow API</a></li>
</ul>
<p>Check out the <a href="https://www.secondstate.io/faas/">Second State Functions</a> website for more tutorials.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="write-a-webassembly-application"><a class="header" href="#write-a-webassembly-application">Write a WebAssembly Application</a></h1>
<blockquote>
<p>This part has been moved to <a href="https://wasmedge.org/docs/develop/overview">https://wasmedge.org/docs/develop/overview</a>. Please use our new docs.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="c"><a class="header" href="#c">C</a></h1>
<blockquote>
<p>This part has been moved to <a href="https://wasmedge.org/docs/develop/c/simd">https://wasmedge.org/docs/develop/c/simd</a>. Please use our new docs</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="getting-started"><a class="header" href="#getting-started">Getting Started</a></h1>
<blockquote>
<p>This part has been moved to  <a href="https://wasmedge.org/docs/develop/c/hello_world">https://wasmedge.org/docs/develop/c/hello_world</a>. Please use our new docs.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="webassembly-simd-example-in-c"><a class="header" href="#webassembly-simd-example-in-c">WebAssembly SIMD Example in C</a></h1>
<blockquote>
<p>This part has been moved to <a href="https://wasmedge.org/docs/develop/c/simd">https://wasmedge.org/docs/develop/c/simd</a>. Please use our new docs.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rust"><a class="header" href="#rust">Rust</a></h1>
<blockquote>
<p>This part has been moved to <a href="https://wasmedge.org/docs/develop/rust/hello_world">https://wasmedge.org/docs/develop/rust/hello_world</a>. Please use our new docs.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bindgen-of-rust-functions"><a class="header" href="#bindgen-of-rust-functions">Bindgen of Rust Functions</a></h1>
<blockquote>
<p>This part has been moved to  <a href="https://wasmedge.org/docs/develop/rust/bindgen">https://wasmedge.org/docs/develop/rust/bindgen</a>. Please use our new docs.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="access-os-services"><a class="header" href="#access-os-services">Access OS services</a></h1>
<blockquote>
<p>This part has been moved to  <a href="https://wasmedge.org/docs/develop/rust/os">https://wasmedge.org/docs/develop/rust/os</a>. Please use our new docs.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tensorflow"><a class="header" href="#tensorflow">Tensorflow</a></h1>
<blockquote>
<p>This part has been moved to <a href="https://wasmedge.org/docs/develop/rust/ai_inference/tensorflow_lite">https://wasmedge.org/docs/develop/rust/ai_inference/tensorflow_lite</a>. Please use our new docs.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="neural-network-for-wasi"><a class="header" href="#neural-network-for-wasi">Neural Network for WASI</a></h1>
<p>This Part has been moved to</p>
<ol>
<li>Pytorch: <a href="https://wasmedge.org/docs/develop/rust/wasinn/pytorch">https://wasmedge.org/docs/develop/rust/wasinn/pytorch</a></li>
<li>OpenVINO: <a href="https://wasmedge.org/docs/develop/rust/wasinn/openvino">https://wasmedge.org/docs/develop/rust/wasinn/openvino</a></li>
<li>TensorFlow-Lite: <a href="https://wasmedge.org/docs/develop/rust/wasinn/tensorflow_lite">https://wasmedge.org/docs/develop/rust/wasinn/tensorflow_lite</a></li>
</ol>
<p>Please use our new docs.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="crypto-for-wasi"><a class="header" href="#crypto-for-wasi">Crypto for WASI</a></h1>
<blockquote>
<p>This part has been moved to  <a href="https://wasmedge.org/docs/develop/rust/wasicrypto">https://wasmedge.org/docs/develop/rust/wasicrypto</a>. Please use our new docs.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="simple-networking-sockets"><a class="header" href="#simple-networking-sockets">Simple Networking Sockets</a></h1>
<blockquote>
<p>This part has been moved to</p>
</blockquote>
<ol>
<li>Client example: <a href="https://wasmedge.org/docs/develop/rust/socket_networking/client">https://wasmedge.org/docs/develop/rust/socket_networking/client</a></li>
<li>Server example: <a href="https://wasmedge.org/docs/develop/rust/socket_networking/server/">https://wasmedge.org/docs/develop/rust/socket_networking/server/</a></li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="simple-https-client--server"><a class="header" href="#simple-https-client--server">Simple HTTPS Client &amp; Server</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="non-blocking-networking-sockets"><a class="header" href="#non-blocking-networking-sockets">Non-blocking Networking Sockets</a></h1>
<blockquote>
<p>This part has been moved to</p>
</blockquote>
<ol>
<li>
<p>Client example: <a href="https://wasmedge.org/docs/develop/rust/socket_networking/client">https://wasmedge.org/docs/develop/rust/socket_networking/client</a></p>
</li>
<li>
<p>Server example: <a href="https://wasmedge.org/docs/develop/rust/socket_networking/server/">https://wasmedge.org/docs/develop/rust/socket_networking/server/</a></p>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="server-side-rendering"><a class="header" href="#server-side-rendering">Server-side rendering</a></h1>
<blockquote>
<p>This part has been moved to <a href="https://wasmedge.org/docs/develop/rust/ssr">https://wasmedge.org/docs/develop/rust/ssr</a>. Please use our new docs.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="command-interface"><a class="header" href="#command-interface">Command interface</a></h1>
<p>This part part has moved to <a href="https://wasmedge.org/docs/develop/rust/command">https://wasmedge.org/docs/develop/rust/command</a>. Please use our docs.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="javascript-1"><a class="header" href="#javascript-1">JavaScript</a></h1>
<blockquote>
<p>This part has been moved to  <a href="https://wasmedge.org/docs/develop/javascript/intro">https://wasmedge.org/docs/develop/javascript/intro</a>. Please use our new docs.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="quick-start-with-javascript-on-wasmedge"><a class="header" href="#quick-start-with-javascript-on-wasmedge">Quick Start with JavaScript on WasmEdge</a></h1>
<blockquote>
<p>This part has been moved to  <a href="https://wasmedge.org/docs/develop/javascript/hello_world">https://wasmedge.org/docs/develop/javascript/hello_world</a>. Please use our new docs.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="nodejs-support"><a class="header" href="#nodejs-support">Node.js support</a></h1>
<blockquote>
<p>This part has been moved to  <a href="https://wasmedge.org/docs/develop/javascript/nodejs">https://wasmedge.org/docs/develop/javascript/nodejs</a>. Please use our new docs.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="http-and-networking-apps"><a class="header" href="#http-and-networking-apps">HTTP and networking apps</a></h1>
<blockquote>
<p>This part has been moved to  <a href="https://wasmedge.org/docs/develop/javascript/networking">https://wasmedge.org/docs/develop/javascript/networking</a>. Please use our new docs.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="react-ssr"><a class="header" href="#react-ssr">React SSR</a></h1>
<blockquote>
<p>This part has been moved to  <a href="https://wasmedge.org/docs/develop/javascript/ssr">https://wasmedge.org/docs/develop/javascript/ssr</a>. Please use our new docs.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tensorflow-1"><a class="header" href="#tensorflow-1">TensorFlow</a></h1>
<blockquote>
<p>This part has been moved to  <a href="https://wasmedge.org/docs/develop/javascript/tensorflow">https://wasmedge.org/docs/develop/javascript/tensorflow</a>. Please use our new docs.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="es6-module-support"><a class="header" href="#es6-module-support">ES6 module support</a></h1>
<blockquote>
<p>This part has been moved to  <a href="https://wasmedge.org/docs/develop/javascript/es6">https://wasmedge.org/docs/develop/javascript/es6</a>. Please use our new docs.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="nodejs-and-npm-module"><a class="header" href="#nodejs-and-npm-module">NodeJS and NPM module</a></h1>
<blockquote>
<p>This part has been moved to  <a href="https://wasmedge.org/docs/develop/javascript/npm">https://wasmedge.org/docs/develop/javascript/npm</a>. Please use our new docs.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="system-modules"><a class="header" href="#system-modules">System modules</a></h1>
<blockquote>
<p>This part has been moved to  <a href="https://wasmedge.org/docs/develop/javascript/modules">https://wasmedge.org/docs/develop/javascript/modules</a>. Please use our new docs.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="use-rust-to-implement-js-api"><a class="header" href="#use-rust-to-implement-js-api">Use Rust to implement JS API</a></h1>
<blockquote>
<p>This part has been moved to  <a href="https://wasmedge.org/docs/develop/javascript/rust">https://wasmedge.org/docs/develop/javascript/rust</a>. Please use our new docs.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="go"><a class="header" href="#go">Go</a></h1>
<blockquote>
<p>This part has been moved to  <a href="https://wasmedge.org/docs/develop/go/hello_world">https://wasmedge.org/docs/develop/go/hello_world</a>. Please use our new docs.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="swift"><a class="header" href="#swift">Swift</a></h1>
<p>The <a href="https://swiftwasm.org/">swiftwasm</a> project compiles Swift source code to WebAssembly.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="assemblyscript"><a class="header" href="#assemblyscript">AssemblyScript</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="kotlin"><a class="header" href="#kotlin">Kotlin</a></h1>
<p>Check out how to <a href="https://blog.jdriven.com/2021/04/running-kotlin-in-the-browser-with-wasm/">compile Kotlin programs to WebAssembly</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="grain"><a class="header" href="#grain">Grain</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="python"><a class="header" href="#python">Python</a></h1>
<blockquote>
<p>This part has been moved to <a href="https://wasmedge.org/docs/develop/python/hello_world">https://wasmedge.org/docs/develop/python/hello_world</a>. Please use our new docs</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="use-wasmedge-library-in-programming-languages"><a class="header" href="#use-wasmedge-library-in-programming-languages">Use WasmEdge Library in Programming Languages</a></h1>
<blockquote>
<p>This doc has been moved to <a href="https://wasmedge.org/docs/embed/overview">https://wasmedge.org/docs/embed/overview</a>. Please use our new docs.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="wasmedge-c-sdk"><a class="header" href="#wasmedge-c-sdk">WasmEdge C SDK</a></h1>
<blockquote>
<p>This part has been moved to  <a href="https://wasmedge.org/docs/embed/c/intro">https://wasmedge.org/docs/embed/c/intro</a>. Please use our new docs.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="use-the-wasmedge-library"><a class="header" href="#use-the-wasmedge-library">Use the WasmEdge Library</a></h1>
<blockquote>
<p>This part has been moved to  <a href="https://wasmedge.org/docs/embed/c/library">https://wasmedge.org/docs/embed/c/library</a>. Please use our new docs.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="host-functions"><a class="header" href="#host-functions">Host Functions</a></h1>
<blockquote>
<p>This part has been moved to  <a href="https://wasmedge.org/docs/embed/c/host_function">https://wasmedge.org/docs/embed/c/host_function</a>. Please use our new docs.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="customized-external-references"><a class="header" href="#customized-external-references">Customized External References</a></h1>
<blockquote>
<p>This part has been moved to  <a href="https://wasmedge.org/docs/embed/c/externref">https://wasmedge.org/docs/embed/c/externref</a>. Please use our new docs.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="multiple-wasm-module-example"><a class="header" href="#multiple-wasm-module-example">Multiple WASM Module Example</a></h1>
<blockquote>
<p>This part has been moved to  <a href="https://wasmedge.org/docs/embed/c/multiple_modules">https://wasmedge.org/docs/embed/c/multiple_modules</a>. Please use our new docs.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="wasmedge-c-0120-api-documentation"><a class="header" href="#wasmedge-c-0120-api-documentation">WasmEdge C 0.12.0 API Documentation</a></h1>
<blockquote>
<p>This part has been moved to  <a href="https://wasmedge.org/docs/embed/c/reference/0.12.x">https://wasmedge.org/docs/embed/c/reference/0.12.x</a>. Please use our new docs.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="wasmedge-c-0112-api-documentation"><a class="header" href="#wasmedge-c-0112-api-documentation">WasmEdge C 0.11.2 API Documentation</a></h1>
<p>This  part has moved to <a href="https://wasmedge.org/docs/embed/c/reference/0.11.x">https://wasmedge.org/docs/embed/c/reference/0.11.x</a>. Please use our new docs.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="upgrade-to-wasmedge-0120"><a class="header" href="#upgrade-to-wasmedge-0120">Upgrade to WasmEdge 0.12.0</a></h1>
<p>Thias part has moved to <a href="https://wasmedge.org/docs/embed/c/reference/upgrade_to_0.12.0">https://wasmedge.org/docs/embed/c/reference/upgrade_to_0.12.0</a>. Please use our new docs.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="wasmedge-0101-c-api-documentation"><a class="header" href="#wasmedge-0101-c-api-documentation">WasmEdge 0.10.1 C API Documentation</a></h1>
<blockquote>
<p>This part has been moved to  <a href="https://wasmedge.org/docs/embed/c/reference/0.10.x">https://wasmedge.org/docs/embed/c/reference/0.10.x</a>. Please use our new docs.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="upgrade-to-wasmedge-0110"><a class="header" href="#upgrade-to-wasmedge-0110">Upgrade to WasmEdge 0.11.0</a></h1>
<blockquote>
<p>This part has been moved to  <a href="https://wasmedge.org/docs/embed/c/reference/upgrade_to_0.11.0">https://wasmedge.org/docs/embed/c/reference/upgrade_to_0.11.0</a>. Please use our new docs.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="wasmedge-091-c-api-documentation"><a class="header" href="#wasmedge-091-c-api-documentation">WasmEdge 0.9.1 C API Documentation</a></h1>
<blockquote>
<p>This part has been moved to  <a href="https://wasmedge.org/docs/embed/c/reference/0.9.x">https://wasmedge.org/docs/embed/c/reference/0.9.x</a>. Please use our new docs.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="upgrade-to-wasmedge-0100"><a class="header" href="#upgrade-to-wasmedge-0100">Upgrade to WasmEdge 0.10.0</a></h1>
<blockquote>
<p>This part has been moved to  <a href="https://wasmedge.org/docs/embed/c/reference/upgrade_to_0.10.0">https://wasmedge.org/docs/embed/c/reference/upgrade_to_0.10.0</a>. Please use our new docs.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="wasmedge-go-sdk"><a class="header" href="#wasmedge-go-sdk">WasmEdge Go SDK</a></h1>
<blockquote>
<p>This part has been moved to <a href="https://wasmedge.org/docs/embed/go/intro">https://wasmedge.org/docs/embed/go/intro</a>. Please use our new doc.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="embed-a-standalone-wasm-app"><a class="header" href="#embed-a-standalone-wasm-app">Embed a standalone WASM app</a></h1>
<blockquote>
<p>This part has been moved to  <a href="https://wasmedge.org/docs/embed/go/app">https://wasmedge.org/docs/embed/go/app</a>. Please use our new docs.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="embed-a-wasm-function"><a class="header" href="#embed-a-wasm-function">Embed a Wasm function</a></h1>
<blockquote>
<p>This part has been moved to  <a href="https://wasmedge.org/docs/embed/go/function">https://wasmedge.org/docs/embed/go/function</a>. Please use our new docs.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pass-complex-parameters-to-wasm-functions"><a class="header" href="#pass-complex-parameters-to-wasm-functions">Pass complex parameters to Wasm functions</a></h1>
<blockquote>
<p>This part has been moved to  <a href="https://wasmedge.org/docs/embed/go/passing_data">https://wasmedge.org/docs/embed/go/passing_data</a>. Please use pur new docs.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tensorflow-2"><a class="header" href="#tensorflow-2">Tensorflow</a></h1>
<p>This  part has moved to <a href="https://wasmedge.org/docs/embed/go/ai">https://wasmedge.org/docs/embed/go/ai</a>. Please use our new docs.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="embed-a-bindgen-function"><a class="header" href="#embed-a-bindgen-function">Embed a bindgen function</a></h1>
<blockquote>
<p>This part has been moved to  <a href="https://wasmedge.org/docs/embed/go/bindgen">https://wasmedge.org/docs/embed/go/bindgen</a>. Please use our new docs.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="wasmedge-go-v0120-api-references"><a class="header" href="#wasmedge-go-v0120-api-references">WasmEdge Go v0.12.0 API references</a></h1>
<p>This part has been moved to <a href="https://wasmedge.org/docs/embed/go/reference/0.12.x">https://wasmedge.org/docs/embed/go/reference/0.12.x</a>. Please use our new docs.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="wasmedge-go-v0112-api-references"><a class="header" href="#wasmedge-go-v0112-api-references">WasmEdge Go v0.11.2 API references</a></h1>
<blockquote>
<p>This part has been moved to  <a href="https://wasmedge.org/docs/embed/go/reference/0.11.x">https://wasmedge.org/docs/embed/go/reference/0.11.x</a>. Please use our new docs.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="upgrade-to-wasmedge-go-v0120"><a class="header" href="#upgrade-to-wasmedge-go-v0120">Upgrade to WasmEdge-Go v0.12.0</a></h1>
<blockquote>
<p>This part has been moved to  <a href="https://wasmedge.org/docs/embed/go/reference/upgrade_to_0.12.0">https://wasmedge.org/docs/embed/go/reference/upgrade_to_0.12.0</a>. Please use our new docs.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="wasmedge-go-v0101-api-references"><a class="header" href="#wasmedge-go-v0101-api-references">WasmEdge Go v0.10.1 API references</a></h1>
<blockquote>
<p>This part has been moved to  <a href="https://wasmedge.org/docs/embed/go/reference/0.10.x">https://wasmedge.org/docs/embed/go/reference/0.10.x</a>. Please use our new docs.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="upgrade-to-wasmedge-go-v0110"><a class="header" href="#upgrade-to-wasmedge-go-v0110">Upgrade to WasmEdge-Go v0.11.0</a></h1>
<blockquote>
<p>This part has been moved to  <a href="https://wasmedge.org/docs/embed/go/reference/upgrade_to_0.11.0">https://wasmedge.org/docs/embed/go/reference/upgrade_to_0.11.0</a>. Please use our new docs.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="wasmedge-go-v091-api-documentation"><a class="header" href="#wasmedge-go-v091-api-documentation">WasmEdge Go v0.9.1 API Documentation</a></h1>
<blockquote>
<p>This part has been moved to  <a href="https://wasmedge.org/docs/embed/go/reference/0.9.x">https://wasmedge.org/docs/embed/go/reference/0.9.x</a>. Please use our new docs.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="upgrade-to-wasmedge-go-v0100"><a class="header" href="#upgrade-to-wasmedge-go-v0100">Upgrade to WasmEdge-Go v0.10.0</a></h1>
<blockquote>
<p>This part has been moved to  <a href="https://wasmedge.org/docs/embed/go/reference/upgrade_to_0.10.0">https://wasmedge.org/docs/embed/go/reference/upgrade_to_0.10.0</a>. Please use our new docs.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="nodejs-sdk"><a class="header" href="#nodejs-sdk">Node.js SDK</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="wasmedge-rust-sdk"><a class="header" href="#wasmedge-rust-sdk">WasmEdge Rust SDK</a></h1>
<blockquote>
<p>This part has been moved to  <a href="https://wasmedge.org/docs/embed/rust/intro">https://wasmedge.org/docs/embed/rust/intro</a>. Please use our new docs.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hello-world-1"><a class="header" href="#hello-world-1">Hello World</a></h1>
<p>In this example, we'll use a wasm module, in which a function <code>run</code> is exported and it will call a function <code>say_hello</code> from an import module named <code>env</code>. The imported function <code>say_hello</code> has no inputs and outputs, and only prints a greeting message out.</p>
<blockquote>
<p>The code in the following example is verified on</p>
<ul>
<li>wasmedge-sdk v0.5.0</li>
<li>wasmedge-sys v0.10.0</li>
<li>wasmedge-types v0.3.0</li>
</ul>
</blockquote>
<p>Let's start off by getting all imports right away so you can follow along</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// please add this feature if you're using rust of version &lt; 1.63
// #![feature(explicit_generic_args_with_impl_trait)]

#![feature(never_type)]

use wasmedge_sdk::{
    error::HostFuncError, host_function, params, wat2wasm, Caller, Executor, ImportObjectBuilder,
    Module, Store, WasmValue,
};

<span class="boring">}</span></code></pre></pre>
<h2 id="step-1-define-a-native-function-and-create-an-importobject"><a class="header" href="#step-1-define-a-native-function-and-create-an-importobject">Step 1: Define a native function and Create an ImportObject</a></h2>
<p>First, let's define a native function named <code>say_hello_world</code> that prints out <code>Hello, World!</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[host_function]
fn say_hello(caller: &amp;Caller, _args: Vec&lt;WasmValue&gt;) -&gt; Result&lt;Vec&lt;WasmValue&gt;, HostFuncError&gt; {
    println!(&quot;Hello, world!&quot;);

    Ok(vec![])
}
<span class="boring">}</span></code></pre></pre>
<p>To use the native function as an import function in the <code>WasmEdge</code> runtime, we need an <code>ImportObject</code>. <code>wasmedge-sdk</code> defines a <a href="https://wasmedge.github.io/WasmEdge/wasmedge_sdk/struct.ImportObjectBuilder.html">ImportObjectBuilder</a>, which provides a group of chaining methods used to create an <code>ImportObject</code>. Let's see how to do it.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// create an import module
let import = ImportObjectBuilder::new()
    .with_func::&lt;(), (), !&gt;(&quot;say_hello&quot;, say_hello, None)?
    .build(&quot;env&quot;)?;
<span class="boring">}</span></code></pre></pre>
<p>Now, we have an import module named <code>env</code> which holds a host function <code>say_hello</code>. As you may notice, the names we used for the import module and the host function are exactly the same as the ones appearing in the wasm module. You can find the wasm module in <a href="sdk/rust/say_hello.html#step-2-load-a-wasm-module">Step 2</a>.</p>
<h2 id="step-2-load-a-wasm-module"><a class="header" href="#step-2-load-a-wasm-module">Step 2: Load a wasm module</a></h2>
<p>Now, let's load a wasm module. <code>wasmedge-sdk</code> defines two methods in <code>Module</code>:</p>
<ul>
<li>
<p><a href="https://wasmedge.github.io/WasmEdge/wasmedge_sdk/struct.Module.html#method.from_file">from_file</a> loads a wasm module from a file, and meanwhile, validates the loaded wasm module.</p>
</li>
<li>
<p><a href="https://wasmedge.github.io/WasmEdge/wasmedge_sdk/struct.Module.html#method.from_bytes">from_bytes</a> loads a wasm module from an array of in-memory bytes, and meanwhile, validates the loaded wasm module.</p>
</li>
</ul>
<p>Here we choose <code>Module::from_bytes</code> method to load our wasm module from an array of in-memory bytes.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let wasm_bytes = wat2wasm(
    br#&quot;
(module
    ;; First we define a type with no parameters and no results.
    (type $no_args_no_rets_t (func (param) (result)))

    ;; Then we declare that we want to import a function named &quot;env&quot; &quot;say_hello&quot; with
    ;; that type signature.
    (import &quot;env&quot; &quot;say_hello&quot; (func $say_hello (type $no_args_no_rets_t)))

    ;; Finally we create an entrypoint that calls our imported function.
    (func $run (type $no_args_no_rets_t)
    (call $say_hello))
    ;; And mark it as an exported function named &quot;run&quot;.
    (export &quot;run&quot; (func $run)))
&quot;#,
)?;

// loads a wasm module from the given in-memory bytes and returns a compiled module
let module = Module::from_bytes(None, &amp;wasm_bytes)?;
<span class="boring">}</span></code></pre></pre>
<h2 id="step-3-register-import-module-and-compiled-module"><a class="header" href="#step-3-register-import-module-and-compiled-module">Step 3: Register import module and compiled module</a></h2>
<p>To register a compiled module, we need to check if it has dependency on some import modules. In the wasm module this statement <code>(import &quot;env&quot; &quot;say_hello&quot; (func $say_hello (type $no_args_no_rets_t)))</code> tells us that it depends on an import module named <code>env</code>. Therefore, we need to register the import module first before registering the compiled wasm module.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// loads a wasm module from the given in-memory bytes
let module = Module::from_bytes(None, &amp;wasm_bytes)?;

// create an executor
let mut executor = Executor::new(None, None)?;

// create a store
let mut store = Store::new()?;

// register the module into the store
store.register_import_module(&amp;mut executor, &amp;import)?;

// register the compiled module into the store and get an module instance
let extern_instance = store.register_named_module(&amp;mut executor, &quot;extern&quot;, &amp;module)?;
<span class="boring">}</span></code></pre></pre>
<p>In the code above we use <a href="https://wasmedge.github.io/WasmEdge/wasmedge_sdk/struct.Executor.html">Executor</a> and <a href="https://wasmedge.github.io/WasmEdge/wasmedge_sdk/struct.Store.html">Store</a> to register the import module and the compiled module. <code>wasmedge-sdk</code> also provides alternative APIs to do the same thing:
<a href="https://wasmedge.github.io/WasmEdge/wasmedge_sdk/struct.Vm.html#method.register_import_module">Vm::register_import_module</a> and <a href="https://wasmedge.github.io/WasmEdge/wasmedge_sdk/struct.Vm.html#method.register_module_from_bytes">Vm::register_module_from_bytes</a>.</p>
<h2 id="step-4-run-the-exported-function"><a class="header" href="#step-4-run-the-exported-function">Step 4: Run the exported function</a></h2>
<p>Now we are ready to run the exported function.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// get the exported function &quot;run&quot;
let run = extern_instance
    .func(&quot;run&quot;)
    .ok_or_else(|| anyhow::Error::msg(&quot;Not found exported function named 'run'.&quot;))?;

// run host function
run.call(&amp;mut executor, params!())?;
<span class="boring">}</span></code></pre></pre>
<p>In this example we created an instance of <code>Executor</code>, hence, we have two choices to call a <a href="https://wasmedge.github.io/WasmEdge/wasmedge_sdk/struct.Func.html">function instance</a>:</p>
<ul>
<li>
<p><a href="https://wasmedge.github.io/WasmEdge/wasmedge_sdk/struct.Func.html#method.call">Func::call</a></p>
</li>
<li>
<p><a href="https://wasmedge.github.io/WasmEdge/wasmedge_sdk/trait.Engine.html#tymethod.run_func">Executor::run_func</a></p>
</li>
</ul>
<p>Any one of these two methods requires that you have to get a <a href="https://wasmedge.github.io/WasmEdge/wasmedge_sdk/struct.Func.html">function instance</a>.</p>
<p>In addition, <a href="https://wasmedge.github.io/WasmEdge/wasmedge_sdk/struct.Vm.html">Vm</a> defines a group of methods which can invoke host function in different ways. For details, please reference <a href="https://wasmedge.github.io/WasmEdge/wasmedge_sdk/struct.Vm.html">Vm</a>.</p>
<p>The complete example can be found in <a href="https://github.com/WasmEdge/WasmEdge/blob/master/bindings/rust/wasmedge-sdk/examples/hello_world.rs">hello_world.rs</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="memory-manipulation"><a class="header" href="#memory-manipulation">Memory Manipulation</a></h1>
<p>In this example, we'll present how to manipulate the linear memory with the APIs defined in <a href="https://wasmedge.github.io/WasmEdge/wasmedge_sdk/struct.Memory.html">wasmedge_sdk::Memory</a>.</p>
<blockquote>
<p>The code in the following example is verified on</p>
<ul>
<li>wasmedge-sdk v0.5.0</li>
<li>wasmedge-sys v0.10.0</li>
<li>wasmedge-types v0.3.0</li>
</ul>
</blockquote>
<h2 id="wasm-module"><a class="header" href="#wasm-module">Wasm module</a></h2>
<p>Before talking about the code, let's first see the wasm module we use in this example. In the wasm module, a linear memory of 1-page (64KiB) size is defined; in addition, three functions are exported from this module: <code>get_at</code>, <code>set_at</code>, and <code>mem_size</code>.</p>
<pre><code class="language-wasm">(module
  (type $mem_size_t (func (result i32)))
  (type $get_at_t (func (param i32) (result i32)))
  (type $set_at_t (func (param i32) (param i32)))

  # A memory with initial size of 1 page
  (memory $mem 1)

  (func $get_at (type $get_at_t) (param $idx i32) (result i32)
    (i32.load (local.get $idx)))

  (func $set_at (type $set_at_t) (param $idx i32) (param $val i32)
    (i32.store (local.get $idx) (local.get $val)))

  (func $mem_size (type $mem_size_t) (result i32)
    (memory.size))
  
  # Exported functions
  (export &quot;get_at&quot; (func $get_at))
  (export &quot;set_at&quot; (func $set_at))
  (export &quot;mem_size&quot; (func $mem_size))
  (export &quot;memory&quot; (memory $mem)))
</code></pre>
<p>Next, we'll demonstrate how to manipulate the linear memory by calling the exported functions.</p>
<h2 id="load-and-register-module"><a class="header" href="#load-and-register-module">Load and Register Module</a></h2>
<p>Let's start off by getting all imports right away so you can follow along</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// please add this feature if you're using rust of version &lt; 1.63
// #![feature(explicit_generic_args_with_impl_trait)]

use wasmedge_sdk::{params, wat2wasm, Executor, Module, Store, WasmVal};
<span class="boring">}</span></code></pre></pre>
<p>To load a <code>Module</code>, <code>wasmedge-sdk</code> defines two methods:</p>
<ul>
<li>
<p><a href="https://wasmedge.github.io/WasmEdge/wasmedge_sdk/struct.Module.html#method.from_file">from_file</a> loads a wasm module from a file, and meanwhile, validates the loaded wasm module.</p>
</li>
<li>
<p><a href="https://wasmedge.github.io/WasmEdge/wasmedge_sdk/struct.Module.html#method.from_bytes">from_bytes</a> loads a wasm module from an array of in-memory bytes, and meanwhile, validates the loaded wasm module.</p>
</li>
</ul>
<p>Here we use <code>Module::from_bytes</code> method to load our wasm module from an array of in-memory bytes.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let wasm_bytes = wat2wasm(
        r#&quot;
(module
  (type $mem_size_t (func (result i32)))
  (type $get_at_t (func (param i32) (result i32)))
  (type $set_at_t (func (param i32) (param i32)))

  (memory $mem 1)

  (func $get_at (type $get_at_t) (param $idx i32) (result i32)
    (i32.load (local.get $idx)))

  (func $set_at (type $set_at_t) (param $idx i32) (param $val i32)
    (i32.store (local.get $idx) (local.get $val)))

  (func $mem_size (type $mem_size_t) (result i32)
    (memory.size))

  (export &quot;get_at&quot; (func $get_at))
  (export &quot;set_at&quot; (func $set_at))
  (export &quot;mem_size&quot; (func $mem_size))
  (export &quot;memory&quot; (memory $mem)))
&quot;#
    .as_bytes(),
)?;

// loads a wasm module from the given in-memory bytes
let module = Module::from_bytes(None, &amp;wasm_bytes)?;
<span class="boring">}</span></code></pre></pre>
<p>The module returned by <code>Module::from_bytes</code> is a compiled module, also called AST Module in WasmEdge terminology. To use it in WasmEdge runtime environment, we need to instantiate the AST module. We use <a href="https://wasmedge.github.io/WasmEdge/wasmedge_sdk/struct.Store.html#method.register_named_module">Store::register_named_module</a> API to achieve the goal.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// create an executor
let mut executor = Executor::new(None, None)?;

// create a store
let mut store = Store::new()?;

// register the module into the store
let extern_instance = store.register_named_module(&amp;mut executor, &quot;extern&quot;, &amp;module)?;
<span class="boring">}</span></code></pre></pre>
<p>In the code above, we register the AST module into a <code>Store</code>, in which the module is instantiated, and as a result, a <a href="https://wasmedge.github.io/WasmEdge/wasmedge_sdk/struct.Instance.html">module instance</a> named <code>extern</code> is returned.</p>
<h2 id="memory"><a class="header" href="#memory">Memory</a></h2>
<p>In the previous section, we get an instance by registering a compiled module into the runtime environment. Now we retrieve the memory instance from the module instance, and make use of the APIs defined in <a href="https://wasmedge.github.io/WasmEdge/wasmedge_sdk/struct.Memory.html">Memory</a> to manipulate the linear memory.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// get the exported memory instance
let mut memory = extern_instance
    .memory(&quot;memory&quot;)
    .ok_or_else(|| anyhow::anyhow!(&quot;failed to get memory instance named 'memory'&quot;))?;

// check memory size
assert_eq!(memory.size(), 1);
assert_eq!(memory.data_size(), 65536);

// grow memory size
memory.grow(2)?;
assert_eq!(memory.size(), 3);
assert_eq!(memory.data_size(), 3 * 65536);

// get the exported functions: &quot;set_at&quot; and &quot;get_at&quot;
let set_at = extern_instance
    .func(&quot;set_at&quot;)
    .ok_or_else(|| anyhow::Error::msg(&quot;Not found exported function named 'set_at'.&quot;))?;
let get_at = extern_instance
    .func(&quot;get_at&quot;)
    .ok_or_else(|| anyhow::Error::msg(&quot;Not found exported function named 'get_at`.&quot;))?;

// call the exported function named &quot;set_at&quot;
let mem_addr = 0x2220;
let val = 0xFEFEFFE;
set_at.call(&amp;mut executor, params!(mem_addr, val))?;

// call the exported function named &quot;get_at&quot;
let returns = get_at.call(&amp;mut executor, params!(mem_addr))?;
assert_eq!(returns[0].to_i32(), val);

// call the exported function named &quot;set_at&quot;
let page_size = 0x1_0000;
let mem_addr = (page_size * 2) - std::mem::size_of_val(&amp;val) as i32;
let val = 0xFEA09;
set_at.call(&amp;mut executor, params!(mem_addr, val))?;

// call the exported function named &quot;get_at&quot;
let returns = get_at.call(&amp;mut executor, params!(mem_addr))?;
assert_eq!(returns[0].to_i32(), val);
<span class="boring">}</span></code></pre></pre>
<p>The comments in the code explain the meaning of the code sample above, so we don't describe more.</p>
<p>The complete code of this example can be found in <a href="https://github.com/WasmEdge/WasmEdge/blob/master/bindings/rust/wasmedge-sdk/examples/memory.rs">memory.rs</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="table-and-funcref"><a class="header" href="#table-and-funcref">Table and FuncRef</a></h1>
<p>In this example, we'll present how to use <a href="https://wasmedge.github.io/WasmEdge/wasmedge_sdk/struct.Table.html">Table</a> and <a href="https://wasmedge.github.io/WasmEdge/wasmedge_sdk/struct.FuncRef.html">FuncRef</a> stored in a slot of a <code>Table</code> instance to implement indirect function invocation.</p>
<blockquote>
<p>The code in the following example is verified on</p>
<ul>
<li>wasmedge-sdk v0.5.0</li>
<li>wasmedge-sys v0.10.0</li>
<li>wasmedge-types v0.3.0</li>
</ul>
</blockquote>
<p>Let's start off by getting all imports right away so you can follow along</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// If the version of rust used is less than v1.63, please uncomment the follow attribute.
// #![feature(explicit_generic_args_with_impl_trait)]

#![feature(never_type)]

use wasmedge_sdk::{
    config::{CommonConfigOptions, ConfigBuilder},
    error::HostFuncError,
    host_function, params,
    types::Val,
    Caller, Executor, Func, ImportObjectBuilder, RefType, Store, Table, TableType, ValType,
    WasmVal, WasmValue,
};
<span class="boring">}</span></code></pre></pre>
<h2 id="define-host-function"><a class="header" href="#define-host-function">Define host function</a></h2>
<p>In this example we defines a native function <code>real_add</code> that takes two numbers and returns their sum. This function will be registered as a host function into WasmEdge runtime environment</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[host_function]
fn real_add(_caller: &amp;Caller, input: Vec&lt;WasmValue&gt;) -&gt; Result&lt;Vec&lt;WasmValue&gt;, HostFuncError&gt; {
    println!(&quot;Rust: Entering Rust function real_add&quot;);

    if input.len() != 2 {
        return Err(HostFuncError::User(1));
    }

    let a = if input[0].ty() == ValType::I32 {
        input[0].to_i32()
    } else {
        return Err(HostFuncError::User(2));
    };

    let b = if input[1].ty() == ValType::I32 {
        input[1].to_i32()
    } else {
        return Err(HostFuncError::User(3));
    };

    let c = a + b;
    println!(&quot;Rust: calculating in real_add c: {:?}&quot;, c);

    println!(&quot;Rust: Leaving Rust function real_add&quot;);
    Ok(vec![WasmValue::from_i32(c)])
}
<span class="boring">}</span></code></pre></pre>
<h2 id="register-table-instance"><a class="header" href="#register-table-instance">Register Table instance</a></h2>
<p>The first thing we need to do is to create a <code>Table</code> instance. After that, we register the table instance along with an import module into the WasmEdge runtime environment. Now let's see the code.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// create an executor
let config = ConfigBuilder::new(CommonConfigOptions::default()).build()?;
let mut executor = Executor::new(Some(&amp;config), None)?;

// create a store
let mut store = Store::new()?;

// create a table instance
let result = Table::new(TableType::new(RefType::FuncRef, 10, Some(20)));
assert!(result.is_ok());
let table = result.unwrap();

// create an import object
let import = ImportObjectBuilder::new()
    .with_table(&quot;my-table&quot;, table)?
    .build(&quot;extern&quot;)?;

// register the import object into the store
store.register_import_module(&amp;mut executor, &amp;import)?;
<span class="boring">}</span></code></pre></pre>
<p>In the code snippet above, we create a <code>Table</code> instance with the initial size of <code>10</code> and the maximum size of 20. The element type of the <code>Table</code> instance is <code>reference to function</code>.</p>
<h2 id="store-a-function-reference-into-table"><a class="header" href="#store-a-function-reference-into-table">Store a function reference into Table</a></h2>
<p>In the previous steps, we defined a native function <code>real_add</code> and registered a <code>Table</code> instance named <code>my-table</code> into the runtime environment. Now we'll save a reference to <code>read_add</code> function to a slot of <code>my-table</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// get the imported module instance
let instance = store
    .module_instance(&quot;extern&quot;)
    .expect(&quot;Not found module instance named 'extern'&quot;);

// get the exported table instance
let mut table = instance
    .table(&quot;my-table&quot;)
    .expect(&quot;Not found table instance named 'my-table'&quot;);

// create a host function
let host_func = Func::wrap::&lt;(i32, i32), i32, !&gt;(Box::new(real_add), None)?;

// store the reference to host_func at the given index of the table instance
table.set(3, Val::FuncRef(Some(host_func.as_ref())))?;
<span class="boring">}</span></code></pre></pre>
<p>We save the reference to <code>host_func</code> into the third slot of <code>my-table</code>. Next, we can retrieve the function reference from the table instance by index and call the function via its reference.</p>
<h2 id="call-native-function-via-funcref"><a class="header" href="#call-native-function-via-funcref">Call native function via <code>FuncRef</code></a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// retrieve the function reference at the given index of the table instance
let value = table.get(3)?;
if let Val::FuncRef(Some(func_ref)) = value {
    // get the function type by func_ref
    let func_ty = func_ref.ty()?;

    // arguments
    assert_eq!(func_ty.args_len(), 2);
    let param_tys = func_ty.args().unwrap();
    assert_eq!(param_tys, [ValType::I32, ValType::I32]);

    // returns
    assert_eq!(func_ty.returns_len(), 1);
    let return_tys = func_ty.returns().unwrap();
    assert_eq!(return_tys, [ValType::I32]);

    // call the function by func_ref
    let returns = func_ref.call(&amp;mut executor, params!(1, 2))?;
    assert_eq!(returns.len(), 1);
    assert_eq!(returns[0].to_i32(), 3);
}
<span class="boring">}</span></code></pre></pre>
<p>The complete code of this example can be found in <a href="https://github.com/WasmEdge/WasmEdge/blob/master/bindings/rust/wasmedge-sdk/examples/table_and_funcref.rs">table_and_funcref.rs</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="run-a-webassembly-function-with-wasmedge-low-level-rust-apis"><a class="header" href="#run-a-webassembly-function-with-wasmedge-low-level-rust-apis">Run a WebAssembly function with WasmEdge low-level Rust APIs</a></h1>
<h2 id="overview"><a class="header" href="#overview">Overview</a></h2>
<p>This section demonstrates how to use the Rust APIs of the <code>wasmedge-sys</code> crate to run a host function.</p>
<p>As you may know, several mainstream programming languages, such as C/C++, Rust, Go, and Python, support compiling their programs into WebAssembly binary. In this demo, we'll introduce how to use the APIs defined in <code>Vm</code> of <code>wasmedge-sys</code> crate to call a WebAssembly function which could be coded in any programming language mentioned above.</p>
<blockquote>
<p>The code in the example is verified on</p>
<ul>
<li>wasmedge-sys v0.10.0</li>
<li>wasmedge-types v0.3.0</li>
</ul>
</blockquote>
<h2 id="example"><a class="header" href="#example">Example</a></h2>
<p>We use <code>fibonacci.wasm</code> in this demo, and the contents of the WebAssembly file are presented below. The statement, <code>(export &quot;fib&quot; (func $fib))</code>, declares an exported function named <code>fib</code>. This function computes a Fibonacci number with a given <code>i32</code> number as input. We'll use the function name later to achieve the goal of computing a Fibonacci number.</p>
<pre><code class="language-wasm">(module
  (export &quot;fib&quot; (func $fib))
  (func $fib (param $n i32) (result i32)
    (if
      (i32.lt_s
        (get_local $n)
        (i32.const 2)
      )
      (return
        (i32.const 1)
      )
    )
    (return
      (i32.add
        (call $fib
          (i32.sub
            (get_local $n)
            (i32.const 2)
          )
        )
        (call $fib
          (i32.sub
            (get_local $n)
            (i32.const 1)
          )
        )
      )
    )
  )
)
</code></pre>
<h3 id="step-1-create-a-wasmedge-ast-module"><a class="header" href="#step-1-create-a-wasmedge-ast-module">Step 1: Create a WasmEdge AST Module</a></h3>
<p>In this step,  we'll create a WasmEdge <code>AST Module</code> instance from a WebAssembly file.</p>
<ul>
<li>
<p>First, create a <code>Loader</code> context;</p>
</li>
<li>
<p>Then, load a specified WebAssebly file (&quot;fibonacci.wasm&quot;) via the <code>from_file</code> method of the <code>Loader</code> context. If the process is successful, then a WasmEdge <code>AST Module</code> instance is returned.</p>
</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use wasmedge_sys::Loader;
use std::path::PathBuf;

// create a Loader context
let loader = Loader::create(None).expect(&quot;fail to create a Loader context&quot;);

// load a wasm module from a specified wasm file, and return a WasmEdge AST Module instance
let path = PathBuf::from(&quot;fibonacci.wasm&quot;);
let module = loader.from_file(path).expect(&quot;fail to load the WebAssembly file&quot;);
<span class="boring">}</span></code></pre></pre>
<h3 id="step-2-create-a-wasmedge-vm-context"><a class="header" href="#step-2-create-a-wasmedge-vm-context">Step 2: Create a WasmEdge <code>Vm</code> context</a></h3>
<p>In WasmEdge, a <code>Vm</code> defines a running environment, in which all varieties of instances and contexts are stored and maintained. In the demo code below, we explicitly create a WasmEdge <code>Store</code> context, and then use it as one of the inputs in the creation of a <code>Vm</code> context. If not specify a <code>Store</code> context explicitly, then <code>Vm</code> will create a store by itself.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use wasmedge_sys::{Config, Store, Vm};

// create a Config context
let config = Config::create().expect(&quot;fail to create a Config context&quot;);

// create a Store context
let mut store = Store::create().expect(&quot;fail to create a Store context&quot;);

// create a Vm context with the given Config and Store
let mut vm = Vm::create(Some(config), Some(&amp;mut store)).expect(&quot;fail to create a Vm context&quot;);
<span class="boring">}</span></code></pre></pre>
<h3 id="step-3-invoke-the-fib-function"><a class="header" href="#step-3-invoke-the-fib-function">Step 3: Invoke the <code>fib</code> function</a></h3>
<p>In Step 1, we got a module that hosts the target <code>fib</code> function defined in the WebAssembly. Now, we can call the function via the <code>run_wasm_from_module</code> method of the <code>Vm</code> context by passing the exported function name, <code>fib</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use wasmedge_sys::WasmValue;

// run a function
let returns = vm.run_wasm_from_module(module, &quot;fib&quot;, [WasmValue::from_i32(5)]).expect(&quot;fail to run the target function in the module&quot;);

println!(&quot;The result of fib(5) is {}&quot;, returns[0].to_i32());
<span class="boring">}</span></code></pre></pre>
<p>This is the final result printing on the screen:</p>
<pre><code class="language-bash">The result of fib(5) is 8
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="compute-fibonacci-numbers-concurrently"><a class="header" href="#compute-fibonacci-numbers-concurrently">Compute Fibonacci numbers concurrently</a></h1>
<h2 id="overview-1"><a class="header" href="#overview-1">Overview</a></h2>
<p>In this example, we will demonstrate how to use the objects and the APIs defined in <code>wasmedge-sys</code> to compute Fibonacci numbers concurrently. we creates two child threads, <code>thread_a</code> and <code>thread_b</code>, which are responsible for compute <code>Fib(4)</code> and <code>Fib(5)</code> by calling the host function <code>fib</code>, respectively. After that, the main thread computes <code>Fib(6)</code> by adding the numbers returned by <code>thread_a</code> and <code>thread_b</code>.</p>
<blockquote>
<p>The code in the example is verified on</p>
<ul>
<li>wasmedge-sys v0.10.0</li>
<li>wasmedge-types v0.3.0</li>
</ul>
</blockquote>
<h3 id="step-1-create-a-vm-context-and-register-the-webassembly-module"><a class="header" href="#step-1-create-a-vm-context-and-register-the-webassembly-module">Step 1: create a Vm context and register the WebAssembly module</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// create a Config context
let mut config = Config::create()?;
config.bulk_memory_operations(true);

// create a Store context
let mut store = Store::create()?;

// create a Vm context with the given Config and Store
let mut vm = Vm::create(Some(config), Some(&amp;mut store))?;

// register a wasm module from a wasm file
let file = std::path::PathBuf::from(env!(&quot;WASMEDGE_DIR&quot;))
    .join(&quot;bindings/rust/wasmedge-sys/tests/data/fibonacci.wasm&quot;);
vm.register_wasm_from_file(&quot;extern&quot;, file)?;

<span class="boring">}</span></code></pre></pre>
<h3 id="step-2-create-two-child-threads-to-compute-fib4-and-fib5-respectively"><a class="header" href="#step-2-create-two-child-threads-to-compute-fib4-and-fib5-respectively">Step 2: create two child threads to compute <code>Fib(4)</code> and <code>Fib(5)</code> respectively</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let vm = Arc::new(Mutex::new(vm));

// compute fib(4) by a child thread
let vm_cloned = Arc::clone(&amp;vm);
let handle_a = thread::spawn(move || {
    let vm_child_thread = vm_cloned.lock().expect(&quot;fail to lock vm&quot;);
    let returns = vm_child_thread
        .run_registered_function(&quot;extern&quot;, &quot;fib&quot;, [WasmValue::from_i32(4)])
        .expect(&quot;fail to compute fib(4)&quot;);

    let fib4 = returns[0].to_i32();
    println!(&quot;fib(4) by child thread: {}&quot;, fib4);

    fib4
});

// compute fib(5) by a child thread
let vm_cloned = Arc::clone(&amp;vm);
let handle_b = thread::spawn(move || {
    let vm_child_thread = vm_cloned.lock().expect(&quot;fail to lock vm&quot;);
    let returns = vm_child_thread
        .run_registered_function(&quot;extern&quot;, &quot;fib&quot;, [WasmValue::from_i32(5)])
        .expect(&quot;fail to compute fib(5)&quot;);

    let fib5 = returns[0].to_i32();
    println!(&quot;fib(5) by child thread: {}&quot;, fib5);

    fib5
});

<span class="boring">}</span></code></pre></pre>
<h3 id="step3-get-the-returns-from-the-two-child-threads-and-compute-fib6"><a class="header" href="#step3-get-the-returns-from-the-two-child-threads-and-compute-fib6">Step3: Get the returns from the two child threads, and compute <code>Fib(6)</code></a></h3>
<pre><code class="language-Rust">let fib4 = handle_a.join().unwrap();
let fib5 = handle_b.join().unwrap();

// compute fib(6)
println!(&quot;fib(6) = fib(5) + fib(1) = {}&quot;, fib5 + fib4);
</code></pre>
<p>The final result of the code above should be printed on the screen like below:</p>
<pre><code class="language-bash">fib(4) by child thread: 5
fib(5) by child thread: 8
fib(6) = fib(5) + fib(1) = 13
</code></pre>
<p>The complete code in this demo can be found in <a href="https://github.com/WasmEdge/WasmEdge/blob/master/bindings/rust/wasmedge-sys/examples/threads.rs">threads.rs</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="introduction-to-wasmedge-module-instance"><a class="header" href="#introduction-to-wasmedge-module-instance">Introduction to WasmEdge module instance</a></h1>
<blockquote>
<p>The code in the following examples are verified on</p>
<ul>
<li>wasmedge-sys v0.10.0</li>
<li>wasmedge-types v0.3.0</li>
</ul>
</blockquote>
<h2 id="example-1"><a class="header" href="#example-1">Example 1</a></h2>
<p>In this example, we'll demonstrate how to use the APIs of <code>Vm</code> to</p>
<ul>
<li>
<p>Create Wasi and WasmEdgeProcess module instances implicitly by using a <code>Config</code> while creating a <code>Vm</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// create a Config context
let mut config = Config::create()?;
config.bulk_memory_operations(true);
assert!(config.bulk_memory_operations_enabled());
config.wasi(true);
assert!(config.wasi_enabled());
config.wasmedge_process(true);
assert!(config.wasmedge_process_enabled());

// create a Vm context with the given Config and Store
let mut vm = Vm::create(Some(config), None)?;

<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p>Retrieve the Wasi and WasmEdgeProcess module instances from the <code>Vm</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// get the default Wasi module
let wasi_instance = vm.wasi_module_mut()?;
assert_eq!(wasi_instance.name(), &quot;wasi_snapshot_preview1&quot;);
// get the default WasmEdgeProcess module instance
let wasmedge_process_instance = vm.wasmedge_process_module_mut()?;
assert_eq!(wasmedge_process_instance.name(), &quot;wasmedge_process&quot;);

<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p>Register an import module as a named module into the <code>Vm</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// create ImportModule instance
let module_name = &quot;extern_module&quot;;
let mut import = ImportModule::create(module_name)?;

// a function to import
#[sys_host_function]
fn real_add(_frame: &amp;CallingFrame, inputs: Vec&lt;WasmValue&gt;) -&gt; Result&lt;Vec&lt;WasmValue&gt;, u8&gt; {
    if inputs.len() != 2 {
        return Err(1);
    }

    let a = if inputs[0].ty() == ValType::I32 {
        inputs[0].to_i32()
    } else {
        return Err(2);
    };

    let b = if inputs[1].ty() == ValType::I32 {
        inputs[1].to_i32()
    } else {
        return Err(3);
    };

    let c = a + b;

    Ok(vec![WasmValue::from_i32(c)])
}

// add host function
let func_ty = FuncType::create(vec![ValType::I32; 2], vec![ValType::I32])?;
let host_func = Function::create(&amp;func_ty, Box::new(real_add), 0)?;
import.add_func(&quot;add&quot;, host_func);

// add table
let table_ty = TableType::create(RefType::FuncRef, 0..=u32::MAX)?;
let table = Table::create(&amp;table_ty)?;
import.add_table(&quot;table&quot;, table);

// add memory
let mem_ty = MemType::create(0..=u32::MAX)?;
let memory = Memory::create(&amp;mem_ty)?;
import.add_memory(&quot;mem&quot;, memory);

// add global
let ty = GlobalType::create(ValType::F32, Mutability::Const)?;
let global = Global::create(&amp;ty, WasmValue::from_f32(3.5))?;
import.add_global(&quot;global&quot;, global);

// register the import module as a named module
vm.register_wasm_from_import(ImportObject::Import(import))?;

<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p>Retrieve the internal <code>Store</code> instance from the <code>Vm</code>, and retrieve the named module instance from the <code>Store</code> instance.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut store = vm.store_mut()?;
let named_instance = store.module(module_name)?;
assert!(named_instance.get_func(&quot;add&quot;).is_ok());
assert!(named_instance.get_table(&quot;table&quot;).is_ok());
assert!(named_instance.get_memory(&quot;mem&quot;).is_ok());
assert!(named_instance.get_global(&quot;global&quot;).is_ok());

<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p>Register an active module into the <code>Vm</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// read the wasm bytes
let wasm_bytes = wat2wasm(
    br#&quot;
    (module
      (export &quot;fib&quot; (func $fib))
      (func $fib (param $n i32) (result i32)
        (if
          (i32.lt_s
            (get_local $n)
            (i32.const 2)
          )
          (return
            (i32.const 1)
          )
        )
        (return
          (i32.add
            (call $fib
              (i32.sub
                (get_local $n)
                (i32.const 2)
              )
            )
            (call $fib
              (i32.sub
                (get_local $n)
                (i32.const 1)
              )
            )
          )
        )
      )
    )
&quot;#,
)?;

// load a wasm module from a in-memory bytes, and the loaded wasm module works as an anonymous
// module (aka. active module in WasmEdge terminology)
vm.load_wasm_from_bytes(&amp;wasm_bytes)?;

// validate the loaded active module
vm.validate()?;

// instantiate the loaded active module
vm.instantiate()?;

// get the active module instance
let active_instance = vm.active_module()?;
assert!(active_instance.get_func(&quot;fib&quot;).is_ok());
    
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p>Retrieve the active module from the <code>Vm</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// get the active module instance
let active_instance = vm.active_module()?;
assert!(active_instance.get_func(&quot;fib&quot;).is_ok());

<span class="boring">}</span></code></pre></pre>
</li>
</ul>
<p>The complete code in this demo can be found on <a href="https://github.com/WasmEdge/WasmEdge/blob/master/bindings/rust/wasmedge-sys/examples/mdbook_example_module_instance.rs">WasmEdge Github</a>.</p>
<h2 id="example-2"><a class="header" href="#example-2">Example 2</a></h2>
<p>In this example, we'll demonstrate how to use the APIs of <code>Executor</code> to</p>
<ul>
<li>
<p>Create an <code>Executor</code> and a <code>Store</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// create an Executor context
let mut executor = Executor::create(None, None)?;

// create a Store context
let mut store = Store::create()?;

<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p>Register an import module into the <code>Executor</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// read the wasm bytes
let wasm_bytes = wat2wasm(
    br#&quot;
    (module
      (export &quot;fib&quot; (func $fib))
      (func $fib (param $n i32) (result i32)
        (if
          (i32.lt_s
            (get_local $n)
            (i32.const 2)
          )
          (return
            (i32.const 1)
          )
        )
        (return
          (i32.add
            (call $fib
              (i32.sub
                (get_local $n)
                (i32.const 2)
              )
            )
            (call $fib
              (i32.sub
                (get_local $n)
                (i32.const 1)
              )
            )
          )
        )
      )
    )
&quot;#,
)?;

// load module from a wasm file
let config = Config::create()?;
let loader = Loader::create(Some(config))?;
let module = loader.from_bytes(&amp;wasm_bytes)?;

// validate module
let config = Config::create()?;
let validator = Validator::create(Some(config))?;
validator.validate(&amp;module)?;

// register a wasm module into the store context
let module_name = &quot;extern&quot;;
let named_instance = executor.register_named_module(&amp;mut store, &amp;module, module_name)?;
assert!(named_instance.get_func(&quot;fib&quot;).is_ok());

<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p>Register an active module into the <code>Executor</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// read the wasm bytes
let wasm_bytes = wat2wasm(
    br#&quot;
    (module
      (export &quot;fib&quot; (func $fib))
      (func $fib (param $n i32) (result i32)
        (if
          (i32.lt_s
            (get_local $n)
            (i32.const 2)
          )
          (return
            (i32.const 1)
          )
        )
        (return
          (i32.add
            (call $fib
              (i32.sub
                (get_local $n)
                (i32.const 2)
              )
            )
            (call $fib
              (i32.sub
                (get_local $n)
                (i32.const 1)
              )
            )
          )
        )
      )
    )
&quot;#,
)?;

// load module from a wasm file
let config = Config::create()?;
let loader = Loader::create(Some(config))?;
let module = loader.from_bytes(&amp;wasm_bytes)?;

// validate module
let config = Config::create()?;
let validator = Validator::create(Some(config))?;
validator.validate(&amp;module)?;

// register a wasm module as an active module
let active_instance = executor.register_active_module(&amp;mut store, &amp;module)?;
assert!(active_instance.get_func(&quot;fib&quot;).is_ok());

<span class="boring">}</span></code></pre></pre>
</li>
</ul>
<p>The complete code in this demo can be found in <a href="https://github.com/WasmEdge/WasmEdge/blob/master/bindings/rust/wasmedge-sys/examples/mdbook_example_module_instance.rs">mdbook_example_module_instance.rs</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="wasmedge-python-sdk"><a class="header" href="#wasmedge-python-sdk">WasmEdge Python SDK</a></h1>
<p>Coming soon, or you can <a href="https://github.com/WasmEdge/WasmEdge/pull/633">help out</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="wasmedge-command-line-tools"><a class="header" href="#wasmedge-command-line-tools">WasmEdge Command Line Tools</a></h1>
<blockquote>
<p>This part has been moved to <a href="https://wasmedge.org/docs/start/build-and-run/cli">https://wasmedge.org/docs/start/build-and-run/cli</a>. Please use our new docs.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="wasmedge-cli"><a class="header" href="#wasmedge-cli"><code>wasmedge</code> CLI</a></h1>
<p>This part has been moved to <a href="https://wasmedge.org/docs/start/build-and-run/cli">https://wasmedge.org/docs/start/build-and-run/cli</a>. Please use our new docs.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="wasmedge-compile-cli"><a class="header" href="#wasmedge-compile-cli"><code>wasmedge compile</code> CLI</a></h1>
<blockquote>
<p>This part has been moved to <a href="https://wasmedge.org/docs/start/build-and-run/aot">https://wasmedge.org/docs/start/build-and-run/aot</a>. Please use our new docs.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="wasmedge-run-cli"><a class="header" href="#wasmedge-run-cli"><code>wasmedge run</code> CLI</a></h1>
<blockquote>
<p>This part has been moved to <a href="https://wasmedge.org/docs/start/build-and-run/run">https://wasmedge.org/docs/start/build-and-run/run</a>. Please use our new docs.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="develop-wasmedge-plug-in"><a class="header" href="#develop-wasmedge-plug-in">Develop WasmEdge Plug-in</a></h1>
<blockquote>
<p>This Part has been moved to <a href="https://wasmedge.org/docs/contribute/plugin/intro">https://wasmedge.org/docs/contribute/plugin/intro</a>, Please use our new docs..</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="develop-wasmedge-plug-in-in-c-api"><a class="header" href="#develop-wasmedge-plug-in-in-c-api">Develop WasmEdge Plug-in in C API</a></h1>
<p>This part has been moved to <a href="https://wasmedge.org/docs/contribute/plugin/develop_plugin_c">https://wasmedge.org/docs/contribute/plugin/develop_plugin_c</a>. Please use our new docs.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="develop-wasmedge-plug-in-in-c-api-1"><a class="header" href="#develop-wasmedge-plug-in-in-c-api-1">Develop WasmEdge Plug-in in C++ API</a></h1>
<p>This part has been moved to <a href="https://wasmedge.org/docs/contribute/plugin/develop_plugin_cpp">https://wasmedge.org/docs/contribute/plugin/develop_plugin_cpp</a>. Please use our new docs.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="contribute-to-wasmedge"><a class="header" href="#contribute-to-wasmedge">Contribute to WasmEdge</a></h1>
<blockquote>
<p>This part has been moved to <a href="https://wasmedge.org/docs/contribute/">https://wasmedge.org/docs/contribute/</a>. Please use our new docs.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="wasmedge-release-process"><a class="header" href="#wasmedge-release-process">WasmEdge Release Process</a></h1>
<blockquote>
<p>This part has been moved to <a href="https://wasmedge.org/docs/contribute/release">https://wasmedge.org/docs/contribute/release</a>. Please use our new docs.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="contribution-steps"><a class="header" href="#contribution-steps">Contribution Steps</a></h1>
<blockquote>
<p>This part has been moved to  <a href="https://wasmedge.org/docs/contribute/">https://wasmedge.org/docs/contribute/</a>. Please use our new docs.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="build-wasmedge-from-source"><a class="header" href="#build-wasmedge-from-source">Build WasmEdge from source</a></h1>
<blockquote>
<p>This part has been moved to <a href="https://wasmedge.org/docs/contribute/source/build_from_src">https://wasmedge.org/docs/contribute/source/build_from_src</a>. Please use our new docs.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="build-wasmedge-on-linux"><a class="header" href="#build-wasmedge-on-linux">Build WasmEdge on Linux</a></h1>
<blockquote>
<p>This part has been moved to  <a href="https://wasmedge.org/docs/contribute/source/os/linux">https://wasmedge.org/docs/contribute/source/os/linux</a>. Please use our new docs.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="build-wasmedge-on-macos"><a class="header" href="#build-wasmedge-on-macos">Build WasmEdge on MacOS</a></h1>
<blockquote>
<p>This part has been moved to  <a href="https://wasmedge.org/docs/contribute/source/os/macos">https://wasmedge.org/docs/contribute/source/os/macos</a>. Please use our new docs.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="build-wasmedge-on-windows-10"><a class="header" href="#build-wasmedge-on-windows-10">Build WasmEdge on Windows 10</a></h1>
<blockquote>
<p>This part has been moved to  <a href="https://wasmedge.org/docs/contribute/source/os/windows">https://wasmedge.org/docs/contribute/source/os/windows</a>. Please use our new docs.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="build-wasmedge-for-android"><a class="header" href="#build-wasmedge-for-android">Build WasmEdge for Android</a></h1>
<blockquote>
<p>This part has been moved to  <a href="https://wasmedge.org/docs/contribute/source/os/android/build">https://wasmedge.org/docs/contribute/source/os/android/build</a>. Please use our new docs.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="wasmedge-cli-tools-for-android"><a class="header" href="#wasmedge-cli-tools-for-android">WasmEdge CLI tools for Android</a></h1>
<blockquote>
<p>This part has been moved to  <a href="https://wasmedge.org/docs/contribute/source/os/android/cli">https://wasmedge.org/docs/contribute/source/os/android/cli</a>. Please use our new docs.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="call-wasmedge-functions-from-an-ndk-native-app"><a class="header" href="#call-wasmedge-functions-from-an-ndk-native-app">Call WasmEdge functions from an NDK native app</a></h1>
<blockquote>
<p><em>This part has moved to <a href="https://wasmedge.org/docs/contribute/source/os/android/ndk">https://wasmedge.org/docs/contribute/source/os/android/ndk</a>. Please use our new docs.</em></p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="call-wasmedge-functions-from-an-android-apk-app"><a class="header" href="#call-wasmedge-functions-from-an-android-apk-app">Call WasmEdge functions from an Android APK app</a></h1>
<blockquote>
<p>This part has been moved to  <a href="https://wasmedge.org/docs/contribute/source/os/android/apk">https://wasmedge.org/docs/contribute/source/os/android/apk</a>. Please use our new docs.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="build-wasmedge-for-sel4"><a class="header" href="#build-wasmedge-for-sel4">Build WasmEdge for seL4</a></h1>
<p>This part hs moved to <a href="https://wasmedge.org/docs/contribute/source/os/sel4">https://wasmedge.org/docs/contribute/source/os/sel4</a>. Please use our new docs.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="build-wasmedge-for-open-harmony"><a class="header" href="#build-wasmedge-for-open-harmony">Build WasmEdge for Open Harmony</a></h1>
<p>WIP. For Chinese speakers, please <a href="https://github.com/WasmEdge/WasmEdge/blob/master/utils/ohos/README-zh.md">check out this instruction</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="build-wasmedge-for-raspberry-pi-34"><a class="header" href="#build-wasmedge-for-raspberry-pi-34">Build WasmEdge for Raspberry Pi 3/4</a></h1>
<blockquote>
<p>This part has been moved to  <a href="https://wasmedge.org/docs/contribute/source/os/raspberrypi">https://wasmedge.org/docs/contribute/source/os/raspberrypi</a>. Please use our new docs.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="build-and-test-wasmedge-for-openwrt"><a class="header" href="#build-and-test-wasmedge-for-openwrt">Build and test WasmEdge for OpenWrt</a></h1>
<blockquote>
<p>This part has been moved to  <a href="https://wasmedge.org/docs/contribute/source/os/openwrt">https://wasmedge.org/docs/contribute/source/os/openwrt</a>. Please use our new docs.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="build-wasmedge-with-wasi-crypto-plug-in"><a class="header" href="#build-wasmedge-with-wasi-crypto-plug-in">Build WasmEdge With WASI-Crypto Plug-in</a></h1>
<blockquote>
<p>This part has been moved to  <a href="https://wasmedge.org/docs/contribute/source/plugin/wasi_crypto">https://wasmedge.org/docs/contribute/source/plugin/wasi_crypto</a>. Please use our new docs.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="build-wasmedge-with-wasi-logging-plug-in"><a class="header" href="#build-wasmedge-with-wasi-logging-plug-in">Build WasmEdge With WASI-Logging Plug-in</a></h1>
<blockquote>
<p>This part has been moved to <a href="https://wasmedge.org/docs/contribute/source/plugin/wasi_logging">https://wasmedge.org/docs/contribute/source/plugin/wasi_logging</a>. Please use our new docs.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="build-wasmedge-with-wasi-nn-plug-in"><a class="header" href="#build-wasmedge-with-wasi-nn-plug-in">Build WasmEdge With WASI-NN Plug-in</a></h1>
<blockquote>
<p>This part has been moved to  <a href="https://wasmedge.org/docs/contribute/source/plugin/wasi_nn">https://wasmedge.org/docs/contribute/source/plugin/wasi_nn</a>. Please use our new docs.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="build-wasmedge-with-wasmedge-process-plug-in"><a class="header" href="#build-wasmedge-with-wasmedge-process-plug-in">Build WasmEdge With WasmEdge-Process Plug-in</a></h1>
<blockquote>
<p>This part has been moved to  <a href="https://wasmedge.org/docs/contribute/source/plugin/process">https://wasmedge.org/docs/contribute/source/plugin/process</a>. Please use our new docs.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="installer-guide"><a class="header" href="#installer-guide">Installer Guide</a></h1>
<blockquote>
<p>This part has been moved to <a href="https://wasmedge.org/docs/contribute/installer">https://wasmedge.org/docs/contribute/installer</a>. Please use our new docs.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="wasmedge-internal"><a class="header" href="#wasmedge-internal">WasmEdge Internal</a></h1>
<blockquote>
<p>This part has been moved to <a href="https://wasmedge.org/docs/contribute/internal">https://wasmedge.org/docs/contribute/internal</a>. Please use our new docs.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="wish-list"><a class="header" href="#wish-list">Wish list</a></h1>
<blockquote>
<p>This part has been moved to <a href="https://wasmedge.org/docs/contribute/overview#ideas-for-contributions">https://wasmedge.org/docs/contribute/overview#ideas-for-contributions</a>. Please use our new docs.</p>
</blockquote>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
